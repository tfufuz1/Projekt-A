
---

## 1. Allgemeine Vorbemerkungen zur Implementierung

- **Rust Edition:** Es wird die jeweils aktuell stabile Rust-Edition zum Zeitpunkt der Implementierung verwendet (aktuell Rust 2021, potenziell Rust 2024, falls bis dahin relevant).
- **Abhängigkeitsmanagement:** Cargo wird für das Abhängigkeitsmanagement verwendet. Versionen von Abhängigkeiten sollten sorgfältig gewählt und bei Bedarf über `Cargo.lock` fixiert werden, um reproduzierbare Builds sicherzustellen. Es wird empfohlen, `cargo update -p <crate_name>` für gezielte Updates zu verwenden.
- **Asynchrone Runtime:** Wo nicht anders spezifiziert (z.B. für GTK-spezifische Aufgaben), wird `tokio` als primäre asynchrone Runtime für I/O-gebundene Operationen und Nebenläufigkeit verwendet, insbesondere in der System- und UI-Schicht.
- **Fehlerbehandlung (Globale Konvention):** Die Verwendung von `thiserror` für spezifische Fehler-Enums pro Modul und die Weitergabe von Fehlern über `Result<T, E>` ist verbindlich. Panics sind strikt zu vermeiden, außer in Tests oder bei nachweislich nicht behebbaren internen Invariantenverletzungen mit aussagekräftiger Begründung. Die `source()`-Kette von Fehlern muss erhalten bleiben.
- **Logging (Globale Konvention):** Das `tracing`-Framework ist für strukturiertes, kontextbezogenes Logging verbindlich. Sensible Daten dürfen niemals geloggt werden.
- **Code-Formatierung und Linting:** `rustfmt` mit Projektstandardkonfiguration und `clippy` (mit `-D warnings`) sind bei jedem Commit/Push obligatorisch und werden durch CI erzwungen.
- **Dokumentation:** Umfassende `rustdoc`-Kommentare für alle öffentlichen APIs sind zwingend erforderlich.
- **Tests:** Unit-Tests (`#[cfg(test)] mod tests { ... }`) müssen parallel zur Implementierung geschrieben werden und eine hohe Codeabdeckung anstreben. Integrationstests (`tests/integration_test.rs`) sind für das Zusammenspiel von Modulen/Crates vorzusehen.

---

## 2. Ultra-Feinspezifikation: Kernschicht (Core Layer)

Die Kernschicht (`novade-core` Crate) enthält die absolut grundlegendsten, systemweit genutzten Elemente und hat keine Abhängigkeiten zu anderen Schichten von NovaDE.

### Modul: `core::types` (Fundamentale Datentypen)

**Zweck:** Definition grundlegender, universell einsetzbarer Datentypen für Geometrie, Farben und allgemeine Enumerationen. Diese Typen sind reine Datenstrukturen ohne komplexe Geschäftslogik.

**Designphilosophie:** Modularität, Wiederverwendbarkeit, minimale Kopplung. Generische Typen wo sinnvoll. Klare Trennung von Datenrepräsentation und Fehlerbehandlung.

**Abhängigkeiten:** `std`, `uuid` (für IDs in höheren Schichten, hier als Beispiel für einen Basistyp), `chrono` (für Zeitstempel, dito), `serde` (optional, mit `derive`-Feature, falls Serialisierung hier benötigt wird), `num-traits` (optional).

#### Untermodul: `core::types::geometry`

**Datei:** `src/types/geometry.rs`

##### 1. Struct: `Point<T>`

- **Zweck:** Repräsentiert einen Punkt im 2D-Raum.
- **Generische Parameter:** `T`
- **Felder:**
    - `pub x: T`
    - `pub y: T`
- **Ableitungen (Basis):** `#[derive(Debug, Clone, Copy, PartialEq, Default)]`
    - `Eq` und `Hash` nur, wenn `T: Eq` bzw. `T: Hash`.
- **`serde` (optional):** `#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]`
- **Invarianten:** Keine spezifischen, hängen von `T` ab.
- **Methoden:**
    - `pub const fn new(x: T, y: T) -> Self`
        - **Logik:** Erstellt einen neuen Punkt.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.x == x`, `self.y == y`.
    - `pub fn distance_squared(&self, other: &Point<T>) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + std::ops::Mul<Output = T>`
        - **Logik:** Berechnet das Quadrat der euklidischen Distanz: `(self.x - other.x)^2 + (self.y - other.y)^2`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das Quadrat der Distanz zurück.
    - `pub fn distance(&self, other: &Point<T>) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + std::ops::Mul<Output = T> + num_traits::Float` (oder spezifische Implementierung für `f32`, `f64`)
        - **Logik:** Berechnet die euklidische Distanz: `sqrt((self.x - other.x)^2 + (self.y - other.y)^2)`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt die Distanz zurück.
    - `pub fn manhattan_distance(&self, other: &Point<T>) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + num_traits::Signed`
        - **Logik:** Berechnet die Manhattan-Distanz: `abs(self.x - other.x) + abs(self.y - other.y)`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt die Manhattan-Distanz zurück.
- **Trait-Implementierungen (Zusätzlich):**
    - `impl<T: std::ops::Add<Output = T>> std::ops::Add for Point<T>`
    - `impl<T: std::ops::Sub<Output = T>> std::ops::Sub for Point<T>`
- **Assoziierte Konstanten:**
    - `pub const ZERO_I32: Point<i32> = Point { x: 0, y: 0 };`
    - `pub const ZERO_F32: Point<f32> = Point { x: 0.0, y: 0.0 };`
    - (Weitere für `u32`, `f64` etc.)

##### 2. Struct: `Size<T>`

- **Zweck:** Repräsentiert eine 2D-Dimension (Breite und Höhe).
- **Generische Parameter:** `T`
- **Felder:**
    - `pub width: T`
    - `pub height: T`
- **Ableitungen (Basis):** `#[derive(Debug, Clone, Copy, PartialEq, Default)]`
    - `Eq` und `Hash` nur, wenn `T: Eq` bzw. `T: Hash`.
- **`serde` (optional):** `#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]`
- **Invarianten:** Logisch sollten `width` und `height` nicht-negativ sein. Dies wird nicht durch den Typ erzwungen, aber durch `is_valid()` prüfbar gemacht.
- **Methoden:**
    - `pub const fn new(width: T, height: T) -> Self`
        - **Logik:** Erstellt eine neue Größe.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.width == width`, `self.height == height`.
    - `pub fn area(&self) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Mul<Output = T>`
        - **Logik:** Berechnet die Fläche: `self.width * self.height`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt die Fläche zurück.
    - `pub fn is_empty(&self) -> bool`
        - **Generische Constraints:** `T: PartialEq + num_traits::Zero`
        - **Logik:** Prüft, ob `self.width == T::zero()` oder `self.height == T::zero()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn leer, sonst `false`.
    - `pub fn is_valid(&self) -> bool`
        - **Generische Constraints:** `T: PartialOrd + num_traits::Zero`
        - **Logik:** Prüft, ob `self.width >= T::zero()` und `self.height >= T::zero()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn gültig, sonst `false`.
- **Assoziierte Konstanten:**
    - `pub const ZERO_I32: Size<i32> = Size { width: 0, height: 0 };`
    - `pub const ZERO_F32: Size<f32> = Size { width: 0.0, height: 0.0 };`
    - (Weitere für `u32`, `f64` etc.)

##### 3. Struct: `Rect<T>`

- **Zweck:** Repräsentiert ein 2D-Rechteck, definiert durch Ursprung (oben-links) und Größe.
- **Generische Parameter:** `T`
- **Felder:**
    - `pub origin: Point<T>`
    - `pub size: Size<T>`
- **Ableitungen (Basis):** `#[derive(Debug, Clone, Copy, PartialEq, Default)]`
    - `Eq` und `Hash` nur, wenn `T: Eq` bzw. `T: Hash`.
- **`serde` (optional):** `#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]`
- **Invarianten:** Logisch sollten `size.width` und `size.height` nicht-negativ sein. `is_valid()` prüft dies. Die Verantwortung für das Melden eines Fehlers bei Verwendung eines ungültigen `Rect` liegt beim Aufrufer.
- **Methoden:**
    - `pub const fn new(origin: Point<T>, size: Size<T>) -> Self`
        - **Logik:** Erstellt ein neues Rechteck.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.origin == origin`, `self.size == size`.
    - `pub fn from_coords(x: T, y: T, width: T, height: T) -> Self`
        - **Generische Constraints:** `T` muss die Constraints für `Point::new` und `Size::new` erfüllen.
        - **Logik:** Erstellt ein neues Rechteck aus Koordinaten und Dimensionen.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.origin.x == x`, `self.origin.y == y`, `self.size.width == width`, `self.size.height == height`.
    - `pub fn x(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.origin.x` zurück.
    - `pub fn y(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.origin.y` zurück.
    - `pub fn width(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.size.width` zurück.
    - `pub fn height(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.size.height` zurück.
    - `pub fn top(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.y()` zurück.
    - `pub fn left(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.x()` zurück.
    - `pub fn bottom(&self) -> T` (Constraints: `T: Copy + std::ops::Add<Output = T>`) - Gibt `self.y() + self.height()` zurück.
    - `pub fn right(&self) -> T` (Constraints: `T: Copy + std::ops::Add<Output = T>`) - Gibt `self.x() + self.width()` zurück.
    - `pub fn center(&self) -> Point<T>`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Div<Output = T> + num_traits::FromPrimitive` (für `T::from(2).unwrap()`).
        - **Logik:** Berechnet den Mittelpunkt: `Point::new(self.x() + self.width() / 2, self.y() + self.height() / 2)`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt den Mittelpunkt zurück.
    - `pub fn contains_point(&self, point: &Point<T>) -> bool`
        - **Generische Constraints:** `T: Copy + PartialOrd + std::ops::Add<Output = T>`
        - **Logik:** `point.x >= self.left() && point.x < self.right() && point.y >= self.top() && point.y < self.bottom()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn der Punkt enthalten ist, sonst `false`.
    - `pub fn intersects(&self, other: &Rect<T>) -> bool`
        - **Generische Constraints:** `T: Copy + PartialOrd + std::ops::Add<Output = T>`
        - **Logik:** `self.left() < other.right() && self.right() > other.left() && self.top() < other.bottom() && self.bottom() > other.top()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn sich die Rechtecke überschneiden, sonst `false`.
    - `pub fn intersection(&self, other: &Rect<T>) -> Option<Rect<T>>`
        - **Generische Constraints:** `T: Copy + Ord + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + num_traits::Zero`
        - **Logik:**
            1. `intersect_x = self.x().max(other.x())`
            2. `intersect_y = self.y().max(other.y())`
            3. `intersect_right = self.right().min(other.right())`
            4. `intersect_bottom = self.bottom().min(other.bottom())`
            5. Wenn `intersect_right > intersect_x` und `intersect_bottom > intersect_y`:
                - `intersect_width = intersect_right - intersect_x`
                - `intersect_height = intersect_bottom - intersect_y`
                - `Some(Rect::new(Point::new(intersect_x, intersect_y), Size::new(intersect_width, intersect_height)))`
            6. Sonst: `None`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das Schnittrechteck oder `None` zurück.
    - `pub fn union(&self, other: &Rect<T>) -> Rect<T>`
        - **Generische Constraints:** `T: Copy + Ord + std::ops::Add<Output = T> + std::ops::Sub<Output = T>`
        - **Logik:**
            1. `union_x = self.x().min(other.x())`
            2. `union_y = self.y().min(other.y())`
            3. `union_right = self.right().max(other.right())`
            4. `union_bottom = self.bottom().max(other.bottom())`
            5. `union_width = union_right - union_x`
            6. `union_height = union_bottom - union_y`
            7. `Rect::new(Point::new(union_x, union_y), Size::new(union_width, union_height))`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das umschließende Rechteck zurück.
    - `pub fn translated(&self, dx: T, dy: T) -> Rect<T>`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T>`
        - **Logik:** `Rect::new(Point::new(self.origin.x + dx, self.origin.y + dy), self.size)`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das verschobene Rechteck zurück.
    - `pub fn scaled(&self, sx: T, sy: T) -> Rect<T>` (Skaliert Ursprung und Größe)
        - **Generische Constraints:** `T: Copy + std::ops::Mul<Output = T>`
        - **Logik:** `Rect::new(Point::new(self.origin.x * sx, self.origin.y * sy), Size::new(self.size.width * sx, self.size.height * sy))`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das skalierte Rechteck zurück.
    - `pub fn is_valid(&self) -> bool`
        - **Generische Constraints:** `T` muss `Size::is_valid` unterstützen.
        - **Logik:** Ruft `self.size.is_valid()` auf.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn `size` gültig ist, sonst `false`.
- **Assoziierte Konstanten:**
    - `pub const ZERO_I32: Rect<i32> = Rect { origin: Point::ZERO_I32, size: Size::ZERO_I32 };`
    - `pub const ZERO_F32: Rect<f32> = Rect { origin: Point::ZERO_F32, size: Size::ZERO_F32 };`

##### 4. Struct `RectInt` (Spezifische Implementierung von `Rect<i32/u32>`)

- **Zweck:** Ein achsenparalleles Rechteck mit ganzzahligen `i32` Koordinaten und `u32` Dimensionen. Dies ist oft praktisch für Pixel-basierte Operationen und Fenstergeometrie.
- **Felder:**
    - `pub x: i32`
    - `pub y: i32`
    - `pub width: u32`
    - `pub height: u32`
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize)]` (Serde ist hier oft nützlich)
- **Invarianten:** `width >= 0`, `height >= 0` (durch `u32` Typ erzwungen).
- **Methoden (Beispiele, basierend auf):**
    - `pub const fn new(x: i32, y: i32, width: u32, height: u32) -> Self`
    - `pub fn from_points(p1: Point<i32>, p2: Point<i32>) -> Self`
        - **Logik:** `x = p1.x.min(p2.x)`, `y = p1.y.min(p2.y)`, `width = (p1.x - p2.x).abs() as u32`, `height = (p1.y - p2.y).abs() as u32`.
    - `pub fn top_left(&self) -> Point<i32>` - Gibt `Point::new(self.x, self.y)` zurück.
    - `pub fn size(&self) -> Size<u32>` - Gibt `Size::new(self.width, self.height)` zurück.
    - `pub fn right(&self) -> i32` - Gibt `self.x.saturating_add(self.width as i32)` zurück.
    - `pub fn bottom(&self) -> i32` - Gibt `self.y.saturating_add(self.height as i32)` zurück.
    - `pub fn contains_point(&self, p_x: i32, p_y: i32) -> bool` - `p_x >= self.x && p_x < self.right() && p_y >= self.y && p_y < self.bottom()`.
    - `pub fn intersects(&self, other: RectInt) -> bool` - `self.x < other.right() && self.right() > other.x && self.y < other.bottom() && self.bottom() > other.y`.
    - `pub fn intersection(&self, other: RectInt) -> Option<RectInt>` (Logik wie bei `Rect<T>`)
    - `pub fn union(&self, other: RectInt) -> RectInt` (Logik wie bei `Rect<T>`)
    - `pub fn translate(&self, dx: i32, dy: i32) -> RectInt` - `RectInt::new(self.x.saturating_add(dx), self.y.saturating_add(dy), self.width, self.height)`.
    - `pub fn inflate(&self, dw: i32, dh: i32) -> RectInt`
        - **Logik:** `new_x = self.x.saturating_sub(dw)`, `new_y = self.y.saturating_sub(dh)`. `new_width_signed = (self.width as i64).saturating_add(2 * dw as i64)`. `new_height_signed = (self.height as i64).saturating_add(2 * dh as i64)`. `RectInt::new(new_x, new_y, new_width_signed.max(0) as u32, new_height_signed.max(0) as u32)`.
    - `pub fn is_empty(&self) -> bool` - `self.width == 0 || self.height == 0`.

#### Untermodul: `core::types::color`

**Datei:** `src/types/color.rs`

##### 1. Struct: `Color` (RGBA)

- **Zweck:** Repräsentiert eine Farbe mit Rot-, Grün-, Blau- und Alpha-Komponenten.
- **Felder:**
    - `pub r: f32` (Bereich `[0.0, 1.0]`)
    - `pub g: f32` (Bereich `[0.0, 1.0]`)
    - `pub b: f32` (Bereich `[0.0, 1.0]`)
    - `pub a: f32` (Bereich `[0.0, 1.0]`)
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq)]`
- **Invarianten:** Alle Komponenten `r, g, b, a` müssen im Bereich `[0.0, 1.0]` liegen. Konstruktoren und Methoden klemmen Werte entsprechend.
- **Methoden:**
    - `pub fn new(r: f32, g: f32, b: f32, a: f32) -> Self`
        - **Logik:** `Self { r: r.clamp(0.0, 1.0), g: g.clamp(0.0, 1.0), b: b.clamp(0.0, 1.0), a: a.clamp(0.0, 1.0) }`.
        - **Nachbedingungen:** Alle Felder sind im Bereich `[0.0, 1.0]`.
    - `pub fn from_rgba8(r_u8: u8, g_u8: u8, b_u8: u8, a_u8: u8) -> Self`
        - **Logik:** `Self::new(r_u8 as f32 / 255.0, g_u8 as f32 / 255.0, b_u8 as f32 / 255.0, a_u8 as f32 / 255.0)`.
    - `pub fn to_rgba8(&self) -> (u8, u8, u8, u8)`
        - **Logik:** `((self.r * 255.0).round() as u8, (self.g * 255.0).round() as u8, (self.b * 255.0).round() as u8, (self.a * 255.0).round() as u8)`.
    - `pub fn with_alpha(&self, alpha: f32) -> Self`
        - **Logik:** `Self::new(self.r, self.g, self.b, alpha)`.
    - `pub fn blend(&self, background: &Color) -> Color` (Source-Over Blending)
        - **Logik:**
            1. `fg_a = self.a`
            2. `bg_a = background.a`
            3. `out_a = fg_a + bg_a * (1.0 - fg_a)`
            4. Wenn `out_a == 0.0`, gib `Color::TRANSPARENT` zurück.
            5. `out_r = (self.r * fg_a + background.r * bg_a * (1.0 - fg_a)) / out_a`
            6. `out_g = (self.g * fg_a + background.g * bg_a * (1.0 - fg_a)) / out_a`
            7. `out_b = (self.b * fg_a + background.b * bg_a * (1.0 - fg_a)) / out_a`
            8. `Color::new(out_r, out_g, out_b, out_a)`
    - `pub fn lighten(&self, amount: f32) -> Color`
        - **Logik:** `amount_clamped = amount.clamp(0.0, 1.0)`. `Color::new(self.r + (1.0 - self.r) * amount_clamped, self.g + (1.0 - self.g) * amount_clamped, self.b + (1.0 - self.b) * amount_clamped, self.a)`
    - `pub fn darken(&self, amount: f32) -> Color`
        - **Logik:** `amount_clamped = amount.clamp(0.0, 1.0)`. `Color::new(self.r * (1.0 - amount_clamped), self.g * (1.0 - amount_clamped), self.b * (1.0 - amount_clamped), self.a)`
    - `pub fn interpolate(&self, other: Color, t: f32) -> Color`
        - **Logik:** `t_clamped = t.clamp(0.0, 1.0)`. `r = self.r * (1.0 - t_clamped) + other.r * t_clamped` `g = self.g * (1.0 - t_clamped) + other.g * t_clamped` `b = self.b * (1.0 - t_clamped) + other.b * t_clamped` `a = self.a * (1.0 - t_clamped) + other.a * t_clamped` `Color::new(r,g,b,a)`
    - `pub fn from_hex(hex_string: &str) -> Result<Self, ColorParseError>`
        - **Logik:**
            1. Entferne optionales `#`-Präfix.
            2. Validiere Länge (3, 4, 6, 8 Zeichen). Bei ungültiger Länge: `Err(ColorParseError::InvalidHexLength(hex_string.to_string()))`.
            3. Parse Hex-Zeichen in `u8` Komponenten. Bei ungültigen Zeichen: `Err(ColorParseError::InvalidHexDigit(...))`.
                - `#RGB`: `R`, `G`, `B` (Alpha = FF) -> `RR`, `GG`, `BB`
                - `#RGBA`: `R`, `G`, `B`, `A` -> `RR`, `GG`, `BB`, `AA`
                - `#RRGGBB`: `RR`, `GG`, `BB` (Alpha = FF)
                - `#RRGGBBAA`: `RR`, `GG`, `BB`, `AA`
            4. Konvertiere `u8` zu `f32` (`/ 255.0`).
            5. Erzeuge `Color` via `Color::new()`.
            6. Bei Erfolg `Ok(Self)`.
        - **Fehler:** `ColorParseError` (siehe `core::errors`)
    - `pub fn to_hex_string(&self, include_alpha: bool) -> String`
        - **Logik:** Konvertiere `r,g,b,a` zu `u8`. Formatiere als Hex-String.
            - Wenn `include_alpha` oder `self.a < 1.0` (oder immer Alpha für Konsistenz): `format!("#{:02X}{:02X}{:02X}{:02X}", r_u8, g_u8, b_u8, a_u8)`
            - Sonst: `format!("#{:02X}{:02X}{:02X}", r_u8, g_u8, b_u8)`
- **Trait-Implementierungen (Zusätzlich):**
    - `impl Default for Color { fn default() -> Self { Color::TRANSPARENT } }`
- **Assoziierte Konstanten:**
    - `pub const TRANSPARENT: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };`
    - `pub const BLACK: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 };`
    - `pub const WHITE: Color = Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };`
    - (Weitere wie `RED`, `GREEN`, `BLUE`)
- **Serialisierung (`serde`):**
    - Soll als Hex-String serialisiert/deserialisiert werden (siehe).
    - `impl Serialize for Color { ... serializer.serialize_str(&self.to_hex_string(true)) ... }`
    - `impl<'de> Deserialize<'de> for Color { ... Color::from_hex(&s).map_err(serde::de::Error::custom) ... }`

#### Untermodul: `core::types::enums`

**Datei:** `src/types/enums.rs`

##### 1. Enum: `Orientation`

- **Zweck:** Repräsentiert eine horizontale oder vertikale Ausrichtung.
- **Varianten:**
    - `Horizontal`
    - `Vertical`
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]`
- **Methoden:**
    - `pub fn toggle(&self) -> Self`
        - **Logik:** `match self { Orientation::Horizontal => Orientation::Vertical, Orientation::Vertical => Orientation::Horizontal }`.
- **Trait-Implementierungen (Zusätzlich):**
    - `impl Default for Orientation { fn default() -> Self { Orientation::Horizontal } }`

#### Untermodul: `core::types::ids`

Datei: src/types/ids.rs

(Obwohl in der Gesamtspezifikation WorkspaceId, WindowIdentifier etc. in core::types erwähnt werden, gehören sie semantisch eher in die Domänenschicht oder sind Newtypes um primitive IDs. Hier ein Beispiel für generische ID-Typen, falls benötigt.)

##### 1. Struct: `GenericId` (Beispiel)

- **Zweck:** Ein typsicherer Wrapper um `uuid::Uuid` für generische Entitäts-IDs.
- **Felder:** `pub id: uuid::Uuid`
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]`
- **Methoden:**
    - `pub fnnew() -> Self { Self { id: Uuid::new_v4() } }`
    - `pub fnfrom_uuid(uuid: Uuid) -> Self { Self { id: uuid } }`
    - `pub fnas_uuid(&self) -> &Uuid { &self.id }`
- **Trait-Implementierungen:** `impl Default for GenericId { fn default() -> Self { Self::new() } }`

#### Moduldeklaration `core::types::mod.rs`

Rust

```
// src/types/mod.rs

pub mod color;
pub mod enums;
pub mod geometry;
// pub mod ids; // Falls vorhanden

pub use color::Color;
pub use enums::Orientation;
pub use geometry::{Point, Rect, Size, RectInt};
// pub use ids::GenericId;
```

#### Implementierungsschritte `core::types`

1. **Verzeichnis- und Dateierstellung:**
    - `core/src/types/mod.rs`
    - `core/src/types/geometry.rs`
    - `core/src/types/color.rs`
    - `core/src/types/enums.rs`
    - (`core/src/types/ids.rs` optional)
2. **Implementierung `geometry.rs`:**
    - `Point<T>`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `distance_squared`, `distance`, `manhattan_distance`), Trait-Impls.
    - `Size<T>`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `area`, `is_empty`, `is_valid`).
    - `Rect<T>`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `from_coords`, Zugriffsmethoden, `center`, `contains_point`, `intersects`, `intersection`, `union`, `translated`, `scaled`, `is_valid`).
    - `RectInt`: Struktur, Ableitungen, Methoden wie spezifiziert.
    - Hinzufügen von `use num_traits::{Float, Signed, Zero};` und `use serde::{Serialize, Deserialize};` (letzteres mit `cfg_attr`).
3. **Implementierung `color.rs`:**
    - `Color`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `from_rgba8`, `to_rgba8`, `with_alpha`, `blend`, `lighten`, `darken`, `interpolate`, `from_hex`, `to_hex_string`), `Default`-Impl, `Serialize`/`Deserialize`-Impls.
    - Benötigt `use crate::core::errors::ColorParseError;` (siehe `core::errors`) und `use serde::{Serializer, Deserializer, de::Error as SerdeError};`.
4. **Implementierung `enums.rs`:**
    - `Orientation`: Enum, Ableitungen, `toggle`-Methode, `Default`-Impl.
5. **Implementierung `ids.rs` (optional):**
    - `GenericId` (oder spezifischere ID-Typen, falls hier sinnvoll).
6. **Moduldeklaration `types/mod.rs`:** `pub mod ...` und `pub use ...` für alle definierten Typen.
7. **Aktualisierung `core/src/lib.rs`:** `pub mod types;`
8. **Unit-Tests:**
    - Für jeden Typ und jede Methode Testfälle erstellen.
    - `Point<T>`: Teste `new`, Distanzberechnungen für `i32` und `f32`.
    - `Size<T>`: Teste `new`, `area`, `is_empty`, `is_valid` für `i32`, `u32`, `f32`.
    - `Rect<T>`: Teste Konstruktoren, Zugriffsmethoden, `center`, `contains_point`, `intersects`, `intersection`, `union`.
    - `RectInt`: Teste alle Methoden, insbesondere `inflate` mit positiven/negativen Werten.
    - `Color`: Teste `new` (Klemmung), `from_rgba8`, `to_rgba8`, `blend`, `lighten`, `darken`, `from_hex` (alle Formate, Fehlerfälle), `to_hex_string`, `Default`.
    - `Orientation`: Teste `toggle`, `Default`.
    - Überprüfe `serde`-Implementierungen (Serialisierung zu erwartetem JSON/String, Deserialisierung).
9. **Dokumentation (`rustdoc`):**
    - Umfassende Kommentare für alle öffentlichen Elemente (Module, Structs, Enums, Felder, Methoden, Konstanten).
    - Erklärung von Invarianten, Wertebereichen, Vor-/Nachbedingungen.
    - `# Examples` für komplexere Methoden oder Typverwendungen.

---

### Modul: `core::errors` (Fehlerbehandlung)

**Zweck:** Definition einer robusten und konsistenten Fehlerbehandlungsstrategie und grundlegender Fehlertypen für die Kernschicht.

**Designphilosophie:** Verwendung von `thiserror` für spezifische Fehler-Enums pro Modul. Klare Trennung zwischen `Result<T, E>` für behebbare Fehler und `panic!` für nicht behebbare Programmierfehler. Kontextreiche Fehlermeldungen.

**Abhängigkeiten:** `std`, `thiserror`, `uuid` (für IDs in Fehlermeldungen), `std::path::PathBuf`.

**Datei:** `src/errors.rs`

##### 1. Enum: `CoreError` (Basis-Fehlertyp der Kernschicht)

- **Zweck:** Dient als primäre Schnittstelle für allgemeine Fehler, die von öffentlichen Funktionen der Kernschicht propagiert werden können, oder für Fehler, die keinem spezifischen Submodul zugeordnet werden können.
- **Ableitungen:** `#[derive(Debug, thiserror::Error)]`
- **Varianten:**
    - `#[error("Core component '{component}' failed to initialize")]` `InitializationFailed { component: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
    - `#[error("I/O error accessing path '{path}': {source}")]` `Io { path: PathBuf, #[source] source: std::io::Error }`
        - **Publisher:** Jede Kernfunktion, die direkt I/O-Operationen durchführt.
        - **Subscriber:** Aufrufer, die diese I/O-Fehler behandeln müssen.
    - `#[error("Serialization error: {description}")]` (für generische Serialisierungsfehler, spezifischere sollten eigene Typen haben) `Serialization { description: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
    - `#[error("Deserialization error: {description}")]` `Deserialization { description: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
    - `#[error("Invalid identifier provided: '{invalid_id}'")]` `InvalidId { invalid_id: String }`
    - `#[error("Resource not found: {resource_description}")]` `NotFound { resource_description: String }`
    - `#[error("Configuration error (core level): {message}")]` `CoreConfigError { message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }` (Spezifischere `ConfigError` in `core::config::errors`)
    - `#[error("An internal logic error occurred: {0}")]` `InternalError(String)` (Sollte selten verwendet werden; spezifischere Fehler sind vorzuziehen)

##### 2. Enum: `ColorParseError` (Spezifischer Fehler für `Color::from_hex`)

- **Zweck:** Repräsentiert Fehler, die beim Parsen eines Hex-Strings zu einer `Color` auftreten können.
- **Datei:** `src/types/color.rs` (oder `src/errors/color_errors.rs` und re-exportiert) – hier in `errors.rs` für Zentralität der Fehler.
- **Ableitungen:** `#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]`
- **Varianten:**
    - `#[error("Invalid hex color string format for '{0}'. Expected formats: #RGB, #RGBA, #RRGGBB, #RRGGBBAA.")]` `InvalidHexFormat(String)`
    - `#[error("Invalid hex digit in string '{0}': {source}")]` `InvalidHexDigit(String, #[source] std::num::ParseIntError)`
    - `#[error("Invalid hex color string length for '{0}'. Expected 3, 4, 6, or 8 characters after '#'.")]` `InvalidHexLength(String)`

##### Implementierungsschritte `core::errors`

1. **Abhängigkeiten in `core/Cargo.toml` sicherstellen:**
    
    Ini, TOML
    
    ```
    [dependencies]
    thiserror = "1.0"
    uuid = { version = "1.0", features = ["v4", "serde"] } # serde optional für Fehler
    chrono = { version = "0.4", features = ["serde"] } # serde optional
    # num-traits, serde, toml, once_cell je nach Bedarf anderer Module
    ```
    
2. **Datei `core/src/errors.rs` erstellen/modifizieren:**
    - `CoreError`-Enum mit allen Varianten, `#[error(...)]`-Attributen und `#[source]`-Feldern definieren.
    - `ColorParseError`-Enum definieren.
3. **Öffentliche API und Interne Schnittstellen:**
    - Alle Enums und ihre Varianten sind `pub`.
    - Die `source()`-Methode wird von `thiserror` bereitgestellt.
4. **Unit-Tests (`core/src/errors.rs` -> `#[cfg(test)] mod tests`):**
    - Für jede Fehlervariante testen, ob die `Display`-Implementierung (via `#[error]`) die erwartete Nachricht erzeugt.
    - Für Varianten mit `#[source]`, testen, ob `source()` den zugrunde liegenden Fehler korrekt zurückgibt.
        - Beispiel für `CoreError::Io`:
            
            Rust
            
            ```
            let original_io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "file not found");
            let core_io_err = CoreError::Io { path: "test.txt".into(), source: original_io_err };
            assert!(core_io_err.source().is_some());
            // Ggf. den Typ des source-Fehlers prüfen.
            ```
            
    - Testen der `ColorParseError`-Varianten.
5. **Aktualisierung `core/src/lib.rs`:** `pub mod errors;`
    - `pub use errors::{CoreError, ColorParseError};` (oder nur `CoreError` und `ColorParseError` wird über `crate::types::Color::from_hex` verwendet)

---

### Modul: `core::logging` (Logging-Infrastruktur)

**Zweck:** Initialisierung und Konfiguration des globalen `tracing`-Frameworks.

**Designphilosophie:** Bereitstellung einer einfachen Initialisierungsfunktion. Die eigentliche Verwendung der `tracing::{trace, debug, info, warn, error}` Makros erfolgt direkt im Code der anderen Module/Schichten.

**Abhängigkeiten:** `tracing`, `tracing-subscriber` (mit Features wie `fmt`, `json`, `env-filter`).

**Datei:** `src/logging.rs`

##### 1. Enum: `LogFormat`

- **Zweck:** Definiert die möglichen Ausgabeformate für das Logging.
- **Varianten:**
    - `PlainTextDevelopment`
    - `JsonProduction`
- **Ableitungen:** `#[derive(Debug, Clone, Copy)]`

##### 2. Enum: `LoggingError`

- **Zweck:** Fehler, die bei der Initialisierung des Loggings auftreten können.
- **Ableitungen:** `#[derive(Debug, thiserror::Error)]`
- **Varianten:**
    - `#[error("Failed to set global default tracing subscriber: {0}")]` `SetGlobalDefaultError(String)` (Kapselt den Fehler von `tracing::subscriber::set_global_default`)
    - `#[error("Failed to initialize tracing subscriber: {0}")]` `InitializationError(String)`

##### 3. Funktion: `initialize_logging`

- **Signatur:** `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: LogFormat) -> Result<(), LoggingError>`
- **Parameter:**
    - `level_filter: tracing::LevelFilter`: Der minimale Log-Level, der global gelten soll.
    - `format: LogFormat`: Das gewünschte Ausgabeformat.
- **Rückgabe:** `Result<(), LoggingError>`
- **Logik:**
    1. Erstelle einen `tracing_subscriber::fmt::Builder` oder einen `tracing_subscriber::Registry` mit Layern.
    2. Konfiguriere den Subscriber basierend auf `format`:
        - `LogFormat::PlainTextDevelopment`:
            - Verwende `tracing_subscriber::fmt::layer()`
            - `with_ansi(true)` (falls Terminal es unterstützt, kann über Feature-Flag gesteuert werden)
            - `with_target(true)` (Modulpfad anzeigen)
            - `with_file(true)`
            - `with_line_number(true)`
            - `with_level(true)`
            - `with_filter(level_filter)`
        - `LogFormat::JsonProduction`:
            - Verwende `tracing_subscriber::fmt::layer().json()`
            - `with_current_span(true)`
            - `with_span_list(true)`
            - `with_filter(level_filter)`
            - Alternativ: `tracing_bunyan_formatter` für spezifisches Bunyan-JSON-Format.
    3. Optional: Füge einen `EnvFilter` hinzu, um Log-Levels zur Laufzeit über `RUST_LOG` feingranularer zu steuern, zusätzlich zum globalen `level_filter`. `let env_filter = tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| tracing_subscriber::EnvFilter::new(level_filter.to_string()));` Der `level_filter` Parameter dient dann als Fallback, wenn `RUST_LOG` nicht gesetzt ist. Der Layer wird dann mit `with_filter(env_filter)` konfiguriert.
    4. Baue den Subscriber und versuche, ihn als globalen Default zu setzen: `tracing::subscriber::set_global_default(subscriber).map_err(|e| LoggingError::SetGlobalDefaultError(e.to_string()))`.
- **Fehlerbehandlung:** Gibt `LoggingError` zurück, falls die Initialisierung fehlschlägt.

##### Implementierungsschritte `core::logging`

1. **Abhängigkeiten in `core/Cargo.toml`:**
    
    Ini, TOML
    
    ```
    tracing = "0.1"
    tracing-subscriber = { version = "0.3", features = ["fmt", "json", "env-filter"] }
    # Ggf. tracing-bunyan-formatter
    ```
    
2. **Datei `core/src/logging.rs` erstellen:**
    - `LogFormat` Enum definieren.
    - `LoggingError` Enum mit `thiserror` definieren.
    - `initialize_logging` Funktion implementieren.
3. **Unit-Tests (konzeptionell, da `set_global_default` global ist):**
    - Testen, ob die Funktion mit verschiedenen Formaten und Leveln ohne Panic durchläuft. Das tatsächliche Setzen des globalen Subscribers ist schwer isoliert zu testen. Man könnte prüfen, ob der Builder korrekt konfiguriert wird.
4. **Aktualisierung `core/src/lib.rs`:** `pub mod logging;`
    - `pub use logging::{initialize_logging, LogFormat, LoggingError};`

---

### Modul: `core::config` (Konfigurationsprimitive)

**Zweck:** Definition von Mechanismen zum Laden, Parsen und Zugreifen auf Basiskonfigurationen.

**Designphilosophie:** Einfachheit, Robustheit. Verwendung von TOML als Konfigurationsformat und `serde` für (De-)Serialisierung.

**Abhängigkeiten:** `serde` (mit `derive`), `toml`, `once_cell` (für globalen Zugriff).

**Datei:** `src/config/mod.rs` (kann `errors.rs`, `types.rs`, `loader.rs` enthalten)

#### Untermodul: `core::config::errors`

**Datei:** `src/config/errors.rs`

##### 1. Enum: `ConfigError`

- **Zweck:** Fehler, die beim Laden oder Verarbeiten von Konfigurationen auftreten können.
- **Ableitungen:** `#[derive(Debug, thiserror::Error)]`
- **Varianten:**
    - `#[error("Failed to read configuration file from path '{path}': {source}")]` `FileReadError { path: PathBuf, #[source] source: std::io::Error }`
    - `#[error("Failed to deserialize configuration from path '{path}': {source}")]` `DeserializationError { path: PathBuf, #[source] source: toml::de::Error }`
    - `#[error("No configuration file found. Checked paths: {checked_paths:?}")]` `NoConfigurationFileFound { checked_paths: Vec<PathBuf> }`
    - `#[error("Configuration already initialized.")]` `AlreadyInitializedError`
    - `#[error("Configuration not yet initialized.")]` `NotInitializedError`
    - `#[error("Invalid configuration value for key '{key}': {reason}")]` (Falls Validierung hier stattfindet) `InvalidValueError { key: String, reason: String }`

#### Untermodul: `core::config::types`

**Datei:** `src/config/types.rs`

##### 1. Struct: `CoreConfig` (Beispielstruktur)

- **Zweck:** Hält alle spezifischen Konfigurationen der Kernschicht. Muss an die tatsächlichen Bedürfnisse angepasst werden.
- **Ableitungen:** `#[derive(Debug, Clone, serde::Deserialize, Default)]`
- **Attribute:** `#[serde(deny_unknown_fields)]` auf der Struktur.
- **Felder (Beispiele):**
    
    Rust
    
    ```
    use serde::Deserialize;
    use std::path::PathBuf;
    
    #[derive(Debug, Clone, Deserialize, Default)]
    #[serde(rename_all = "kebab-case")] // TOML verwendet oft kebab-case
    pub enum LogLevelConfig { // Muss auch in core::logging bekannt sein oder hierhin verschoben werden
        Trace,
        Debug,
        #[default]
        Info,
        Warn,
        Error,
    }
    
    #[derive(Debug, Clone, Deserialize)]
    #[serde(deny_unknown_fields)]
    pub struct CoreConfig {
        #[serde(default = "default_log_level")]
        pub log_level: LogLevelConfig,
        #[serde(default = "default_some_path")]
        pub some_critical_path: PathBuf,
        #[serde(default)] // Verwendet FeatureFlags::default()
        pub feature_flags: FeatureFlags,
    }
    
    // Default-Funktionen müssen den korrekten Typ zurückgeben
    fn default_log_level() -> LogLevelConfig { LogLevelConfig::default() }
    fn default_some_path() -> PathBuf { PathBuf::from("/usr/share/novade/default_resource") }
    
    impl Default for CoreConfig {
        fn default() -> Self {
            Self {
                log_level: default_log_level(),
                some_critical_path: default_some_path(),
                feature_flags: FeatureFlags::default(),
            }
        }
    }
    
    #[derive(Debug, Clone, Deserialize, Default)]
    #[serde(deny_unknown_fields)]
    pub struct FeatureFlags {
        #[serde(default)] // bool standardmäßig auf false
        pub enable_alpha_feature: bool,
        #[serde(default = "default_beta_timeout_ms")]
        pub beta_feature_timeout_ms: u64,
    }
    
    fn default_beta_timeout_ms() -> u64 { 1000 }
    ```
    
- **Validierung:** Grundlegende Validierung durch Typen und `serde`-Attribute. Komplexere Validierung kann nach Deserialisierung erfolgen (z.B. `TryFrom<RawCoreConfig>` oder `validate()`-Methode), die dann `ConfigError::InvalidValueError` zurückgibt.

#### Untermodul: `core::config::loader`

**Datei:** `src/config/loader.rs`

##### 1. Funktion: `load_core_config`

- **Signatur:** `pub fn load_core_config(config_paths: &[PathBuf]) -> Result<CoreConfig, ConfigError>` (Nimmt eine Liste von Pfaden, um sie der Reihe nach zu prüfen).
- **Logik:**
    1. Iteriere über `config_paths`.
    2. Für jeden Pfad:
        - Prüfe, ob die Datei existiert.
        - Wenn ja, versuche sie zu lesen: `std::fs::read_to_string(path).map_err(|e| ConfigError::FileReadError { path: path.to_path_buf(), source: e })?`.
        - Versuche, den Inhalt zu deserialisieren: `toml::from_str(&content_str).map_err(|e| ConfigError::DeserializationError { path: path.to_path_buf(), source: e })?`.
        - Wenn erfolgreich, gib `Ok(config)` zurück.
    3. Wenn keine Datei gefunden oder erfolgreich geparst wurde, gib `Err(ConfigError::NoConfigurationFileFound { checked_paths: config_paths.to_vec() })` zurück.

#### Statischer Zugriff (`core::config::mod.rs` oder `core::config::global.rs`)

Rust

```
// In core::config::mod.rs oder einem neuen core::config::global.rs
use super::types::CoreConfig;
use super::errors::ConfigError;
use once_cell::sync::OnceCell;
use std::path::PathBuf;

static CORE_CONFIG: OnceCell<CoreConfig> = OnceCell::new();

/// Initialisiert die globale Core-Konfiguration.
/// Darf nur einmal während des Anwendungsstarts aufgerufen werden.
pub fn initialize_global_core_config(config: CoreConfig) -> Result<(), ConfigError> {
    CORE_CONFIG.set(config).map_err(|_| ConfigError::AlreadyInitializedError)
}

/// Gibt eine Referenz auf die global initialisierte Core-Konfiguration zurück.
///
/// # Panics
///
/// Paniert, wenn `initialize_global_core_config()` nicht zuvor erfolgreich aufgerufen wurde.
/// Dies signalisiert einen schwerwiegenden Programmierfehler in der Anwendungsinitialisierung.
pub fn get_global_core_config() -> &'static CoreConfig {
    CORE_CONFIG.get().expect("CoreConfig wurde nicht initialisiert. initialize_global_core_config() muss zuerst aufgerufen werden.")
}

/// Lädt die Konfiguration von den angegebenen Pfaden und initialisiert sie global.
/// Dies ist eine Bequemlichkeitsfunktion.
pub fn load_and_initialize_global_config(config_paths: &[PathBuf]) -> Result<(), ConfigError> {
    use super::loader::load_core_config; // Pfad anpassen
    let config = load_core_config(config_paths)?;
    initialize_global_core_config(config)
}
```

##### Implementierungsschritte `core::config`

1. **Abhängigkeiten in `core/Cargo.toml`:**
    
    Ini, TOML
    
    ```
    serde = { version = "1.0", features = ["derive"] }
    toml = "0.8" # Aktuelle Version prüfen
    once_cell = "1.19" # Aktuelle Version prüfen
    ```
    
2. **Verzeichnisstruktur erstellen:** `core/src/config/`, darin `mod.rs`, `errors.rs`, `types.rs`, `loader.rs`, `global.rs` (optional).
3. **`errors.rs`:** `ConfigError` Enum implementieren.
4. **`types.rs`:** `CoreConfig` (und ggf. untergeordnete Strukturen wie `LogLevelConfig`, `FeatureFlags`) mit `serde`-Attributen und `Default`-Implementierungen definieren. Default-Funktionen erstellen.
5. **`loader.rs`:** `load_core_config` Funktion implementieren.
6. **`global.rs` (oder `mod.rs`):** Statische `CORE_CONFIG` Variable mit `OnceCell`, `initialize_global_core_config`, `get_global_core_config` und `load_and_initialize_global_config` implementieren.
7. **`config/mod.rs`:** Module deklarieren und öffentliche Typen/Funktionen re-exportieren.
    
    Rust
    
    ```
    pub mod errors;
    pub mod types;
    pub mod loader;
    pub mod global; // oder Inhalt direkt hier
    
    pub use errors::ConfigError;
    pub use types::{CoreConfig, LogLevelConfig, FeatureFlags}; // Beispiele
    pub use loader::load_core_config;
    pub use global::{initialize_global_core_config, get_global_core_config, load_and_initialize_global_config};
    ```
    
8. **Aktualisierung `core/src/lib.rs`:** `pub mod config;`
9. **Unit-Tests:**
    - `ConfigError`: Teste Display-Implementierungen.
    - `CoreConfig`: Teste `Default`-Implementierung und `serde` (De-)Serialisierung mit Beispieldaten (gültiges TOML, TOML mit fehlenden Feldern, TOML mit unbekannten Feldern bei `deny_unknown_fields`).
    - `load_core_config`:
        - Test mit gültiger Konfigurationsdatei.
        - Test mit mehreren Pfaden, wobei die erste gefundene Datei verwendet wird.
        - Test, wenn keine Datei gefunden wird (`NoConfigurationFileFound`).
        - Test mit nicht lesbarer Datei (`FileReadError`).
        - Test mit fehlerhafter TOML-Syntax (`DeserializationError`).
    - Globaler Zugriff: Teste `initialize_global_core_config` (Erfolg, Fehler bei Mehrfachinitialisierung), `get_global_core_config` (Erfolg nach Init, Panic vor Init).

---

### Modul: `core::utils` (Allgemeine Hilfsfunktionen)

**Zweck:** Beherbergt allgemeine, in sich geschlossene Hilfsfunktionen, die nicht in spezifischere Module passen.

**Designphilosophie:** Einfachheit, Reinheit (wo möglich), keine Abhängigkeiten zu anderen Kernschicht-Modulen außer `core::errors` (für Utility-spezifische Fehler).

**Abhängigkeiten:** `std`, `thiserror`.

**Struktur:** Dieses Modul kann in Submodule unterteilt werden, falls viele Utilities entstehen (z.B. `core::utils::string`, `core::utils::math`). Für den Anfang eine einzelne `src/utils.rs`.

**Datei:** `src/utils.rs` (und ggf. `src/utils/errors.rs`)

#### Beispiel: Utility-Submodul `core::utils::path_utils`

**Datei:** `src/utils/path_utils.rs`

##### 1. Enum: `PathUtilError`

- **Ableitungen:** `#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]`
- **Varianten:**
    - `#[error("Path normalization failed: {0}")]` `NormalizationFailed(String)`

##### 2. Funktion: `normalize_path_robustly` (Beispiel für ein komplexeres Utility)

- **Signatur:** `pub fn normalize_path_robustly(path: &std::path::Path) -> Result<PathBuf, PathUtilError>`
- **Logik:** (Hier würde eine detaillierte Schritt-für-Schritt-Beschreibung des Normalisierungsalgorithmus stehen, z.B. Auflösen von `.` und `..`, Umgang mit Symlinks (falls im Scope), Sicherstellung einer kanonischen Form). Für diese Spezifikation wird kein konkreter Algorithmus vorgegeben, da die Anforderung eines "komplexen" Utilities noch nicht klar ist.
- **Fehlerbehandlung:** Gibt `PathUtilError` zurück.

#### Allgemeine Richtlinien für `core::utils`

- **Geltungsbereich:** Nur wirklich allgemeine Utilities.
- **Einfachheit:** Einfache Funktionen bevorzugen.
- **Reinheit:** Reine Funktionen bevorzugen.
- **Fehlerbehandlung:** Jede fehleranfällige Utility-Funktion gibt `Result<T, YourUtilError>` zurück, wobei `YourUtilError` mit `thiserror` im Utility-Submodul definiert und in einen allgemeinen `UtilsError` (oder direkt in `CoreError` via `#[from]`, falls sehr generisch) gewrappt werden kann.
- **Dokumentation:** Umfassende `rustdoc`-Kommentare mit Beispielen.
- **Tests:** Gründliche Unit-Tests für jede Utility-Funktion.

##### Implementierungsschritte `core::utils`

1. **Datei `core/src/utils/mod.rs` (oder `core/src/utils.rs`) erstellen.**
2. Falls Submodule für Utilities benötigt werden (z.B. `path_utils.rs`), diese erstellen und in `utils/mod.rs` deklarieren.
3. Für jedes Utility oder Utility-Submodul ggf. eine eigene `errors.rs` erstellen oder Fehler im Haupt-`core::errors` definieren, falls extrem generisch.
4. Utility-Funktionen implementieren, dabei die oben genannten Richtlinien beachten.
5. Umfassende Unit-Tests für jede Funktion schreiben.
6. **Aktualisierung `core/src/lib.rs`:** `pub mod utils;`

---

**Finale `core/src/lib.rs` (Beispiel):**

Rust

```
// src/lib.rs

// Module deklarieren
pub mod config;
pub mod errors;
pub mod logging;
pub mod types;
pub mod utils;

// Wichtige Typen und Funktionen re-exportieren, falls gewünscht
pub use errors::{CoreError, ColorParseError}; // Beispiel
pub use types::{Point, Size, Rect, RectInt, Color, Orientation}; // Beispiel
// ...usw. für andere Module, falls eine flachere API für das Crate gewünscht ist.

// Dieser Crate dient als Fundament und sollte keine spezifische Anwendungslogik enthalten.
// Seine API sollte stabil und gut dokumentiert sein.
```

---

## 3. Ausblick auf weitere Schichten (Methodik)

Die Ultra-Feinspezifikationen für die Domänen-, System- und UI-Schicht würden derselben detaillierten Methodik folgen:

1. **Modulübersicht:** Zweck, Verantwortlichkeiten, Design-Rationale.
2. **Datenstrukturen und Typdefinitionen:**
    - Alle `struct`s, `enum`s, `trait`s, Typaliase in Rust-Syntax.
    - Felder/Varianten: Name, Typ, Sichtbarkeit, Initialwerte (falls zutreffend).
    - Ableitungen (`Debug`, `Clone`, `Serialize`, `Deserialize`, `Default`, `thiserror::Error`, etc.).
    - Invarianten und Geschäftsregeln, die durch die Typen abgebildet werden.
3. **Öffentliche API und Interne Schnittstellen:**
    - Exakte Signaturen aller `pub fn`, `pub trait`, `pub struct` Methoden (Parameter: Name, Typ; Rückgabetyp; `async`, `const`, Zugriffsmodifikatoren).
    - Vor- und Nachbedingungen für jede Methode.
    - Detaillierte Beschreibung der Logik/Algorithmen, die die Methode implementiert.
4. **Event-Spezifikationen (falls zutreffend):**
    - Eindeutiger Event-Name/Typ (Rust-Struktur).
    - Payload-Struktur (Felder und deren Typen).
    - Typische Publisher und Subscriber.
    - Auslösebedingungen für das Event.
5. **Fehlerbehandlung:**
    - Definition des modulspezifischen Fehler-Enums mit `thiserror`.
    - Jede Variante: `#[error("...")]`-Nachricht, Felder für Kontext.
    - Verwendung von `#[source]` und `#[from]` für Fehlerverkettung und -konvertierung.
    - Abbildung von Fehlern aus tieferliegenden Schichten oder externen Bibliotheken.
6. **Zustandsverwaltung und Lebenszyklus (für komplexe Komponenten):**
    - Detaillierte Beschreibung des internen Zustands.
    - Methoden zur Zustandsänderung und deren Auswirkungen.
    - Lebenszyklusmanagement (Initialisierung, Laufzeit, Beendigung).
7. **Interaktionen und Abhängigkeiten:**
    - Mit anderen Modulen derselben Schicht.
    - Mit Modulen anderer Schichten (explizite Nutzung von deren APIs oder Events).
8. **Detaillierte Implementierungsschritte:**
    - Ziel-Dateistruktur für das Modul.
    - Schritt-für-Schritt-Anleitung zur Implementierung von Datenstrukturen, Logik und API.
    - Reihenfolge der Implementierung von Funktionen/Methoden.
9. **Testaspekte:**
    - Identifikation testkritischer Logik.
    - Beispiele für Unit-Testfälle (Szenarien, Eingaben, erwartete Ausgaben/Fehler).
    - Hinweise zu Mocking-Strategien für Abhängigkeiten.

Für die **Domänenschicht** würde dies beispielsweise für `domain::theming`, `domain::workspaces`, `domain::user_centric_services` etc. detailliert erfolgen, wobei jede Entität, jeder Service-Trait und jede Methode genau spezifiziert wird.

Für die **Systemschicht** (z.B. `system::compositor`, `system::input`, `system::dbus`) wäre die Spezifikation besonders komplex, da sie die Interaktion mit externen Bibliotheken (Smithay, libinput, zbus), Wayland-Protokollen und Systemdiensten detailliert beschreiben muss. Hier wären die Handler-Implementierungen (z.B. `CompositorHandler`, `XdgShellHandler`) und die exakte Nutzung der Smithay-APIs im Fokus.

Für die **UI-Schicht** (z.B. `ui::shell`, `ui::widgets`, `ui::control_center`) würde die Spezifikation die GTK4-Widget-Struktur, das Layout, die Signal-Handler, die Datenbindung an Domänen-/Systemzustände und die Logik zur Auslösung von Aktionen in den unteren Schichten detailliert beschreiben.

Dieser extrem detaillierte Ansatz ist sehr aufwendig, stellt aber sicher, dass Entwickler eine klare, unmissverständliche Anleitung haben, was die Konsistenz und Qualität des Endprodukts maßgeblich verbessert.