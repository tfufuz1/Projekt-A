**Struktur der Domänenschicht-Spezifikation:**

Die Domänenschicht (`novade-domain` Crate) wird in folgende logische Hauptmodule unterteilt, die teilweise bereits in Ihren Dokumenten skizziert wurden. Ich werde diese Struktur beibehalten und verfeinern:

1. **`domain::theming`**: Logik der Theming-Engine. (Basierend auf)
2. **`domain::workspaces`**: Umfassende Verwaltungslogik für Arbeitsbereiche. (Basierend auf)
    - `workspaces::core`
    - `workspaces::assignment`
    - `workspaces::manager`
    - `workspaces::config`
3. **`domain::user_centric_services`**: KI-Interaktion und Benachrichtigungsmanagement. (Basierend auf)
    - `user_centric_services::ai_interaction`
    - `user_centric_services::notifications_core`
4. **`domain::notifications_rules`**: Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf Regeln. (Basierend auf der Gesamtspezifikation und )
5. **`domain::global_settings_and_state_management`**: Repräsentation und Logik globaler Desktop-Einstellungen. (Basierend auf der Gesamtspezifikation und)
    - `global_settings::types` (Definition der Einstellungsstrukturen)
    - `global_settings::service` (Der `GlobalSettingsService` Trait und Implementierung)
    - `global_settings::paths` (Der `SettingPath` Enum)
    - `global_settings::persistence_iface` (Trait für die Persistenz, Interaktion mit `core::config`)
6. **`domain::window_management_policy`**: High-Level-Regeln und Richtlinien für Fensterplatzierung, Tiling etc. (Basierend auf der Gesamtspezifikation)
7. **`domain::common_events`**: Definition von Domänen-übergreifenden Events, die nicht spezifisch einem einzelnen Service zugeordnet sind, oder als gemeinsame Payloads dienen.
8. **`domain::shared_types`**: Wiederverwendbare, domänenspezifische Typen, die von mehreren Domänenmodulen genutzt werden, aber nicht in `core::types` gehören (z.B. spezifische IDs, Status-Enums).

**Allgemeine Entwicklungsrichtlinien für die Domänenschicht (Wiederholung und Erweiterung):**

- **UI-Unabhängigkeit:** Die Domänenschicht darf keine direkten Abhängigkeiten zu UI-Toolkits (GTK4) oder spezifischen UI-Implementierungen haben.
- **Systemunabhängigkeit:** Keine direkte Abhängigkeit von Systemdetails wie D-Bus oder Wayland-Protokollen. Diese werden von der Systemschicht gehandhabt.
- **Fokus auf Geschäftslogik:** Enthält die Kernregeln und -prozesse der Desktop-Umgebung.
- **API-Design:** Öffentliche Schnittstellen werden primär über Traits definiert, um Testbarkeit (Mocking) und lose Kopplung zu fördern.
- **Zustandsverwaltung:** Veränderliche Zustände innerhalb von Services werden threadsicher gekapselt (z.B. `Arc<Mutex<...>>` oder `Arc<RwLock<...>>`).
- **Asynchronität:** `async/await` und `async_trait` werden für Operationen verwendet, die potenziell blockieren könnten (z.B. Warten auf Ergebnisse von der Systemschicht, komplexe Berechnungen, die ausgelagert werden können). Die primäre Runtime (z.B. `tokio`) wird von der Anwendung bereitgestellt, die die Domänenschicht nutzt.
- **Events:** Ein klar definierter Event-Mechanismus (z.B. `tokio::sync::broadcast` oder ein dedizierter Event-Bus-Trait) wird für die Kommunikation von Zustandsänderungen zwischen Domänenmodulen und an höhere Schichten verwendet.
- **Fehlerbehandlung:** Konsequente Nutzung von `thiserror` für modulspezifische Fehler-Enums. Fehler aus der Kernschicht werden ggf. gewrappt (`#[from]`).
- **Validierung:** Eingabedaten und Zustandsänderungen werden aktiv validiert.
- **Serialisierung:** `serde` wird für Datenstrukturen verwendet, die persistiert oder über Schnittstellen ausgetauscht werden müssen.
- **Abhängigkeit zur Kernschicht:** Die Domänenschicht nutzt ausschließlich die Kernschicht (`core::*`) für fundamentale Typen, Fehlerbasis, Logging und Konfigurationsprimitive.

---

## Ultra-Feinspezifikation: Domänenschicht (`novade-domain` Crate)

### Modul 1: `domain::theming`

**Zweck:** Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel.

**Bestehende Spezifikation:** wird als Basis verwendet und hier integriert/verfeinert.

#### Untermodul: `domain::theming::types`

**Datei:** `src/theming/types.rs`

- **Struct `TokenIdentifier`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Ord, PartialOrd` (für konsistente Sortierung in HashMaps/Sets, falls Schlüssel Iteriert werden).
- **Enum `TokenValue`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Eq, Hash` (falls `TokenIdentifier` es ist und für `Color`, `Dimension` etc. eine Hash-Implementierung sinnvoll ist – für String-basierte Werte ist dies der Fall).
- **Struct `RawToken`**: Wie in spezifiziert.
- **Typalias `TokenSet`**: Wie in spezifiziert.
- **Struct `ThemeIdentifier`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Ord, PartialOrd`.
- **Enum `ColorSchemeType`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Eq, Hash`.
- **Struct `AccentColor`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Eq, Hash` (falls `name` `Option<String>` ist und `value` `String`).
- **Struct `ThemeVariantDefinition`**: Wie in spezifiziert.
- **Struct `ThemeDefinition`**: Wie in spezifiziert.
- **Struct `AppliedThemeState`**: Wie in spezifiziert.
    - **Felder:**
        - `pub theme_id: ThemeIdentifier`
        - `pub color_scheme: ColorSchemeType`
        - `pub active_accent_color: Option<AccentColor>`
        - `pub resolved_tokens: std::collections::HashMap<TokenIdentifier, String>`
    - **Invarianten:** `resolved_tokens` darf keine Referenzen enthalten, alle Werte sind finale CSS-Strings.
- **Struct `ThemingConfiguration`**: Wie in spezifiziert.

#### Untermodul: `domain::theming::errors`

**Datei:** `src/theming/errors.rs`

- **Enum `ThemingError`**: Wie in spezifiziert.
    - **Varianten (Beispiele, konsolidiert):**
        - `TokenFileParseError { path: PathBuf, #[source] source: serde_json::Error }`
        - `TokenFileIoError { path: PathBuf, #[source] source: std::io::Error }`
        - `InvalidTokenData { path: PathBuf, message: String }`
        - `CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> }`
        - `ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: serde_json::Error }`
        - `ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: std::io::Error }`
        - `InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String }`
        - `ThemeNotFound { theme_id: ThemeIdentifier }`
        - `MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier }`
        - `MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 }`
        - `ThemeApplicationError { message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
        - `FallbackThemeLoadError { #[source] source: Box<dyn std::error::Error + Send + Sync + 'static> }`
        - `InitialConfigurationError(String)`
        - `InternalStateError(String)`
        - `EventSubscriptionError(String)`
        - `AccentColorProcessingError { theme_id: ThemeIdentifier, accent_value: String, message: String }` (Neu, für Fehler bei Akzentfarben-Anwendung)
        - `TokenResolutionError { token_id: TokenIdentifier, message: String }` (Allgemeiner Fehler während der Auflösung)

#### Untermodul: `domain::theming::logic` (oder `domain::theming::engine_internal`)

**Datei:** `src/theming/logic.rs` (oder aufgeteilt in `token_loader.rs`, `theme_loader.rs`, `token_resolver.rs` etc.)

- **Kernlogik und Geschäftsregeln** wie in spezifiziert:
    - Laden, Parsen, Validieren von Token- (_.tokens.json) und Theme-Definitionen (_.theme.json).
        - **Funktion:** `pub(crate) async fn load_and_validate_token_files(paths: &[PathBuf]) -> Result<TokenSet, ThemingError>`
        - **Funktion:** `pub(crate) async fn load_and_validate_theme_files(paths: &[PathBuf], global_tokens: &TokenSet) -> Result<Vec<ThemeDefinition>, ThemingError>`
    - Token Resolution Pipeline:
        - **Funktion:** `pub(crate) fn resolve_tokens_for_config(config: &ThemingConfiguration, theme_def: &ThemeDefinition, global_tokens: &TokenSet, max_depth: u8) -> Result<std::collections::HashMap<TokenIdentifier, String>, ThemingError>`
            - Schritt 1: Basissatz (Globale Tokens + Theme Base Tokens)
            - Schritt 2: Varianten-spezifische Tokens anwenden
            - Schritt 3: Akzentfarben-Logik anwenden (Direkte Ersetzung spezifischer Tokens, z.B. `token.system.accent.primary`, `token.system.accent.secondary`)
            - Schritt 4: Benutzerdefinierte globale Token-Overrides anwenden
            - Schritt 5: Rekursive Auflösung von `TokenValue::Reference` mit Zyklenerkennung und Tiefenbegrenzung.
            - Schritt 6: Finale Wertkonvertierung zu `String`.
    - Caching-Logik für `AppliedThemeState`.
        - **Typ:** `CacheKey(ThemeIdentifier, ColorSchemeType, Option<AccentColorHash>, UserOverridesHash)`
        - Cache-Struktur: `std::collections::HashMap<CacheKey, AppliedThemeState>`
    - Laden des Fallback-Themes (siehe).
        - **Funktion:** `pub(crate) fn load_fallback_theme_definition() -> Result<(ThemeDefinition, TokenSet), ThemingError>` (aus eingebetteten Strings)
        - **Funktion:** `pub(crate) fn generate_fallback_applied_state() -> AppliedThemeState`

#### Öffentliche API: `ThemingEngine` Service

**Datei:** `src/theming/mod.rs` (oder `src/theming/api.rs` oder `src/theming/service.rs`)

- **Struct `ThemingEngine`**: Wie in spezifiziert, verwendet `Arc<Mutex<ThemingEngineInternalState>>`.
    - **`ThemingEngineInternalState` Felder:**
        - `current_config: ThemingConfiguration`
        - `available_themes: Vec<ThemeDefinition>`
        - `global_raw_tokens: TokenSet`
        - `applied_state: AppliedThemeState`
        - `theme_load_paths: Vec<PathBuf>`
        - `token_load_paths: Vec<PathBuf>`
        - `resolved_state_cache: std::collections::HashMap<(ThemeIdentifier, ColorSchemeType, Option<String>, u64), AppliedThemeState>` (Cache-Schlüssel muss Hashable sein; Option&lt;AccentColor> könnte zu Option&lt;String> für den Farbwert vereinfacht werden, UserOverrides zu einem Hash).
        - `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>` (anstelle von `mpsc`)
- **Methoden der `ThemingEngine`**:
    - `pub async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, broadcast_capacity: usize) -> Result<Self, ThemingError>`
        - Initialisiert `event_sender = tokio::sync::broadcast::channel(broadcast_capacity).0;`
        - Lädt Themes und Tokens asynchron.
        - Berechnet initialen `applied_state` oder Fallback.
    - `pub async fn get_current_theme_state(&self) -> AppliedThemeState` (gibt Klon von `applied_state` zurück, kein `Result` wenn interner Zustand immer gültig ist).
    - `pub async fn get_available_themes(&self) -> Vec<ThemeDefinition>` (gibt Klon zurück).
    - `pub async fn get_current_configuration(&self) -> ThemingConfiguration` (gibt Klon zurück).
    - `pub async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
        - Berechnet neuen `applied_state`.
        - Wenn geändert, `self.event_sender.send(ThemeChangedEvent { ... }).map_err(...)`. Ignoriere Fehler, wenn keine Subscriber da sind (`Ok(_)`).
    - `pub async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`
        - Lädt Themes/Tokens neu.
        - Wendet `current_config` neu an, aktualisiert `applied_state`.
        - Sendet Event, falls geändert.
        - Invalidiert Cache.
    - `pub fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`
        - Gibt `self.event_sender.subscribe()` zurück.
- **Event `ThemeChangedEvent`**: Wie in spezifiziert.
    - **Payload:** `pub new_state: AppliedThemeState`
    - **Publisher:** `ThemingEngine`
    - **Subscriber:** `ui::theming_gtk`, andere UI-Komponenten, `domain::global_settings_service` (falls Theming von globalen Einstellungen abhängt).

#### Implementierungsschritte `domain::theming`

1. **Dateistruktur anlegen:** Gemäß.
2. **`types.rs` implementieren:** Alle Datenstrukturen mit `serde`-Attributen und Ableitungen.
3. **`errors.rs` implementieren:** `ThemingError`-Enum mit `thiserror`.
4. **`logic.rs` (oder Submodule) implementieren:**
    - Token-/Theme-Lade- und Validierungsfunktionen (asynchron).
    - Token Resolution Pipeline (synchron, da CPU-gebunden nach dem Laden).
    - Fallback-Theme-Logik.
    - Caching-Logik.
5. **`ThemingEngine`-Service (`mod.rs` oder `service.rs`) implementieren:**
    - `ThemingEngineInternalState` und `ThemingEngine` Strukturen.
    - `new()`-Konstruktor (asynchron).
    - Alle öffentlichen API-Methoden (asynchron, wo sinnvoll).
    - Event-Versand mit `tokio::sync::broadcast`.
6. **Unit-Tests:**
    - Für alle Datenstrukturen: Serialisierung/Deserialisierung.
    - Für `ThemingError`: `Display`-Implementierung und `source()`-Verhalten.
    - Für Lade-/Validierungslogik: Gültige/ungültige Dateien, Zyklen, fehlende Referenzen.
    - Für Token Resolution Pipeline: Verschiedene Szenarien (Basis, Varianten, Overrides, Akzente, komplexe Referenzen, Fehlerfälle).
    - Für `ThemingEngine`: API-Methodenverhalten, Zustandsänderungen, Event-Auslösung, Cache-Verhalten, Thread-Sicherheit (konzeptionell, durch korrekte Mutex-Nutzung).

---

### Modul 2: `domain::workspaces`

**Zweck:** Umfassende Verwaltungslogik für Arbeitsbereiche ("Spaces").

**Bestehende Spezifikation:** wird als Basis verwendet.

#### Untermodul: `domain::workspaces::core`

**Datei:** `src/workspaces/core/types.rs` (konsolidiert Typen hier)

- **Typalias `WorkspaceId`**: `pub type WorkspaceId = uuid::Uuid;`
- **Struct `WindowIdentifier`**: `#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)] pub struct WindowIdentifier(String);`
    - Methoden: `new(id: String) -> Result<Self, WorkspaceCoreError>`, `as_str()`. `From<String>` für einfache Konvertierung (kann Validierung in `new` haben). `Display`-Implementierung.
- **Enum `WorkspaceLayoutType`**: `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)] pub enum WorkspaceLayoutType { #[default] Floating, TilingHorizontal, TilingVertical, Maximized }`
- **Struct `Workspace`**: Wie in spezifiziert.
    - **Felder:** `id: WorkspaceId`, `name: String`, `persistent_id: Option<String>`, `layout_type: WorkspaceLayoutType`, `window_ids: HashSet<WindowIdentifier>`, `created_at: chrono::DateTime<chrono::Utc>`.
    - **Ableitungen:** `#[derive(Debug, Clone, Serialize, Deserialize)]` (`PartialEq` ggf. manuell wegen `HashSet`).
    - **Methoden:** `new(...) -> Result<Self, WorkspaceCoreError>`, `id()`, `name()`, `rename(...) -> Result<...>`, `layout_type()`, `set_layout_type(...)`, `add_window_id(&mut self, ...)` (pub(crate)), `remove_window_id(&mut self, ...)` (pub(crate)), `window_ids()`, `persistent_id()`, `set_persistent_id(...) -> Result<...>`, `created_at()`.

**Datei:** `src/workspaces/core/event_data.rs`

- **Event-Payload-Strukturen**: `WorkspaceRenamedData`, `WorkspaceLayoutChangedData`, `WindowAddedToWorkspaceData`, `WindowRemovedFromWorkspaceData`, `WorkspacePersistentIdChangedData` - wie in spezifiziert. Alle mit `#[derive(Debug, Clone, Serialize, Deserialize)]`.

**Datei:** `src/workspaces/core/errors.rs`

- **Konstante `MAX_WORKSPACE_NAME_LENGTH`**: `pub const MAX_WORKSPACE_NAME_LENGTH: usize = 64;`
- **Enum `WorkspaceCoreError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `InvalidName(String)`
        - `NameCannotBeEmpty`
        - `NameTooLong { name: String, max_len: usize, actual_len: usize }`
        - `InvalidPersistentId(String)` (z.B. leer oder ungültige Zeichen)
        - `Internal { context: String }`
        - `WindowIdentifierEmpty` (Für `WindowIdentifier::new`)

#### Untermodul: `domain::workspaces::assignment`

**Datei:** `src/workspaces/assignment/mod.rs`

- **Öffentliche API-Funktionen**: Operieren auf `&mut std::collections::HashMap<WorkspaceId, Workspace>`. Wie in spezifiziert.
    - `pub fn assign_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier, ensure_unique_assignment: bool) -> Result<(), WindowAssignmentError>`
    - `pub fn remove_window_from_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<bool, WindowAssignmentError>`
    - `pub fn move_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id: WorkspaceId, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WindowAssignmentError>`
    - `pub fn find_workspace_for_window(workspaces: &HashMap<WorkspaceId, Workspace>, window_id: &WindowIdentifier) -> Option<WorkspaceId>`

**Datei:** `src/workspaces/assignment/errors.rs`

- **Enum `WindowAssignmentError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `WorkspaceNotFound(WorkspaceId)`
        - `WindowAlreadyAssigned { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `WindowNotAssignedToWorkspace { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `SourceWorkspaceNotFound(WorkspaceId)`
        - `TargetWorkspaceNotFound(WorkspaceId)`
        - `WindowNotOnSourceWorkspace { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `CannotMoveToSameWorkspace { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `RuleViolation { reason: String, window_id: Option<WindowIdentifier>, target_workspace_id: Option<WorkspaceId> }`
        - `Internal { context: String }`

#### Untermodul: `domain::workspaces::manager`

**Datei:** `src/workspaces/manager/events.rs`

- **Enum `WorkspaceEvent`**: Wie in spezifiziert. Alle Payloads mit `#[derive(Debug, Clone, Serialize, Deserialize)]`.
    - Payload-Strukturen aus `workspaces::core::event_data` werden hier verwendet.

**Datei:** `src/workspaces/manager/errors.rs`

- **Enum `WorkspaceManagerError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `WorkspaceNotFound(WorkspaceId)`
        - `CannotDeleteLastWorkspace`
        - `DeleteRequiresFallbackForWindows { workspace_id: WorkspaceId, window_count: usize }`
        - `FallbackWorkspaceNotFound(WorkspaceId)`
        - `CoreError { #[from] source: crate::domain::workspaces::core::errors::WorkspaceCoreError }`
        - `AssignmentError { #[from] source: crate::domain::workspaces::assignment::errors::WindowAssignmentError }`
        - `ConfigError { #[from] source: crate::domain::workspaces::config::errors::WorkspaceConfigError }`
        - `SetActiveWorkspaceNotFound(WorkspaceId)`
        - `NoActiveWorkspace`
        - `DuplicatePersistentId(String)`
        - `Internal { context: String }`

**Datei:** `src/workspaces/manager/mod.rs` (oder `service.rs`)

- **Trait `EventPublisher<E>` (Beispiel, falls nicht global):** `pub trait EventPublisher<E: Clone + Send + 'static>: Send + Sync { fn publish(&self, event: E); }`
- **Struct `WorkspaceManager`**: Wie in spezifiziert.
    - **Felder:**
        - `workspaces: HashMap<WorkspaceId, Workspace>`
        - `active_workspace_id: Option<WorkspaceId>`
        - `ordered_workspace_ids: Vec<WorkspaceId>`
        - `next_workspace_number: u32`
        - `config_provider: Arc<dyn WorkspaceConfigProvider>` (aus `workspaces::config`)
        - `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`
        - `ensure_unique_window_assignment: bool`
- **Methoden der `WorkspaceManager`** (alle `async` wo I/O oder potenziell blockierende Logik involviert ist, insbesondere `save_configuration` und `new`):
    - `pub async fn new(config_provider: Arc<dyn WorkspaceConfigProvider>, broadcast_capacity: usize, ensure_unique_window_assignment: bool) -> Result<Self, WorkspaceManagerError>`
    - `pub async fn create_workspace(&mut self, name: Option<String>, persistent_id: Option<String>) -> Result<WorkspaceId, WorkspaceManagerError>`
    - `pub async fn delete_workspace(&mut self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>`
    - `pub fn get_workspace(&self, id: WorkspaceId) -> Option<&Workspace>`
    - `pub fn get_workspace_mut(&mut self, id: WorkspaceId) -> Option<&mut Workspace>`
    - `pub fn all_workspaces_ordered(&self) -> Vec<&Workspace>`
    - `pub fn active_workspace_id(&self) -> Option<WorkspaceId>`
    - `pub async fn set_active_workspace(&mut self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - `pub async fn assign_window_to_active_workspace(&mut self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `pub async fn assign_window_to_specific_workspace(&mut self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `pub async fn remove_window_from_its_workspace(&mut self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
    - `pub async fn move_window_to_specific_workspace(&mut self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `pub async fn rename_workspace(&mut self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
    - `pub async fn set_workspace_layout(&mut self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>`
    - `pub async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>`
    - `pub fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`

#### Untermodul: `domain::workspaces::config`

**Datei:** `src/workspaces/config/errors.rs`

- **Enum `WorkspaceConfigError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `LoadError { path: String, #[source] source: crate::core::config::ConfigError }` (nutzt `ConfigError` aus `core`)
        - `SaveError { path: String, #[source] source: crate::core::config::ConfigError }`
        - `InvalidData { reason: String, path: Option<String> }`
        - `SerializationError { message: String, #[source] source: Option<serde_json::Error> }` (oder `toml::ser::Error`)
        - `DeserializationError { message: String, snippet: Option<String>, #[source] source: Option<serde_json::Error> }` (oder `toml::de::Error`)
        - `PersistentIdNotFoundInLoadedSet { persistent_id: String }` (Umbenannt für Klarheit)
        - `DuplicatePersistentIdInLoadedSet { persistent_id: String }` (Umbenannt für Klarheit)
        - `VersionMismatch { expected: Option<String>, found: Option<String> }`
        - `Internal { context: String }`

**Datei:** `src/workspaces/config/mod.rs` (oder `provider.rs` und `types.rs` hier)

- **Struct `WorkspaceSnapshot`**: Wie in spezifiziert. `#[derive(Debug, Clone, Serialize, Deserialize)]`.
    - Felder: `persistent_id: String`, `name: String`, `layout_type: WorkspaceLayoutType`.
- **Struct `WorkspaceSetSnapshot`**: Wie in spezifiziert. `#[derive(Debug, Clone, Serialize, Deserialize, Default)]`.
    - Felder: `workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`.
- **Trait `WorkspaceConfigProvider`**: `#[async_trait::async_trait] pub trait WorkspaceConfigProvider: Send + Sync { async fn load_workspace_config(&self) -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>; async fn save_workspace_config(&self, config_snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>; }` (Methoden sind `async` da Dateizugriff erfolgt).
- **Struct `FilesystemConfigProvider`**: Wie in spezifiziert.
    - Implementiert `WorkspaceConfigProvider` `async`. Nutzt `core::config::ConfigService` (oder `load_core_config`/`save_core_config` Äquivalente, die `async` sind).
        - **Logik für `load_workspace_config`**: Asynchrones Lesen der Datei, Deserialisierung, Validierung.
        - **Logik für `save_workspace_config`**: Serialisierung, asynchrones Schreiben der Datei.

#### Implementierungsschritte `domain::workspaces`

1. **`core` Modul implementieren:**
    - Dateien `types.rs`, `event_data.rs`, `errors.rs`, `mod.rs` anlegen.
    - Alle Typen, Enums, Fehler und `Workspace`-Methoden implementieren. Unit-Tests.
2. **`assignment` Modul implementieren:**
    - Dateien `errors.rs`, `mod.rs` anlegen.
    - `WindowAssignmentError` und Zuweisungsfunktionen implementieren. Unit-Tests.
3. **`config` Modul implementieren:**
    - Dateien `errors.rs`, `mod.rs` anlegen.
    - Snapshot-Structs, `WorkspaceConfigError`, `WorkspaceConfigProvider`-Trait und `FilesystemConfigProvider` implementieren (`async`). Unit-Tests mit Mocking für `core::config`.
4. **`manager` Modul implementieren:**
    - Dateien `events.rs`, `errors.rs`, `mod.rs` anlegen.
    - `WorkspaceEvent`, `WorkspaceManagerError` und `WorkspaceManager`-Service implementieren (`async`).
    - Integration von `core`, `assignment`, `config` Logik. Event-Versand mit `tokio::sync::broadcast`.
    - Umfassende Unit- und Integrationstests (Mocking für `config_provider` und `event_publisher`).

---

(Die Spezifikationen für die Module 3 bis 8 würden analog folgen, mit derselben Detailtiefe. Aufgrund der aktuellen Längenbeschränkung werde ich die Titel und eine kurze Zusammenfassung der Verantwortlichkeiten für die verbleibenden Module geben, basierend auf der Gesamtspezifikation und Ihrer vorherigen Ausgabe.)

### Modul 3: `domain::user_centric_services`

**Zweck:** KI-Interaktionsmanagement (inkl. Einwilligungen) und Benachrichtigungsmanagement.

**Bestehende Spezifikation:** wird als Basis verwendet.

#### Untermodul: `domain::user_centric_services::ai_interaction`

- **Datenstrukturen:** `AIInteractionContext`, `AIConsent`, `AIModelProfile`, `AttachmentData`, `AIConsentStatus`, `AIDataCategory`.
- **Service Trait:** `AIInteractionLogicService` (asynchron).
- **Fehler-Enum:** `AIInteractionError`.
- **Events:** `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`.

#### Untermodul: `domain::user_centric_services::notifications_core`

- **Datenstrukturen:** `Notification`, `NotificationAction`, `NotificationUrgency`, `NotificationActionType`, `NotificationFilterCriteria`, `NotificationSortOrder`.
- **Service Trait:** `NotificationService` (asynchron).
- **Fehler-Enum:** `NotificationError`.
- **Events:** `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent`.

**Implementierungsschritte:** Analog zu den vorherigen Modulen, mit Fokus auf die jeweilige Geschäftslogik, Fehlerbehandlung und Event-Auslösung. Die Persistenz von `AIConsent` und `AIModelProfile` wird an `core::config` delegiert.

---

### Modul 4: `domain::notifications_rules`

**Zweck:** Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln.

#### Untermodul: `domain::notifications_rules::types`

- **Struct `RuleCondition`**: Enum mit Varianten wie `AppNameIs(String)`, `SummaryContains(String)`, `UrgencyIs(NotificationUrgency)`, `SettingIsTrue(SettingPath)` etc. Muss rekursive Strukturen wie `And(Vec<RuleCondition>)`, `Or(Vec<RuleCondition>)`, `Not(Box<RuleCondition>)` unterstützen.
- **Struct `RuleAction`**: Enum mit Varianten wie `SuppressNotification`, `SetUrgency(NotificationUrgency)`, `PlaySound(String)`, `MarkAsPersistent(bool)`.
- **Struct `NotificationRule`**: Enthält `id: Uuid`, `description: String`, `conditions: RuleCondition`, `actions: Vec<RuleAction>`, `is_enabled: bool`, `priority: i32`, `stop_processing_after_match: bool`.
- **Typalias `NotificationRuleSet`**: `Vec<NotificationRule>`.

#### Untermodul: `domain::notifications_rules::errors`

- **Enum `NotificationRulesError`**: Varianten wie `InvalidRuleDefinition`, `ConditionEvaluationError` (mit Details zum Fehler), `ActionApplicationError`, `SettingsAccessError` (wenn `SettingIsTrue` evaluiert wird und `GlobalSettingsService` einen Fehler zurückgibt), `RulePersistenceError` (beim Laden/Speichern von Regeln).

#### Untermodul: `domain::notifications_rules::engine` (oder `service.rs`)

- **Struct `NotificationRulesEngine`**:
    - Hält `rules: NotificationRuleSet` (sortiert nach Priorität).
    - Abhängigkeit zum `GlobalSettingsService` (für `SettingIsTrue` Bedingungen).
    - Methode `pub async fn process_notification(&self, notification: &mut Notification, settings: &GlobalDesktopSettings) -> Result<RuleProcessingResult, NotificationRulesError>`
        - Iteriert durch `is_enabled` Regeln in Prioritätsreihenfolge.
        - Für jede Regel: `evaluate_condition(&rule.conditions, notification, settings)`.
        - Wenn Bedingung zutrifft: `apply_actions(&rule.actions, notification)`.
        - Gibt `RuleProcessingResult::Allow` (ggf. modifizierte Notification) oder `RuleProcessingResult::Suppress` zurück.
- **Enum `RuleProcessingResult`**: `Allow(Notification)`, `Suppress { rule_id: Uuid }`.
- **Interne Funktionen**: `evaluate_condition_recursive(...)`, `apply_action_internal(...)`.

#### Untermodul: `domain::notifications_rules::persistence_iface`

- **Trait `NotificationRulesProvider`**: `async fn load_rules() -> Result<NotificationRuleSet, NotificationRulesError>`, `async fn save_rules(rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`.
- Implementierung (z.B. `FilesystemNotificationRulesProvider`) interagiert mit `core::config`.

**Implementierungsschritte:** Datenstrukturen, Fehler, Logik der Engine (rekursive Bedingungsauswertung), Persistenzschnittstelle. Integration mit `notifications_core::NotificationService`.

---

### Modul 5: `domain::global_settings_and_state_management`

**Zweck:** Repräsentation, Logik zur Verwaltung und Konsistenz globaler Desktop-Einstellungen.

**Bestehende Spezifikation:** wird als Basis verwendet.

#### Untermodul: `domain::global_settings::types`

- **Strukturen:** `GlobalDesktopSettings`, `AppearanceSettings`, `WorkspaceSettings`, `FontSettings`, `InputBehaviorSettings`, `PowerManagementPolicySettings`, `DefaultApplicationsSettings` etc. mit allen Feldern und `serde`-Attributen.
- **Enums:** `ColorScheme`, `FontHinting`, `LidCloseAction` etc.
- `SerdeF32` Wrapper.

#### Untermodul: `domain::global_settings::paths`

- **Enum `SettingPath`**: Hierarchischer Enum zur typsicheren Adressierung von Einstellungen (z.B. `SettingPath::Appearance(AppearanceSettingPath::FontSettings(FontSettingPath::DefaultFontSize))`).

#### Untermodul: `domain::global_settings::errors`

- **Enum `GlobalSettingsError`**: Varianten wie `PathNotFound`, `InvalidValueType`, `ValidationError`, `SerializationError`, `DeserializationError`, `PersistenceError { #[from] source: crate::core::config::ConfigError }`.

#### Untermodul: `domain::global_settings::service`

- **Trait `GlobalSettingsService`**: Methoden (`async` wo nötig):
    - `load_settings()`
    - `save_settings()`
    - `get_current_settings() -> GlobalDesktopSettings`
    - `update_setting(path: SettingPath, value: serde_json::Value)`
    - `get_setting(path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`
    - `reset_to_defaults()`
    - `subscribe_to_changes() -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`
- **Implementierung `DefaultGlobalSettingsService`**: Hält `settings: GlobalDesktopSettings`, `persistence_provider: Arc<dyn SettingsPersistenceProvider>`, `event_sender: tokio::sync::broadcast::Sender<SettingChangedEvent>`.

#### Untermodul: `domain::global_settings::persistence_iface`

- **Trait `SettingsPersistenceProvider`**: `async fn load_global_settings() -> Result<GlobalDesktopSettings, GlobalSettingsError>`, `async fn save_global_settings(settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`.
- Implementierung (z.B. `FilesystemSettingsProvider`) interagiert mit `core::config`.

**Events:** `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`, `SettingsLoadedEvent { settings: GlobalDesktopSettings }`, `SettingsSavedEvent`.

**Implementierungsschritte:** Definition aller Einstellungsstrukturen, `SettingPath`, Fehler, Service-Trait und Implementierung, Persistenzschnittstelle. Event-Mechanismus.

---

### Modul 6: `domain::window_management_policy`

**Zweck:** Definition von High-Level-Regeln und Richtlinien für Fensterplatzierung, Logik für automatisches Tiling (Layout-Typen wie Spalten, Spiralen), Snapping-Verhalten, Fenstergruppierung und Gap-Management. Diese Schicht definiert die "Policy", die Systemschicht die "Mechanik".

#### Untermodul: `domain::window_management_policy::types`

- **Enum `TilingLayoutType`**: `Columns`, `Rows`, `Spiral`, `MaximizedFocused`, `Floating`.
- **Struct `GapSettings`**: `outer_gap: u32`, `inner_gap: u32`.
- **Struct `WindowSnappingPolicy`**: `snap_to_screen_edges: bool`, `snap_to_other_windows: bool`, `snap_distance: u32`.
- **Struct `WindowGroupingPolicy`**: (Regeln für automatische oder manuelle Fenstergruppierung, z.B. `group_by_application_id: bool`).
- **Struct `WindowPlacementPolicy`**: `new_window_placement_strategy: NewWindowPlacementStrategy` (Enum: `Smart`, `Center`, `Cascade`).
- **Struct `FocusPolicy`**: `focus_follows_mouse: bool`, `click_to_focus: bool`, `focus_new_windows: bool`.
- **Struct `ManagedWindowProperties`**: Hält domänenspezifische Eigenschaften eines Fensters, die für die Policy relevant sind (z.B. `current_tiling_layout_override: Option<TilingLayoutType>`, `user_defined_size: Option<Size<u32>>`, `is_floating_override: bool`). Wird über `WindowIdentifier` referenziert.

#### Untermodul: `domain::window_management_policy::errors`

- **Enum `WindowPolicyError`**: `LayoutCalculationError`, `InvalidPolicyConfiguration`.

#### Untermodul: `domain::window_management_policy::service`

- **Trait `WindowManagementPolicyService`**:
    - `async fn get_layout_for_workspace(&self, workspace_id: WorkspaceId, windows_on_workspace: Vec<WindowIdentifier>, available_space: RectInt) -> Result<HashMap<WindowIdentifier, RectInt>, WindowPolicyError>`: Berechnet die Geometrien für Fenster auf einem Workspace basierend auf der Policy.
    - `async fn apply_new_window_policy(&self, window_id: WindowIdentifier, workspace_id: WorkspaceId, current_windows: &[WindowIdentifier]) -> Result<RectInt, WindowPolicyError>`: Bestimmt die initiale Geometrie für ein neues Fenster.
    - `async fn get_snapping_target(&self, moving_window_id: WindowIdentifier, current_rect: RectInt, other_windows: &[(&WindowIdentifier, &RectInt)]) -> Option<RectInt>`: Berechnet ein "Snap"-Ziel.
    - (Weitere Methoden zur Abfrage/Aktualisierung von Policies für Tiling, Gaps, Snapping, Gruppierung, Fokus).
- **Implementierung `DefaultWindowManagementPolicyService`**:
    - Hält die aktuellen Policy-Konfigurationen (geladen von `GlobalSettingsService`).
    - Implementiert die Logik zur Layoutberechnung (Spalten, Spiralen etc.) und Snapping.

**Abhängigkeiten:** `domain::global_settings_service` (zum Lesen der Policy-Konfigurationen), `domain::workspaces` (um Infos über Workspaces und Fenster darauf zu erhalten).

**Interaktion:** Die Systemschicht (`system::window_mechanics`) ruft Methoden dieses Services auf, um die gewünschten Fenstergeometrien und -verhalten zu erhalten und technisch umzusetzen.

---

### Modul 7: `domain::common_events`

**Datei:** `src/common_events.rs`

- **Zweck:** Definition von Event-Typen, die von mehreren Domänenmodulen ausgelöst oder konsumiert werden können oder die als generische Payloads dienen.
- **Beispiele:**
    - `pub struct UserActivityDetectedEvent { timestamp: DateTime<Utc>, activity_type: UserActivityType }`
    - `pub enum UserActivityType { MouseMoved, KeyPressed, WorkspaceSwitched }`
    - `pub struct SystemShutdownInitiatedEvent { reason: String }`

---

### Modul 8: `domain::shared_types`

**Datei:** `src/shared_types.rs`

- **Zweck:** Definition von domänenspezifischen Typen, die von mehreren Domänenmodulen verwendet werden, aber nicht allgemein genug für `core::types` sind.
- **Beispiele:**
    - `pub type ApplicationId = String;` (Falls spezifischer als `WindowIdentifier`)
    - `pub enum UserSessionState { Active, Locked, Idle }` (Domänenrepräsentation, Systemschicht mappt Logind-Zustände darauf)
    - `pub struct ResourceIdentifier { pub r#type: String, pub id: String }` (Für KI-Interaktionen oder andere Ressourcen)

---

**Implementierungsleitfaden (Allgemein für Domänenschicht):**

1. **Crate-Struktur:** Erstellen Sie ein `novade-domain`-Crate.
2. **Modulstruktur:** Legen Sie die Verzeichnisstruktur für die oben genannten Hauptmodule an (z.B. `src/theming/`, `src/workspaces/`, etc.).
3. **Abhängigkeiten in `novade-domain/Cargo.toml`:**
    
    Ini, TOML
    
    ```
    [dependencies]
    novade-core = { path = "../novade-core" } # Relative Pfade anpassen
    thiserror = "1.0"
    serde = { version = "1.0", features = ["derive"] }
    serde_json = "1.0" # Für JsonValue und Fehler
    uuid = { version = "1.0", features = ["v4", "serde"] }
    chrono = { version = "0.4", features = ["serde"] }
    async-trait = "0.1"
    tokio = { version = "1", features = ["sync"] } # Für broadcast channels
    # Ggf. weitere spezifische Crates
    ```
    
4. **Implementierung pro Modul:**
    - Beginnen Sie mit `types.rs` und `errors.rs`.
    - Implementieren Sie dann die Service-Traits und deren interne Logik.
    - Definieren und implementieren Sie die Event-Strukturen und deren Versandlogik.
    - Schreiben Sie umfassende Unit-Tests für jede Komponente.
5. **`novade-domain/src/lib.rs`:** Deklarieren Sie alle öffentlichen Module und re-exportieren Sie die primären Service-Traits und wichtigsten Typen für eine saubere Crate-API.

Dieser detaillierte Plan für die Domänenschicht sollte es den Entwicklern ermöglichen, die Geschäftslogik der NovaDE-Desktop-Umgebung systematisch und konsistent zu implementieren. Der Fokus auf Traits, klare Fehlerdefinitionen und einen Event-basierten Ansatz wird zu einer robusten und wartbaren Schicht führen.

Okay, ich werde nun die Ultra-Feinspezifikation und den detaillierten Implementierungsplan für die **Domänenschicht** des NovaDE-Projekts entwickeln. Ich werde die bereits existierenden Spezifikationen (,,) als Grundlage nehmen, sie konsolidieren, verfeinern und erweitern, um einen lückenlosen Leitfaden zu erstellen.

**Autonome Entscheidung zur Sequenzierung und Submodul-Aufteilung:**

1. **`domain::shared_types`** (Wird zuerst definiert, da von vielen anderen Modulen genutzt)
2. **`domain::common_events`** (Ebenfalls früh, da Events modulübergreifend sein können)
3. **`domain::theming`**
4. **`domain::global_settings_and_state_management`** (Einstellungen beeinflussen viele andere Module)
5. **`domain::workspaces`**
6. **`domain::window_management_policy`** (Baut auf Workspaces und globalen Einstellungen auf)
7. **`domain::user_centric_services`** (KI und Benachrichtigungen, können Einstellungen und Kontext nutzen)
    - `user_centric_services::ai_interaction`
    - `user_centric_services::notifications_core`
8. **`domain::notifications_rules`** (Baut auf `notifications_core` und `global_settings` auf)

Diese Reihenfolge versucht, Abhängigkeiten zu berücksichtigen, indem grundlegendere oder breiter genutzte Module früher spezifiziert werden.

---

## Ultra-Feinspezifikation und Implementierungsplan: Domänenschicht (`novade-domain` Crate)

**Allgemeine Entwicklungsrichtlinien für die Domänenschicht:** (Wiederholung zur Betonung)

- **Sprache:** Rust (Edition 2021 oder neuer)
- **UI-Unabhängigkeit:** Strikte Trennung von UI-Belangen. Keine GTK-Abhängigkeiten.
- **Systemunabhängigkeit:** Keine direkten Systemaufrufe (D-Bus, Wayland-Protokolle).
- **Kernlogik:** Fokus auf Geschäftsregeln und -prozesse.
- **API-Design:** Öffentliche Schnittstellen primär über `async_trait` Traits.
- **Zustandsverwaltung:** Threadsichere Kapselung (`Arc<Mutex<...>>` oder `Arc<RwLock<...>>`).
- **Asynchronität:** `async/await` für potenziell blockierende Operationen. Runtime (`tokio`) wird von der Anwendung bereitgestellt.
- **Events:** `tokio::sync::broadcast` für die Event-Kommunikation.
- **Fehlerbehandlung:** `thiserror` für modulspezifische Fehler-Enums. Sauberes Wrapping von `novade-core::errors`.
- **Validierung:** Aktive Validierung von Eingaben und Zustandsänderungen.
- **Serialisierung:** `serde` für Datenstrukturen, die persistiert oder ausgetauscht werden.
- **Abhängigkeiten:**
    - `novade-core = { path = "../novade-core" }`
    - `thiserror = "1.0"`
    - `serde = { version = "1.0", features = ["derive"] }`
    - `serde_json = "1.0"`
    - `uuid = { version = "1.8", features = ["v4", "serde"] }` (Aktuelle Version prüfen)
    - `chrono = { version = "0.4", features = ["serde"] }` (Aktuelle Version prüfen)
    - `async-trait = "0.1"`
    - `tokio = { version = "1", features = ["sync"] }`
    - `tracing = "0.1"`
- **Logging:** Verwendung von `tracing::{trace, debug, info, warn, error}` Makros aus `novade-core`.

---

### Modul 1: `domain::shared_types`

Zweck: Definition von domänenspezifischen Typen, die von mehreren Domänenmodulen verwendet werden, aber nicht allgemein genug für core::types sind.

Datei: src/shared_types.rs

#### 1.1. Type Alias: `ApplicationId`

- **Definition:** `pub type ApplicationId = String;`
- **Zweck:** Eindeutiger Bezeichner für eine Anwendung (z.B. Reverse-DNS-Name wie "org.novade.FileExplorer").
- **Invarianten:** Sollte nicht leer sein. Formatierungsregeln können von der Systemschicht (z.B. AppID aus `.desktop`-Dateien) abhängen und hier nur als Konvention dokumentiert werden.
- **Ableitungen (indirekt durch String):** `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.

#### 1.2. Enum: `UserSessionState`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum UserSessionState {
        #[default]
        Active, // Normale Benutzersitzung
        Locked, // Sitzung gesperrt (z.B. Bildschirmschoner aktiv)
        Idle,   // Benutzer ist für eine bestimmte Zeit inaktiv
    }
    ```
    
- **Zweck:** Repräsentiert den aktuellen Zustand der Benutzersitzung aus Sicht der Domäne. Die Systemschicht mappt hierauf ggf. detailliertere Zustände von `logind` o.ä.
- **Initialwert:** `Active` (durch `#[default]`).

#### 1.3. Struct: `ResourceIdentifier`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use uuid::Uuid;
    
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct ResourceIdentifier {
        pub r#type: String, // z.B. "file", "contact", "calendar_event"
        pub id: String,     // Eindeutige ID innerhalb des Typs, kann auch Uuid sein
    }
    
    impl ResourceIdentifier {
        pub fn new(r#type: impl Into<String>, id: impl Into<String>) -> Self {
            Self {
                r#type: r#type.into(),
                id: id.into(),
            }
        }
    }
    ```
    
- **Zweck:** Allgemeiner Bezeichner für eine Ressource, die von KI-Funktionen oder anderen Diensten referenziert werden könnte.
- **Felder:**
    - `r#type: String` (öffentlich): Der Typ der Ressource.
    - `id: String` (öffentlich): Die eindeutige ID der Ressource innerhalb ihres Typs.
- **Invarianten:** `r#type` und `id` sollten nicht leer sein.

#### 1.4. Implementierungsschritte `domain::shared_types`

1. **Datei erstellen:** `novade-domain/src/shared_types.rs`.
2. **Typen definieren:** `ApplicationId`, `UserSessionState`, `ResourceIdentifier` wie oben spezifiziert.
3. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    pub mod shared_types;
    pub use shared_types::{ApplicationId, UserSessionState, ResourceIdentifier};
    ```
    
4. **Unit-Tests:**
    - Für `ResourceIdentifier::new`.
    - Für `UserSessionState`: `Default`-Implementierung.
    - Serialisierung/Deserialisierung der Typen testen.

---

### Modul 2: `domain::common_events`

Zweck: Definition von Event-Typen, die von mehreren Domänenmodulen ausgelöst oder konsumiert werden können.

Datei: src/common_events.rs

#### 2.1. Enum: `UserActivityType`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum UserActivityType {
        MouseMoved,
        MouseClicked,
        KeyPressed,
        WorkspaceSwitched,
        ApplicationFocused,
        // Weitere Typen nach Bedarf
    }
    ```
    
- **Zweck:** Kategorisierung von Benutzeraktivitäten.

#### 2.2. Struct: `UserActivityDetectedEvent`

- **Definition:**
    
    Rust
    
    ```
    use chrono::{DateTime, Utc};
    use serde::{Serialize, Deserialize};
    use super::shared_types::UserSessionState; // Oder spezifischere Aktivitätsdaten
    use super::UserActivityType; // aus demselben Modul
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct UserActivityDetectedEvent {
        pub timestamp: DateTime<Utc>,
        pub activity_type: UserActivityType,
        pub current_session_state: UserSessionState, // Beispielhafter zusätzlicher Kontext
        // Optional: pub source_component: String; // z.B. "system::input", "domain::workspaces"
        // Optional: pub details: serde_json::Value; // Für flexible Zusatzdaten
    }
    
    impl UserActivityDetectedEvent {
        pub fn new(activity_type: UserActivityType, current_session_state: UserSessionState) -> Self {
            Self {
                timestamp: Utc::now(),
                activity_type,
                current_session_state,
            }
        }
    }
    ```
    
- **Zweck:** Wird ausgelöst, wenn eine signifikante Benutzeraktivität erkannt wird. Kann für Idle-Detection, kontextsensitive Aktionen etc. verwendet werden.
- **Payload:**
    - `timestamp: DateTime<Utc>`
    - `activity_type: UserActivityType`
    - `current_session_state: UserSessionState`
- **Typische Publisher:** `system::input` (indirekt über Domänenadapter), `domain::workspaces::manager`.
- **Typische Subscriber:** `domain::user_centric_services` (für Idle-Timer der KI), `domain::power_management_policy` (für Idle-basierte Energiesparmaßnahmen), UI-Komponenten für Statusanzeigen.

#### 2.3. Struct: `SystemShutdownInitiatedEvent`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum ShutdownReason {
        UserRequest,
        PowerButton,
        LowBattery,
        SystemUpdate,
        Unknown,
    }
    
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct SystemShutdownInitiatedEvent {
        pub reason: ShutdownReason,
        pub delay_seconds: Option<u32>, // Optionale Verzögerung, bevor der Shutdown tatsächlich erfolgt
    }
    ```
    
- **Zweck:** Signalisiert, dass das System heruntergefahren oder neu gestartet wird.
- **Payload:**
    - `reason: ShutdownReason`
    - `delay_seconds: Option<u32>`
- **Typische Publisher:** Ein Systemdienst-Adapter in der Systemschicht (z.B. Reaktion auf `logind PrepareForShutdown`).
- **Typische Subscriber:** Alle Domänendienste, die Zustände speichern müssen (`ThemingEngine`, `WorkspaceManager`, `GlobalSettingsService`), Anwendungen (über Portals).

#### 2.4. Implementierungsschritte `domain::common_events`

1. **Datei erstellen:** `novade-domain/src/common_events.rs`.
2. **Typen definieren:** `UserActivityType`, `UserActivityDetectedEvent`, `ShutdownReason`, `SystemShutdownInitiatedEvent`.
3. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    pub mod common_events;
    pub use common_events::{UserActivityType, UserActivityDetectedEvent, ShutdownReason, SystemShutdownInitiatedEvent};
    ```
    
4. **Unit-Tests:**
    - Für `UserActivityDetectedEvent::new`.
    - Serialisierung/Deserialisierung der Event-Strukturen.

---

### Modul 3: `domain::theming`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

- Verwendung von `tokio::sync::broadcast` für `ThemeChangedEvent` ist bestätigt.
- Alle Ladeoperationen (`load_and_validate_token_files`, `load_and_validate_theme_files` in der Logik sowie `ThemingEngine::new` und `ThemingEngine::reload_themes_and_tokens` in der API) sind `async`, da sie potenziell Dateisystem-I/O beinhalten. Die Kernauflösungslogik (`resolve_tokens_for_config`) bleibt synchron, da sie CPU-gebunden ist.
- **Fehler-Enum `ThemingError`**:
    - Die Variante `FallbackThemeLoadError` erhält ein `#[source]`-Feld, da das Laden selbst fehlschlagen kann: `FallbackThemeLoadError { #[source] source: Box<dyn std::error::Error + Send + Sync + 'static> }`
    - `TokenResolutionError` hinzugefügt als allgemeinerer Fehler während der Auflösung. `#[error("Failed to resolve token '{token_id}': {message}")] TokenResolutionError { token_id: TokenIdentifier, message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
- **`ThemingEngineInternalState` Cache-Schlüssel:** Um `AccentColor` und `TokenSet` (für `custom_user_token_overrides`) hashbar zu machen, werden sie im Cache-Schlüssel durch einen Hash ihres Inhalts repräsentiert oder durch eine kanonische String-Repräsentation.
    - `AccentColor` wird im Cache-Key zu `Option<String>` (dem `value` der Akzentfarbe).
    - `custom_user_token_overrides: Option<TokenSet>` wird zu einem `u64`-Hash (z.B. mit `std::collections::hash_map::DefaultHasher`).
    - `resolved_state_cache: std::collections::HashMap<(ThemeIdentifier, ColorSchemeType, Option<String>, u64), AppliedThemeState>`

---

### Modul 4: `domain::global_settings_and_state_management`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

#### `domain::global_settings::types`

- **Enum `MouseAccelerationProfile`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
    pub enum MouseAccelerationProfile {
        Adaptive,
        Flat,
        // Custom(f32) // Direktes f32 ist problematisch für Default und Eq.
                       // Besser wäre eine separate Einstellung für den Custom-Wert.
    }
    impl Default for MouseAccelerationProfile { fn default() -> Self { Self::Adaptive } }
    // Zusätzliches Feld in InputBehaviorSettings:
    // pub custom_mouse_acceleration_value: Option<f32>; // Nur relevant wenn Profil Custom(TODO: Wie Custom hier darstellen ohne f32?)
    // Alternative für Custom: Keine f32 im Enum, sondern ein Flag und separates Feld
    // Oder der Custom-Wert wird direkt über einen Slider gesetzt und das Enum
    // dient nur zur Auswahl des Profils. Für die Domäne ist es einfacher, wenn
    // `Custom` keine Daten enthält und der Wert separat verwaltet wird.
    // Hier vereinfacht zu: `Custom` (ohne Wert im Enum)
    ```
    
    Überarbeitung: `MouseAccelerationProfile` enthält kein `f32`. Der Custom-Wert wird ein separates Feld in `InputBehaviorSettings`: `pub custom_mouse_acceleration_factor: Option<f32>; // Aktiv, wenn Profil auf Custom gesetzt ist` Das Enum `MouseAccelerationProfile` wird: `Adaptive, Flat, Custom`.

#### `domain::global_settings::paths`

- Der `SettingPath`-Enum muss vollständig für alle Einstellungen in `GlobalDesktopSettings` und dessen Unterstrukturen ausdefiniert werden.
    - Beispiel für `InputBehaviorSettings`:
        
        Rust
        
        ```
        // In paths.rs
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum InputBehaviorSettingPath {
            MouseAccelerationProfile,
            CustomMouseAccelerationFactor, // Neu
            MouseSensitivity,
            NaturalScrollingMouse,
            NaturalScrollingTouchpad,
            TapToClickTouchpad,
            TouchpadPointerSpeed,
            KeyboardRepeatDelayMs,
            KeyboardRepeatRateCps,
        }
        ```
        
    - Dies muss für `WorkspaceSettingPath`, `PowerManagementPolicySettingPath`, `DefaultApplicationsSettingPath` etc. analog erfolgen.

#### `domain::global_settings::service`

- **Trait `GlobalSettingsService`**:
    - `load_settings()` und `save_settings()` sind `async`.
    - `update_setting()` ist `async`.
    - `reset_to_defaults()` ist `async`.
    - `subscribe_to_changes()` wird `pub fn subscribe_to_setting_changes(&self) -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`
- **Implementierung `DefaultGlobalSettingsService`**:
    - Hält `persistence_provider: Arc<dyn SettingsPersistenceProvider>`.
    - Verwendet `tokio::sync::broadcast::Sender<SettingChangedEvent>`.
    - Die `update_setting` Logik zur Pfad-Navigation und Deserialisierung/Validierung muss robust implementiert werden. Hier ist ein Beispielansatz:
        - Eine interne Hilfsfunktion/Makro, die basierend auf `SettingPath` einen `&mut dyn std::any::Any` auf das Feld liefert und dessen `TypeId` kennt.
        - Dann `serde_json::from_value` verwenden und das Ergebnis dynamisch prüfen/casten und validieren.
        - Oder eine große `match`-Anweisung auf `SettingPath`.

#### `domain::global_settings::persistence_iface`

- **Trait `SettingsPersistenceProvider`**: Methoden sind `async`.
    - `async fn load_global_settings() -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - `async fn save_global_settings(settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`
- **Implementierung `FilesystemSettingsProvider`**:
    - Nutzt `Arc<dyn novade_core::config::ConfigServiceAsync>` (hypothetischer Trait für asynchronen Zugriff auf `core::config` oder direkt `novade_core::config::load_core_config_async` / `save_core_config_async`).
    - Die Methoden `load_global_settings` und `save_global_settings` werden `async`.

**Events:** `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`, `SettingsLoadedEvent { settings: GlobalDesktopSettings }`, `SettingsSavedEvent`.

---

### Modul 5: `domain::workspaces`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

- **`WorkspaceManager`**:
    - Der `event_publisher` wird `tokio::sync::broadcast::Sender<WorkspaceEvent>`.
    - Die Methode `subscribe_to_workspace_events()` gibt `tokio::sync::broadcast::Receiver<WorkspaceEvent>` zurück.
    - Alle Methoden, die potenziell die Konfiguration speichern (`create_workspace`, `delete_workspace`, `set_active_workspace`, `rename_workspace`, `set_workspace_layout`) oder laden (`new`), werden `async`, da `save_configuration` und `config_provider.load_workspace_config` `async` sind.
- **`FilesystemConfigProvider`**:
    - Nutzt einen asynchronen `core::config::ConfigServiceAsync` oder äquivalente `async` Funktionen zum Lesen/Schreiben von Dateien.
    - Die Methoden `load_workspace_config` und `save_workspace_config` sind `async`.

---

### Modul 6: `domain::window_management_policy`

Zweck: High-Level-Regeln für Fensterplatzierung, Tiling, Snapping, Gruppierung, Gap-Management.

Datei: src/window_management_policy/types.rs

#### 6.1. Typen

- **Enum `TilingMode`** (ersetzt `TilingLayoutType` für Klarheit, da Layouts spezifischer sind):
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum TilingMode {
        #[default]
        Manual, // Keine automatische Anordnung, Fenster sind floating
        Columns,
        Rows,
        Spiral, // Fibonacci-Spirale
        MaximizedFocused, // Aktives Fenster maximiert, andere ggf. versteckt/klein
    }
    ```
    
- **Struct `GapSettings`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct GapSettings {
        pub screen_outer_horizontal: u16, // Rand zum Bildschirm horizontal
        pub screen_outer_vertical: u16,   // Rand zum Bildschirm vertikal
        pub window_inner: u16,            // Abstand zwischen Fenstern
    }
    ```
    
- **Struct `WindowSnappingPolicy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct WindowSnappingPolicy {
        pub snap_to_screen_edges: bool,
        pub snap_to_other_windows: bool,
        pub snap_to_workspace_gaps: bool, // Snapping an virtuelle Gap-Grenzen
        pub snap_distance_px: u16,
    }
    ```
    
- **Struct `WindowGroupingPolicy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct WindowGroupingPolicy {
        pub enable_manual_grouping: bool,
        // Automatische Gruppierungsregeln (komplexer, für V2):
        // pub auto_group_by_application_id: bool,
        // pub auto_group_transients_with_parent: bool,
    }
    ```
    
- **Enum `NewWindowPlacementStrategy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum NewWindowPlacementStrategy {
        #[default]
        Smart,    // Versucht intelligent zu platzieren (z.B. nicht überlappend, im größten freien Bereich)
        Center,   // Zentriert auf dem Bildschirm/Workspace
        Cascade,  // Kaskadierend vom letzten Fenster
        UnderMouse, // Unter dem Mauszeiger (falls zutreffend)
    }
    ```
    
- **Enum `FocusStealingPreventionLevel`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum FocusStealingPreventionLevel {
        None,   // Jedes Fenster darf Fokus anfordern
        #[default]
        Moderate, // Verhindert aggressives Stehlen, erlaubt aber legitime Anforderungen
        Strict, // Nur explizite Benutzeraktion kann Fokus ändern
    }
    ```
    
- **Struct `FocusPolicy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct FocusPolicy {
        pub focus_follows_mouse: bool, // Mausbewegung ändert Fokus
        pub click_to_focus: bool,      // Klick erforderlich
        pub focus_new_windows_on_creation: bool, // Neue Fenster erhalten sofort Fokus
        pub focus_new_windows_on_workspace_switch: bool, // Beim Workspace-Wechsel wird das zuletzt fokussierte Fenster des Ziel-WS fokussiert
        pub focus_stealing_prevention: FocusStealingPreventionLevel,
    }
    ```
    
- **Struct `WindowPolicyOverrides`** (pro Fenster, optional, von Benutzer oder Regeln setzbar):
    
    Rust
    
    ```
    use crate::core::types::RectInt; // Aus der Kernschicht
    use uuid::Uuid;
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
    pub struct WindowPolicyOverrides {
        pub preferred_tiling_mode: Option<TilingMode>,
        pub is_always_floating: Option<bool>, // Überschreibt Workspace-Tiling-Modus
        pub fixed_size: Option<(u32, u32)>, // Breite, Höhe
        pub fixed_position: Option<(i32, i32)>, // x, y (relativ zum Workspace)
        pub prevent_focus_stealing: Option<bool>, // Individuelle Überschreibung der globalen Policy
        pub min_size_override: Option<(u32, u32)>,
        pub max_size_override: Option<(u32, u32)>,
    }
    ```
    
    - Dieses Struct würde nicht direkt in `GlobalDesktopSettings` sein, sondern dynamisch pro Fenster verwaltet (z.B. in einer `HashMap<WindowIdentifier, WindowPolicyOverrides>`).
- **Struct `WorkspaceWindowLayout`**: Repräsentiert das berechnete Layout für einen Workspace.
    
    Rust
    
    ```
    use crate::core::types::RectInt;
    use crate::domain::workspaces::core::types::WindowIdentifier;
    use std::collections::HashMap;
    
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct WorkspaceWindowLayout {
        // Fenster-ID zu seiner berechneten Geometrie (Position und Größe)
        pub window_geometries: HashMap<WindowIdentifier, RectInt>,
        // Bereich, der vom Layout genutzt wird (kann kleiner sein als available_space, z.B. bei zentrierten Layouts)
        pub occupied_area: Option<RectInt>,
    }
    ```
    

**Datei:** `src/window_management_policy/errors.rs`

- **Enum `WindowPolicyError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use crate::domain::workspaces::core::types::WorkspaceId;
    
    #[derive(Debug, Error)]
    pub enum WindowPolicyError {
        #[error("Failed to calculate layout for workspace '{workspace_id}': {reason}")]
        LayoutCalculationError { workspace_id: WorkspaceId, reason: String },
        #[error("Invalid window management policy configuration: {setting_path}, reason: {reason}")]
        InvalidPolicyConfiguration { setting_path: String, reason: String },
        #[error("Window referenced by identifier '{0:?}' not found for policy application.")]
        WindowNotFoundForPolicy(crate::domain::workspaces::core::types::WindowIdentifier),
        #[error("An internal error occurred in window management policy: {0}")]
        InternalError(String),
    }
    ```
    

**Datei:** `src/window_management_policy/service.rs` (oder `mod.rs`)

- **Trait `WindowManagementPolicyService`**:
    
    Rust
    
    ```
    use async_trait::async_trait;
    use std::collections::HashMap;
    use crate::core::types::{RectInt, Size, Point};
    use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};
    use super::types::{TilingMode, GapSettings, WindowSnappingPolicy, NewWindowPlacementStrategy, WorkspaceWindowLayout, WindowPolicyOverrides};
    use super::errors::WindowPolicyError;
    use crate::domain::global_settings_and_state_management::types::GlobalDesktopSettings; // Für den Zugriff auf globale Policies
    
    #[async_trait]
    pub trait WindowManagementPolicyService: Send + Sync {
        /// Berechnet das Layout für alle Fenster auf einem gegebenen Workspace.
        /// `windows_on_workspace`: Liste der Fenster-IDs auf dem Workspace und ihre aktuellen (oder gewünschten Mindest-)Größen.
        /// `workspace_tiling_mode`: Der vom Workspace gewünschte Tiling-Modus.
        /// `global_settings`: Aktuelle globale Einstellungen, die Policies enthalten.
        /// `window_specific_overrides`: Map von Fenster-IDs zu ihren spezifischen Policy-Überschreibungen.
        async fn calculate_workspace_layout(
            &self,
            workspace_id: WorkspaceId,
            windows_on_workspace: &[(WindowIdentifier, Size<u32>)], // Fenster und ihre (Mindest-)Größen
            available_area: RectInt, // Der für Fenster verfügbare Bereich auf dem Workspace
            workspace_tiling_mode: TilingMode, // Vom Workspace Manager festgelegter Modus
            gap_settings: &GapSettings, // Aktuelle Gap-Einstellungen
            window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>
        ) -> Result<WorkspaceWindowLayout, WindowPolicyError>;
    
        /// Bestimmt die initiale Geometrie und den Zustand für ein neues Fenster.
        async fn get_initial_window_geometry(
            &self,
            window_id: &WindowIdentifier,
            requested_size: Option<Size<u32>>, // Vom Fenster gewünschte Größe
            is_transient_for: Option<&WindowIdentifier>, // Elternfenster für transiente Fenster
            workspace_id: WorkspaceId,
            active_layout_on_workspace: &WorkspaceWindowLayout, // Aktuelles Layout des Ziel-Workspace
            available_area: RectInt,
            placement_strategy: NewWindowPlacementStrategy,
            window_specific_overrides: &Option<WindowPolicyOverrides>
        ) -> Result<RectInt, WindowPolicyError>;
    
        /// Berechnet ein potenzielles "Snap"-Ziel für ein sich bewegendes oder größenveränderndes Fenster.
        async fn calculate_snap_target(
            &self,
            moving_window_id: &WindowIdentifier,
            current_geometry: RectInt, // Aktuelle Geometrie des bewegten Fensters
            other_windows_on_workspace: &[(&WindowIdentifier, &RectInt)], // Andere Fenster
            workspace_area: RectInt, // Gesamtbereich des Workspace
            snapping_policy: &WindowSnappingPolicy,
            gap_settings: &GapSettings
        ) -> Option<RectInt>;
    
        /// Gibt die Fokus-Policy zurück.
        async fn get_focus_policy(&self, global_settings: &GlobalDesktopSettings) -> FocusPolicy;
    
        /// Gibt die Policy für neue Fensterplatzierung zurück.
        async fn get_new_window_placement_strategy(&self, global_settings: &GlobalDesktopSettings) -> NewWindowPlacementStrategy;
    
        // Ggf. Methoden zum Abrufen spezifischer Policy-Objekte wie GapSettings, WindowSnappingPolicy etc.
        // basierend auf global_settings oder Workspace-spezifischen Einstellungen.
    }
    ```
    
- **Implementierung `DefaultWindowManagementPolicyService`**:
    - **Konstruktor:** `pub fn new(settings_service: Arc<dyn GlobalSettingsService>) -> Self`
        - Hält eine Referenz (`Arc`) zum `GlobalSettingsService`, um bei Bedarf aktuelle Policy-Einstellungen abzurufen.
    - **`calculate_workspace_layout` Logik:**
        1. Ruft globale Einstellungen (Tiling-Modus-Präferenz, Gaps) vom `settings_service` ab (oder erhält sie als Parameter).
        2. Filtert Fenster heraus, die `is_always_floating == Some(true)` haben. Diese werden ignoriert für Tiling.
        3. Basierend auf dem `workspace_tiling_mode` (und ggf. Fenster-spezifischen `preferred_tiling_mode` Overrides):
            - `TilingMode::Manual`: Gibt aktuelle Geometrien zurück (oder platziert sie initial gemäß `NewWindowPlacementStrategy`).
            - `TilingMode::Columns`: Teilt `available_area` (unter Berücksichtigung von `gap_settings`) vertikal für jedes nicht-floating Fenster auf. Berücksichtigt `min_size_override`.
            - `TilingMode::Rows`: Teilt horizontal auf.
            - `TilingMode::Spiral`: Implementiert Fibonacci-Spiral-Layout-Algorithmus.
            - `TilingMode::MaximizedFocused`: Macht das "aktive" Fenster (muss als Parameter übergeben werden oder heuristisch bestimmt werden) bildschirmfüllend (innerhalb `available_area` minus Gaps), andere minimiert/versteckt.
        4. Floating-Fenster werden über den gekachelten Fenstern platziert, ihre Positionen bleiben relativ erhalten oder werden initial gemäß `get_initial_window_geometry` platziert.
        5. Erstellt und gibt `WorkspaceWindowLayout` zurück.
    - **`get_initial_window_geometry` Logik:**
        1. Berücksichtigt `requested_size`, `is_transient_for` (z.B. zentriert über Parent).
        2. Wendet `placement_strategy` an (`Smart` könnte versuchen, Überlappungen mit `active_layout_on_workspace` zu vermeiden).
        3. Berücksichtigt `window_specific_overrides.fixed_position` und `fixed_size`.
    - **`calculate_snap_target` Logik:**
        1. Prüft Distanz zu Bildschirmrändern, Gap-Grenzen und Kanten/Mittelpunkten anderer Fenster.
        2. Wenn innerhalb `snap_distance_px`, gibt die neue "eingerastete" `RectInt` zurück.

**Abhängigkeiten & Interaktion:**

- Liest Policy-Konfigurationen von `domain::global_settings_service`.
- Wird von der Systemschicht (`system::window_mechanics`) aufgerufen, um Layouts und Platzierungen zu bestimmen.
- Könnte von `domain::workspaces::manager` Events abonnieren (z.B. `WindowAddedToWorkspaceEvent`), um Layouts proaktiv neu zu berechnen.

**Implementierungsschritte:**

1. `types.rs` und `errors.rs` definieren.
2. `service.rs`: `WindowManagementPolicyService`-Trait definieren.
3. `DefaultWindowManagementPolicyService` implementieren:
    - Konstruktor.
    - Implementierung der Layout-Algorithmen (Columns, Rows, Spiral etc.) als private Hilfsfunktionen.
    - Implementierung der Snapping-Logik.
    - Implementierung der öffentlichen Trait-Methoden.
4. Unit-Tests für jeden Layout-Algorithmus, Snapping-Logik und die Service-Methoden mit verschiedenen Szenarien und Konfigurationen.

---

### Modul 7: `domain::user_centric_services`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

#### `domain::user_centric_services::ai_interaction`

- **Strukturen/Enums:** Wie definiert in.
- **`AIInteractionLogicService` Trait & Implementierung `DefaultAIInteractionLogicService`**:
    - Methoden sind `async`.
    - `initiate_interaction`: Benötigt ggf. Zugriff auf `GlobalSettingsService` für Standardmodell oder globale KI-Einstellungen.
    - `provide_consent`: Muss den `AIConsentStatus` im `AIInteractionContext` und ggf. einen persistenten `AIConsent`-Eintrag aktualisieren.
    - `store_consent` / `get_all_user_consents`: Delegieren die Persistenz an einen `AIConsentProvider` (neuer Trait, ähnlich `SettingsPersistenceProvider`, interagiert mit `core::config`).
    - `load_model_profiles`: Lädt von `core::config` über einen `AIModelProfileProvider`.
- **Events:** `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent` (gesendet via `tokio::sync::broadcast`).

#### `domain::user_centric_services::notifications_core`

- **Strukturen/Enums:** Wie definiert in.
- **`NotificationService` Trait & Implementierung `DefaultNotificationService`**:
    - Methoden sind `async`.
    - `post_notification`: Berücksichtigt `DoNotDisturbModeChangedEvent` und DND-Status. Interagiert mit `domain::notifications_rules::NotificationRulesEngine` (wird als Abhängigkeit injiziert), um Benachrichtigungen vor dem Posten zu verarbeiten.
- **Events:** `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent` (gesendet via `tokio::sync::broadcast`).

**Neue Sub-Traits/Provider für Persistenz:**

- `domain::user_centric_services::ai_interaction::persistence_iface`:
    - `AIConsentProvider`: `async fn load_consents(user_id: &str) -> Result<Vec<AIConsent>, AIInteractionError>`, `async fn save_consent(consent: &AIConsent) -> Result<(), AIInteractionError>`.
    - `AIModelProfileProvider`: `async fn load_model_profiles() -> Result<Vec<AIModelProfile>, AIInteractionError>`.
    - Implementierungen nutzen `core::config`.

---

### Modul 8: `domain::notifications_rules`

Bestehende Spezifikation: Übernommen und integriert aus der vorherigen Antwort.

Anpassungen/Verfeinerungen:

#### `domain::notifications_rules::engine` (oder `service.rs`)

- **Struct `NotificationRulesEngine`**:
    - Konstruktor `pub async fn new(rules_provider: Arc<dyn NotificationRulesProvider>, settings_service: Arc<dyn GlobalSettingsService>) -> Self`
    - `load_rules()`-Methode, um Regeln vom `rules_provider` neu zu laden.
    - `process_notification`: Nimmt `&Notification` und gibt `Result<Option<Notification>, NotificationRulesError>` zurück (None, wenn unterdrückt, Some(modified_notification) wenn erlaubt/geändert).

#### `domain::notifications_rules::persistence_iface`

- **Trait `NotificationRulesProvider`**:
    - `async fn load_rules() -> Result<NotificationRuleSet, NotificationRulesError>`
    - `async fn save_rules(rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`
- Implementierung `FilesystemNotificationRulesProvider` nutzt `core::config`.

**Interaktion:**

- Der `notifications_core::DefaultNotificationService` wird eine Instanz des `NotificationRulesEngine` halten und `process_notification` aufrufen, bevor eine Benachrichtigung tatsächlich "gepostet" wird (d.h. bevor das `NotificationPostedEvent` ausgelöst und die Benachrichtigung den aktiven/historischen Listen hinzugefügt wird).
- Der `NotificationRulesEngine` benötigt Zugriff auf den `GlobalSettingsService`, um `SettingIsTrue`-Bedingungen auszuwerten.

---

**Finale `novade-domain/src/lib.rs` (Struktur):**

Rust

```
// novade-domain/src/lib.rs

// Kern-Abhängigkeiten (Beispiel)
// use novade_core; // Wird implizit durch Pfade wie crate::core::... genutzt

// Öffentliche Module deklarieren
pub mod common_events;
pub mod global_settings_and_state_management;
pub mod notifications_rules;
pub mod shared_types;
pub mod theming;
pub mod user_centric_services;
pub mod window_management_policy;
pub mod workspaces;

// Öffentliche API Re-Exports (Beispiele)
pub use common_events::{UserActivityDetectedEvent, SystemShutdownInitiatedEvent, /* ... */};
pub use global_settings_and_state_management::{
    GlobalSettingsService, GlobalDesktopSettings, SettingPath, GlobalSettingsError,
    SettingsPersistenceProvider, /* ... Untertypen und Enums ... */
};
pub use theming::{ThemingEngine, ThemeDefinition, AppliedThemeState, ThemingError, /* ... */};
pub use workspaces::{
    WorkspaceManager, Workspace, WorkspaceId, WindowIdentifier, WorkspaceEvent, WorkspaceLayoutType,
    WorkspaceConfigProvider, WorkspaceCoreError, WindowAssignmentError, WorkspaceManagerError, WorkspaceConfigError, /* ... */
};
pub use user_centric_services::{
    AIInteractionLogicService, NotificationService, AIInteractionContext, Notification, AIConsent, AIModelProfile,
    AIInteractionError, NotificationError, /* ... Events und andere Typen ... */
    // Ggf. auch die Provider-Traits für Persistenz
    ai_interaction::persistence_iface::{AIConsentProvider, AIModelProfileProvider},
};
pub use notifications_rules::{
    NotificationRulesEngine, NotificationRule, RuleCondition, RuleAction, NotificationRulesError,
    persistence_iface::NotificationRulesProvider,
};
pub use window_management_policy::{
    WindowManagementPolicyService, TilingMode, GapSettings, WorkspaceWindowLayout, WindowPolicyError, /* ... */
};
pub use shared_types::{ApplicationId, UserSessionState, ResourceIdentifier};

// Initialisierungsfunktion für die gesamte Domänenschicht könnte hier existieren,
// die alle Services instanziiert und ggf. miteinander verbindet.
// pub async fn initialize_domain_layer(
//     core_config_service: Arc<dyn novade_core::config::ConfigServiceAsync>,
//     // ... andere notwendige Abhängigkeiten aus der Kernschicht ...
// ) -> Result<DomainServices, DomainInitializationError> {
//     // ... Instanziiere alle Provider und Services ...
//     // Beispiel:
//     // let settings_persistence_provider = Arc::new(global_settings_and_state_management::FilesystemSettingsProvider::new(core_config_service.clone()));
//     // let settings_service = Arc::new(global_settings_and_state_management::DefaultGlobalSettingsService::new(settings_persistence_provider));
//     // settings_service.load_settings().await?;
//     // ...
//     // Ok(DomainServices { settings_service, ... })
// }

// pub struct DomainServices {
//     pub settings_service: Arc<dyn GlobalSettingsService>,
//     pub theming_engine: Arc<ThemingEngine>,
//     pub workspace_manager: Arc<WorkspaceManager>,
//     // ... andere Services
// }

// #[derive(Debug, thiserror::Error)]
// pub enum DomainInitializationError {
//     #[error("Failed to initialize settings service: {0}")]
//     SettingsInitError(#[from] global_settings_and_state_management::GlobalSettingsError),
//     // ... andere Initialisierungsfehler
// }
```

Diese umfassende Spezifikation für die Domänenschicht sollte eine sehr solide Grundlage für die Implementierung bieten. Jedes Modul ist klar abgegrenzt, und die Interaktionen sowie Abhängigkeiten sind definiert. Der nächste Schritt wäre, für jedes dieser Module die detaillierten Implementierungsschritte (wie im Beispiel für `core::types` gezeigt) und die Unit-Tests vollständig auszuarbeiten.

---

## Ultra-Feinspezifikation und Implementierungsplan: Domänenschicht (`novade-domain` Crate)

Allgemeine Entwicklungsrichtlinien für die Domänenschicht: (Siehe vorherige Antwort für eine vollständige Liste)

Kurzfassung: Rust (Edition 2021+), UI- und Systemunabhängigkeit, Fokus auf Geschäftslogik, APIs über async_trait Traits, threadsichere Zustandsverwaltung, tokio für Asynchronität und Events, thiserror für Fehler, serde für Serialisierung, Nutzung von novade-core.

**Cargo.toml für `novade-domain`:**

Ini, TOML

```
[package]
name = "novade-domain"
version = "0.1.0"
edition = "2021" # oder neuer

[dependencies]
novade-core = { path = "../novade-core" } # Pfad anpassen
thiserror = "1.0.58" # Aktuelle Version prüfen
serde = { version = "1.0.197", features = ["derive"] } # Aktuelle Version prüfen
serde_json = "1.0.115" # Aktuelle Version prüfen
uuid = { version = "1.8.0", features = ["v4", "serde"] } # Aktuelle Version prüfen
chrono = { version = "0.4.38", features = ["serde"] } # Aktuelle Version prüfen
async-trait = "0.1.79" # Aktuelle Version prüfen
tokio = { version = "1.37.0", features = ["sync", "macros", "rt-multi-thread"] } # Aktuelle Version prüfen, rt-multi-thread für broadcast ggf.
tracing = "0.1.40" # Aktuelle Version prüfen

# Optional, falls für spezifische Algorithmen benötigt
# parking_lot = "0.12" # Für Mutex/RwLock Alternativen
# im = { version = "15.1.0", features = ["serde"] } # Für persistente Datenstrukturen, falls HashMap/Vec nicht ausreichen
```

---

### Modul 1: `domain::shared_types`

Zweck: Definition von domänenspezifischen Typen, die von mehreren Domänenmodulen verwendet werden, aber nicht allgemein genug für core::types sind. Diese Typen sind oft einfache Wrapper oder Enums, die die Semantik im Domänencode verbessern.

Verantwortlichkeiten: Bereitstellung dieser gemeinsam genutzten Typen.

Design-Rationale: Zentralisierung vermeidet Duplikation und fördert Konsistenz.

**Datei:** `src/shared_types.rs`

#### 1.1. Type Alias: `ApplicationId`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Eindeutiger Bezeichner für eine Anwendung.
    ///
    /// Repräsentiert typischerweise einen Reverse-DNS-Namen (z.B. "org.novade.FileExplorer")
    /// oder den Namen der .desktop-Datei ohne Erweiterung.
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default, PartialOrd, Ord)]
    pub struct ApplicationId(String);
    
    impl ApplicationId {
        /// Erstellt eine neue `ApplicationId`.
        ///
        /// # Panics
        /// Paniert, wenn die `id` leer ist (im Debug-Modus).
        pub fn new(id: impl Into<String>) -> Self {
            let id_str = id.into();
            debug_assert!(!id_str.is_empty(), "ApplicationId darf nicht leer sein.");
            Self(id_str)
        }
    
        /// Gibt die `ApplicationId` als String-Slice zurück.
        pub fn as_str(&self) -> &str {
            &self.0
        }
    }
    
    impl From<String> for ApplicationId {
        fn from(s: String) -> Self {
            debug_assert!(!s.is_empty(), "ApplicationId (from String) darf nicht leer sein.");
            Self(s)
        }
    }
    
    impl From<&str> for ApplicationId {
        fn from(s: &str) -> Self {
            debug_assert!(!s.is_empty(), "ApplicationId (from &str) darf nicht leer sein.");
            Self(s.to_string())
        }
    }
    
    impl std::fmt::Display for ApplicationId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.0)
        }
    }
    ```
    
- **Zweck:** Eindeutiger Bezeichner für eine Anwendung.
- **Invarianten:** Der interne String darf nicht leer sein. Diese Invariante wird durch `debug_assert!` in `new()` und `From`-Implementierungen im Debug-Modus geprüft. Für Release-Builds wird auf die Korrektheit der Eingabe vertraut oder höhere Schichten validieren.
- **Methoden:** `new(id: impl Into<String>) -> Self`, `as_str(&self) -> &str`.
- **Trait-Implementierungen:** `From<String>`, `From<&str>`, `std::fmt::Display`.
- **Ableitungen:** `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default, PartialOrd, Ord`.

#### 1.2. Enum: `UserSessionState`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Repräsentiert den aktuellen Zustand der Benutzersitzung aus Sicht der Domäne.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum UserSessionState {
        #[default]
        Active, // Normale Benutzersitzung, Benutzer ist aktiv
        Locked, // Sitzung gesperrt (z.B. durch Bildschirmsperre)
        Idle,   // Benutzer ist für eine definierte Zeit inaktiv
    }
    ```
    
- **Zweck:** Abstraktion des Sitzungszustands.
- **Initialwert:** `Active`.
- **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.

#### 1.3. Struct: `ResourceIdentifier`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use uuid::Uuid; // Wird für das Beispiel eines Uuid-basierten IDs verwendet
    
    /// Allgemeiner Bezeichner für eine Ressource.
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct ResourceIdentifier {
        /// Der Typ der Ressource (z.B. "file", "contact", "calendar-event", "web-url").
        /// Sollte ein konsistenter, definierter Satz von Strings sein.
        pub r#type: String,
        /// Die eindeutige ID der Ressource innerhalb ihres Typs.
        /// Dies kann ein Pfad, eine URL, eine Datenbank-ID oder eine UUID sein.
        pub id: String,
        /// Optionale menschenlesbare Beschreibung oder Name der Ressource.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
    }
    
    impl ResourceIdentifier {
        /// Erstellt einen neuen `ResourceIdentifier`.
        ///
        /// # Panics
        /// Paniert, wenn `resource_type` oder `resource_id` leer sind (im Debug-Modus).
        pub fn new(resource_type: impl Into<String>, resource_id: impl Into<String>, label: Option<String>) -> Self {
            let type_str = resource_type.into();
            let id_str = resource_id.into();
            debug_assert!(!type_str.is_empty(), "ResourceIdentifier type darf nicht leer sein.");
            debug_assert!(!id_str.is_empty(), "ResourceIdentifier id darf nicht leer sein.");
            Self {
                r#type: type_str,
                id: id_str,
                label,
            }
        }
    
        /// Erstellt einen `ResourceIdentifier` für eine Datei.
        pub fn file(path: impl Into<String>, label: Option<String>) -> Self {
            Self::new("file", path, label)
        }
    
        /// Erstellt einen `ResourceIdentifier` für eine URL.
        pub fn url(url_str: impl Into<String>, label: Option<String>) -> Self {
            Self::new("web-url", url_str, label)
        }
    
        /// Erstellt einen `ResourceIdentifier` mit einer generierten UUID.
        pub fn new_uuid(resource_type: impl Into<String>, label: Option<String>) -> Self {
            Self::new(resource_type, Uuid::new_v4().to_string(), label)
        }
    }
    ```
    
- **Zweck:** Allgemeiner, typisierter Bezeichner für Ressourcen.
- **Felder:**
    - `r#type: String` (öffentlich)
    - `id: String` (öffentlich)
    - `label: Option<String>` (öffentlich, optional)
- **Invarianten:** `r#type` und `id` dürfen nicht leer sein (geprüft via `debug_assert!`).
- **Methoden:** `new(...)`, `file(...)`, `url(...)`, `new_uuid(...)`.
- **Ableitungen:** `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize`.

#### 1.4. Implementierungsschritte `domain::shared_types`

1. **Datei erstellen:** `novade-domain/src/shared_types.rs`.
2. **Typen definieren:** `ApplicationId`, `UserSessionState`, `ResourceIdentifier` wie oben spezifiziert, inklusive aller Methoden, Trait-Implementierungen und `serde`-Attributen.
3. **Unit-Tests erstellen (`novade-domain/src/shared_types.rs` -> `#[cfg(test)] mod tests { ... }`):**
    - Für `ApplicationId`:
        - `test_application_id_new()`: Erstellung, `as_str()`.
        - `test_application_id_from_string()`: Konvertierung.
        - `test_application_id_from_str()`: Konvertierung.
        - `test_application_id_display()`: `Display`-Trait.
        - `test_application_id_serde()`: Serialisierung zu JSON und Deserialisierung.
        - `#[should_panic]` (im Debug-Modus) für `ApplicationId::new("")`.
    - Für `UserSessionState`:
        - `test_user_session_state_default()`: Prüft `Active` als Default.
        - `test_user_session_state_serde()`: Serialisierung/Deserialisierung.
    - Für `ResourceIdentifier`:
        - `test_resource_identifier_new()`: Korrekte Erstellung.
        - `test_resource_identifier_file_url_uuid()`: Hilfskonstruktoren.
        - `test_resource_identifier_serde()`: Serialisierung/Deserialisierung (auch mit `Option<String>` für Label).
        - `#[should_panic]` (im Debug-Modus) für `ResourceIdentifier::new("", "id", None)` und `ResourceIdentifier::new("type", "", None)`.
4. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    // In novade-domain/src/lib.rs
    pub mod shared_types;
    // Re-export für einfacheren Zugriff von anderen Crates/Modulen
    pub use shared_types::{ApplicationId, UserSessionState, ResourceIdentifier};
    ```
    

---

### Modul 2: `domain::common_events`

Zweck: Definition von Event-Typen, die von mehreren Domänenmodulen ausgelöst oder konsumiert werden können oder die als generische Payloads dienen.

Design-Rationale: Fördert lose Kopplung und eine klare Ereignis-basierte Architektur. Events sind Datenstrukturen, die Zustandsänderungen oder signifikante Vorkommnisse repräsentieren.

Event-Mechanismus: Es wird tokio::sync::broadcast für die Verteilung dieser Events angenommen, wo ein globaler oder Service-spezifischer broadcast::Sender verwendet wird.

**Datei:** `src/common_events.rs`

#### 2.1. Enum: `UserActivityType`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Kategorisiert die Art einer erkannten Benutzeraktivität.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum UserActivityType {
        MouseMoved,
        MouseClicked,
        MouseWheelScrolled,
        KeyPressed,
        TouchInteraction, // Generisch für Touch-Events
        WorkspaceSwitched,
        ApplicationFocused,
        WindowOpened,
        WindowClosed,
        // Weitere spezifische Aktivitätstypen nach Bedarf
    }
    ```
    
- **Zweck:** Granulare Unterscheidung von Benutzeraktivitäten für verschiedene Zwecke (z.B. Idle-Detection, kontextuelle Aktionen).
- **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`.

#### 2.2. Struct: `UserActivityDetectedEvent`

- **Definition:**
    
    Rust
    
    ```
    use chrono::{DateTime, Utc};
    use serde::{Serialize, Deserialize};
    use super::shared_types::{UserSessionState, ApplicationId}; // Pfad anpassen
    use super::UserActivityType; // Aus demselben Modul
    use uuid::Uuid;
    
    /// Wird ausgelöst, wenn eine signifikante Benutzeraktivität im System erkannt wird.
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct UserActivityDetectedEvent {
        /// Eindeutige ID des Events.
        pub event_id: Uuid,
        /// Zeitstempel der Aktivitätserkennung.
        pub timestamp: DateTime<Utc>,
        /// Art der erkannten Aktivität.
        pub activity_type: UserActivityType,
        /// Der Sitzungszustand des Benutzers zum Zeitpunkt der Aktivität.
        pub current_session_state: UserSessionState,
        /// Optional: ID der Anwendung, die im Fokus war oder die Aktivität ausgelöst hat.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_application_id: Option<ApplicationId>,
        /// Optional: ID des Workspaces, auf dem die Aktivität stattfand.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_workspace_id: Option<crate::workspaces::core::types::WorkspaceId>, // Pfad anpassen
        // Zukünftig: Optionale, spezifischere Daten zum Event, z.B. welcher Key gedrückt wurde (mit Bedacht auf PII)
        // pub details: Option<serde_json::Value>,
    }
    
    impl UserActivityDetectedEvent {
        pub fn new(
            activity_type: UserActivityType,
            current_session_state: UserSessionState,
            active_application_id: Option<ApplicationId>,
            active_workspace_id: Option<crate::workspaces::core::types::WorkspaceId> // Pfad anpassen
        ) -> Self {
            Self {
                event_id: Uuid::new_v4(),
                timestamp: Utc::now(),
                activity_type,
                current_session_state,
                active_application_id,
                active_workspace_id,
            }
        }
    }
    ```
    
- **Zweck:** Zentrales Event zur Signalisierung von Benutzeraktivität.
- **Payload:**
    - `event_id: Uuid` (öffentlich): Eindeutige ID für das Event selbst.
    - `timestamp: DateTime<Utc>` (öffentlich)
    - `activity_type: UserActivityType` (öffentlich)
    - `current_session_state: UserSessionState` (öffentlich)
    - `active_application_id: Option<ApplicationId>` (öffentlich, optional)
    - `active_workspace_id: Option<WorkspaceId>` (öffentlich, optional, Typ aus `domain::workspaces`)
- **Typische Publisher:** Ein Adapter in der Systemschicht, der rohe Input-Events von `system::input` konsumiert und aggregiert, oder spezifische Domänendienste wie `domain::workspaces::manager` bei einem Workspace-Wechsel.
- **Typische Subscriber:**
    - `domain::user_centric_services::ai_interaction` (z.B. für Reset von Idle-Timern für KI-Kontext-Timeouts).
    - `domain::power_management_policy` (für System-Idle-Detection und Auslösen von Energiesparmaßnahmen).
    - UI-Komponenten, die auf Benutzeraktivität reagieren (z.B. "Zuletzt aktiv"-Anzeigen, obwohl dies eher UI-Zustand ist).
    - Logging/Auditing-Systeme.

#### 2.3. Enum: `ShutdownReason`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Definiert den Grund für ein System-Shutdown oder einen Neustart.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum ShutdownReason {
        #[default]
        UserRequest,     // Direkte Anforderung durch den Benutzer (z.B. über Menü)
        PowerButtonPress,  // Physischer Power-Button wurde gedrückt
        LowBattery,        // Kritischer Batteriestand erfordert Shutdown
        SystemUpdate,      // Shutdown/Neustart aufgrund eines Systemupdates
        ApplicationRequest,// Eine Anwendung hat einen Shutdown angefordert (selten, braucht spezielle Rechte)
        OsError,           // Kritischer OS-Fehler erfordert Neustart (hypothetisch für Domäne)
        Unknown,           // Unbekannter Grund
    }
    ```
    
- **Zweck:** Klare Angabe des Grundes für einen Shutdown.
- **Initialwert:** `UserRequest`.
- **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.

#### 2.4. Struct: `SystemShutdownInitiatedEvent`

- **Definition:**
    
    Rust
    
    ```
    use chrono::{DateTime, Utc};
    use serde::{Serialize, Deserialize};
    use super::ShutdownReason; // Aus demselben Modul
    use uuid::Uuid;
    
    /// Wird ausgelöst, wenn der Prozess des Herunterfahrens oder Neustarts des Systems initiiert wird.
    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    pub struct SystemShutdownInitiatedEvent {
        pub event_id: Uuid,
        pub timestamp: DateTime<Utc>,
        /// Der Grund für den Shutdown.
        pub reason: ShutdownReason,
        /// Gibt an, ob es sich um einen Neustart (`true`) oder ein Herunterfahren (`false`) handelt.
        pub is_reboot: bool,
        /// Optionale Verzögerung in Sekunden, bevor der eigentliche Shutdown/Neustart ausgeführt wird.
        /// Dies gibt Anwendungen Zeit, ihre Daten zu speichern.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delay_seconds: Option<u32>,
        /// Optionale Nachricht, die dem Benutzer angezeigt werden könnte.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
    }
    
    impl SystemShutdownInitiatedEvent {
        pub fn new(reason: ShutdownReason, is_reboot: bool, delay_seconds: Option<u32>, message: Option<String>) -> Self {
            Self {
                event_id: Uuid::new_v4(),
                timestamp: Utc::now(),
                reason,
                is_reboot,
                delay_seconds,
                message,
            }
        }
    }
    ```
    
- **Zweck:** Signalisiert bevorstehenden System-Shutdown/Neustart.
- **Payload:**
    - `event_id: Uuid` (öffentlich)
    - `timestamp: DateTime<Utc>` (öffentlich)
    - `reason: ShutdownReason` (öffentlich)
    - `is_reboot: bool` (öffentlich): `true` für Neustart, `false` für Herunterfahren.
    - `delay_seconds: Option<u32>` (öffentlich, optional)
    - `message: Option<String>` (öffentlich, optional)
- **Typische Publisher:** Ein Adapter in der Systemschicht, der auf Signale von `logind` (z.B. `PrepareForShutdown(true/false)`) reagiert.
- **Typische Subscriber:**
    - Alle Domänendienste, die einen sauberen Shutdown-Prozess benötigen, um Zustände zu speichern (z.B. `GlobalSettingsService::save_settings`, `WorkspaceManager::save_configuration`, `ThemingEngine` falls er Caches persistiert, `AIInteractionLogicService` für `AIConsent`).
    - Die Systemschicht selbst, um z.B. Anwendungen über XDG Portals oder andere Mechanismen zu benachrichtigen.
    - Die UI-Schicht, um einen Shutdown-Dialog anzuzeigen.

#### 2.5. Implementierungsschritte `domain::common_events`

1. **Datei erstellen:** `novade-domain/src/common_events.rs`.
2. **Typen definieren:** `UserActivityType`, `UserActivityDetectedEvent`, `ShutdownReason`, `SystemShutdownInitiatedEvent` wie oben spezifiziert, inklusive aller Methoden und `serde`-Attribute.
3. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    // In novade-domain/src/lib.rs
    pub mod common_events;
    // Re-export für einfacheren Zugriff
    pub use common_events::{
        UserActivityType, UserActivityDetectedEvent,
        ShutdownReason, SystemShutdownInitiatedEvent,
    };
    ```
    
4. **Unit-Tests erstellen (`novade-domain/src/common_events.rs` -> `#[cfg(test)] mod tests { ... }`):**
    - Für `UserActivityDetectedEvent`:
        - `test_user_activity_event_new()`: Korrekte Initialisierung von `event_id` und `timestamp`.
        - `test_user_activity_event_serde()`: Serialisierung/Deserialisierung.
    - Für `SystemShutdownInitiatedEvent`:
        - `test_system_shutdown_event_new()`: Korrekte Initialisierung.
        - `test_system_shutdown_event_serde()`: Serialisierung/Deserialisierung.
    - Für Enums: Teste `Default`-Implementierung und Serialisierung/Deserialisierung.

---

### Modul 3: `domain::theming`

Bestehende Spezifikation: und vorherige Antwort.

Verantwortlichkeiten: Logik für Erscheinungsbild, Design-Token-Verwaltung, dynamische Theme-Wechsel.

#### Verfeinerungen und Ergänzungen:

**3.1. `domain::theming::types` (`src/theming/types.rs`)**

- **`TokenIdentifier`**:
    - **Validierung in `new()`**: `debug_assert!(!id_str.is_empty() && id_str.chars().all(|c| c.is_ascii_alphanumeric() || c == '.' || c == '-'), "TokenIdentifier darf nur ASCII-Alphanumerisch, Punkte und Bindestriche enthalten und nicht leer sein.");`
- **`TokenValue`**:
    - **`Reference(TokenIdentifier)`**: Stellt sicher, dass Alias-Tokens klar definiert sind.
    - **Validierung**: Die String-Werte für `Color`, `Dimension` etc. sollten idealerweise bei der Erstellung oder beim Parsen einer Basisvalidierung unterzogen werden (z.B. Hex-Format für Farben, Suffix "px"/"rem" für Dimensionen). Dies kann durch spezifische Newtype-Wrapper oder Validierungsfunktionen in der Logikschicht erfolgen. Für die `TokenValue` selbst bleiben es Strings, die Validierung erfolgt in der `TokenResolutionPipeline`.
- **`AccentColor`**:
    - **`value: novade_core::types::Color`**: Anstatt `String` direkt den `Color`-Typ aus der Kernschicht verwenden. Dies erfordert, dass `Color` `serde` mit `from_hex`/`to_hex_string` implementiert.
        - **Konsequenz:** Die `from_hex`-Logik und `ColorParseError` aus `core::types::color` bzw. `core::errors` wird hier relevant.
- **`AppliedThemeState`**:
    - `resolved_tokens: std::collections::BTreeMap<TokenIdentifier, String>`: `BTreeMap` statt `HashMap` verwenden, um eine deterministische Reihenfolge der Tokens zu gewährleisten, was für Tests und das Debugging von generiertem CSS nützlich sein kann. `TokenIdentifier` muss `Ord` implementieren.
- **`ThemingConfiguration`**:
    - `selected_accent_color: Option<novade_core::types::Color>`: Verwendet `core::types::Color`.

**3.2. `domain::theming::errors` (`src/theming/errors.rs`)**

- **`ThemingError`**:
    - `InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String }`: Neuer Fehler für ungültige Werte innerhalb eines `RawToken` nach dem Parsen, aber vor der Auflösung.
    - `AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: novade_core::types::Color, details: String }`: Spezifischer Fehler für die Akzentfarbenanwendung.

**3.3. `domain::theming::logic` (oder `engine_internal`) (`src/theming/logic.rs`)**

- **Token- und Theme-Laden (`async fn load_and_validate_token_files`, `async fn load_and_validate_theme_files`):**
    - Nutzen `novade_core::config::ConfigServiceAsync` (hypothetischer Trait) für asynchronen Dateizugriff. Die Implementierung dieses Traits in `novade-core` würde `tokio::fs` verwenden.
    - Beim Parsen von `RawToken.value` (z.B. `TokenValue::Color(s)`) könnte eine erste Basisvalidierung des `s` erfolgen.
- **Token Resolution Pipeline (`resolve_tokens_for_config`):**
    - **Akzentfarben-Logik:**
        1. Die `ThemeDefinition` sollte definieren, welche Tokens "akzentfähig" sind und wie sie modifiziert werden (z.B. eine Liste von `(TokenIdentifier, AccentModificationType)` wobei `AccentModificationType` `DirectReplace`, `Lighten(f32)`, `Darken(f32)` sein könnte).
        2. Wenn `config.selected_accent_color` gesetzt ist:
            - Iteriere über die akzentfähigen Tokens des Themes.
            - `DirectReplace`: Der Wert des akzentfähigen Tokens (z.B. `token.system.accent.primary`) wird direkt auf den Wert der `selected_accent_color` gesetzt.
            - `Lighten/Darken`: Der Basiswert des akzentfähigen Tokens wird mit der `selected_accent_color` als Referenz aufgehellt/abgedunkelt (erfordert Farbmodifikationslogik, die ggf. `novade_core::types::Color` Methoden nutzt).
    - **Caching-Schlüssel für `resolved_state_cache`**:
        - `CacheKey(ThemeIdentifier, ColorSchemeType, Option<novade_core::types::Color>, u64)`: `AccentColor` direkt (da `Color` hashbar sein kann, wenn f32-Felder mit einer Wrapper-Struct gehasht werden, die Bit-Repräsentationen vergleicht oder eine feste Präzision annimmt – einfacher ist, `color.to_hex_string(true)` zu hashen oder zu verwenden). Für `u64` den Hash der `custom_user_token_overrides` verwenden.
- **Fallback-Theme Laden (`load_fallback_theme_definition`):**
    - JSON-Strings für Fallback-Theme und -Tokens werden mittels `include_str!("default_themes/fallback.theme.json")` etc. einkompiliert.

**3.4. `ThemingEngine` Service (`src/theming/service.rs`)**

- **`ThemingEngineInternalState`**:
    - `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`: Wird korrekt initialisiert.
    - `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`: Wird injiziert für das Laden von Dateien.
- **Methoden:**
    - `new(...)`: Benötigt `Arc<dyn novade_core::config::ConfigServiceAsync>`.
    - `reload_themes_and_tokens()`: Nutzt den injizierten `config_service` für asynchrones Neuladen.
    - Event-Versand: `if self.event_sender.send(event).is_err() { tracing::warn!("ThemingEngine: Keine aktiven Subscriber für ThemeChangedEvent vorhanden."); }`

**3.5. Detaillierte Implementierungsschritte `domain::theming`**

1. **Grundgerüst schaffen:** Verzeichnisstruktur anlegen, `Cargo.toml`-Abhängigkeiten prüfen/ergänzen.
2. **`types.rs` implementieren:**
    - `TokenIdentifier`, `TokenValue`, `RawToken`, `TokenSet` definieren.
    - `ThemeIdentifier`, `ColorSchemeType`, `AccentColor` (mit `core::types::Color`), `ThemeVariantDefinition`, `ThemeDefinition` definieren.
    - `AppliedThemeState` (mit `BTreeMap`), `ThemingConfiguration` (mit `core::types::Color`) definieren.
    - Alle notwendigen `derive`s (`Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`, `Default`, `Ord`, `Hash` wo sinnvoll) und `serde`-Attribute hinzufügen.
    - Unit-Tests für Serialisierung/Deserialisierung und `Default`-Werte schreiben.
3. **`errors.rs` implementieren:**
    - `ThemingError`-Enum mit allen Varianten und `thiserror`-Attributen.
    - Unit-Tests für `Display`-Format und `source()`-Verhalten.
4. **`logic.rs` (oder Submodule) implementieren:**
    - `load_and_validate_token_files_async`: Liest JSON-Dateien (via `config_service`), parst zu `TokenSet`, validiert (Duplikate, Basis-Format von Werten).
    - `load_and_validate_theme_files_async`: Liest JSON, parst zu `ThemeDefinition`, validiert (Token-Referenzen).
    - `validate_tokenset_for_cycles`: Implementiert Zyklenerkennung.
    - `resolve_tokens_for_config`: Implementiert die vollständige Pipeline (Basis, Variante, Akzent, Overrides, Referenzauflösung).
        - Private Hilfsfunktionen für jeden Schritt der Pipeline.
        - Funktion zur Anwendung von Akzentfarben (ggf. mit `Lighten`/`Darken`-Logik).
    - `generate_fallback_applied_state`: Lädt einkompilierte JSONs und erzeugt daraus einen minimalen `AppliedThemeState`.
    - Unit-Tests für jeden Logik-Schritt und Fehlerfall.
5. **`service.rs` (oder `mod.rs`) `ThemingEngine` implementieren:**
    - `ThemingEngineInternalState`-Struktur definieren.
    - `ThemingEngine`-Struktur mit `Arc<Mutex<ThemingEngineInternalState>>` und `broadcast::Sender`.
    - `new()`-Konstruktor: Initialisiert `event_sender`, `config_service`, lädt initial Themes/Tokens, berechnet ersten `applied_state` (oder Fallback), füllt Cache.
    - `get_current_theme_state()`, `get_available_themes()`, `get_current_configuration()`: Implementieren Klonen aus dem internen Zustand.
    - `update_configuration()`: Berechnet neuen Zustand, prüft auf Änderungen, aktualisiert internen Zustand, sendet Event, aktualisiert Cache.
    - `reload_themes_and_tokens()`: Lädt neu, berechnet neu, sendet Event, invalidiert Cache.
    - `subscribe_to_theme_changes()`: Gibt `event_sender.subscribe()` zurück.
    - Unit-Tests für alle API-Methoden, Zustandsänderungen, Event-Auslösung, Cache-Verhalten (Invalidierung, Treffer). Mocking des `ConfigServiceAsync`.
6. **`default_themes/` Verzeichnis anlegen:** `fallback.theme.json` und `base.tokens.json` mit minimalen, gültigen Werten erstellen.
7. **`src/theming/mod.rs` erstellen:** Module deklarieren und öffentliche API re-exportieren (`ThemingEngine`, `ThemeChangedEvent`, wichtige Typen aus `types.rs`, `ThemingError`).

---

Die Spezifikationen für die Module `domain::global_settings_and_state_management`, `domain::workspaces`, `domain::window_management_policy`, `domain::user_centric_services` und `domain::notifications_rules` würden mit derselben Detailtiefe folgen, aufbauend auf den bereits existierenden Zitationen und den hier gezeigten Verfeinerungen und Implementierungsschritten.

**Beispielhafte Verfeinerungen für `domain::global_settings_and_state_management`:**

- **`types.rs`**:
    - Für alle Einstellungs-Unterstrukturen (z.B. `AppearanceSettings`) eine `validate(&self) -> Result<(), GlobalSettingsError>`-Methode hinzufügen, die spezifische Konsistenzprüfungen durchführt (z.B. "wenn `color_scheme == AutoSystem`, dann darf `manual_dark_mode_active` nicht `true` sein" – hypothetisch). Diese wird von `DefaultGlobalSettingsService::update_setting` nach der Deserialisierung aufgerufen.
- **`paths.rs`**:
    - Implementierung von `impl std::fmt::Display for SettingPath` für menschenlesbare Pfade in Logs/Fehlern.
    - Implementierung von `impl TryFrom<&str> for SettingPath` und `impl From<SettingPath> for String` für die Konvertierung zu/von String-basierten Pfaden (nützlich für D-Bus APIs oder Debugging).
- **`service.rs`**:
    - `DefaultGlobalSettingsService::update_setting`:
        1. Auflösen des `SettingPath` zu einem mutierbaren Verweis auf das spezifische Feld in `self.settings` (z.B. mittels Makro oder einer großen `match`-Anweisung).
        2. Deserialisieren des `serde_json::Value` in den erwarteten Typ des Feldes. `Err(GlobalSettingsError::InvalidValueType)` bei Fehlschlag.
        3. Validieren des deserialisierten Wertes mit einer spezifischen Validierungsfunktion für diese Einstellung (oder einer Methode auf der Einstellungs-Unterstruktur). `Err(GlobalSettingsError::ValidationError)` bei Fehlschlag.
        4. Wert aktualisieren, `SettingChangedEvent` senden, `save_settings()` aufrufen.

Dieser extrem granulare Ansatz ist zwar aufwendig, aber unerlässlich, um das Ziel eines "finalen lückenlosen Entwickler-Implementierungsleitfadens" zu erreichen. Jede Komponente ist bis ins Detail durchdacht, was die Implementierung erheblich beschleunigt und die Fehleranfälligkeit reduziert.


---

### Modul 3: `domain::theming`

Zweck: Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel (Farbschema, Akzentfarben). Dieses Modul stellt sicher, dass die UI-Schicht die korrekten, aufgelösten Stilwerte erhält.

Verantwortlichkeiten: Parsen von Token- und Theme-Dateien, Auflösen von Token-Referenzen und -Hierarchien, Anwenden von Benutzerkonfigurationen auf Themes, Bereitstellen des finalen AppliedThemeState und Benachrichtigen bei Änderungen.

Design-Rationale: Trennung der Theming-Logik von der UI-Darstellung. Ein Token-basiertes System ermöglicht hohe Flexibilität und Konsistenz. Dynamische Wechsel zur Laufzeit sind ein Kernziel.

Bestehende Spezifikation: und vorherige Antwort.

#### 3.1. Untermodul: `domain::theming::types`

**Datei:** `src/theming/types.rs`

- **Struct `TokenIdentifier`**
    
    - **Definition:**
        
        Rust
        
        ```
        use serde::{Serialize, Deserialize};
        use std::fmt;
        
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct TokenIdentifier(String);
        
        impl TokenIdentifier {
            pub fn new(id: impl Into<String>) -> Self {
                let id_str = id.into();
                // Invariante: Nicht leer und nur erlaubte Zeichen.
                // Hier nur Debug-Assert, da Validierung auch beim Parsen erfolgen kann.
                debug_assert!(!id_str.is_empty(), "TokenIdentifier darf nicht leer sein.");
                debug_assert!(
                    id_str.chars().all(|c| c.is_ascii_alphanumeric() || c == '.' || c == '-'),
                    "TokenIdentifier ({}) enthält ungültige Zeichen.", id_str
                );
                Self(id_str)
            }
            pub fn as_str(&self) -> &str { &self.0 }
        }
        impl fmt::Display for TokenIdentifier { /* ... */ } // Wie in [cite:656]
        impl From<&str> for TokenIdentifier { fn from(s: &str) -> Self { Self::new(s) } }
        ```
        
    - **Invarianten:** String nicht leer, enthält nur `a-zA-Z0-9.-`.
- **Enum `TokenValue`**
    
    - **Definition:**
        
        Rust
        
        ```
        // ... (andere Varianten wie in)
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        #[serde(rename_all = "kebab-case")]
        pub enum TokenValue {
            Color(String),      // CSS-kompatibler Farbwert, z.B. "#RRGGBB", "rgba(...)", "var(--andere-farbe)"
            Dimension(String),  // z.B. "16px", "2rem", "calc(100% - 20px)"
            FontSize(String),
            FontFamily(String),
            FontWeight(String), // z.B. "400", "bold"
            LineHeight(String), // z.B. "1.5", "150%"
            LetterSpacing(String),
            Border(String),     // z.B. "1px solid var(--border-color)"
            Shadow(String),
            Radius(String),
            Spacing(String),
            ZIndex(i32),
            Opacity(f64),       // Validierung: 0.0 <= opacity <= 1.0
            Text(String),
            Reference(TokenIdentifier), // Verweis auf eine andere TokenIdentifier
        }
        ```
        
    - **Invarianten:** Für `Opacity`, Wert muss zwischen 0.0 und 1.0 liegen. Die Strings in den anderen Varianten sollten gültige CSS-Werte sein (Validierung erfolgt später in der Pipeline oder bei der Anwendung).
- **Struct `RawToken`**
    
    - **Definition:** Wie in. `id: TokenIdentifier`, `value: TokenValue`, `description: Option<String>`, `group: Option<String>`.
    - **Ableitungen:** `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **Typalias `TokenSet`**: `pub type TokenSet = std::collections::BTreeMap<TokenIdentifier, RawToken>;` (BTreeMap für deterministische Reihenfolge).
    
- **Struct `ThemeIdentifier`**
    
    - **Definition:** Analog zu `TokenIdentifier`.
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct ThemeIdentifier(String);
        // ... impls wie TokenIdentifier ...
        ```
        
    - **Invarianten:** String nicht leer, empfohlene Zeichen: `a-zA-Z0-9-`.
- **Enum `ColorSchemeType`**
    
    - **Definition:** Wie in. `Light`, `Dark`.
    - **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`. (`#[default]` für `Light` oder `Dark` festlegen).
- **Struct `AccentColor`**
    
    - **Definition:**
        
        Rust
        
        ```
        use novade_core::types::Color as CoreColor; // Verwendung des Kerntyps
        
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AccentColor {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub name: Option<String>, // z.B. "Blau", "Waldgrün"
            pub value: CoreColor,     // Der tatsächliche Farbwert
        }
        // Eq und Hash manuell implementieren, wenn CoreColor::f32 nicht direkt Eq/Hash ist.
        // Für Cache-Zwecke kann der Hex-String von CoreColor verwendet werden.
        ```
        
- **Struct `ThemeVariantDefinition`**: Wie in. `applies_to_scheme: ColorSchemeType`, `tokens: TokenSet`.
    
- **Struct `ThemeDefinition`**: Wie in. Enthält `id`, `name`, `base_tokens`, `variants`, `supported_accent_colors: Option<Vec<AccentColor>>`.
    
- **Struct `AppliedThemeState`**
    
    - **Definition:** Wie in vorheriger Antwort verfeinert (mit `BTreeMap`).
        
        Rust
        
        ```
        use std::collections::BTreeMap;
        // ...
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)] // Serialize/Deserialize für Caching/Events
        pub struct AppliedThemeState {
            pub theme_id: ThemeIdentifier,
            pub color_scheme: ColorSchemeType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub active_accent_color: Option<AccentColor>,
            pub resolved_tokens: BTreeMap<TokenIdentifier, String>, // CSS-finale Werte
        }
        ```
        
- **Struct `ThemingConfiguration`**
    
    - **Definition:** Wie in vorheriger Antwort verfeinert.
        
        Rust
        
        ```
        use novade_core::types::Color as CoreColor;
        // ...
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ThemingConfiguration {
            pub selected_theme_id: ThemeIdentifier,
            pub preferred_color_scheme: ColorSchemeType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub selected_accent_color: Option<CoreColor>, // Verwendet CoreColor
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub custom_user_token_overrides: Option<TokenSet>,
        }
        impl Default for ThemingConfiguration { /* Sinnvolle Standardwerte, z.B. Fallback-Theme */ }
        ```
        

#### 3.2. Untermodul: `domain::theming::errors`

**Datei:** `src/theming/errors.rs`

- **Enum `ThemingError`**: Wie in vorheriger Antwort verfeinert (konsolidierte Liste aus und Ergänzungen).
    
    Rust
    
    ```
    use thiserror::Error;
    use std::path::PathBuf;
    use super::types::{TokenIdentifier, ThemeIdentifier}; // Lokale Typen
    use novade_core::types::Color as CoreColor; // Kerntyp
    
    #[derive(Debug, Error)]
    pub enum ThemingError {
        #[error("Failed to parse token file '{path}': {source}")]
        TokenFileParseError { path: PathBuf, #[source] source: serde_json::Error },
        #[error("I/O error while processing token file '{path}': {source}")]
        TokenFileIoError { path: PathBuf, #[source] source: std::io::Error },
        #[error("Invalid token data in file '{path}': {message}")]
        InvalidTokenData { path: PathBuf, message: String },
        #[error("Invalid token value for '{token_id}': '{value_string}'. Reason: {reason}")]
        InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String },
        #[error("Cyclic dependency detected involving token '{token_id}'. Cycle path: {cycle_path:?}")]
        CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> },
        #[error("Failed to load theme definition '{theme_id}' from file '{path}': {source}")]
        ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: serde_json::Error },
        #[error("I/O error while loading theme definition '{theme_id}' from file '{path}': {source}")]
        ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: std::io::Error },
        #[error("Invalid theme data for theme '{theme_id}' in file '{path}': {message}")]
        InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String },
        #[error("Theme with ID '{theme_id}' not found.")]
        ThemeNotFound { theme_id: ThemeIdentifier },
        #[error("Referenced token '{target_token_id}' not found (referenced by '{referencing_token_id}').")]
        MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier },
        #[error("Maximum token reference depth ({depth}) exceeded while resolving '{token_id}'.")]
        MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 },
        #[error("Failed to apply theming configuration: {message}")]
        ThemeApplicationError { message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> },
        #[error("Critical error: Failed to initialize theming engine because no suitable fallback theme could be loaded: {source}")]
        FallbackThemeLoadError { #[source] source: Box<dyn std::error::Error + Send + Sync + 'static> },
        #[error("Initial theming configuration is invalid: {0}")]
        InitialConfigurationError(String),
        #[error("Internal state error in ThemingEngine: {0}")]
        InternalStateError(String),
        #[error("Failed to subscribe to theme change events: {0}")]
        EventSubscriptionError(String),
        #[error("Error applying accent color '{accent_color}' to theme '{theme_id}': {details}")]
        AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: CoreColor, details: String },
        #[error("Failed to resolve token '{token_id}': {message}")]
        TokenResolutionError { token_id: TokenIdentifier, message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> },
        #[error("Filesystem operation error for ThemingEngine: {0}")] // Neuer Fehler für ConfigServiceAsync-Fehler
        FilesystemError(#[from] novade_core::errors::CoreError), // Annahme: ConfigServiceAsync gibt CoreError zurück
    }
    ```
    

#### 3.3. Untermodul: `domain::theming::logic` (oder `engine_internal`)

**Datei:** `src/theming/logic.rs` (und ggf. `token_loader.rs`, `theme_loader.rs`, `token_resolver.rs`)

- **Konstante:** `const MAX_TOKEN_RESOLUTION_DEPTH: u8 = 16;`
- **Funktion: `async fn load_raw_tokens_from_file(path: &Path, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`**
    1. `content = config_service.read_file_to_string(path).await.map_err(|e| ThemingError::TokenFileIoError { path: path.to_path_buf(), source: e.into_std_io_error_or_generic() })?;` (Annahme: `ConfigServiceAsync` gibt einen Fehler zurück, der in `std::io::Error` oder einen generischen `CoreError` konvertiert werden kann).
    2. `raw_tokens: Vec<RawToken> = serde_json::from_str(&content).map_err(|e| ThemingError::TokenFileParseError { path: path.to_path_buf(), source: e })?;`
    3. In `TokenSet` (`BTreeMap`) konvertieren. Bei Duplikaten: `ThemingError::InvalidTokenData`.
    4. Basisvalidierung jedes `RawToken.value` (z.B. `TokenValue::Opacity(o)` prüfen, ob `0.0 <= o <= 1.0`). Bei Fehler: `ThemingError::InvalidTokenValue`.
- **Funktion: `async fn load_and_validate_token_files(paths: &[PathBuf], config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`**
    1. Iteriert über `paths`, ruft `load_raw_tokens_from_file` für jede Datei auf.
    2. Mergt die `TokenSet`s (Benutzer-spezifische überschreiben System-spezifische, falls Pfade so interpretiert werden). Loggt Überschreibungen mit `tracing::debug!`.
    3. Ruft `validate_tokenset_for_cycles` für das finale Set auf.
- **Funktion: `async fn load_theme_definition_from_file(...)`**: Analog zu Tokens, parst zu `ThemeDefinition`.
- **Funktion: `async fn load_and_validate_theme_files(...)`**: Analog, validiert zusätzlich Referenzen mittels `validate_theme_definition_references`.
- **Funktion: `validate_tokenset_for_cycles(tokens: &TokenSet) -> Result<(), ThemingError>`**
    - Implementiert Tiefensuche. Verfolgt den aktuellen Pfad (`Vec<TokenIdentifier>`). Wenn ein bereits besuchtes Token im aktuellen Pfad erneut angetroffen wird -> Zyklus.
- **Funktion: `validate_theme_definition_references(theme_def: &ThemeDefinition, global_tokens: &TokenSet) -> Result<(), ThemingError>`** (Wie in).
- **Funktion: `resolve_tokens_for_config(...) -> Result<BTreeMap<TokenIdentifier, String>, ThemingError>`**
    1. **Ausgangspunkt:** Erstelle `current_resolved_tokens: BTreeMap<TokenIdentifier, TokenValue>` (noch nicht final Strings).
    2. **Basissatz:** Kopiere `global_tokens` nach `current_resolved_tokens`. Überschreibe/Merge mit `theme_def.base_tokens`.
    3. **Variante anwenden:** Finde passende `ThemeVariantDefinition` für `config.preferred_color_scheme`. Merge deren `tokens` in `current_resolved_tokens`.
    4. **Akzentfarbe anwenden:**
        - Wenn `config.selected_accent_color` (Typ `CoreColor`) vorhanden ist:
        - Iteriere über `theme_def.accentable_tokens` (neues Feld in `ThemeDefinition`: `Option<HashMap<TokenIdentifier, AccentModificationType>>`).
        - Für jeden `token_id_to_accent` und `modification_type`:
            - Hole den Basiswert des `token_id_to_accent` aus `current_resolved_tokens` (muss ein `TokenValue::Color` sein).
            - Wende `modification_type` an (z.B. `DirectReplace` -> setze auf `selected_accent_color`; `Lighten(0.2)` -> helle `selected_accent_color` um 20% auf und setze das als neuen Wert).
            - Aktualisiere `current_resolved_tokens`. Bei Fehlern: `ThemingError::AccentColorApplicationError`.
    5. **Benutzer-Overrides:** Merge `config.custom_user_token_overrides` (falls vorhanden) in `current_resolved_tokens`.
    6. **Rekursive Referenzauflösung:**
        - Iteriere über `current_resolved_tokens`. Für jedes `(id, value)`:
        - `final_value = resolve_single_token_value(id, value, &current_resolved_tokens, Vec::new(), max_depth)?`
        - Speichere `(id, final_value_as_string)` in `final_css_tokens: BTreeMap<TokenIdentifier, String>`.
        - Die `resolve_single_token_value` Funktion ist rekursiv:
            
            Rust
            
            ```
            fn resolve_single_token_value(
                original_id: &TokenIdentifier,
                current_value: &TokenValue,
                all_tokens: &BTreeMap<TokenIdentifier, TokenValue>, // Zustand vor String-Konvertierung
                visited_path: &mut Vec<TokenIdentifier>, // Für Zyklenerkennung
                max_depth: u8,
            ) -> Result<String, ThemingError> {
                if visited_path.len() > max_depth as usize {
                    return Err(ThemingError::MaxReferenceDepthExceeded { token_id: original_id.clone(), depth: max_depth });
                }
                if visited_path.contains(original_id) {
                    return Err(ThemingError::CyclicTokenReference { token_id: original_id.clone(), cycle_path: visited_path.clone() });
                }
                visited_path.push(original_id.clone());
            
                let result = match current_value {
                    TokenValue::Reference(target_id) => {
                        let target_raw_value = all_tokens.get(target_id)
                            .ok_or_else(|| ThemingError::MissingTokenReference {
                                referencing_token_id: original_id.clone(),
                                target_token_id: target_id.clone(),
                            })?;
                        // Rekursiver Aufruf für das Ziel
                        resolve_single_token_value(target_id, target_raw_value, all_tokens, visited_path, max_depth)
                    }
                    TokenValue::Color(s) => Ok(s.clone()),
                    TokenValue::Dimension(s) => Ok(s.clone()),
                    // ... andere direkte Typen zu String ...
                    TokenValue::Opacity(o) => Ok(format!("{:.2}", o.clamp(0.0, 1.0))),
                    TokenValue::ZIndex(z) => Ok(z.to_string()),
                    TokenValue::Text(s) => Ok(s.clone()),
                };
                visited_path.pop(); // Wichtig: Beim Verlassen des Rekursionsschritts entfernen
                result
            }
            ```
            
    7. Gib `final_css_tokens` zurück.
- **Caching-Logik:**
    - **Cache-Schlüssel:** `(ThemeIdentifier, ColorSchemeType, Option<String> /* hex von AccentColor */, u64 /* hash von Overrides */)`.
    - Vor der Auflösung im Cache nachsehen. Bei Treffer direkt zurückgeben.
    - Nach erfolgreicher Auflösung Ergebnis im Cache speichern.
- **Fallback-Theme Laden:**
    - `pub(crate) fn generate_fallback_applied_state() -> AppliedThemeState`: Parst einkompilierte JSONs für `fallback.theme.json` und `base.tokens.json`, führt minimale Auflösung durch (sollte keine komplexen Referenzen haben).

#### 3.4. Öffentliche API: `ThemingEngine` Service

**Datei:** `src/theming/service.rs` (oder `mod.rs`)

- **Struct `ThemingEngineInternalState`**:
    - `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>` (neu)
    - Rest wie in vorheriger Antwort (Cache-Typ angepasst).
- **Struct `ThemingEngine`**:
    - `internal_state: Arc<tokio::sync::Mutex<ThemingEngineInternalState>>` (Verwendung von `tokio::sync::Mutex` für `async` Methoden).
    - `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`.
- **Methoden der `ThemingEngine`**:
    - `pub async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, broadcast_capacity: usize) -> Result<Self, ThemingError>`:
        1. Initialisiert `event_sender`, `config_service_ref`.
        2. Sperrt `internal_state` (initial leer).
        3. Speichert `theme_load_paths`, `token_load_paths`, `config_service_ref` in `internal_state`.
        4. Ruft `internal_load_themes_and_tokens_locked(&mut internal_state_guard).await?` auf.
        5. Ruft `internal_apply_configuration_locked(&mut internal_state_guard, initial_config, true /* is_initial */).await?` auf.
        6. Gibt `Self` zurück.
    - `async fn internal_load_themes_and_tokens_locked(&mut self_internal: &mut ThemingEngineInternalState) -> Result<(), ThemingError>`: Interne Methode zum Neuladen.
    - `async fn internal_apply_configuration_locked(&mut self_internal: &mut ThemingEngineInternalState, config: ThemingConfiguration, is_initial: bool) -> Result<(), ThemingError>`: Interne Methode zum Anwenden einer Konfig, prüft Cache, löst Pipeline aus, aktualisiert `applied_state`, `current_config`, sendet Event. Wenn `is_initial` und Auflösung fehlschlägt, wird `generate_fallback_applied_state` verwendet.
    - `pub async fn get_current_theme_state(&self) -> AppliedThemeState`: Sperrt `internal_state`, klont und gibt `applied_state` zurück.
    - `pub async fn get_available_themes(&self) -> Vec<ThemeDefinition>`: Sperrt, klont, gibt zurück.
    - `pub async fn get_current_configuration(&self) -> ThemingConfiguration`: Sperrt, klont, gibt zurück.
    - `pub async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`: Sperrt `internal_state`, ruft `internal_apply_configuration_locked(..., new_config, false).await`.
    - `pub async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`: Sperrt `internal_state`, ruft `internal_load_themes_and_tokens_locked().await`, dann `internal_apply_configuration_locked(..., self_internal.current_config.clone(), false).await`. Invalidiert kompletten Cache.
    - `pub fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`: Gibt `self.event_sender.subscribe()` zurück.
- **Event `ThemeChangedEvent`**:
    - **Payload:** `pub new_state: AppliedThemeState`
    - **Publisher:** `ThemingEngine` (via `event_sender`).
    - **Subscriber:** `ui::theming_gtk` (wendet CSS an), `domain::global_settings_service` (wenn Theming-Einstellungen sich auf globale Nicht-Theme-Einstellungen auswirken, z.B. Kontrastmodus).

#### 3.5. Implementierungsschritte `domain::theming`

(Wie in vorheriger Antwort, aber mit `async` für Ladeoperationen und `tokio::sync::Mutex` für `ThemingEngineInternalState`.)

1. **Grundgerüst** und `Cargo.toml` aktualisieren.
2. **`types.rs`**: `AccentColor` mit `CoreColor`, `AppliedThemeState` mit `BTreeMap`, `ThemingConfiguration` mit `CoreColor`. `TokenIdentifier` Validierung.
3. **`errors.rs`**: `ThemingError` um `InvalidTokenValue`, `AccentColorApplicationError`, `FilesystemError` erweitern. `FallbackThemeLoadError` mit `#[source]`.
4. **`logic.rs`**:
    - Ladefunktionen (`load_raw_tokens_from_file`, etc.) `async` machen, `ConfigServiceAsync` nutzen.
    - `resolve_tokens_for_config`: Akzentfarben-Logik detaillieren (Nutzung von `accentable_tokens` aus `ThemeDefinition`). `MAX_TOKEN_RESOLUTION_DEPTH` verwenden. Rekursive `resolve_single_token_value` Funktion implementieren.
    - Caching-Logik mit `CacheKey` (inkl. Hash für Overrides) implementieren.
    - `generate_fallback_applied_state`: JSONs parsen und minimalen State erzeugen.
5. **`service.rs`**: `ThemingEngine` mit `tokio::sync::Mutex` für `internal_state`. `async` API-Methoden. Interne `_locked`-Methoden für die Hauptlogik. Event-Versand über `tokio::sync::broadcast`.
6. **Unit-Tests**: An `async` anpassen. Mocking des `ConfigServiceAsync`. Tests für Akzentfarben, Cache-Logik (Treffer, Fehlschlag, Invalidierung).
7. **Fallback-JSONs** in `default_themes/` erstellen.
8. **`mod.rs`**: Öffentliche API re-exportieren.

---

### Modul 4: `domain::global_settings_and_state_management`

Zweck: Repräsentation, Logik zur Verwaltung und Konsistenz globaler Desktop-Einstellungen.

Bestehende Spezifikation: und vorherige Antwort.

#### Verfeinerungen und Ergänzungen:

**4.1. `domain::global_settings::types` (`src/global_settings/types.rs`)**

- Alle Einstellungs-Structs (z.B. `AppearanceSettings`, `InputBehaviorSettings`) müssen vollständig ausdefiniert werden, inklusive aller Felder, Typen, `serde`-Attribute (`#[serde(default)]`, `#[serde(rename_all = "kebab-case")]` für TOML-Kompatibilität) und `Default`-Implementierungen.
    
    Rust
    
    ```
    // Beispiel für InputBehaviorSettings
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    #[serde(default, rename_all = "kebab-case")]
    pub struct InputBehaviorSettings {
        pub mouse_acceleration_profile: MouseAccelerationProfile,
        pub custom_mouse_acceleration_factor: Option<f32>, // Validierung: 0.0 < factor
        pub mouse_sensitivity: f32, // Validierung: z.B. 0.1 - 10.0
        pub natural_scrolling_mouse: bool,
        pub natural_scrolling_touchpad: bool,
        pub tap_to_click_touchpad: bool,
        pub touchpad_pointer_speed: f32, // Validierung: z.B. 0.1 - 10.0
        pub keyboard_repeat_delay_ms: u32, // Validierung: z.B. 100-2000
        pub keyboard_repeat_rate_cps: u32, // Zeichen pro Sekunde; Validierung: z.B. 10-100
    }
    impl Default for InputBehaviorSettings { /* ... */ }
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum MouseAccelerationProfile { #[default] Adaptive, Flat, Custom }
    ```
    
- **Validierungsmethoden**: Jede Einstellungs-Unterstruktur sollte eine `pub fn validate(&self) -> Result<(), String>`-Methode (oder `Result<(), GlobalSettingsError::ValidationError>`) haben, die interne Konsistenz und Wertebereiche prüft.
    - Beispiel: `InputBehaviorSettings::validate(&self)` prüft, ob `custom_mouse_acceleration_factor` nur `Some` ist, wenn `mouse_acceleration_profile == Custom`, und ob Faktoren/Raten in gültigen Bereichen liegen.

**4.2. `domain::global_settings::paths` (`src/global_settings/paths.rs`)**

- Der `SettingPath`-Enum muss die gesamte Hierarchie von `GlobalDesktopSettings` exakt abbilden.
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum SettingPath {
        Appearance(AppearanceSettingPath),
        WorkspaceConfig(WorkspaceSettingPath),
        InputBehavior(InputBehaviorSettingPath),
        // ...
    }
    // ... für jede Unterstruktur
    ```
    
- **Implementierung von `TryFrom<&str>` und `Display` für `SettingPath`:**
    
    Rust
    
    ```
    // Beispielhaft für einen Teilpfad
    impl fmt::Display for AppearanceSettingPath {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                AppearanceSettingPath::ActiveThemeName => write!(f, "appearance.active-theme-name"),
                AppearanceSettingPath::FontSettings(fp) => write!(f, "appearance.font-settings.{}", fp),
                // ...
            }
        }
    }
    // TryFrom<&str> erfordert sorgfältiges Parsen des Strings.
    ```
    

**4.3. `domain::global_settings::errors` (`src/global_settings/errors.rs`)**

- **`GlobalSettingsError`**:
    - `ValidationError { path: SettingPath, reason: String }`: Verwendet `SettingPath` statt `String`.
    - `PathNotFound { path: SettingPath }`.
    - `PersistenceError` sollte den spezifischen Fehler aus dem `SettingsPersistenceProvider` wrappen.

**4.4. `domain::global_settings::persistence_iface` (`src/global_settings/persistence_iface.rs`)**

- **Trait `SettingsPersistenceProvider`**:
    
    Rust
    
    ```
    #[async_trait]
    pub trait SettingsPersistenceProvider: Send + Sync {
        async fn load_global_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>;
        async fn save_global_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>;
    }
    ```
    
- **Implementierung `FilesystemSettingsProvider`**:
    - Nutzt `Arc<dyn novade_core::config::ConfigServiceAsync>`.
    - `load_global_settings`: Liest TOML-Datei, deserialisiert zu `GlobalDesktopSettings`. Bei Deserialisierungsfehlern (z.B. unbekannte Felder, wenn `deny_unknown_fields` aktiv ist, oder Typfehler), wird ein `GlobalSettingsError::DeserializationError` zurückgegeben. Wenn die Datei nicht existiert, wird `Ok(GlobalDesktopSettings::default())` zurückgegeben.
    - `save_global_settings`: Serialisiert `GlobalDesktopSettings` zu TOML, schreibt in Datei.

**4.5. `domain::global_settings::service` (`src/global_settings/service.rs`)**

- **`DefaultGlobalSettingsService`**:
    - Hält `settings: Arc<tokio::sync::RwLock<GlobalDesktopSettings>>` für threadsicheren Lese-/Schreibzugriff.
    - **`update_setting(path: SettingPath, value: serde_json::Value)`**:
        1. Holt eine Schreibsperre für `self.settings`.
        2. Erstellt einen Klon der aktuellen `settings` für die Modifikation (`let mut new_settings = (*settings_guard).clone();`).
        3. **Pfad-Navigation und Aktualisierung (komplex):**
            - Eine große `match path { ... }`-Anweisung, die für jede `SettingPath`-Variante:
                - Das entsprechende Feld in `new_settings` referenziert.
                - `serde_json::from_value::<TargetType>(value)` versucht. Bei Fehler -> `InvalidValueType`.
                - Den deserialisierten Wert in `new_settings` setzt.
        4. `new_settings.validate_recursive() -> Result<(), GlobalSettingsError::ValidationError>` aufrufen (eine Methode, die alle `validate()`-Methoden der Unterstrukturen aufruft). Bei Fehler, Änderung nicht anwenden, Fehler zurückgeben.
        5. Wenn Validierung erfolgreich: Ersetze `*settings_guard = new_settings;`.
        6. `self.event_sender.send(SettingChangedEvent { path, new_value: value /* oder serialisierter neuer Wert */})`.
        7. `self.save_settings_internal(settings_guard).await` (interne Methode, die die Sperre nutzt).
    - **`get_setting(path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`**:
        1. Holt eine Lesesperre.
        2. Navigiert zum Wert via `match path`.
        3. Serialisiert den Wert zu `serde_json::Value`.
- **Events:** `SettingChangedEvent`, `SettingsLoadedEvent`, `SettingsSavedEvent` (via `tokio::sync::broadcast`).

**4.6. Detaillierte Implementierungsschritte `domain::global_settings`**

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml`.
2. **`types.rs`**: Alle Einstellungs-`struct`s und `enum`s mit `serde`, `Default`, `validate()`-Methoden.
3. **`paths.rs`**: `SettingPath` Enum vollständig definieren, `Display` und `TryFrom<&str>` implementieren.
4. **`errors.rs`**: `GlobalSettingsError` definieren.
5. **`persistence_iface.rs`**: `SettingsPersistenceProvider`-Trait. `FilesystemSettingsProvider` implementieren (mit Mocking von `ConfigServiceAsync` für Tests).
6. **`service.rs`**: `GlobalSettingsService`-Trait. `DefaultGlobalSettingsService` implementieren:
    - Konstruktor, `RwLock` für `settings`.
    - `load_settings`, `save_settings` (interagieren mit Provider).
    - `update_setting` mit detaillierter Pfad-Navigation, Deserialisierung, Validierung.
    - `get_setting`, `reset_to_defaults`.
    - Event-Versand (`tokio::sync::broadcast`).
7. **Unit-Tests**: Für jede Einstellungsstruktur (Validierung, Serde, Default). Für `SettingPath` (Konvertierungen). Für `FilesystemSettingsProvider` (Mocking). Für `DefaultGlobalSettingsService` (alle API-Methoden, Fehlerfälle, Event-Auslösung, korrekte Aktualisierung verschachtelter Einstellungen).
8. **`mod.rs`**: Module deklarieren, öffentliche API re-exportieren.

---

Dieser detaillierte Plan für die Module `domain::theming` und `domain::global_settings_and_state_management` sollte es Entwicklern ermöglichen, diese Komponenten präzise zu implementieren. Die verbleibenden Module (Workspaces, Window Management Policy, User-Centric Services, Notifications Rules) würden nach demselben Schema und mit derselben Detailtiefe ausgearbeitet.


---

### Modul 5: `domain::workspaces`

Zweck: Umfassende Verwaltungslogik für Arbeitsbereiche ("Spaces"), einschließlich ihrer Definition, Fensterzuweisung, Orchestrierung und Persistenz.

Verantwortlichkeiten: Definition der Workspace-Entität, Regeln für Fensterzuweisung, Verwaltung der Workspace-Sammlung (inkl. aktivem Workspace), Laden und Speichern der Workspace-Konfiguration, Publizieren von Workspace-bezogenen Events.

Design-Rationale: Kapselung aller Workspace-bezogenen Logik an einem Ort, um Konsistenz und Wartbarkeit zu gewährleisten. Strikte Trennung von UI- und Systemdetails.

Bestehende Spezifikation: und vorherige Antworten.

#### 5.1. Untermodul: `domain::workspaces::core`

**Zweck:** Fundamentale Definition der `Workspace`-Entität und zugehöriger Typen.

**Datei:** `src/workspaces/core/types.rs`

- **Typalias `WorkspaceId`**
    - **Definition:** `pub type WorkspaceId = uuid::Uuid;`
    - **Ableitungen:** (Keine direkt, `uuid::Uuid` hat eigene)
- **Struct `WindowIdentifier`**
    - **Definition:**
        
        Rust
        
        ```
        use serde::{Serialize, Deserialize};
        use std::fmt;
        use super::errors::WorkspaceCoreError; // Für Validierungsfehler
        
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct WindowIdentifier(String);
        
        impl WindowIdentifier {
            pub fn new(id: impl Into<String>) -> Result<Self, WorkspaceCoreError> {
                let id_str = id.into();
                if id_str.is_empty() {
                    return Err(WorkspaceCoreError::WindowIdentifierEmpty);
                }
                // Ggf. weitere Validierungen (z.B. erlaubte Zeichen)
                Ok(Self(id_str))
            }
            pub fn as_str(&self) -> &str { &self.0 }
        }
        impl fmt::Display for WindowIdentifier { /* ... */ }
        impl From<&str> for WindowIdentifier { fn from(s: &str) -> Self { Self::new(s).expect("Ungültiger WindowIdentifier aus &str") } }
        // From<String> ist riskanter ohne Fehlerbehandlung, new() bevorzugen
        ```
        
    - **Invarianten:** String nicht leer.
- **Enum `WorkspaceLayoutType`**
    - **Definition:** Wie in und vorheriger Antwort.
        
        Rust
        
        ```
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
        pub enum WorkspaceLayoutType {
            #[default]
            Floating,
            TilingHorizontal, // Fenster nebeneinander
            TilingVertical,   // Fenster untereinander
            // Zukünftig ggf. komplexere Tiling-Modi direkt hier definieren oder durch
            // domain::window_management_policy referenzieren. Fürs Erste sind diese fix.
            Maximized,        // Ein Fenster ist maximiert, andere ggf. verborgen/minimiert
        }
        ```
        

**Datei:** `src/workspaces/core/mod.rs` (enthält `Workspace`-Struct-Definition)

- **Struct `Workspace`**
    - **Definition:**
        
        Rust
        
        ```
        use std::collections::HashSet;
        use uuid::Uuid;
        use chrono::{DateTime, Utc};
        use serde::{Serialize, Deserialize};
        use super::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};
        use super::errors::WorkspaceCoreError;
        use super::errors::MAX_WORKSPACE_NAME_LENGTH;
        
        #[derive(Debug, Clone, Serialize, Deserialize)]
        // PartialEq manuell implementieren wegen HashSet, falls nötig, oder nur auf IDs vergleichen.
        // Für die meisten Anwendungsfälle ist der Vergleich über `id` ausreichend.
        pub struct Workspace {
            id: WorkspaceId,
            name: String,
            persistent_id: Option<String>,
            layout_type: WorkspaceLayoutType,
            window_ids: HashSet<WindowIdentifier>,
            created_at: DateTime<Utc>,
            // Neu: Optionale Metadaten für den Workspace, z.B. benutzerdefiniertes Icon/Farbe
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub icon_name: Option<String>, // Name eines Icons aus dem System-Theme
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub accent_color_hex: Option<String>, // z.B. "#RRGGBB"
        }
        
        impl Workspace {
            pub fn new(name: String, persistent_id: Option<String>, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<Self, WorkspaceCoreError> {
                if name.is_empty() {
                    return Err(WorkspaceCoreError::NameCannotBeEmpty);
                }
                if name.len() > MAX_WORKSPACE_NAME_LENGTH {
                    return Err(WorkspaceCoreError::NameTooLong {
                        name: name.clone(),
                        max_len: MAX_WORKSPACE_NAME_LENGTH,
                        actual_len: name.len(),
                    });
                }
                if let Some(pid) = &persistent_id {
                    if pid.is_empty() || pid.chars().any(|c| !c.is_ascii_alphanumeric() && c != '-' && c != '_') {
                        return Err(WorkspaceCoreError::InvalidPersistentId(pid.clone()));
                    }
                }
                if let Some(hex) = &accent_color_hex {
                    // Basis-Validierung für Hex-Farbe
                    if !(hex.starts_with('#') && (hex.len() == 7 || hex.len() == 9) && hex[1..].chars().all(|c| c.is_ascii_hexdigit())) {
                        return Err(WorkspaceCoreError::InvalidAccentColorFormat(hex.clone()));
                    }
                }
        
                Ok(Self {
                    id: Uuid::new_v4(),
                    name,
                    persistent_id,
                    layout_type: WorkspaceLayoutType::default(),
                    window_ids: HashSet::new(),
                    created_at: Utc::now(),
                    icon_name,
                    accent_color_hex,
                })
            }
        
            pub fn id(&self) -> WorkspaceId { self.id }
            pub fn name(&self) -> &str { &self.name }
            pub fn persistent_id(&self) -> Option<&str> { self.persistent_id.as_deref() }
            pub fn layout_type(&self) -> WorkspaceLayoutType { self.layout_type }
            pub fn window_ids(&self) -> &HashSet<WindowIdentifier> { &self.window_ids }
            pub fn created_at(&self) -> DateTime<Utc> { self.created_at }
            pub fn icon_name(&self) -> Option<&str> { self.icon_name.as_deref() }
            pub fn accent_color_hex(&self) -> Option<&str> { self.accent_color_hex.as_deref() }
        
            pub fn rename(&mut self, new_name: String) -> Result<(), WorkspaceCoreError> {
                if new_name.is_empty() { /* ... NameCannotBeEmpty ... */ }
                if new_name.len() > MAX_WORKSPACE_NAME_LENGTH { /* ... NameTooLong ... */ }
                self.name = new_name;
                Ok(())
            }
        
            pub fn set_layout_type(&mut self, layout_type: WorkspaceLayoutType) {
                self.layout_type = layout_type;
            }
        
            pub(crate) fn add_window_id(&mut self, window_id: WindowIdentifier) -> bool {
                self.window_ids.insert(window_id)
            }
        
            pub(crate) fn remove_window_id(&mut self, window_id: &WindowIdentifier) -> bool {
                self.window_ids.remove(window_id)
            }
        
            pub fn set_persistent_id(&mut self, pid: Option<String>) -> Result<(), WorkspaceCoreError> {
                if let Some(p) = &pid {
                    if p.is_empty() || p.chars().any(|c| !c.is_ascii_alphanumeric() && c != '-' && c != '_') {
                        return Err(WorkspaceCoreError::InvalidPersistentId(p.clone()));
                    }
                }
                self.persistent_id = pid;
                Ok(())
            }
        
            pub fn set_icon_name(&mut self, icon: Option<String>) {
                self.icon_name = icon;
            }
        
            pub fn set_accent_color_hex(&mut self, color_hex: Option<String>) -> Result<(), WorkspaceCoreError> {
                 if let Some(hex) = &color_hex {
                    if !(hex.starts_with('#') && (hex.len() == 7 || hex.len() == 9) && hex[1..].chars().all(|c| c.is_ascii_hexdigit())) {
                        return Err(WorkspaceCoreError::InvalidAccentColorFormat(hex.clone()));
                    }
                }
                self.accent_color_hex = color_hex;
                Ok(())
            }
        }
        ```
        
    - **Felder:** Wie in vorheriger Antwort, plus `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - **Methoden:** Wie in vorheriger Antwort, plus `set_icon_name`, `set_accent_color_hex`. Die `new`-Methode wird angepasst, um die neuen Felder zu akzeptieren und zu validieren.

**Datei:** `src/workspaces/core/event_data.rs`

- **Event-Payload-Strukturen**: Wie in. Zusätzlich:
    - `pub struct WorkspaceIconChangedData { pub id: WorkspaceId, pub old_icon_name: Option<String>, pub new_icon_name: Option<String> }`
    - `pub struct WorkspaceAccentChangedData { pub id: WorkspaceId, pub old_color_hex: Option<String>, pub new_color_hex: Option<String> }`
    - Alle mit `#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]`.

**Datei:** `src/workspaces/core/errors.rs`

- **Konstante `MAX_WORKSPACE_NAME_LENGTH`**: `pub const MAX_WORKSPACE_NAME_LENGTH: usize = 64;`
- **Enum `WorkspaceCoreError`**: Wie in. Zusätzlich:
    - `WindowIdentifierEmpty`
    - `InvalidAccentColorFormat(String)`

#### 5.2. Untermodul: `domain::workspaces::assignment`

**Zweck:** Geschäftslogik für die Zuweisung von Fenstern zu Workspaces.

**Datei:** `src/workspaces/assignment/errors.rs`

- **Enum `WindowAssignmentError`**: Wie in. Keine Änderungen zur vorherigen Spezifikation notwendig, da es bereits umfassend war.

**Datei:** `src/workspaces/assignment/mod.rs`

- **API-Funktionen**: Wie in. Die Implementierung der Funktionen muss detailliert werden:
    - **`assign_window_to_workspace(...)` Logik:**
        1. Prüfe `target_workspace_id` in `workspaces`. Wenn nicht gefunden: `Err(WorkspaceNotFound)`.
        2. Wenn `ensure_unique_assignment` `true` ist:
            - Iteriere über alle `(ws_id, ws)` in `workspaces`.
            - Wenn `ws_id != target_workspace_id` UND `ws.window_ids().contains(window_id)`:
                - `ws.remove_window_id(window_id);` (Diese Methode ist `pub(crate)` in `Workspace`).
        3. Hole `target_ws = workspaces.get_mut(&target_workspace_id).unwrap()`.
        4. Wenn `target_ws.add_window_id(window_id.clone())` `false` zurückgibt (Fenster war bereits da):
            - `Ok(())` (Kein Fehler, wenn es bereits auf dem Ziel-Workspace ist, auch wenn `ensure_unique_assignment` `false` war. Die Semantik ist "stelle sicher, dass es auf dem Ziel ist").
        5. Sonst (wurde neu hinzugefügt): `Ok(())`.
    - **`remove_window_from_workspace(...)` Logik:**
        1. Prüfe `source_workspace_id`. Wenn nicht gefunden: `Err(WorkspaceNotFound)`.
        2. Hole `source_ws = workspaces.get_mut(&source_workspace_id).unwrap()`.
        3. `Ok(source_ws.remove_window_id(window_id))`
    - **`move_window_to_workspace(...)` Logik:**
        1. Wenn `source_workspace_id == target_workspace_id`: `Err(CannotMoveToSameWorkspace)`.
        2. Prüfe `source_workspace_id`. Wenn nicht: `Err(SourceWorkspaceNotFound)`.
        3. Prüfe `target_workspace_id`. Wenn nicht: `Err(TargetWorkspaceNotFound)`.
        4. `source_ws = workspaces.get_mut(&source_workspace_id).unwrap()`.
        5. Wenn `!source_ws.remove_window_id(window_id)`: `Err(WindowNotOnSourceWorkspace)`.
        6. `target_ws = workspaces.get_mut(&target_workspace_id).unwrap()`.
        7. `target_ws.add_window_id(window_id.clone());` (Rückgabewert hier ignorieren, da wir wissen, dass es von der Quelle entfernt wurde).
        8. `Ok(())`.
    - **`find_workspace_for_window(...)` Logik:**
        1. Iteriere `workspaces.values()`.
        2. Wenn `ws.window_ids().contains(window_id)`, gib `Some(ws.id())` zurück.
        3. Sonst `None`.

#### 5.3. Untermodul: `domain::workspaces::config`

**Zweck:** Persistenzlogik für Workspace-Konfigurationen.

**Datei:** `src/workspaces/config/errors.rs`

- **Enum `WorkspaceConfigError`**: Wie in vorheriger Antwort (basierend auf).

**Datei:** `src/workspaces/config/mod.rs` (oder `provider.rs` und `types.rs` hier)

- **Struct `WorkspaceSnapshot`**: Wie in vorheriger Antwort. Zusätzlich `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct WorkspaceSnapshot {
        pub persistent_id: String, // Eindeutig über Sitzungen
        pub name: String,
        pub layout_type: WorkspaceLayoutType,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub icon_name: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub accent_color_hex: Option<String>,
    }
    ```
    
- **Struct `WorkspaceSetSnapshot`**: Wie in vorheriger Antwort (`workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`).
- **Trait `WorkspaceConfigProvider`**: Wie in vorheriger Antwort (`async fn load_workspace_config`, `async fn save_workspace_config`).
- **Struct `FilesystemConfigProvider`**:
    - **Felder:** `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`, `config_key_or_path: String` (z.B. "workspaces.toml").
    - **Konstruktor:** `pub fn new(config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, config_key_or_path: String) -> Self`.
    - **Implementierung von `WorkspaceConfigProvider`**:
        - **`load_workspace_config`**:
            1. `content_result = self.config_service.read_config_file_string(&self.config_key_or_path).await;`
            2. `match content_result { Ok(content_str) => { ... } Err(core_err) => { ... } }`
            3. Wenn `core_err` "nicht gefunden" signalisiert (z.B. `CoreError::Io` mit `ErrorKind::NotFound` oder spezifischer `ConfigError`-Typ): `Ok(WorkspaceSetSnapshot::default())` zurückgeben (Manager erstellt dann Standard).
            4. Wenn anderer `core_err`: `Err(WorkspaceConfigError::LoadError { ..., source: core_err })`.
            5. Wenn `Ok(content_str)`: `toml::from_str(&content_str).map_err(|e| DeserializationError { ... source: Some(e) })`.
            6. Nach Deserialisierung: Validierung (doppelte `persistent_id`s in `snapshot.workspaces`, Existenz von `active_workspace_persistent_id` im Set). Bei Fehlern `InvalidData` oder `PersistentIdNotFoundInLoadedSet`.
        - **`save_workspace_config`**:
            1. `serialized_content = toml::to_string_pretty(config_snapshot).map_err(|e| SerializationError { ... source: Some(e) })?;`
            2. `self.config_service.write_config_file_string(&self.config_key_or_path, serialized_content).await.map_err(|e| SaveError { ..., source: e })?;`

#### 5.4. Untermodul: `domain::workspaces::manager`

**Zweck:** Zentraler Orchestrator für Workspace-Operationen.

**Datei:** `src/workspaces/manager/events.rs`

- **Enum `WorkspaceEvent`**: Wie in vorheriger Antwort. Zusätzlich:
    - `WorkspaceIconChanged(WorkspaceIconChangedData)`
    - `WorkspaceAccentChanged(WorkspaceAccentChangedData)`

**Datei:** `src/workspaces/manager/errors.rs`

- **Enum `WorkspaceManagerError`**: Wie in vorheriger Antwort. Keine wesentlichen Änderungen.

**Datei:** `src/workspaces/manager/mod.rs` (oder `service.rs`)

- **Trait `WorkspaceManagerService`**: (Neuer Trait für die öffentliche API, um die Implementierung zu entkoppeln).
    
    Rust
    
    ```
    use async_trait::async_trait;
    // ... imports ...
    #[async_trait]
    pub trait WorkspaceManagerService: Send + Sync {
        async fn create_workspace(&self, name: Option<String>, persistent_id: Option<String>, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<WorkspaceId, WorkspaceManagerError>;
        async fn delete_workspace(&self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>;
        fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>; // Gibt Klon zurück
        fn all_workspaces_ordered(&self) -> Vec<Workspace>; // Gibt Klone zurück
        fn active_workspace_id(&self) -> Option<WorkspaceId>;
        async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;
        async fn assign_window_to_active_workspace(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>;
        async fn move_window_to_specific_workspace(&self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_layout(&self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_accent_color(&self, id: WorkspaceId, color_hex: Option<String>) -> Result<(), WorkspaceManagerError>;
        async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>;
        fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>;
        // Neu: Methode zur Änderung der Reihenfolge
        async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>;
    }
    ```
    
- **Struct `WorkspaceManager`** (umbenannt zu `DefaultWorkspaceManager` für die Implementierung).
    - **Felder:** `internal: Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>`.
- **Struct `WorkspaceManagerInternalState`**:
    - `workspaces: HashMap<WorkspaceId, Workspace>`
    - `active_workspace_id: Option<WorkspaceId>`
    - `ordered_workspace_ids: Vec<WorkspaceId>`
    - `next_workspace_number: u32`
    - `config_provider: Arc<dyn WorkspaceConfigProvider>`
    - `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`
    - `ensure_unique_window_assignment: bool`
- **Implementierung `#[async_trait] impl WorkspaceManagerService for DefaultWorkspaceManager`**:
    - **`new(...)`**:
        1. Sperrt `internal`, initialisiert Felder.
        2. `snapshot = self.internal.config_provider.load_workspace_config().await.map_err(WorkspaceManagerError::from)?;`
        3. Wenn `snapshot.workspaces` leer ist (oder `load_config` "nicht gefunden" signalisiert und Default zurückgibt):
            - Ruft `internal_create_workspace_locked` auf, um einen Standard-Workspace ("Workspace 1") zu erstellen.
            - Setzt diesen als aktiv.
        4. Sonst: Rekonstruiert `workspaces` und `ordered_workspace_ids` aus `snapshot`. Setzt `active_workspace_id` basierend auf `snapshot.active_workspace_persistent_id`.
        5. Aktualisiert `next_workspace_number`.
        6. Sendet `WorkspacesReloaded` und `ActiveWorkspaceChanged` Events.
    - **`create_workspace(...)`**:
        1. Sperrt `internal`.
        2. Prüft auf `DuplicatePersistentId`.
        3. Ruft `Workspace::new(...)`.
        4. Fügt zu `workspaces` und `ordered_workspace_ids` hinzu.
        5. Sendet `WorkspaceCreated`.
        6. Ruft `internal_save_configuration_locked()`.
    - **`delete_workspace(...)`**: Sperrt, prüft Bedingungen, verschiebt Fenster via `assignment`-Modul, sendet Events, speichert.
    - `get_workspace()` / `all_workspaces_ordered()`: Sperrt, klont die angeforderten `Workspace`-Objekte und gibt sie zurück.
    - **`set_active_workspace(...)`**: Sperrt, prüft, aktualisiert, sendet Event, speichert (optional).
    - **Fensterzuweisungsmethoden**: Sperren `internal`, rufen Funktionen aus `domain::workspaces::assignment` mit `&mut internal.workspaces` auf, senden Events.
    - **`rename_workspace(...)`, `set_workspace_layout(...)`, `set_workspace_icon(...)`, `set_workspace_accent_color(...)`**:
        1. Sperrt `internal`.
        2. Findet `workspace_mut` in `internal.workspaces`. Wenn nicht: `Err(WorkspaceNotFound)`.
        3. Ruft entsprechende `workspace_mut.set_...(...)` Methode auf.
        4. Sendet entsprechendes Event (`WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`).
        5. Ruft `internal_save_configuration_locked()`.
    - **`reorder_workspace(...)`**:
        1. Sperrt `internal`.
        2. Validiert `workspace_id` und `new_index`.
        3. Entfernt `workspace_id` aus `ordered_workspace_ids` und fügt es an `new_index` wieder ein.
        4. Sendet `WorkspaceOrderChanged` mit der neuen `ordered_workspace_ids` (als Klon).
        5. Ruft `internal_save_configuration_locked()`.
    - **`save_configuration()`**: Sperrt `internal`, ruft `internal_save_configuration_locked()`.
    - **`internal_save_configuration_locked()`**: Private Hilfsmethode, die den Snapshot erstellt und `config_provider.save_workspace_config()` aufruft.
    - **`subscribe_to_workspace_events()`**: `self.internal.lock().await.event_publisher.subscribe()`.

#### 5.5. Implementierungsschritte `domain::workspaces`

(Reihenfolge und Tests wie in vorheriger Antwort, aber mit Fokus auf `async` wo spezifiziert und `tokio::sync::Mutex`.)

1. **`core` Modul**: `Workspace` um neue Felder und Methoden erweitern. Neue Event-Payloads. `WorkspaceCoreError` erweitern. Tests.
2. **`assignment` Modul**: Implementierungslogik der Funktionen detaillieren und testen.
3. **`config` Modul**: `WorkspaceSnapshot` anpassen. `FilesystemConfigProvider` mit `async` Methoden und `ConfigServiceAsync`. Tests (Mocking).
4. **`manager` Modul**: `WorkspaceEvent` erweitern. `WorkspaceManagerService` Trait definieren. `DefaultWorkspaceManager` mit `tokio::sync::Mutex` und `async` Methoden implementieren. `reorder_workspace` Methode hinzufügen. Umfassende Tests.
5. **`src/workspaces/mod.rs`**: Module deklarieren, öffentliche API (Service-Trait, wichtige Typen, Fehler, Events) re-exportieren.

---

### Modul 6: `domain::window_management_policy`

Zweck: Definition von High-Level-Regeln und Richtlinien für Fensterplatzierung, Tiling, Snapping, Gruppierung, Fokus und Gap-Management. Definiert die "Policy", die Systemschicht die "Mechanik".

Verantwortlichkeiten: Bereitstellung von Algorithmen zur Berechnung von Fenstergeometrien basierend auf aktuellen Policies und Workspace-Zuständen.

Design-Rationale: Entkopplung der komplexen Layout- und Policy-Logik von der technischen Umsetzung im Compositor. Ermöglicht flexible und austauschbare Fensterverwaltungsstrategien.

#### 6.1. Untermodul: `domain::window_management_policy::types`

**Datei:** `src/window_management_policy/types.rs`

- **Enum `TilingMode`**: Wie in vorheriger Antwort (Manual, Columns, Rows, Spiral, MaximizedFocused).
- **Struct `GapSettings`**: Wie in vorheriger Antwort.
- **Struct `WindowSnappingPolicy`**: Wie in vorheriger Antwort.
- **Struct `WindowGroupingPolicy`**: Wie in vorheriger Antwort.
- **Enum `NewWindowPlacementStrategy`**: Wie in vorheriger Antwort.
- **Enum `FocusStealingPreventionLevel`**: Wie in vorheriger Antwort.
- **Struct `FocusPolicy`**: Wie in vorheriger Antwort.
- **Struct `WindowPolicyOverrides`**: Wie in vorheriger Antwort.
- **Struct `WorkspaceWindowLayout`**: Wie in vorheriger Antwort.
    - **Zusatzfeld**: `pub tiling_mode_applied: TilingMode` (Speichert, welcher Modus tatsächlich für dieses Layout verwendet wurde).
- **Struct `WindowLayoutInfo`** (neu, für die Übergabe an `calculate_workspace_layout`):
    
    Rust
    
    ```
    use crate::domain::workspaces::core::types::WindowIdentifier;
    use crate::core::types::Size; // u32 Annahme
    
    #[derive(Debug, Clone, PartialEq)]
    pub struct WindowLayoutInfo {
        pub id: WindowIdentifier,
        pub requested_min_size: Option<Size<u32>>, // Vom Client oder Policy
        pub requested_base_size: Option<Size<u32>>,// Für Größeninkremente (zukünftig)
        pub is_fullscreen_requested: bool,
        pub is_maximized_requested: bool, // Expliziter Maximierungswunsch vom Client/User
        // Weitere Flags, die das Layout beeinflussen könnten
    }
    ```
    

#### 6.2. Untermodul: `domain::window_management_policy::errors`

**Datei:** `src/window_management_policy/errors.rs`

- **Enum `WindowPolicyError`**: Wie in vorheriger Antwort.

#### 6.3. Untermodul: `domain::window_management_policy::service`

**Datei:** `src/window_management_policy/service.rs` (oder `mod.rs`)

- **Trait `WindowManagementPolicyService`**:
    
    - **`calculate_workspace_layout` Signatur angepasst:**
        
        Rust
        
        ```
        async fn calculate_workspace_layout(
            &self,
            workspace_id: WorkspaceId,
            windows_to_layout: &[WindowLayoutInfo], // Geänderter Typ
            available_area: RectInt,
            // Policy-Einstellungen werden jetzt intern vom Service über GlobalSettingsService bezogen
            // oder es gibt spezifische Methoden, um sie zu setzen/abzurufen.
            // Hier gehen wir davon aus, dass sie intern über GlobalSettingsService bezogen werden.
            workspace_current_tiling_mode: TilingMode, // Tiling-Modus, der für diesen Workspace gilt
            focused_window_id: Option<&WindowIdentifier>, // Optional, für MaximizedFocused
            window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>
        ) -> Result<WorkspaceWindowLayout, WindowPolicyError>;
        ```
        
    - **`get_initial_window_geometry` Signatur angepasst:**
        
        Rust
        
        ```
        async fn get_initial_window_geometry(
            &self,
            window_info: &WindowLayoutInfo, // Enthält requested_size etc.
            is_transient_for: Option<&WindowIdentifier>,
            parent_geometry: Option<RectInt>, // Geometrie des Elternfensters für transiente Fenster
            workspace_id: WorkspaceId,
            active_layout_on_workspace: &WorkspaceWindowLayout,
            available_area: RectInt,
            // placement_strategy wird intern vom Service via GlobalSettingsService bezogen
            window_specific_overrides: &Option<WindowPolicyOverrides>
        ) -> Result<RectInt, WindowPolicyError>;
        ```
        
    - **`calculate_snap_target`**: Signatur bleibt ähnlich.
    - **Neue Methoden zum Abruf von Teil-Policies (statt Übergabe von `GlobalDesktopSettings`):**
        
        Rust
        
        ```
        async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>;
        async fn get_effective_gap_settings_for_workspace(&self, workspace_id: WorkspaceId) -> Result<GapSettings, WindowPolicyError>;
        async fn get_effective_snapping_policy(&self) -> Result<WindowSnappingPolicy, WindowPolicyError>;
        async fn get_effective_focus_policy(&self) -> Result<FocusPolicy, WindowPolicyError>;
        async fn get_effective_new_window_placement_strategy(&self) -> Result<NewWindowPlacementStrategy, WindowPolicyError>;
        // Diese Methoden würden intern den GlobalSettingsService konsultieren und
        // ggf. Workspace-spezifische Overrides berücksichtigen (falls diese in Zukunft eingeführt werden).
        ```
        
- **Implementierung `DefaultWindowManagementPolicyService`**:
    
    - **Konstruktor:** `pub fn new(settings_service: Arc<dyn GlobalSettingsService>) -> Self`.
    - **`calculate_workspace_layout` Logik (verfeinert):**
        1. Holt `GapSettings` über `self.get_effective_gap_settings_for_workspace()`.
        2. `effective_area = available_area` abzüglich äußerer `screen_outer_horizontal/vertical` Gaps.
        3. **Floating-Fenster herausfiltern:** Identifiziere Fenster mit `is_always_floating == Some(true)` aus `window_specific_overrides` oder solche, die aufgrund von Client-Hints (z.B. feste Größe, Dialoge - Information nicht direkt hier verfügbar, muss von Systemschicht kommen und in `WindowLayoutInfo` oder `WindowPolicyOverrides` reflektiert werden) als floating behandelt werden sollen. Für diese wird keine Tiling-Geometrie berechnet; ihre Positionen/Größen bleiben (oder werden initial gesetzt).
        4. `tiled_windows: Vec<&WindowLayoutInfo>` = verbleibende Fenster.
        5. Wenn `tiled_windows` leer ist oder `workspace_current_tiling_mode == TilingMode::Manual`:
            - Für jedes `window_info` in `windows_to_layout` (auch die "floating" markierten):
                - Wenn es ein Override für `fixed_position`/`fixed_size` gibt, dieses verwenden.
                - Sonst: Rufe `self.get_initial_window_geometry(...)` für dieses Fenster auf, um eine initiale Platzierung zu erhalten (oder behalte die aktuelle Position, falls es ein Re-Layout ist).
            - `WorkspaceWindowLayout` mit diesen Geometrien und `tiling_mode_applied = TilingMode::Manual` zurückgeben.
        6. **Tiling-Logik (Beispiel für `TilingMode::Columns`):**
            - `num_tiled_windows = tiled_windows.len()`.
            - `total_inner_gaps_width = gap_settings.window_inner * (num_tiled_windows - 1) as u16`.
            - `allocatable_width = effective_area.width - total_inner_gaps_width`.
            - `width_per_window = allocatable_width / num_tiled_windows as u32`. (Restbreite könnte verteilt oder ignoriert werden).
            - `current_x = effective_area.x`.
            - Für jedes `window_info` in `tiled_windows`:
                - `height = effective_area.height`.
                - `actual_width = width_per_window`. Ggf. Mindestbreite aus `window_info.requested_min_size` oder `WindowPolicyOverrides` berücksichtigen und `actual_width` anpassen (komplexere Verteilung nötig, wenn Mindestbreiten Summe überschreiten).
                - Speichere `RectInt::new(current_x, effective_area.y, actual_width, height)` für `window_info.id`.
                - `current_x += actual_width as i32 + gap_settings.window_inner as i32`.
            - `WorkspaceWindowLayout` mit diesen Geometrien und `tiling_mode_applied = TilingMode::Columns` zurückgeben.
        7. **`TilingMode::MaximizedFocused` Logik:**
            - Wenn `focused_window_id` und dieses Fenster in `tiled_windows` ist:
                - Geometrie für `focused_window_id` ist `effective_area`.
                - Andere `tiled_windows` erhalten eine (0,0)-Größe oder werden nicht in die `window_geometries` Map aufgenommen (signalisiert "versteckt").
            - Sonst (kein Fokus oder fokussiertes Fenster ist floating): Falle zurück auf `Manual` oder einen anderen Default-Tiling-Modus.
        8. Algorithmen für `Rows` (analog zu Columns), `Spiral` (Fibonacci-Partitionierung des `effective_area`) implementieren.
    - **Interne Hilfsfunktionen für Layout-Algorithmen.**

#### 6.4. Detaillierte Implementierungsschritte `domain::window_management_policy`

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml`.
2. **`types.rs`**: Alle Policy-Typen (`TilingMode`, `GapSettings`, etc.), `WindowLayoutInfo`, `WorkspaceWindowLayout` definieren. `serde` und `Default`.
3. **`errors.rs`**: `WindowPolicyError` definieren.
4. **`service.rs`**:
    - `WindowManagementPolicyService`-Trait definieren mit den verfeinerten Signaturen.
    - `DefaultWindowManagementPolicyService`-Struktur mit `Arc<dyn GlobalSettingsService>`.
    - `new()`-Konstruktor implementieren.
    - `get_effective_*_policy()`-Methoden implementieren (lesen aus `GlobalSettingsService`).
    - `calculate_workspace_layout()`:
        - Implementiere Logik zum Herausfiltern von Floating-Fenstern.
        - Implementiere die spezifischen Layout-Algorithmen (Manual, Columns, Rows, Spiral, MaximizedFocused) als private Methoden, die `available_area`, `gap_settings` und die Liste der zu kachelnden Fenster berücksichtigen.
        - Stelle sicher, dass Mindest-/Maximalgrößen und Overrides aus `WindowPolicyOverrides` beachtet werden.
    - `get_initial_window_geometry()`: Implementiere verschiedene Strategien (`Smart`, `Center` etc.).
    - `calculate_snap_target()`: Implementiere Snapping-Logik.
5. **Unit-Tests**:
    - Für jeden Layout-Algorithmus: Verschiedene Anzahlen von Fenstern, verschiedene `available_area`, verschiedene Gap-Settings. Teste auch mit Mindestgrößen.
    - Für `get_initial_window_geometry`: Teste alle Platzierungsstrategien.
    - Für `calculate_snap_target`: Teste Snapping an Bildschirmränder und andere Fenster.
    - Für die Service-Methoden: Mocking des `GlobalSettingsService`. Teste, dass die korrekten Policies abgerufen und angewendet werden.

---

Die detaillierten Spezifikationen für die Module 7 (`user_centric_services`) und 8 (`notifications_rules`) werden in der nächsten Antwort folgen, basierend auf dieser Struktur und Methodik.
### Modul 7: `domain::user_centric_services`

Zweck: Bündelt die Logik für Dienste, die direkt auf die Bedürfnisse und Interaktionen des Benutzers ausgerichtet sind, insbesondere KI-Interaktionen (inklusive Einwilligungsmanagement) und ein umfassendes Benachrichtigungssystem.

Verantwortlichkeiten: Verwaltung von KI-Interaktionskontexten, Benutzereinwilligungen und KI-Modellprofilen. Entgegennahme, Verarbeitung, Speicherung und Verwaltung von System- und Anwendungsbenachrichtigungen.

Design-Rationale: Zentralisierung benutzerorientierter Dienste, um eine kohärente und kontrollierte Benutzererfahrung in Bezug auf Assistenzfunktionen und Benachrichtigungen zu ermöglichen. Trennung der Domänenlogik von der technischen Umsetzung (MCP-Kommunikation, D-Bus-Notification-Daemon-Interaktion) in der Systemschicht und der Darstellung in der UI-Schicht.

Bestehende Spezifikation: und vorherige Antworten.

#### 7.1. Untermodul: `domain::user_centric_services::ai_interaction`

**Zweck:** Verwaltung von KI-Interaktionen, Benutzereinwilligungen und KI-Modellprofilen.

**Datei:** `src/user_centric_services/ai_interaction/types.rs`

- **Enum `AIDataCategory`**
    
    - **Definition:** Wie in (UserProfile, ApplicationUsage, FileSystemRead, ClipboardAccess, LocationData, GenericText, GenericImage).
    - **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`.
    - **Zusatz:**
        
        Rust
        
        ```
        // Optional: Methode zur menschenlesbaren Beschreibung
        impl AIDataCategory {
            pub fn description(&self) -> &'static str {
                match self {
                    AIDataCategory::UserProfile => "Persönliche Profilinformationen (z.B. Name, Einstellungen)",
                    AIDataCategory::ApplicationUsage => "Informationen über genutzte Anwendungen und deren Aktivität",
                    AIDataCategory::FileSystemRead => "Lesezugriff auf das Dateisystem",
                    AIDataCategory::ClipboardAccess => "Zugriff auf den Inhalt der Zwischenablage",
                    AIDataCategory::LocationData => "Standortinformationen",
                    AIDataCategory::GenericText => "Allgemeiner Textinhalt (z.B. vom Benutzer eingegeben)",
                    AIDataCategory::GenericImage => "Allgemeiner Bildinhalt",
                }
            }
        }
        ```
        
- **Enum `AIConsentStatus`**
    
    - **Definition:** Wie in (Granted, Denied, PendingUserAction, NotRequired).
    - **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`.
- **Struct `AttachmentData`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        use uuid::Uuid;
        use serde::{Serialize, Deserialize};
        
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AttachmentData {
            pub id: Uuid,
            pub mime_type: String, // z.B. "text/plain", "image/png", "application/pdf"
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub source_uri: Option<String>, // z.B. "file:///path/to/file.txt"
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub content_base64: Option<String>, // Base64-kodierter Inhalt für Binärdaten
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub text_content: Option<String>, // Für reinen Textinhalt
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub description: Option<String>,
        }
        
        impl AttachmentData {
            pub fn new_text(text: String, description: Option<String>) -> Self { /* ... */ }
            pub fn new_from_uri(uri: String, mime_type: String, description: Option<String>) -> Self { /* ... */ }
            // new_from_binary_content(content: Vec<u8>, mime_type: String, description: Option<String>) -> Self
        }
        ```
        
    - **Verfeinerung:** `content: Option<Vec<u8>>` wird zu `content_base64: Option<String>` für leichtere Serialisierung (JSON) und `text_content: Option<String>`. `source_uri` bleibt für Verweise.
- **Struct `AIInteractionContext`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        use chrono::{DateTime, Utc};
        // ... andere Imports ...
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AIInteractionContext {
            pub id: Uuid,
            pub creation_timestamp: DateTime<Utc>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub active_model_id: Option<String>, // ID des KI-Modells
            pub consent_status: AIConsentStatus,
            pub associated_data_categories: Vec<AIDataCategory>,
            // interaction_history als separate Struktur für mehr Flexibilität
            pub history_entries: Vec<InteractionHistoryEntry>,
            pub attachments: Vec<AttachmentData>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub user_prompt_template: Option<String>, // Vorlage für den initialen Prompt
            #[serde(default)]
            pub is_active: bool, // Ob dieser Kontext gerade "offen" oder aktiv in der UI ist
        }
        ```
        
    - **Neue Struktur `InteractionHistoryEntry`**:
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub enum InteractionParticipant { User, Assistant, System }
        
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InteractionHistoryEntry {
            pub entry_id: Uuid,
            pub timestamp: DateTime<Utc>,
            pub participant: InteractionParticipant,
            pub content: String, // Text der Nachricht/Aktion
            #[serde(default, skip_serializing_if = "Vec::is_empty")]
            pub related_attachment_ids: Vec<Uuid>, // IDs von Attachments, die sich auf diesen Eintrag beziehen
        }
        ```
        
- **Struct `AIConsent`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
        pub struct AIConsent {
            pub id: Uuid, // Eindeutige ID der Einwilligung selbst
            pub user_id: String, // Vereinfacht, könnte komplexer sein
            pub model_id: String, // Für welches spezifische Modell oder "*" für alle
            pub data_category: AIDataCategory, // Einwilligung pro Kategorie
            pub granted_timestamp: DateTime<Utc>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub expiry_timestamp: Option<DateTime<Utc>>,
            pub is_revoked: bool,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub last_used_timestamp: Option<DateTime<Utc>>, // Wann zuletzt genutzt
            pub consent_scope: AIConsentScope, // Neu
        }
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
        pub enum AIConsentScope { #[default] SessionOnly, PersistentUntilRevoked, SpecificDuration }
        ```
        
    - **Verfeinerung:** `data_categories: Vec<AIDataCategory>` wird zu `data_category: AIDataCategory`, um granularere Einwilligungen pro Kategorie zu ermöglichen (d.h. ein `AIConsent`-Objekt pro (user, model, category)-Tupel). `AIConsentScope` hinzugefügt.
- **Struct `AIModelProfile`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
        pub struct AIModelProfile {
            pub model_id: String, // Eindeutig, z.B. "local-llama3-8b", "openai-gpt-4o"
            pub display_name: String,
            pub description: String,
            pub provider: String, // z.B. "Local", "OpenAI", "Groq"
            pub required_consent_categories: Vec<AIDataCategory>,
            pub capabilities: Vec<AIModelCapability>, // Enum statt String
            pub supports_streaming: bool, // Gibt das Modell Antworten im Stream zurück?
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub endpoint_url: Option<String>, // Für Remote-Modelle
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub api_key_secret_name: Option<String>, // Name des Secrets im Secret Service
            #[serde(default)]
            pub is_default_model: bool, // Kann nur ein Modell Default sein
            #[serde(default)]
            pub sort_order: i32, // Für die Anzeige in UI-Auswahlen
        }
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AIModelCapability { TextGeneration, CodeGeneration, Summarization, Translation, ImageAnalysis, FunctionCalling }
        ```
        
    - **Verfeinerung:** `capabilities` als Enum `AIModelCapability`. Zusätzliche Felder `supports_streaming`, `endpoint_url`, `api_key_secret_name`, `is_default_model`, `sort_order`.

**Datei:** `src/user_centric_services/ai_interaction/errors.rs`

- **Enum `AIInteractionError`**: Wie in. Zusätzlich/Verfeinert:
    - `ConsentCheckFailed { model_id: String, category: AIDataCategory, reason: String }`
    - `ApiKeyNotFoundInSecrets { secret_name: String }`
    - `ModelEndpointUnreachable { model_id: String, url: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }` (Dieser Fehler käme eher von der Systemschicht, wird hier aber als möglicher Domänenfehler bei der Modellvalidierung aufgeführt)
    - `NoDefaultModelConfigured`
    - `CoreConfigError(#[from] novade_core::config::ConfigError)` (Wenn Laden von Profilen/Consents fehlschlägt)

**Datei:** `src/user_centric_services/ai_interaction/persistence_iface.rs`

- **Trait `AIConsentProvider`**:
    
    Rust
    
    ```
    #[async_trait]
    pub trait AIConsentProvider: Send + Sync {
        async fn load_consents_for_user(&self, user_id: &str) -> Result<Vec<AIConsent>, AIInteractionError>;
        async fn save_consent(&self, consent: &AIConsent) -> Result<(), AIInteractionError>;
        async fn revoke_consent(&self, consent_id: Uuid, user_id: &str) -> Result<(), AIInteractionError>;
        // Ggf. Methode zum Löschen abgelaufener Consents
    }
    ```
    
- **Trait `AIModelProfileProvider`**:
    
    Rust
    
    ```
    #[async_trait]
    pub trait AIModelProfileProvider: Send + Sync {
        async fn load_model_profiles(&self) -> Result<Vec<AIModelProfile>, AIInteractionError>;
        // Ggf. async fn save_model_profiles(&self, profiles: &[AIModelProfile]) -> Result<(), AIInteractionError>;
    }
    ```
    
- **Implementierungen** (z.B. `FilesystemAIConsentProvider`, `FilesystemAIModelProfileProvider`) in einem `persistence.rs` Untermodul, die `Arc<dyn novade_core::config::ConfigServiceAsync>` nutzen, um Daten als TOML/JSON in spezifischen Dateien unter `$XDG_CONFIG_HOME/novade/ai/` zu speichern/laden.

**Datei:** `src/user_centric_services/ai_interaction/service.rs` (oder `mod.rs`)

- **Trait `AIInteractionLogicService`**:
    - **Signaturen:** Wie in.
    - **Zusätzliche Methoden/Verfeinerungen:**
        - `async fn get_consent_status_for_interaction(&self, context_id: Uuid, model_id: &str, required_categories: &[AIDataCategory]) -> Result<AIConsentStatus, AIInteractionError>;` (Prüft spezifisch für einen Kontext)
        - `async fn get_default_model(&self) -> Result<Option<AIModelProfile>, AIInteractionError>;`
        - `async fn update_interaction_history(&mut self, context_id: Uuid, entry: InteractionHistoryEntry) -> Result<(), AIInteractionError>;`
- **Implementierung `DefaultAIInteractionLogicService`**:
    - **Felder:**
        - `active_contexts: Arc<tokio::sync::Mutex<HashMap<Uuid, AIInteractionContext>>>`
        - `model_profiles: Arc<tokio::sync::RwLock<Vec<AIModelProfile>>>`
        - `user_consents: Arc<tokio::sync::Mutex<HashMap<String /* user_id */, Vec<AIConsent>>>>`
        - `consent_provider: Arc<dyn AIConsentProvider>`
        - `profile_provider: Arc<dyn AIModelProfileProvider>`
        - `event_publisher: tokio::sync::broadcast::Sender<super::events::AIInteractionEventEnum>` (Wrapper-Enum für Events)
    - **Konstruktor `new(...)`**: Nimmt Provider, lädt initial Profile und Consents für den aktuellen Benutzer.
    - **Logik `initiate_interaction`**: Erstellt `AIInteractionContext`, speichert in `active_contexts`, sendet `AIInteractionInitiatedEvent`.
    - **Logik `provide_consent`**:
        1. Findet oder erstellt `AIConsent`-Objekt(e) basierend auf `model_id`, `granted_categories`, `consent_decision`.
        2. Ruft `consent_provider.save_consent()` auf.
        3. Aktualisiert `user_consents` Cache.
        4. Aktualisiert `consent_status` im `AIInteractionContext` (falls `context_id` gegeben).
        5. Sendet `AIConsentUpdatedEvent`.
    - **Logik `get_consent_status_for_interaction`**:
        1. Lädt `active_model_id` aus `AIInteractionContext` (falls nicht direkt übergeben).
        2. Iteriert `required_categories`. Für jede Kategorie:
            - Sucht in `self.user_consents` nach einem gültigen (nicht abgelaufen, nicht widerrufen) `AIConsent` für den `user_id` (aus Kontext, hier vereinfacht), `model_id` und die `category`.
            - Wenn für eine Kategorie keine explizite Zustimmung (Granted) gefunden wird -> `AIConsentStatus::PendingUserAction` oder `Denied` (wenn zuvor explizit verweigert).
        3. Wenn für alle `Granted` -> `AIConsentStatus::Granted`.
        4. Wenn `model_profile.required_consent_categories` leer ist -> `AIConsentStatus::NotRequired`.
- **Events:** (Wrapper-Enum `AIInteractionEventEnum` für `tokio::sync::broadcast`)
    - `AIInteractionInitiatedEvent { context: AIInteractionContext }` (Payload enthält ganzen Kontext)
    - `AIConsentUpdatedEvent { user_id: String, model_id: String, category: AIDataCategory, new_status: AIConsentStatus, scope: AIConsentScope }`
    - `AIContextUpdatedEvent { context_id: Uuid, updated_field: String /* z.B. "history", "attachment" */}`
    - `AIModelProfilesReloadedEvent { profiles: Vec<AIModelProfile> }`

#### 7.2. Untermodul: `domain::user_centric_services::notifications_core`

**Zweck:** Kernlogik für das Verwalten von Benachrichtigungen.

**Datei:** `src/user_centric_services/notifications_core/types.rs`

- **Enum `NotificationUrgency`**: Wie in (Low, Normal, Critical).
- **Enum `NotificationActionType`**: Wie in (Callback, OpenLink).
- **Struct `NotificationAction`**: Wie in.
- **Struct `Notification`**: Wie in.
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct Notification {
        pub id: Uuid,
        pub application_name: String, // Optional: ApplicationId statt String
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub application_icon: Option<String>, // Icon-Name oder Pfad
        pub summary: String, // Darf nicht leer sein
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub body: Option<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub actions: Vec<NotificationAction>,
        pub urgency: NotificationUrgency,
        pub timestamp: DateTime<Utc>, // Zeitpunkt des Eintreffens in diesem Service
        #[serde(default)]
        pub is_read: bool,
        #[serde(default)]
        pub is_dismissed: bool, // Vom Benutzer aktiv geschlossen
        #[serde(default)]
        pub transient: bool, // Nicht in Historie speichern, wenn true
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub category: Option<String>, // Standardkategorien: "device", "email", "im", "transfer" etc.
        #[serde(default, skip_serializing_if = "HashMap::is_empty")]
        pub hints: HashMap<String, serde_json::Value>, // Für zusätzliche Daten (z.B. x-coordinates, image-data)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub timeout_ms: Option<u32>, // 0 für persistent, None für Standard-Timeout
    }
    impl Notification { /* ... new() ... mark_as_read(), dismiss() ... */ }
    ```
    
    - **Verfeinerung:** Zusätzliche Felder `category`, `hints`, `timeout_ms`.
- **Enum `NotificationFilterCriteria`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum NotificationFilterCriteria {
        Unread(bool), // true für nur ungelesene, false für nur gelesene
        Application(ApplicationId),
        Urgency(NotificationUrgency),
        Category(String),
        HasAction(String), // Action Key
        BodyContains(String),
        SummaryContains(String),
        IsTransient(bool),
        AndTimeRange { // Neu
            start: Option<DateTime<Utc>>,
            end: Option<DateTime<Utc>>,
        },
        And(Vec<NotificationFilterCriteria>), // Neu
        Or(Vec<NotificationFilterCriteria>),  // Neu
        Not(Box<NotificationFilterCriteria>), // Neu
    }
    ```
    
- **Enum `NotificationSortOrder`**: Wie in (TimestampAscending, TimestampDescending, Urgency). Zusätzlich: `ApplicationNameAscending`, `SummaryAscending`.

**Datei:** `src/user_centric_services/notifications_core/errors.rs`

- **Enum `NotificationError`**: Wie in. Zusätzlich:
    - `InvalidFilterCriteria(String)`
    - `ActionInvocationFailed { notification_id: Uuid, action_id: String, reason: String }`

**Datei:** `src/user_centric_services/notifications_core/service.rs` (oder `mod.rs`)

- **Trait `NotificationService`**:
    - **Signaturen:** Wie in.
    - `post_notification` nimmt `notification_data: NotificationInput` (eine vereinfachte Struktur ohne `id`, `timestamp`, `is_read`, `is_dismissed`).
    - **Neue Methoden:**
        - `async fn get_stats(&self) -> Result<NotificationStats, NotificationError>;`
        - `async fn clear_all_for_app(&mut self, app_id: &ApplicationId) -> Result<usize, NotificationError>;` (gibt Anzahl gelöschter zurück)
- **Implementierung `DefaultNotificationService`**:
    - **Felder:**
        - `active_notifications: Arc<tokio::sync::RwLock<VecDeque<Notification>>>` (VecDeque für einfaches FIFO-Verhalten, wenn ein Limit für aktive Popups existiert)
        - `history: Arc<tokio::sync::RwLock<VecDeque<Notification>>>`
        - `dnd_enabled: Arc<tokio::sync::RwLock<bool>>`
        - `rules_engine: Arc<dyn domain::notifications_rules::NotificationRulesEngine>` (Abhängigkeit injiziert)
        - `settings_service: Arc<dyn domain::global_settings_and_state_management::GlobalSettingsService>` (für MAX_HISTORY etc.)
        - `event_publisher: tokio::sync::broadcast::Sender<super::events::NotificationEventEnum>`
        - `max_active_popups: usize` (aus Einstellungen)
        - `max_history_items: usize` (aus Einstellungen)
    - **Konstruktor `new(...)`**: Nimmt Abhängigkeiten, lädt `max_active_popups` und `max_history_items` aus `settings_service`.
    - **Logik `post_notification(input: NotificationInput)`**:
        1. Erstellt `Notification`-Objekt aus `input`, generiert `id`, setzt `timestamp`.
        2. `processed_notification_option = self.rules_engine.process_notification(&mut notification_from_input, &current_global_settings).await?`
        3. Wenn `processed_notification_option` `None` ist (Regel hat unterdrückt) -> `Ok(notification_from_input.id)` (oder spezifischer Rückgabewert/Event).
        4. `let final_notification = processed_notification_option.unwrap();`
        5. Prüfe `dnd_enabled` und `final_notification.urgency`.
        6. Wenn nicht unterdrückt: Füge zu `active_notifications` hinzu. Wenn `max_active_popups` überschritten, ältestes entfernen (und ggf. Event für "Popup abgelaufen" senden). Sendet `NotificationPostedEvent { notification: final_notification.clone(), suppressed_by_dnd: false }`.
        7. Wenn unterdrückt: Sendet `NotificationPostedEvent { notification: final_notification.clone(), suppressed_by_dnd: true }`.
        8. Wenn `!final_notification.transient`: Füge zu `history` hinzu. Wenn `max_history_items` überschritten, ältestes aus `history` entfernen.
        9. `Ok(final_notification.id)`.
    - **Logik `get_active_notifications` / `get_notification_history`**: Implementiert Filterung (rekursiv für And/Or/Not) und Sortierung.
- **Struct `NotificationInput`**: Enthält Felder, die ein Client zum Erstellen einer Benachrichtigung bereitstellt (ohne `id`, `timestamp`, `is_read`, `is_dismissed`).
- **Struct `NotificationStats`**: `num_active: usize`, `num_history: usize`, `num_unread: usize`.
- **Events:** (Wrapper-Enum `NotificationEventEnum`)
    - `NotificationPostedEvent { notification: Notification, suppressed_by_dnd: bool }`
    - `NotificationDismissedEvent { notification_id: Uuid, reason: DismissReason }` (Grund für Dismiss, z.B. User, Timeout, Replaced)
    - `NotificationReadEvent { notification_id: Uuid }`
    - `NotificationActionInvokedEvent { notification_id: Uuid, action_key: String }`
    - `DoNotDisturbModeChangedEvent { dnd_enabled: bool }`
    - `NotificationHistoryClearedEvent`
    - `NotificationPopupExpiredEvent { notification_id: Uuid }` (Wenn aus aktiven Popups entfernt wegen Limit)

**Datei:** `src/user_centric_services/mod.rs`

- Deklariert Submodule `ai_interaction`, `notifications_core`, und ein gemeinsames `events.rs`.
- Re-exportiert öffentliche Traits (`AIInteractionLogicService`, `NotificationService`), Event-Enums und wichtige Typen.

#### 7.3. Implementierungsschritte `domain::user_centric_services`

1. **Grundgerüst:** Verzeichnisse für `ai_interaction` und `notifications_core` sowie gemeinsames `events.rs`.
2. **`ai_interaction` Modul:**
    - `types.rs`: Alle KI-bezogenen Typen und Enums.
    - `errors.rs`: `AIInteractionError`.
    - `persistence_iface.rs`: `AIConsentProvider`, `AIModelProfileProvider` Traits.
    - `persistence.rs` (intern): Implementierungen der Provider-Traits (z.B. `Filesystem...Provider`), die `Arc<dyn novade_core::config::ConfigServiceAsync>` nutzen.
    - `service.rs`: `AIInteractionLogicService`-Trait und `DefaultAIInteractionLogicService`-Implementierung.
    - Unit-Tests für Typen, Fehler, Provider-Implementierungen (Mocking `ConfigServiceAsync`), Service-Logik.
3. **`notifications_core` Modul:**
    - `types.rs`: Alle Benachrichtigungs-bezogenen Typen und Enums. `NotificationInput`.
    - `errors.rs`: `NotificationError`.
    - `service.rs`: `NotificationService`-Trait und `DefaultNotificationService`-Implementierung (nimmt `NotificationRulesEngine`, `GlobalSettingsService` als Abhängigkeiten).
    - Unit-Tests für Typen, Fehler, Service-Logik (insb. DND, History-Limit, Filter/Sort). Mocking von `NotificationRulesEngine` und `GlobalSettingsService`.
4. **`user_centric_services/events.rs`**: Event-Wrapper-Enums (`AIInteractionEventEnum`, `NotificationEventEnum`) definieren.
5. **`user_centric_services/mod.rs`**: Öffentliche API re-exportieren.
6. **Abhängigkeiten in `Cargo.toml`** für `user_centric_services` prüfen (insbesondere `uuid`, `chrono`, `serde`, `thiserror`, `async-trait`, `tokio`).

---

### Modul 8: `domain::notifications_rules`

Zweck: Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln. Diese Regeln modifizieren oder unterdrücken Benachrichtigungen, bevor sie dem Benutzer präsentiert oder in der Historie gespeichert werden.

Verantwortlichkeiten: Definition von Regelstrukturen, Laden/Speichern von Regeldefinitionen, Auswerten von Regeln gegen eingehende Benachrichtigungen.

Design-Rationale: Entkopplung der komplexen Regellogik vom Kern-Benachrichtigungsdienst. Ermöglicht es Benutzern oder Administratoren, das Benachrichtigungsverhalten fein granular anzupassen.

**Datei:** `src/notifications_rules/types.rs`

- **Enum `RuleConditionValue`** (neu, für Vergleiche):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum RuleConditionValue {
        String(String),
        Integer(i64),
        Boolean(bool),
        Urgency(NotificationUrgency), // NotificationUrgency aus notifications_core::types
        Regex(String), // Für Regex-Matching
    }
    ```
    
- **Enum `RuleConditionOperator`** (neu):
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum RuleConditionOperator {
        Is, IsNot,
        Contains, NotContains,
        StartsWith, EndsWith,
        MatchesRegex, NotMatchesRegex, // Für String-Werte gegen Regex
        GreaterThan, LessThan, GreaterThanOrEqual, LessThanOrEqual, // Für Integer
    }
    ```
    
- **Struct `RuleConditionField`** (neu, um das Feld der Notification zu spezifizieren):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum RuleConditionField {
        ApplicationName,
        Summary,
        Body,
        Urgency, // Vergleicht mit NotificationUrgency
        Category,
        HintExists(String), // Prüft Existenz eines Hints
        HintValue(String),  // Prüft Wert eines Hints (benötigt Operator und RuleConditionValue)
        // Zukünftig: ApplicationId, etc.
    }
    ```
    
- **Struct `SimpleRuleCondition`** (neu, für atomare Bedingungen):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SimpleRuleCondition {
        pub field: RuleConditionField,
        pub operator: RuleConditionOperator,
        pub value: RuleConditionValue, // Wert, mit dem verglichen wird
    }
    ```
    
- **Enum `RuleCondition`** (rekursiv):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum RuleCondition {
        Simple(SimpleRuleCondition),
        SettingIsTrue(crate::global_settings_and_state_management::paths::SettingPath), // Pfad zu einer booleschen Einstellung
        And(Vec<RuleCondition>),
        Or(Vec<RuleCondition>),
        Not(Box<RuleCondition>),
    }
    ```
    
- **Enum `RuleAction`**:
    
    Rust
    
    ```
    use novade_core::types::Color as CoreColor; // Für das Setzen von Akzenten
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum RuleAction {
        SuppressNotification, // Benachrichtigung komplett unterdrücken
        SetUrgency(NotificationUrgency),
        AddActionToNotification(NotificationAction), // NotificationAction aus notifications_core::types
        SetHint(String /* key */, serde_json::Value /* value */),
        PlaySound(String /* sound_name_or_path */),
        MarkAsPersistent(bool), // Überschreibt transient-Flag der Notification
        SetTimeoutMs(Option<u32>), // Überschreibt Timeout
        SetCategory(String),
        // Neu:
        SetSummary(String), // Kann Template-Variablen enthalten, z.B. "{{original_summary}} - Wichtig!"
        SetBody(String),    // dito
        SetIcon(String),    // Icon-Name oder Pfad
        SetAccentColor(Option<CoreColor>), // Spezifische Akzentfarbe für diese Benachrichtigung
        StopProcessingFurtherRules, // Verhindert, dass nachfolgende Regeln ausgewertet werden
        LogMessage(String), // Loggt eine Nachricht, wenn die Regel zutrifft (für Debugging)
    }
    ```
    
- **Struct `NotificationRule`**:
    
    Rust
    
    ```
    use uuid::Uuid;
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct NotificationRule {
        pub id: Uuid,
        pub name: String, // Menschenlesbarer Name/Beschreibung der Regel
        pub condition: RuleCondition, // Die Bedingung(en)
        pub actions: Vec<RuleAction>, // Aktionen, die ausgeführt werden, wenn Bedingung zutrifft
        pub is_enabled: bool,
        pub priority: i32, // Höhere Zahl = höhere Priorität (wird früher ausgewertet)
        // stop_processing_after_match ist jetzt eine RuleAction::StopProcessingFurtherRules
    }
    impl Default for NotificationRule { /* ... id = new_v4(), is_enabled = true, priority = 0 ... */ }
    ```
    
- **Typalias `NotificationRuleSet`**: `pub type NotificationRuleSet = Vec<NotificationRule>;`

**Datei:** `src/notifications_rules/errors.rs`

- **Enum `NotificationRulesError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use super::types::NotificationRule; // Pfad ggf. anpassen
    
    #[derive(Debug, Error)]
    pub enum NotificationRulesError {
        #[error("Invalid rule definition for rule '{rule_name}' (ID: {rule_id}): {reason}")]
        InvalidRuleDefinition { rule_id: uuid::Uuid, rule_name: String, reason: String },
        #[error("Error evaluating condition for rule '{rule_name}' (ID: {rule_id}): {details}")]
        ConditionEvaluationError { rule_id: uuid::Uuid, rule_name: String, details: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> },
        #[error("Error applying action for rule '{rule_name}' (ID: {rule_id}): {details}")]
        ActionApplicationError { rule_id: uuid::Uuid, rule_name: String, details: String },
        #[error("Error accessing global settings for rule condition evaluation: {0}")]
        SettingsAccessError(#[from] crate::global_settings_and_state_management::GlobalSettingsError), // Pfad anpassen
        #[error("Error loading or saving notification rules: {0}")]
        RulePersistenceError(#[from] novade_core::errors::CoreError), // Annahme: Provider nutzt CoreError für I/O
        #[error("Invalid regex in rule condition: {0}")]
        InvalidRegex(String),
        #[error("An internal error occurred in notification rules engine: {0}")]
        InternalError(String),
    }
    ```
    

**Datei:** `src/notifications_rules/persistence_iface.rs`

- **Trait `NotificationRulesProvider`**: Wie in vorheriger Antwort.

**Datei:** `src/notifications_rules/persistence.rs` (intern)

- **Struct `FilesystemNotificationRulesProvider`**: Implementiert `NotificationRulesProvider`, nutzt `Arc<dyn novade_core::config::ConfigServiceAsync>` zum Laden/Speichern der `NotificationRuleSet` (z.B. als JSON-Array in `$XDG_CONFIG_HOME/novade/notification_rules.json`).

**Datei:** `src/notifications_rules/engine.rs` (oder `service.rs` / `mod.rs`)

- **Enum `RuleProcessingResult`**:
    
    Rust
    
    ```
    use crate::user_centric_services::notifications_core::types::Notification; // Pfad anpassen
    
    #[derive(Debug, Clone, PartialEq)]
    pub enum RuleProcessingResult {
        Allow(Notification),      // Benachrichtigung (ggf. modifiziert) erlauben
        Suppress { rule_id: uuid::Uuid }, // Benachrichtigung aufgrund dieser Regel unterdrücken
    }
    ```
    
- **Trait `NotificationRulesEngine`**:
    
    Rust
    
    ```
    use async_trait::async_trait;
    use crate::user_centric_services::notifications_core::types::Notification;
    use crate::global_settings_and_state_management::types::GlobalDesktopSettings;
    use super::types::NotificationRuleSet; // Eigene Typen
    use super::errors::NotificationRulesError;
    
    #[async_trait]
    pub trait NotificationRulesEngine: Send + Sync {
        /// Lädt oder aktualisiert die im System verwendeten Regeln.
        async fn reload_rules(&self) -> Result<(), NotificationRulesError>;
    
        /// Verarbeitet eine eingehende Benachrichtigung gegen die geladenen Regeln.
        /// Kann die Benachrichtigung modifizieren oder deren Unterdrückung signalisieren.
        async fn process_notification(
            &self,
            notification: Notification, // Nimmt Ownership, gibt ggf. modifizierte zurück
            // settings_snapshot: &GlobalDesktopSettings, // Benötigt aktuellen Snapshot für SettingIsTrue
        ) -> Result<RuleProcessingResult, NotificationRulesError>;
    
        /// Gibt die aktuell geladenen Regeln zurück (z.B. für UI zur Anzeige/Bearbeitung).
        async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>;
    
        /// Speichert einen neuen Satz von Regeln.
        async fn update_rules(&self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>;
    }
    ```
    
- **Implementierung `DefaultNotificationRulesEngine`**:
    - **Felder:**
        - `rules: Arc<tokio::sync::RwLock<NotificationRuleSet>>`
        - `rules_provider: Arc<dyn NotificationRulesProvider>`
        - `settings_service: Arc<dyn crate::global_settings_and_state_management::GlobalSettingsService>`
    - **Konstruktor `new(...)`**: Nimmt Provider, lädt initial Regeln via `reload_rules_internal_locked()`.
    - **`reload_rules()`**: Sperrt `rules`-Lock, ruft `rules_provider.load_rules()`, sortiert nach `priority`, aktualisiert `self.rules`.
    - **`process_notification(...)` Logik:**
        1. Holt Lesesperre für `self.rules`. Holt aktuellen Snapshot der `GlobalDesktopSettings` vom `settings_service`.
        2. Iteriert durch eine Kopie der `enabled_rules` (sortiert nach `priority` DESC).
        3. `let mut current_notification = notification;` (mutable Kopie für mögliche Modifikationen).
        4. Für jede Regel:
            - `match self.evaluate_condition_recursive(&rule.condition, &current_notification, &settings_snapshot).await { ... }`
            - Wenn `Ok(true)` (Bedingung erfüllt):
                - `let stop_after_this = self.apply_actions_internal(&rule.actions, &mut current_notification, &rule).await?;`
                - Wenn eine Aktion `SuppressNotification` war: `return Ok(RuleProcessingResult::Suppress { rule_id: rule.id });`
                - Wenn `stop_after_this` (durch `RuleAction::StopProcessingFurtherRules`): `break;` (aus der Regelschleife).
            - Bei `Err(e)`: Logge Fehler, fahre ggf. mit nächster Regel fort oder gib Fehler zurück.
        5. `Ok(RuleProcessingResult::Allow(current_notification))`.
    - **`evaluate_condition_recursive(...)` Logik:**
        - `Simple(simple_cond)`: Wertet Feld gegen `operator` und `value` aus. Für `HintValue`, `Regex` etc.
        - `SettingIsTrue(setting_path)`: Ruft `settings_service.get_setting(&setting_path)` ab, prüft ob `serde_json::Value::Bool(true)`.
        - `And`, `Or`, `Not`: Rekursive Auswertung.
    - **`apply_actions_internal(...)` Logik:** Modifiziert `current_notification` basierend auf `RuleAction`s. Gibt `bool` zurück, ob Verarbeitung gestoppt werden soll.
    - **`get_rules()`**: Sperrt, klont, gibt `self.rules` zurück.
    - **`update_rules(...)`**: Sperrt, ersetzt `self.rules`, ruft `rules_provider.save_rules()` auf.

**Datei:** `src/notifications_rules/mod.rs`

- Deklariert Submodule. Re-exportiert `NotificationRulesEngine`-Trait, `NotificationRule`, `RuleCondition`, `RuleAction`, `NotificationRulesError`, `RuleProcessingResult` und den `NotificationRulesProvider`-Trait.

#### 7.4. Implementierungsschritte `domain::notifications_rules`

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml`.
2. **`types.rs`**: Alle Regel-Typen (`RuleConditionValue`, `Operator`, `Field`, `SimpleRuleCondition`, `RuleCondition`, `RuleAction`, `NotificationRule`, `NotificationRuleSet`). `serde` und `Default`.
3. **`errors.rs`**: `NotificationRulesError` definieren.
4. **`persistence_iface.rs`**: `NotificationRulesProvider`-Trait definieren.
5. **`persistence.rs`**: `FilesystemNotificationRulesProvider` implementieren (nutzt `ConfigServiceAsync`). Tests mit Mocking.
6. **`engine.rs`**: `RuleProcessingResult` Enum. `NotificationRulesEngine`-Trait. `DefaultNotificationRulesEngine` implementieren:
    - Konstruktor, `RwLock` für `rules`.
    - `reload_rules()`, `process_notification()` (mit rekursiver Bedingungsauswertung und Aktionsanwendung), `get_rules()`, `update_rules()`.
    - Tests für Bedingungsauswertung (alle Operatoren, Feldtypen, logische Verknüpfungen, `SettingIsTrue`). Tests für Aktionsanwendung. Tests für Regelpriorisierung und `StopProcessingFurtherRules`. Mocking von `NotificationRulesProvider` und `GlobalSettingsService`.
7. **`mod.rs`**: Öffentliche API re-exportieren.

---

Diese detaillierten Pläne für die Module 1 bis 8 der Domänenschicht sollten eine sehr solide Grundlage für die Implementierung bieten. Jede Komponente ist klar abgegrenzt, und die Interaktionen sowie Abhängigkeiten sind definiert. Der nächste Schritt wäre, für jedes dieser Module die detaillierten Implementierungsschritte (wie im Beispiel für `core::types` und jetzt für die Domänenmodule gezeigt) und die Unit-Tests vollständig auszuarbeiten.