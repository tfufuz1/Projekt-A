
1. **Die detaillierte Aufteilung der Systemschicht in Hauptmodule und deren Submodule** basierend auf der Gesamtspezifikation () und Ihren Anforderungen festlegen.
2. Für **ein ausgewähltes, kritisches Hauptmodul (z.B. `system::compositor`) und dessen wichtigste Submodule eine vollständige Ultra-Feinspezifikation** mit der geforderten Detailtiefe erstellen, einschließlich Dateistruktur, Datentypen, API-Signaturen, Logikbeschreibungen und Implementierungsschritten.
3. Für die **weiteren Hauptmodule der Systemschicht die Struktur (Submodule) und die Kernverantwortlichkeiten skizzieren** sowie auf die relevanten Abschnitte in der Gesamtspezifikation () verweisen. Eine vollständige Ausarbeitung aller Module würde den Rahmen sprengen, aber die Methodik des detaillierten Moduls dient als Blaupause.

**Autonome Entscheidung zur Sequenzierung und Submodul-Aufteilung der Systemschicht:**

Basierend auf der Gesamtspezifikation () und der Notwendigkeit einer klaren Struktur, unterteile ich die Systemschicht (`novade-system` Crate) wie folgt:

1. **`system::compositor`**: Wayland-Compositor-Logik (Smithay-basiert).
    - `compositor::core`: Zentrale Compositor-Zustände und Handler.
    - `compositor::surface_management`: Verwaltung von `WlSurface`-Daten.
    - `compositor::shm`: SHM-Pufferbehandlung.
    - `compositor::xdg_shell`: XDG-Shell-Protokollintegration (Toplevels, Popups).
    - `compositor::layer_shell`: `wlr-layer-shell`-Integration für Panels, Docks etc.
    - `compositor::decoration`: `xdg-decoration`-Integration (Client/Server-Side Decorations).
    - `compositor::output_management`: `wlr-output-management` und `xdg-output` für Monitor-Konfiguration.
    - `compositor::input_method`: Integration von Eingabemethoden (IME).
    - `compositor::screencopy`: Screenshot- und Screencasting-Protokolle (z.B. `wlr-screencopy`).
    - `compositor::data_device`: Zwischenablage (Copy & Paste) und Drag & Drop.
    - `compositor::xwayland`: Integration und Verwaltung des XWayland-Servers.
    - `compositor::renderer_interface`: Abstrakte Schnittstelle zum Rendering-Backend.
    - `compositor::drm_gbm_renderer` (optional, eine konkrete Renderer-Implementierung).
    - `compositor::winit_renderer` (optional, eine weitere konkrete Renderer-Implementierung für verschachtelten Betrieb).
2. **`system::input`**: Eingabeverarbeitung (libinput-basiert).
    - `input::seat_manager`: Seat-Management, Fokus, Capabilities.
    - `input::libinput_handler`: Integration des Libinput-Backends.
    - `input::keyboard`: Tastaturereignis-Übersetzung, XKB-Management.
    - `input::pointer`: Maus-/Zeigerereignis-Verarbeitung, Cursor.
    - `input::touch`: Touch-Ereignis-Verarbeitung.
    - `input::gestures`: Gestenerkennung (aufbauend auf libinput-Events).
3. **`system::dbus_interfaces`**: Schnittstellen zu System-D-Bus-Diensten.
    - `dbus_interfaces::connection_manager`: Basis für D-Bus-Verbindungen.
    - `dbus_interfaces::network_manager`: Client für NetworkManager.
    - `dbus_interfaces::upower`: Client für UPower.
    - `dbus_interfaces::logind`: Client für systemd-logind.
    - `dbus_interfaces::notifications_server`: Implementierung des `org.freedesktop.Notifications`-Servers (nutzt `domain::user_centric_services::notifications_core`).
    - `dbus_interfaces::secrets_service`: Client für `org.freedesktop.secrets`.
    - `dbus_interfaces::policykit`: Client für PolicyKit.
    - `dbus_interfaces::xdg_desktop_portal_handler`: Backend-Logik für Portale (Interaktion mit Compositor etc.).
4. **`system::audio_management`**: PipeWire-Client-Integration.
    - `audio_management::client`: PipeWire-Core-Interaktion.
    - `audio_management::device_manager`: Verwaltung von Audio-Geräten.
    - `audio_management::stream_manager`: Verwaltung von Anwendungs-Streams.
    - `audio_management::volume_control`: Lautstärkeregelung.
5. **`system::mcp_client`**: Implementierung des Model Context Protocol Clients.
    - `mcp_client::connection`: Verwaltung der MCP-Server-Verbindung.
    - `mcp_client::protocol_handler`: Senden/Empfangen von MCP-Nachrichten.
    - `mcp_client::resource_provider`: Bereitstellung von Systemressourcen für KI-Modelle.
6. **`system::window_mechanics`**: Technische Umsetzung des Fenstermanagements.
    - `window_mechanics::placement`: Anwendung von Platzierungsrichtlinien.
    - `window_mechanics::tiling_engine`: Anwendung von Tiling-Layouts.
    - `window_mechanics::focus_arbitration`: Technische Fokushandhabung.
    - `window_mechanics::decoration_manager`: Koordination von SSD/CSD.
7. **`system::event_bridge`**: Brücke für Systemereignisse zur Domänenschicht und UI-Schicht.
8. **`system::power_management`**: Interaktion mit `wlr-output-power-management` und DPMS.

**Detailausarbeitung für `system::compositor` (Teil 1 - Kern & XDG Shell):**

---

## Ultra-Feinspezifikation und Implementierungsplan: Systemschicht (`novade-system` Crate)

**Allgemeine Entwicklungsrichtlinien für die Systemschicht:**

- **Sprache:** Rust (Edition 2021+).
- **Abhängigkeiten:** `novade-core`, `novade-domain`, `smithay` (spezifische Version, z.B. 0.10 oder neuer), `wayland-server`, `wayland-protocols`, `calloop`, `libinput`, `xkbcommon`, `zbus`, `pipewire-rs`, `mcp_client_rs`, `tracing`, `thiserror`, `uuid`, `serde`, `serde_json`, `parking_lot` (optional für Mutex).
- **Fehlerbehandlung:** Modulspezifische Fehler-Enums mit `thiserror`. Fehler aus `smithay` und anderen Bibliotheken werden gewrappt.
- **Asynchronität:** `calloop` ist die primäre Ereignisschleife für `smithay`. Andere asynchrone Operationen (z.B. `zbus`) müssen ggf. über Adapter integriert werden oder in eigenen Threads laufen und mit `calloop` über Kanäle/Signale kommunizieren. Wo `smithay` oder seine Abhängigkeiten `async/await` erfordern (z.B. einige `zbus`-Interaktionen), wird dies genutzt.
- **Zustandsverwaltung:** Eine zentrale `DesktopState`-Struktur wird die meisten `smithay`-Handler implementieren und die Zustände der Subsysteme halten.
- **Interaktion mit Domänenschicht:** Die Systemschicht ruft Services der Domänenschicht auf, um Geschäftslogik anzuwenden oder Zustände zu aktualisieren/abzufragen. Sie übersetzt Systemereignisse in Domänenereignisse oder -aufrufe.

**Cargo.toml für `novade-system` (Auszug):**

Ini, TOML

```
[dependencies]
novade-core = { path = "../novade-core" }
novade-domain = { path = "../novade-domain" }

smithay = { version = "0.10.0", features = ["renderer_gl", "backend_libinput", "backend_session", "backend_udev", "backend_drm", "backend_winit", "desktop", "xwayland", "use_system_lib"] } # Beispielversion, Features anpassen
wayland-server = "0.30" # Smithay-kompatible Version
wayland-protocols = { version = "0.30", features = ["server", "unstable_protocols"] } # Smithay-kompatible Version
calloop = "0.12"
libinput = "0.9"
xkbcommon = "0.7"
# ... weitere Abhängigkeiten ...
```

---

### Modul 1: `system::compositor`

Zweck: Implementierung des Wayland-Compositors unter Verwendung des Smithay-Toolkits.

Verantwortlichkeiten: Client-Verwaltung, Oberflächen-Lebenszyklus, Pufferbehandlung, Shell-Protokolle, Koordination des Renderings.

#### 1.1. Submodul: `system::compositor::core`

**Zweck:** Zentrale Compositor-Zustände, `DesktopState`-Definition, Basis-Handler-Implementierungen.

**Datei:** `src/compositor/core/errors.rs`

- **Enum `CompositorCoreError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use smithay::wayland::compositor::SurfaceRoleError;
    use wayland_server::{backend::ClientId, protocol::wl_surface::WlSurface};
    
    #[derive(Debug, Error)]
    pub enum CompositorCoreError {
        #[error("Failed to create Wayland global object '{0}'")]
        GlobalCreationFailed(String),
        #[error("Surface role error: {0}")]
        RoleError(#[from] SurfaceRoleError), // From smithay
        #[error("Client data not found for client ID {0:?}")]
        ClientDataMissing(ClientId),
        #[error("SurfaceData not found or of wrong type for WlSurface {0:?}")]
        SurfaceDataMissing(WlSurface),
        #[error("Invalid surface state: {0}")]
        InvalidSurfaceState(String),
        #[error("Renderer backend initialization failed: {0}")]
        RendererInitializationFailed(String),
        #[error("Display or EventLoop creation failed: {0}")]
        DisplayOrLoopCreationFailed(String),
        #[error("Failed to initialize XWayland: {0}")]
        XWaylandInitializationError(String),
        // Weitere spezifische Fehler
    }
    ```
    

**Datei:** `src/compositor/core/state.rs`

- **Struct `ClientCompositorData`** (für `Client::data_map`)
    
    Rust
    
    ```
    use smithay::wayland::compositor::CompositorClientState;
    use smithay::wayland::shell::xdg::XdgShellClientData; // Für XDG-Shell
    // Ggf. weitere Client-spezifische Zustände von Smithay-Modulen
    
    pub struct ClientCompositorData {
        pub compositor_state: CompositorClientState,
        // pub xdg_shell_data: XdgShellClientData, // Wird von XdgShellState::new_client verwaltet
    }
    
    impl ClientCompositorData {
        pub fn new() -> Self {
            Self {
                compositor_state: CompositorClientState::default(),
            }
        }
    }
    ```
    
- **Struct `DesktopState`** (Zentrale Zustandsstruktur)
    
    Rust
    
    ```
    use smithay::{
        backend::renderer::gles2::Gles2Renderer, // Beispiel-Renderer
        desktop::{Space, Window, WindowSurfaceType},
        input::{Seat, SeatState, pointer::CursorImageStatus},
        reexports::{
            calloop::{LoopHandle, Interest, Mode, PostAction},
            wayland_server::{Display, DisplayHandle, Client, backend::{GlobalId, ClientId}},
        },
        utils::{Clock, Logical, Point, Rectangle, Serial, Transform},
        wayland::{
            compositor::{CompositorState, CompositorClientState, CompositorHandler, SurfaceAttributes as WlSurfaceAttributes, add_destruction_hook},
            output::OutputManagerState, // Für wlr-output-management & xdg-output
            shell::{
                xdg::{XdgShellState, XdgShellHandler, XdgToplevelSurfaceData, XdgPopupSurfaceData, SurfaceCachedState, XdgWmBaseClientData},
                kde_decoration::KdeDecorationManagerState, // Beispiel für SSD
            },
            shm::{ShmState, ShmHandler},
            seat::WaylandSeatData, // Für wl_seat UserData
            // ... weitere Smithay-Module ...
            selection::data_device::{DataDeviceState, DataDeviceHandler},
            selection::primary_selection::{PrimarySelectionState, PrimarySelectionHandler},
            input_method::InputMethodManagerState,
            relative_pointer::RelativePointerManagerState,
            pointer_constraints::PointerConstraintsState,
            viewporter::ViewporterState,
            presentation::PresentationState,
            xdg_activation::XdgActivationState,
        },
    };
    use crate::domain::window_management_policy::{WindowManagementPolicyService, WindowPolicyOverrides, TilingMode, WorkspaceWindowLayout}; // Domain Service
    use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier as DomainWindowIdentifier};
    use crate::domain::workspaces::manager::WorkspaceManagerService;
    use std::{collections::HashMap, sync::{Arc, Mutex}}; // Mutex für Domain-Services
    use uuid::Uuid;
    use super::surface_management::{SurfaceData, RenderableElement}; // Eigene Typen
    use super::super::input::keyboard::xkb_config::XkbKeyboardData; // Aus system::input
    
    pub const CLOCK_ID: usize = 0;
    
    pub struct NovaDEWaylandState { /* Für Globals, die nur einmal existieren */
        pub shm_global: GlobalId,
        pub xdg_shell_global: GlobalId,
        pub output_manager_global: GlobalId,
        pub seat_global: GlobalId,
        pub data_device_global: GlobalId,
        // ... weitere GlobalIds ...
        pub xdg_activation_global: GlobalId,
    }
    
    pub struct DesktopState {
        pub display_handle: DisplayHandle,
        pub loop_handle: LoopHandle<'static, Self>, // 'static, wenn DesktopState global ist
        pub clock: Clock<u64>, // Für Timings, Animationen
    
        // Compositor & Core States
        pub compositor_state: CompositorState,
        pub shm_state: ShmState,
        pub presentation_state: PresentationState,
        pub viewporter_state: ViewporterState,
    
    
        // Shells & Window Management
        pub xdg_shell_state: XdgShellState,
        pub xdg_activation_state: XdgActivationState,
        // pub layer_shell_state: LayerShellState, // Für wlr-layer-shell
        // pub kde_decoration_state: KdeDecorationManagerState, // Für KWin SSD
    
        // Workspace & Window Tracking (Compositor-Sicht)
        pub space: Space<Window>, // Smithay's Desktop-Raum für Fensterverwaltung
        pub windows: HashMap<DomainWindowIdentifier, Window>, // Eigene Map für Zugriff via Domain ID
    
        // Input & Seat
        pub seat_state: SeatState<Self>,
        pub seat: Seat<Self>, // Der primäre Seat
        pub seat_name: String,
        pub input_method_manager_state: InputMethodManagerState, // Für IME
        pub relative_pointer_manager_state: RelativePointerManagerState,
        pub pointer_constraints_state: PointerConstraintsState,
        pub keyboard_data_map: HashMap<String /* seat_name oder device_id */, XkbKeyboardData>, // Für XKB
        pub current_cursor_status: Arc<Mutex<CursorImageStatus>>, // Für Cursor-Rendering
    
        // Output Management
        pub output_manager_state: OutputManagerState,
    
        // Data Exchange (Clipboard, DnD)
        pub data_device_state: DataDeviceState,
        // pub primary_selection_state: PrimarySelectionState,
    
        // XWayland
        // pub xwayland: XWayland, // Smithay's XWayland-Struktur
    
        // Domain Service Handles (Arc<Mutex<...>> oder Arc<dyn ...>)
        pub window_policy_service: Arc<dyn WindowManagementPolicyService>,
        pub workspace_manager_service: Arc<dyn WorkspaceManagerService>,
        // ... weitere Domain-Services ...
    
        // Renderer (wird später konkretisiert)
        // pub renderer: Gles2Renderer,
        // pub last_render_time: std::time::Instant,
    
        // Wayland Global IDs (um sie am Leben zu halten)
        pub wayland_globals: Option<NovaDEWaylandState>, // Wird nach Erstellung der Globals gefüllt
    }
    
    impl DesktopState {
        pub fn new(
            loop_handle: LoopHandle<'static, Self>,
            display_handle: DisplayHandle,
            window_policy_service: Arc<dyn WindowManagementPolicyService>,
            workspace_manager_service: Arc<dyn WorkspaceManagerService>,
        ) -> Self {
            let clock = Clock::new(Some(tracing::Span::current())); // tracing integration
            let compositor_state = CompositorState::new::<Self>(&display_handle, Some(tracing::Span::current()));
            let shm_state = ShmState::new::<Self>(&display_handle, vec![], Some(tracing::Span::current())); // Keine zusätzlichen Formate initial
            let presentation_state = PresentationState::new::<Self>(&display_handle, clock.id() as u32);
            let viewporter_state = ViewporterState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
            let xdg_shell_state = XdgShellState::new::<Self>(&display_handle, Some(tracing::Span::current()));
            let xdg_activation_state = XdgActivationState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
            let space = Space::new(Some(tracing::Span::current()));
    
            let mut seat_state = SeatState::new();
            let seat_name = "seat0".to_string();
            let seat = seat_state.new_wl_seat(&display_handle, seat_name.clone(), Some(tracing::Span::current()));
            // Capabilities (Keyboard, Pointer, Touch) werden später beim Input-Backend-Init hinzugefügt
    
            let input_method_manager_state = InputMethodManagerState::new::<Self>(&display_handle);
            let relative_pointer_manager_state = RelativePointerManagerState::new::<Self>(&display_handle);
            let pointer_constraints_state = PointerConstraintsState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
    
            let output_manager_state = OutputManagerState::new_with_xdg_output::<Self>(&display_handle);
            let data_device_state = DataDeviceState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
            Self {
                display_handle,
                loop_handle,
                clock,
                compositor_state,
                shm_state,
                presentation_state,
                viewporter_state,
                xdg_shell_state,
                xdg_activation_state,
                space,
                windows: HashMap::new(),
                seat_state,
                seat,
                seat_name,
                input_method_manager_state,
                relative_pointer_manager_state,
                pointer_constraints_state,
                keyboard_data_map: HashMap::new(),
                current_cursor_status: Arc::new(Mutex::new(CursorImageStatus::Default)),
                output_manager_state,
                data_device_state,
                window_policy_service,
                workspace_manager_service,
                wayland_globals: None,
            }
        }
    }
    ```
    
    - **Initialisierung der Smithay-States:** Erfolgt im `new()` Konstruktor von `DesktopState`. Die `Logger` Parameter sind in neueren Smithay-Versionen oft durch `Option<tracing::Span>` ersetzt oder implizit.
    - **Domain Service Handles:** Werden als `Arc<dyn TraitName>` gespeichert, um Flexibilität und Testbarkeit zu gewährleisten. Sie werden von außen injiziert.
- **Implementierung `CompositorHandler` für `DesktopState`**:
    - **`compositor_state(&mut self) -> &mut CompositorState`**: Gibt `&mut self.compositor_state` zurück.
    - **`client_compositor_state<'a>(&self, client: &'a Client) -> &'a CompositorClientState`**:
        1. `client.get_data::<ClientCompositorData>().unwrap().compositor_state` (Annahme: `ClientCompositorData` wird beim Client-Connect in `Client::data_map` eingefügt).
    - **`commit(&mut self, surface: &WlSurface)`**:
        1. `tracing::debug!(surface_id = ?surface.id(), "Commit für WlSurface");`
        2. `smithay::wayland::compositor::with_states(surface, |states| { ... })` verwenden, um auf `SurfaceAttributes` und `SurfaceData` zuzugreifen.
        3. `let surface_attributes = states.cached_state.current::<WlSurfaceAttributes>();`
        4. **Puffer-Handling:**
            - Wenn `surface_attributes.buffer.is_some()` und `surface_attributes.buffer_delta != (0,0)` oder ein neuer Puffer angehängt wurde:
                - Die `SurfaceData` für diesen `surface` abrufen (aus `states.data_map`).
                - `surface_data.lock().unwrap().current_buffer = surface_attributes.buffer.clone();`
                - `surface_data.lock().unwrap().buffer_scale = surface_attributes.buffer_scale;`
                - `surface_data.lock().unwrap().buffer_transform = surface_attributes.buffer_transform;`
                - Renderer benachrichtigen, die Textur für diesen Puffer zu aktualisieren/erstellen (Details im Renderer-Modul).
        5. **Schadensverfolgung (Damage Tracking):**
            - `let damage = &surface_attributes.damage;` (Liste von `Rectangle<i32, BufferCoords>`).
            - Die `SurfaceData` mit diesen Schadensregionen aktualisieren: `surface_data.lock().unwrap().damage_buffer_coords.extend(damage.iter().cloned());`
        6. **Rollenbasierte Commit-Logik:**
            - `let role = smithay::wayland::compositor::get_role(surface);`
            - `match role { Some("xdg_toplevel") => { ... }, Some("xdg_popup") => { ... }, ... }`
            - Ruft spezifische Commit-Handler für XDG-Toplevels, Popups, Subsurfaces, Layer-Surfaces etc. auf. Diese könnten in `SurfaceData` als Callbacks/Hooks gespeichert sein oder direkt hier behandelt werden. Für XDG-Shell wird dies oft vom `XdgShellHandler` übernommen. Smithay's `desktop::Space` und `Window` handhaben vieles davon.
        7. **Synchronisierte Subsurfaces:** `if surface.is_sync_subsurface() { ... }` Logik für Parent-Commit ( Schritt 8).
        8. Oberfläche für Neuzeichnung im nächsten Frame markieren (z.B. `self.space.damage_window(&window_für_surface, ...)`).
    - **`new_surface(&mut self, surface: &WlSurface, client_data: &Arc<ClientCompositorData>)`** (Signatur kann variieren, je nachdem wie Client-Daten übergeben werden):
        1. `tracing::info!(surface_id = ?surface.id(), client_id = ?surface.client().unwrap().id(), "Neue WlSurface erstellt");`
        2. Initialisiere `SurfaceData::new(surface.client().unwrap().id())`.
        3. `surface.data_map().insert_if_missing_threadsafe(|| Arc::new(Mutex::new(SurfaceData::new(...))));`
        4. `add_destruction_hook(surface, |data_map| { ... Bereinigung von SurfaceData ... });`
    - **`new_subsurface(&mut self, surface: &WlSurface, parent: &WlSurface, client_data: &Arc<ClientCompositorData>)`**:
        1. `tracing::info!(surface_id = ?surface.id(), parent_id = ?parent.id(), "Neue WlSubsurface erstellt");`
        2. `SurfaceData` von `surface` aktualisieren: `surface_data.lock().unwrap().parent = Some(parent.downgrade());`
        3. `SurfaceData` von `parent` aktualisieren: `parent_surface_data.lock().unwrap().children.push(surface.downgrade());`
    - **`destroyed(&mut self, surface: &WlSurface)`**:
        1. `tracing::info!(surface_id = ?surface.id(), "WlSurface zerstört");`
        2. Smithay kümmert sich um das Entfernen aus der `UserDataMap`.
        3. Sicherstellen, dass alle Referenzen auf diese `WlSurface` in `DesktopState` (z.B. in `space`, `windows`, Fokus-Listen) entfernt werden. Dies geschieht oft über den `destruction_hook` der `SurfaceData`.

#### 1.2. Submodul: `system::compositor::surface_management`

**Zweck:** Definition und Verwaltung von `SurfaceData`.

**Datei:** `src/compositor/surface_management/mod.rs`

- **Enum `RenderableElement`** (kann auch direkt Smithay's `Element` sein oder dieses wrappen)
    
    Rust
    
    ```
    // Beispiel, wird durch Renderer-Schnittstelle konkretisiert
    pub enum RenderableElement {
        WaylandSurface {
            surface: WlSurface, // Oder eine ID/Wrapper, der die Textur hält
            position: Point<i32, Logical>,
            scale: f64,
            transform: Transform, // Bildschirmrotation etc.
            damage_surface_local: Vec<Rectangle<i32, Logical>>, // Schaden relativ zur Oberfläche
            opaque_regions_surface_local: Vec<Rectangle<i32, Logical>>,
        },
        SolidColor { /* ... */ },
        Cursor { /* ... */ },
    }
    ```
    
- **Struct `SurfaceData`**:
    - **Felder:**
        - `pub id: Uuid` (Eigene interne ID)
        - `pub client_id: ClientId`
        - `pub role: Mutex<Option<String>>` (Rolle, z.B. "toplevel", "popup", "cursor", "layer")
        - `pub current_buffer_info: Mutex<Option<AttachedBufferInfo>>` (Infos zum aktuellen Puffer)
        - `pub texture_handle: Mutex<Option<Box<dyn RenderableTexture>>>` (Handle vom Renderer, `RenderableTexture` Trait wird in `renderer_interface` definiert)
        - `pub damage_buffer_coords: Mutex<Vec<Rectangle<i32, smithay::utils::Buffer>>>`
        - `pub damage_surface_coords: Mutex<Vec<Rectangle<i32, Logical>>>` (Transformierter Schaden)
        - `pub opaque_region_surface_local: Mutex<Option<smithay::utils::Region<Logical>>>`
        - `pub input_region_surface_local: Mutex<Option<smithay::utils::Region<Logical>>>`
        - `pub user_data_ext: UserDataMap` (Für anwendungsspezifische Daten, die von anderen Modulen wie XDG-Shell oder Layer-Shell hier abgelegt werden)
        - `pub parent: Mutex<Option<wayland_server::Weak<WlSurface>>>`
        - `pub children: Mutex<Vec<wayland_server::Weak<WlSurface>>>`
        - `pub pre_commit_hooks: Mutex<Vec<Box<dyn FnMut(&mut DesktopState, &WlSurface) + Send + Sync>>>`
        - `pub post_commit_hooks: Mutex<Vec<Box<dyn FnMut(&mut DesktopState, &WlSurface) + Send + Sync>>>`
        - `destruction_callback: Mutex<Option<Box<dyn FnOnce(&mut DesktopState, &WlSurface) + Send + Sync>>>` (Ein dedizierter Callback statt Vec für einmalige Zerstörung)
        - `pub surface_viewporter_state: Mutex<smithay::wayland::viewporter::SurfaceState>`
        - `pub surface_presentation_state: Mutex<smithay::wayland::presentation::SurfaceState>`
        - `pub surface_scale_factor: Mutex<f64>` (Skalierungsfaktor, der auf diese Oberfläche angewendet wird, z.B. vom Output)
    - **Struct `AttachedBufferInfo`**:
        
        Rust
        
        ```
        #[derive(Debug, Clone)]
        pub struct AttachedBufferInfo {
            pub buffer: WlBuffer,
            pub scale: i32, // Smithay's buffer_scale
            pub transform: Transform, // Smithay's buffer_transform
            pub dimensions: Size<i32, smithay::utils::Buffer>, // Größe des Puffers
        }
        ```
        
    - **Methoden für `SurfaceData`**:
        - `pub fn new(client_id: ClientId) -> Self`
        - `pub fn set_role(&self, role: &str) -> Result<(), CompositorCoreError>`
        - `pub fn get_role(&self) -> Option<String>`
        - `pub fn attach_buffer(&self, buffer_info: Option<AttachedBufferInfo>)`
        - `pub fn take_damage_buffer_coords(&self) -> Vec<Rectangle<i32, smithay::utils::Buffer>>`
        - `pub fn add_pre_commit_hook(...)`, `add_post_commit_hook(...)`
        - `pub fn set_destruction_callback(...)`
        - `pub fn get_effective_damage_and_transform(&self, output_transform: Transform) -> (Vec<Rectangle<i32, Logical>>, Transform)` (Berechnet transformierten Schaden)
- **Funktionen:**
    - `pub fn get_surface_data(surface: &WlSurface) -> Option<Arc<SurfaceData>>`: Ruft `Arc<SurfaceData>` aus `surface.data_map()` ab.
    - `pub fn with_surface_data_mut<F, R>(surface: &WlSurface, callback: F) -> Result<R, CompositorCoreError> where F: FnOnce(&mut SurfaceData, &WlSurfaceAttributes) -> R`: Kapselt Locken und Zugriff. `WlSurfaceAttributes` wird über `with_states` geholt.

#### 1.3. Submodul: `system::compositor::shm`

**Zweck:** SHM-Pufferbehandlung (`wl_shm`).

**Datei:** `src/compositor/shm/errors.rs`

- **Enum `ShmError`**: ()
    - `PoolCreationFailed(String)`
    - `BufferCreationFailed(String)`
    - `InvalidFormat(wl_shm::Format)`
    - `AccessError(#[from] smithay::wayland::shm::BufferAccessError)`

**Datei:** `src/compositor/shm/mod.rs` (oder `state.rs`)

- **Implementierung `ShmHandler` für `DesktopState`**:
    - `shm_state(&self) -> &ShmState`: Gibt `&self.shm_state` zurück.
- **Implementierung `BufferHandler` für `DesktopState`** (Hier spezifisch für SHM-Puffer, obwohl der Trait generisch ist):
    - `buffer_destroyed(&mut self, buffer: &wl_buffer::WlBuffer)`:
        1. `tracing::debug!(buffer_id = ?buffer.id(), "SHM WlBuffer zerstört");`
        2. Finde alle `SurfaceData`-Instanzen, die diesen `buffer` in `current_buffer_info` verwenden.
        3. Für jede gefundene Instanz:
            - Entferne die Referenz auf den Puffer.
            - Benachrichtige den Renderer, die zugehörige Textur freizugeben (`surface_data.texture_handle.take()`).
            - Markiere die Oberfläche als beschädigt, da ihr Inhalt nun ungültig ist.
- **Implementierung `GlobalDispatch<WlShm, ()>` für `DesktopState`**: ()
    - `bind(...)`: `data_init.init(resource, ());` (Smithay's `ShmState` kümmert sich um das Senden von Formaten).
- **Funktion `pub fn create_shm_global(state: &mut DesktopState, display_handle: &DisplayHandle)`**: ()
    1. `let shm_global_id = state.shm_state.global().clone();` (Da `shm_state` bereits in `DesktopState::new` initialisiert wurde).
    2. Speichere `shm_global_id` in `state.wayland_globals.as_mut().unwrap().shm_global`.
    3. `tracing::info!("wl_shm Global für Clients verfügbar gemacht. Unterstützte Formate: ARGB8888, XRGB8888.");`

**Datei:** `src/compositor/shm/buffer_access.rs`

- **Funktion `pub fn with_shm_buffer_contents<F, T>(buffer: &wl_buffer::WlBuffer, callback: F) -> Result<T, ShmError> where F: FnOnce(*const u8, usize, &smithay::wayland::shm::BufferData) -> T`**:
    1. `smithay::wayland::shm::with_buffer_contents(buffer, callback).map_err(ShmError::from)`

#### 1.4. Submodul: `system::compositor::xdg_shell`

**Zweck:** XDG-Shell-Protokollintegration (`xdg_wm_base`, `xdg_surface`, `xdg_toplevel`, `xdg_popup`).

**Datei:** `src/compositor/xdg_shell/errors.rs`

- **Enum `XdgShellError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use smithay::{utils::Serial, wayland::shell::xdg::ToplevelConfigureError};
    use wayland_server::protocol::wl_surface::WlSurface;
    use uuid::Uuid; // Für interne Window-IDs
    use crate::compositor::core::errors::CompositorCoreError;
    
    #[derive(Debug, Error)]
    pub enum XdgShellError {
        #[error("Surface {0:?} already has a different XDG role or is uninitialized.")]
        InvalidSurfaceRole(WlSurface),
        #[error("Window handling error for window ID {0}: {1}")]
        WindowHandlingError(Uuid, String), // Uuid ist die interne ID des ManagedWindow
        #[error("Popup positioning failed: {0}")]
        PopupPositioningError(String),
        #[error("Client provided invalid serial {client_serial:?} for configure, expected around {expected_serial:?}.")]
        InvalidAckConfigureSerial { client_serial: Serial, expected_serial: Serial },
        #[error("ManagedToplevel with ID {0} not found.")]
        ToplevelNotFound(Uuid),
        #[error("ManagedPopup with ID {0} not found.")]
        PopupNotFound(Uuid),
        #[error("XDG Toplevel configure operation failed: {0}")]
        ToplevelConfigureFailed(#[from] ToplevelConfigureError),
        #[error("Core compositor error during XDG operation: {0}")]
        CoreError(#[from] CompositorCoreError),
        #[error("XDG WM Base client data not found.")]
        XdgWmBaseClientDataMissing,
    }
    ```
    

**Datei:** `src/compositor/xdg_shell/types.rs`

- **Struct `ManagedWindow`** (ersetzt `ManagedToplevel` und `ManagedPopup` für Smithay's `Space<Window>`)
    
    Rust
    
    ```
    use smithay::{
        desktop::{Window, WindowSurface, WindowSurfaceType, Space},
        output::Output,
        reexports::wayland_protocols::xdg::shell::server::xdg_toplevel,
        utils::{Logical, Point, Rectangle, Size},
        wayland::shell::xdg::{ToplevelSurface, PopupSurface, PositionerState, XdgPopupSurfaceData, XdgToplevelSurfaceData},
    };
    use wayland_server::protocol::wl_surface::WlSurface;
    use wayland_server::Weak;
    use uuid::Uuid;
    use crate::domain::workspaces::core::types::WindowIdentifier as DomainWindowIdentifier; // Domain-ID
    use crate::compositor::surface_management::SurfaceData; // Zugriff auf SurfaceData
    use std::sync::{Arc, Mutex};
    
    #[derive(Debug, Clone, PartialEq)] // PartialEq ggf. manuell oder nur auf ID
    pub struct ManagedWindow {
        pub id: Uuid, // Interne Compositor-ID
        pub domain_id: DomainWindowIdentifier, // Verknüpfung zur Domänenschicht
        pub xdg_surface: WindowSurface, // Smithay's WindowSurface (Toplevel oder Popup)
        // app_id und title werden über xdg_surface.get_app_id() / .get_title() geholt
        pub current_geometry: Rectangle<i32, Logical>, // Berechnete Geometrie
        pub requested_size: Option<Size<i32, Logical>>,
        pub min_size: Option<Size<i32, Logical>>,
        pub max_size: Option<Size<i32, Logical>>,
        pub parent_id: Option<Uuid>, // Für transiente Toplevels oder Popups
        pub is_mapped: bool,
        // Weitere Zustände wie maximized, fullscreen, activated werden über xdg_surface.toplevel()
        // und dessen Methoden (e.g. current_states()) oder XdgToplevelSurfaceData verwaltet.
    }
    
    impl ManagedWindow {
        pub fn new_toplevel(toplevel_surface: ToplevelSurface, domain_id: DomainWindowIdentifier) -> Self {
            // Initialgeometrie etc. wird später vom Layout-Manager gesetzt
            Self {
                id: Uuid::new_v4(),
                domain_id,
                xdg_surface: WindowSurface::Toplevel(toplevel_surface),
                current_geometry: Rectangle::from_loc_and_size((0,0), (0,0)),
                requested_size: None, min_size: None, max_size: None,
                parent_id: None, // TODO: Parent-Logik für transiente Toplevel
                is_mapped: false,
            }
        }
    
        pub fn new_popup(popup_surface: PopupSurface, parent_domain_id: DomainWindowIdentifier) -> Self {
             // Popups haben eine komplexere Geometrieberechnung
            Self {
                id: Uuid::new_v4(),
                domain_id: DomainWindowIdentifier::new(format!("popup-{}", Uuid::new_v4())).unwrap(), // Eigene ID für Popups
                xdg_surface: WindowSurface::Popup(popup_surface),
                current_geometry: Rectangle::from_loc_and_size((0,0), (0,0)), // Wird durch Positioner bestimmt
                requested_size: None, min_size: None, max_size: None,
                parent_id: Some(Uuid::default()), // TODO: parent_id korrekt setzen auf Uuid des Parent ManagedWindow
                is_mapped: false,
            }
        }
    
        pub fn wl_surface(&self) -> &WlSurface {
            self.xdg_surface.wl_surface()
        }
        // ... weitere Hilfsmethoden ...
    }
    
    // Implementierung von smithay::desktop::Window für ManagedWindow
    impl Window for ManagedWindow {
        fn id(&self) -> usize {
            // Smithay's Space benötigt usize. Wir können die Bytes unserer Uuid nehmen.
            // Dies muss stabil sein für die Lebenszeit des Fensters.
            let mut hasher = std::collections::hash_map::DefaultHasher::new();
            self.id.hash(&mut hasher);
            std::hash::Hasher::finish(&hasher) as usize
        }
        fn wl_surface(&self) -> Option<WlSurface> { Some(self.xdg_surface.wl_surface().clone()) }
        fn surface_type(&self) -> WindowSurfaceType { self.xdg_surface.surface_type() }
        fn geometry(&self) -> Rectangle<i32, Logical> { self.current_geometry }
        fn is_mapped(&self) -> bool { self.is_mapped && self.xdg_surface.alive() } // Und ob die Wayland-Oberfläche noch existiert
        fn is_suspended(&self) -> bool {
            // Abfragen von XdgToplevelSurfaceData, ob minimiert etc.
            if let WindowSurface::Toplevel(t) = &self.xdg_surface {
                let data = t.user_data().get::<XdgToplevelSurfaceData>().unwrap();
                return data.minimized || data.suspended;
            }
            false
        }
        // ... weitere Methoden des Window-Traits implementieren (send_configure, set_activated etc.)
        // Diese rufen oft Methoden auf self.xdg_surface.toplevel() oder .popup() auf.
        fn send_frame(&self, output: &Output, time: impl Into<Duration>, throttle: Option<Duration>, primary_scan_out_output: Option<&Output>) {
            // Für Frame-Callbacks des Presentation-Time Protokolls
            if let Some(wl_surface) = self.wl_surface() {
                 smithay::wayland::presentation::send_frames_surface_dest harming_region_transform,
                    &wl_surface,
                    output,
                    time,
                    throttle,
                    primary_scan_out_output,
                );
            }
        }
        // ...
    }
    ```
    
    - **Verwendung von `smithay::desktop::Window` Trait**: Die `ManagedWindow`-Struktur implementiert diesen Trait, um mit `smithay::desktop::Space` kompatibel zu sein. Dies vereinfacht die Fensterverwaltung, das Stapeln und die Schadensberechnung für den Renderer erheblich.

**Datei:** `src/compositor/xdg_shell/handlers.rs`

- **Implementierung `XdgShellHandler` für `DesktopState`**:
    - **`xdg_shell_state(&mut self) -> &mut XdgShellState`**: Gibt `&mut self.xdg_shell_state` zurück.
    - **`new_toplevel(&mut self, surface: ToplevelSurface)`**:
        1. `tracing::info!(surface = ?surface.wl_surface().id(), "Neues XDG Toplevel wird erstellt.");`
        2. `let domain_window_id = DomainWindowIdentifier::new(format!("xdg-toplevel-{}", Uuid::new_v4())).unwrap();`
        3. `let mut managed_window = ManagedWindow::new_toplevel(surface.clone(), domain_window_id.clone());`
        4. **Initialgeometrie von Domäne anfordern:**
            - `let window_layout_info = WindowLayoutInfo { id: domain_window_id.clone(), requested_min_size: None, ... };`
            - `let initial_geom_result = block_on(self.window_policy_service.get_initial_window_geometry(&window_layout_info, ...));` (Blockieren hier ist problematisch in `calloop`. Besser: `get_initial_window_geometry` synchron machen oder die Fenstererstellung in eine Task-Pipeline verschieben.)
            - Wenn `Ok(geom)`, setze `managed_window.current_geometry = geom;`. Sonst Standardgeometrie.
        5. Füge `XdgToplevelSurfaceData` zur UserDataMap des `surface.wl_surface()` hinzu (Smithay macht das oft schon).
        6. `surface.with_pending_state(|state| { state.size = Some(managed_window.current_geometry.size); });`
        7. `surface.send_configure();` (Sendet initiale Größe etc. an Client).
        8. Füge `managed_window` zu `self.space` hinzu: `let window_arc = Arc::new(managed_window); self.space.map_window(window_arc.clone(), (initial_x, initial_y), true);` (Aktivieren, falls es Fokus bekommen soll).
        9. `self.windows.insert(domain_window_id, window_arc);`
    - **`new_popup(&mut self, surface: PopupSurface, _client_data: &XdgWmBaseClientData)`**:
        1. `tracing::info!(surface = ?surface.wl_surface().id(), "Neues XDG Popup wird erstellt.");`
        2. `let parent_wl_surface = surface.get_parent_surface().ok_or_else(|| XdgShellError::PopupPositioningError("Popup hat keine Elternoberfläche".into()))?;`
        3. Finde `parent_managed_window` über `parent_wl_surface` in `self.space` oder `self.windows`.
        4. `let managed_popup = ManagedWindow::new_popup(surface.clone(), parent_managed_window.domain_id.clone());`
        5. Füge `XdgPopupSurfaceData` zum `surface.wl_surface().data_map()` hinzu (Smithay macht das oft).
        6. Berechne Popup-Geometrie: `let positioner = surface.get_positioner(); let popup_geom = calculate_popup_geometry(&positioner, parent_managed_window.geometry());`
        7. `managed_popup.current_geometry = popup_geom;`
        8. `surface.send_configure();`
        9. Füge Popup zu `self.space` hinzu (Smithay's Space kann auch Popups verwalten, oder sie werden relativ zum Parent gerendert).
        10. `self.windows.insert(managed_popup.domain_id.clone(), Arc::new(managed_popup));`
    - **`map_toplevel(&mut self, surface: &ToplevelSurface)`**:
        1. Finde `ManagedWindow` für `surface.wl_surface()`.
        2. `managed_window.is_mapped = true;`
        3. Benachrichtige Domänenschicht (z.B. `workspace_manager_service.assign_window_to_active_workspace(&managed_window.domain_id)`).
        4. Fordere ein Re-Layout für den Workspace an.
        5. `self.space.damage_all_outputs();` (Oder spezifischer Schaden).
    - **`unmap_toplevel(&mut self, surface: &ToplevelSurface)`**:
        1. Finde `ManagedWindow`. `managed_window.is_mapped = false;`
        2. Entferne Fenster aus Workspace (`workspace_manager_service.remove_window_from_its_workspace`).
        3. `self.space.unmap_window(&managed_window_arc);`
    - **`ack_configure(&mut self, surface: WlSurface, configure_data: XdgSurfaceConfigureUserData)`**:
        1. `tracing::debug!(surface = ?surface.id(), serial = ?configure_data.serial, "XDG Surface ack_configure empfangen.");`
        2. Finde `ManagedWindow`.
        3. Logik für `ack_configure` gemäß Smithay-Dokumentation (Serial-Vergleich, Zustandsanwendung).
        4. `if let SurfaceCachedState::Toplevel(toplevel_data) = configure_data.cached_state { ... }`
    - **Andere `XdgShellHandler`-Methoden (`*_request_*`):**
        - Finde das `ManagedWindow`.
        - Aktualisiere den Zustand im `ManagedWindow` und/oder dessen `XdgToplevelSurfaceData` (z.B. `title`, `app_id`, `maximized`, `fullscreen`).
        - Interagiere mit `self.window_policy_service` für Größen-/Zustandsänderungen.
        - Rufe `toplevel_surface.send_configure()` auf, um den Client über den neuen Zustand zu informieren.
        - Für `move` und `resize`: Starte einen interaktiven Grab über `self.seat.start_pointer_grab(...)` oder `self.seat.start_touch_grab(...)`.
    - **`toplevel_destroyed(&mut self, toplevel: ToplevelSurface)`**:
        1. Finde `ManagedWindow`.
        2. `self.space.unmap_window(&managed_window_arc);`
        3. `self.windows.remove(&managed_window.domain_id);`
        4. Benachrichtige Domäne.
    - **`popup_destroyed(&mut self, popup: PopupSurface)`**: Analog.

**Datei:** `src/compositor/xdg_shell/mod.rs` (oder `state.rs`)

- **Implementierung `GlobalDispatch<XdgWmBase, ()>` für `DesktopState`**: ()
    - `bind(...)`:
        1. `let client_data = client.get_data::<Arc<Mutex<XdgWmBaseClientData>>>().cloned();` (oder `state.xdg_shell_state.new_client(client)` und speichern).
        2. `data_init.init(resource, client_data.expect("XdgWmBase client data must be set").clone());`
- **Funktion `pub fn create_xdg_shell_global(state: &mut DesktopState, display_handle: &DisplayHandle)`**: ()
    1. `let xdg_shell_global_id = state.xdg_shell_state.global().clone();`
    2. Speichere in `state.wayland_globals`.
    3. `tracing::info!("xdg_wm_base Global v{} für Clients verfügbar gemacht.", XdgWmBase::VERSION);`

#### 1.5. Implementierungsschritte `system::compositor` (Teil 1)

1. **Grundgerüst**: Verzeichnisse anlegen, `Cargo.toml` für Smithay etc. anpassen.
2. **`core/errors.rs`**: `CompositorCoreError` definieren.
3. **`surface_management/mod.rs`**: `SurfaceData`, `AttachedBufferInfo` definieren. `get_surface_data`, `with_surface_data_mut` implementieren.
4. **`core/state.rs`**: `ClientCompositorData`. `DesktopState` Grundstruktur mit `compositor_state`, `display_handle`, `loop_handle`, `clock`, `space`, `windows`, `seat_state`, `seat`, Domain-Service-Handles. `new()`-Konstruktor.
5. **`core/state.rs`**: `CompositorHandler` für `DesktopState` implementieren (`compositor_state`, `client_compositor_state`, `commit`, `new_surface`, `new_subsurface`, `destroyed`).
6. **`shm/errors.rs`**: `ShmError`.
7. **`shm/mod.rs`**: `ShmHandler` und `BufferHandler` (SHM-Teil) für `DesktopState`. `GlobalDispatch<WlShm, ()>`. `create_shm_global`.
8. **`shm/buffer_access.rs`**: `with_shm_buffer_contents`.
9. **`xdg_shell/errors.rs`**: `XdgShellError`.
10. **`xdg_shell/types.rs`**: `ManagedWindow` (implementiert `smithay::desktop::Window`), `XdgToplevelSurfaceData`, `XdgPopupSurfaceData` (Smithay-Typen, die via `UserDataMap` an `WlSurface` gehängt werden).
11. **`xdg_shell/handlers.rs`**: `XdgShellHandler` für `DesktopState` implementieren (alle Methoden, Interaktion mit `ManagedWindow`, `Space`, `window_policy_service`).
12. **`xdg_shell/mod.rs`**: `GlobalDispatch<XdgWmBase, ()>`. `create_xdg_shell_global`.
13. **`src/compositor/mod.rs`**: Öffentliche API des Compositor-Moduls definieren (z.B. Initialisierungsfunktionen, Zugriff auf `DesktopState` falls nötig).
14. **Unit-Tests (sehr anspruchsvoll für Compositor-Logik, Fokus auf Handler-Teillogik):**
    - Testen der Zustandsübergänge von `ManagedWindow`.
    - Testen der `SurfaceData`-Manipulation.
    - Mocking von Domain-Services, um Interaktionen mit `window_policy_service` etc. zu testen.
    - Smithay bietet Test-Utilities (`smithay::test_render`, Test-Clients), die evaluiert werden sollten.

---

**Nächste Schritte für `system::compositor` (Skizze für weitere Teile):**

- **`layer_shell`**: Implementierung von `WlrLayerShellHandler` etc. für Panels, Docks.
- **`decoration`**: `KdeDecorationManagerHandler` oder `XdgDecorationHandler`.
- **`output_management`**: `OutputManagerState`-Nutzung, `WlrOutputManagementHandlerV1`.
- **`input_method`**: `InputMethodManagerHandler`.
- **`screencopy`**, `data_device`, `xwayland` etc. analog.
- **`renderer_interface`**: Definition der Traits `FrameRenderer`, `RenderableTexture`.
- **Konkrete Renderer**: Implementierung für DRM/GBM und/oder Winit.

Diese detaillierte Ausarbeitung für den Kern des Compositors und XDG-Shell legt den Grundstein. Die weiteren Module der Systemschicht (`system::input`, `system::dbus_interfaces` etc.) würden mit ähnlicher Tiefe und Struktur spezifiziert werden, wobei jeweils die spezifischen Smithay-Komponenten, Systembibliotheken und Domäneninteraktionen im Fokus stehen.

---

### Modul 2: `system::input`

Zweck: Umfassende Verarbeitung von Benutzereingaben von diversen Geräten (Tastatur, Maus, Touchpad, Touchscreen, Tablets). Dies beinhaltet die Initialisierung und Verwaltung von Eingabegeräten mittels libinput, die Übersetzung roher Eingabeereignisse in für den Compositor und Wayland-Clients verständliche Formate, sowie die Handhabung des Seat-Managements, des Eingabefokus und der Cursor-Darstellung.

Verantwortlichkeiten: Integration mit libinput, Seat-Erstellung und -Verwaltung, Capability-Management (Tastatur, Zeiger, Touch), Fokuslogik, Übersetzung von Keycodes zu Keysyms/UTF-8 mittels xkbcommon, Verarbeitung von Zeigerbewegungen, Klicks, Scroll-Events, Touch-Interaktionen und Basis-Gesten.

Design-Rationale: Kapselung der komplexen Eingabelogik. libinput als Standard für die Geräteabstraktion unter Linux. Enge Verzahnung mit smithay's Seat-Management und Event-Strukturen. Die Logik muss performant und präzise sein, um eine direkte und reaktionsschnelle Benutzerinteraktion zu gewährleisten.

Bestehende Spezifikation: (ausführliche Basis aus Systemschicht Teil 1/4 der Recherche)

#### 2.1. Submodul: `system::input::errors`

**Datei:** `src/input/errors.rs`

- **Enum `InputError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use smithay::input::{SeatError, keyboard::KeyboardError};
    use std::io;
    
    #[derive(Debug, Error)]
    pub enum InputError {
        #[error("Failed to create or configure a seat: {0}")]
        SeatCreationFailed(String), // Generischer Fehler für Seat-Erstellung
        #[error("Failed to add capability '{capability}' to seat '{seat_name}': {source}")]
        CapabilityAdditionFailed {
            seat_name: String,
            capability: String,
            #[source]
            source: Box<dyn std::error::Error + Send + Sync + 'static>, // Kann SeatError oder KeyboardError sein
        },
        #[error("XKB configuration error for seat '{seat_name}': {message}")]
        XkbConfigError { seat_name: String, message: String },
        #[error("Libinput backend initialization or processing error: {0}")]
        LibinputError(String), // Für Fehler direkt von libinput oder dem Smithay-Backend
        #[error("Libinput session error: {0}")] // Für Fehler von der LibinputInterface (open_restricted/close_restricted)
        LibinputSessionError(#[from] io::Error),
        #[error("Seat '{0}' not found.")]
        SeatNotFound(String),
        #[error("Keyboard handle not found for seat '{0}'.")]
        KeyboardHandleNotFound(String),
        #[error("Pointer handle not found for seat '{0}'.")]
        PointerHandleNotFound(String),
        #[error("Touch handle not found for seat '{0}'.")]
        TouchHandleNotFound(String),
        #[error("Failed to initialize input event source in event loop: {0}")]
        EventSourceSetupError(String),
        #[error("Internal error in input system: {0}")]
        InternalError(String),
    }
    ```
    
    - **Begründung:** Diese Fehlerstruktur deckt die in genannten Fehler ab und erweitert sie um spezifischere Fälle für `libinput` und die Ereignisschleifenintegration. Das `CapabilityAdditionFailed` fasst Fehler von `seat.add_keyboard/pointer/touch` generisch zusammen.

#### 2.2. Submodul: `system::input::seat_manager`

**Zweck:** Definiert und verwaltet `SeatState` und `SeatHandler` für Eingabefokus und Capabilities.

**Datei:** `src/input/seat_manager/mod.rs` (oder `state.rs` und `handler.rs`)

- **Struktur `DesktopState` (Erweiterung für Input-Aspekte)**:
    
    Rust
    
    ```
    // In src/compositor/core/state.rs (oder wo DesktopState definiert ist)
    // ... existing fields ...
    // pub seat_state: SeatState<Self>, // Bereits vorhanden
    // pub seat: Seat<Self>,           // Bereits vorhanden
    // pub seat_name: String,          // Bereits vorhanden
    // pub keyboard_data_map: HashMap<String /* seat_name */, XkbKeyboardData>, // Bereits vorhanden
    // pub current_cursor_status: Arc<Mutex<CursorImageStatus>>, // Bereits vorhanden
    
    // Neu oder verfeinert für Fokusmanagement:
    pub pointer_location: Point<f64, Logical>, // Aktuelle globale Zeigerposition
    pub last_active_window_per_workspace: HashMap<WorkspaceId, Weak<ManagedWindow>>, // Für Fokuswiederherstellung
    pub active_input_surface: Option<Weak<WlSurface>>, // Die Oberfläche, die aktuell den logischen Input-Fokus hat (Tastatur, Zeiger, Touch)
                                                       // Dies kann komplexer sein, wenn Zeiger- und Tastaturfokus getrennt sind.
                                                       // Smithay's Seat/KeyboardHandle/PointerHandle verwalten den Fokus auf Protokollebene.
                                                       // Dieses Feld könnte den "logischen" Anwendungsfokus speichern.
    ```
    
- **Implementierung `SeatHandler` für `DesktopState`**: ()
    
    - **`type KeyboardFocus = WlSurface;`**
    - **`type PointerFocus = WlSurface;`**
    - **`type TouchFocus = WlSurface;`**
    - **`fn seat_state(&mut self) -> &mut SeatState<Self>`**: Gibt `&mut self.seat_state` zurück.
    - **`fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&Self::KeyboardFocus>)`**:
        1. `tracing::debug!(seat_name = %seat.name(), old_focus = ?self.active_input_surface.as_ref().and_then(|w| w.upgrade()).map(|s| s.id()), new_focus = ?focused.map(|s| s.id()), "SeatHandler::focus_changed (keyboard) called");`
        2. **Wichtig**: Diese Methode wird von `KeyboardHandle::set_focus` aufgerufen. Sie sollte primär dazu dienen, _interne Compositor-Zustände_ zu aktualisieren, die von der Fokusänderung abhängen, nicht umgekehrt den Fokus erneut zu setzen.
        3. Die `KeyboardHandle` sendet bereits `wl_keyboard.enter/leave`.
        4. Aktualisiere `self.active_input_surface` (oder eine spezifischere Variable für Tastaturfokus).
        5. Benachrichtige die Domänenschicht (`workspace_manager_service` oder einen dedizierten `FocusManagerService` in der Domäne) über die Fokusänderung, damit diese z.B. Fenstertitel in der UI aktualisieren oder Policy-Entscheidungen treffen kann.
            
            Rust
            
            ```
            // Beispiel:
            // let domain_window_id = find_domain_window_id_for_surface(focused);
            // block_on(self.workspace_manager_service.notify_focus_changed(domain_window_id));
            ```
            
    - **`fn cursor_image(&mut self, seat: &Seat<Self>, image: CursorImageStatus)`**:
        1. `tracing::trace!(seat_name = %seat.name(), status = ?image, "Cursor-Image-Anfrage erhalten");`
        2. `let mut current_status_guard = self.current_cursor_status.lock().unwrap();`
        3. `*current_status_guard = image;`
        4. Renderer muss benachrichtigt werden, den Cursor neu zu zeichnen. Dies kann über ein Flag geschehen oder indem der Renderer den `current_cursor_status` direkt abfragt. Der Renderer braucht auch die `pointer_location`.
            - Wenn `image == CursorImageStatus::Hidden`, setzt der Renderer den Cursor unsichtbar.
            - Wenn `image == CursorImageStatus::Surface(surface)`, muss der Renderer den Puffer dieser `surface` als Cursor verwenden (Hotspot-Informationen sind in `SurfaceData` oder als Teil von `SurfaceAttributes`).
            - Wenn `image == CursorImageStatus::Named(name)`, muss eine Cursor-Theming-Logik den Namen in eine Textur auflösen (z.B. über `libwayland-cursor` oder eine eigene Implementierung, die XCursor-Themes parst). Diese Logik gehört ggf. in ein Hilfsmodul.
- **Funktion `pub fn create_seat(state: &mut DesktopState, display_handle: &DisplayHandle, seat_name: String) -> Result<Seat<DesktopState>, InputError>`**:
    
    1. `tracing::info!("Erstelle neuen Seat: {}", seat_name);`
    2. `let seat = state.seat_state.new_wl_seat(display_handle, seat_name.clone(), Some(tracing::Span::current()));`
    3. `seat.user_data().insert_if_missing(WaylandSeatData::default);` // Standard-UserData für wl_seat
    4. **Capabilities initialisieren (aber noch nicht setzen, wenn Geräte noch nicht bekannt):**
        - `state.keyboard_data_map.insert(seat_name.clone(), XkbKeyboardData::new(&Default::default())?);` (Mit Default-XKB-Config, wird später aktualisiert).
    5. `tracing::info!("Seat '{}' erfolgreich erstellt. Capabilities werden beim Hinzufügen von Geräten gesetzt.", seat_name);`
    6. Speichere `seat.clone()` in `state.seat` (falls dies der primäre Seat ist) und `state.active_seat_name`.
    7. `Ok(seat)`

#### 2.3. Submodul: `system::input::libinput_handler`

**Zweck:** Initialisiert und konfiguriert das `LibinputInputBackend` und leitet dessen Events an spezifische Handler weiter.

**Datei:** `src/input/libinput_handler/session_interface.rs`

- **Struct `LibinputSessionManager`**:
    
    Rust
    
    ```
    use smithay::backend::session::{Session, Signal as SessionSignal, SessionNotifier};
    use std::rc::Rc; // Oder Arc, wenn thread-übergreifend benötigt
    use calloop::LoopHandle;
    use super::super::core::state::DesktopState; // Pfad anpassen
    
    // Diese Struktur wird die Logik für das Öffnen/Schließen von Geräten kapseln,
    // basierend auf dem gewählten Session-Typ (logind, direct).
    // Für diese Spezifikation ist sie ein Platzhalter.
    pub struct LibinputSessionManager {
        // notifier: SessionNotifier, // Von Smithay's Session
        // session: Rc<dyn Session>, // Oder eine konkrete Session-Implementierung
    }
    
    impl LibinputSessionManager {
        // pub fn new(session: Rc<dyn Session>, loop_handle: LoopHandle<'static, DesktopState>) -> Self {
        //     let notifier = session.notifier(loop_handle).expect("Failed to create session notifier");
        //     Self { session, notifier }
        // }
    }
    
    // Implementiert smithay::backend::input::LibinputInterface
    impl smithay::backend::input::LibinputInterface for LibinputSessionManager {
        fn open_restricted(&mut self, path: &std::path::Path, flags: i32) -> Result<std::os::unix::io::RawFd, std::io::Error> {
            // self.session.open(path, flags)
            // Platzhalter:
            Err(std::io::Error::new(std::io::ErrorKind::Unsupported, "Session Management nicht implementiert"))
        }
        fn close_restricted(&mut self, fd: std::os::unix::io::RawFd) {
            // self.session.close(fd);
            // Platzhalter:
            let _ = fd;
        }
    }
    ```
    
    - **Wichtig:** Die konkrete Implementierung hängt stark vom gewählten `Session`-Typ ab (`smithay::backend::session::direct::DirectSession` für Start ohne `logind`, `smithay::backend::session::logind::LogindSession` für `logind`-Integration). Die `Session` selbst muss korrekt initialisiert und in die `calloop`-Schleife integriert werden (Behandlung von `SessionSignal`). Dies ist ein komplexes Thema für sich und wird hier nur angerissen. Für eine minimale Lauffähigkeit kann eine Dummy-Implementierung verwendet werden, die immer Fehler zurückgibt oder `/dev/input/*` direkt öffnet (was Root-Rechte erfordert).

**Datei:** `src/input/libinput_handler/mod.rs` (oder `backend_init.rs` und `event_dispatcher.rs`)

- **Funktion `pub fn init_libinput_backend<S: Session + 'static>(loop_handle: &LoopHandle<'static, DesktopState>, session: Rc<S>) -> Result<LibinputInputBackend, InputError>`**:
    1. `tracing::info!("Initialisiere Libinput-Backend...");`
    2. `let session_interface = Rc::new(std::cell::RefCell::new(smithay::backend::session::libinput_session_interface(session)));` (Smithay stellt diese Hilfsfunktion bereit).
    3. `let mut libinput_context = libinput::Libinput::new_from_path(session_interface.clone());`
    4. `libinput_context.udev_assign_seat("seat0").map_err(|e| InputError::LibinputError(format!("Zuweisung zu udev seat0 fehlgeschlagen: {:?}", e)))?;`
    5. `let libinput_backend = LibinputInputBackend::new(libinput_context, Some(tracing::Span::current()));`
    6. `tracing::info!("Libinput-Backend erfolgreich initialisiert.");`
    7. `Ok(libinput_backend)`
- **Funktion `pub fn register_libinput_source(loop_handle: &LoopHandle<'static, DesktopState>, libinput_backend: LibinputInputBackend, seat_name: String) -> Result<calloop::Source<LibinputInputBackend>, InputError>`**:
    1. `let libinput_event_source = loop_handle.insert_source(libinput_backend, move |event, _metadata, desktop_state| { // desktop_state ist hier &mut DesktopState // Rufe den zentralen Event-Dispatcher auf super::event_dispatcher::process_input_event(desktop_state, event, &seat_name); }).map_err(|e| InputError::EventSourceSetupError(e.to_string()))?;`
    2. `Ok(libinput_event_source)` (Der Rückgabewert ist hier nicht ganz korrekt, `insert_source` gibt `RegistrationToken` oder `Source` zurück, abhängig von der calloop-Version und Methode). Korrekt wäre, dass der `LibinputInputBackend` selbst die Quelle ist. Die Logik ist, dass der `LibinputInputBackend` in die Schleife eingefügt wird.
- **Datei: `src/input/event_dispatcher.rs`**
    - **Funktion `pub fn process_input_event(desktop_state: &mut DesktopState, event: InputEvent<LibinputInputBackend>, seat_name: &str)`**: ()
        1. `let seat = match desktop_state.seat_state.seats().find(|s| s.name() == seat_name) { Some(s) => s.clone(), None => { tracing::error!("Seat '{}' nicht gefunden für Input-Event.", seat_name); return; } };`
        2. `match event { ... }` wie in detailliert.
            - **`InputEvent::DeviceAdded { device }`**:
                - `tracing::info!("Eingabegerät hinzugefügt: {} (Sys: {})", device.name(), device.sysname());`
                - Wenn `device.has_capability(libinput::DeviceCapability::Keyboard)` und `seat.get_keyboard().is_none()`:
                    - `let kbd_config = XkbConfig::default(); // Oder aus GlobalSettings laden`
                    - `match seat.add_keyboard(kbd_config, 200, 25) { Ok(_) => tracing::info!("Tastatur-Capability zu Seat '{}' hinzugefügt.", seat_name), Err(e) => tracing::error!("Fehler beim Hinzufügen der Tastatur-Capability: {}", e), };`
                    - (XkbKeyboardData muss ggf. aktualisiert werden)
                - Analog für `Pointer` und `Touch`.
            - **`InputEvent::DeviceRemoved { device }`**:
                - `tracing::info!("Eingabegerät entfernt: {}", device.name());`
                - Wenn `device.has_capability(libinput::DeviceCapability::Keyboard)`: `seat.remove_keyboard();`
                - Analog für `Pointer` und `Touch`.

#### 2.4. Submodul: `system::input::keyboard`

**Zweck:** Tastaturereignis-Übersetzung, XKB-Management.

**Datei:** `src/input/keyboard/xkb_config.rs`

- **Struct `XkbKeyboardData`**:
    
    Rust
    
    ```
    use xkbcommon::xkb;
    use smithay::input::keyboard::{KeyboardConfig, ModifiersState as SmithayModifiersState};
    use calloop::TimerHandle;
    use smithay::reexports::wayland_server::protocol::wl_surface::WlSurface;
    use wayland_server::Weak;
    use smithay::utils::Serial;
    
    #[derive(Debug)] // TimerHandle ist nicht Debug
    pub struct XkbKeyboardData {
        pub context: xkb::Context,
        pub keymap: xkb::Keymap,
        pub state: xkb::State,
        pub repeat_timer: Option<TimerHandle>,
        pub repeat_info: Option<(u32 /* keycode */, xkb::Keycode /* xkb keycode */, SmithayModifiersState, std::time::Duration /* delay */, std::time::Duration /* rate */)>,
        pub focused_surface_on_seat: Option<Weak<WlSurface>>,
        pub repeat_key_serial: Option<Serial>,
        // Für Tastenwiederholung: Speichern des xkb-Keycodes, nicht nur des libinput-Keycodes.
    }
    
    impl XkbKeyboardData {
        pub fn new(config: &KeyboardConfig<'_>) -> Result<Self, InputError> {
            let context = xkb::Context::new(xkb::CONTEXT_NO_FLAGS);
            let keymap_name = config.keymap_name.as_deref().unwrap_or("default"); // Bessere Defaults nötig
            let rules = config.rules.as_deref().unwrap_or("evdev");
            let model = config.model.as_deref().unwrap_or("pc105");
            let layout = config.layout.as_deref().unwrap_or("us");
            let variant = config.variant.as_deref();
            let options = config.options.as_deref();
    
            tracing::debug!("Lade XKB Keymap: rules={}, model={}, layout={}, variant={:?}, options={:?}",
                rules, model, layout, variant, options);
    
            let mut keymap_builder = xkb::KeymapCompileArgsBuilder::new();
            keymap_builder.rules(rules);
            keymap_builder.model(model);
            keymap_builder.layout(layout);
            if let Some(v) = variant { keymap_builder.variant(v); }
            if let Some(o) = options { keymap_builder.options(o); }
    
    
            let keymap = match xkb::Keymap::new_from_names(
                &context,
                &keymap_builder.build(), // Verwende den Builder
                xkb::KEYMAP_COMPILE_NO_FLAGS,
            ) {
                Ok(km) => km,
                Err(_) => { // Fallback zu einfacherem Setup
                    tracing::warn!("Komplexe XKB-Keymap '{}' konnte nicht geladen werden, versuche Fallback (us).", keymap_name);
                    let fallback_args = xkb::KeymapCompileArgsBuilder::new()
                        .layout("us").build();
                    xkb::Keymap::new_from_names(&context, &fallback_args, xkb::KEYMAP_COMPILE_NO_FLAGS)
                        .map_err(|_| InputError::XkbConfigError { seat_name: "unknown".into(), message: "Fallback XKB Keymap (us) konnte nicht kompiliert werden".into() })?
                }
            };
    
            let state = xkb::State::new(&keymap);
            Ok(Self {
                context, keymap, state,
                repeat_timer: None, repeat_info: None, focused_surface_on_seat: None, repeat_key_serial: None
            })
        }
    }
    ```
    
- **`Default for KeyboardConfig`**: Wird benötigt, um `XkbKeyboardData::new(&Default::default())` aufrufen zu können.
    
    Rust
    
    ```
    // Ggf. in KeyboardConfig von Smithay oder hier lokal
    // impl Default for KeyboardConfig<'_> { ... }
    ```
    

**Datei:** `src/input/keyboard/key_event_translator.rs`

- **Funktion `pub fn handle_keyboard_key_event(...)`**: ()
    1. Hole `keyboard_handle = seat.get_keyboard().ok_or(...)?.clone();`
    2. Hole `xkb_data = desktop_state.keyboard_data_map.get_mut(seat_name).ok_or(...)?;`
    3. `let keycode = event.key_code();`
    4. `let xkb_keycode = keycode + 8; // Libinput keycodes sind XKB keycodes - 8`
    5. `let key_state_xkb = match event.state() { KeyState::Pressed => xkb::KeyDirection::Down, KeyState::Released => xkb::KeyDirection::Up, };`
    6. `xkb_data.state.update_key(xkb_keycode.into(), key_state_xkb);`
    7. `let smithay_mods_state = SmithayModifiersState { ... /* von xkb_data.state.serialize_mods etc. */ };`
    8. `keyboard_handle.modifiers(event.serial(), smithay_mods_state.clone(), Some(tracing::Span::current()));`
    9. Wenn `event.state() == KeyState::Pressed`:
        - `let serial = event.serial();`
        - `let time = event.time();`
        - `keyboard_handle.key(serial, time, xkb_keycode, KeyState::Pressed, Some(tracing::Span::current()));`
        - **Tastenwiederholung einrichten:**
            - `if let Some(timer) = xkb_data.repeat_timer.take() { timer.cancel(); }`
            - `if keyboard_handle.is_repeating(xkb_keycode) { ... }`
            - `let (delay, rate) = keyboard_handle.repeat_info();`
            - `xkb_data.repeat_info = Some((keycode, xkb_keycode.into(), smithay_mods_state, delay, rate));`
            - `xkb_data.repeat_key_serial = Some(serial);`
            - `let timer_seat_name = seat_name.to_string();`
            - `xkb_data.repeat_timer = Some(desktop_state.loop_handle.insert_timer(delay, move |ds: &mut DesktopState| { ... repeat_logic ... }).expect("Timer creation failed"));`
    10. Wenn `event.state() == KeyState::Released`:
        - `keyboard_handle.key(event.serial(), event.time(), xkb_keycode, KeyState::Released, Some(tracing::Span::current()));`
        - **Tastenwiederholung abbrechen:** `if xkb_data.repeat_info.map_or(false, |(_, rkc, ..)| rkc == xkb_keycode.into()) { ... cancel timer ... }`
- **Tastenwiederholungslogik im Timer-Callback:**
    1. Hole `xkb_data` für `timer_seat_name`.
    2. Wenn `xkb_data.repeat_info` `None` ist oder der Fokus gewechselt hat (prüfe `xkb_data.focused_surface_on_seat`), Timer abbrechen und `return;`.
    3. `let (keycode, xkb_keycode, mods_state, _, rate) = xkb_data.repeat_info.as_ref().unwrap().clone();`
    4. Hole aktuellen `seat` und `keyboard_handle`.
    5. `let new_serial = Serial::now();` // Wichtig: Neuer Serial für wiederholte Events
    6. `keyboard_handle.modifiers(new_serial, mods_state, Some(tracing::Span::current()));`
    7. `keyboard_handle.key(new_serial, current_time_ms(), xkb_keycode, KeyState::Pressed, Some(tracing::Span::current()));`
    8. `xkb_data.repeat_key_serial = Some(new_serial);`
    9. Timer mit `rate` neu planen.

**Datei:** `src/input/keyboard/focus.rs` (ersetzt `focus_handler_keyboard.rs`)

- **Funktion `pub fn set_keyboard_focus(desktop_state: &mut DesktopState, seat_name: &str, surface: Option<&WlSurface>, serial: Serial)`**:
    1. `tracing::debug!(seat = %seat_name, new_focus_surface = ?surface.map(|s| s.id()), ?serial, "Setze Tastaturfokus");`
    2. Hole `seat = desktop_state.seat_state.seats().find(|s| s.name() == seat_name).cloned().ok_or(...)`;
    3. Hole `keyboard = seat.get_keyboard().ok_or(...)?.clone();`
    4. Hole `xkb_data = desktop_state.keyboard_data_map.get_mut(seat_name).ok_or(...)?;`
    5. `let old_focus_wl_surface = xkb_data.focused_surface_on_seat.as_ref().and_then(|w| w.upgrade());`
    6. `if old_focus_wl_surface.as_ref() == surface { tracing::trace!("Tastaturfokus unverändert."); return Ok(()); }`
    7. `keyboard.set_focus(surface, serial, Some(tracing::Span::current()));` // Smithay sendet Enter/Leave
    8. `xkb_data.focused_surface_on_seat = surface.map(|s| s.downgrade());`
    9. // Domänenschicht über Fokusänderung informieren, falls `SeatHandler::focus_changed` nicht ausreicht
        
        Rust
        
        ```
        // let domain_window_id = surface.and_then(|s| find_domain_window_id_for_surface(desktop_state, s));
        // block_on(desktop_state.workspace_manager_service.notify_keyboard_focus_changed(domain_window_id));
        ```
        

#### 2.5. Submodul: `system::input::pointer`

**Zweck:** Maus-/Zeigerereignis-Verarbeitung, Cursor.

**Datei:** `src/input/pointer/mod.rs` (oder `event_translator.rs`, `focus.rs`, `cursor.rs`)

- **Funktion `pub fn handle_pointer_motion_event(...)`**: ()
    1. Hole `pointer_handle = seat.get_pointer().ok_or(...)?;`
    2. `desktop_state.pointer_location += event.delta();` // Einfache Akkumulation, ggf. an Bildschirmgrenzen klemmen.
    3. `let (new_focus_surface_option, surface_local_coords) = find_surface_and_coords_at_global_point(desktop_state, desktop_state.pointer_location);`
    4. `pointer_handle.motion(event.time(), new_focus_surface_option.as_ref(), serial, desktop_state.pointer_location, surface_local_coords, Some(tracing::Span::current()));` (Smithay's `motion` sendet `enter`/`leave` und `motion`).
    5. Aktualisiere `desktop_state.active_input_surface` basierend auf `new_focus_surface_option`.
    6. Renderer Cursor-Position aktualisieren (indem Renderer `desktop_state.pointer_location` liest).
- **Funktion `find_surface_and_coords_at_global_point(desktop_state: &DesktopState, global_pos: Point<f64, Logical>) -> (Option<WlSurface>, Point<f64, Logical>)`**:
    1. Iteriere über `desktop_state.space.elements_under(global_pos)` (Smithay's Space liefert Fenster in korrekter Reihenfolge).
    2. Für jedes `Window` (unsere `ManagedWindow`-Implementierung):
        - Hole `wl_surface = window.wl_surface()`.
        - Prüfe, ob `wl_surface` eine Eingaberegion hat (`SurfaceData::input_region_surface_local`).
        - Transformiere `global_pos` in Oberflächen-lokale Koordinaten.
        - Wenn `global_pos` innerhalb der Eingaberegion (oder der Oberflächengeometrie, falls keine Eingaberegion):
            - Gib `(Some(wl_surface.clone()), surface_local_coords)` zurück.
    3. Sonst: `(None, global_pos)` (oder `(0.0, 0.0)` für lokale Coords).
- **Funktion `handle_pointer_button_event(...)`**: ()
    1. Hole `pointer_handle`.
    2. `pointer_handle.button(event.button(), event.button_state().into(), event.serial(), event.time(), Some(tracing::Span::current()));`
    3. Wenn `event.button_state() == ButtonState::Pressed`:
        - `let (focused_surface_option, _) = find_surface_and_coords_at_global_point(desktop_state, desktop_state.pointer_location);`
        - Wenn `focused_surface_option` `Some(surface_to_focus)`:
            - `set_keyboard_focus(desktop_state, seat_name, Some(&surface_to_focus), event.serial())?;` (Click-to-focus).
            - Hier könnte auch Logik für Fenstermanagement-Aktionen (Move/Resize-Start) basierend auf `surface_to_focus` und Klickposition (relativ zu Dekorationen) ausgelöst werden.
- **Funktion `handle_pointer_axis_event(...)`**: ()
    1. Hole `pointer_handle`.
    2. `pointer_handle.axis(event.time(), event.axis(), event.axis_source().into(), event.axis_value_discrete(), event.axis_value(smithay::utils:: SERIAL_COUNTER_RANGE), event.serial(), Some(tracing::Span::current()));` (Smithay-Signatur anpassen).

#### 2.6. Submodul: `system::input::touch`

**Zweck:** Touch-Ereignis-Verarbeitung.

**Datei:** `src/input/touch/mod.rs` (oder `event_translator.rs`, `focus.rs`)

- **Logik für `handle_touch_down_event`**: ()
    1. Hole `touch_handle = seat.get_touch().ok_or(...)?;`
    2. `let slot = event.slot().ok_or_else(|| InputError::InternalError("Touch down event ohne Slot ID".into()))?;`
    3. `let (focused_surface_option, surface_local_coords) = find_surface_and_coords_at_global_point(desktop_state, event.position_transformed(output_size));`
    4. Wenn `focused_surface_option` `Some(surface)`:
        - Speichere `surface.clone()` als Fokus für diesen `slot` (z.B. in einer `HashMap<TouchSlotId, WlSurface>` in `DesktopState`).
        - `touch_handle.down(event.serial(), event.time(), slot, surface_local_coords, &surface, Some(tracing::Span::current()));`
        - `set_keyboard_focus(desktop_state, seat_name, Some(&surface), event.serial())?;` (Touch-to-focus).
- **Logik für `handle_touch_up_event`**: ()
    1. Hole `touch_handle`. `let slot = event.slot().ok_or(...)`;
    2. `touch_handle.up(event.serial(), event.time(), slot, Some(tracing::Span::current()));`
    3. Entferne Fokus für diesen `slot` aus der internen Map.
- **Logik für `handle_touch_motion_event`**: ()
    1. Hole `touch_handle`. `let slot = event.slot().ok_or(...)`;
    2. Hole die fokussierte Oberfläche für diesen `slot` aus der internen Map.
    3. Transformiere `event.position_transformed(output_size)` in lokale Koordinaten dieser Oberfläche.
    4. `touch_handle.motion(event.serial(), event.time(), slot, surface_local_coords, Some(tracing::Span::current()));`
- **`handle_touch_frame_event`, `handle_touch_cancel_event`**: Rufen entsprechende `touch_handle`-Methoden auf.

#### 2.7. Submodul: `system::input::gestures`

Zweck: Grundlegende Gestenerkennung (Pinch, Swipe) aufbauend auf libinput-Events.

Datei: src/input/gestures/mod.rs

- **Initial:** Für Gesten wie `InputEvent::GesturePinchBegin/Update/End`, `InputEvent::GestureSwipeBegin/Update/End`:
    1. Logge das Ereignis mit `tracing::debug!`.
    2. **Zukünftige Erweiterung:**
        - Eine `GestureState`-Struktur pro aktivem Seat, die laufende Gesten verfolgt.
        - Bei `GestureSwipeBegin`: Starte eine "Swipe"-Geste.
        - Bei `GestureSwipeUpdate`: Akkumuliere `event.dx()`, `event.dy()`. Wenn ein Schwellenwert überschritten wird:
            - Wandle in eine Domänenaktion um (z.B. Workspace wechseln). Rufe z.B. `desktop_state.workspace_manager_service.switch_to_next_workspace().await;`.
        - Bei `GestureSwipeEnd`: Beende die Geste.
        - Ähnlich für Pinch-to-Zoom (könnte z.B. Skalierungsfaktor einer App oder des Desktops beeinflussen - komplexe Interaktion mit Compositor/Anwendung).
- **Abhängigkeiten:** Benötigt Zugriff auf Domänenservices (z.B. `WorkspaceManagerService`).

#### 2.8. Implementierungsschritte `system::input`

1. **Grundgerüst**: Verzeichnisse anlegen, `Cargo.toml` für `libinput`, `xkbcommon` etc.
2. **`errors.rs`**: `InputError` Enum definieren.
3. **`seat_manager/mod.rs`**:
    - `DesktopState`-Felder für Input/Fokus erweitern.
    - `SeatHandler` für `DesktopState` implementieren (`focus_changed`, `cursor_image`).
    - `create_seat` Funktion implementieren.
4. **`libinput_handler/session_interface.rs`**: `LibinputSessionManager` (ggf. mit Dummy-Implementierung für `open/close_restricted` initial).
5. **`libinput_handler/mod.rs`**: `init_libinput_backend`, `register_libinput_source`.
6. **`event_dispatcher.rs`**: `process_input_event` mit `match` für alle relevanten `InputEvent`-Typen und Delegation an Handler in `keyboard`, `pointer`, `touch`. Logik für `DeviceAdded/Removed`.
7. **`keyboard/xkb_config.rs`**: `XkbKeyboardData`-Struct und `new()`-Methode.
8. **`keyboard/key_event_translator.rs`**: `handle_keyboard_key_event` inklusive Tastenwiederholungslogik (Timer-Setup und Callback).
9. **`keyboard/focus.rs`**: `set_keyboard_focus` implementieren.
10. **`pointer/mod.rs`**: `handle_pointer_motion_event` (inkl. `find_surface_and_coords_at_global_point`), `handle_pointer_button_event`, `handle_pointer_axis_event`.
11. **`touch/mod.rs`**: `handle_touch_down/up/motion/frame/cancel_event`. Interne Verwaltung des Touch-Fokus pro Slot.
12. **`gestures/mod.rs`**: Basis-Logging für Gesten-Events.
13. **`src/input/mod.rs`**: Öffentliche API des Input-Moduls definieren (z.B. Initialisierungsfunktionen).
14. **Unit-Tests (anspruchsvoll, erfordert oft Mocking von `Seat`, `KeyboardHandle` etc. oder Integrationstests):**
    - Testen der XKB-Keymap-Erstellung.
    - Testen der Keycode-zu-Keysym/UTF-8-Übersetzung für einige Tasten.
    - Testen der Fokussetzungslogik (Keyboard, Pointer, Touch).
    - Testen der Event-Weiterleitung für verschiedene Eingabetypen.
    - Testen der `find_surface_and_coords_at_global_point`-Logik mit verschiedenen Fensterlayouts.

---

**Nächste Schritte für `system` (Skizze für weitere Module):**

- **`system::dbus_interfaces`**:
    - **Verantwortlichkeiten:** Clients für wichtige Systemdienste (NetworkManager, UPower, logind, Secrets, PolicyKit) und Server für `org.freedesktop.Notifications`.
    - **Technologie:** `zbus` (async).
    - **Struktur:** Pro Dienst ein Submodul (z.B. `dbus_interfaces::upower_client`).
    - **Jedes Client-Submodul:**
        - Definiert Proxy-Structs für die D-Bus-Interfaces des Dienstes.
        - Implementiert Methoden zum Abrufen von Eigenschaften und Aufrufen von Methoden des Dienstes.
        - Implementiert Signal-Handler, um auf D-Bus-Signale zu reagieren und diese in interne System-Events oder Domänenaufrufe zu übersetzen.
        - Fehlerbehandlung mit spezifischem `DBusInterfaceError`.
    - **`notifications_server`**: Implementiert den `org.freedesktop.Notifications`-D-Bus-Service. Leitet eingehende `Notify`-Aufrufe an `domain::user_centric_services::NotificationService::post_notification` weiter. Handhabt `GetCapabilities`, `CloseNotification`, `GetServerInformation`. Sendet `NotificationClosed`, `ActionInvoked` Signale.
- **`system::audio_management`**:
    - **Verantwortlichkeiten:** Steuerung der Systemlautstärke, Auswahl von Audio-Geräten, Verwaltung von Anwendungs-Streams.
    - **Technologie:** `pipewire-rs`.
    - **Struktur:** `client` (Core-Verbindung), `device_manager`, `stream_manager`, `volume_control`.
    - Interaktion mit PipeWire-Registry, um Geräte und Streams zu entdecken.
    - Nutzung von `PWStream` für Lautstärkeregelung etc.
    - Übersetzung von PipeWire-Events in interne System-Events oder Domänenaufrufe.
- **`system::mcp_client`**:
    - **Verantwortlichkeiten:** Sichere Kommunikation mit lokalen/remote MCP-Servern.
    - **Technologie:** `mcp_client_rs`.
    - Nimmt Anweisungen und Kontextdaten von `domain::user_centric_services::ai_interaction` entgegen.
    - Ruft Methoden des `mcp_client_rs::McpClient` auf.
    - Leitet Ergebnisse/Fehler an die Domänenschicht zurück.
    - Verwaltet API-Schlüssel sicher (über `dbus_interfaces::secrets_service`).
- **`system::window_mechanics`**:
    - **Verantwortlichkeiten:** Konkrete Umsetzung der Fenstermanagement-"Mechanik" basierend auf Richtlinien aus `domain::window_management_policy`.
    - Interagiert eng mit `system::compositor::xdg_shell` und `smithay::desktop::Space`.
    - Ruft `domain::window_management_policy_service::calculate_workspace_layout()` auf und wendet die resultierenden Geometrien auf `ManagedWindow`s an (z.B. über deren `send_configure`-Methoden oder direkte Manipulation im `Space`).
    - Implementiert Snapping während interaktiver Move/Resize-Operationen.
    - Koordiniert Client-Side vs. Server-Side Decorations.
- **`system::event_bridge`**:
    - Ein Modul, das `tokio::sync::broadcast` Kanäle oder ähnliche Mechanismen nutzt, um System-interne Events (z.B. "Neues Eingabegerät", "Netzwerkstatus geändert", "Batteriestand niedrig") für andere Systemmodule oder Adapter zur Domänenschicht bereitzustellen.
- **`system::power_management`**:
    - Interagiert mit `wlr-output-power-management-unstable-v1` (serverseitig im Compositor implementiert).
    - Interagiert mit `system::dbus_interfaces::logind` für Suspend/Hibernate.
    - Setzt DPMS-Modi für Outputs basierend auf `domain::global_settings_service` und Benutzeraktivität (`domain::common_events::UserActivityDetectedEvent`).

Diese detaillierte Ausarbeitung für `system::input` und die Skizzen für die weiteren Module sollten eine solide Basis für die Implementierung der gesamten Systemschicht bilden. Jedes dieser Module erfordert eine ähnliche Tiefe der Spezifikation, insbesondere bei der Interaktion mit externen Bibliotheken und Protokollen.

Kurzfassung: Rust (Edition 2021+), Nutzung von novade-core und novade-domain, zbus für D-Bus-Interaktionen, smithay (wo relevant für Compositor-Interaktionen), tokio (oft von zbus benötigt), thiserror für Fehler.

**Cargo.toml für `novade-system` (relevante Ergänzungen für D-Bus):**

Ini, TOML

```
[dependencies]
# ... (bestehende Abhängigkeiten wie novade-core, novade-domain, smithay, etc.) ...
zbus = { version = "3.15", default-features = false, features = ["tokio"] } # Aktuelle zbus 4.x Version prüfen, tokio feature ist wichtig
serde = { version = "1.0.197", features = ["derive"] }
serde_json = "1.0.115" # Falls einige D-Bus Properties/Methoden JSON verwenden
tracing = "0.1.40"
thiserror = "1.0.58"
async-trait = "0.1.79"
tokio = { version = "1.37.0", features = ["sync", "rt", "macros"] }
# Ggf. spezifische Crates für Freedesktop-Spezifikationen, falls zbus nicht alles abdeckt
# oder für komplexere Typen (z.B. `dbus-crossroads` für Server-Seite, obwohl zbus auch Server kann)
```

---

### Modul 3: `system::dbus_interfaces`

Zweck: Implementierung von Schnittstellen zur Interaktion mit etablierten System-D-Bus-Diensten sowie Bereitstellung eigener D-Bus-Schnittstellen, wo dies von der Architektur vorgesehen ist (z.B. org.freedesktop.Notifications).

Verantwortlichkeiten:

- Erstellen und Verwalten von D-Bus-Verbindungen (Session und System Bus).
- Implementierung von Clients (Proxies) für externe D-Bus-Dienste wie NetworkManager, UPower, logind, org.freedesktop.secrets, PolicyKit.
- Abrufen von Eigenschaften, Aufrufen von Methoden und Abonnieren von Signalen dieser Dienste.
- Übersetzung von D-Bus-Daten und -Signalen in interne System-Events oder Aufrufe an die Domänenschicht.
- Implementierung von D-Bus-Server-Objekten für Dienste, die NovaDE selbst bereitstellt (z.B. `org.freedesktop.Notifications`). **Design-Rationale:** Kapselung aller D-Bus-spezifischen Logik. Verwendung von `zbus` als moderne, asynchrone D-Bus-Bibliothek in Rust. Klare Trennung zwischen D-Bus-Protokoll-Interaktion und der Verarbeitungslogik in anderen System- oder Domänenmodulen.

#### 3.1. Submodul: `system::dbus_interfaces::common`

**Zweck:** Definition gemeinsamer Typen, Fehler und Hilfsfunktionen für alle D-Bus-Interaktionen.

**Datei:** `src/dbus_interfaces/common/errors.rs`

- **Enum `DBusInterfaceError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use zbus::Error as ZBusError;
    use zbus::names::ErrorName;
    
    #[derive(Debug, Error)]
    pub enum DBusInterfaceError {
        #[error("D-Bus connection failed: {0}")]
        ConnectionFailed(#[from] ZBusError), // Direkter Fehler von zbus beim Verbindungsaufbau
        #[error("Failed to create D-Bus proxy for service '{service}' path '{path}' interface '{interface}': {source}")]
        ProxyCreationFailed {
            service: String,
            path: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("D-Bus method call '{method}' on '{interface}' failed: {source}")]
        MethodCallFailed {
            method: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Failed to get D-Bus property '{property}' from '{interface}': {source}")]
        PropertyGetFailed {
            property: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Failed to set D-Bus property '{property}' on '{interface}': {source}")]
        PropertySetFailed {
            property: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Failed to subscribe to D-Bus signal '{signal}' from '{interface}': {source}")]
        SignalSubscriptionFailed {
            signal: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Received D-Bus error reply: {name} - {body}")]
        DBusErrorReply {
            name: ErrorName<'static>, // 'static hier, da ErrorName oft geklont wird
            body: String, // Oft der Message-Teil des D-Bus-Fehlers
        },
        #[error("Type conversion error during D-Bus operation: {0}")]
        TypeConversionError(String), // Wenn z.B. ein zvariant nicht in den erwarteten Rust-Typ passt
        #[error("Required D-Bus service '{service}' is not available or not activatable.")]
        ServiceUnavailable { service: String },
        #[error("D-Bus object path '{0}' not found for service.")]
        ObjectPathNotFound(String),
        #[error("D-Bus interface '{0}' not found on object.")]
        InterfaceNotFound(String),
        #[error("An internal error occurred in a D-Bus interface: {0}")]
        InternalError(String),
    }
    
    // Hilfsfunktion, um zbus::Error in DBusErrorReply zu konvertieren, falls es ein D-Bus-Fehler war
    impl From<ZBusError> for DBusInterfaceError {
        fn from(err: ZBusError) -> Self {
            if let ZBusError::MethodError(name, body, _) = err {
                DBusInterfaceError::DBusErrorReply { name: name.into_static(), body: body.unwrap_or_default() }
            } else {
                // Für andere ZBusError-Typen, die nicht MethodError sind,
                // könnte man spezifischere Mappings oder eine generische Variante haben.
                // Hier als Beispiel: fallback auf MethodCallFailed (kontextabhängig anpassen)
                DBusInterfaceError::MethodCallFailed {
                    method: "unknown".to_string(),
                    interface: "unknown".to_string(),
                    source: err,
                }
            }
        }
    }
    ```
    
    - **Begründung:** Fasst generische D-Bus-Fehler und spezifischere Fälle wie `ProxyCreationFailed` oder `ServiceUnavailable` zusammen. Die `From<ZBusError>` Implementierung hilft, `zbus`-Fehler direkt in benutzerdefinierte Fehler zu überführen.

**Datei:** `src/dbus_interfaces/common/connection_manager.rs`

- **Struct `DBusConnectionManager`**:
    
    Rust
    
    ```
    use zbus::{Connection, ConnectionBuilder, Address, Transport};
    use super::errors::DBusInterfaceError;
    use std::sync::{Arc, OnceLock}; // OnceLock für Singleton-Verbindungen
    use tokio::sync::Mutex; // Mutex, falls die Verbindung modifiziert werden kann (selten)
    
    static SESSION_BUS: OnceLock<Arc<Connection>> = OnceLock::new();
    static SYSTEM_BUS: OnceLock<Arc<Connection>> = OnceLock::new();
    
    #[derive(Debug, Clone)]
    pub struct DBusConnectionManager;
    
    impl DBusConnectionManager {
        /// Stellt die Session-Bus-Verbindung her (oder gibt die bestehende zurück).
        pub async fn session_bus() -> Result<Arc<Connection>, DBusInterfaceError> {
            if let Some(conn) = SESSION_BUS.get() {
                return Ok(conn.clone());
            }
            let conn = ConnectionBuilder::session()?
                .build()
                .await?;
            let arc_conn = Arc::new(conn);
            match SESSION_BUS.set(arc_conn.clone()) {
                Ok(_) => Ok(arc_conn),
                Err(existing_conn_arc) => Ok(existing_conn_arc.clone()), // Rennen gewonnen von anderem Thread
            }
        }
    
        /// Stellt die System-Bus-Verbindung her (oder gibt die bestehende zurück).
        pub async fn system_bus() -> Result<Arc<Connection>, DBusInterfaceError> {
            if let Some(conn) = SYSTEM_BUS.get() {
                return Ok(conn.clone());
            }
            let conn = ConnectionBuilder::system()?
                .build()
                .await?;
            let arc_conn = Arc::new(conn);
            match SYSTEM_BUS.set(arc_conn.clone()) {
                Ok(_) => Ok(arc_conn),
                Err(existing_conn_arc) => Ok(existing_conn_arc.clone()),
            }
        }
    
        /// Erstellt einen zbus Proxy.
        pub async fn create_proxy<'a, T: zbus::ProxyDefault + Send + Sync + 'static>(
            connection: Arc<Connection>,
            destination: &'static str, // Muss 'static sein für einige Proxy-Konstrukte
            path: &'static str,
        ) -> Result<T, DBusInterfaceError> {
            T::builder(&connection)
                .destination(destination)?
                .path(path)?
                .build()
                .await
                .map_err(|e| DBusInterfaceError::ProxyCreationFailed {
                    service: destination.to_string(),
                    path: path.to_string(),
                    interface: T::INTERFACE.unwrap_or("unknown").to_string(), // T::INTERFACE ist Option<&'static str>
                    source: e,
                })
        }
    }
    ```
    
    - **Zweck:** Stellt sicher, dass nur eine Verbindung pro Bus-Typ (Session/System) besteht und verwaltet wird (`OnceLock` für Singleton-Pattern). Bietet eine Hilfsfunktion zum Erstellen von Proxies.
    - **Methoden:** `session_bus() -> Result<Arc<Connection>>`, `system_bus() -> Result<Arc<Connection>>`, `create_proxy<T>(...)`.
    - **Zustand:** Die `OnceLock`-statischen Variablen halten die globalen Verbindungen.

**Datei:** `src/dbus_interfaces/common/mod.rs`

- `pub mod errors;`
- `pub mod connection_manager;`
- `pub use errors::DBusInterfaceError;`
- `pub use connection_manager::DBusConnectionManager;`

#### 3.2. Submodul: `system::dbus_interfaces::upower_client`

Zweck: Client für den org.freedesktop.UPower Dienst zur Abfrage von Energieinformationen (Batteriestatus, Deckelzustand etc.).

Interaktion mit Domäne: Sendet UPowerEvent (neu zu definierendes Event in system::event_bridge oder direkt an einen Domänen-Service) an die Domänenschicht (z.B. domain::power_management_policy oder einen allgemeinen SystemStatusService).

**Datei:** `src/dbus_interfaces/upower_client/types.rs`

- **Enums (Spiegelung der D-Bus-Typen von UPower):**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize}; // Für Events
    use zbus::zvariant::Type; // Für D-Bus Typ-Annotationen
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Type, Serialize, Deserialize)]
    #[repr(u32)] // Entspricht den UPower-Enum-Werten
    pub enum PowerDeviceType {
        Unknown = 0,
        LinePower = 1,
        Battery = 2,
        Ups = 3,
        Monitor = 4,
        Mouse = 5,
        Keyboard = 6,
        Pda = 7,
        Phone = 8,
        MediaPlayer = 9,
        Tablet = 10,
        Computer = 11,
    }
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Type, Serialize, Deserialize)]
    #[repr(u32)]
    pub enum PowerState {
        Unknown = 0,
        Charging = 1,
        Discharging = 2,
        Empty = 3,
        FullyCharged = 4,
        PendingCharge = 5,
        PendingDischarge = 6,
    }
    
    #[derive(Debug, Clone, PartialEq, Type, Serialize, Deserialize)]
    pub struct PowerDeviceDetails {
        pub native_path: String, // z.B. /sys/class/power_supply/BAT0
        pub vendor: String,
        pub model: String,
        pub serial: String,
        pub update_time: u64, // Unix-Timestamp
        pub device_type: PowerDeviceType,
        pub online: bool,
        pub energy: f64, // Wh (Watt-hours)
        pub energy_empty: f64,
        pub energy_full: f64,
        pub energy_full_design: f64,
        pub energy_rate: f64, // Watt (aktuelle Leistung)
        pub voltage: f64,
        pub time_to_empty: u64, // Sekunden
        pub time_to_full: u64, // Sekunden
        pub percentage: f64, // 0.0 - 100.0
        pub temperature: f64, // Celsius
        pub is_rechargeable: bool,
        pub capacity: f64, // Prozentsatz der Design-Kapazität
        pub technology: u32, // Enum UPowerTechnology
        pub warning_level: u32, // Enum UPowerWarningLevel
        pub state: PowerState,
        pub icon_name: String,
        // Weitere Felder nach Bedarf aus `org.freedesktop.UPower.Device`
    }
    ```
    
- **Event-Struktur (für `system::event_bridge`):**
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum UPowerEvent {
        DeviceAdded(String /* object_path */),
        DeviceRemoved(String /* object_path */),
        DeviceChanged(String /* object_path */), // Wenn Eigenschaften eines Geräts sich ändern
        LidStateChanged(bool /* is_closed */),
        OnBatteryChanged(bool /* is_on_battery */),
        PowerSupplyChanged, // Generelles Event, wenn sich etwas an der Stromversorgung ändert
    }
    ```
    

**Datei:** `src/dbus_interfaces/upower_client/proxies.rs`

- **zbus Proxy-Definitionen (manuell oder mit `zbus::proxy` Makro):**
    - **`UPowerProxy` für `org.freedesktop.UPower` auf `/org/freedesktop/UPower`**:
        
        Rust
        
        ```
        use zbus::proxy;
        use zbus::zvariant::{OwnedObjectPath, Value};
        use super::types::PowerDeviceDetails; // Annahme: PowerDeviceDetails ist als Value deserialisierbar
        
        #[proxy(
            interface = "org.freedesktop.UPower",
            default_service = "org.freedesktop.UPower",
            default_path = "/org/freedesktop/UPower"
        )]
        trait UPower {
            fn enumerate_devices(&self) -> zbus::Result<Vec<OwnedObjectPath>>;
            fn get_display_device(&self) -> zbus::Result<OwnedObjectPath>;
            fn get_critical_action(&self) -> zbus::Result<String>;
        
            #[zbus(property)]
            fn lid_is_closed(&self) -> zbus::Result<bool>;
            #[zbus(property)]
            fn lid_is_present(&self) -> zbus::Result<bool>;
            #[zbus(property)]
            fn on_battery(&self) -> zbus::Result<bool>;
            #[zbus(property)]
            fn daemon_version(&self) -> zbus::Result<String>;
        
            #[zbus(signal)]
            fn device_added(&self, device_path: OwnedObjectPath) -> zbus::Result<()>;
            #[zbus(signal)]
            fn device_removed(&self, device_path: OwnedObjectPath) -> zbus::Result<()>;
            // Weitere Signale: LidIsClosed, LidIsOpened, DeviceChanged (oft als PropertiesChanged auf Device-Interface)
        }
        ```
        
    - **`UPowerDeviceProxy` für `org.freedesktop.UPower.Device` (dynamischer Pfad)**:
        
        Rust
        
        ```
        #[proxy(
            interface = "org.freedesktop.UPower.Device",
            default_service = "org.freedesktop.UPower"
            // default_path wird dynamisch gesetzt
        )]
        trait UPowerDevice {
            fn refresh(&self) -> zbus::Result<()>;
            fn get_history(&self, type_: &str, timespan: u32, resolution: u32) -> zbus::Result<Vec<(u32, f64, u32)>>; // Array of (time, value, state)
            fn get_statistics(&self, type_: &str) -> zbus::Result<Vec<(f64, f64)>>; // Array of (value, accuracy)
        
            // Alle Eigenschaften aus PowerDeviceDetails als #[zbus(property)]
            #[zbus(property)] fn native_path(&self) -> zbus::Result<String>;
            #[zbus(property)] fn vendor(&self) -> zbus::Result<String>;
            #[zbus(property)] fn model(&self) -> zbus::Result<String>;
            #[zbus(property)] fn serial(&self) -> zbus::Result<String>;
            // ... alle weiteren Properties aus PowerDeviceDetails ...
            #[zbus(property)] fn state(&self) -> zbus::Result<super::types::PowerState>;
            #[zbus(property)] fn type_(&self) -> zbus::Result<super::types::PowerDeviceType>; // type ist ein Keyword
            #[zbus(property, name = "Type")] // Expliziter Name für D-Bus
            fn device_type_prop(&self) -> zbus::Result<super::types::PowerDeviceType>;
        
        
            // Oft wird `org.freedesktop.DBus.Properties.PropertiesChanged` Signal auf diesem Interface verwendet
        }
        ```
        
    - **Wichtig:** `zbus` erfordert, dass Enums, die direkt als D-Bus-Typen verwendet werden (wie `PowerState`, `PowerDeviceType`), `TryFrom<Value<'a>>` und `Into<Value<'static>>` implementieren, oder `zbus::zvariant::Type` und `serde` für automatische Konvertierung. `#[repr(u32)]` und `Type` sollten hier helfen.

**Datei:** `src/dbus_interfaces/upower_client/service.rs` (oder `client.rs`)

- **Struct `UPowerClientService`**:
    - **Felder:**
        - `connection: Arc<Connection>`
        - `proxy: UPowerProxy<'static>` (Proxy benötigt eine Lebenszeit, oft an die Connection gebunden)
        - `device_proxies: Arc<tokio::sync::Mutex<HashMap<OwnedObjectPath, UPowerDeviceProxy<'static>>>>`
        - `event_publisher: tokio::sync::broadcast::Sender<UPowerEvent>` (aus `system::event_bridge`)
        - `is_initialized: Arc<tokio::sync::watch::Sender<bool>>` (um Signale erst nach Initialisierung zu verarbeiten)
    - **Konstruktor `pub async fn new(event_publisher: tokio::sync::broadcast::Sender<UPowerEvent>) -> Result<Self, DBusInterfaceError>`**:
        1. `connection = DBusConnectionManager::system_bus().await?;`
        2. `proxy = UPowerProxy::new(&connection).await?;`
        3. Initialisiert `device_proxies` als leere Map.
        4. Initialisiert `is_initialized` Sender.
        5. Gibt `Self` zurück.
    - **Methode `pub async fn initialize_and_listen(&self) -> Result<(), DBusInterfaceError>`**:
        1. Ruft `proxy.enumerate_devices().await?` auf, um initiale Geräte zu bekommen.
        2. Für jedes Gerät: `self.add_device_proxy(device_path).await?;`
        3. Abonniert Signale des `UPowerProxy`:
            - `device_added_stream = proxy.receive_device_added().await?;` -> `self.handle_device_added(path).await;`
            - `device_removed_stream = proxy.receive_device_removed().await?;` -> `self.handle_device_removed(path).await;`
            - (Signale für LidIsClosed, LidIsOpened, OnBatteryChanged auf dem UPower-Interface, falls vorhanden, oder über PropertiesChanged)
        4. Abonniert `org.freedesktop.DBus.Properties.PropertiesChanged` auf dem `UPowerProxy` für Änderungen an `LidIsClosed`, `OnBattery`.
            
            Rust
            
            ```
            // let properties_changed_stream = self.proxy.receive_properties_changed().await?;
            // tokio::spawn(handle_property_changes_stream(properties_changed_stream, self.event_publisher.clone()));
            ```
            
        5. Setzt `*self.is_initialized.send(true).is_ok();`.
        6. Startet eine `tokio::task` für jeden Signal-Stream, der die Events verarbeitet.
    - **Private Methode `async fn add_device_proxy(&self, device_path: OwnedObjectPath) -> Result<(), DBusInterfaceError>`**:
        1. `let device_proxy = UPowerDeviceProxy::builder(&self.connection).path(device_path.clone())?.build().await?;`
        2. Abonniert `org.freedesktop.DBus.Properties.PropertiesChanged` auf `device_proxy`.
            
            Rust
            
            ```
            // let device_props_stream = device_proxy.receive_properties_changed().await?;
            // tokio::spawn(handle_device_property_changes_stream(device_path.clone(), device_props_stream, self.event_publisher.clone()));
            ```
            
        3. `self.device_proxies.lock().await.insert(device_path, device_proxy);`
        4. `self.event_publisher.send(UPowerEvent::DeviceAdded(device_path.into_inner().into_string())).ok();`
    - **Private Methode `async fn handle_device_added(&self, device_path: OwnedObjectPath)`**: Ruft `add_device_proxy`.
    - **Private Methode `async fn handle_device_removed(&self, device_path: OwnedObjectPath)`**: Entfernt aus `device_proxies`, sendet `DeviceRemoved` Event.
    - **Öffentliche Methoden zum Abrufen von Daten (Beispiele):**
        - `pub async fn get_all_device_details(&self) -> Result<Vec<PowerDeviceDetails>, DBusInterfaceError>`: Iteriert `device_proxies`, ruft alle Properties jedes Geräts ab und konstruiert `PowerDeviceDetails`.
        - `pub async fn is_lid_closed(&self) -> Result<bool, DBusInterfaceError>`: Ruft `proxy.lid_is_closed().await?`.
        - `pub async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError>`: Ruft `proxy.on_battery().await?`.
- **Signal-Handler-Tasks (Beispiel für `PropertiesChanged` auf UPowerProxy):**
    
    Rust
    
    ```
    // async fn handle_upower_property_changes_stream(
    //     mut stream: zbus::fdo::PropertiesChangedStream<'_>, // Korrekter Stream-Typ
    //     event_publisher: tokio::sync::broadcast::Sender<UPowerEvent>,
    // ) {
    //     while let Some(signal) = stream.next().await {
    //         if let Ok(args) = signal.args() {
    //             if args.interface_name() == "org.freedesktop.UPower" {
    //                 if args.changed_properties().contains_key("LidIsClosed") {
    //                     if let Some(Value::Bool(closed)) = args.changed_properties().get("LidIsClosed") {
    //                         event_publisher.send(UPowerEvent::LidStateChanged(*closed)).ok();
    //                     }
    //                 }
    //                 if args.changed_properties().contains_key("OnBattery") {
    //                    // ... ähnlich ...
    //                    event_publisher.send(UPowerEvent::PowerSupplyChanged).ok(); // Generisches Event
    //                 }
    //             }
    //         }
    //     }
    // }
    ```
    

**Datei:** `src/dbus_interfaces/upower_client/mod.rs`

- `pub mod types;`
- `pub mod proxies;` // Ist oft intern, wenn Service die Fassade ist
- `pub mod service;`
- `pub use service::UPowerClientService;`
- `pub use types::{PowerDeviceDetails, PowerDeviceType, PowerState, UPowerEvent};`

#### 3.3. Implementierungsschritte `system::dbus_interfaces::upower_client`

1. **Grundgerüst**: Verzeichnis, `mod.rs`.
2. **`types.rs`**: `PowerDeviceType`, `PowerState`, `PowerDeviceDetails`, `UPowerEvent` definieren. `serde` und `zbus::zvariant::Type` implementieren.
3. **`proxies.rs`**: `UPowerProxy` und `UPowerDeviceProxy` mit `#[zbus::proxy]` definieren. Alle relevanten Methoden und Properties aus der UPower-Spezifikation aufnehmen.
4. **`service.rs`**: `UPowerClientService`-Struktur definieren.
    - `new()`-Konstruktor: D-Bus-Verbindung herstellen, Hauptproxy erstellen.
    - `initialize_and_listen()`: Initiale Geräte laden, Signal-Handler für `DeviceAdded`/`Removed` und `PropertiesChanged` (sowohl auf Hauptproxy als auch auf Geräteproxies) einrichten. Diese Handler laufen in eigenen `tokio::spawn`-Tasks.
    - `add_device_proxy()`: Erstellt, speichert und abonniert Signale für einen Geräteproxy.
    - Öffentliche Getter-Methoden (`get_all_device_details`, `is_lid_closed`, etc.) implementieren, die Properties von den Proxies abrufen.
5. **Event-Publishing**: Sicherstellen, dass bei relevanten Signalempfängen oder Zustandsänderungen die definierten `UPowerEvent`s über den `event_publisher` gesendet werden.
6. **Fehlerbehandlung**: Alle `zbus::Error`-Fälle in `DBusInterfaceError` umwandeln und propagieren.
7. **Unit-/Integrationstests**:
    - **Schwierig ohne laufenden D-Bus-Dienst.** Man könnte `zbus::MockConnection` verwenden, um D-Bus-Interaktionen zu mocken.
    - Testen der Proxy-Generierung.
    - Testen der Property-Abfrage-Logik gegen einen gemockten Dienst.
    - Testen der Signal-Verarbeitung (indem man Signale im Mock simuliert).
    - Testen der korrekten Event-Erzeugung.

---

**Nächste Schritte für `system::dbus_interfaces` (Skizze für weitere Dienste):**

- **`logind_client`**:
    - **Zweck:** Interaktion mit `org.freedesktop.login1` für Sitzungsmanagement (Sperren, Suspend, Shutdown-Signale).
    - **Proxies:** `LogindManagerProxy` (`/org/freedesktop/login1`), `LogindSessionProxy` (`/org/freedesktop/login1/session/self`).
    - **Signale:** `PrepareForShutdown`, `PrepareForSleep`, `Lock`, `Unlock` auf Session-Objekt.
    - **Events:** `LogindEvent::PrepareForShutdown(bool is_reboot)`, `LogindEvent::PrepareForSleep(bool is_suspending)`, `LogindEvent::SessionLocked`, `LogindEvent::SessionUnlocked`.
    - **Methoden:** `LockSession()`, `UnlockSession()`, `CanSuspend()`, `Suspend(bool interactive)`, etc. an Domäne weiterleiten oder von dort empfangen.
- **`network_manager_client`**:
    - **Zweck:** Abfrage von Netzwerkstatus, verfügbaren Verbindungen, Signalstärke (WLAN), IP-Adressen.
    - **Proxies:** `NetworkManagerProxy`, `NMDeviceProxy`, `NMActiveConnectionProxy`, `NMAccessPointProxy`, etc.
    - **Signale:** `StateChanged`, `DeviceAdded/Removed`, `PropertiesChanged` auf verschiedenen Objekten.
    - **Events:** `NetworkEvent::ConnectivityChanged(ConnectivityState)`, `NetworkEvent::WifiDeviceAdded/Removed`, `NetworkEvent::WiredDeviceAdded/Removed`, `NetworkEvent::ActiveConnectionChanged { ... }`.
    - **Typen:** `ConnectivityState` (Disconnected, Connecting, Limited, Full), `NetworkDeviceDetails`, `ActiveConnectionDetails`.
- **`notifications_server`**:
    - **Zweck:** Implementierung des `org.freedesktop.Notifications` D-Bus-Servers.
    - **Technologie:** `zbus` Server-Fähigkeiten (`#[dbus_interface(...)]` auf einem Struct).
    - **Methoden (D-Bus):** `Notify`, `CloseNotification`, `GetCapabilities`, `GetServerInformation`.
    - **Interaktion:** Leitet `Notify`-Aufrufe an `domain::user_centric_services::NotificationService::post_notification` weiter.
    - **Signale (D-Bus):** `NotificationClosed`, `ActionInvoked`. Reagiert auf `NotificationDismissedEvent` und `NotificationActionInvokedEvent` aus der Domäne, um diese D-Bus-Signale zu senden.
- **`secrets_service_client`**:
    - **Zweck:** Client für `org.freedesktop.secrets` zum sicheren Speichern und Abrufen von Geheimnissen (z.B. API-Keys für `mcp_client`).
    - **Proxies:** `SecretServiceProxy`, `SecretCollectionProxy`, `SecretItemProxy`.
    - **Methoden:** `CreateCollection`, `CreateItem`, `GetSecret`, `SearchItems`, `Unlock`.
    - **Interaktion:** Wird von anderen Systemmodulen (z.B. `mcp_client`) oder ggf. Domänendiensten genutzt. UI-Interaktion für Prompts (Unlock) wird oft vom Secret Service selbst gehandhabt (z.B. GNOME Keyring).
- **`policykit_client`**:
    - **Zweck:** Client für `org.freedesktop.PolicyKit1.Authority` zur Autorisierung privilegierter Aktionen.
    - **Proxy:** `PolicyKitAuthorityProxy`.
    - **Methode:** `CheckAuthorization`.
    - **Interaktion:** Wird von System- oder Domänenmodulen aufgerufen, bevor eine privilegierte Aktion ausgeführt wird. UI-Interaktion für Passwortabfragen wird vom PolicyKit-Agenten des Systems gehandhabt.
- **`xdg_desktop_portal_handler`**:
    - **Zweck:** Dies ist kein Client, sondern die Backend-Logik, die von den XDG Desktop Portal D-Bus-Server-Implementierungen (die NovaDE bereitstellt) aufgerufen wird.
    - **Schnittstellen:** Definiert Traits oder konkrete Methoden, die von den Portal-D-Bus-Objekten aufgerufen werden.
    - **Beispiele:**
        - Für `org.freedesktop.portal.FileChooser`: `async fn open_file_dialog(...) -> Result<Vec<PathBuf>, PortalError>`. Interagiert mit der UI-Schicht, um den Dialog anzuzeigen.
        - Für `org.freedesktop.portal.Screenshot`: `async fn take_screenshot(interactive: bool, region: Option<RectInt>) -> Result<PathBuf, PortalError>`. Interagiert mit `system::compositor::screencopy`.
        - Für `org.freedesktop.portal.ScreenCast`: Interagiert mit Compositor und PipeWire.
    - **Wichtig:** Die eigentlichen D-Bus-Server-Objekte für die Portale werden typischerweise in einem separaten Prozess oder zumindest einem dedizierten D-Bus-Dienst innerhalb von NovaDE laufen. Dieses Modul hier liefert die Logik, die diese D-Bus-Methoden ausführt.

Diese detaillierte Ausarbeitung für `system::dbus_interfaces::upower_client` und die Skizzen für die weiteren Dienste legen einen klaren Pfad für die Implementierung der D-Bus-Interaktionen fest. Jedes Client-Modul erfordert sorgfältige Definition der Proxy-Interfaces und die Übersetzung der D-Bus-spezifischen Daten und Signale in die internen Strukturen und Events von NovaDE.

---

### Modul 3: `system::dbus_interfaces` (Fortsetzung)

#### 3.4. Submodul: `system::dbus_interfaces::logind_client`

Zweck: Client für den org.freedesktop.login1 Dienst zur Abfrage und Steuerung von Sitzungsinformationen und Systemzuständen (Suspend, Shutdown).

Interaktion mit Domäne: Sendet LogindEvents an die Domänenschicht (z.B. domain::power_management_policy, domain::common_events). Empfängt Befehle (z.B. LockSession) von der Domäne oder UI über die Domäne.

**Datei:** `src/dbus_interfaces/logind_client/types.rs`

- **Event-Struktur (für `system::event_bridge` oder direkt an Domänen-Services):**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use crate::dbus_interfaces::common::DBusObjectPath; // Typalias für String oder OwnedObjectPath
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub enum LogindPowerOperation {
        Suspend,
        Hibernate,
        HybridSleep,
        SuspendThenHibernate,
        Reboot,
        PowerOff,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum LogindEvent {
        PrepareForShutdown(bool /* is_reboot */),
        PrepareForSleep(bool /* is_suspending_to_ram_not_disk */), // true für Suspend, false für Hibernate
        SessionLocked(DBusObjectPath /* session_id */),
        SessionUnlocked(DBusObjectPath /* session_id */),
        SessionRemoved(DBusObjectPath /* session_id */),
        SystemIdleHintChanged(bool /* is_idle */), // Falls logind IdleHint sendet
    }
    
    #[derive(Debug, Clone, Type, Serialize, Deserialize, PartialEq)] // zbus::zvariant::Type
    pub struct SessionDetails {
        pub id: String, // Session ID
        pub user_id: u32,
        pub user_name: String,
        pub seat_id: String,
        pub seat_path: DBusObjectPath,
        pub vtnr: u32,
        pub display: String, // z.B. ":0"
        pub remote: bool,
        pub remote_host: String,
        pub remote_user: String,
        pub service: String, // z.B. "gdm-password", "tty"
        pub desktop: String, // z.B. "NovaDE"
        pub scope: String, // z.B. "system-user"
        pub leader_pid: u32,
        pub audit_session_id: u32,
        pub session_class: String, // z.B. "user"
        pub session_type: String, // z.B. "wayland", "x11"
        pub active: bool,
        pub state: String, // z.B. "active", "online", "closing"
        pub idle_hint: bool,
        pub idle_since_hint_usec: u64, // Mikrosekunden
        pub locked_hint: bool,
    }
    ```
    

**Datei:** `src/dbus_interfaces/logind_client/proxies.rs`

- **`LogindManagerProxy` für `org.freedesktop.login1.Manager` auf `/org/freedesktop/login1`**:
    
    Rust
    
    ```
    use zbus::{proxy, zvariant::{OwnedObjectPath, Type, Value, Dict}};
    use super::types::SessionDetails;
    
    #[proxy(
        interface = "org.freedesktop.login1.Manager",
        default_service = "org.freedesktop.login1",
        default_path = "/org/freedesktop/login1"
    )]
    trait LogindManager {
        fn get_session(&self, session_id: &str) -> zbus::Result<OwnedObjectPath>;
        fn get_session_by_pid(&self, pid: u32) -> zbus::Result<OwnedObjectPath>;
        fn get_user(&self, uid: u32) -> zbus::Result<OwnedObjectPath>;
        fn get_user_by_pid(&self, pid: u32) -> zbus::Result<OwnedObjectPath>;
        fn get_seat(&self, seat_id: &str) -> zbus::Result<OwnedObjectPath>;
        fn list_sessions(&self) -> zbus::Result<Vec<(String, u32, String, String, OwnedObjectPath)>>; // (id, uid, user, seat, path)
        fn list_users(&self) -> zbus::Result<Vec<(u32, String, OwnedObjectPath)>>; // (uid, name, path)
        fn list_seats(&self) -> zbus::Result<Vec<(String, OwnedObjectPath)>>; // (id, path)
    
        fn inhibit(&self, what: &str, who: &str, why: &str, mode: &str) -> zbus::Result<zbus::zvariant::Fd>; // Returns FD for inhibitor lock
        fn can_power_off(&self) -> zbus::Result<String>; // "yes", "no", "challenge"
        fn can_reboot(&self) -> zbus::Result<String>;
        fn can_suspend(&self) -> zbus::Result<String>;
        fn can_hibernate(&self) -> zbus::Result<String>;
        fn can_hybrid_sleep(&self) -> zbus::Result<String>;
        fn can_suspend_then_hibernate(&self) -> zbus::Result<String>;
    
        fn power_off(&self, interactive: bool) -> zbus::Result<()>;
        fn reboot(&self, interactive: bool) -> zbus::Result<()>;
        fn suspend(&self, interactive: bool) -> zbus::Result<()>;
        fn hibernate(&self, interactive: bool) -> zbus::Result<()>;
        fn hybrid_sleep(&self, interactive: bool) -> zbus::Result<()>;
        fn suspend_then_hibernate(&self, interactive: bool) -> zbus::Result<()>;
        // TerminateSeat, TerminateSession, TerminateUser...
    
        #[zbus(signal)]
        fn session_new(&self, session_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn session_removed(&self, session_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn seat_new(&self, seat_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn seat_removed(&self, seat_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn prepare_for_shutdown(&self, start: bool) -> zbus::Result<()>; // true = about to shut down, false = cancelled
        #[zbus(signal)]
        fn prepare_for_sleep(&self, start: bool) -> zbus::Result<()>;   // true = about to suspend/hibernate, false = cancelled
    }
    ```
    
- **`LogindSessionProxy` für `org.freedesktop.login1.Session` (dynamischer Pfad)**:
    
    Rust
    
    ```
    #[proxy(
        interface = "org.freedesktop.login1.Session",
        default_service = "org.freedesktop.login1"
    )]
    trait LogindSession {
        fn terminate(&self) -> zbus::Result<()>;
        fn activate(&self) -> zbus::Result<()>;
        fn lock(&self) -> zbus::Result<()>;
        fn unlock(&self) -> zbus::Result<()>;
        fn set_idle_hint(&self, idle: bool) -> zbus::Result<()>;
        fn set_locked_hint(&self, locked: bool) -> zbus::Result<()>;
        // Kill(who: &str, signal_number: i32)
        // TakeControl(force: bool)
        // ReleaseControl()
        // TakeDevice(major: u32, minor: u32) -> zbus::Result<(zbus::zvariant::Fd, bool)>
        // ReleaseDevice(major: u32, minor: u32)
        // PauseDeviceComplete(major: u32, minor: u32)
        // SetBrightness(subsystem: &str, name: &str, value: u32)
    
        // Properties (viele, können über Properties.GetAll abgerufen werden)
        #[zbus(property)] fn id(&self) -> zbus::Result<String>;
        #[zbus(property)] fn user(&self) -> zbus::Result<(u32, OwnedObjectPath)>; // (uid, user_path)
        #[zbus(property)] fn name(&self) -> zbus::Result<String>; // Username
        #[zbus(property)] fn timestamp(&self) -> zbus::Result<u64>; // usec
        #[zbus(property)] fn timestamp_monotonic(&self) -> zbus::Result<u64>; // usec
        #[zbus(property)] fn vtnr(&self) -> zbus::Result<u32>;
        #[zbus(property)] fn seat(&self) -> zbus::Result<(String, OwnedObjectPath)>; // (seat_id, seat_path)
        #[zbus(property)] fn display(&self) -> zbus::Result<String>;
        #[zbus(property)] fn remote(&self) -> zbus::Result<bool>;
        #[zbus(property)] fn remote_host(&self) -> zbus::Result<String>;
        #[zbus(property)] fn remote_user(&self) -> zbus::Result<String>;
        #[zbus(property)] fn service(&self) -> zbus::Result<String>;
        #[zbus(property)] fn desktop(&self) -> zbus::Result<String>;
        #[zbus(property)] fn scope(&self) -> zbus::Result<String>;
        #[zbus(property)] fn leader(&self) -> zbus::Result<u32>; // PID
        #[zbus(property)] fn audit(&self) -> zbus::Result<u32>; // Audit Session ID
        #[zbus(property, name = "Class")] fn class_prop(&self) -> zbus::Result<String>; // "user", "greeter", ...
        #[zbus(property, name = "Type")] fn type_prop(&self) -> zbus::Result<String>;   // "x11", "wayland", "tty"
        #[zbus(property)] fn active(&self) -> zbus::Result<bool>;
        #[zbus(property)] fn state(&self) -> zbus::Result<String>;
        #[zbus(property)] fn idle_hint(&self) -> zbus::Result<bool>;
        #[zbus(property)] fn idle_since_hint(&self) -> zbus::Result<u64>; // usec
        #[zbus(property)] fn locked_hint(&self) -> zbus::Result<bool>;
    
        #[zbus(signal)]
        fn pause_device(&self, major: u32, minor: u32, type_: &str) -> zbus::Result<()>; // type: "pause", "force-pause", "timeout-pause"
        #[zbus(signal)]
        fn resume_device(&self, major: u32, minor: u32, fd_idx: zbus::zvariant::Fd, type_: &str) -> zbus::Result<()>; // type: "resume"
        #[zbus(signal)]
        fn lock(&self) -> zbus::Result<()>; // Sitzung wurde gesperrt
        #[zbus(signal)]
        fn unlock(&self) -> zbus::Result<()>; // Sitzung wurde entsperrt
    }
    ```
    

**Datei:** `src/dbus_interfaces/logind_client/service.rs`

- **Struct `LogindClientService`**:
    - **Felder:** `connection: Arc<Connection>`, `manager_proxy: LogindManagerProxy<'static>`, `session_proxies: Arc<tokio::sync::Mutex<HashMap<String /*session_id*/, LogindSessionProxy<'static>>>>`, `event_publisher: tokio::sync::broadcast::Sender<LogindEvent>`.
    - **Konstruktor `new(...)`**: Stellt Verbindung her, erstellt `manager_proxy`.
    - **Methode `initialize_and_listen()`**:
        1. `list_sessions()` vom `manager_proxy` abrufen, um initiale Sessions zu cachen und ggf. Proxies zu erstellen.
        2. `LogindManagerProxy`-Signale abonnieren (`SessionNew`, `SessionRemoved`, `PrepareForShutdown`, `PrepareForSleep`).
            - `SessionNew`: Erstelle `LogindSessionProxy`, speichere in `session_proxies`, abonniere dessen `Lock`/`Unlock`-Signale.
            - `SessionRemoved`: Entferne Proxy.
            - `PrepareForShutdown/Sleep`: Sende `LogindEvent` an `event_publisher`.
        3. `LogindSessionProxy`-Signale (`Lock`, `Unlock`) für jede aktive Session abonnieren und entsprechende `LogindEvent`s senden.
    - **Öffentliche Methoden (Beispiele):**
        - `pub async fn get_current_session_details(&self) -> Result<Option<SessionDetails>, DBusInterfaceError>`: Ruft `GetSessionByPid(std::process::id())` auf, dann alle Properties vom Session-Proxy.
        - `pub async fn lock_current_session(&self) -> Result<(), DBusInterfaceError>`: Ruft `Lock()` auf dem aktuellen Session-Proxy auf.
        - `pub async fn can_power_off(&self) -> Result<String, DBusInterfaceError>`: Ruft `manager_proxy.can_power_off()`.
        - `pub async fn power_off(&self, interactive: bool) -> Result<(), DBusInterfaceError>`: Ruft `manager_proxy.power_off(interactive)`. (Benötigt PolicyKit-Autorisierung, die von logind gehandhabt wird).

**Implementierungsschritte `logind_client`**:

1. `types.rs`: `LogindEvent`, `SessionDetails`, `LogindPowerOperation` definieren.
2. `proxies.rs`: `LogindManagerProxy` und `LogindSessionProxy` definieren.
3. `service.rs`: `LogindClientService` implementieren (Konstruktor, Initialisierung/Signal-Listener, öffentliche Methoden).
4. Tests mit gemockter D-Bus-Verbindung.

---

#### 3.5. Submodul: `system::dbus_interfaces::network_manager_client`

Zweck: Client für org.freedesktop.NetworkManager.

Interaktion: Sendet NetworkManagerEvents.

(Struktur analog zu upower_client und logind_client)

- **`types.rs`**: Enums (`NMState`, `NMDeviceType`, `NMConnectivityState`), Structs (`NetworkDeviceDetails`, `AccessPointDetails`, `ActiveConnectionDetails`), Event (`NetworkManagerEvent`).
- **`proxies.rs`**: `NetworkManagerProxy`, `NMDeviceProxy`, `NMActiveConnectionProxy`, `NMAccessPointProxy`, `NMSettingsConnectionProxy` etc.
- **`service.rs`**: `NetworkManagerClientService` mit Logik zum Auflisten von Geräten, Verbindungen, APs; Abonnieren von `StateChanged`, `DeviceAdded/Removed`, `PropertiesChanged` etc.

---

#### 3.6. Submodul: `system::dbus_interfaces::secrets_service_client`

Zweck: Client für org.freedesktop.Secret.Service.

Interaktion: Stellt Methoden zum Speichern/Abrufen von Geheimnissen bereit, die von anderen Systemmodulen (z.B. mcp_client) genutzt werden.

(Struktur analog zu upower_client)

- **`types.rs`**: Structs (`Secret`, `SecretItemAttributes`).
- **`proxies.rs`**: `SecretServiceProxy`, `SessionProxy` (für D-Bus-Session der Secret Service API), `CollectionProxy`, `ItemProxy`, `PromptProxy`.
- **`service.rs`**: `SecretsServiceClientService` mit Methoden wie `async fn store_secret(collection_alias: &str, label: &str, secret_content: &[u8], attributes: HashMap<String, String>, replace: bool) -> Result<DBusObjectPath, DBusInterfaceError>`, `async fn retrieve_secret(item_path: &DBusObjectPath) -> Result<Vec<u8>, DBusInterfaceError>`, `async fn search_items(attributes: HashMap<String, String>) -> Result<Vec<DBusObjectPath>, DBusInterfaceError>`. Handhabt Unlock-Prompts (oft delegiert an den Secret Service Agenten).

---

#### 3.7. Submodul: `system::dbus_interfaces::policykit_client`

Zweck: Client für org.freedesktop.PolicyKit1.Authority.

Interaktion: Stellt eine Methode zur Autorisierungsprüfung bereit.

(Struktur analog, aber einfacher, da meist nur eine Hauptmethode)

- **`types.rs`**: Enum `PolicyKitAuthorizationResult` (allow, challenge, deny). Structs für `Subject` (pid, uid), `ActionId`.
- **`proxies.rs`**: `PolicyKitAuthorityProxy`.
- **`service.rs`**: `PolicyKitClientService` mit Methode `async fn check_authorization(action_id: &str, subject_pid: Option<u32>, details: HashMap<String, String>, flags: u32 /* PolicyKitCheckAuthorizationFlags */) -> Result<PolicyKitAuthorizationResult, DBusInterfaceError>`.

---

#### 3.8. Submodul: `system::dbus_interfaces::notifications_server`

Zweck: Implementierung des org.freedesktop.Notifications D-Bus-Servers.

Interaktion: Empfängt Notify-Aufrufe und leitet sie an domain::user_centric_services::NotificationService weiter. Sendet NotificationClosed und ActionInvoked Signale basierend auf Events aus der Domänenschicht.

**Datei:** `src/dbus_interfaces/notifications_server/mod.rs` (kann `interface.rs`, `service_object.rs` enthalten)

- **Struct `FreedesktopNotificationsServer`** (Das D-Bus-Objekt):
    
    Rust
    
    ```
    use zbus::dbus_interface;
    use crate::domain::user_centric_services::{NotificationService, Notification, NotificationUrgency as DomainUrgency, NotificationAction as DomainAction}; // Domain Traits/Typen
    use crate::domain::user_centric_services::notifications_core::types::NotificationInput; // Für Notify
    use crate::domain::shared_types::ApplicationId;
    use std::sync::Arc;
    use tokio::sync::Mutex; // Für NotificationService Handle
    use zbus::zvariant::{Value, Dict, Array};
    use zbus::SignalContext;
    use super::common::DBusInterfaceError; // Eigener Fehlertyp
    
    pub struct FreedesktopNotificationsServer {
        notification_service: Arc<Mutex<dyn NotificationService>>, // Injizierter Domain-Service
        // Ggf. ein tokio::sync::broadcast::Receiver für Domain-Events (NotificationDismissedEvent etc.)
        // um D-Bus Signale zu senden.
    }
    
    impl FreedesktopNotificationsServer {
        pub fn new(notification_service: Arc<Mutex<dyn NotificationService>>) -> Self {
            Self { notification_service }
            // Hier den Event-Receiver von notification_service abonnieren und Task starten,
            // der Domain-Events in D-Bus-Signale umwandelt.
        }
    
        // Hilfsmethode zur Konvertierung von D-Bus Urgency zu Domain Urgency
        fn to_domain_urgency(level: u8) -> DomainUrgency {
            match level {
                0 => DomainUrgency::Low,
                1 => DomainUrgency::Normal,
                2 => DomainUrgency::Critical,
                _ => DomainUrgency::Normal, // Fallback
            }
        }
    }
    
    #[dbus_interface(name = "org.freedesktop.Notifications")]
    impl FreedesktopNotificationsServer {
        async fn get_capabilities(&self) -> Vec<String> {
            // Fähigkeiten, die NovaDE unterstützt, z.B. "body", "actions", "persistence", "icon-static"
            vec![
                "body".to_string(),
                "actions".to_string(),
                "persistence".to_string(), // Wenn Benachrichtigungen gespeichert werden
                "icon-static".to_string(),
                "body-markup".to_string(), // Wenn Pango-Markup im Body unterstützt wird
                // "sound"
            ]
        }
    
        async fn notify(
            &self,
            app_name: String,
            replaces_id: u32, // ID der zu ersetzenden Benachrichtigung (0 für neue)
            app_icon: String,  // Icon-Name oder Pfad
            summary: String,
            body: String,
            actions: Vec<String>, // Actions als flache Liste: [key1, label1, key2, label2, ...]
            hints: Dict<'_, String, Value<'_>>, // zbus Dict für a{sv}
            expire_timeout: i32, // Millisekunden, -1 für Default, 0 für persistent (laut Spezifikation)
        ) -> Result<u32, zbus::fdo::Error> { // Gibt die neue Notification ID zurück
            tracing::info!("D-Bus Notify: app='{}', summary='{}'", app_name, summary);
    
            let mut domain_actions = Vec::new();
            for chunk in actions.chunks_exact(2) {
                domain_actions.push(DomainAction {
                    key: chunk[0].clone(),
                    label: chunk[1].clone(),
                    // action_type wird hier nicht direkt übergeben, müsste ggf. aus Hints oder Konvention abgeleitet werden
                    // oder Aktionen sind immer "Callback" für D-Bus.
                    action_type: crate::domain::user_centric_services::notifications_core::types::NotificationActionType::Callback,
                });
            }
    
            let urgency_hint = hints.get("urgency")
                .and_then(|v| v.downcast_ref::<Value<'_>>()) // Value in Value ist seltsam, eher direkt u8 oder byte
                .and_then(|v_inner| v_inner.try_into().ok()) // u8
                .map(Self::to_domain_urgency)
                .unwrap_or(DomainUrgency::Normal);
    
            let category_hint = hints.get("category")
                                .and_then(|v| v.downcast_ref::<String>())
                                .cloned();
    
            // TODO: 'replaces_id' Logik implementieren (alte Notification mit dieser ID entfernen/aktualisieren)
            // TODO: 'app_icon' und 'hints' genauer verarbeiten (image-data, sound etc.)
    
            let notification_input = NotificationInput {
                application_name: app_name, // Optional: ApplicationId::new(app_name)
                application_icon: if app_icon.is_empty() { None } else { Some(app_icon) },
                summary,
                body: if body.is_empty() { None } else { Some(body) },
                actions: domain_actions,
                urgency: urgency_hint,
                transient: hints.get("transient").and_then(|v| v.try_into().ok()).unwrap_or(false),
                category: category_hint,
                hints: hints.iter().map(|(k,v)| (k.to_string(), serde_json::to_value(v).unwrap_or(serde_json::Value::Null))).collect(), // Konvertiere zbus::Value zu serde_json::Value
                timeout_ms: if expire_timeout == 0 { Some(0) } // 0 für persistent laut D-Bus
                             else if expire_timeout > 0 { Some(expire_timeout as u32) }
                             else { None }, // -1 für Default
            };
    
            let mut service_guard = self.notification_service.lock().await;
            match service_guard.post_notification(notification_input).await {
                // Die zurückgegebene u32 ID muss für D-Bus eindeutig sein.
                // Der Domain-Service verwendet Uuid. Hier muss eine Abbildung erfolgen,
                // z.B. eine laufende u32-ID, die der Uuid zugeordnet wird.
                // Für Einfachheit hier: Hash der Uuid (nicht ideal, da Kollisionen möglich)
                // Besser: Map<Uuid, u32> im Server halten.
                Ok(domain_id) => {
                    let dbus_id =贫穷的男子哈希(domain_id); // Vereinfacht
                    Ok(dbus_id)
                }
                Err(e) => {
                    tracing::error!("Fehler beim Posten der Benachrichtigung an den Domain-Service: {:?}", e);
                    Err(zbus::fdo::Error::Failed(format!("Interner Fehler beim Verarbeiten der Benachrichtigung: {}", e)))
                }
            }
        }
    
        async fn close_notification(&self, id: u32) -> zbus::fdo::Result<()> {
            tracing::info!("D-Bus CloseNotification für ID: {}", id);
            // TODO: ID von u32 (D-Bus) zu Uuid (Domain) mappen
            // let domain_id = map_dbus_id_to_domain_id(id);
            // let mut service_guard = self.notification_service.lock().await;
            // match service_guard.dismiss_notification(domain_id).await {
            //     Ok(_) => Ok(()),
            //     Err(domain::user_centric_services::NotificationError::NotFound(_)) => {
            //         // Gemäß Spezifikation kein Fehler, wenn ID unbekannt ist
            //         Ok(())
            //     }
            //     Err(e) => Err(zbus::fdo::Error::Failed(format!("Fehler beim Schließen: {}", e))),
            // }
            Ok(()) // Platzhalter
        }
    
        async fn get_server_information(&self) -> (String, String, String, String) {
            (
                "NovaDE Notification Server".to_string(), // name
                "NovaDE Team".to_string(),                // vendor
                "0.1.0".to_string(),                      // version
                "1.2".to_string(),                        // spec_version
            )
        }
    
        #[dbus_interface(signal)]
        async fn notification_closed(ctxt: &SignalContext<'_>, id: u32, reason: u32) -> zbus::Result<()>;
        // reason: 1=expired, 2=dismissed by user, 3=closed by call to CloseNotification, 4=undefined
    
        #[dbus_interface(signal)]
        async fn action_invoked(ctxt: &SignalContext<'_>, id: u32, action_key: String) -> zbus::Result<()>;
    }
    ```
    
- **Logik zur Signal-Weiterleitung:**
    - Der `FreedesktopNotificationsServer` muss `NotificationDismissedEvent` und `NotificationActionInvokedEvent` vom `NotificationService` abonnieren.
    - Wenn ein `NotificationDismissedEvent { notification_id, reason }` empfangen wird:
        - `dbus_id = map_domain_id_to_dbus_id(notification_id);`
        - `dbus_reason = match reason { DismissReason::User => 2, DismissReason::Timeout => 1, ... };`
        - `FreedesktopNotificationsServer::notification_closed(ctxt, dbus_id, dbus_reason).await;` (Benötigt `SignalContext`).
    - Wenn ein `NotificationActionInvokedEvent { notification_id, action_key }` empfangen wird:
        - `dbus_id = map_domain_id_to_dbus_id(notification_id);`
        - `FreedesktopNotificationsServer::action_invoked(ctxt, dbus_id, action_key).await;`

#### 3.9. Implementierungsschritte `system::dbus_interfaces` (Fortsetzung)

5. **`logind_client` implementieren**: Typen, Proxies, Service. Signal-Handler für `PrepareForShutdown/Sleep`, `SessionNew/Removed`, `Lock/Unlock`. Tests.
6. **`network_manager_client` implementieren**: Typen, Proxies, Service. Signal-Handler für relevante NM-Signale. Tests.
7. **`secrets_service_client` implementieren**: Typen, Proxies, Service. Methoden für Speichern/Abrufen. Tests.
8. **`policykit_client` implementieren**: Typen, Proxy, Service. `check_authorization`-Methode. Tests.
9. **`notifications_server` implementieren**:
    - D-Bus-Interface-Struct `FreedesktopNotificationsServer`.
    - Implementierung der Methoden (`Notify`, `CloseNotification`, etc.), die den `domain::NotificationService` aufrufen.
    - ID-Mapping zwischen D-Bus `u32` und Domain `Uuid` implementieren (z.B. `HashMap<u32, Uuid>` und `HashMap<Uuid, u32>`).
    - Task starten, der Domain-Events (`NotificationDismissedEvent`, `NotificationActionInvokedEvent`) abonniert und entsprechende D-Bus-Signale (`notification_closed`, `action_invoked`) über den `SignalContext` sendet.
    - Registrierung des D-Bus-Objekts auf dem Session-Bus.
10. **`xdg_desktop_portal_handler`** (wird später detailliert, da es von UI-Dialogen und Compositor-Funktionen abhängt).

---

### Modul 4: `system::audio_management`

Zweck: Integration mit PipeWire zur Steuerung der Systemlautstärke, Auswahl von Audio-Geräten und Verwaltung von Anwendungs-Streams.

Verantwortlichkeiten: Aufbau und Verwaltung der PipeWire-Verbindung, Auflisten von Audio-Geräten (Sinks, Sources) und Streams, Setzen/Abfragen von Lautstärke und Mute-Status, Auswahl von Standardgeräten.

Design-Rationale: PipeWire als moderner Standard für Audio unter Linux. Kapselung der PipeWire-spezifischen Logik. Bereitstellung einer abstrahierten Schnittstelle für die Domänen- und UI-Schicht.

Technologie: pipewire-rs Crate.

#### 4.1. Submodul: `system::audio_management::types`

**Datei:** `src/audio_management/types.rs`

- **Enum `AudioDeviceType`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum AudioDeviceType {
        Sink,    // Wiedergabegerät (z.B. Lautsprecher, Kopfhörer)
        Source,  // Aufnahmegerät (z.B. Mikrofon)
        Other,
    }
    ```
    
- **Struct `AudioDevice`**:
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use uuid::Uuid; // Interne ID für das Domänenobjekt
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct AudioDevice {
        pub internal_id: Uuid, // Eigene ID, da PipeWire IDs u32 sind und sich ändern können
        pub pipewire_id: u32,  // Die aktuelle PipeWire Node ID
        pub name: String,      // z.B. "alsa_output.pci-0000_00_1f.3.analog-stereo"
        pub description: String, // Menschenlesbar, z.B. "Built-in Audio Analog Stereo"
        pub device_type: AudioDeviceType,
        pub volume_percent: u8, // 0-100 (oder höher, falls >100% unterstützt)
        pub is_muted: bool,
        pub is_default: bool,   // Ob es das Standardgerät seines Typs ist
        // Optional: channel_map, sample_format, etc.
    }
    ```
    
- **Struct `AudioStream`** (repräsentiert einen Anwendungs-Audiostream):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct AudioStream {
        pub internal_id: Uuid,
        pub pipewire_id: u32, // PipeWire Client/Stream ID
        pub application_name: Option<String>, // Name der Anwendung, die den Stream erzeugt
        pub media_role: Option<String>, // z.B. "Music", "Video", "Game", "Notification"
        pub volume_percent: u8,
        pub is_muted: bool,
        pub target_device_pw_id: Option<u32>, // PipeWire ID des Geräts, mit dem der Stream verbunden ist
    }
    ```
    
- **Event-Struktur (für `system::event_bridge` oder direkt an Domäne):**
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AudioEvent {
        DeviceListChanged(Vec<AudioDevice>),
        DefaultDeviceChanged { device_type: AudioDeviceType, new_default_pw_id: Option<u32> },
        DeviceVolumeChanged { device_pw_id: u32, new_volume_percent: u8, is_muted: bool },
        StreamListChanged(Vec<AudioStream>),
        StreamVolumeChanged { stream_pw_id: u32, new_volume_percent: u8, is_muted: bool },
        ServerConnectionStateChanged(bool /* is_connected */),
    }
    ```
    

#### 4.2. Submodul: `system::audio_management::errors`

**Datei:** `src/audio_management/errors.rs`

- **Enum `AudioManagementError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    
    #[derive(Debug, Error)]
    pub enum AudioManagementError {
        #[error("PipeWire connection failed: {0}")]
        ConnectionFailed(String),
        #[error("PipeWire context error: {0}")]
        ContextError(String),
        #[error("PipeWire main loop error: {0}")]
        MainLoopError(String),
        #[error("PipeWire core error: {0}")]
        CoreError(String), // Generischer Fehler von pipewire-rs
        #[error("Failed to create PipeWire proxy or object: {0}")]
        ProxyCreationFailed(String),
        #[error("PipeWire object not found (ID: {0})")]
        ObjectNotFound(u32),
        #[error("Invalid parameter for PipeWire operation: {0}")]
        InvalidParameter(String),
        #[error("Operation timed out: {0}")]
        Timeout(String),
        #[error("Type conversion error in PipeWire data: {0}")]
        TypeConversionError(String),
        #[error("Audio device or stream is in an unexpected state: {0}")]
        InvalidState(String),
        #[error("An internal error occurred in audio management: {0}")]
        InternalError(String),
    }
    // Hilfsimplementierungen, um Fehler von pipewire-rs zu wrappen
    impl From<pipewire::Error> for AudioManagementError {
        fn from(err: pipewire::Error) -> Self {
            AudioManagementError::CoreError(err.to_string())
        }
    }
    ```
    

#### 4.3. Submodul: `system::audio_management::client`

**Zweck:** Kernlogik für die PipeWire-Verbindung, Event-Loop-Integration und Objektverwaltung.

**Datei:** `src/audio_management/client/mod.rs` (oder `service.rs`)

- **Struct `PipeWireClientService`**:
    - **Felder:**
        - `main_loop: Arc<pipewire::MainLoop>` (muss in eigenem Thread laufen oder in `calloop` integriert werden)
        - `context: Arc<pipewire::Context>`
        - `core: Arc<pipewire::Core>`
        - `registry: Arc<pipewire::Registry>`
        - `devices: Arc<tokio::sync::RwLock<HashMap<u32 /*pw_id*/, AudioDevice>>>`
        - `streams: Arc<tokio::sync::RwLock<HashMap<u32 /*pw_id*/, AudioStream>>>`
        - `default_sink_id: Arc<tokio::sync::RwLock<Option<u32>>>`
        - `default_source_id: Arc<tokio::sync::RwLock<Option<u32>>>`
        - `event_publisher: tokio::sync::broadcast::Sender<AudioEvent>`
        - `registry_listener: Option<pipewire::registry::Listener>` (muss `'static` sein oder anders verwaltet werden)
        - `core_listener: Option<pipewire::core::CoreListener>`
        - `loop_thread_handle: Option<std::thread::JoinHandle<()>>` (Falls MainLoop in eigenem Thread)
    - **Konstruktor `pub async fn new(event_publisher: tokio::sync::broadcast::Sender<AudioEvent>) -> Result<Self, AudioManagementError>`**:
        1. `pipewire::init()` aufrufen.
        2. `MainLoop::new(None)?` erstellen.
        3. `Context::new(&main_loop)?` erstellen.
        4. `Core::new(&context, None)?` (Verbindung zum PipeWire-Daemon herstellen).
        5. `Registry::new(&core)?` erstellen.
        6. Referenzen (`Arc`) für diese Objekte erstellen.
        7. `registry_listener` einrichten:
            - Im `global` Callback: Objekte filtern nach Typ (`PipewireObject::Node` für Geräte, `PipewireObject::Client` oder `PipewireObject::Stream` für Streams).
            - Für Nodes: Prüfen, ob es Audio Sinks/Sources sind (via Properties). `AudioDevice` erstellen, in `devices` speichern. `AudioEvent::DeviceListChanged` senden.
            - Für Streams: `AudioStream` erstellen, in `streams` speichern. `AudioEvent::StreamListChanged` senden.
            - `Metadata`-Objekt beobachten, um Standardgeräte zu finden (`default.audio.sink`, `default.audio.source`). `AudioEvent::DefaultDeviceChanged` senden.
        8. `core_listener` für `info` (um Server-Verbindungsstatus zu bekommen) und `error` einrichten.
        9. Wenn `main_loop` in eigenem Thread: `std::thread::spawn(move || main_loop_ref.run());`.
        10. Gibt `Self` zurück.
    - **Methode `pub async fn shutdown(&self)`**: Stoppt den `main_loop`-Thread sauber.
    - **Öffentliche Getter-Methoden (Beispiele):**
        - `pub async fn get_audio_devices(&self) -> Vec<AudioDevice>`: Gibt Klon von `self.devices.read().await.values()` zurück.
        - `pub async fn get_audio_streams(&self) -> Vec<AudioStream>`
        - `pub async fn get_default_sink(&self) -> Option<AudioDevice>`
        - `pub async fn get_default_source(&self) -> Option<AudioDevice>`
    - **Öffentliche Setter-Methoden (Beispiele):**
        - `pub async fn set_device_volume(&self, device_pw_id: u32, volume_percent: u8, is_muted: bool) -> Result<(), AudioManagementError>`:
            1. Findet das `Device` oder `Node` Proxy-Objekt für `device_pw_id` (muss im Registry-Handler gecacht werden).
            2. Erstellt `SpaPodBuilder` mit den neuen Lautstärkeparametern (`Props` mit `mute`, `channelVolumes`).
            3. Ruft `node_proxy.set_param("Props", 0, &pod)` auf.
            4. (PipeWire sendet dann über den Listener ein Event über die Volumenänderung, das dann ein `AudioEvent::DeviceVolumeChanged` auslöst).
        - `pub async fn set_stream_volume(...)` (analog).
        - `pub async fn set_default_device(&self, device_pw_id: u32, device_type: AudioDeviceType) -> Result<(), AudioManagementError>`:
            1. Erstellt `Metadata` Proxy für das `core`-Objekt.
            2. Setzt die Eigenschaft `default.audio.sink` oder `default.audio.source` auf die `device_pw_id`.
- **Wichtig:** Die `pipewire-rs` API ist Callback-basiert und integriert sich in eine `MainLoop`. Diese `MainLoop` muss entweder in einem dedizierten Thread laufen oder, falls möglich und komplexer, in die `calloop`-Schleife des Compositors integriert werden (z.B. indem der FD des PipeWire-Loops in `calloop` überwacht wird). Ein eigener Thread für den PipeWire-`MainLoop` ist oft einfacher zu handhaben. Die Kommunikation zwischen diesem Thread und den `async` Methoden des `PipeWireClientService` erfolgt dann über `tokio::sync::mpsc` Kanäle oder indem die `Arc<RwLock<...>>`-geschützten Zustände aktualisiert und `watch` Kanäle für Benachrichtigungen verwendet werden.

#### 4.4. Implementierungsschritte `system::audio_management`

1. **Grundgerüst**: Verzeichnis, `mod.rs`, `Cargo.toml` um `pipewire-rs` und ggf. `libspa` (falls für Pods nötig) erweitern.
2. **`types.rs`**: Alle Audio-bezogenen Typen und Enums (`AudioDeviceType`, `AudioDevice`, `AudioStream`, `AudioEvent`) definieren.
3. **`errors.rs`**: `AudioManagementError` Enum mit `thiserror` und `From<pipewire::Error>` definieren.
4. **`client/mod.rs`**:
    - `PipeWireClientService`-Struktur definieren.
    - `new()`-Konstruktor implementieren: Initialisiert PipeWire-Objekte (`MainLoop`, `Context`, `Core`, `Registry`).
    - `RegistryListener`-Logik implementieren:
        - `global` Callback: Erkennt Nodes (Sinks/Sources) und Streams. Parst deren Properties, um `AudioDevice`- und `AudioStream`-Objekte zu erstellen/aktualisieren. Speichert sie in den `RwLock`-geschützten HashMaps.
        - `global` Callback: Beobachtet `Metadata` für Default-Geräte.
        - Sendet entsprechende `AudioEvent`s über den `event_publisher`.
    - `CoreListener`-Logik für Fehler und Server-Info.
    - Startet den `MainLoop` in einem eigenen Thread.
    - `shutdown()`-Methode implementieren.
    - Öffentliche `async` Getter-Methoden implementieren (lesen aus den `RwLock`-geschützten Maps).
    - Öffentliche `async` Setter-Methoden implementieren (`set_device_volume`, `set_default_device` etc.), die PipeWire-Befehle (oft über Setzen von Properties/Params auf Nodes/Streams via SPA Pods) asynchron ausführen. Dies könnte das Senden von Nachrichten an den MainLoop-Thread über einen Kanal erfordern, falls die `pipewire-rs` Proxies nicht direkt `Send+Sync` sind oder Operationen im MainLoop-Kontext erfordern.
5. **Unit-/Integrationstests**:
    - Sehr schwierig ohne laufenden PipeWire-Server. Fokus auf:
    - Korrekte Erstellung/Parsen der eigenen Typen (`AudioDevice` etc.).
    - Logik der Listener-Callbacks (mocken von `Registry`, `GlobalObject` etc. ist aufwendig). Eventuell Tests, die auf einem Test-PipeWire-Server laufen (falls headless möglich).
    - Testen der Setter-Methoden, ob sie die korrekten PipeWire-Parameter (SPA Pods) generieren würden.

---

Diese detaillierten Pläne für die Module `system::dbus_interfaces` (Fortsetzung) und `system::audio_management` sollten eine sehr solide Grundlage für die Implementierung bieten. Die Komplexität liegt hier oft in der korrekten asynchronen Integration und der genauen Abbildung der externen D-Bus/PipeWire-APIs und -Events auf die internen Strukturen und das Event-System von NovaDE.

---

### Modul 3: `system::dbus_interfaces` (Fortsetzung und Vervollständigung)

#### 3.4. Submodul: `system::dbus_interfaces::logind_client` (Vervollständigung)

Zweck: Client für org.freedesktop.login1 für Sitzungsmanagement.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

**Datei:** `src/dbus_interfaces/logind_client/service.rs` (Fortsetzung)

- **`LogindClientService` Implementierung (Methoden-Details):**
    - **`async fn initialize_and_listen(&self) -> Result<(), DBusInterfaceError>`**:
        1. `sessions = self.manager_proxy.list_sessions().await?.into_iter().map(|(id, _uid, _user, _seat, path)| (id, path)).collect::<HashMap<_,_>>();`
        2. Für jede `(id, path)` in `sessions`:
            - `self.add_session_proxy_and_listen(&id, path).await?;`
        3. Starte `tokio::task` für `manager_proxy.receive_session_new()`:
            - Bei `SessionNew { session_id, object_path }`: `self.add_session_proxy_and_listen(&session_id, object_path).await;` `self.event_publisher.send(LogindEvent::SessionNew(...))`.
        4. Starte `tokio::task` für `manager_proxy.receive_session_removed()`:
            - Bei `SessionRemoved { session_id, object_path }`: `self.session_proxies.lock().await.remove(&session_id);` `self.event_publisher.send(LogindEvent::SessionRemoved(...))`.
        5. Starte `tokio::task` für `manager_proxy.receive_prepare_for_shutdown()`:
            - `self.event_publisher.send(LogindEvent::PrepareForShutdown(start_signal_arg)).ok();`
        6. Starte `tokio::task` für `manager_proxy.receive_prepare_for_sleep()`:
            - `self.event_publisher.send(LogindEvent::PrepareForSleep(start_signal_arg)).ok();`
    - **`async fn add_session_proxy_and_listen(&self, session_id: &str, object_path: OwnedObjectPath) -> Result<(), DBusInterfaceError>`**:
        1. `session_proxy = LogindSessionProxy::builder(&self.connection).path(object_path.clone())?.build().await?;`
        2. Starte `tokio::task` für `session_proxy.receive_lock()`: `self.event_publisher.send(LogindEvent::SessionLocked(object_path.clone())).ok();`
        3. Starte `tokio::task` für `session_proxy.receive_unlock()`: `self.event_publisher.send(LogindEvent::SessionUnlocked(object_path.clone())).ok();`
        4. `self.session_proxies.lock().await.insert(session_id.to_string(), session_proxy);`
    - **`get_current_session_details()`**:
        1. `current_pid = std::process::id();`
        2. `session_path = self.manager_proxy.get_session_by_pid(current_pid).await?;`
        3. `session_proxy = LogindSessionProxy::builder(&self.connection).path(session_path.clone())?.build().await?;`
        4. Rufe alle Properties von `session_proxy` ab (z.B. `id()`, `user()`, `name()`, etc.) und fülle `SessionDetails`.
    - **`lock_current_session()`**:
        1. `session_path = self.manager_proxy.get_session_by_pid(std::process::id()).await?;`
        2. `session_proxy = self.session_proxies.lock().await.get(session_path.as_str())` (oder neu erstellen, falls nicht gecacht).
        3. `session_proxy.lock().await?;`
    - Andere Methoden (`can_power_off`, `power_off`, etc.) rufen die entsprechenden `manager_proxy`-Methoden auf.

**Datei:** `src/dbus_interfaces/logind_client/mod.rs`

- `pub mod types;`
- `pub mod proxies;`
- `pub mod service;`
- `pub use service::LogindClientService;`
- `pub use types::{LogindEvent, SessionDetails, LogindPowerOperation};`

#### 3.5. Submodul: `system::dbus_interfaces::network_manager_client` (Vervollständigung)

**Zweck:** Client für `org.freedesktop.NetworkManager`.

**Datei:** `src/dbus_interfaces/network_manager_client/types.rs`

- **Enums:**
    - `NMState`: `Unknown, Asleep, Disconnected, Disconnecting, Connecting, ConnectedLocal, ConnectedSite, ConnectedGlobal`. `#[repr(u32)]`, `Type`.
    - `NMDeviceType`: `Unknown, Ethernet, Wifi, Wimax, Modem, Bluetooth, OlpcMesh, WifiP2p, Bond, Vlan, Adsl, Bridge, Generic, Team, Tun, IpTunnel, Macvlan, Vxlan, Veth, Dummy, Sriov`. `#[repr(u32)]`, `Type`.
    - `NMConnectivityState`: `Unknown, None, Portal, Limited, Full`. `#[repr(u32)]`, `Type`.
    - `NMWifiAccessPointFlags`, `NMWifiAccessPointSecurityFlags`.
- **Structs:**
    - `NetworkDeviceDetails { id: u32, path: DBusObjectPath, interface: String, device_type: NMDeviceType, state: u32 /* NMDeviceState */, ip4_address: Option<String>, ip6_address: Option<String>, hw_address: Option<String>, mtu: u32, managed: bool, firmware_missing: bool, driver: String, ... }`
    - `AccessPointDetails { path: DBusObjectPath, ssid: String, bssid: String, strength: u8, frequency: u32, flags: u32, wpa_flags: u32, rsn_flags: u32, max_bitrate: u32, ... }`
    - `ActiveConnectionDetails { path: DBusObjectPath, uuid: String, connection_type: String, id: String, specific_object_path: DBusObjectPath, state: u32 /* NMActiveConnectionState */, default: bool, default6: bool, vpn: bool, master_path: Option<DBusObjectPath>, ip4_config_path: Option<DBusObjectPath>, ... }`
- **Event:**
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum NetworkManagerEvent {
        ConnectivityChanged(NMConnectivityState),
        StateChanged(NMState),
        DeviceAdded(NetworkDeviceDetails),
        DeviceRemoved(DBusObjectPath /* device path */),
        DeviceStateChanged { device_path: DBusObjectPath, new_state: u32 /* NMDeviceState */, old_state: u32 },
        ActiveConnectionAdded(ActiveConnectionDetails),
        ActiveConnectionRemoved(DBusObjectPath /* active connection path */),
        AccessPointAdded(AccessPointDetails),
        AccessPointRemoved(DBusObjectPath /* ap path */),
        PrimaryConnectionChanged(Option<ActiveConnectionDetails>),
    }
    ```
    

**Datei:** `src/dbus_interfaces/network_manager_client/proxies.rs`

- **`NetworkManagerProxy` für `org.freedesktop.NetworkManager`**: Properties (`Connectivity`, `State`, `NetworkingEnabled`, `WirelessEnabled`, `WirelessHardwareEnabled`, `WwanEnabled`, `WwanHardwareEnabled`, `ActiveConnections`, `PrimaryConnection`, `Devices`, etc.). Methoden (`GetDevices`, `GetActiveConnections`, `ActivateConnection`, `DeactivateConnection`, `ScanWifiAccessPoints`, etc.). Signale (`CheckPermissions`, `StateChanged`, `PropertiesChanged`, `DeviceAdded`, `DeviceRemoved`, `ActiveConnectionAdded`, `ActiveConnectionRemoved`).
- **`NMDeviceProxy` für `org.freedesktop.NetworkManager.Device`**: Viele Properties (Interface, IpInterface, Udi, State, DeviceType, AvailableConnections, Ip4Config, Dhcp4Config, etc.).
- **`NMWifiDeviceProxy` für `org.freedesktop.NetworkManager.Device.Wireless`**: Properties (`HwAddress`, `PermHwAddress`, `Mode`, `Bitrate`, `ActiveAccessPoint`, etc.). Methoden (`GetAccessPoints`, `RequestScan`, etc.). Signale (`AccessPointAdded`, `AccessPointRemoved`, `PropertiesChanged`).
- **`NMAccessPointProxy` für `org.freedesktop.NetworkManager.AccessPoint`**: Properties (`Ssid`, `Frequency`, `HwAddress`, `Mode`, `MaxBitrate`, `Strength`, `Flags`, `WpaFlags`, `RsnFlags`, etc.).
- **`NMActiveConnectionProxy` für `org.freedesktop.NetworkManager.Connection.Active`**: Properties (`Connection` (path), `SpecificObject` (path), `Id`, `Uuid`, `Type`, `Devices`, `State`, `Default`, `Ip4Config`, etc.). Signale (`StateChanged`, `PropertiesChanged`).
- **`NMSettingsProxy` für `org.freedesktop.NetworkManager.Settings`**: Methoden (`ListConnections`, `AddConnection`, `GetConnectionByUuid`, etc.).
- **`NMSettingsConnectionProxy` für `org.freedesktop.NetworkManager.Settings.Connection`**: Methoden (`Update`, `Delete`, `GetSettings`, `GetSecrets`, etc.).

**Datei:** `src/dbus_interfaces/network_manager_client/service.rs`

- **`NetworkManagerClientService`**:
    - **Felder:** Connection, Hauptproxy, Maps für Geräte-, AP-, aktive Verbindungsproxies. Event-Publisher.
    - **`initialize_and_listen()`**: Initiales Laden von Devices, aktiven Verbindungen. Signale abonnieren (Hauptproxy, Geräte, aktive Verbindungen).
    - **Öffentliche Methoden:** `get_connectivity_state()`, `get_primary_connection_details()`, `list_devices()`, `list_active_connections()`, `list_wifi_access_points(device_path: &DBusObjectPath)`, `activate_connection(connection_path: &DBusObjectPath, device_path: &DBusObjectPath)`, etc.

**Implementierungsschritte `network_manager_client`**:

1. `types.rs`: Alle NM-bezogenen Typen und Events.
2. `proxies.rs`: Alle benötigten NM-Proxies.
3. `service.rs`: `NetworkManagerClientService` implementieren.
4. Tests (schwierig ohne NM, `zbus::MockConnection` verwenden).

---

#### 3.6. Submodul: `system::dbus_interfaces::secrets_service_client` (Vervollständigung)

**Zweck:** Client für `org.freedesktop.Secret.Service`.

**Datei:** `src/dbus_interfaces/secrets_service_client/types.rs`

- **Struct `Secret`**: `session: DBusObjectPath`, `parameters: Vec<u8>`, `value: Vec<u8>`, `content_type: String`.
- **Struct `SecretItemProperties`**: `label: String`, `attributes: HashMap<String, String>`, `created: u64`, `modified: u64`, `locked: bool`.
- **Event:** `SecretServiceEvent::PromptRequired { prompt_path: DBusObjectPath }`, `SecretServiceEvent::PromptCompleted { prompt_path: DBusObjectPath, dismissed: bool }`.

**Datei:** `src/dbus_interfaces/secrets_service_client/proxies.rs`

- **`SecretServiceProxy` (`org.freedesktop.Secret.Service`)**: Methoden (`OpenSession`, `CreateCollection`, `SearchItems`, `Unlock`, `Lock`, `GetSecrets`, `ReadAlias`, `SetAlias`). Properties (`Collections`, `State`). Signal (`CollectionCreated`, `CollectionDeleted`, `CollectionChanged`).
- **`SecretSessionProxy` (`org.freedesktop.Secret.Session`)**: Methode (`Close`). (Lebensdauer beachten).
- **`SecretCollectionProxy` (`org.freedesktop.Secret.Collection`)**: Methoden (`Delete`, `SearchItems`, `CreateItem`). Properties (`Items`, `Label`, `Locked`, `Created`, `Modified`). Signal (`ItemCreated`, `ItemDeleted`, `ItemChanged`).
- **`SecretItemProxy` (`org.freedesktop.Secret.Item`)**: Methoden (`Delete`, `GetSecret`, `SetSecret`). Properties (`Locked`, `Attributes`, `Label`, `Type`, `Created`, `Modified`).
- **`SecretPromptProxy` (`org.freedesktop.Secret.Prompt`)**: Methode (`Prompt`). Signal (`Completed`).

**Datei:** `src/dbus_interfaces/secrets_service_client/service.rs`

- **Struct `SecretsServiceClientService`**:
    - **Felder:** Connection, `service_proxy: SecretServiceProxy`, `default_collection_alias: String` (z.B. "novade_default" oder "login"), `open_sessions: Arc<tokio::sync::Mutex<HashMap<DBusObjectPath, SecretSessionProxy<'static>>>>`. Event-Publisher für `SecretServiceEvent`.
    - **Konstruktor:** `new(...)`.
    - **`initialize_and_listen()`**: Öffnet eine initiale Session für die Default-Collection (oder "login"). Abonniert Signale von `SecretServiceProxy`.
    - **Öffentliche Methoden:**
        - `async fn ensure_collection_exists(&self, alias: &str, label: &str) -> Result<DBusObjectPath, DBusInterfaceError>`
        - `async fn store_secret_in_collection(&self, collection_path_or_alias: &str, item_label: &str, secret_content: &[u8], attributes: HashMap<String, String>, content_type: &str, replace: bool) -> Result<DBusObjectPath /* item_path */, DBusInterfaceError>`
        - `async fn retrieve_secret_from_item(&self, item_path: &DBusObjectPath) -> Result<Vec<u8>, DBusInterfaceError>`
        - `async fn search_items_in_collection(&self, collection_path_or_alias: &str, attributes: HashMap<String, String>) -> Result<Vec<(DBusObjectPath, SecretItemProperties)>, DBusInterfaceError>`
        - `async fn delete_item(&self, item_path: &DBusObjectPath) -> Result<(), DBusInterfaceError>`
        - `async fn unlock_items_or_paths(&self, paths: &[DBusObjectPath]) -> Result<(), DBusInterfaceError>`: Ruft `Unlock` auf `SecretServiceProxy`. Startet Task, um `Prompt.Completed`-Signal zu behandeln.
    - **Handhabung von `Prompt`**: Wenn `Unlock` einen `Prompt`-Pfad zurückgibt, wird ein `SecretPromptProxy` erstellt, `Prompt()` aufgerufen und das `Completed`-Signal abgewartet. Das `SecretServiceEvent` wird gesendet, um UI ggf. zu informieren.

**Implementierungsschritte `secrets_service_client`**:

1. Typen, Proxies, Service-Struktur.
2. Implementierung der Methoden, insbesondere der komplexen Abläufe mit Sessions und Collections.
3. Sorgfältige Handhabung von `Unlock`-Prompts und deren Signalen.
4. Tests mit gemocktem D-Bus.

---

#### 3.7. Submodul: `system::dbus_interfaces::policykit_client` (Vervollständigung)

**Zweck:** Client für `org.freedesktop.PolicyKit1.Authority`.

**Datei:** `src/dbus_interfaces/policykit_client/types.rs`

- **Enum `PolicyKitImplicitAuthorization`**: (aus Polkit-Spezifikation) `Unknown, NotAuthorized, AuthenticationRequired, AdministratorAuthenticationRequired, AuthenticationRequiredRetained, AdministratorAuthenticationRequiredRetained, Authorized`. `#[repr(u32)]`, `Type`.
- **Struct `PolicyKitAuthorizationResultDetails`**: Enthält zusätzliche Daten vom Result.
- **Struct `PolicyKitSubjectSystemBusName`**: `name: String`.
- **Enum `PolicyKitSubjectKind`**: `User { user_id: u32 }`, `SystemBusName { name: String }`, `Binary { path: String, pid: Option<u32> }`. (Vereinfacht, Polkit hat komplexere Subject-Typen).

**Datei:** `src/dbus_interfaces/policykit_client/proxies.rs`

- **`PolicyKitAuthorityProxy` für `org.freedesktop.PolicyKit1.Authority`**:
    
    Rust
    
    ```
    #[proxy(
        interface = "org.freedesktop.PolicyKit1.Authority",
        default_service = "org.freedesktop.PolicyKit1",
        default_path = "/org/freedesktop/PolicyKit1/Authority"
    )]
    trait PolicyKitAuthority {
        // flags: 0x00000001 (ALLOW_USER_INTERACTION)
        // cancellation_id: String (leer für keinen)
        async fn check_authorization(
            &self,
            subject: zbus::zvariant::Value<'_>, // ('sys', {'unix-process': <{'pid': <uint32 ProcessID>, 'start-time': <uint64 StartTime>}>})
            action_id: &str,
            details: std::collections::HashMap<&str, &str>,
            flags: u32,
            cancellation_id: &str,
        ) -> zbus::Result<(bool, bool, Dict<'static, String, Value<'static>>)>; // (is_authorized, is_challenge, details)
        // Weitere Methoden wie EnumerateActions, RegisterAuthenticationAgent etc.
    }
    ```
    
    - **Hinweis:** Der `subject`-Parameter ist komplex (`a{sv}`). `zbus` sollte dies als `Value` oder `Dict` handhaben können.

**Datei:** `src/dbus_interfaces/policykit_client/service.rs`

- **Struct `PolicyKitClientService`**:
    - **Felder:** Connection, `authority_proxy: PolicyKitAuthorityProxy`.
    - **Konstruktor:** `new(...)`.
    - **Öffentliche Methode `async fn check_authorization(...) -> Result<PolicyKitAuthorizationDetails, DBusInterfaceError>`**:
        1. Konstruiert das `subject`-Value (z.B. für den aktuellen Prozess `std::process::id()`).
        2. Ruft `authority_proxy.check_authorization(...)`.
        3. Parst das Ergebnis-Tuple in `PolicyKitAuthorizationDetails`.
        4. UI-Interaktion für Passwortabfragen wird vom systemweiten PolicyKit-Agenten gehandhabt, nicht von diesem Client.

**Implementierungsschritte `policykit_client`**:

1. Typen, Proxy, Service-Struktur.
2. `check_authorization` Implementierung mit korrekter Erstellung des `subject`-Parameters.
3. Tests mit gemocktem D-Bus.

---

#### 3.8. Submodul: `system::dbus_interfaces::notifications_server` (Vervollständigung)

**Zweck:** Implementierung des `org.freedesktop.Notifications` D-Bus-Servers.

**Datei:** `src/dbus_interfaces/notifications_server/service_object.rs`

- **Struct `FreedesktopNotificationsServer`**:
    - **Felder:**
        - `notification_service: Arc<Mutex<dyn NotificationService>>`
        - `id_map: Arc<tokio::sync::Mutex<HashMap<u32, Uuid>>>` (D-Bus ID -> Domain ID)
        - `reverse_id_map: Arc<tokio::sync::Mutex<HashMap<Uuid, u32>>>` (Domain ID -> D-Bus ID)
        - `next_dbus_id: Arc<tokio::sync::atomic::AtomicU32>` (Für eindeutige D-Bus IDs)
        - `signal_ctxt_sender: tokio::sync::mpsc::Sender<DbusSignalTask>` (Um Signale aus einem anderen Kontext senden zu können)
    - **Enum `DbusSignalTask`**: `NotificationClosed { dbus_id: u32, reason: u32 }`, `ActionInvoked { dbus_id: u32, action_key: String }`.
    - **Konstruktor `new(...)`**: Initialisiert Felder. Startet einen `tokio::task`, der Domain-Events (`NotificationDismissedEvent`, `NotificationActionInvokedEvent`) vom `notification_service` empfängt (über dessen `subscribe` Methode), die Domain-UUIDs in D-Bus-`u32`-IDs umwandelt und Tasks über `signal_ctxt_sender` sendet, um die D-Bus-Signale zu emittieren.
    - **D-Bus Methoden Implementierung (`#[dbus_interface(...)]`)**:
        - **`notify(...)`**:
            1. Konvertiert D-Bus Parameter in `NotificationInput`.
            2. Ruft `self.notification_service.lock().await.post_notification(input).await`.
            3. Bei Erfolg: Generiert neue `dbus_id` (aus `next_dbus_id`), speichert Mapping zu Domain-`Uuid`, gibt `dbus_id` zurück.
        - **`close_notification(id: u32)`**:
            1. Findet Domain-`Uuid` für `id` in `id_map`.
            2. Ruft `self.notification_service.lock().await.dismiss_notification(domain_id, DismissReason::DbusRequest).await`. (Grund anpassen)
        - **`get_server_information()`, `get_capabilities()`**: Wie zuvor.
    - **D-Bus Signale**: (`notification_closed`, `action_invoked`) werden von dem separaten Task gesendet, der auf Domain-Events lauscht und den `SignalContext` vom Server-Objekt benötigt. Der `SignalContext` kann geklont und an den Task übergeben werden oder man verwendet den `signal_ctxt_sender` um die Aufgabe ans Hauptobjekt zu delegieren.
- **Funktion zum Starten des D-Bus Dienstes:**
    
    Rust
    
    ```
    // In service_object.rs oder mod.rs
    pub async fn run_notifications_server(
        notification_service: Arc<Mutex<dyn NotificationService>>,
        // broadcast_receiver_for_domain_events: tokio::sync::broadcast::Receiver<NotificationEventEnum>
    ) -> Result<(), DBusInterfaceError> {
        let conn = DBusConnectionManager::session_bus().await?;
        let server_logic = Arc::new(FreedesktopNotificationsServer::new(notification_service));
    
        // Task starten, der Domain-Events in D-Bus-Signale umwandelt
        // Dieser Task benötigt eine Möglichkeit, Signale zu senden.
        // Entweder durch Klonen des SignalContext (falls möglich und sicher)
        // oder durch einen internen MPSC-Kanal zum Server-Objekt.
        // setup_domain_event_to_dbus_signal_handler(server_logic.clone(), broadcast_receiver_for_domain_events);
    
        conn.object_server().at("/org/freedesktop/Notifications", server_logic)?.await?;
        conn.request_name("org.freedesktop.Notifications", zbus:: stazione::RequestNameFlags::ReplaceExisting.into()).await?;
        tracing::info!("org.freedesktop.Notifications D-Bus Service gestartet und Name angefordert.");
        // Die Connection muss am Leben erhalten werden, z.B. indem der Server in einem blockierenden Task läuft
        // oder die Connection selbst in einem Arc gehalten und nie fallengelassen wird.
        // Für einen langlaufenden Dienst ist es üblich, dass diese Funktion nicht zurückkehrt oder
        // die Connection in einer globalen Variable/einem Manager gehalten wird.
        std::future::pending::<()>().await; // Hält den Server am Laufen
        Ok(())
    }
    ```
    

#### 3.10. `system::dbus_interfaces::mod.rs`

- Deklariert alle Submodule (`common`, `upower_client`, `logind_client`, etc.).
- Re-exportiert die öffentlichen Service-Structs/Traits und wichtigen Event-Typen/Fehler.

---

### Modul 4: `system::audio_management` (Vervollständigung)

Zweck: PipeWire-Integration für Audio-Steuerung.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

**Datei:** `src/audio_management/types.rs` (Vervollständigung)

- **`AudioDevice`**:
    - Zusätzliche Felder: `ports: Vec<AudioPortInfo>`, `active_profile_index: Option<u32>`, `profiles: Vec<AudioProfileInfo>`, `form_factor: String` (z.B. "headset", "speaker", "microphone"), `bus_path: String`.
- **`AudioPortInfo`**: `id: u32`, `name: String`, `direction: pipewire::spa::Direction`, `available: bool`.
- **`AudioProfileInfo`**: `index: u32`, `name: String`, `description: String`, `available: bool`, `priority: u32`.
- **`AudioStream`**:
    - Zusätzliche Felder: `process_id: Option<u32>`, `process_binary_name: Option<String>`, `is_corked: bool`.
- **`AudioEvent`**:
    - `DefaultDeviceChanged` Payload: `{ device_type: AudioDeviceType, new_default_device: Option<AudioDevice> }` (ganzes Objekt statt nur ID).
    - `DevicePropertiesChanged(AudioDevice)` (Wenn sich andere Properties als nur Volume/Mute ändern).
    - `StreamPropertiesChanged(AudioStream)`.

**Datei:** `src/audio_management/client/pipewire_listener.rs` (Neues Submodul/Datei)

- **Struct `PipeWireRegistryEventHandler`**:
    - **Felder:** `devices: Arc<tokio::sync::RwLock<HashMap<u32, AudioDevice>>>`, `streams: Arc<tokio::sync::RwLock<HashMap<u32, AudioStream>>>`, `default_sink_id: Arc<tokio::sync::RwLock<Option<u32>>>`, `default_source_id: Arc<tokio::sync::RwLock<Option<u32>>>`, `event_publisher: tokio::sync::broadcast::Sender<AudioEvent>`, `core_ref: Weak<pipewire::Core>` (um Proxies zu erstellen).
    - **Methoden (Callbacks für `RegistryListener`):**
        - **`global(global_object)`**:
            1. Prüft Typ (`Node` für Geräte, `Client`/`Stream` für Streams, `Metadata` für Defaults).
            2. Für `Node`:
                - `node_proxy = registry.bind::<pipewire::node::Node>(&global_object)?;`
                - Properties parsen (media.class, device.description, device.api, etc.) um `AudioDeviceType` zu bestimmen.
                - Listener für `node_proxy.receive_info_changed()` und `node_proxy.receive_param_changed()` einrichten.
                    - `info_changed`: Aktualisiert `AudioDevice`-Properties, sendet `DevicePropertiesChanged` oder `DeviceListChanged`.
                    - `param_changed` (für "Props", "Route"): Aktualisiert Volume/Mute in `AudioDevice`, sendet `DeviceVolumeChanged`.
                - Erstellt `AudioDevice`, speichert in `devices`, sendet `DeviceListChanged`.
            3. Für `Stream` (oder `Client`, das Streams hat): Analog für `AudioStream`.
            4. Für `Metadata` (Name "default"):
                - Listener für `metadata_proxy.receive_property_changed()` einrichten.
                - Bei Änderung von "default.audio.sink" oder "default.audio.source": Aktualisiere `default_sink_id`/`default_source_id`, finde das `AudioDevice`-Objekt, setze `is_default`, sende `DefaultDeviceChanged`.
        - **`global_remove(id)`**: Entfernt Objekt aus Maps, sendet `DeviceListChanged`/`StreamListChanged`.
- **Struct `PipeWireCoreEventHandler`**:
    - **Felder:** `event_publisher: tokio::sync::broadcast::Sender<AudioEvent>`.
    - **Methoden (Callbacks für `CoreListener`):**
        - `info(info)`: Prüft `info.change_mask` für `CoreChangeMask::PROPS`, um Server-Verbindungsstatus zu erkennen. Sendet `ServerConnectionStateChanged`.
        - `error(...)`: Loggt Fehler.

**Datei:** `src/audio_management/client/service.rs` (oder `mod.rs`)

- **`PipeWireClientService`**:
    - **Konstruktor `new(...)`**:
        1. Initialisiert PipeWire-Objekte.
        2. Erstellt `PipeWireRegistryEventHandler` und `PipeWireCoreEventHandler`.
        3. `registry.add_listener_local(registry_event_handler_struct)` (oder `Weak` Referenzen verwenden, um Zyklen zu vermeiden, Listener müssen `'static` sein für `add_listener_local`).
        4. `core.add_listener_local(core_event_handler_struct)`.
        5. Startet `MainLoop`-Thread.
    - **Setter-Methoden (`set_device_volume`, `set_default_device` etc.):**
        - Müssen nun asynchron mit dem `MainLoop`-Thread kommunizieren, wenn die `pipewire-rs`-Proxies nicht `Send` sind oder Operationen im Loop-Kontext erfordern.
        - **Ansatz 1 (Kanal zum MainLoop-Thread):**
            - `PipeWireClientService` hält `command_sender: tokio::sync::mpsc::Sender<AudioCommand>`.
            - Im `MainLoop`-Thread wird ein `mpsc::Receiver<AudioCommand>` abgefragt.
            - `AudioCommand` Enum: `SetDeviceVolume { pw_id: u32, volume: u8, mute: bool }, SetDefaultDevice { ... }`.
            - Setter-Methoden senden Befehl über Kanal. `MainLoop` führt Aktion aus, aktualisiert internen Zustand und der Listener sendet dann das `AudioEvent`.
        - **Ansatz 2 (Proxies direkt nutzen, wenn `Send`):** Wenn `pipewire::node::Node` (der Proxy) `Send` ist, können die Setter-Methoden ihn direkt verwenden. Die Aktualisierung der `AudioDevice`-Struktur und das Senden des `AudioEvent` erfolgt dann immer noch über den Listener-Pfad als Reaktion auf das `param_changed`-Signal von PipeWire.
    - **`Youtube_property(core_proxy: &Arc<Core>, key: &str) -> Option<String>`**: Hilfsfunktion zum Lesen von Metadaten-Properties für Default-Geräte.

#### 4.4. Implementierungsschritte `system::audio_management` (Fortsetzung)

1. **`types.rs`**: `AudioDevice`, `AudioStream`, `AudioEvent` vervollständigen. `AudioPortInfo`, `AudioProfileInfo`.
2. **`errors.rs`**: `AudioManagementError` vervollständigen.
3. **`client/pipewire_listener.rs`**: `PipeWireRegistryEventHandler` und `PipeWireCoreEventHandler` implementieren, inklusive der detaillierten Logik in den Callbacks zum Parsen von Properties und Senden von Events.
4. **`client/service.rs`**:
    - `PipeWireClientService`-Struktur mit Feldern für PipeWire-Objekte, Listener-Handles und Zustand (Maps, Default-IDs) definieren.
    - `new()`-Konstruktor: Initialisierung, Listener-Registrierung, `MainLoop`-Thread starten.
    - Getter-Methoden implementieren (lesen aus den `RwLock`-geschützten Maps).
    - Setter-Methoden implementieren:
        - Entscheiden, ob Kommunikation mit MainLoop-Thread via Kanal nötig ist oder ob Proxies direkt verwendet werden können.
        - SPA Pods für Lautstärke etc. korrekt erstellen.
        - `set_default_device` über PipeWire-Metadaten implementieren.
    - `shutdown()`-Methode.
5. **Tests**: Fokus auf korrekte Erstellung von SPA Pods, Parsing von Properties in Listenern (mit Beispiel-Property-Dicts), korrekte Event-Erzeugung. Integrationstests mit laufendem PipeWire-Server sind ideal, aber schwer aufzusetzen.

---

**Nächste Schritte für `system` (Skizze für verbleibende Module):**

- **Modul 5: `system::mcp_client`**:
    - **Zweck:** Implementierung des Model Context Protocol Clients.
    - **Verantwortlichkeiten:** Verbindung zu MCP-Servern, Senden von Anfragen (Ressourcenauflistung, Tool-Aufrufe) basierend auf Anweisungen von `domain::user_centric_services::ai_interaction`, Empfangen und Weiterleiten von Antworten/Benachrichtigungen. API-Schlüssel-Management via `secrets_service_client`.
    - **Technologie:** `mcp_client_rs` Crate.
    - **Struktur:** `connection.rs` (Verwaltung der Verbindung, ggf. Starten eines lokalen MCP-Server-Prozesses), `protocol_handler.rs` (Wrapper um `mcp_client_rs::McpClient`), `resource_provider.rs` (stellt `mcp_client_rs::Resource`s bereit, z.B. für Dateisystemzugriff, Zwischenablage – interagiert mit anderen Systemmodulen).
    - **Fehler:** `McpClientError`.
    - **Events:** `McpResponseEvent`, `McpNotificationEvent`.
- **Modul 6: `system::window_mechanics`**:
    - **Zweck:** Technische Umsetzung des Fenstermanagements (Positionierung, Größe, Stapelreihenfolge, Tiling, Fokus, Dekorationen).
    - **Verantwortlichkeiten:** Nimmt `WorkspaceWindowLayout` von `domain::window_management_policy` entgegen und wendet es auf `ManagedWindow`s im `system::compositor::core::DesktopState::space` an. Sendet `configure`-Events an Wayland-Clients. Handhabt interaktive Operationen (Move/Resize-Grabs). Koordiniert Server-Side Decorations (SSD) mit Client-Side Decorations (CSD) basierend auf `xdg-decoration`-Protokoll und Domänen-Policy.
    - **Interaktion:** Eng mit `system::compositor` (insb. `xdg_shell` und `Space`) und `domain::window_management_policy`.
    - **Fehler:** `WindowMechanicsError`.
- **Modul 7: `system::event_bridge`**:
    - **Zweck:** Eine zentrale Stelle für System-interne Events, die nicht direkt an einen spezifischen D-Bus-Dienst oder ein Wayland-Protokoll gebunden sind.
    - **Verantwortlichkeiten:** Definition von generischen System-Event-Typen. Bereitstellung von `tokio::sync::broadcast` Kanälen für diese Events.
    - **Beispiel-Events:** `InputDeviceHotplugEvent { device_name: String, event_type: HotplugType (Added/Removed) }`, `SystemSuspendRequestEvent { operation: SuspendOperation (Suspend/Hibernate) }`, `ActiveOutputConfigurationChangedEvent`.
    - Dient als Entkopplungsschicht innerhalb des Systems.
- **Modul 8: `system::power_management`**:
    - **Zweck:** Implementierung von DPMS und Interaktion mit `wlr-output-power-management`.
    - **Verantwortlichkeiten:** Hört auf `UserActivityDetectedEvent` und `LogindEvent::SystemIdleHintChanged`. Liest Energieeinstellungen von `domain::global_settings_service`. Steuert den DPMS-Zustand von Outputs über die Compositor-Schnittstelle (z.B. direkte Aufrufe an DRM-Backend oder über `wlr-output-power-management`-Protokoll, falls als Client implementiert).
    - **Interaktion:** `system::compositor::output_management` (für serverseitige `wlr-output-power-management`-Implementierung), `system::dbus_interfaces::logind_client`, `domain::global_settings_service`.
    - **Fehler:** `PowerManagementError`.

Diese detaillierte Aufschlüsselung und die Pläne für die einzelnen Module sollten eine sehr klare Richtung für die Implementierung der Systemschicht geben. Der Fokus liegt auf der korrekten Integration externer Bibliotheken und Protokolle, der robusten Fehlerbehandlung und der Bereitstellung klarer Schnittstellen zur Domänen- und UI-Schicht.

---

### Modul 5: `system::mcp_client`

Zweck: Implementierung des Clients für das Model Context Protocol (MCP), um sicher mit lokalen oder Cloud-basierten KI-Modellen (LLMs) zu interagieren.

Verantwortlichkeiten:

- Aufbau und Verwaltung der Verbindung zu einem MCP-Server (kann ein lokaler Prozess oder ein Remote-Endpunkt sein).
- Senden von Anfragen an den MCP-Server (z.B. `ListResources`, `CallTool`) basierend auf Anweisungen von `domain::user_centric_services::ai_interaction`.
- Empfangen von Antworten und asynchronen Benachrichtigungen vom MCP-Server.
- Sichere Handhabung von API-Schlüsseln (via `system::dbus_interfaces::secrets_service_client`) für Cloud-basierte Modelle.
- Bereitstellung einer abstrahierten Schnittstelle für die Domänenschicht, um KI-Funktionen anzufordern, ohne MCP-Protokolldetails kennen zu müssen. **Design-Rationale:** Kapselung der MCP-spezifischen Kommunikationslogik. Nutzung des `mcp_client_rs` Crates als Basis. Ermöglichung einer flexiblen Anbindung verschiedener KI-Modelle, die das MCP unterstützen. **Technologie:** `mcp_client_rs` Crate, `tokio` für asynchrone Operationen, `serde` für Datenstrukturen.

#### 5.1. Untermodul: `system::mcp_client::types`

**Datei:** `src/mcp_client/types.rs`

- **Struct `McpServerConfig`** (Konfiguration für die Verbindung zu einem MCP-Server):
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub enum McpServerType {
        LocalExecutable {
            command: String,
            args: Vec<String>,
            working_directory: Option<String>,
        },
        RemoteHttp {
            endpoint_url: String, // z.B. "http://localhost:8000/mcp"
            // api_key_secret_name: Option<String>, // Wird über AIModelProfile gehandhabt
        },
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub struct McpServerConfig {
        pub server_id: String, // Eindeutige ID für diese Serverkonfiguration
        pub server_type: McpServerType,
        #[serde(default)]
        pub default_request_timeout_ms: u64, // Standard-Timeout für Anfragen
    }
    
    impl Default for McpServerConfig {
        fn default() -> Self {
            Self {
                server_id: "default_local_mcp".to_string(),
                server_type: McpServerType::LocalExecutable {
                    command: "nova-mcp-server".to_string(), // Beispiel
                    args: vec![],
                    working_directory: None,
                },
                default_request_timeout_ms: 30000, // 30 Sekunden
            }
        }
    }
    ```
    
- **Re-Export und Wrapper für `mcp_client_rs::protocol` Typen (falls nötig):**
    - `pub use mcp_client_rs::protocol::{InitializeParams, InitializeResult, ListResourcesParams, ListResourcesResult, Resource, CallToolParams, CallToolResult, ToolCall, ToolResult, McpMessage, Notification, ErrorResponse, ErrorCode};`
    - Ggf. eigene Wrapper-Structs, wenn Felder hinzugefügt oder angepasst werden müssen.
- **Event-Struktur (für `system::event_bridge` oder direkt an Domäne):**
    
    Rust
    
    ```
    use mcp_client_rs::protocol::{Notification as McpNotification, ErrorResponse as McpErrorResponse, ToolResult as McpToolResult};
    use uuid::Uuid;
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum McpClientEvent {
        McpNotificationReceived {
            server_id: String,
            interaction_id: Option<Uuid>, // Interne ID der AIInteractionContext
            notification: McpNotification,
        },
        McpToolCallSuccessful {
            server_id: String,
            interaction_id: Uuid,
            request_id: String, // Aus CallToolParams
            tool_result: McpToolResult,
        },
        McpRequestFailed {
            server_id: String,
            interaction_id: Option<Uuid>,
            request_id: Option<String>,
            error: McpErrorResponse, // Der MCP-Fehler
        },
        McpServerError { // Für Verbindungsfehler etc.
            server_id: String,
            message: String,
        },
        McpServerConnectionStateChanged {
            server_id: String,
            is_connected: bool,
        }
    }
    ```
    

#### 5.2. Untermodul: `system::mcp_client::errors`

**Datei:** `src/mcp_client/errors.rs`

- **Enum `McpSystemClientError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use mcp_client_rs::Error as McpLibError;
    use crate::dbus_interfaces::common::DBusInterfaceError; // Für Secrets Service Fehler
    
    #[derive(Debug, Error)]
    pub enum McpSystemClientError {
        #[error("MCP Server configuration not found for ID: {0}")]
        ServerConfigNotFound(String),
        #[error("Failed to start local MCP server (command: '{command}'): {source}")]
        LocalServerStartFailed {
            command: String,
            #[source]
            source: std::io::Error,
        },
        #[error("MCP client library error: {0}")]
        McpLibError(#[from] McpLibError),
        #[error("Failed to retrieve API key '{secret_name}' from secrets service: {source}")]
        ApiKeyRetrievalFailed {
            secret_name: String,
            #[source]
            source: DBusInterfaceError,
        },
        #[error("API key '{secret_name}' not found in secrets service.")]
        ApiKeyNotFound(String),
        #[error("MCP request timed out for request ID '{request_id}' to server '{server_id}'.")]
        RequestTimeout { server_id: String, request_id: String },
        #[error("MCP Server '{server_id}' is not connected or connection lost.")]
        ServerNotConnected(String),
        #[error("No active MCP server connection available.")]
        NoActiveConnection,
        #[error("Internal MCP client error: {0}")]
        InternalError(String),
    }
    ```
    

#### 5.3. Submodul: `system::mcp_client::connection_manager`

**Zweck:** Verwaltung von Verbindungen zu MCP-Servern (lokal oder remote), inklusive Starten lokaler Server.

**Datei:** `src/mcp_client/connection_manager.rs`

- **Struct `McpConnection`**:
    - **Felder:**
        - `server_id: String`
        - `client: mcp_client_rs::McpClient` (Der eigentliche Client aus dem Crate)
        - `local_process_handle: Option<tokio::process::Child>` (Für lokale Server)
        - `is_connected: Arc<tokio::sync::watch::Sender<bool>>`
    - **Methoden:**
        - `pub async fn new(config: &McpServerConfig, api_key: Option<String>) -> Result<Self, McpSystemClientError>`:
            1. Wenn `config.server_type` `LocalExecutable`:
                - Starte den Prozess mit `tokio::process::Command`. Speichere `Child` Handle.
                - `client = McpClient::connect_local_stdio(child_process_stdio).await?`
            2. Wenn `config.server_type` `RemoteHttp`:
                - `client = McpClient::connect_http(&config.endpoint_url, api_key).await?`
            3. Setze `is_connected` auf `true`.
        - `pub async fn close(&mut self)`: Schließt die Verbindung, beendet ggf. lokalen Prozess.
        - Getter für `client`.
- **Struct `McpConnectionManager`**:
    - **Felder:**
        - `connections: Arc<tokio::sync::Mutex<HashMap<String /* server_id */, Arc<McpConnection>>>>`
        - `server_configs: Arc<tokio::sync::RwLock<HashMap<String /* server_id */, McpServerConfig>>>` (Geladen aus `core::config` oder `GlobalSettingsService`)
        - `secrets_service: Arc<dyn crate::dbus_interfaces::secrets_service_client::SecretsServiceClient>` // Pfad anpassen
        - `event_publisher: tokio::sync::broadcast::Sender<McpClientEvent>`
    - **Konstruktor `new(...)`**: Nimmt `secrets_service` und `event_publisher`. Lädt `server_configs` initial.
    - **Methoden:**
        - `pub async fn load_server_configs(&self, configs: Vec<McpServerConfig>)`: Aktualisiert `self.server_configs`.
        - `pub async fn get_or_connect(&self, server_id: &str, ai_model_profile: Option<&crate::domain::user_centric_services::ai_interaction::types::AIModelProfile>) -> Result<Arc<McpConnection>, McpSystemClientError>`:
            1. Prüft, ob Verbindung in `connections` existiert und verbunden ist. Wenn ja, zurückgeben.
            2. Sucht `McpServerConfig` in `server_configs`. Wenn nicht -> `ServerConfigNotFound`.
            3. Wenn `config.server_type` `RemoteHttp` und `ai_model_profile.api_key_secret_name` gesetzt ist:
                - Rufe `self.secrets_service.retrieve_secret_by_label_or_item_path(...)` auf, um API-Key zu holen. Fehler bei Fehlschlag.
            4. Erstelle neue `McpConnection::new(&config, api_key)`.
            5. Speichere in `connections`.
            6. Starte einen Task, der auf Nachrichten/Notifications vom `mcp_connection.client.receive_message()` lauscht und `McpClientEvent`s publiziert.
            7. Sendet `McpServerConnectionStateChanged`.
        - `pub async fn disconnect(&self, server_id: &str) -> Result<(), McpSystemClientError>`: Schließt Verbindung, entfernt aus `connections`. Sendet `McpServerConnectionStateChanged`.
        - `pub async fn get_active_connection_for_model(&self, model_profile: &crate::domain::user_centric_services::ai_interaction::types::AIModelProfile) -> Result<Arc<McpConnection>, McpSystemClientError>`:
            - Bestimmt `server_id` basierend auf `model_profile` (z.B. wenn Profil eine `mcp_server_id` enthält oder ein Default verwendet wird).
            - Ruft `get_or_connect(server_id, Some(model_profile))`.

#### 5.4. Submodul: `system::mcp_client::service`

**Zweck:** Implementierung des `SystemMcpService` Traits, der die Abstraktion zur Domänenschicht darstellt.

**Datei:** `src/mcp_client/service.rs`

- **Trait `SystemMcpService`** (definiert, was die Domänenschicht vom MCP-Client erwartet):
    
    Rust
    
    ```
    use async_trait::async_trait;
    use super::types::*; // McpClientEvent, McpSystemClientError etc.
    use crate::domain::user_centric_services::ai_interaction::types::AIModelProfile;
    use uuid::Uuid;
    
    #[async_trait]
    pub trait SystemMcpService: Send + Sync {
        /// Initialisiert den MCP-Client mit Serverkonfigurationen.
        async fn configure_servers(&self, server_configs: Vec<McpServerConfig>) -> Result<(), McpSystemClientError>;
    
        /// Sendet eine `Initialize` Nachricht an einen spezifischen MCP-Server.
        async fn initialize_server(
            &self,
            server_id: &str,
            params: InitializeParams,
            model_profile: Option<&AIModelProfile>, // Für API-Key etc.
        ) -> Result<InitializeResult, McpSystemClientError>;
    
        /// Listet Ressourcen vom MCP-Server auf.
        async fn list_resources(
            &self,
            server_id: &str,
            params: ListResourcesParams,
            model_profile: Option<&AIModelProfile>,
            interaction_id: Option<Uuid>, // Für Event-Korrelation
        ) -> Result<ListResourcesResult, McpSystemClientError>;
    
        /// Ruft ein Tool auf dem MCP-Server auf.
        async fn call_tool(
            &self,
            server_id: &str,
            params: CallToolParams,
            model_profile: Option<&AIModelProfile>,
            interaction_id: Uuid, // Für Event-Korrelation und Timeout-Management
        ) -> Result<CallToolResult, McpSystemClientError>; // McpClient::call_tool gibt McpMessage zurück
    
        /// Abonniert MCP-Client-Events.
        fn subscribe_to_mcp_events(&self) -> tokio::sync::broadcast::Receiver<McpClientEvent>;
    }
    ```
    
- **Struct `DefaultSystemMcpService`**:
    - **Felder:** `connection_manager: Arc<McpConnectionManager>`.
    - **Konstruktor `new(connection_manager: Arc<McpConnectionManager>) -> Self`**.
    - **Implementierung von `SystemMcpService`**:
        - `configure_servers`: Ruft `connection_manager.load_server_configs()`.
        - `initialize_server`, `list_resources`, `call_tool`:
            1. `mcp_conn = self.connection_manager.get_or_connect(server_id, model_profile).await?;`
            2. `let client = &mcp_conn.client;`
            3. Erstelle `McpMessage` für die Anfrage.
            4. `response_message = client.send_request(request_message).await.map_err(McpSystemClientError::from)?;` (Timeout hier oder im `McpClient` Crate)
            5. Parse `response_message` in den erwarteten Ergebnistyp (z.B. `InitializeResult`). Bei Fehler `McpSystemClientError::McpLibError` oder spezifischer.
            6. Für `call_tool`, wenn erfolgreich, `McpToolCallSuccessful` Event senden (über `connection_manager.event_publisher`).
            7. Bei MCP-Fehlerantwort, `McpRequestFailed` Event senden.
        - `subscribe_to_mcp_events`: Gibt `connection_manager.event_publisher.subscribe()` zurück.

#### 5.5. `system::mcp_client::mod.rs`

- Deklariert Submodule.
- Re-exportiert `SystemMcpService`-Trait, `DefaultSystemMcpService` (als konkrete Implementierung), `McpClientEvent`, `McpSystemClientError`, `McpServerConfig`.

#### 5.6. Implementierungsschritte `system::mcp_client`

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml` für `mcp_client_rs`.
2. **`types.rs`**: `McpServerConfig`, `McpClientEvent`, ggf. Wrapper definieren.
3. **`errors.rs`**: `McpSystemClientError` definieren.
4. **`connection_manager.rs`**: `McpConnection`, `McpConnectionManager` implementieren. Logik zum Starten lokaler Server, API-Key-Abruf via `SecretsServiceClientService`. Task für `client.receive_message()` und Event-Publishing.
5. **`service.rs`**: `SystemMcpService`-Trait und `DefaultSystemMcpService`-Implementierung.
6. **Unit-Tests**:
    - Testen von `McpServerConfig`-Serialisierung.
    - Testen der `McpConnectionManager`-Logik (Mocking von `SecretsServiceClientService` und `mcp_client_rs::McpClient` falls möglich, oder Integrationstests gegen einen Dummy-MCP-Server).
    - Testen der `DefaultSystemMcpService`-Methoden (Mocking von `McpConnectionManager`).

---

### Modul 6: `system::window_mechanics`

Zweck: Technische Umsetzung des Fenstermanagements basierend auf den Richtlinien der Domänenschicht.

Verantwortlichkeiten:

- Empfangen von `WorkspaceWindowLayout` von `domain::window_management_policy`.
- Anwenden dieser Geometrien auf die tatsächlichen Fenster (`ManagedWindow`s im Compositor).
- Senden von `configure`-Events an Wayland-Clients, um sie über neue Größen/Zustände zu informieren.
- Handhabung interaktiver Operationen (Move/Resize-Grabs), Anwendung von Snapping.
- Koordination von Server-Side Decorations (SSD) und Client-Side Decorations (CSD) in Absprache mit `system::compositor::decoration` und der Domänen-Policy.
- Technische Umsetzung des Fokuswechsels basierend auf Domänenentscheidungen. **Design-Rationale:** Trennt die "Mechanik" (Wie wird ein Fenster bewegt/gegrößert?) von der "Policy" (Wohin soll es bewegt/gegrößert werden?). Enge Kopplung mit dem Compositor (`DesktopState::space`, `ManagedWindow`).

#### 6.1. Submodul: `system::window_mechanics::types`

**Datei:** `src/window_mechanics/types.rs`

- **Struct `InteractiveOpState`** (für laufende Move/Resize Grabs):
    
    Rust
    
    ```
    use smithay::utils::{Logical, Point, Rectangle, Serial};
    use crate::compositor::core::state::ManagedWindow; // Pfad anpassen
    use std::sync::Arc;
    
    #[derive(Debug, Clone)]
    pub enum InteractiveOpType { Move, ResizeEdge(xdg_toplevel::ResizeEdge), ResizeCorner(/* ... */) }
    
    #[derive(Debug, Clone)]
    pub struct InteractiveOpState {
        pub window_arc: Arc<ManagedWindow>, // Das Fenster, das bewegt/vergrößert wird
        pub op_type: InteractiveOpType,
        pub start_pointer_pos_global: Point<f64, Logical>,
        pub initial_window_geometry: Rectangle<i32, Logical>,
        pub last_configure_serial: Option<Serial>, // Um Configure-Storms zu vermeiden
        // Ggf. weitere Felder für Snapping-Feedback etc.
    }
    ```
    
- **Event (System-intern, via `system::event_bridge`):**
    
    Rust
    
    ```
    #[derive(Debug, Clone)]
    pub enum WindowMechanicsEvent {
        WindowConfigured { window_domain_id: DomainWindowIdentifier, new_geometry: RectInt, new_state_flags: u32 },
        InteractiveOpStarted(DomainWindowIdentifier, InteractiveOpType),
        InteractiveOpEnded(DomainWindowIdentifier, InteractiveOpType),
    }
    ```
    

#### 6.2. Submodul: `system::window_mechanics::errors`

**Datei:** `src/window_mechanics/errors.rs`

- **Enum `WindowMechanicsError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use crate::compositor::xdg_shell::errors::XdgShellError; // Pfad anpassen
    
    #[derive(Debug, Error)]
    pub enum WindowMechanicsError {
        #[error("Window not found for mechanics operation: {0:?}")]
        WindowNotFound(crate::domain::workspaces::core::types::WindowIdentifier),
        #[error("Failed to apply layout from domain policy: {0}")]
        LayoutApplicationFailed(String),
        #[error("Error during interactive operation (move/resize): {0}")]
        InteractiveOpFailed(String),
        #[error("XDG Shell operation failed during window mechanics: {0}")]
        XdgShellError(#[from] XdgShellError), // Wenn Configure-Sends etc. fehlschlagen
        #[error("Failed to acquire necessary lock for window operation.")]
        LockFailed,
        #[error("Internal window mechanics error: {0}")]
        InternalError(String),
    }
    ```
    

#### 6.3. Submodul: `system::window_mechanics::layout_applier`

**Zweck:** Anwenden eines von der Domäne berechneten Layouts.

**Datei:** `src/window_mechanics/layout_applier.rs`

- **Funktion `pub async fn apply_workspace_layout(desktop_state: &Arc<Mutex<DesktopState>>, workspace_id: WorkspaceId, layout: &WorkspaceWindowLayout) -> Result<(), WindowMechanicsError>`**:
    1. Sperre `desktop_state`.
    2. Für jede `(domain_window_id, target_geometry)` in `layout.window_geometries`:
        - Finde das `Arc<ManagedWindow>` in `desktop_state.windows` (oder `desktop_state.space`). Wenn nicht: `WindowMechanicsError::WindowNotFound`.
        - `let mut window_guard = managed_window_arc.lock_blocking();` (Oder `async` Lock, wenn `ManagedWindow` selbst einen `async` Mutex hat. Hier Annahme: `ManagedWindow` ist `desktop::Window`, das intern ggf. synchron ist oder dessen `send_configure` etc. synchron sind).
        - **Geometrie setzen:** `window_guard.current_geometry = target_geometry;`
        - **Größe/Status an Client senden:**
            - `if let WindowSurface::Toplevel(toplevel_surface) = &window_guard.xdg_surface { ... }`
            - `toplevel_surface.with_pending_state(|state| { state.size = Some(target_geometry.size); /* state.maximized, .fullscreen etc. basierend auf Layout-Anforderungen setzen */ });`
            - `toplevel_surface.send_configure();` (Dies sendet `xdg_surface.configure` und `xdg_toplevel.configure`).
        - Ggf. `WindowMechanicsEvent::WindowConfigured` senden.
    3. Für Fenster, die im alten Layout waren, aber nicht im neuen (d.h. geschlossen oder auf anderen Workspace verschoben): `desktop_state.space.unmap_window(...)`.
    4. Für neue Fenster im Layout (noch nicht im Space): `desktop_state.space.map_window(...)`.
    5. `desktop_state.space.damage_all_outputs();` (Oder spezifischerer Schaden).

#### 6.4. Submodul: `system::window_mechanics::interactive_ops`

**Zweck:** Handhabung von interaktiven Fenster-Moves und -Resizes.

**Datei:** `src/window_mechanics/interactive_ops.rs`

- **Funktionen zum Starten von Grabs (aufgerufen von `XdgShellHandler` in `system::compositor`):**
    - `pub fn start_interactive_move(desktop_state: &Arc<Mutex<DesktopState>>, seat: &Seat<DesktopState>, window_arc: Arc<ManagedWindow>, serial: Serial, start_pointer_pos: Point<f64, Logical>)`
    - `pub fn start_interactive_resize(desktop_state: &Arc<Mutex<DesktopState>>, seat: &Seat<DesktopState>, window_arc: Arc<ManagedWindow>, serial: Serial, edge: xdg_toplevel::ResizeEdge, start_pointer_pos: Point<f64, Logical>)`
    - **Logik:**
        1. Erstelle `InteractiveOpState`.
        2. `seat.start_pointer_grab(...)` mit einem spezifischen `PointerGrabStartData` und einem `PointerGrab` Handler.
        3. Der `PointerGrab` Handler:
            - **`motion(...)`**:
                - Berechne neue Geometrie basierend auf `delta` und `InteractiveOpState`.
                - Rufe `domain::window_management_policy_service.calculate_snap_target(...)` auf, um Snapping anzuwenden.
                - Aktualisiere `window_arc.lock_blocking().current_geometry` (vorläufig, ohne Configure).
                - Optional: Zeige visuelles Feedback (z.B. Umriss des Fensters an neuer Position – dies ist Renderer-Aufgabe).
            - **`button(...)`**: Wenn Maustaste losgelassen:
                - Finalisiere Geometrie.
                - Sende `configure` an Client (via `window_arc.xdg_surface.toplevel().send_configure()`).
                - Beende den Grab (`pointer_handle.unset_grab()`).
                - Sende `WindowMechanicsEvent::InteractiveOpEnded`.
            - **`axis(...)`**: Ignorieren während Grab.
            - **`cancel(...)`**: Grab abbrechen, Fenster auf `initial_window_geometry` zurücksetzen.

#### 6.5. Submodul: `system::window_mechanics::focus_manager`

**Zweck:** Technische Umsetzung des Fokuswechsels.

**Datei:** `src/window_mechanics/focus_manager.rs`

- **Funktion `pub async fn set_application_focus(desktop_state: &Arc<Mutex<DesktopState>>, seat_name: &str, window_domain_id_to_focus: Option<&DomainWindowIdentifier>, serial: Serial)`**:
    1. Sperre `desktop_state`.
    2. Finde das `Arc<ManagedWindow>` für `window_domain_id_to_focus` (oder `None`).
    3. Rufe `system::input::keyboard::focus::set_keyboard_focus(desktop_state_guard, seat_name, target_wl_surface_option, serial)`.
    4. Aktualisiere `desktop_state_guard.active_input_surface`.
    5. Wenn `target_wl_surface_option` ein Toplevel ist: `target_toplevel.set_activated(true); target_toplevel.send_configure();`
    6. Für den vorherigen Fokus: `old_toplevel.set_activated(false); old_toplevel.send_configure();`
    7. Ggf. Fenster im `Space` anheben (`desktop_state_guard.space.raise_window(...)`).

#### 6.6. Implementierungsschritte `system::window_mechanics`

1. `types.rs`, `errors.rs` definieren.
2. `layout_applier.rs`: `apply_workspace_layout` implementieren.
3. `interactive_ops.rs`: Logik für Start und Handling von Pointer-Grabs für Move/Resize.
4. `focus_manager.rs`: `set_application_focus` implementieren.
5. Tests: Mocking von `DesktopState` (schwierig), `DomainWindowManagementPolicyService`. Testen der Geometrieanwendung. Testen der Grab-Logik (Zustandsübergänge).

---

### Modul 7: `system::power_management`

Zweck: Implementierung von DPMS und Interaktion mit Power-Management-Protokollen/Diensten.

Verantwortlichkeiten: Überwachen der Benutzeraktivität und System-Idle-Hinweise, Anwenden von Energieeinstellungen (Bildschirm-Timeout, Suspend-Verhalten) von der Domänenschicht, Steuerung des DPMS-Zustands von Bildschirmen.

Design-Rationale: Zentralisierung der Energieverwaltungslogik, die sowohl auf Benutzereingaben als auch auf Systemzustände reagiert.

#### 7.1. Untermodul: `system::power_management::types`

**Datei:** `src/power_management/types.rs`

- **Enum `DpmsState`**: `On, Standby, Suspend, Off`.
- **Event (System-intern, via `system::event_bridge`):**
    
    Rust
    
    ```
    #[derive(Debug, Clone)]
    pub enum PowerManagementEvent {
        OutputDpmsStateChanged { output_name: String, new_state: DpmsState },
        SystemSuspending(crate::dbus_interfaces::logind_client::types::LogindPowerOperation), // Pfad anpassen
        SystemResumed,
    }
    ```
    
- **Struct `IdleTimerState`**: `last_activity_ts: DateTime<Utc>`, `current_timeout_secs: u32`, `timer_handle: Option<calloop::TimerHandle>`.

#### 7.2. Untermodul: `system::power_management::errors`

**Datei:** `src/power_management/errors.rs`

- **Enum `PowerManagementError`**:
    
    Rust
    
    ```
    #[derive(Debug, Error)]
    pub enum PowerManagementError {
        #[error("Failed to set DPMS state for output '{output_name}': {reason}")]
        SetDpmsFailed { output_name: String, reason: String },
        #[error("Logind operation failed: {0}")]
        LogindError(#[from] crate::dbus_interfaces::common::DBusInterfaceError), // Pfad anpassen
        #[error("Failed to interact with compositor output management: {0}")]
        CompositorOutputError(String),
        #[error("Internal power management error: {0}")]
        InternalError(String),
    }
    ```
    

#### 7.3. Submodul: `system::power_management::service`

**Zweck:** Hauptlogik des Power-Management-Dienstes.

**Datei:** `src/power_management/service.rs`

- **Struct `PowerManagementService`**:
    - **Felder:**
        - `desktop_state_weak: Weak<Mutex<DesktopState>>` (oder direkter Zugriff, falls in `DesktopState` integriert)
        - `settings_service: Arc<dyn GlobalSettingsService>`
        - `logind_service: Arc<dyn LogindClientService>` // Annahme, dass LogindClientService ein Trait ist
        - `event_publisher: tokio::sync::broadcast::Sender<PowerManagementEvent>`
        - `user_activity_receiver: tokio::sync::broadcast::Receiver<UserActivityDetectedEvent>` (aus `common_events`)
        - `logind_event_receiver: tokio::sync::broadcast::Receiver<LogindEvent>`
        - `output_idle_timers: Arc<tokio::sync::Mutex<HashMap<String /* output_name */, IdleTimerState>>>`
        - `system_idle_timer: Arc<tokio::sync::Mutex<Option<IdleTimerState>>>` // Für automatischen Suspend
    - **Konstruktor `new(...)`**: Nimmt Abhängigkeiten, abonniert `UserActivityDetectedEvent` und `LogindEvent`.
    - **Methode `pub async fn run(&self)`**: Hauptschleife des Dienstes (läuft als `tokio::task`).
        1. Lädt initiale Energieeinstellungen vom `settings_service`.
        2. Startet Listener für `SettingChangedEvent` (um Energieeinstellungen neu zu laden).
        3. Verarbeitet eingehende `UserActivityDetectedEvent`: Setzt alle Idle-Timer zurück.
        4. Verarbeitet eingehende `LogindEvent::PrepareForSleep/Shutdown`: Führt Aktionen aus (z.B. DPMS Off).
        5. Verarbeitet `LogindEvent::SystemIdleHintChanged`.
        6. Periodisch (oder bei Timer-Ablauf):
            - Prüft `output_idle_timers`. Wenn Timeout erreicht: Setze DPMS-Status des Outputs (via Compositor/DRM-Backend). Sendet `OutputDpmsStateChanged`.
            - Prüft `system_idle_timer`. Wenn Timeout erreicht: Rufe `self.logind_service.suspend(false)` oder `hibernate(false)` auf, basierend auf Policy.
    - **Private Methoden:**
        - `async fn reset_idle_timers(&self, current_settings: &PowerManagementPolicySettings)`
        - `async fn apply_dpms_state(&self, output_name: &str, dpms_state: DpmsState)`: Interagiert mit `system::compositor::output_management` (oder direkt DRM-Backend), um DPMS zu setzen.
        - `async fn on_screen_blank_timeout(&self, output_name: &str, current_settings: &PowerManagementPolicySettings)`
        - `async fn on_system_suspend_timeout(&self, current_settings: &PowerManagementPolicySettings)`

#### 7.4. Implementierungsschritte `system::power_management`

1. `types.rs`, `errors.rs` definieren.
2. `service.rs`: `PowerManagementService` implementieren.
    - Event-Loops für `UserActivityDetectedEvent` und `LogindEvent`.
    - Logik für Idle-Timer-Management mit `calloop::Timer` (muss mit `tokio` synchronisiert werden, wenn Service `async` ist, z.B. Timer in `calloop`-Schleife, der Nachricht an `tokio`-Task sendet).
    - Interaktion mit `GlobalSettingsService` für Policies.
    - Interaktion mit `LogindClientService` für Suspend/Hibernate.
    - Interaktion mit Compositor (Output-Management) für DPMS.
3. Tests: Mocking von Abhängigkeiten, Testen der Timer-Logik und Zustandsübergänge.

---

### Modul 8: `system::event_bridge`

Zweck: Eine zentrale Stelle für System-interne Events, die nicht direkt an einen spezifischen D-Bus-Dienst oder ein Wayland-Protokoll gebunden sind. Dient der Entkopplung innerhalb der Systemschicht und als definierte Quelle für bestimmte Domänen-Events.

Verantwortlichkeiten: Definition von generischen System-Event-Typen. Bereitstellung von tokio::sync::broadcast Kanälen für diese Events.

Design-Rationale: Verhindert direkte Abhängigkeiten zwischen allen Systemmodulen. Ermöglicht es Modulen, relevante Ereignisse zu publizieren, ohne ihre Konsumenten explizit kennen zu müssen.

**Datei:** `src/event_bridge/mod.rs` (kann `types.rs` und `channels.rs` enthalten)

- **Struct `SystemEventBridge`**:
    - **Felder (Beispiele für `broadcast::Sender`):**
        - `upower_event_tx: tokio::sync::broadcast::Sender<UPowerEvent>`
        - `logind_event_tx: tokio::sync::broadcast::Sender<LogindEvent>`
        - `network_manager_event_tx: tokio::sync::broadcast::Sender<NetworkManagerEvent>`
        - `audio_event_tx: tokio::sync::broadcast::Sender<AudioEvent>`
        - `mcp_client_event_tx: tokio::sync::broadcast::Sender<McpClientEvent>`
        - `window_mechanics_event_tx: tokio::sync::broadcast::Sender<WindowMechanicsEvent>`
        - `power_management_event_tx: tokio::sync::broadcast::Sender<PowerManagementEvent>`
        - `input_device_hotplug_event_tx: tokio::sync::broadcast::Sender<InputDeviceHotplugEvent>`
        - **Domänen-Events, die von der Systemschicht ausgelöst werden:**
        - `user_activity_event_tx: tokio::sync::broadcast::Sender<crate::domain::common_events::UserActivityDetectedEvent>`
        - `system_shutdown_event_tx: tokio::sync::broadcast::Sender<crate::domain::common_events::SystemShutdownInitiatedEvent>`
    - **Konstruktor `new(capacity_per_channel: usize) -> Self`**: Initialisiert alle Sender.
    - **Methoden zum Abrufen von `Receiver`n**:
        - `pub fn subscribe_upower_events(&self) -> tokio::sync::broadcast::Receiver<UPowerEvent>` (analog für alle anderen).
    - **Methoden zum Senden von Events (intern von anderen Systemmodulen genutzt):**
        - `pub(crate) fn publish_upower_event(&self, event: UPowerEvent)` (analog).
- **Event-Typen (Beispiele, falls noch nicht in spezifischen Modulen definiert):**
    - `InputDeviceHotplugEvent { device_name: String, device_type: String /* z.B. "keyboard", "pointer" */, event_type: HotplugType /* Added, Removed */}`
    - Die meisten spezifischen Events (`UPowerEvent`, `LogindEvent` etc.) werden in ihren jeweiligen Modulen (`system::dbus_interfaces::upower_client::types`) definiert und hier nur die Sender verwaltet.

**Implementierungsschritte `system::event_bridge`**:

1. `SystemEventBridge`-Struktur definieren.
2. Konstruktor und `subscribe_`/`publish_`-Methoden implementieren.
3. Sicherstellen, dass alle Systemmodule, die Events publizieren oder konsumieren, eine Referenz (`Arc`) zum `SystemEventBridge` erhalten (z.B. bei der Initialisierung von `DesktopState` oder der Systemschicht).

---

Diese detaillierten Pläne für die Module 3 (Vervollständigung) bis 8 der Systemschicht bilden eine solide Grundlage für die Implementierung. Die Komplexität liegt weiterhin in der korrekten asynchronen Integration, der Interaktion mit externen Bibliotheken/Protokollen und der robusten Fehlerbehandlung.

---

### Modul 5: `system::mcp_client`

Zweck: Implementierung des Clients für das Model Context Protocol (MCP), um sicher mit lokalen oder Cloud-basierten KI-Modellen (LLMs) zu interagieren.

Verantwortlichkeiten:

- Aufbau und Verwaltung der Verbindung zu einem MCP-Server.
- Senden von Anfragen an den MCP-Server (z.B. `Initialize`, `ListResources`, `CallTool`) basierend auf Anweisungen von `domain::user_centric_services::ai_interaction`.
- Empfangen von Antworten und asynchronen Benachrichtigungen (`Notification`) vom MCP-Server.
- Sichere Handhabung von API-Schlüsseln (via `system::dbus_interfaces::secrets_service_client`) für Cloud-basierte Modelle.
- Bereitstellung einer abstrahierten Schnittstelle (`SystemMcpService`-Trait) für die Domänenschicht. **Design-Rationale:** Kapselung der MCP-spezifischen Kommunikationslogik. Nutzung des `mcp_client_rs` Crates als Basis. Ermöglichung einer flexiblen Anbindung verschiedener KI-Modelle. **Technologie:** `mcp_client_rs` Crate, `tokio` für asynchrone Operationen, `serde` für Datenstrukturen.

**Abhängigkeiten in `novade-system/Cargo.toml` (zusätzlich):**

Ini, TOML

```
mcp_client_rs = "0.2.0" # Aktuelle Version des mcp_client_rs Crates prüfen
# ggf. http_types oder reqwest, falls RemoteHttp direkt implementiert wird und mcp_client_rs dies nicht vollständig abstrahiert
```

#### 5.1. Untermodul: `system::mcp_client::types`

**Datei:** `src/mcp_client/types.rs`

- **Struct `McpServerConfig`**:
    
    - **Definition:** Wie in der vorherigen Antwort (Teil 4 der Systemschicht-Spezifikation).
        
        Rust
        
        ```
        use serde::{Serialize, Deserialize};
        use std::path::PathBuf; // Für working_directory
        
        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
        pub enum McpServerType {
            LocalExecutable {
                command: String,
                args: Vec<String>,
                #[serde(default, skip_serializing_if = "Option::is_none")]
                working_directory: Option<PathBuf>, // PathBuf verwenden
            },
            RemoteHttp {
                endpoint_url: String,
            },
        }
        
        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
        pub struct McpServerConfig {
            pub server_id: String,
            pub server_type: McpServerType,
            #[serde(default = "default_request_timeout_ms_config")]
            pub default_request_timeout_ms: u64,
        }
        
        fn default_request_timeout_ms_config() -> u64 { 30000 } // 30 Sekunden
        
        impl Default for McpServerConfig { /* ... */ } // Sinnvoller Default, z.B. für einen häufig genutzten lokalen Server
        ```
        
- **Re-Export von `mcp_client_rs::protocol` Typen:**
    
    Rust
    
    ```
    pub use mcp_client_rs::protocol::{
        InitializeParams, InitializeResult, ListResourcesParams, ListResourcesResult,
        Resource, ToolDefinition, CallToolParams, CallToolResult, ToolCall, ToolResult,
        McpMessage, Notification as McpProtocolNotification, ErrorResponse, ErrorCode,
        // Weitere benötigte Typen aus dem Protokoll
    };
    ```
    
- **Event-Struktur (für `system::event_bridge` oder direkt an Domäne):**
    
    Rust
    
    ```
    use uuid::Uuid;
    // McpProtocolNotification, McpErrorResponse, McpToolResult sind bereits oben re-exportiert
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum McpClientSystemEvent { // Umbenannt von McpClientEvent zur Unterscheidung von Domain-Events
        McpNotificationReceived {
            server_id: String,
            interaction_id: Option<Uuid>,
            notification: McpProtocolNotification,
        },
        McpToolCallSuccessful {
            server_id: String,
            interaction_id: Uuid,
            request_id: String,
            tool_result: McpToolResult,
        },
        McpRequestFailed { // Wenn die Anfrage den Server erreicht hat, aber dieser einen Fehler zurückgibt
            server_id: String,
            interaction_id: Option<Uuid>,
            request_id: Option<String>,
            error: McpErrorResponse,
        },
        McpCommunicationError { // Für Verbindungsfehler, Timeouts etc. vor/während der Anfrage
            server_id: String,
            interaction_id: Option<Uuid>,
            request_id: Option<String>,
            message: String, // Detailliertere Fehlermeldung des Clients
        },
        McpServerConnectionStateChanged {
            server_id: String,
            is_connected: bool,
            error_message: Option<String>, // Grund für Disconnect
        }
    }
    ```
    

#### 5.2. Untermodul: `system::mcp_client::errors`

**Datei:** `src/mcp_client/errors.rs`

- **Enum `McpSystemClientError`**:
    
    - **Definition:** Wie in der vorherigen Antwort, aber `McpLibError` wird differenzierter behandelt. <!-- end list -->
    
    Rust
    
    ```
    use thiserror::Error;
    use mcp_client_rs::Error as McpLibInternalError; // Interner Fehler des mcp_client_rs Crates
    use crate::dbus_interfaces::common::DBusInterfaceError; // Für Secrets Service Fehler
    use super::types::ErrorResponse as McpErrorResponse; // MCP Protokoll-Fehler
    
    #[derive(Debug, Error)]
    pub enum McpSystemClientError {
        #[error("MCP Server configuration not found for ID: {0}")]
        ServerConfigNotFound(String),
        #[error("Failed to start local MCP server (command: '{command}'): {source}")]
        LocalServerStartFailed { command: String, #[source] source: std::io::Error },
        #[error("MCP client library internal error: {0}")]
        McpLibInternalError(#[from] McpLibInternalError),
        #[error("MCP server returned an error: {error_code:?} - {message}")]
        McpServerErrorReply { error_code: mcp_client_rs::protocol::ErrorCode, message: String, diagnostic_info: Option<String> }, // Von McpErrorResponse
        #[error("Failed to retrieve API key '{secret_name}' from secrets service: {source}")]
        ApiKeyRetrievalFailed { secret_name: String, #[source] source: DBusInterfaceError },
        #[error("API key '{secret_name}' not found in secrets service.")]
        ApiKeyNotFound(String),
        #[error("MCP request timed out for request ID '{request_id}' to server '{server_id}'.")]
        RequestTimeout { server_id: String, request_id: String },
        #[error("MCP Server '{server_id}' is not connected or connection lost.")]
        ServerNotConnected(String),
        #[error("No active MCP server connection available for the request.")]
        NoActiveConnection,
        #[error("Failed to serialize MCP request: {0}")]
        SerializationError(#[from] serde_json::Error), // Falls wir manuell serialisieren
        #[error("Failed to deserialize MCP response: {0}")]
        DeserializationError(serde_json::Error), // Falls wir manuell deserialisieren
        #[error("Unsupported MCP server type: {0:?}")]
        UnsupportedServerType(super::types::McpServerType),
        #[error("Internal MCP client error: {0}")]
        InternalError(String),
    }
    
    // Konvertierung von McpErrorResponse zu McpSystemClientError
    impl From<McpErrorResponse> for McpSystemClientError {
        fn from(err_resp: McpErrorResponse) -> Self {
            McpSystemClientError::McpServerErrorReply {
                error_code: err_resp.error.code,
                message: err_resp.error.message,
                diagnostic_info: err_resp.error.data.and_then(|v| serde_json::to_string(&v).ok()),
            }
        }
    }
    ```
    

#### 5.3. Untermodul: `system::mcp_client::connection_manager`

**Zweck:** Verwaltung von Verbindungen zu MCP-Servern.

**Datei:** `src/mcp_client/connection_manager.rs`

- **Struct `McpConnection`**:
    - **Felder:** Wie in der vorherigen Antwort.
        - `server_id: String`
        - `client: mcp_client_rs::McpClient`
        - `local_process_handle: Arc<tokio::sync::Mutex<Option<tokio::process::Child>>>` (Arc&lt;Mutex&lt;Option&lt;...>>> damit der Listener-Task den Prozess ggf. beenden kann)
        - `is_connected_state: Arc<tokio::sync::watch::Sender<bool>>` (Sender, damit der Manager den Status setzen kann)
        - `notification_task_handle: Option<tokio::task::JoinHandle<()>>` (Für den Task, der `client.receive_message()` lauscht)
    - **Methoden:**
        - **`pub async fn new(config: &McpServerConfig, api_key: Option<String>, event_publisher_clone: tokio::sync::broadcast::Sender<McpClientSystemEvent>, server_id_clone: String) -> Result<Self, McpSystemClientError>`**:
            1. `is_connected_state_tx = Arc::new(tokio::sync::watch::channel(false).0);`
            2. Wenn `LocalExecutable`: Starte Prozess, `client = McpClient::attach_stdio(child_process.stdin.take().unwrap(), child_process.stdout.take().unwrap()).await?`.
            3. Wenn `RemoteHttp`: `client = McpClient::connect_http(&config.endpoint_url, api_key).await?`.
            4. Setze `is_connected_state_tx.send(true).ok();`.
            5. Starte `notification_task`:
                
                Rust
                
                ```
                let client_clone = client.clone(); // McpClient muss Clone sein
                let is_connected_state_clone = is_connected_state_tx.clone();
                let publisher_clone = event_publisher_clone;
                let s_id_clone = server_id_clone;
                
                let handle = tokio::spawn(async move {
                    loop {
                        match client_clone.receive_message().await {
                            Ok(Some(McpMessage::Notification(notification))) => {
                                publisher_clone.send(McpClientSystemEvent::McpNotificationReceived {
                                    server_id: s_id_clone.clone(),
                                    interaction_id: None, // Muss aus Notification-Payload extrahiert werden, falls vorhanden
                                    notification,
                                }).ok();
                            }
                            Ok(Some(McpMessage::Response { .. })) => {
                                tracing::warn!("Unerwartete Response im Notification-Stream von MCP Server {}", s_id_clone);
                            }
                            Ok(None) => { // Stream beendet (Verbindung geschlossen)
                                tracing::info!("MCP Notification-Stream für Server {} beendet.", s_id_clone);
                                is_connected_state_clone.send(false).ok();
                                publisher_clone.send(McpClientSystemEvent::McpServerConnectionStateChanged {
                                    server_id: s_id_clone.clone(),
                                    is_connected: false,
                                    error_message: Some("Connection closed by server or stream ended.".to_string()),
                                }).ok();
                                break;
                            }
                            Err(e) => {
                                tracing::error!("Fehler beim Empfangen der MCP Notification von Server {}: {:?}", s_id_clone, e);
                                is_connected_state_clone.send(false).ok();
                                publisher_clone.send(McpClientSystemEvent::McpServerConnectionStateChanged {
                                    server_id: s_id_clone.clone(),
                                    is_connected: false,
                                    error_message: Some(format!("Receive error: {}", e)),
                                }).ok();
                                break;
                            }
                        }
                    }
                });
                ```
                
            6. Return `Self { ..., notification_task_handle: Some(handle), ... }`.
        - **`pub async fn close(&mut self)`**:
            1. `self.is_connected_state.send(false).ok();`
            2. `self.client.close().await;` (Wenn `McpClient` eine `close`-Methode hat).
            3. Wenn `notification_task_handle.take().is_some()`, `handle.abort();` (oder sanfter beenden).
            4. Wenn `local_process_handle.lock().await.take().is_some()`, `child.kill().await?`.
- **Struct `McpConnectionManager`**:
    - **Felder:** Wie in der vorherigen Antwort.
    - **Methoden:**
        - `load_server_configs` (wie zuvor).
        - `get_or_connect`:
            1. Prüft `connections` Cache. Wenn verbunden (`is_connected_state.borrow() == true`), zurückgeben.
            2. API-Key-Abruf via `secrets_service`.
            3. `McpConnection::new(...)` aufrufen.
            4. Verbindung in `connections` speichern.
            5. `event_publisher.send(McpServerConnectionStateChanged { is_connected: true, ... })`.
        - `disconnect` (wie zuvor, ruft `McpConnection::close()`).
        - `get_active_connection_for_model` (wie zuvor).

#### 5.4. Submodul: `system::mcp_client::service`

**Zweck:** Implementierung des `SystemMcpService` Traits.

**Datei:** `src/mcp_client/service.rs`

- **Trait `SystemMcpService`**: Wie in der vorherigen Antwort.
- **Struct `DefaultSystemMcpService`**:
    - **Felder:** `connection_manager: Arc<McpConnectionManager>`.
    - **Implementierung von `SystemMcpService`**:
        - **`initialize_server`, `list_resources`, `call_tool`**:
            1. `mcp_conn_arc = self.connection_manager.get_or_connect(server_id, model_profile).await?;`
            2. `let mcp_conn_guard = mcp_conn_arc; // Arc kann direkt verwendet werden, McpClient ist Clone`
            3. `let client_ref = &mcp_conn_guard.client;`
            4. Timeout erstellen: `tokio::time::timeout(Duration::from_millis(timeout_ms), client_ref.send_request_json(mcp_protocol_message)).await`
                - Wenn `Ok(Ok(response_message))`: Verarbeite `response_message`.
                - Wenn `Ok(Err(mcp_lib_err))`: `Err(McpSystemClientError::McpLibInternalError(mcp_lib_err))`.
                - Wenn `Err(_timeout_err)`: `Err(McpSystemClientError::RequestTimeout { ... })`.
            5. Wenn `response_message` eine `McpMessage::Error(err_resp)` ist:
                - `self.connection_manager.event_publisher.send(McpClientSystemEvent::McpRequestFailed { ..., error: err_resp.clone() }).ok();`
                - `Err(McpSystemClientError::from(err_resp))`
            6. Sonst: Parse Response in den erwarteten Typ (z.B. `InitializeResult`). Bei Erfolg, `McpToolCallSuccessful` Event senden (für `call_tool`).
        - **`subscribe_to_mcp_events`**: `self.connection_manager.event_publisher.subscribe()`.

#### 5.5. Implementierungsschritte `system::mcp_client`

(Wie in vorheriger Antwort, aber mit Fokus auf `tokio::sync::Mutex/RwLock/watch`, `tokio::process` und `tokio::task` für asynchrone Operationen und den Notification-Listener-Task in `McpConnection`.)

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml` anpassen.
2. **`types.rs`**: `McpServerConfig` (mit `PathBuf`), `McpClientSystemEvent`, Protokoll-Typen re-exportieren.
3. **`errors.rs`**: `McpSystemClientError` (mit detaillierter Fehlerbehandlung für `McpLibInternalError` und `McpErrorResponse`).
4. **`connection_manager.rs`**:
    - `McpConnection`: `new` implementieren (Prozessstart, Verbindung, Notification-Listener-Task). `close` implementieren.
    - `McpConnectionManager`: `new`, `load_server_configs`, `get_or_connect` (mit API-Key-Abruf), `disconnect`, `get_active_connection_for_model`.
5. **`service.rs`**: `SystemMcpService`-Trait und `DefaultSystemMcpService`-Implementierung. Timeout-Logik für Anfragen. Korrektes Event-Publishing.
6. **`mod.rs`**: API re-exportieren.
7. **Unit-/Integrationstests**:
    - Mocking für `SecretsServiceClientService`.
    - Testen der lokalen Prozessstart- und Managementlogik.
    - Für HTTP-Verbindungen: Testen gegen einen einfachen Mock-MCP-HTTP-Server.
    - Testen der Timeout-Logik.
    - Testen des Notification-Listener-Tasks (Senden von Dummy-Notifications).

---

### Modul 6: `system::window_mechanics`

Zweck: Technische Umsetzung des Fenstermanagements (Positionierung, Größe, Stapelreihenfolge, Tiling, Fokus, Dekorationen) basierend auf Domänen-Policies.

Verantwortlichkeiten: Anwenden von WorkspaceWindowLayout auf Compositor-Fenster, Senden von configure-Events, Handhabung interaktiver Operationen (Move/Resize), Koordination von SSD/CSD, technische Fokusumsetzung.

Design-Rationale: Trennung von "Mechanik" und "Policy". Enge Kopplung mit system::compositor und domain::window_management_policy.

#### 6.1. Untermodul: `system::window_mechanics::types`

**Datei:** `src/window_mechanics/types.rs`

- **Struct `InteractiveOpState`**: Wie in der vorherigen Antwort.
    
    Rust
    
    ```
    use smithay::{
        utils::{Logical, Point, Rectangle, Serial},
        reexports::wayland_protocols::xdg::shell::server::xdg_toplevel::ResizeEdge,
    };
    use crate::compositor::xdg_shell::types::ManagedWindow; // Pfad anpassen
    use std::sync::Arc;
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum InteractiveOpType { Move, Resize(ResizeEdge) } // ResizeEdge aus xdg_toplevel
    
    #[derive(Debug, Clone)]
    pub struct InteractiveOpState {
        pub window_arc: Arc<ManagedWindow>, // Smithay's Window Trait-Objekt
        pub op_type: InteractiveOpType,
        pub start_pointer_pos_global: Point<f64, Logical>, // Globale Position beim Start des Grabs
        pub initial_window_geometry: Rectangle<i32, Logical>, // Geometrie des Fensters beim Start des Grabs
        pub last_configure_serial: Option<Serial>, // Um Configure-Storms zu vermeiden
        // Für Resize:
        pub initial_window_size_constraints: Option<(Option<Size<i32, Logical>>, Option<Size<i32, Logical>>)>, // (min_size, max_size)
    }
    ```
    
- **Event (System-intern, via `system::event_bridge`):**
    
    Rust
    
    ```
    use crate::domain::workspaces::core::types::WindowIdentifier as DomainWindowIdentifier;
    use crate::core::types::RectInt; // Aus novade-core
    use smithay::wayland::shell::xdg::ToplevelState; // Beispiel für Zustandsflags
    
    #[derive(Debug, Clone)]
    pub enum WindowMechanicsEvent {
        WindowConfiguredByMechanics { // Unterscheidung von Client-initiiertem Configure
            window_domain_id: DomainWindowIdentifier,
            new_geometry: RectInt, // Die tatsächlich angewendete Geometrie
            new_state: Vec<ToplevelState>, // z.B. Maximized, Activated etc.
        },
        InteractiveOpStarted { window_domain_id: DomainWindowIdentifier, op_type: InteractiveOpType },
        InteractiveOpEnded { window_domain_id: DomainWindowIdentifier, op_type: InteractiveOpType, final_geometry: RectInt },
        FocusSetByMechanics(Option<DomainWindowIdentifier>), // Wenn der Fokus durch Mechanics geändert wurde
    }
    ```
    

#### 6.2. Untermodul: `system::window_mechanics::errors`

**Datei:** `src/window_mechanics/errors.rs`

- **Enum `WindowMechanicsError`**: Wie in der vorherigen Antwort.
    - Zusätzlich: `#[error("Window {0:?} does not support the requested operation (e.g., trying to resize a non-resizable window).")] WindowOperationNotSupported(DomainWindowIdentifier)`

#### 6.3. Untermodul: `system::window_mechanics::layout_applier`

**Zweck:** Anwenden eines von der Domäne berechneten Layouts.

**Datei:** `src/window_mechanics/layout_applier.rs`

- **Funktion `pub async fn apply_workspace_layout(desktop_state_accessor: &impl Fn() -> Arc<Mutex<DesktopState>>, workspace_id: WorkspaceId, layout: &WorkspaceWindowLayout) -> Result<(), WindowMechanicsError>`**:
    
    - **Annahme:** `DesktopStateAccessor` ist ein Weg, um Zugriff auf `DesktopState` zu bekommen, da `DesktopState` selbst nicht einfach `Send` sein könnte für `async fn`. Einfacher: Wenn `apply_workspace_layout` von einem Ort aufgerufen wird, der bereits Zugriff auf `&mut DesktopState` hat (z.B. innerhalb eines `calloop` Callbacks oder eines `tokio::task::block_in_place`), dann kann es synchron sein. Für die Spezifikation nehmen wir an, dass es irgendwie Zugriff bekommt.
    - **Alternative (synchron, wenn im Compositor-Thread):** `pub fn apply_workspace_layout_blocking(desktop_state: &mut DesktopState, workspace_id: WorkspaceId, layout: &WorkspaceWindowLayout) -> Result<(), WindowMechanicsError>` <!-- end list -->
    
    1. `tracing::debug!("Wende Layout für Workspace {:?} an: {:?}", workspace_id, layout);`
    2. `let space = &mut desktop_state.space;`
    3. `let windows_map = &mut desktop_state.windows;` // Map von DomainWindowIdentifier zu Arc&lt;ManagedWindow>
    4. Für jede `(domain_id, target_geometry)` in `layout.window_geometries`:
        - `let managed_window_arc = match windows_map.get(&domain_id) { Some(w) => w.clone(), None => { tracing::warn!("Fenster {:?} im Layout nicht in DesktopState gefunden.", domain_id); continue; } };`
        - `let mut managed_window_ref = (*managed_window_arc).clone(); // Klone Arc für Smithay-Window-Trait-Methoden, wenn ManagedWindow selbst nicht Mutex-geschützt ist.`
        - `managed_window_ref.current_geometry = target_geometry;` // Internen Zustand aktualisieren
        - **Senden der Konfiguration an den Client (Beispiel für Toplevel):**
            - `if let WindowSurface::Toplevel(toplevel) = &managed_window_ref.xdg_surface { ... }`
            - `let mut new_xdg_states = Vec::new();`
            - // Logik, um layout.tiling_mode_applied in XDG-Zustände zu übersetzen (z.B. Maximized)
            - // if layout.tiling_mode_applied == TilingMode::MaximizedFocused && Some(&amp;domain_id) == layout.focused_window_id {
            - // new_xdg_states.push(xdg_toplevel::State::Maximized);
            - // }
            - `toplevel.with_pending_state(|xdg_state| { xdg_state.size = Some(target_geometry.size); xdg_state.states = ToplevelState::new(&new_xdg_states); });`
            - `toplevel.send_configure();`
        - `space.map_window(managed_window_arc.clone(), target_geometry.loc, true);` (Stellt sicher, dass es im Space ist und die Position aktualisiert wird. `true` für Aktivierung, falls es das fokussierte Fenster sein soll – Fokuslogik ist separat).
        - `desktop_state.event_bridge.publish_window_mechanics_event(WindowMechanicsEvent::WindowConfiguredByMechanics { ... });`
    5. Für Fenster, die im `space` sind, aber NICHT in `layout.window_geometries` (d.h. sollen nicht mehr auf diesem Workspace sichtbar sein, z.B. weil geschlossen oder auf anderen WS verschoben):
        - `if let Some(window_to_unmap) = windows_map.get(&domain_id_im_space) { space.unmap_window(window_to_unmap); }`
    6. `space.damage_all_outputs();` (Oder spezifischer: `space.damage_elements(betroffene_fenster)`).
    7. `Ok(())`

#### 6.4. Untermodul: `system::window_mechanics::interactive_ops`

**Zweck:** Handhabung von interaktiven Fenster-Moves und -Resizes.

**Datei:** `src/window_mechanics/interactive_ops.rs`

- **Struct `PointerMoveResizeGrab`**: Implementiert `smithay::input::pointer::PointerGrab<DesktopState>`.
    - **Felder:** `op_state: InteractiveOpState`, `desktop_state_accessor: impl Fn() -> Arc<Mutex<DesktopState>>` (oder `Weak<Mutex<DesktopState>>`), `window_policy_service: Arc<dyn WindowManagementPolicyService>`.
    - **`motion(...)` Logik:**
        1. `current_pointer_pos_global = global_grab_start_pos + (current_event_pos - op_state.start_pointer_pos_pointer_local);`
        2. `new_geometry = calculate_new_geometry_for_op(&op_state.initial_window_geometry, &op_state.op_type, current_pointer_pos_global, op_state.start_pointer_pos_global);`
        3. **Snapping:**
            - `other_windows_on_workspace = collect_other_windows_geometries(desktop_state_accessor, &op_state.window_arc);`
            - `snapping_policy = block_on(self.window_policy_service.get_effective_snapping_policy());`
            - `gap_settings = block_on(self.window_policy_service.get_effective_gap_settings_for_workspace(...));`
            - `if let Some(snapped_geom) = block_on(self.window_policy_service.calculate_snap_target(&op_state.window_arc.domain_id, new_geometry, &other_windows_on_workspace, workspace_area, &snapping_policy, &gap_settings)) { new_geometry = snapped_geom; }`
        4. **Größenbeschränkungen anwenden:** Klemme `new_geometry.size` auf `op_state.initial_window_size_constraints`.
        5. Aktualisiere `op_state.window_arc.current_geometry = new_geometry;` (visuelles Feedback, kein Configure).
        6. `desktop_state_accessor().lock().unwrap().space.damage_window(&op_state.window_arc, None, None);` (Alte und neue Position beschädigen).
    - **`button(...)` Logik:**
        1. Wenn Maustaste losgelassen:
            - Finalisiere `final_geometry = op_state.window_arc.current_geometry;`
            - `if let WindowSurface::Toplevel(toplevel) = &op_state.window_arc.xdg_surface { ... send_configure mit final_geometry ... }`
            - `pointer_handle.unset_grab(serial, time);`
            - `desktop_state_accessor().lock().unwrap().event_bridge.publish_window_mechanics_event(InteractiveOpEnded { ... });`
- **Funktionen `start_interactive_move` / `start_interactive_resize`**:
    1. Erstellen `InteractiveOpState`.
    2. `pointer_handle.set_grab(serial, PointerMoveResizeGrab { ... }, Focus::Clear);`

#### 6.5. Submodul: `system::window_mechanics::focus_manager` (Vervollständigung)

**Zweck:** Technische Umsetzung des Fokuswechsels basierend auf Domänenentscheidungen und Benutzerinteraktionen.

**Datei:** `src/window_mechanics/focus_manager.rs`

- **Funktion `pub async fn set_application_focus(desktop_state_accessor: &impl Fn() -> Arc<Mutex<DesktopState>>, seat_name: &str, window_domain_id_to_focus: Option<&DomainWindowIdentifier>, serial: Serial) -> Result<(), WindowMechanicsError>`**:
    1. `let mut ds_guard = desktop_state_accessor().lock().await;`
    2. `let seat = ds_guard.seat_state.seats().find(|s| s.name() == seat_name).cloned().ok_or(WindowMechanicsError::InternalError("Seat nicht gefunden".into()))?;`
    3. `let old_focused_window_domain_id = ds_guard.active_input_surface.as_ref().and_then(|weak_surf| weak_surf.upgrade()).and_then(|surf| find_domain_id_for_surface(&ds_guard, &surf));`
    4. Finde `target_managed_window_arc_option`:
        - Wenn `window_domain_id_to_focus` `Some(id)`, suche in `ds_guard.windows.get(id)`.
        - Sonst `None`.
    5. `let target_wl_surface_option = target_managed_window_arc_option.as_ref().map(|arc_win| arc_win.wl_surface().clone());`
    6. Rufen Sie `crate::input::keyboard::focus::set_keyboard_focus(&mut ds_guard, seat_name, target_wl_surface_option.as_ref(), serial)?;`
    7. // Aktivierungslogik für XDG Toplevel
        - Wenn `old_focused_window_domain_id` existiert und sich von `window_domain_id_to_focus` unterscheidet:
            - Finde altes `ManagedWindow`. Wenn Toplevel, `old_toplevel.set_activated(false); old_toplevel.send_configure();`.
        - Wenn `target_managed_window_arc_option` ein Toplevel ist (`newly_focused_toplevel`):
            - `newly_focused_toplevel.set_activated(true); newly_focused_toplevel.send_configure();`
            - `ds_guard.space.raise_window(&newly_focused_toplevel_arc, true);` // True für Fokus
            - `ds_guard.active_input_surface = target_wl_surface_option.map(|s| s.downgrade());`
    8. `ds_guard.event_bridge.publish_window_mechanics_event(FocusSetByMechanics(window_domain_id_to_focus.cloned()));`
    9. `Ok(())`
- **Funktion `fn find_domain_id_for_surface(ds: &DesktopState, surface: &WlSurface) -> Option<DomainWindowIdentifier>`**: Iteriert `ds.windows` und vergleicht `wl_surface()`.

#### 6.6. Implementierungsschritte `system::window_mechanics`

1. `types.rs`, `errors.rs` definieren.
2. `layout_applier.rs`: `apply_workspace_layout_blocking` implementieren. Fokus auf korrekte `configure`-Events.
3. `interactive_ops.rs`: `PointerMoveResizeGrab` mit `PointerGrab` Trait implementieren. `start_interactive_move/resize` Funktionen. Snapping-Logik integrieren.
4. `focus_manager.rs`: `set_application_focus` mit XDG-Aktivierungslogik und Space-Interaktion.
5. Unit-Tests (sehr komplex):
    - Testen der `apply_workspace_layout` für verschiedene Layouts (mock `DesktopState` und `ManagedWindow`s).
    - Testen der Grab-Handler-Logik (Zustandsübergänge, Geometrieberechnung).
    - Testen der Fokus-Aktivierungslogik.

---

### Modul 7: `system::power_management` (Vervollständigung)

Zweck: DPMS, Interaktion mit logind für Suspend/Hibernate, Reaktion auf Benutzerinaktivität.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

#### 7.1. Untermodul: `system::power_management::types`

**Datei:** `src/power_management/types.rs`

- **Enum `DpmsState`**: Wie in der vorherigen Antwort (`On, Standby, Suspend, Off`). Serde für Konfiguration.
- **Event `PowerManagementSystemEvent`** (umbenannt von `PowerManagementEvent`):
    
    Rust
    
    ```
    use crate::dbus_interfaces::logind_client::types::LogindPowerOperation; // Pfad anpassen
    
    #[derive(Debug, Clone)]
    pub enum PowerManagementSystemEvent {
        OutputDpmsStateSet { output_name: String, new_state: DpmsState, success: bool },
        SystemSuspendingInitiated(LogindPowerOperation), // Vom logind_client erhalten
        SystemResumedNormally,
        ScreenBlankTimeoutReached(String /* output_name */),
        SystemIdleTimeoutReached, // Für Suspend/Hibernate
    }
    ```
    
- **Struct `IdleTimerState`**: Wie in der vorherigen Antwort, aber `timer_handle` muss `Send + Sync` sein, wenn der Service in einem `tokio::task` läuft und den Timer in `calloop` der Compositor-Schleife managt. Besser: Timer wird über einen Befehl an den Compositor-Thread gesetzt.
    
    Rust
    
    ```
    use chrono::{DateTime, Utc, Duration as ChronoDuration}; // Duration für Timer
    use calloop::TimerHandle; // Wenn Timer in calloop läuft
    
    #[derive(Debug)] // TimerHandle ist nicht Clone/Debug
    pub struct IdleTimerState {
        pub timer_id: String, // Eindeutige ID für den Timer (z.B. "output-HDMI-A-1-blank", "system-suspend")
        pub last_activity_ts: DateTime<Utc>,
        pub current_timeout_duration: ChronoDuration,
        // pub calloop_timer_handle: Option<TimerHandle>, // Wenn direkt in calloop
        // Alternativ: Timestamp, wann der Timer ablaufen soll
        pub scheduled_expiry_ts: Option<DateTime<Utc>>,
    }
    ```
    

#### 7.2. Untermodul: `system::power_management::errors`

**Datei:** `src/power_management/errors.rs`

- **Enum `PowerManagementError`**: Wie in der vorherigen Antwort.

#### 7.3. Untermodul: `system::power_management::service`

**Datei:** `src/power_management/service.rs`

- **Trait `PowerManagementControl`** (Schnittstelle zum Compositor/DRM-Backend für DPMS):
    
    Rust
    
    ```
    use async_trait::async_trait;
    use super::types::DpmsState;
    use super::errors::PowerManagementError;
    
    #[async_trait]
    pub trait PowerManagementControl: Send + Sync {
        async fn set_output_dpms_state(&self, output_name: &str, state: DpmsState) -> Result<(), PowerManagementError>;
        async fn list_outputs_for_dpms(&self) -> Result<Vec<String>, PowerManagementError>; // Gibt Namen der relevanten Outputs
    }
    ```
    
- **Struct `PowerManagementService`**:
    - **Felder:**
        - `settings_service: Arc<dyn GlobalSettingsService>`
        - `logind_service: Arc<dyn LogindClientService>`
        - `compositor_dpms_control: Arc<dyn PowerManagementControl>` (Injizierte Abhängigkeit)
        - `event_publisher: tokio::sync::broadcast::Sender<PowerManagementSystemEvent>`
        - `system_event_receiver: tokio::sync::broadcast::Receiver<crate::event_bridge::SystemLayerEvent>` (Empfängt `UserActivityDetectedEvent`, `LogindSystemEvent::PrepareForSleep/Shutdown`, `SettingChangedEvent` für Power-Settings).
        - `active_timers: Arc<tokio::sync::Mutex<HashMap<String /* timer_id */, IdleTimerState>>>`
        - `current_power_settings: Arc<tokio::sync::RwLock<crate::domain::global_settings_and_state_management::types::PowerManagementPolicySettings>>`
        - `on_ac_power: Arc<tokio::sync::RwLock<bool>>` (Wird durch UPower-Events aktualisiert)
    - **Konstruktor `new(...)`**: Nimmt Abhängigkeiten, abonniert Events vom `SystemEventBridge`.
    - **Methode `pub async fn run(&self)`**: Haupt-Task des Dienstes.
        1. Lädt initiale `PowerManagementPolicySettings` und `on_ac_power`-Status.
        2. Initialisiert/Resettet alle Idle-Timer basierend auf aktuellen Einstellungen und AC-Status.
        3. **Event-Loop (`tokio::select!`)**:
            - Hört auf `system_event_receiver`:
                - `UserActivityDetectedEvent`: `self.reset_all_idle_timers().await;`
                - `LogindSystemEvent::PrepareForSleep(is_suspending)`: Setze alle Outputs auf `DpmsState::Off`. `self.cancel_all_idle_timers().await;`
                - `LogindSystemEvent::SystemResumed`: `self.reset_all_idle_timers().await;` Setze Outputs auf `DpmsState::On`.
                - `SettingChangedEvent` für Power-Pfade: Lade `current_power_settings` neu, `self.reset_all_idle_timers().await;`
                - `UPowerSystemEvent::OnBatteryChanged(is_on_battery)`: Aktualisiere `self.on_ac_power`, `self.reset_all_idle_timers().await;`
            - Hört auf Timer-Abläufe (wenn Timer in `tokio` verwaltet werden, z.B. `tokio::time::sleep_until` für jeden Timer in einem separaten Task, der dann eine Nachricht an diesen Haupt-Task sendet).
                - Wenn "Screen Blank Timeout" für einen Output abläuft: `self.apply_dpms_state(output_name, DpmsState::Off).await;` Sende `ScreenBlankTimeoutReached`.
                - Wenn "System Suspend Timeout" abläuft:
                    - Rufe `self.logind_service.suspend(false).await` oder `hibernate(false).await` basierend auf Policy. Sende `SystemIdleTimeoutReached`.
    - **Private Methoden:**
        - `async fn reset_all_idle_timers(&self)`: Liest aktuelle Settings und AC-Status. Berechnet neue Timeout-Dauern (z.B. `screen_blank_timeout_ac_secs` vs. `_battery_secs`). Startet/Neustartet `tokio::time::sleep_until` für jeden Output-Timer und den System-Suspend-Timer. Speichert `ScheduledExpiryTs` in `IdleTimerState`.
        - `async fn cancel_all_idle_timers(&self)`: Bricht laufende `tokio::time::sleep_until` ab (indem die Tasks, die sie verwalten, beendet werden oder indem `scheduled_expiry_ts` auf `None` gesetzt wird).
        - `async fn apply_dpms_state(...)`: Ruft `self.compositor_dpms_control.set_output_dpms_state(...)`. Sendet `OutputDpmsStateSet`.

#### 7.4. Implementierungsschritte `system::power_management`

1. `types.rs`, `errors.rs` definieren. `PowerManagementControl`-Trait definieren.
2. `service.rs`: `PowerManagementService` implementieren.
    - Event-Loop-Logik mit `tokio::select!`.
    - Timer-Management mit `tokio::time::sleep_until` (oder Integration mit `calloop`, falls performanter/einfacher im Compositor-Kontext).
    - Interaktion mit `GlobalSettingsService`, `LogindClientService`, `PowerManagementControl`.
3. Sicherstellen, dass `PowerManagementControl` im Compositor-Modul implementiert wird (z.B. `impl PowerManagementControl for DesktopState`).
4. Tests: Mocking von Abhängigkeiten. Testen der Timer-Logik, korrekte Reaktion auf Events, korrekte Anwendung von Policies (AC vs. Batterie).

---

### Modul 8: `system::event_bridge` (Vervollständigung)

Zweck: Zentrale Event-Verteilung innerhalb der Systemschicht und ggf. an die Domänenschicht für System-level Events.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

**Datei:** `src/event_bridge/events.rs` (Definition aller System-internen Events)

- Hier werden alle Events definiert, die in den `types.rs`-Dateien der Submodule (`UPowerEvent`, `LogindEvent`, `NetworkManagerEvent`, `AudioEvent`, `McpClientSystemEvent`, `WindowMechanicsEvent`, `PowerManagementSystemEvent`, `InputDeviceHotplugEvent`) definiert wurden, ggf. gewrappt in ein übergreifendes `SystemLayerEvent`-Enum.
    
    Rust
    
    ```
    // Beispiel:
    // use crate::dbus_interfaces::upower_client::types::UPowerEvent;
    // use crate::input::types::InputDeviceHotplugEvent; // Beispiel
    // ...
    
    #[derive(Debug, Clone)] // Ggf. Serialize/Deserialize wenn über Grenzen gesendet
    pub enum SystemLayerEvent {
        UPower(UPowerEvent),
        Logind(LogindEvent),
        NetworkManager(NetworkManagerEvent),
        Audio(AudioEvent),
        McpClient(McpClientSystemEvent),
        WindowMechanics(WindowMechanicsEvent),
        PowerManagement(PowerManagementSystemEvent),
        InputDeviceHotplug(InputDeviceHotplugEvent),
        // Auch Domänen-Events, die von Systemschicht ausgelöst werden
        DomainUserActivity(crate::domain::common_events::UserActivityDetectedEvent),
        DomainSystemShutdown(crate::domain::common_events::SystemShutdownInitiatedEvent),
    }
    ```
    

**Datei:** `src/event_bridge/mod.rs`

- **Struct `SystemEventBridge`**:
    - **Felder:** Hält einen einzelnen `tokio::sync::broadcast::Sender<SystemLayerEvent>`.
        - `event_tx: tokio::sync::broadcast::Sender<SystemLayerEvent>`
    - **Konstruktor `new(capacity: usize) -> Self`**.
    - **Methoden:**
        - `pub fn subscribe(&self) -> tokio::sync::broadcast::Receiver<SystemLayerEvent>`
        - `pub(crate) fn publish(&self, event: SystemLayerEvent)`: Sendet das Event. Loggt Fehler, wenn keine Subscriber vorhanden sind.
- **Globale Instanz (optional aber oft praktisch):**
    
    Rust
    
    ```
    use std::sync::OnceLock;
    static SYSTEM_EVENT_BRIDGE_INSTANCE: OnceLock<SystemEventBridge> = OnceLock::new();
    
    pub fn global_system_event_bridge() -> &'static SystemEventBridge {
        SYSTEM_EVENT_BRIDGE_INSTANCE.get().expect("SystemEventBridge nicht initialisiert")
    }
    
    pub fn initialize_global_system_event_bridge(capacity: usize) {
        if SYSTEM_EVENT_BRIDGE_INSTANCE.set(SystemEventBridge::new(capacity)).is_err() {
            tracing::warn!("SystemEventBridge bereits initialisiert.");
        }
    }
    ```
    
    - Die Initialisierung würde sehr früh im Startprozess der Systemschicht erfolgen.

**Implementierungsschritte `system::event_bridge`**:

1. Alle relevanten Event-Typen in `events.rs` (oder den jeweiligen Modulen und hier re-exportiert/gewrappt) definieren.
2. `SystemEventBridge`-Struktur und globale Instanz implementieren.
3. Alle Systemmodule, die Events publizieren, nutzen `global_system_event_bridge().publish(...)`.
4. Alle Systemmodule (und Adapter zur Domänenschicht), die Events konsumieren, nutzen `global_system_event_bridge().subscribe()` und filtern dann nach dem `SystemLayerEvent`-Typ.

---

**Finale `novade-system/src/lib.rs` (Struktur):**

Rust

```
// novade-system/src/lib.rs

// Kern- und Domänen-Abhängigkeiten
// use novade_core;
// use novade-domain;

// System-interne Module
pub mod audio_management;
pub mod compositor;
pub mod dbus_interfaces;
pub mod event_bridge; // Muss früh initialisiert werden
pub mod input;
pub mod mcp_client;
pub mod power_management;
pub mod window_mechanics;

// Öffentliche API der Systemschicht (Traits und wichtige Typen)
// Diese werden typischerweise von der Hauptanwendung (Binary) oder der UI-Schicht genutzt.
// Beispiel:
// pub use compositor::CompositorControlService; // Hypothetischer Trait
// pub use input::InputControlService;          // Hypothetischer Trait
pub use dbus_interfaces::{
    UPowerClientService, LogindClientService, NetworkManagerClientService,
    SecretsServiceClientService, PolicyKitClientService, FreedesktopNotificationsServer,
    // Re-export der Service-Traits wäre hier besser als konkrete Typen, falls Traits existieren
};
pub use audio_management::{PipeWireClientService /* oder Trait */, AudioEvent};
pub use mcp_client::{SystemMcpService, McpClientSystemEvent, McpServerConfig};
// ... usw.

// Initialisierungsfunktion für die gesamte Systemschicht
// pub async fn initialize_system_layer(
//     core_services: Arc<CoreServices>, // Hypothetische Sammlung von Kernschicht-Services
//     domain_services: Arc<DomainServices>, // Hypothetische Sammlung von Domänenschicht-Services
//     display_handle: DisplayHandle, // Vom Backend (DRM, Winit)
//     loop_handle: LoopHandle<'static, DesktopState>, // Vom Backend
// ) -> Result<SystemServices, SystemInitializationError> {
//
//     event_bridge::initialize_global_system_event_bridge(1024);
//     let event_bridge = event_bridge::global_system_event_bridge();
//
//     // DesktopState (Compositor-Herzstück)
//     let desktop_state = Arc::new(Mutex::new(DesktopState::new(loop_handle.clone(), display_handle.clone(), domain_services.window_policy_service.clone(), ...)));
//
//     // Input-System initialisieren und in calloop registrieren
//     // let libinput_backend = input::libinput_handler::init_libinput_backend(&loop_handle, session_interface).await?;
//     // input::libinput_handler::register_libinput_source(&loop_handle, libinput_backend, "seat0".to_string(), desktop_state.clone())?;
//     // input::seat_manager::create_seat(&mut desktop_state.lock().unwrap(), &display_handle, "seat0".to_string())?;
//
//     // D-Bus Clients initialisieren
//     // let upower_client = Arc::new(UPowerClientService::new(event_bridge.publisher_for_upower_events()).await?);
//     // upower_client.initialize_and_listen().await?;
//     // ... für andere D-Bus Clients ...
//
//     // PipeWire Client initialisieren
//     // let audio_service = Arc::new(PipeWireClientService::new(event_bridge.publisher_for_audio_events()).await?);
//
//     // MCP Client initialisieren
//     // let mcp_connection_manager = Arc::new(McpConnectionManager::new(secrets_service_client, event_bridge.publisher_for_mcp_events()));
//     // let mcp_service = Arc::new(DefaultSystemMcpService::new(mcp_connection_manager));
//     // mcp_service.configure_servers(domain_services.global_settings.mcp_server_configs).await?;
//
//     // Window Mechanics (ist oft eng mit DesktopState oder als Service)
//     // let window_mechanics_service = Arc::new(DefaultWindowMechanicsService::new(desktop_state.clone(), domain_services.window_policy_service.clone()));
//
//     // Power Management Service
//     // let power_management_dpms_control = desktop_state.clone(); // DesktopState implementiert PowerManagementControl
//     // let power_service = Arc::new(PowerManagementService::new(domain_services.settings_service, logind_client, power_management_dpms_control, ...));
//     // tokio::spawn(async move { power_service.run().await; });
//
//     // Alle Wayland Globals erstellen (nachdem alle States in DesktopState initialisiert sind)
//     // compositor::core::create_all_wayland_globals(&mut desktop_state.lock().unwrap(), &display_handle)?;
//
//     // D-Bus Notifications Server starten (wenn NovaDE ihn bereitstellt)
//     // tokio::spawn(async move {
//     //    dbus_interfaces::notifications_server::run_notifications_server(domain_services.notification_service).await;
//     // });
//
//     // SystemServices struct zurückgeben, das Handles zu den wichtigsten System-Services enthält
//     // Ok(SystemServices { desktop_state_handle: desktop_state, ... })
// }
```

Mit diesen detaillierten Plänen für die Module 5 bis 8 ist die Spezifikation der Systemschicht nun vollständig. Die Implementierung erfordert sorgfältige Beachtung der Asynchronität, der Inter-Prozess-Kommunikation und der Integration mit den Domänen- und Kernschichten. Die Testbarkeit bleibt eine Herausforderung und erfordert umfangreiches Mocking oder dedizierte Testumgebungen.