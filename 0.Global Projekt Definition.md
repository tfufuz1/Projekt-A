
**Technische Gesamtspezifikation & Richtlinien: Linux Desktop-Umgebung "NovaDE" (Kompakte Gesamtdefinition inkl. Features)**

**I. Vision und Kernziele**

- **Vision:** NovaDE (Nova Desktop Environment) ist eine innovative Linux-Desktop-Umgebung, die eine moderne, schnelle, intuitive und KI-gestützte Benutzererfahrung schafft. Sie ist optimiert für Entwickler, Kreative und alltägliche Nutzer und zielt darauf ab, Produktivität und Freude an der Interaktion mit dem System zu maximieren.
- **Kernziele:** Performance, Intuition, Modernität, Modularität & Wartbarkeit, Anpassbarkeit, sichere KI-Integration, Stabilität & Sicherheit.

**II. Architektonischer Überblick: Vier-Schichten-Architektur**

NovaDE basiert auf einer strengen, vier-schichtigen Architektur (Kern, Domäne, System, Benutzeroberfläche) für Modularität, lose Kopplung und hohe Kohäsion. Kommunikation erfolgt über wohldefinierte Schnittstellen.

1. **Kernschicht (Core Layer):**
    
    - **Verantwortlichkeiten:** Fundamentale Datentypen (z.B. `Point<T>`, `Color`), Dienstprogramme, Konfigurationsprimitive (TOML, Serde), Logging (`tracing`), Basis-Fehler (`thiserror`).
    - **Featurespiegelung:** Stellt die atomaren Bausteine für alle visuellen und logischen Elemente bereit.
2. **Domänenschicht (Domain Layer):**
    
    - **Verantwortlichkeiten:** UI-unabhängige Geschäftslogik.
        - `domain::theming`: Logik für das Erscheinungsbild, Design-Token-Verwaltung, dynamische Theme-Wechsel (Hell/Dunkel, Akzentfarben).
        - `domain::workspaces`: Verwaltung von Arbeitsbereichen ("Spaces"), Fensterzuweisung, Workspace-Orchestrierung und -Persistenz.
        - `domain::user_centric_services`: Logik für KI-Interaktionen (inkl. Einwilligungsmanagement für Datenkategorien wie `FileSystemRead`, `ClipboardAccess`), Benachrichtigungsverwaltung.
        - `domain::notifications_rules`: Regelbasierte, dynamische Verarbeitung von Benachrichtigungen.
        - `domain::global_settings_and_state_management`: Verwaltung globaler Desktop-Einstellungen.
        - `domain::window_management_policy`: Richtlinien für Fensterplatzierung, automatisches Tiling (Layouts: Spalten, Spiralen), Snapping, Fenstergruppierung, Gap-Management.
    - **Featurespiegelung:** Definiert _was_ personalisierbar ist (Themes, Akzente), _wie_ Arbeitsbereiche funktionieren (Spaces mit Icons, gepinnten Apps), _wie_ KI sicher und mit Zustimmung agiert und _welche_ Regeln für Fenster gelten.
3. **Systemschicht (System Layer):**
    
    - **Verantwortlichkeiten:** OS-Interaktion, technische Umsetzung der Domänenrichtlinien.
        - `system::compositor`: Smithay-basierter Wayland-Compositor (Implementierung von `xdg-shell`, `wlr-layer-shell-unstable-v1`, etc.), XWayland.
        - `system::input`: `libinput`-basierte Eingabeverarbeitung, Gestenerkennung, Seat-Management (`xkbcommon`).
        - `system::dbus`: `zbus`-Schnittstellen zu Systemdiensten (NetworkManager, UPower, logind, org.freedesktop.Notifications, org.freedesktop.secrets, PolicyKit).
        - `system::outputs`: Monitorkonfiguration (Auflösung, Skalierung, DPMS über `wlr-output-management`).
        - `system::audio`: PipeWire-Client (`pipewire-rs`) für Audio-Management.
        - `system::mcp`: MCP-Client (`mcp_client_rs`) für KI-Modell-Kommunikation.
        - `system::portals`: Backend für XDG Desktop Portals (FileChooser, Screenshot).
        - `system::window_mechanics`: Technische Umsetzung des Fenstermanagements (Positionierung, Anwendung von Tiling-Layouts, Fokus, Fensterdekorationen). Technische Basis für die "Intelligente Tab-Leiste".
    - **Featurespiegelung:** Ermöglicht flüssige Darstellung (Wayland), präzise Eingabe (`libinput`, Gesten), Integration mit Systemdiensten für Energie, Netzwerk, Sound (PipeWire) und sichere KI-Kommunikation (MCP). Setzt Fensterregeln (Tiling, Snapping) technisch um.
4. **Benutzeroberflächenschicht (User Interface Layer):**
    
    - **Verantwortlichkeiten:** Grafische Darstellung, Benutzerinteraktion (GTK4, `gtk4-rs`).
        - `ui::shell`:
            - **Kontroll-/Systemleiste(n) (PanelWidget):** Module für AppMenu, Workspace-Indikator, Uhr, System-Tray, Schnelleinstellungen, Benachrichtigungszentrum, Netzwerk-, Energie-, Audio-Indikatoren. _Elegante Leiste mit optionalem Leuchtakzent._
            - **Intelligente Tab-Leiste (SmartTabBarWidget):** Pro "Space", mit ApplicationTabWidgets für "angepinnte" Apps/Split-Views, aktive Tabs mit Akzentfarbe. _Moderne Tabs mit abgerundeten oberen Ecken._
            - **Schnelleinstellungs-Panel (QuickSettingsPanelWidget):** Ausklappbar für WLAN, Bluetooth, Lautstärke, Dark Mode.
            - **Workspace-Switcher (WorkspaceSwitcherWidget):** Adaptive linke Seitenleiste mit SpaceIconWidgets (Icons der gepinnten App oder benutzerdefiniert) für schnelle Navigation zwischen "Spaces", mit Hervorhebung des aktiven Space. _Bei Mouse-Over/Geste aufklappbar mit Namen/Vorschau._
            - **Schnellaktionsdock (QuickActionDockWidget):** Konfigurierbares Dock (schwebend/angedockt) für Apps, Dateien, Aktionen; intelligente Vorschläge, Tastaturbedienung.
            - **Benachrichtigungszentrum (NotificationCenterPanelWidget):** Anzeige von Benachrichtigungsliste und -historie.
        - `ui::control_center`: Modulare GTK4-Anwendung für alle Systemeinstellungen (Erscheinungsbild, Netzwerk, etc.) mit Live-Vorschau.
        - `ui::widgets`:
            - **Adaptive rechte Seitenleiste (RightSidebarWidget):** Optional, mit dezent transluzentem Hintergrund für informative Widgets (Uhr, Kalender, Wetter, Systemmonitor), per Drag & Drop anpassbar.
            - WidgetManagerService, WidgetPickerPopover.
        - `ui::window_manager_frontend`:
            - **Client-Side Decorations (CSD):** Logik (z.B. via `Gtk::HeaderBar`).
            - **Übersichtsmodus (OverviewModeWidget):** Fenster- und Workspace-Übersicht als interaktive Kacheln mit Live-Vorschau, Drag & Drop von Fenstern zwischen Spaces. _Hintergrund abgedunkelt/unscharf._
            - AltTabSwitcherWidget.
        - `ui::notifications_frontend`: **Pop-up-Benachrichtigungen (NotificationPopupWidget):** Dezent, im Dark Mode Stil mit Akzentfarbe für Dringlichkeit.
        - `ui::theming_gtk`: Anwendung von CSS-Stilen aus `domain::theming` via `GtkCssProvider`.
        - `ui::speed_dial`: GTK4-Implementierung der Startansicht für leere Workspaces mit Favoriten und intelligenten Vorschlägen.
        - `ui::command_palette`: GTK4-Implementierung der kontextuellen Befehlspalette (`Super+Space`).
    - **Featurespiegelung:** Setzt die gesamte beschriebene Nutzererfahrung um: dunkle Ästhetik mit Akzentfarben, Panel(s), intelligente Tab-Leiste, adaptive Seitenleisten mit Widgets, Workspace-Switcher, Schnellaktionsdock, Control Center, Speed-Dial, Übersichtsmodus und die kontextuelle Befehlspalette. Ermöglicht die Personalisierung und direkte Manipulation.

**III. Technologie-Stack (Verbindliche Auswahl)**

Rust, Meson, GTK4 (`gtk4-rs`), Smithay Toolkit, Wayland (xdg-shell, wlr-Protokolle), D-Bus (`zbus`), Model Context Protocol (MCP), `libinput`, PipeWire (`pipewire-rs`), Freedesktop Secret Service API, PolicyKit, Token-basiertes CSS-Theming, XDG Desktop Portals.

**IV. Entwicklungsrichtlinien (Verbindlich)**

- **Rust:** `rustfmt`, Rust API Guidelines, `thiserror` pro Modul, `Result<T,E>`, `tracing` für Logging, `async/await` (Tokio, GLib).
- **Allgemein:** Git (GitHub Flow), Conventional Commits, umfassende Tests (Unit, Integration, Compositor, UI), CI-Pipeline, detaillierte Dokumentation (rustdoc, Architektur, READMEs).

**V. Deployment-Überlegungen**

Native Pakete (.deb, .rpm), Flatpak (evaluieren), Integration mit Display Managern, `systemd` User Sessions, PAM, XDG Base Directory Specification. SemVer.

# NovaDE: Technische Gesamtspezifikation und Richtliniensammlung

## 1. Einleitung

Dieses Dokument dient als zentrale technische Gesamtspezifikation und Richtliniensammlung für die Linux Desktop-Umgebung 'NovaDE'. Es hat zum Ziel, ein umfassendes Verständnis des Gesamtsystems zu ermöglichen und sicherzustellen, dass alle technischen Anforderungen, die sich aus den Beschreibungen der Nutzererfahrung (UX) ergeben, adäquat berücksichtigt und integriert werden. Die Spezifikation richtet sich an Entwickler, Architekten, Tester und alle weiteren Stakeholder, die an der Entwicklung, Wartung und Erweiterung von NovaDE beteiligt sind.

Eine präzise und detaillierte technische Spezifikation ist unerlässlich für den Erfolg komplexer Softwareprojekte.1 Sie minimiert Risiken durch frühzeitige Definition von Erwartungen und Randbedingungen, verbessert die Kommunikation zwischen den Beteiligten durch Schaffung einer gemeinsamen Referenz und steigert die Effizienz im Entwicklungsprozess.1 Studien belegen, dass detaillierte Spezifikationen Implementierungszeiten und Kosten durch Last-Minute-Änderungen signifikant reduzieren können.1 Dieses Dokument legt den Grundstein für Qualität, Wartbarkeit und Skalierbarkeit von NovaDE.2

### 1.1. Zweck und Geltungsbereich

Der Zweck dieses Dokuments ist die Definition der technischen Architektur, der Kernkomponenten, der Entwicklungsprozesse und der Qualitätsstandards für NovaDE. Es umfasst:

- Eine detaillierte Beschreibung der Systemarchitektur und ihrer Komponenten.
- Funktionale und nicht-funktionale Anforderungen, die sich aus der angestrebten Nutzererfahrung ableiten.
- Technologische Entscheidungen und deren Begründungen.
- Richtlinien für Entwicklung, Code-Qualität, Testing, Dokumentation und Sicherheit.
- Schnittstellendefinitionen für die Interaktion zwischen Komponenten und mit externen Systemen.
- Richtlinien für die Systemintegration und Erweiterbarkeit.

Der Geltungsbereich erstreckt sich auf alle Aspekte der NovaDE-Software, von den Low-Level-Systemdiensten bis hin zu den Benutzeroberflächenkomponenten. Es dient als maßgebliche Referenz für alle Entwicklungsaktivitäten.

### 1.2. Zielgruppe

Dieses Dokument richtet sich primär an:

- **Softwarearchitekten und -entwickler:** Für das Design, die Implementierung und Wartung von NovaDE-Komponenten.
- **Qualitätssicherungsingenieure und Tester:** Für die Erstellung von Testplänen und die Verifizierung der Systemanforderungen.
- **Projektmanager und Produktmanager:** Für das Verständnis der technischen Grundlagen und zur Planung von Entwicklungszyklen.
- **Systemintegratoren und Drittanbieter-Entwickler:** Für die Integration von Anwendungen und die Entwicklung von Erweiterungen für NovaDE.
- **Technische Redakteure:** Für die Erstellung von Endbenutzer- und Entwicklerdokumentation.

Die klare und präzise Formulierung soll auch nicht-technischen Stakeholdern ein grundlegendes Verständnis ermöglichen, wobei technische Details für Experten ausreichend tiefgehend behandelt werden.1

### 1.3. Definitionen und Akronyme

Eine umfassende Liste von Definitionen und Akronymen, die in diesem Dokument verwendet werden, findet sich im Anhang (Abschnitt 8.1). Dies dient der Vermeidung von Mehrdeutigkeiten und stellt ein einheitliches Verständnis sicher.4

### 1.4. Referenzierte Dokumente

Alle externen Dokumente, Standards und Spezifikationen, auf die in diesem Text Bezug genommen wird, sind im Anhang (Abschnitt 8.2) aufgeführt. Dies gewährleistet die Nachvollziehbarkeit und ermöglicht den Zugriff auf weiterführende Informationen.2

## 2. Systemübersicht und Architektur

Dieser Abschnitt beschreibt die übergeordnete Architektur von NovaDE und die Kernkomponenten, aus denen sich die Desktop-Umgebung zusammensetzt. Die Architektur ist darauf ausgelegt, eine moderne, performante und flexible Nutzererfahrung zu ermöglichen, basierend auf aktuellen Technologien wie Wayland, GTK4 und Rust.

### 2.1. Systemarchitektur

NovaDE folgt einer modularen Architektur, die eine klare Trennung der Verantwortlichkeiten zwischen den einzelnen Komponenten anstrebt. Dies fördert die Wartbarkeit, Testbarkeit und unabhängige Entwicklung der Systemteile. Die Architektur basiert auf einem Wayland-Compositor als Kernstück, der für die Darstellung und Verwaltung von Fenstern zuständig ist. Darauf aufbauend existieren eine Desktop-Shell für die Nutzerinteraktion, ein Session-Manager für den Lebenszyklus der Desktop-Sitzung sowie diverse Systemdienste für Hintergrundaufgaben und die Integration mit der Hardware und anderen Software-Subsystemen.

Die Kommunikation zwischen den Prozessen erfolgt primär über D-Bus für Steuerungs- und Benachrichtigungsaufgaben sowie über das Wayland-Protokoll für die Display-Server-Kommunikation. PipeWire wird für das Multimedia-Routing und -Management eingesetzt. Die Verwendung von Rust als primäre Programmiersprache zielt auf Systemsicherheit und Performance ab.

Die Architektur muss die Skalierbarkeit und Zuverlässigkeit des Systems sicherstellen.1 Eine gut dokumentierte Architektur ist entscheidend, um das System zu verstehen, weiterzuentwickeln und zu skalieren, da sonst wichtige Informationen verloren gehen können.3

### 2.2. Kernkomponenten und ihre Verantwortlichkeiten

Die folgende Tabelle listet die Kernkomponenten von NovaDE, ihre Hauptverantwortlichkeiten, die eingesetzten Schlüsseltechnologien und ihre wesentlichen Interaktionen auf.

**Tabelle 1: Kernkomponenten und ihre Verantwortlichkeiten**

|   |   |   |   |
|---|---|---|---|
|**Komponente**|**Hauptverantwortlichkeiten**|**Schlüsseltechnologien**|**Wesentliche Interaktionen**|
|**NovaDE Compositor**|Fenster-Management, Darstellung, Eingabeverarbeitung, Implementierung des Wayland-Protokolls, Compositing-Effekte.|Wayland, Smithay (Rust-Bibliothek), EGL, evdev (Kernel)|Empfängt Eingabeereignisse vom Kernel (evdev), kommuniziert mit Clients über Wayland-Protokoll, rendert Fensterinhalte auf den Bildschirm (KMS).5 Stellt sicher, dass keine Bildrisse (Tearing) auftreten und Fensterattribute korrekt dargestellt werden.5|
|**NovaDE Shell**|Bereitstellung der primären Benutzeroberfläche (Panel, Anwendungsstarter, Task-Manager, System-Tray, Desktop-Hintergrund, Widgets).|GTK4, Rust|Interagiert mit dem Compositor zur Platzierung und Darstellung von Shell-Elementen, startet Anwendungen, kommuniziert mit dem Session Manager und Systemdiensten über D-Bus für Statusinformationen und Aktionen. Lädt Menüs aus Builder-Ressourcen.7|
|**NovaDE Session Manager**|Verwaltung des Lebenszyklus einer Benutzersitzung (Login, Logout, Sperren), Starten der Kernkomponenten (Compositor, Shell, erforderliche Dienste).|D-Bus, systemd (optional für Service-Management)|Authentifiziert Benutzer, startet den Compositor und die Shell, verwaltet Umgebungsvariablen, kommuniziert mit systemd für den Start/Stopp von User-Services, reagiert auf Power-Management-Events über D-Bus.8|
|**NovaDE Settings Daemon**|Verwaltung und Bereitstellung globaler und benutzerspezifischer Einstellungen (Theme, Schriftarten, Eingabegeräte, Monitoreinstellungen).|D-Bus, GSettings (oder äquivalente Rust-Implementierung)|Stellt Einstellungen über D-Bus bereit, auf die Anwendungen und Shell-Komponenten zugreifen können. Liest Einstellungen aus Konfigurationsdateien (z.B. `settings.ini` für GTK) und ggf. DConf.9 Ermöglicht Anwendungen, systemweite Einstellungen zu überschreiben (mit Vorsicht zu verwenden).9|
|**NovaDE Notification Service**|Empfang, Verwaltung und Anzeige von Desktop-Benachrichtigungen von Anwendungen und Systemdiensten.|D-Bus (Freedesktop Notification Specification), GTK4|Empfängt Benachrichtigungsanfragen über D-Bus, verwaltet eine Warteschlange, zeigt Benachrichtigungen gemäß den Benutzereinstellungen an (z.B. Pop-ups, Benachrichtigungscenter). Interagiert mit der Shell zur Darstellung.|
|**NovaDE Power Manager**|Überwachung des Batteriestatus, Verwaltung von Energieeinstellungen, Behandlung von Suspend/Hibernate-Zuständen, Bildschirmhelligkeit.|D-Bus, UPower (oder direkte Kernel-Schnittstellen)|Kommuniziert mit UPower (oder äquivalent) für Batteriestatus, implementiert Energieprofile, initiiert Suspend/Hibernate über D-Bus-Aufrufe an `logind` oder systemd.8|
|**NovaDE Workspace Manager**|Verwaltung virtueller Desktops/Arbeitsbereiche, Fensterplatzierung über Arbeitsbereiche hinweg.|Integriert in Shell und Compositor|Ermöglicht dem Benutzer das Erstellen, Wechseln und Verwalten von Arbeitsbereichen. Der Compositor ist für die tatsächliche Zuordnung von Fenstern zu Arbeitsbereichen und deren Darstellung zuständig. Die Shell stellt die UI-Elemente zur Interaktion bereit. Die Logik kann komplex sein und erfordert eine sorgfältige Verwaltung von Zuständen und Übergängen, ähnlich wie bei Projektmanagement-Tools.10|
|**PipeWire Integration**|Audio- und Video-Stream-Management, Hardware-Abstraktion für Multimedia, Screen-Sharing-Unterstützung.|PipeWire, WirePlumber (Session Manager)|Stellt Audio- und Video-Funktionalität für Anwendungen bereit, ermöglicht Screen-Sharing unter Wayland, verwaltet Audiogeräte und -profile. Interagiert mit dem Kernel (ALSA) und Anwendungen.12 Bietet Ersatz für PulseAudio und JACK.13|
|**D-Bus Broker**|Vermittlung der Interprozesskommunikation zwischen NovaDE-Komponenten und Anwendungen.|D-Bus Daemon (z.B. `dbus-daemon` oder `dbus-broker`)|Stellt System- und Session-Busse bereit, über die Dienste ihre Funktionalität anbieten (Methoden, Signale, Eigenschaften) und Clients diese nutzen können.8|
|**XWayland Server**|Ausführung von X11-Anwendungen unter der Wayland-basierten NovaDE-Umgebung.|XWayland, Xorg-Server-Codebase|Dient als Kompatibilitätsschicht, indem ein X-Server innerhalb der Wayland-Sitzung läuft und X11-Clients mit dem Wayland-Compositor kommunizieren können. Dies ist notwendig, da nicht alle Anwendungen native Wayland-Unterstützung bieten.15|
|**Model Context Protocol (MCP) Integration (optional)**|Ermöglicht die strukturierte Interaktion von KI-Modellen (z.B. in einem KI-Assistenten) mit externen Daten und Diensten innerhalb von NovaDE.|MCP (JSON-RPC basiert)|Ein MCP-Host (z.B. ein KI-Assistent in NovaDE) kommuniziert mit MCP-Servern (Dienste, die Werkzeuge/Ressourcen bereitstellen). Ermöglicht KI-gesteuerte Aktionen wie Kalenderverwaltung oder sicheren Datenzugriff.17 Erfordert strenge Sicherheitsmaßnahmen.19|

### 2.3. Technologiestack

Der Technologiestack von NovaDE ist sorgfältig ausgewählt, um moderne Anforderungen an Leistung, Sicherheit und Entwicklereffizienz zu erfüllen.

- **Programmiersprache:** Rust wird als primäre Sprache für die Entwicklung von Kernkomponenten eingesetzt. Die Stärken von Rust in Bezug auf Speichersicherheit ohne Garbage Collector, Nebenläufigkeit und Performance machen es zu einer idealen Wahl für Systemsoftware wie eine Desktop-Umgebung. Die Rust API Guidelines 21 und der Rust Style Guide 22 sind maßgeblich für die Codeentwicklung.
- **Display Server Protokoll:** Wayland 5 ist das Fundament für die Display-Server-Architektur. Es bietet im Vergleich zu X11 eine modernere, sicherere und effizientere Basis, indem es die Rolle des Display-Servers und des Compositors vereint und viele Altlasten von X11 vermeidet.5 Herausforderungen bei der Wayland-Adoption, wie Kompatibilität mit älteren Anwendungen und spezifische Funktionen (z.B. Screen-Sharing, Drag-and-Drop), werden durch XWayland und Protokollerweiterungen sowie Bibliotheken wie PipeWire adressiert.15
- **Compositor-Bibliothek:** Smithay 5 dient als Bibliothek für die Entwicklung des Wayland-Compositors in Rust. Smithay stellt Bausteine für Wayland-Compositoren bereit und zielt auf Sicherheit, Modularität und eine High-Level-API ab.24 Da Smithay eine Bibliothek und kein Framework ist, bietet es hohe Flexibilität, erfordert aber auch mehr Eigenverantwortung bei der Implementierung der Compositor-Logik. Die Dokumentation und Community-Unterstützung von Smithay sind wichtige Ressourcen.24 Aktuelle Herausforderungen und Entwicklungen in Smithay (z.B. bezüglich Input-Handling, XWayland-Integration, Puffer-Management) müssen kontinuierlich beobachtet werden.26
- **UI Toolkit:** GTK4 9 wird für die Entwicklung der Desktop-Shell und anderer grafischer Anwendungen innerhalb von NovaDE verwendet. GTK4 bietet moderne Rendering-Fähigkeiten, CSS-basiertes Theming 27 und gute Integration mit Wayland. Die Rust-Bindings (`gtk4-rs`) 7 ermöglichen eine idiomatische Entwicklung in Rust. Die Architektur von GTK4-Anwendungen, insbesondere die Nutzung von `GtkApplication` 7, fördert eine strukturierte Anwendungsentwicklung.
- **Interprozesskommunikation (IPC):** D-Bus 8 ist der Standardmechanismus für die IPC zwischen NovaDE-Komponenten und zwischen Anwendungen und dem System. D-Bus ermöglicht es Diensten, Methoden, Signale und Eigenschaften bereitzustellen. Design-Richtlinien für D-Bus APIs, wie die Minimierung von Roundtrips und die Nutzung des Typsystems, sind für Performance und Robustheit entscheidend.30 Sicherheitsaspekte, insbesondere auf dem System-Bus, müssen berücksichtigt werden.30
- **Multimedia-Framework:** PipeWire 12 wird für das Management von Audio- und Videoströmen eingesetzt. PipeWire bietet geringe Latenz, flexible Graphen-basierte Verarbeitung und Kompatibilität mit PulseAudio-, JACK- und ALSA-Anwendungen.12 WirePlumber dient als Session-Manager für PipeWire und handhabt die Verbindungslogik und Profilverwaltung.13 Die Konfiguration von PipeWire erfolgt über Dateien und D-Bus, und es integriert sich mit XDG Portals für Screen-Sharing.12
- **Build-System:** Meson wird in Kombination mit Cargo für das Bauen von Rust-Projekten und deren Integration mit C-Bibliotheken (wie GTK) verwendet.34 Meson handhabt Abhängigkeiten von Nicht-Rust-Komponenten und die Installation von systemweiten Dateien, während Cargo die Rust-spezifischen Bauprozesse steuert. Es ist wichtig, `extern crate` zu vermeiden und stattdessen Abhängigkeiten in Meson zu deklarieren, um eine korrekte Nachverfolgung zu gewährleisten.35 Meson generiert auch `rust-project.json` für eine bessere IDE-Integration mit `rust-analyzer`.35
- **Versionskontrolle:** Git wird für die Versionskontrolle des gesamten NovaDE-Quellcodes verwendet.

### 2.4. Architekturdiagramm

Ein detailliertes Architekturdiagramm, das die Kernkomponenten, ihre Beziehungen und die wichtigsten Kommunikationspfade visualisiert, ist für das Verständnis des Systems unerlässlich. Dieses Diagramm sollte die Interaktionen über Wayland, D-Bus und PipeWire klar darstellen. Die Verwendung von Modellen wie dem C4-Modell (Context, Containers, Components, Code) kann hierbei hilfreich sein, um verschiedene Abstraktionsebenen darzustellen.36 Softwarearchitektur-Dokumentation nutzt oft Diagramme (z.B. UML) und textuelle Beschreibungen, um das Systemdesign zu erklären.3

_(An dieser Stelle würde ein Diagramm eingefügt werden, das die oben beschriebenen Komponenten und ihre Interaktionen zeigt. Da dies textbasiert ist, wird das Diagramm hier nicht visuell dargestellt, sondern seine Erstellung als Teil der Spezifikation gefordert.)_

Das Diagramm sollte folgende Elemente umfassen:

- **Kontext-Diagramm (Level 1):** Zeigt NovaDE im Kontext des Betriebssystems und der Benutzer.
- **Container-Diagramm (Level 2):** Zeigt die wichtigsten laufenden Prozesse/Dienste von NovaDE (Compositor, Shell, Session Manager etc.) und deren Hauptkommunikationswege (Wayland, D-Bus, PipeWire).
- **Komponenten-Diagramm (Level 3):** Detailliert die internen Hauptmodule innerhalb eines Containers, z.B. die Module des Compositors oder der Shell.

Diese visuelle Darstellung ergänzt die textuellen Beschreibungen und erleichtert das schnelle Erfassen der Systemstruktur.3

## 3. Detaillierte Komponentenspezifikationen

Dieser Abschnitt geht detailliert auf die Spezifikationen der einzelnen Kernkomponenten von NovaDE ein, die in Abschnitt 2.2 identifiziert wurden. Für jede Komponente werden ihre spezifischen Verantwortlichkeiten, Schnittstellen, technischen Anforderungen und Designüberlegungen beschrieben.

### 3.1. Wayland Compositor (Smithay-basiert)

Der NovaDE Wayland Compositor ist die zentrale Komponente für die grafische Darstellung und Interaktion. Er basiert auf der Smithay-Bibliothek.5

- **Verantwortlichkeiten:**
    
    - Implementierung des Wayland-Server-Protokolls und relevanter Erweiterungen (z.B. `xdg-shell`, `xdg-decoration`, `layer-shell`, `input-method`, `screencopy`).
    - Fenstermanagement: Platzierung, Stapelung, Größenänderung, Minimierung, Maximierung von Fenstern.
    - Compositing: Zusammenführen der Inhalte verschiedener Fenster und Oberflächen zu einem finalen Bild für den Bildschirm. Dies beinhaltet Transparenz, Schatten und optionale Animationen/Effekte.
    - Eingabeverarbeitung: Empfang von Eingabeereignissen (Maus, Tastatur, Touch) vom Kernel (via `libinput`/`evdev`) und Weiterleitung an die entsprechenden Client-Fenster oder die Shell.5 Dies beinhaltet die Transformation von Bildschirmkoordinaten zu lokalen Fensterkoordinaten.6
    - Ausgabemanagement: Konfiguration von Monitoren (Auflösung, Bildwiederholrate, Position), Unterstützung für Multi-Monitor-Setups und Hot-Plugging.
    - Verwaltung von Oberflächenrollen (`wl_surface` roles), insbesondere der Subsurface-Rolle.25
    - Koordination mit XWayland für die Unterstützung von X11-Anwendungen.
- **Schnittstellen:**
    
    - **Wayland-Protokoll:** Kommunikation mit Wayland-Clients (Anwendungen, Shell).
    - **Kernel Mode Setting (KMS) / Direct Rendering Manager (DRM):** Direkte Interaktion mit der Grafikhardware für die Bildausgabe.5
    - **`libinput` (oder äquivalente Smithay-Integration):** Für die Verarbeitung von Eingabegeräteereignissen.
    - **D-Bus:** Für die Kommunikation mit anderen NovaDE-Diensten (z.B. Settings Daemon für Theme-Änderungen, Power Manager für Helligkeitssteuerung).
- **Technische Anforderungen und Designüberlegungen:**
    
    - **Performance:** Geringe Latenz bei Eingabe und Darstellung ist kritisch. Effiziente Nutzung von GPU-Ressourcen durch EGL und OpenGL ES / Vulkan. Zero-Copy-Mechanismen, wo möglich, um die CPU-Auslastung zu minimieren.12
    - **Stabilität und Sicherheit:** Als Kernkomponente muss der Compositor extrem robust sein. Die Speichersicherheit von Rust trägt hierzu bei. Sicherheitslücken im X11-Protokoll sollen durch Waylands Design vermieden werden.5
    - **Modularität (Smithay-Ansatz):** Smithay ist eine Bibliothek, kein Framework.24 Dies gibt NovaDE-Entwicklern volle Kontrolle über die Compositor-Architektur und -Logik, bedeutet aber auch mehr Verantwortung für die Implementierung von Kernfunktionalitäten. Die Auswahl und Integration von Smithay-Modulen (z.B. für `xdg-shell`, Client-Handling, Rendering) muss sorgfältig erfolgen. Die Dokumentation von Smithay (`docs.rs` und für den Master-Branch) ist eine wichtige Ressource.24
    - **Atomare Updates:** Wayland ist darauf ausgelegt, atomare Updates zu ermöglichen, um Tearing und inkonsistente Fensterzustände zu vermeiden.5 Dies muss im Compositor korrekt implementiert werden, insbesondere bei der Anwendung von Zustandsänderungen von Oberflächen und Subsurfaces.25 Smithay's `CompositorState` und `SurfaceData` helfen bei der kohärenten Verwaltung von Oberflächenzuständen und der Anwendung von Double-Buffered State.25
    - **Damage Tracking:** Effizientes Damage Tracking ist notwendig, um nur die Teile des Bildschirms neu zu zeichnen, die sich geändert haben. Dies ist entscheidend für die Performance und Energieeffizienz.
    - **XWayland-Integration:** Nahtlose und performante Integration von XWayland ist für die Abwärtskompatibilität unerlässlich. Herausforderungen wie Tastatur-Grabs 26 oder spezifische Fenstergeometrien 26 müssen adressiert werden.
    - **Unterstützung für Protokollerweiterungen:** Eine klare Strategie für die Unterstützung und Implementierung neuer und optionaler Wayland-Protokollerweiterungen ist notwendig, um mit der Entwicklung des Wayland-Ökosystems Schritt zu halten.
    - **Fehlerbehandlung:** Robuste Fehlerbehandlung bei ungültigen Client-Anfragen oder internen Fehlern. Smithay bietet Mechanismen zur Erkennung von Problemen wie ungültige Fenstergeometrien oder Rollen-Neuzuweisungen vor der Zerstörung.26
    - **Konfigurierbarkeit:** Bereitstellung von Optionen zur Anpassung des Compositor-Verhaltens (z.B. Animationen, Effekte) über den Settings Daemon.

Die Entwicklung eines Wayland-Compositors mit Smithay erfordert ein tiefes Verständnis des Wayland-Protokolls und der Linux-Grafik- und Eingabe-Subsysteme. Die aktive Community und die Issue-Tracker von Smithay 26 sind wichtige Quellen für Problemlösungen und Best Practices.

### 3.2. Desktop Shell (GTK4-basiert)

Die NovaDE Shell ist die primäre Schnittstelle für den Benutzer und basiert auf GTK4 und Rust.

- **Verantwortlichkeiten:**
    
    - Bereitstellung und Verwaltung von UI-Elementen wie Panel(s), Anwendungsstarter (Launcher), Task-Manager, System-Tray-Bereich, Desktop-Hintergrund und Desktop-Widgets.
    - Starten von Anwendungen und Verwalten laufender Anwendungsfenster (in Koordination mit dem Compositor).
    - Anzeige von Systemstatusinformationen (Netzwerk, Lautstärke, Akku etc.).
    - Integration mit dem Notification Service zur Anzeige von Benachrichtigungen.
    - Verwaltung von Arbeitsbereichen/virtuellen Desktops.
    - Bereitstellung von Suchfunktionen (Anwendungen, Dateien, Einstellungen).
    - Integration von `GtkApplication` für Menüleisten und automatische Ressourcenladung (z.B. Icons, Menüdefinitionen aus UI-Dateien).7
- **Schnittstellen:**
    
    - **Wayland-Protokoll:** Als Wayland-Client kommuniziert die Shell mit dem NovaDE Compositor, um ihre UI-Elemente als Wayland-Oberflächen (z.B. mittels `layer-shell` für Panels) darzustellen und Eingaben zu empfangen.
    - **D-Bus:** Kommunikation mit dem Session Manager (z.B. für Logout/Shutdown-Aktionen), Settings Daemon (für Theme- und Einstellungsänderungen), Notification Service, Power Manager und anderen Systemdiensten.
    - **GTK4 API:** Für die Erstellung und Verwaltung der UI-Elemente.
    - **PipeWire:** Indirekt über Portale oder Bibliotheken für Funktionen wie Lautstärkeregelung oder Mediensteuerung.
- **Technische Anforderungen und Designüberlegungen:**
    
    - **Performance und Reaktionsfähigkeit:** Die Shell muss auch bei hoher Systemlast flüssig und reaktionsschnell bleiben. Effiziente Nutzung von GTK4-Rendering und Minimierung von blockierenden Operationen im Hauptthread.
    - **Anpassbarkeit und Theming:** Umfangreiche Anpassungsmöglichkeiten für den Benutzer (Position und Inhalt von Panels, Themes, Icons, Schriftarten). GTK4-CSS wird für das Theming verwendet.27 Die Shell muss auf Änderungen der GTK-Einstellungen (z.B. `gtk-application-prefer-dark-theme` 9) reagieren.
    - **Modularität:** Einzelne Shell-Komponenten (z.B. Panel, Launcher, Widgets) sollten möglichst modular und austauschbar gestaltet sein, um Erweiterbarkeit und alternative Implementierungen zu ermöglichen.
    - **Barrierefreiheit (Accessibility):** Einhaltung von Standards für Barrierefreiheit unter Verwendung der AT-Context-APIs von GTK.28
    - **Multi-Monitor-Unterstützung:** Korrekte Darstellung und Verwaltung von Shell-Elementen auf mehreren Monitoren mit unterschiedlichen Auflösungen und DPI-Einstellungen.
    - **Zustandsverwaltung:** Effiziente Verwaltung des Zustands der Shell (z.B. geöffnete Menüs, aktive Widgets). Rust-Muster für die Zustandsverwaltung (z.B. Verwendung von `Arc<RwLock<T>>` oder `Rc<RefCell<T>>` je nach Threading-Modell 37, oder dedizierte State-Management-Bibliotheken wie `stateflow` 38 bei komplexen Zustandsautomaten) sind relevant.
    - **Integration mit `GtkApplication`:** Nutzung von `GtkApplication` für die Hauptanwendungslogik der Shell, um von dessen Features wie Anwendungs-Uniqueness, Session-Management-Integration und automatischer Ressourcenladung (Menüs, Icons) zu profitieren.7 Menüs können über `gtk/menus.ui` geladen und über `menu_by_id()` dynamisch manipuliert werden.7
    - **Icon-Handling:** Nutzung des `GtkIconTheme` und automatisches Hinzufügen von Ressourcenpfaden für anwendungsspezifische Icons.7

Die Entwicklung der Shell erfordert ein gutes Verständnis von GTK4, ereignisgesteuerter Programmierung und der Interaktion mit dem Wayland-Compositor und D-Bus-Diensten.

### 3.3. Session Manager

Der NovaDE Session Manager ist verantwortlich für den Lebenszyklus der Benutzersitzung.

- **Verantwortlichkeiten:**
    
    - Benutzerauthentifizierung (typischerweise delegiert an PAM oder einen Display Manager).
    - Starten der Kernkomponenten von NovaDE beim Login (Compositor, Shell, Settings Daemon, etc.).
    - Verwaltung von Umgebungsvariablen für die Sitzung.
    - Behandlung von Sitzungsereignissen wie Sperren, Abmelden, Herunterfahren, Neustarten.
    - Koordination mit `systemd-logind` (falls vorhanden) für Sitzungsmanagement und Hardware-Zugriffsrechte.
    - Bereitstellung einer D-Bus-Schnittstelle für andere Komponenten, um Sitzungsaktionen auszulösen (z.B. Logout-Button in der Shell).
- **Schnittstellen:**
    
    - **PAM (Pluggable Authentication Modules):** Für die Benutzerauthentifizierung.
    - **D-Bus:** Kommunikation mit `systemd-logind` und Bereitstellung einer eigenen D-Bus-Schnittstelle für Sitzungssteuerung. Andere NovaDE-Komponenten (z.B. Shell, Power Manager) interagieren über D-Bus mit dem Session Manager.8
    - **Prozessmanagement:** Starten und Überwachen der Kernprozesse der Desktop-Umgebung.
- **Technische Anforderungen und Designüberlegungen:**
    
    - **Sicherheit:** Sichere Handhabung von Authentifizierungsdaten und Sitzungsinformationen.
    - **Robustheit:** Zuverlässiges Starten und Beenden der Desktop-Umgebung. Fehler beim Start einzelner Komponenten müssen ggf. abgefangen und behandelt werden.
    - **Integration mit Systemdiensten:** Enge Integration mit `systemd-logind` oder alternativen Mechanismen zur Verwaltung von Sitzungen und Gerätezugriff (z.B. für DRM/KMS). PipeWire erfordert beispielsweise eine korrekte Sitzungseinrichtung für Geräte-ACLs.12
    - **Konfigurierbarkeit:** Möglichkeit zur Konfiguration von Autostart-Anwendungen und Sitzungsparametern.
    - **Schneller Start:** Optimierung der Startsequenz für ein schnelles Hochfahren der Desktop-Umgebung.

### 3.4. Settings Daemon und Konfigurationsmanagement

Der Settings Daemon zentralisiert die Verwaltung von System- und Benutzereinstellungen.

- **Verantwortlichkeiten:**
    
    - Bereitstellung einer zentralen Anlaufstelle für das Lesen und Schreiben von Konfigurationseinstellungen.
    - Verwaltung von Einstellungen für Erscheinungsbild (Theme, Icons, Schriftarten, Hintergrund), Hardware (Monitore, Eingabegeräte, Energieoptionen) und Verhalten der Desktop-Umgebung.
    - Benachrichtigung von interessierten Anwendungen und Komponenten über Einstellungsänderungen.
    - Laden von Standardeinstellungen und Zusammenführen mit benutzerspezifischen Anpassungen.
    - GTK-Einstellungen: Der Daemon ist verantwortlich für die Bereitstellung von GTK-spezifischen Einstellungen (z.B. `gtk-theme-name`, `gtk-font-name`, `gtk-application-prefer-dark-theme`). Diese werden typischerweise über einen XSettings-Manager (unter X11) oder einen Settings-Portal/DConf (unter Wayland) geteilt.9 GTK liest auch Standardwerte aus `settings.ini`-Dateien.9
- **Schnittstellen:**
    
    - **D-Bus:** Hauptschnittstelle für Anwendungen und Shell-Komponenten, um Einstellungen abzufragen und (ggf. mit entsprechenden Rechten) zu ändern. Signale werden verwendet, um über Änderungen zu informieren.
    - **Konfigurations-Backends:** Interaktion mit Speichermechanismen für Einstellungen (z.B. GSettings/DConf, INI-Dateien, XML-Dateien).
    - **XSettings-Protokoll (optional, für XWayland-Kompatibilität):** Falls erforderlich, um Einstellungen für X11-Anwendungen bereitzustellen.
- **Technische Anforderungen und Designüberlegungen:**
    
    - **Konsistenz:** Sicherstellung, dass alle Komponenten auf einen konsistenten Satz von Einstellungen zugreifen.
    - **Performance:** Schneller Zugriff auf Einstellungen und effiziente Benachrichtigung bei Änderungen. Caching-Mechanismen können hier sinnvoll sein.39
    - **Granularität:** Feingranulare Einstellungsoptionen, um eine detaillierte Anpassung durch den Benutzer zu ermöglichen.
    - **Schema-Definition:** Ein klares Schema für alle Konfigurationsparameter, inklusive Datentypen, erlaubter Werte und Standardwerte (siehe Tabelle 4 im Anhang).
    - **Migration:** Strategien für die Migration von Einstellungen bei Updates der Desktop-Umgebung.
    - **Sicherheit:** Zugriffskontrolle für das Ändern systemweiter oder sicherheitsrelevanter Einstellungen.
    - **Global Settings Management:** Die Verwaltung globaler Einstellungen ist ein kritischer Aspekt für die Stabilität und Konsistenz großer Anwendungen.39 Eine zentrale Konfigurationsverwaltung reduziert das Risiko von Ausfällen und Sicherheitslücken durch Nachverfolgbarkeit von Änderungen und Durchsetzung von Richtlinien.40

Eine Herausforderung beim Konfigurationsmanagement ist die Balance zwischen Flexibilität für den Benutzer und der Komplexität der Verwaltung. Eine klare Struktur und gute Werkzeuge zur Konfiguration sind entscheidend.

### 3.5. Notification Service

Der Notification Service ist für die Anzeige von Desktop-Benachrichtigungen zuständig.

- **Verantwortlichkeiten:**
    
    - Implementierung der Freedesktop Desktop Notifications Specification.
    - Empfang von Benachrichtigungsanfragen von Anwendungen und Systemdiensten.
    - Verwaltung einer Warteschlange für Benachrichtigungen.
    - Anzeige von Benachrichtigungen als Pop-ups oder in einem Benachrichtigungscenter, gemäß den Benutzereinstellungen und dem aktuellen Systemzustand (z.B. "Nicht stören"-Modus).
    - Unterstützung für Aktionen in Benachrichtigungen.
    - Persistenz von Benachrichtigungen (optional, für ein Benachrichtigungscenter).
- **Schnittstellen:**
    
    - **D-Bus:** Empfängt Benachrichtigungsanfragen über die standardisierte D-Bus-Schnittstelle (`org.freedesktop.Notifications`).
    - **NovaDE Shell:** Interagiert mit der Shell zur Darstellung der Benachrichtigungs-UI.
    - **Settings Daemon:** Abfrage von Benutzereinstellungen bezüglich Benachrichtigungen (z.B. Position, Timeout, "Nicht stören"-Modus).
- **Technische Anforderungen und Designüberlegungen:**
    
    - **Zuverlässigkeit:** Benachrichtigungen müssen zuverlässig zugestellt und angezeigt werden.41
    - **Performance:** Der Dienst darf das System nicht übermäßig belasten, auch bei vielen eingehenden Benachrichtigungen.
    - **Anpassbarkeit:** Benutzer sollten das Aussehen und Verhalten von Benachrichtigungen anpassen können.
    - **Regel-Engine (optional):** Eine erweiterte Implementierung könnte eine Regel-Engine enthalten, um Benachrichtigungen basierend auf Quelle, Inhalt oder Systemzustand unterschiedlich zu behandeln (z.B. Priorisierung, Stummschaltung).42 Eine solche Engine würde aus einer Sammlung von Regeln, einem Eingabemechanismus, Trigger-Bedingungen und Aktionen bestehen.42
    - **Rate Limiting und Queuing:** Um eine Überlastung des Systems oder des Benutzers zu vermeiden, sollten Mechanismen für Rate Limiting und Queuing implementiert werden.41
    - **Logging:** Detailliertes Logging zur Fehlerbehebung und Nachverfolgung von Benachrichtigungsflüssen.41
    - **Datenbankschema (für Persistenz):** Falls Benachrichtigungen persistiert werden, ist ein gut designtes Datenbankschema für Benutzerpräferenzen, Anfragen und Zustellstatus erforderlich.41

Die Architektur eines Benachrichtigungssystems umfasst typischerweise einen Client (die Anwendung, die die Benachrichtigung sendet), einen Notification Server (der die Anfragen verarbeitet und in die Warteschlange stellt) und einen Notification Executor (der die Benachrichtigungen über die entsprechenden Kanäle zustellt).44

### 3.6. Weitere Systemdienste (z.B. Power Management, Workspace Management)

Neben den oben genannten Hauptkomponenten können weitere spezialisierte Systemdienste existieren.

- **Power Manager:**
    
    - **Verantwortlichkeiten:** Überwachung des Batteriestatus, Umschaltung zwischen Energieprofilen, Initiierung von Suspend/Hibernate, Steuerung der Bildschirmhelligkeit, Reaktion auf Deckel-Schließen-Events bei Laptops.
    - **Schnittstellen:** D-Bus (Interaktion mit `UPower`, `systemd-logind`, Settings Daemon, Shell).
    - **Anforderungen:** Geringer Ressourcenverbrauch, zuverlässige Reaktion auf Energieereignisse.
- **Workspace Manager:**
    
    - **Verantwortlichkeiten:** Logik für die Verwaltung von virtuellen Desktops/Arbeitsbereichen, Verschieben von Fenstern zwischen Arbeitsbereichen, Speichern und Wiederherstellen von Fensteranordnungen pro Arbeitsbereich (optional). Die Implementierung ist oft eng mit dem Compositor und der Shell verwoben.
    - **Schnittstellen:** Interne APIs mit Compositor und Shell, D-Bus für die Steuerung durch externe Tools oder Skripte.
    - **Anforderungen:** Effiziente Verwaltung von Fensterzuständen, intuitive Bedienung. Die Komplexität der Workspace-Verwaltung kann mit der von Projektmanagement-Tools verglichen werden, bei denen es darum geht, Aufgaben (Fenster) in verschiedenen Kontexten (Arbeitsbereichen) zu organisieren und den Überblick zu behalten.10 Funktionen wie das "Verpacken" von Fenstern in Ordner-ähnliche Strukturen oder das Speichern und Abrufen von Layouts (Screensets) sind denkbare Erweiterungen.10
- **Model Context Protocol (MCP) Host (optional, falls KI-Funktionen integriert werden):**
    
    - **Verantwortlichkeiten:** Dient als Container oder Koordinator für MCP-Client-Instanzen innerhalb von NovaDE (z.B. ein KI-Assistent). Verwaltet den Lebenszyklus, Sicherheitspolicies (Berechtigungen, Benutzerautorisierung, Zustimmung) und die Interaktion zwischen KI-Modellen und MCP-Servern (externe Werkzeuge und Datenquellen).17
    - **Schnittstellen:** MCP (JSON-RPC über lokale Prozesse oder HTTP-Streams), interne APIs mit der KI-Anwendung, D-Bus für die Systemintegration.
    - **Anforderungen:** Starke Authentifizierung zwischen Host, Client und Servern, explizite und bereichsbezogene Autorisierung, Eingabevalidierung und Ausgabesanitisierung, Ratenbegrenzung, Überwachung und Logging.19 Die Sicherheit ist hier von größter Bedeutung, da MCP den Zugriff auf sensible Daten und Systemfunktionen ermöglichen kann.19 Ein kompromittierter MCP-Server könnte Daten stehlen oder Befehle manipulieren.19

Die Notwendigkeit und das Design weiterer Dienste ergeben sich aus den spezifischen Anforderungen der Nutzererfahrung und den geplanten Features von NovaDE.

## 4. Nicht-funktionale Anforderungen (NFRs)

Nicht-funktionale Anforderungen definieren, _wie_ das System seine Funktionen ausführt, und sind entscheidend für die Qualität und Akzeptanz der Software.45 Sie müssen spezifisch, messbar, erreichbar, relevant und zeitgebunden (SMART) formuliert werden. Die Vernachlässigung von NFRs kann dazu führen, dass eine Software trotz voller Funktionalität die Erwartungen der Nutzer nicht erfüllt.46

### 4.1. Performance

- **Reaktionszeiten:**
    - Start der Desktop-Umgebung (vom Login bis zur vollen Nutzbarkeit): <5 Sekunden auf Zielhardware.
    - Start typischer Anwendungen (Texteditor, Browser): <2 Sekunden.
    - Öffnen des Anwendungsstarters: <300 ms.
    - Fensteroperationen (Öffnen, Schließen, Minimieren, Verschieben, Größenänderung): Visuell unmittelbar, Latenz <50 ms.
    - Shell-Animationen und -Effekte: Mindestens 60 FPS, um Flüssigkeit zu gewährleisten.
- **Ressourcennutzung:**
    - Leerlauf-CPU-Auslastung des Desktops (ohne laufende Anwendungen): <5% auf einem einzelnen Kern der Zielhardware.
    - RAM-Nutzung der Kern-Desktop-Prozesse (Compositor, Shell, Session Manager) im Leerlauf: <512 MB insgesamt.
    - Die Performance-Anforderungen müssen unter Berücksichtigung der aktuellen Systemlast spezifiziert werden.45
- **Datendurchsatz (falls relevant, z.B. für Dateioperationen im Dateimanager):** Spezifische Metriken je nach Anwendungsfall.
- **PipeWire Latenz:** Für Audio-Anwendungen ist eine geringe Latenz wichtig. PipeWire ermöglicht die Konfiguration von Quanten und Raten, um die Latenz zu beeinflussen (z.B. 11 ms für Bluetooth-Headsets, 90 ms für Video-Apps bei 48 kHz).12 Die Latenz wird als Verhältnis von Quantum zu Rate berechnet.12

### 4.2. Stabilität und Zuverlässigkeit

- **Mean Time Between Failures (MTBF):** Für Kernkomponenten (Compositor, Shell) wird ein MTBF von >1000 Betriebsstunden angestrebt.
- **Fehlertoleranz:** Absturz einer einzelnen Anwendung darf nicht zur Instabilität des gesamten Desktops führen. Der Compositor muss robust gegenüber fehlerhaften Clients sein.
- **Wiederherstellbarkeit:** Im Falle eines Absturzes einer Kernkomponente (z.B. Shell) soll ein automatischer Neustart ohne Datenverlust der laufenden Anwendungen (soweit möglich) erfolgen.
- **Verfügbarkeit:** Die Verfügbarkeit des Systems sollte hoch sein, z.B. 99.9%.46 Dies muss unter Berücksichtigung der finanziellen und kritischen Auswirkungen von Ausfallzeiten definiert werden.45

### 4.3. Sicherheit

- **Zugriffskontrolle:** Strikte Trennung von Benutzerprivilegien und Systemprivilegien. Prozesse laufen mit minimal notwendigen Rechten (Principle of Least Privilege).
- **Datenschutz:** Schutz sensibler Benutzerdaten (Passwörter, private Dateien) vor unbefugtem Zugriff. Einhaltung relevanter Datenschutzbestimmungen (z.B. DSGVO).
- **Wayland-Sicherheitsmodell:** Wayland ist inhärent sicherer als X11, da Clients isolierter sind und keinen direkten Zugriff auf die Eingaben oder Fensterinhalte anderer Clients haben.5 Der Compositor agiert als Gatekeeper.
- **D-Bus-Sicherheit:** Der System-Bus von D-Bus verfügt über Sicherheitsmechanismen, die einschränken, welche Prozesse Namen besitzen oder Methodenaufrufe senden dürfen.30 Session-Busse gelten typischerweise nicht als Sicherheitsgrenze innerhalb der Benutzersitzung.30
- **Sicherheitsupdates:** Ein klar definierter Prozess für die schnelle Bereitstellung von Sicherheitsupdates.
- **Schutz vor Angriffen:** Maßnahmen zum Schutz vor gängigen Angriffsvektoren (z.B. SQL-Injection, XSS bei Web-basierten Komponenten – falls vorhanden, Code Injection durch unsichere Plugin-Schnittstellen).
- **MCP-Sicherheit (falls implementiert):** Starke Authentifizierung, explizite Autorisierung, Eingabevalidierung, Ausgabesanitisierung, Ratenbegrenzung und Sandboxing sind für MCP-Komponenten unerlässlich.17 Die Verwendung von nicht überprüften MCP-Paketen stellt ein Risiko dar.20

### 4.4. Skalierbarkeit

- **Anzahl gleichzeitiger Anwendungen:** Das System muss auch bei einer großen Anzahl (>50) gleichzeitig laufender Anwendungen performant und stabil bleiben.
- **Multi-Monitor-Unterstützung:** Unterstützung für mindestens 4 Monitore mit unterschiedlichen Auflösungen und DPI-Einstellungen ohne signifikanten Performanceverlust.
- **Anpassung an Hardware:** Das System soll auf einer breiten Palette von Hardware, von Low-End-Laptops bis zu High-End-Workstations, zufriedenstellend laufen. Dies kann unterschiedliche Konfigurationsprofile erfordern.
- **PipeWire Skalierbarkeit:** PipeWire ist darauf ausgelegt, eine große Anzahl von Multimedia-Streams effizient zu verwalten.12

### 4.5. Wartbarkeit

- **Code-Komplexität:** Reduzierung der Code-Komplexität durch modulare Bauweise und klare Schnittstellen.47 Verwendung von Code-Qualitäts-Tools (Linters, statische Analyse).
- **Dokumentation:** Umfassende und aktuelle Entwicklerdokumentation (API-Referenzen, Architektur-Beschreibungen).1
- **Testbarkeit:** Hohe Testabdeckung durch Unit-, Integrations- und UI-Tests.2
- **Logging und Debugging:** Aussagekräftige Log-Meldungen und gute Debugging-Unterstützung.
- **Standardisierte Formate und Prozesse:** Einhaltung von Coding-Standards und Entwicklungsprozessen.1
- Die Wartbarkeit wird durch die Lesbarkeit und Verständlichkeit des Codes beeinflusst. Klare Namenskonventionen und eine konsistente Code-Struktur sind hierfür wichtig.48

### 4.6. Benutzbarkeit (Usability)

Obwohl primär durch UX-Spezifikationen definiert, hat die Benutzbarkeit auch technische Implikationen:

- **Konsistenz:** Einheitliches Erscheinungsbild und Verhalten über alle NovaDE-Komponenten hinweg.
- **Barrierefreiheit (Accessibility):** Einhaltung von a11y-Standards (z.B. WCAG für Web-Inhalte, entsprechende GTK-Richtlinien). Wayland selbst hat Herausforderungen im Bereich Barrierefreiheit, die durch Protokollerweiterungen und Toolkit-Unterstützung adressiert werden müssen.23
- **Internationalisierung (i18n) und Lokalisierung (l10n):** Unterstützung für verschiedene Sprachen und regionale Formate.
- **Konfigurierbarkeit:** Einfache und verständliche Anpassungsmöglichkeiten für den Benutzer.
- Messbare Usability-Ziele sollten auf Basis von Benutzertests (ggf. mit Prototypen oder Konkurrenzprodukten) festgelegt werden.45

### 4.7. Kompatibilität

- **Anwendungskompatibilität:**
    - Native Wayland-Anwendungen (GTK, Qt): Vollständige Unterstützung.
    - X11-Anwendungen: Unterstützung über XWayland.15 Es muss sichergestellt werden, dass gängige X11-Anwendungen (Browser, Office-Suiten, Spiele) unter XWayland zufriedenstellend funktionieren. Bekannte Probleme mit XWayland (z.B. bei spezifischen Anwendungen wie Krita, Discord, OBS 15) müssen adressiert oder dokumentiert werden.
    - Flatpak/Snap-Anwendungen: Integration über XDG Desktop Portals für den Zugriff auf Systemressourcen.6
- **Hardwarekompatibilität:** Unterstützung für gängige Grafikchips (Intel, AMD, NVIDIA – letztere oft mit proprietären Treibern und spezifischen Herausforderungen unter Wayland), Eingabegeräte und Peripherie.
- **Freedesktop.org-Standards:** Einhaltung relevanter Standards für Interoperabilität (z.B. Desktop Entry Specification, Icon Theme Specification, MIME-Type System, Notification Specification).

Die Dokumentation von NFRs sollte in Zusammenarbeit mit verschiedenen Stakeholdern erfolgen und NFRs sollten mit Geschäftszielen verknüpft werden.45 Es ist wichtig, Einschränkungen durch Drittanbieter-APIs oder bestehende Architekturen zu berücksichtigen.45 Eine separate Verfolgung von NFRs und regelmäßige Überprüfung wird empfohlen.46

## 5. Schnittstellenspezifikationen

Dieser Abschnitt definiert die wichtigsten internen und externen Schnittstellen von NovaDE. Eine klare Definition dieser Schnittstellen ist entscheidend für die modulare Entwicklung und die Interoperabilität der Komponenten.

### 5.1. Interne APIs (zwischen NovaDE-Komponenten)

- **D-Bus Schnittstellen:**
    
    - **Definition:** Jede NovaDE-Komponente, die Dienste für andere Komponenten bereitstellt (z.B. Settings Daemon, Session Manager, Notification Service), exponiert eine oder mehrere D-Bus-Schnittstellen. Diese Schnittstellen definieren Objekte, Methoden, Signale und Eigenschaften.8
    - **Designrichtlinien:**
        - Verwendung sprechender Namen für Dienste, Pfade, Schnittstellen, Methoden und Signale (z.B. `org.novade.Settings`, `/org/novade/Settings`, `org.novade.Settings.Interface`, `GetSetting`, `SettingChanged`). Versionierung sollte in Namen inkludiert werden, um API-inkompatible Änderungen zu handhaben (z.B. `org.novade.MyService1`).30
        - Minimierung der Anzahl von Roundtrips durch gut gestaltete Methoden (z.B. Rückgabe mehrerer verwandter Werte in einer Methode statt mehrerer einzelner Aufrufe).30
        - Nutzung des D-Bus-Typsystems: Strukturierte Daten (Structs, Arrays, Dictionaries) sollten nativen D-Bus-Typen anstelle von serialisierten Strings vorgezogen werden. Enumerierte Werte als Unsigned Integers übertragen, um String-Parsing zu vermeiden und die Nachrichten kompakter zu halten.30
        - Klare Dokumentation jeder Schnittstelle, ihrer Methoden, Argumente, Rückgabewerte und Signale. Die Bedeutung von Enum-Werten muss dokumentiert werden.30
        - Verwendung von `org.freedesktop.DBus.Properties` für den Zugriff auf Eigenschaften, anstatt spezifischer Get/Set-Methoden für jede Eigenschaft.30
    - **Sicherheit:** D-Bus-Richtlinien (Policy-Dateien) definieren, welche Benutzer oder Prozesse auf welche Schnittstellen und Methoden zugreifen dürfen, insbesondere auf dem System-Bus.
    - **Beispiele:**
        - Session Manager: `org.novade.SessionManager.Logout()`, `org.novade.SessionManager.CanShutdownChanged (Signal)`.
        - Settings Daemon: `org.novade.Settings.GetValue(category, key)`, `org.novade.Settings.SetValue(category, key, value)`, `org.novade.Settings.ValueChanged (Signal)`.
- **Wayland Protokollerweiterungen (falls spezifisch für NovaDE):**
    
    - Falls NovaDE eigene, private Wayland-Protokollerweiterungen für die Kommunikation zwischen dem Compositor und der Shell (oder anderen internen Clients) benötigt, müssen diese hier spezifiziert werden.
    - **Definition:** XML-basierte Protokolldateien, die neue Interfaces, Requests, Events und Enums definieren.6
    - **Generierung:** C-Header und Glue-Code können mit `wayland-scanner` generiert werden.5 Für Rust werden entsprechende Generatoren oder manuelle Bindings benötigt.
    - **Stabilität:** Private Protokolle sollten als instabil betrachtet und klar als solche gekennzeichnet werden, um externe Abhängigkeiten zu vermeiden.
- **Interne Rust-Bibliotheks-APIs (Crates):**
    
    - NovaDE wird voraussichtlich aus mehreren Rust-Crates bestehen. Die öffentlichen APIs dieser Crates (Funktionen, Structs, Traits, Enums, Module) müssen klar definiert und dokumentiert sein (`rustdoc`).
    - **Richtlinien:** Einhaltung der offiziellen Rust API Guidelines.21 Dies beinhaltet Aspekte wie Namenskonventionen (C-CASE, C-CONV, C-GETTER, C-ITER), Implementierung gängiger Traits (C-COMMON-TRAITS wie `Debug`, `Clone`, `Send`, `Sync`), Fehlerbehandlung (C-GOOD-ERR), Dokumentation (C-CRATE-DOC, C-EXAMPLE) und Zukunftsfähigkeit (C-STRUCT-PRIVATE, C-SEALED).
    - **Modularität:** Crates sollten klar definierte Verantwortlichkeiten haben und lose gekoppelt sein.

### 5.2. Externe APIs (für Drittanbieter-Anwendungen)

- **Wayland Protokoll:**
    
    - NovaDE implementiert Standard-Wayland-Protokolle und -Erweiterungen (z.B. `xdg-shell`, `xdg-decoration`, `wl_output`, `wl_seat`). Anwendungen interagieren mit NovaDE primär über diese Protokolle.
    - Die unterstützten Protokolle und deren Versionen müssen dokumentiert werden.
    - Wayland ist ein asynchrones, objektorientiertes Protokoll. Clients fordern Dienste vom Compositor an, indem sie Methoden auf Objekten aufrufen. Der Compositor sendet Informationen an Clients, indem Objekte Ereignisse auslösen.6
- **D-Bus Schnittstellen (öffentlich):**
    
    - NovaDE kann ausgewählte D-Bus-Schnittstellen für Drittanbieter-Anwendungen bereitstellen (z.B. für Statusinformationen, Abfrage von Desktop-Funktionen).
    - Diese Schnittstellen müssen stabil, versioniert und gut dokumentiert sein.
    - Beispiel: Eine Schnittstelle, um die aktuelle Theme-Farbe oder den "Nicht stören"-Status abzufragen.
- **XDG Desktop Portals:**
    
    - Für sandboxed Anwendungen (Flatpak, Snap) ist die Interaktion über XDG Desktop Portals der bevorzugte Weg, um auf Systemressourcen zuzugreifen (Dateiauswahl, Öffnen von URIs, Drucken, Screen-Sharing etc.).
    - NovaDE muss die Backend-Implementierungen für die relevanten Portale bereitstellen (z.B. `xdg-desktop-portal-novade` oder Nutzung von generischen Backends wie `xdg-desktop-portal-gtk`). PipeWire integriert sich mit Portalen für Screen-Sharing.6
- **Freedesktop.org Standards:**
    
    - Anwendungen verlassen sich auf die Einhaltung von Freedesktop.org-Standards durch die Desktop-Umgebung für eine nahtlose Integration. Dazu gehören:
        - Desktop Entry Specification (`.desktop`-Dateien für Anwendungsmenüs).
        - Icon Theme Specification (Auffinden und Anzeigen von Icons).
        - MIME Applications Associations (Zuordnung von Dateitypen zu Anwendungen).
        - Desktop Notifications Specification (bereits durch den Notification Service abgedeckt).
        - Status Notifier Item Specification (für System-Tray-Icons, falls unterstützt).

### 5.3. Model Context Protocol (MCP) Schnittstellen (falls zutreffend)

Falls NovaDE KI-gestützte Funktionen integriert, die auf dem Model Context Protocol basieren, sind dessen Schnittstellen relevant.

- **MCP-Architektur:** MCP verwendet eine Client-Server-Architektur. Die KI-Anwendung (z.B. ein Desktop-Assistent) fungiert als Host und betreibt einen MCP-Client. Externe Integrationen (Tools, Datenquellen) laufen als MCP-Server.17
- **Kommunikation:** Erfolgt über standardisierte JSON-RPC-Nachrichten.17
    - Beispielhafte Methoden: `tools/list` (um verfügbare Werkzeuge aufzulisten), `tools/call` (um ein Werkzeug mit Parametern aufzurufen).17
- **MCP-Primitive:**
    - **Tools:** Vom Modell gesteuerte API-Aufrufe oder Operationen (z.B. Datei schreiben, Kalendereintrag erstellen).18
    - **Resources:** Von der Anwendung gesteuerte kontextuelle Daten (z.B. Dateiinhalte, Git-Historie).18
    - **Prompts:** Vom Benutzer gesteuerte Vorlagen oder Anweisungen (z.B. Slash-Befehle).18
- **Sicherheitsaspekte:** Da MCP den Zugriff auf externe Dienste und potenziell sensible Daten ermöglicht, sind strenge Sicherheitsmaßnahmen unerlässlich:
    - **Authentifizierung:** Starke Authentifizierung zwischen Host, Client und Server (z.B. API-Keys, Tokens, mTLS).19 Clients sollten nur mit vertrauenswürdigen, whitelisted Servern verbinden.19
    - **Autorisierung:** Explizite, bereichsbezogene Autorisierung nach dem Prinzip der geringsten Rechte.19
    - **Eingabevalidierung und Ausgabesanitisierung:** Alle über MCP fließenden Daten müssen als potenziell bösartig behandelt und validiert/sanitisiert werden, um Injection-Angriffe oder Verwirrung des KI-Modells zu verhindern.19
    - **Ratenbegrenzung und Ressourcenbeschränkungen:** Um Missbrauch oder Überlastung zu verhindern.19
    - **Überwachung und Logging:** Zur Nachverfolgung von Aktivitäten und Erkennung von Anomalien.19
    - Die Integration von MCP erhöht das Risiko von Supply-Chain-Angriffen und Compliance-Verletzungen, wenn nicht sorgfältig gehandhabt.20

Die Definition und Dokumentation dieser Schnittstellen muss klar, präzise und für die jeweilige Zielgruppe verständlich sein.1 Die Verwendung von API-Beschreibungssprachen (z.B. OpenAPI für HTTP-basierte D-Bus-Alternativen, falls vorhanden, oder XML für Wayland-Protokolle) kann die Konsistenz und Maschinenlesbarkeit verbessern.

## 6. Entwicklungsrichtlinien und -standards

Dieser Abschnitt legt die Richtlinien und Standards für den Entwicklungsprozess von NovaDE fest. Ziel ist es, eine hohe Codequalität, Wartbarkeit, Konsistenz und Effizienz im gesamten Projekt sicherzustellen. Die Einhaltung dieser Richtlinien ist für alle Mitwirkenden verbindlich.

### 6.1. Programmierrichtlinien (Rust)

Die Entwicklung von NovaDE-Komponenten in Rust folgt den offiziellen und Community-etablierten Best Practices.

- **Rust Edition:** Verwendung der neuesten stabilen Rust Edition (z.B. 2021 oder neuer), um von aktuellen Sprachfeatures und Verbesserungen zu profitieren. Für Meson-Projekte ist die Angabe `rust_std=2018` (oder neuer) in den `project(default_options)` wichtig, um `extern crate` zu vermeiden.35
- **Offizielle Rust API Guidelines:** Strikte Einhaltung der Rust API Guidelines.21 Dies umfasst:
    - **Naming Conventions (C-CASE, C-CONV, C-GETTER, C-ITER, C-ITER-TY, C-FEATURE, C-WORD-ORDER):** Konforme Benennung von Crates, Modulen, Typen, Funktionen, Variablen etc.
    - **Interoperabilität (C-COMMON-TRAITS, C-CONV-TRAITS, C-COLLECT, C-SEND-SYNC, C-GOOD-ERR, C-NUM-FMT, C-RW-VALUE):** Implementierung gängiger Traits (`Debug`, `Clone`, `Eq`, `PartialEq`, `Ord`, `PartialOrd`, `Hash`, `Display`, `Default`, `Send`, `Sync`, `From`, `AsRef`, `AsMut`, `FromIterator`, `Extend`), sinnvolle Fehlertypen, Formatierungsoptionen für Zahlentypen.
    - **Macros (C-EVOCATIVE, C-MACRO-ATTR, C-ANYWHERE, C-MACRO-VIS, C-MACRO-TY):** Wohlgeformte und intuitive Makros.
    - **Dokumentation (C-CRATE-DOC, C-EXAMPLE, C-QUESTION-MARK, C-FAILURE, C-LINK, C-METADATA, C-RELNOTES, C-HIDDEN):** Umfassende Dokumentation (siehe auch Abschnitt 6.7).
    - **Vorhersagbarkeit (C-SMART-PTR, C-CONV-SPECIFIC, C-METHOD, C-NO-OUT, C-OVERLOAD, C-DEREF, C-CTOR):** Code soll sich so verhalten, wie er aussieht.
    - **Flexibilität (C-INTERMEDIATE, C-CALLER-CONTROL, C-GENERIC, C-OBJECT):** APIs sollen diverse Anwendungsfälle unterstützen.
    - **Typsicherheit (C-NEWTYPE, C-CUSTOM-TYPE, C-BITFLAG, C-BUILDER):** Effektive Nutzung des Typsystems.
    - **Verlässlichkeit (C-VALIDATE, C-DTOR-FAIL, C-DTOR-BLOCK):** Robuster Code, der Argumente validiert und in Destruktoren nicht fehlschlägt oder blockiert.
    - **Debuggability (C-DEBUG, C-DEBUG-NONEMPTY):** Alle öffentlichen Typen implementieren `Debug`.
    - **Zukunftsfähigkeit (C-SEALED, C-STRUCT-PRIVATE, C-NEWTYPE-HIDE, C-STRUCT-BOUNDS, C-STABLE, C-PERMISSIVE):** Design für Weiterentwicklung ohne Breaking Changes.
- **Rust Style Guide:** Einhaltung des offiziellen Rust Style Guide 22 für Code-Formatierung (Einrückung, Zeilenlänge, Kommentare, Attribute). Die Verwendung von `rustfmt` mit der Standardkonfiguration wird dringend empfohlen, um Konsistenz zu gewährleisten und unnötige Diskussionen über Stilfragen zu vermeiden.22
    - Einrückung: 4 Leerzeichen, keine Tabs.
    - Maximale Zeilenlänge: 100 Zeichen.
    - Kommentare: Bevorzugt Zeilenkommentare (`//`).
    - Attribute: Jedes Attribut auf eigener Zeile.
- **Clippy:** Regelmäßige Verwendung von Clippy (`cargo clippy`) zur Identifizierung von idiomatischen Verbesserungen und häufigen Fehlern. Alle Clippy-Warnungen (mindestens die Standard-Lints) müssen vor dem Mergen von Code behoben werden.
- **Fehlerbehandlung:**
    - Bevorzugung von `Result<T, E>` für Fehler, die behandelt werden können.
    - Verwendung der `thiserror`-Crate zur Erstellung spezifischer, aussagekräftiger Fehlertypen für Bibliotheken.49 `thiserror` reduziert Boilerplate durch automatische Implementierung von `std::error::Error` und `Display` und ermöglicht einfaches Hinzufügen von Kontext und Komposition von Fehlertypen.50 Die `#[from]`-Attribut ist nützlich für die Konvertierung von Fehlern aus anderen Bibliotheken.51
    - Die `anyhow`-Crate kann für Anwendungs-Code verwendet werden, wo es weniger auf spezifische Fehlertypen ankommt und einfache Fehlerpropagation gewünscht ist.52 `anyhow` ist jedoch ein opaquer Fehlertyp, der eine Fehlerbehandlung durch den Aufrufer erschwert und eher für das "Durchreichen" von Fehlern gedacht ist.52
    - Panics sollten auf nicht behebbare Fehler beschränkt sein (z.B. Programmierfehler, inkonsistente Zustände). Bibliotheks-Code sollte möglichst nicht panicen.
    - Fehlermeldungen sollten kontextbezogen und für Entwickler hilfreich sein.
- **Unsafe Code:** Die Verwendung von `unsafe` Rust ist auf ein absolutes Minimum zu beschränken und nur dort einzusetzen, wo es unumgänglich ist (z.B. FFI, direkte Hardware-Interaktion). Jeder `unsafe`-Block muss detailliert kommentiert werden, um die Notwendigkeit und die erfüllten Sicherheitsbedingungen zu rechtfertigen.
- **Nebenläufigkeit (Concurrency):** Nutzung der Rust-eigenen Sicherheitsmechanismen für Nebenläufigkeit (Ownership, Borrowing, `Send`, `Sync`). Bevorzugung von High-Level-Abstraktionen (z.B. `async/await`, `tokio`, `crossbeam`) gegenüber manueller Thread- und Mutex-Verwaltung.
- **Abhängigkeitsmanagement (Cargo):**
    - Sorgfältige Auswahl von externen Crates. Bevorzugung von gut gewarteten, stabilen und weit verbreiteten Bibliotheken.
    - Regelmäßige Überprüfung und Aktualisierung von Abhängigkeiten (`cargo update`).
    - Minimierung der Anzahl von Abhängigkeiten, um Build-Zeiten und Angriffsflächen klein zu halten.
    - Verwendung von semantischer Versionierung.
- **Modulstruktur:** Code sollte logisch in Modulen und Crates organisiert sein, um die Lesbarkeit und Wartbarkeit zu verbessern.53 Domain-Driven Design (DDD) Prinzipien können bei der Strukturierung komplexer Domänen helfen 54, ebenso wie Event-Sourcing-Muster für zustandsbehaftete Systeme, die eine Historie von Änderungen benötigen.56
- **Performance:** Code sollte unter Berücksichtigung von Performance geschrieben werden, ohne jedoch verfrühte Optimierung zu betreiben. Profiling-Tools sind zur Identifizierung von Engpässen einzusetzen.

### 6.2. Code-Review-Prozess

Code-Reviews sind ein integraler Bestandteil des Entwicklungsprozesses, um Code-Qualität, Konsistenz und Wissensaustausch zu gewährleisten.47

- **Review-Pflicht:** Jeder Code-Beitrag (Feature, Bugfix) muss vor dem Mergen in den Hauptentwicklungszweig von mindestens einer anderen Person (idealerweise zwei) gereviewt werden.
- **Review-Kriterien:**
    - Korrektheit und Funktionalität gemäß den Anforderungen.
    - Einhaltung der Programmierrichtlinien (Abschnitt 6.1).
    - Lesbarkeit, Verständlichkeit und Wartbarkeit des Codes.
    - Angemessene Testabdeckung (Unit- und Integrationstests).
    - Aktualität und Korrektheit der Dokumentation (API-Docs, Kommentare).
    - Performance-Implikationen.
    - Sicherheitsaspekte.
    - Keine Einführung von Regressionen.
- **Werkzeuge:** Verwendung von Plattformen wie GitLab oder GitHub für Merge Requests und Inline-Kommentare.
- **Konstruktives Feedback:** Reviews sollten konstruktiv, respektvoll und auf den Code fokussiert sein. Ziel ist die Verbesserung des Codes und des gemeinsamen Verständnisses.
- **Verantwortung des Autors:** Der Autor ist verantwortlich für die Adressierung der Review-Kommentare und die Sicherstellung der Code-Qualität.
- **Zeitnahe Reviews:** Reviews sollten zeitnah durchgeführt werden, um den Entwicklungsfluss nicht unnötig zu blockieren.

Durch Code-Reviews können Fehler frühzeitig erkannt, die Codequalität verbessert und das Wissen im Team verteilt werden. Ein Senior-Kollege kann beispielsweise ineffiziente Datenbankabfragen identifizieren und Optimierungen vorschlagen, die die Performance erheblich verbessern.47

### 6.3. Versionskontrollstrategie (Git)

Eine konsistente Versionskontrollstrategie ist entscheidend für die Zusammenarbeit und Nachverfolgbarkeit.

- **Branching-Modell:** Empfohlen wird ein Modell wie Git Flow oder ein einfacheres GitHub/GitLab Flow.
    - `main` (oder `master`): Enthält stabilen, produktionsreifen Code. Direkte Commits sind verboten.
    - `develop`: Hauptentwicklungszweig, von dem Feature-Branches abzweigen und in den sie zurückgemerged werden.
    - Feature-Branches (`feature/name-des-features`): Für die Entwicklung neuer Funktionen.
    - Release-Branches (`release/version-nummer`): Zur Vorbereitung von Releases (Stabilisierung, Bugfixing).
    - Hotfix-Branches (`hotfix/problem-beschreibung`): Für dringende Korrekturen an produktivem Code.
- **Commit-Nachrichten:**
    - Müssen klar, prägnant und im Imperativ formuliert sein (z.B. "Fix: Behebe Absturz beim Fenster schließen").
    - Sollten eine Zusammenfassungszeile (max. 50 Zeichen) und optional einen detaillierteren Body enthalten.
    - Bezugnahme auf Issue-Nummern (z.B. "Fixes #123").
- **Merging:**
    - Bevorzugung von Merge Requests (Pull Requests) für alle Änderungen an `develop` und `main`.
    - Squash-Merges oder Rebase-Merges können verwendet werden, um die Commit-Historie sauber zu halten, abhängig von der Teampräferenz.
- **Tagging:** Releases auf dem `main`-Branch müssen mit einer Versionsnummer getaggt werden (gemäß Semantischer Versionierung, z.B. `v1.2.3`).
- **Code-Formatierung vor Commit:** Es wird empfohlen, Code vor dem Commit automatisch mit `rustfmt` zu formatieren (z.B. über Git Hooks).

### 6.4. Teststrategie und -richtlinien

Eine umfassende Teststrategie ist unerlässlich, um die Qualität und Zuverlässigkeit von NovaDE sicherzustellen.2

- **Testarten:**
    
    - **Unit-Tests (Rust: `#[test]` in Modulen):** Testen isolierter Code-Einheiten (Funktionen, Methoden).59 Sie werden typischerweise in derselben Datei wie der zu testende Code oder in einem Untermodul `tests` (z.B. `#[cfg(test)] mod tests {... }`) definiert.59
        - Jede öffentliche Funktion und Methode sollte Unit-Tests haben.
        - Private Funktionen können indirekt über öffentliche Schnittstellen oder direkt getestet werden, wenn sie komplexe Logik enthalten.
    - **Integrationstests (Rust: in `tests`-Verzeichnis):** Testen die Interaktion zwischen verschiedenen Modulen oder Crates.59 Sie greifen auf die öffentliche API der Library zu.59
        - Fokus auf Schnittstellen und Datenflüsse zwischen Komponenten.
        - Beispiel: Testen der D-Bus-Kommunikation zwischen zwei NovaDE-Diensten.
    - **UI-/Funktionstests:** Testen der Benutzeroberfläche und End-to-End-Workflows aus Sicht des Benutzers.
        - Werkzeuge wie `dogtail` (für Accessibility-basierte UI-Automatisierung) oder spezifische Test-Frameworks für Wayland/GTK könnten evaluiert werden.
        - Diese Tests sind oft aufwendiger zu erstellen und zu warten.
    - **Performancetests:** Überprüfung der nicht-funktionalen Anforderungen bezüglich Performance (Reaktionszeiten, Ressourcennutzung).58
        - Definierte Benchmarks und Testszenarien.
    - **Dokumentationstests (`rustdoc`):** Sicherstellung, dass Code-Beispiele in der Dokumentation korrekt sind und kompilieren.59 Alle Beispiele in der Dokumentation sollten testbar sein (`/// ```rust... ///`).
- **Testabdeckung:** Anstreben einer hohen Code-Abdeckung (z.B. > 80% für Kernkomponenten). Tools wie `tarpaulin` oder `grcov` können zur Messung verwendet werden. Testabdeckung allein ist jedoch kein Garant für Qualität; die Qualität der Tests ist ebenso wichtig.47
    
- **Testdatenmanagement:** Strategien für die Erstellung und Verwaltung von Testdaten, insbesondere für UI- und Integrationstests.
    
- **Mocking/Stubbing:** Verwendung von Mocking-Frameworks (z.B. `mockall` in Rust) oder manuellen Stubs, um Komponenten während Unit- und Integrationstests zu isolieren.
    
- **Rust Testing Best Practices:**
    
    - Verwendung von Assertions-Makros (`assert!`, `assert_eq!`, `assert_ne!`, `should_panic`).59 `pretty_assertions` kann für bessere Fehlermeldungen bei Vergleichen großer Objekte verwendet werden.62
    - Deskriptive Testfunktionsnamen (z.B. `test_login_success`, `test_render_panel_with_widgets`).59
    - Klare Definition des Testzwecks.59
    - Setup- und Teardown-Logik für Tests, die einen bestimmten Zustand erfordern (z.B. temporäre Dateien mit `tempfile` 62, Initialisierung von Testdatenbanken).
    - Testen von asynchronem Code mit `#[tokio::test]` oder äquivalenten Attributen für den verwendeten Async-Runtime.62
    - Organisation von gemeinsam genutzten Test-Hilfsfunktionen in einem `tests/common` Modul oder einer lokalen `dev-dependency` Crate.62
    - Erwägung von Property-basiertem Testen (z.B. mit `proptest` 62) für Funktionen, die eine breite Palette von Eingaben verarbeiten, um Eigenschaften über zufällige Eingaben zu verifizieren.
    - Erwägung von Mutations-Tests (z.B. mit `cargo-mutants` 62) für kritische Komponenten, um die Effektivität der Testsuite zu bewerten. Ein "gefangener" Mutant (Test schlägt fehl) ist ein gutes Zeichen, ein "verpasster" Mutant (kein Test schlägt fehl) deutet auf eine Lücke in der Testabdeckung hin.62
    - Für Kommandozeilenanwendungen (falls Teile von NovaDE als solche implementiert sind oder Test-Harnesses dies erfordern), können `assert_cmd` und `predicates` für Blackbox-Tests verwendet werden.60 `assert_fs` hilft beim Setup von Dateisystemzuständen für Tests.60

Die Testanforderungen 2 und die Notwendigkeit, verschiedene Aspekte wie Unit-, Integrations-, Benutzerakzeptanz- und Performancetests abzudecken 58, unterstreichen die Bedeutung einer mehrschichtigen Teststrategie.

### 6.5. Continuous Integration und Continuous Delivery (CI/CD)

Automatisierte CI/CD-Pipelines sind entscheidend für eine konsistente und zuverlässige Softwareentwicklung und -bereitstellung.47

- **Implementierung von CI/CD-Pipelines:** Verwendung von Werkzeugen wie GitLab CI, GitHub Actions oder Jenkins.
- **Automatisierte Schritte:**
    - **Build:** Kompilierung des Codes bei jedem Commit/Merge Request auf allen Zielplattformen.
    - **Tests:** Automatische Ausführung aller Unit-, Integrations- und Dokumentationstests.
    - **Static Analysis:** Ausführung von `rustfmt --check`, `cargo clippy` und ggf. weiteren statischen Analysewerkzeugen.
    - **Code Coverage Reports:** Generierung von Testabdeckungsberichten.
- **Deployment-Strategie:**
    - Automatisierte Bereitstellung auf Staging-/Testumgebungen nach erfolgreichen Builds auf dem `develop`-Zweig.
    - Für Produktionsreleases:
        - **Kleine Batches (Small Deploys):** Änderungen in kleineren, inkrementellen Updates häufig bereitstellen, um das Risiko kritischer Fehler zu reduzieren und Rollbacks zu erleichtern.47 Anstatt ein komplettes Redesign auf einmal auszurollen, einzelne Komponenten über mehrere Tage verteilen.47
        - **Feature Flags:** Neue Features zunächst für eine Untergruppe von Benutzern aktivieren, um sie in einer kontrollierten Umgebung zu testen, bevor sie für alle ausgerollt werden.47
- **Artefakt-Management:** Speicherung und Versionierung von Build-Artefakten (Binärdateien, Debug-Symbole, Pakete).

CI/CD reduziert die Bereitstellungszeit von Stunden auf Minuten und stellt sicher, dass Qualitätsprüfungen niemals übersprungen werden.47

### 6.6. Fehlerbehandlung, Logging und Debugging

Robuste Mechanismen für Fehlerbehandlung, Logging und Debugging sind für die Entwicklung und Wartung eines komplexen Systems wie NovaDE unerlässlich.

- **Fehlerbehandlung (Error Handling):**
    
    - **Rusts `Result<T, E>`:** Standard für fallible Operationen.
    - **`thiserror`:** Für die Definition spezifischer, semantisch reicher Fehlertypen in Bibliotheks-Crates.49 Dies ermöglicht es Aufrufern, Fehler programmatisch zu behandeln und zu unterscheiden. `thiserror` hilft, Boilerplate zu reduzieren und klare Fehlermeldungen zu generieren.50 Es wird empfohlen, eine Hierarchie von Fehlertypen zu erstellen, wobei spezifischere Fehler in allgemeinere Fehler überführt werden können (z.B. `ParseError::DecryptionError(DecryptionError)`).49
    - **`anyhow`:** Kann für Anwendungs-Code oder an den oberen Rändern von Bibliotheken verwendet werden, um Fehler einfach zu propagieren, wenn eine detaillierte Fehlerbehandlung durch den Aufrufer nicht erforderlich ist.52 Es ist jedoch zu beachten, dass `anyhow::Error` ein opaker Typ ist, der die Introspektion erschwert.52
    - **Panics:** Sollten vermieden werden, außer bei nicht behebbaren Programmierfehlern oder inkonsistenten Zuständen, die ein sofortiges Beenden erfordern. Bibliotheken dürfen nicht panicen (C-FAILURE 21).
    - **Fehlerkontext:** Fehler sollten ausreichend Kontextinformationen enthalten, um die Ursache des Fehlers nachvollziehen zu können. Bibliotheken wie `eyre` (ähnlich `anyhow`, aber mit Fokus auf Kontext) können hierfür verwendet werden, obwohl das Hinzufügen von Kontext ergonomische Herausforderungen mit sich bringen kann.52
    - Die Entscheidung, ob ein Fehler spezifisch (mit `thiserror`) oder generisch (mit `anyhow`) behandelt wird, hängt davon ab, ob Aufrufer die Fehler introspektieren und unterschiedlich darauf reagieren müssen.49
- **Logging:**
    
    - **Logging Facade:** Verwendung der `log`-Crate als Standard-Logging-Fassade.
    - **Logging Backend:** Ein konfigurierbares Backend wie `env_logger` (einfach) oder `tracing` (strukturierter, leistungsfähiger) sollte verwendet werden.
    - **Log-Level:** Klare Definition der Verwendung von Log-Levels (ERROR, WARN, INFO, DEBUG, TRACE).
        - ERROR: Kritische Fehler, die die Funktionalität beeinträchtigen.
        - WARN: Unerwartete Situationen oder potenzielle Probleme.
        - INFO: Allgemeine Betriebsinformationen, wichtige Ereignisse.
        - DEBUG: Detaillierte Informationen zur Fehlerdiagnose für Entwickler.
        - TRACE: Sehr detaillierte Informationen, typischerweise für tiefgreifendes Debugging.
    - **Log-Nachrichten-Inhalt:** Log-Nachrichten sollten Zeitstempel, Modul-/Funktionsname, Thread-ID und die eigentliche Nachricht enthalten. Strukturierte Logs (z.B. JSON-Format) können die Analyse erleichtern.
    - **PII (Personally Identifiable Information):** Keine sensiblen Benutzerdaten (Passwörter, private Inhalte) in Logs schreiben.
- **Debugging:**
    
    - **`Debug` Trait:** Alle öffentlichen Typen müssen `std::fmt::Debug` implementieren (C-DEBUG 21). Die `Debug`-Repräsentation sollte niemals leer sein (C-DEBUG-NONEMPTY 21).
    - **Debug-Symbole:** Entwicklungs-Builds müssen Debug-Symbole enthalten, um die Verwendung von Debuggern wie GDB oder LLDB zu ermöglichen. `rust-gdb` oder `rust-lldb` können die Debugging-Erfahrung für Rust-Code verbessern.
    - **Spezifische Debugging-Werkzeuge:**
        - Für Wayland: Debugging-Tools wie `weston-debug` oder Wayland-Protokoll-Logger.
        - Für GTK: GTK Inspector.
        - Für PipeWire: `pw-dump`, `pw-top`, `pw-cli`, `helvum`, `qpwgraph`.12
    - **Core Dumps:** Konfiguration des Systems zur Erstellung von Core Dumps bei Abstürzen von NovaDE-Prozessen zur Post-Mortem-Analyse.

### 6.7. Dokumentationsstandards und -pflege

Eine umfassende und aktuelle Dokumentation ist entscheidend für die Wartbarkeit, Erweiterbarkeit und Nutzung von NovaDE.1 Sie sollte als integraler Bestandteil des Entwicklungsprozesses betrachtet werden, nicht als nachträgliche Aufgabe.3

- **`rustdoc` als primäres Werkzeug:** Die API-Dokumentation wird direkt im Rust-Quellcode mit `rustdoc`-Kommentaren (`///` für Items, `//!` für Module) geschrieben.61
    
- **Inhaltsanforderungen für API-Dokumentation:**
    
    - **Crate-Level-Dokumentation (`//!` in `lib.rs` oder `main.rs`):** Eine gründliche Einführung in das Crate, seinen Zweck, Hauptfunktionen und ein Anwendungsbeispiel.21
    - **Dokumentation aller öffentlichen Items:** Jede öffentliche Funktion, Methode, Struct, Enum, Trait und Makro muss dokumentiert werden.61 Die erste Zeile sollte eine prägnante Zusammenfassung sein.63
    - **Code-Beispiele:** Für jedes öffentliche Item sollte mindestens ein lauffähiges Code-Beispiel (`/// ```rust... ///`) bereitgestellt werden, das mit `cargo test --doc` getestet werden kann.21 Beispiele sollten den `?`-Operator verwenden, nicht `try!` oder `unwrap` (C-QUESTION-MARK 21).
    - **Fehler, Panics, Sicherheit:** Dokumentation von Fehlerbedingungen (welche Fehler können zurückgegeben werden), Situationen, die zu Panics führen können, und Sicherheitsüberlegungen bei `unsafe` Code (C-FAILURE 21, 61).
    - **Markdown-Nutzung:** Effektive Verwendung von Markdown für Strukturierung (Überschriften wie `# Examples`, `# Panics`, `# Errors`, `# Safety` 61), Listen, Code-Blöcke, Tabellen und Links zu anderen Teilen der Dokumentation (Intra-Doc-Links) oder externen Ressourcen.61
    - Vermeidung von Implementierungsdetails in der öffentlichen API-Dokumentation, wenn sie für den Benutzer nicht relevant sind (C-HIDDEN 21).
- **`Cargo.toml` Metadaten:** Die `Cargo.toml`-Datei jedes Crates muss vollständige Metadaten enthalten: `authors`, `description`, `license`, `homepage`, `documentation` (Link zur `docs.rs`-Seite), `repository`, `keywords`, `categories` (C-METADATA 21).
    
- **Release Notes / Changelog:** Jedes Release muss von Release Notes begleitet werden, die alle signifikanten Änderungen, neuen Features, Bugfixes und Breaking Changes dokumentieren (C-RELNOTES 21). Das Format "Keep a Changelog" wird empfohlen.
    
- **Technische Gesamtspezifikation (dieses Dokument):** Dieses Dokument selbst ist eine zentrale Säule der Dokumentation. Es muss als "lebendiges Dokument" gepflegt und bei jeder signifikanten Architektur- oder Designänderung aktualisiert werden.1 Agile Methoden helfen, mit sich ändernden Anforderungen umzugehen, und die Dokumentation muss diesen Änderungen folgen.65
    
- **UX-Dokumentation Anbindung:** UX-Anforderungen und Design-Entscheidungen sollten mit den technischen Komponenten und Spezifikationen verknüpft werden.66 Dies stellt sicher, dass die technische Implementierung die beabsichtigte Nutzererfahrung widerspiegelt. UX-Dokumentation sollte als Produkt-Asset behandelt und versioniert werden.67
    
- **Zielgruppenorientierung:** Dokumentation sollte für die jeweilige Zielgruppe (Entwickler, Endbenutzer, Systemadministratoren) verständlich und relevant sein.3
    
- **Konsistenz und Klarheit:** Verwendung einheitlicher Terminologie und klarer, präziser Sprache. Vermeidung von Ambiguität und unnötigem Jargon.1
    
- **Pflegeprozess:**
    
    - Dokumentationsupdates sind Teil der "Definition of Done" für jede Entwicklungsaufgabe.
    - Dokumentationsänderungen unterliegen dem Code-Review-Prozess.
    - Regelmäßige Überprüfung der gesamten Dokumentation auf Aktualität und Korrektheit.

Die Herausforderung, Dokumentation synchron mit einer sich schnell entwickelnden Desktop-Umgebung zu halten, ist erheblich. Dies erfordert Disziplin und die Integration von Dokumentationsaufgaben in den Kernentwicklungsworkflow. Wenn Code-Änderungen erst dann als abgeschlossen gelten, wenn die zugehörige Dokumentation (API-Dokumente, Benutzerhandbücher bei Betroffenheit und diese Spezifikation selbst) ebenfalls aktualisiert und überprüft wurde, wird die Dokumentation zu einem proaktiven Bestandteil der Entwicklung und nicht zu einem nachträglichen Gedanken.3 Dies kann durch die Verknüpfung von Dokumentationsaufgaben mit Entwicklungsaufgaben in einem Issue-Tracker unterstützt werden.

## 7. Richtlinien für Systemintegration und Erweiterungen

Dieser Abschnitt behandelt, wie NovaDE erweitert werden kann und wie es sich in das breitere Linux-Ökosystem integriert. Eine gut definierte Strategie für Erweiterbarkeit und Integration ist entscheidend für die Flexibilität und Akzeptanz der Desktop-Umgebung.

### 7.1. Plugin-Architektur und -entwicklung (Falls zutreffend)

Sollte NovaDE ein Plugin-System zur Erweiterung seiner Kernkomponenten (z.B. für Shell-Widgets, Compositor-Effekte, Dateimanager-Erweiterungen) unterstützen, müssen folgende Aspekte definiert werden:

- **Plugin-API:**
    - **Stabilität:** Klare Definition der Stabilität der Plugin-API (z.B. SemVer für die API). Breaking Changes müssen sorgfältig verwaltet und kommuniziert werden.
    - **Versionierung:** Ein Mechanismus zur Versionierung von Plugins und der Plugin-API, um Kompatibilitätsprobleme zu vermeiden.
    - **Sprachbindung:** Definition, in welchen Sprachen Plugins entwickelt werden können (z.B. nur Rust, oder auch C, Python über FFI).
    - **Funktionsumfang:** Welche Aspekte von NovaDE können durch Plugins erweitert oder modifiziert werden?
- **Verpackung und Entdeckung:** Wie werden Plugins paketiert, installiert und vom System erkannt (z.B. spezifische Verzeichnisse, Metadaten-Dateien)?
- **Ressourcenmanagement und Sandboxing:**
    - Wie werden Ressourcen (Speicher, CPU) von Plugins verwaltet?
    - Gibt es Sandboxing-Mechanismen, um die Auswirkungen fehlerhafter oder bösartiger Plugins zu begrenzen? Dies ist besonders wichtig, wenn Plugins in privilegierten Prozessen laufen.
- **Entwicklungsrichtlinien für Plugin-Ersteller:**
    - Dokumentation der Plugin-API.
    - Best Practices für die Entwicklung stabiler und sicherer Plugins.
    - Beispiel-Plugins.

Eine gut durchdachte Plugin-Architektur kann die Flexibilität und das Community-Engagement erheblich steigern, birgt aber auch Komplexität und potenzielle Sicherheitsrisiken. Die Balance zwischen diesen Aspekten ist entscheidend. Die Prinzipien des Model Context Protocol (MCP) 17, obwohl für KI-Systeme entwickelt, bieten wertvolle Anregungen für die Gestaltung sicherer Plugin-Systeme, insbesondere hinsichtlich Authentifizierung, Autorisierung und Sandboxing 19, falls Plugins weitreichende Fähigkeiten besitzen. Wenn Plugins beispielsweise auf D-Bus-Schnittstellen zugreifen oder beliebigen Code ausführen können, ist das Sicherheitsmodell (siehe Abschnitt 7.3) von größter Bedeutung.

### 7.2. Integration von Drittanbieter-Anwendungen

NovaDE muss eine nahtlose Integration von Standard-Linux-Anwendungen gewährleisten.

- **Verhalten von Anwendungen:**
    - **Native Wayland-Anwendungen:** GTK- und Qt-Anwendungen, die Wayland nativ unterstützen, sollten ohne Probleme laufen und alle relevanten Wayland-Protokolle (z.B. `xdg-shell` für Fensterdekorationen, `input-method-unstable-v2` für Eingabemethoden) nutzen können.
    - **X11-Anwendungen:** Unterstützung über XWayland ist kritisch für die Abwärtskompatibilität.15 Die Performance und Stabilität von XWayland muss für gängige Anwendungen sichergestellt sein. Probleme, die bei der Nutzung von XWayland auftreten (z.B. Fensterdekorationen, globale Tastenkürzel, Screen-Sharing bei bestimmten Apps 15), müssen aktiv angegangen oder klar dokumentiert werden.
    - **Electron-basierte Anwendungen:** Diese laufen oft standardmäßig unter X11 (via XWayland) oder können mit Flags (`--enable-features=UseOzonePlatform --ozone-platform=wayland`) für native Wayland-Unterstützung gestartet werden. NovaDE sollte beide Szenarien unterstützen.
- **Freedesktop.org Standards:** Die Einhaltung von Freedesktop.org-Standards ist fundamental für eine gute Integration:
    - **Desktop Entries (`.desktop`-Dateien):** Für die Anzeige von Anwendungen in Menüs und Startern, inklusive Aktionen und MIME-Typ-Assoziationen.
    - **Icon Themes:** Korrekte Handhabung von Icon-Themes gemäß der Spezifikation.
    - **MIME Types:** Systemweite Datenbank für MIME-Typen und deren zugeordnete Anwendungen.
    - **Notifications:** Empfang und Anzeige von Benachrichtigungen gemäß der Freedesktop Notification Specification.
- **XDG Desktop Portals:** Für sandboxed Anwendungen (Flatpak, Snap) sind XDG Desktop Portals der Standardmechanismus, um sicher auf Systemressourcen zuzugreifen.6 NovaDE muss die notwendigen Portal-Backends bereitstellen oder sicherstellen, dass generische Backends (wie `xdg-desktop-portal-gtk`) korrekt funktionieren. Dies betrifft Funktionen wie:
    - Dateiauswahl (`org.freedesktop.portal.FileChooser`).
    - Öffnen von URIs (`org.freedesktop.portal.OpenURI`).
    - Drucken (`org.freedesktop.portal.Print`).
    - Screen-Sharing und -Aufnahme (`org.freedesktop.portal.ScreenCast`), oft in Verbindung mit PipeWire.12
    - Globale Einstellungen (`org.freedesktop.portal.Settings`).

### 7.3. Sicherheitsrichtlinien für Erweiterungen und Plugins

Die Sicherheit von Erweiterungen und Plugins ist von größter Bedeutung, da sie potenziell tief in das System eingreifen können.

- **Berechtigungsmodell:**
    - Falls ein Plugin-System existiert, muss ein klares Berechtigungsmodell definiert werden. Welche Ressourcen und APIs darf ein Plugin standardmäßig nutzen?
    - Können Benutzer Berechtigungen für Plugins granular verwalten?
    - Das Prinzip der geringsten Rechte (Least Privilege) muss angewendet werden: Ein Plugin sollte nur die Berechtigungen erhalten, die es für seine Funktion unbedingt benötigt.
- **Code-Review und Vetting:**
    - Für offiziell unterstützte oder in einem Community-Repository angebotene Plugins sollte ein Code-Review-Prozess etabliert werden, um Sicherheitslücken und bösartigen Code zu identifizieren.
    - Klare Richtlinien für die Aufnahme von Plugins in offizielle Repositories.
- **Richtlinien für sichere Plugin-Entwicklung:**
    - **Eingabevalidierung:** Alle Eingaben, die ein Plugin von externen Quellen oder dem Benutzer erhält, müssen sorgfältig validiert werden.
    - **Ausgabesanitisierung:** Daten, die von einem Plugin an andere Systemteile oder zur Anzeige weitergegeben werden, müssen ggf. sanitisiert werden.
    - **Fehlerbehandlung:** Robuste Fehlerbehandlung, um Abstürze oder instabile Zustände zu vermeiden.
    - **Ressourcenmanagement:** Sorgfältiger Umgang mit Speicher und anderen Systemressourcen, um Lecks oder übermäßige Nutzung zu vermeiden.
- **Sandboxing (falls möglich):** Wenn technisch machbar, sollten Plugins in einer Sandbox-Umgebung ausgeführt werden, um ihren Zugriff auf das System zu beschränken.
- **Anlehnung an MCP-Sicherheitsprinzipien:** Die für das Model Context Protocol diskutierten Sicherheitsüberlegungen 19 sind auch für NovaDE-Plugins relevant, falls diese signifikante Fähigkeiten haben:
    - **Starke Authentifizierung:** Falls Plugins als separate Prozesse laufen oder von extern geladen werden, Mechanismen zur Verifizierung ihrer Identität.
    - **Bereichsbezogene Autorisierung:** Ein Plugin, das z.B. nur das Wetter anzeigt, benötigt keinen Zugriff auf das Dateisystem.
    - **Ratenbegrenzung:** Verhindern, dass ein fehlerhaftes oder bösartiges Plugin das System durch exzessive API-Aufrufe lahmlegt.

Ein kompromittiertes Plugin kann die Sicherheit der gesamten Desktop-Umgebung untergraben. Daher müssen diese Richtlinien streng durchgesetzt und Entwickler entsprechend geschult werden.

## 8. Anhang

### 8.1. Glossar technischer Begriffe

|   |   |
|---|---|
|**Begriff**|**Definition**|
|**API**|Application Programming Interface: Eine Schnittstelle, die von einer Softwarekomponente bereitgestellt wird, damit andere Softwarekomponenten mit ihr interagieren können.|
|**ALSA**|Advanced Linux Sound Architecture: Eine Kernel-Komponente für Soundkarten-Treiber und eine API für Audio-Anwendungen.12|
|**Compositor**|Eine Software, die die grafischen Ausgaben verschiedener Anwendungen entgegennimmt und zu einem Gesamtbild für den Bildschirm zusammensetzt. Unter Wayland ist der Compositor auch der Display-Server.5|
|**Crate**|Eine Kompilierungs-Einheit in Rust, entweder eine Bibliothek oder eine ausführbare Datei.|
|**CSS**|Cascading Style Sheets: Eine Stylesheet-Sprache, die verwendet wird, um das Aussehen von Dokumenten (typischerweise Webseiten, aber auch GTK4-Anwendungen) zu beschreiben.27|
|**D-Bus**|Ein Nachrichtenbus-System, das die Interprozesskommunikation (IPC) zwischen Anwendungen und Diensten unter Linux ermöglicht.8|
|**DRM**|Direct Rendering Manager: Ein Subsystem des Linux-Kernels, das eine Schnittstelle zu modernen Grafikkarten für Operationen wie Mode-Setting und Speicherverwaltung bereitstellt. Wayland-Compositoren nutzen DRM direkt.5|
|**EGL**|Eine Schnittstelle zwischen Khronos Rendering APIs (wie OpenGL ES oder OpenVG) und dem zugrundeliegenden nativen Plattform-Fenstersystem. Wayland-Compositoren verwenden EGL.6|
|**evdev**|Ein generisches Eingabeereignis-Interface im Linux-Kernel, das Roh-Eingabeereignisse von Geräten wie Tastaturen, Mäusen und Touchscreens bereitstellt.5|
|**FFI**|Foreign Function Interface: Ein Mechanismus, mit dem eine in einer Programmiersprache geschriebene Funktion von einer anderen Programmiersprache aufgerufen werden kann.|
|**Freedesktop.org (XDG)**|Ein Projekt, das Standards und Spezifikationen für die Interoperabilität von Desktop-Umgebungen unter Linux und anderen Unix-artigen Systemen entwickelt.|
|**GSettings**|Ein High-Level-API für Einstellungen in GLib-basierten Anwendungen, das typischerweise DConf als Backend verwendet.|
|**GTK (GIMP Toolkit)**|Ein plattformübergreifendes Widget-Toolkit zur Erstellung grafischer Benutzeroberflächen. GTK4 ist die aktuelle Hauptversion.28|
|**IPC**|Inter-Process Communication: Mechanismen, die es verschiedenen Prozessen ermöglichen, miteinander zu kommunizieren und Daten auszutauschen.|
|**KMS**|Kernel Mode Setting: Ein Verfahren, bei dem der Kernel für die Einstellung des Anzeigemodus (Auflösung, Farbtiefe, Bildwiederholfrequenz) zuständig ist, anstatt des X-Servers oder eines Userspace-Treibers.6|
|**libinput**|Eine Bibliothek, die Eingabegeräte über Kernel-Events (wie evdev) verarbeitet und eine standardisierte Schnittstelle für Wayland-Compositoren und X.Org-Treiber bereitstellt.|
|**MCP**|Model Context Protocol: Ein offener Standard, der die strukturierte Interaktion von KI-Modellen mit externen Daten und Diensten ermöglicht.17|
|**Meson**|Ein Build-System, das auf Benutzerfreundlichkeit, Geschwindigkeit und die Erzeugung korrekter Builds ausgelegt ist. Wird oft für C/C++-Projekte und zunehmend auch für Rust-Projekte in Kombination mit Cargo verwendet.34|
|**NFR**|Non-Functional Requirement: Eine Anforderung, die beschreibt, wie ein System eine bestimmte Funktion ausführen soll (z.B. Performance, Sicherheit), im Gegensatz zu funktionalen Anforderungen, die beschreiben, was das System tun soll.45|
|**PAM**|Pluggable Authentication Modules: Ein Mechanismus unter Linux, der es ermöglicht, Authentifizierungsdienste modular zu integrieren.|
|**PipeWire**|Ein Server und eine API für die Verarbeitung von Audio- und Videoströmen unter Linux. Es zielt darauf ab, PulseAudio und JACK zu ersetzen und bietet geringe Latenz und Flexibilität.12|
|**Rust**|Eine Systemprogrammiersprache, die auf Sicherheit (insbesondere Speichersicherheit) und Performance ausgelegt ist.|
|**rustdoc**|Das Standardwerkzeug in Rust zur Generierung von Dokumentation aus Quellcode-Kommentaren.61|
|**Shell (Desktop Shell)**|Die grafische Benutzeroberfläche einer Desktop-Umgebung, die Elemente wie Panels, Anwendungsstarter und Fensterdekorationen bereitstellt.|
|**Smithay**|Eine Rust-Bibliothek zur Erstellung von Wayland-Compositoren und Utilities.5|
|**Wayland**|Ein Kommunikationsprotokoll, das die Kommunikation zwischen einem Display-Server (dem Wayland-Compositor) und seinen Clients (Anwendungen) spezifiziert. Es soll X11 ersetzen.5|
|**WirePlumber**|Ein modularer Session- und Policy-Manager für PipeWire, der Verbindungen zwischen Geräten und Streams verwaltet und Richtlinien durchsetzt.13|
|**XDG Desktop Portals**|Eine Schnittstelle, die es sandboxed Anwendungen (wie Flatpak oder Snap) ermöglicht, sicher auf Ressourcen außerhalb ihrer Sandbox zuzugreifen (z.B. Dateiauswahl, Drucken).6|
|**XSettings**|Ein Protokoll für X11, das es ermöglicht, Einstellungen (wie Theme, Schriftarten) systemweit zu teilen. GTK kann XSettings unter X11 oder XWayland nutzen.9|
|**XWayland**|Ein X-Server, der als Wayland-Client läuft und es ermöglicht, X11-Anwendungen in einer Wayland-Sitzung auszuführen.15|

### 8.2. Referenzierte Dokumente und Standards

- **Rust Language & Tooling:**
    - The Rust Programming Language Book: [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)
    - Rust API Guidelines: [https://rust-lang.github.io/api-guidelines/](https://rust-lang.github.io/api-guidelines/) (21)
    - Rust Style Guide: [https://doc.rust-lang.org/nightly/style-guide/](https://doc.rust-lang.org/nightly/style-guide/) (22)
    - Rustdoc - How to write documentation: [https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html](https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html) (63)
    - Cargo Book: [https://doc.rust-lang.org/cargo/](https://doc.rust-lang.org/cargo/)
    - The `thiserror` Crate: [https://crates.io/crates/thiserror](https://crates.io/crates/thiserror)
    - The `anyhow` Crate: [https://crates.io/crates/anyhow](https://crates.io/crates/anyhow)
- **Wayland & Compositing:**
    - Wayland Protocol Documentation: [https://wayland.freedesktop.org/docs/html/](https://wayland.freedesktop.org/docs/html/) (6)
    - Smithay Project:(https://github.com/Smithay/smithay) (24)
    - Smithay Documentation (master): [https://smithay.github.io/smithay/smithay/](https://smithay.github.io/smithay/smithay/) (25)
    - XDG Shell Protocol: [https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/stable/xdg-shell/xdg-shell.xml](https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/stable/xdg-shell/xdg-shell.xml)
- **GTK4 & UI:**
    - GTK4 API Reference: [https://docs.gtk.org/gtk4/](https://docs.gtk.org/gtk4/) (28)
    - GTK4 Rust Bindings (`gtk4-rs`): [https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/](https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/) (7)
    - GTK CSS Properties: [https://docs.gtk.org/gtk4/css-properties.html](https://docs.gtk.org/gtk4/css-properties.html) (27)
- **Interprozesskommunikation & Multimedia:**
    - D-Bus Specification: [https://dbus.freedesktop.org/doc/dbus-specification.html](https://dbus.freedesktop.org/doc/dbus-specification.html) (14)
    - PipeWire Documentation: [https://pipewire.org/](https://pipewire.org/) (12)
    - WirePlumber Documentation: [https://pipewire.pages.freedesktop.org/wireplumber/](https://pipewire.pages.freedesktop.org/wireplumber/)
- **Freedesktop.org Standards:**
    - Desktop Entry Specification: [https://specifications.freedesktop.org/desktop-entry-spec/latest/](https://specifications.freedesktop.org/desktop-entry-spec/latest/)
    - Icon Theme Specification: [https://specifications.freedesktop.org/icon-theme-spec/latest/](https://specifications.freedesktop.org/icon-theme-spec/latest/)
    - Desktop Notifications Specification: [https://specifications.freedesktop.org/notification-spec/latest/](https://specifications.freedesktop.org/notification-spec/latest/)
    - XDG Base Directory Specification: [https://specifications.freedesktop.org/basedir-spec/latest/](https://specifications.freedesktop.org/basedir-spec/latest/)
    - XDG Desktop Portal Documentation: [https://flatpak.github.io/xdg-desktop-portal/docs/](https://flatpak.github.io/xdg-desktop-portal/docs/)
- **Build System:**
    - Meson Build System Manual: [https://mesonbuild.com/Manual.html](https://mesonbuild.com/Manual.html) (35)
- **Model Context Protocol (MCP) (falls zutreffend):**
    - MCP Introduction (Stytch Blog): 17
    - MCP Overview (OpenCV Blog): 18
    - MCP Security Considerations (Writer Engineering Blog): 19
- **Software Development Best Practices (Allgemein):**
    - OpsLevel - Standards in Software Development: 47
    - Bocasay - Guide to Writing Functional and Technical Specifications: 1
    - Heretto - Technical Specifications: 2
    - WWG - How to Write a Technical Specification: 58
    - Document360 - Software Architecture Documentation: 3
    - Softkraft - How to Write Software Requirements: 4
    - Pulsion - Software Development Best Practices: 48

### Tabelle 4: Konfigurationsparameter und Standardwerte (Auszug/Beispiel)

Diese Tabelle dient als Referenz für wichtige konfigurierbare Parameter innerhalb von NovaDE. Eine vollständige Liste wird im Laufe der Entwicklung gepflegt und erweitert.

|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|**Parametername**|**Komponente**|**Beschreibung**|**Datentyp**|**Standardwert**|**Erlaubte Werte / Bereich**|**Geltungsbereich**|
|`gtk-theme-name`|GTK Settings|Name des zu verwendenden GTK-Themes.|String|"NovaDE-Default"|Name eines installierten GTK-Themes (z.B. "Adwaita", "NovaDE-Dark")|User/System|
|`gtk-font-name`|GTK Settings|Standardschriftart und -größe (z.B. "Cantarell 11").|String|"Sans 10"|Gültige Pango-Schriftartbeschreibung|User/System|
|`gtk-application-prefer-dark-theme`|GTK Settings|Ob Anwendungen ein dunkles Theme bevorzugen sollen, falls vom Theme unterstützt.9|Boolean|`false`|`true`, `false`|User|
|`org.novade.compositor.enableAnimations`|NovaDE Compositor|Aktiviert/Deaktiviert Fensteranimationen (z.B. Minimieren, Öffnen).|Boolean|`true`|`true`, `false`|User|
|`org.novade.compositor.animationSpeedFactor`|NovaDE Compositor|Faktor zur Skalierung der Animationsgeschwindigkeit (1.0 = normal).|Float|`1.0`|`0.1` - `5.0`|User|
|`org.novade.shell.panel.position`|NovaDE Shell|Position des Hauptpanels auf dem Bildschirm.|Enum|"top"|"top", "bottom", "left", "right"|User|
|`org.novade.shell.panel.autohide`|NovaDE Shell|Ob das Panel automatisch ausgeblendet werden soll.|Boolean|`false`|`true`, `false`|User|
|`org.novade.notifications.popupTimeoutSeconds`|NovaDE Notification Service|Anzeigedauer von Benachrichtigungs-Popups in Sekunden (0 = manuell schließen).|Integer|`5`|`0` - `60`|User|
|`org.novade.power.suspendOnIdleMinutes`|NovaDE Power Manager|Zeit in Minuten, nach der das System bei Inaktivität in den Suspend-Modus wechselt (0 = deaktiviert).|Integer|`30`|`0` - `1440`|User|
|`org.novade.input.mouse.accelerationProfile`|NovaDE Settings Daemon (Input)|Beschleunigungsprofil für die Maus.|Enum|"adaptive"|"adaptive", "flat"|User|
|`pipewire.alsa.force-rate`|PipeWire (ALSA Emulation)|Erzwingt eine bestimmte Samplerate für ALSA-Anwendungen (z.B. 48000 Hz).|Integer|`0` (auto)|`0`, `44100`, `48000`, `96000` etc. (siehe PipeWire Doku)|System/User|
|`pipewire.bluetooth.autoswitch-to-headset-profile`|PipeWire (WirePlumber Bluetooth Config)|Automatisches Umschalten auf HSP/HFP-Profil bei eingehendem Anruf/Aufnahme.13|Boolean|`true`|`true`, `false`|User|

Diese Tabelle ist entscheidend für Administratoren, fortgeschrittene Benutzer und Entwickler, um das Systemverhalten zu verstehen, anzupassen und Fehler zu diagnostizieren. Sie zentralisiert Informationen, die andernfalls über verschiedene Komponentendokumentationen verstreut wären, und verbessert so die Transparenz und Verwaltbarkeit von NovaDE.39

## 9. Schlussfolgerungen und Empfehlungen

Diese Technische Gesamtspezifikation und Richtliniensammlung für NovaDE legt den Grundstein für eine strukturierte, qualitativ hochwertige und zukunftssichere Entwicklung der Desktop-Umgebung. Durch die detaillierte Ausarbeitung der Architektur, der Kernkomponenten, der nicht-funktionalen Anforderungen, der Schnittstellen und der Entwicklungsrichtlinien wird ein gemeinsames Verständnis geschaffen und ein Rahmen für alle Beteiligten etabliert.

**Wesentliche Prinzipien und Erkenntnisse:**

1. **Modularität und klare Schnittstellen:** Die Zerlegung von NovaDE in klar definierte Kernkomponenten mit wohldefinierten Schnittstellen (primär D-Bus und Wayland) ist fundamental für Wartbarkeit, Testbarkeit und parallele Entwicklung.1 Die Verwendung von Rust fördert zusätzlich die Erstellung sicherer und performanter Module.
2. **Technologische Basis:** Die Wahl von Wayland, Smithay, GTK4, PipeWire und Rust als Kerntechnologien positioniert NovaDE als moderne und leistungsfähige Desktop-Umgebung. Dies bringt jedoch auch spezifische Herausforderungen mit sich (z.B. Wayland-Adoption, Komplexität von Smithay als Bibliothek), die kontinuierliche Aufmerksamkeit erfordern.5
3. **Nicht-funktionale Anforderungen (NFRs):** Performance, Stabilität, Sicherheit und Benutzbarkeit sind keine nachrangigen Aspekte, sondern müssen von Beginn an in Design und Implementierung berücksichtigt und durch messbare Kriterien spezifiziert werden.45
4. **Entwicklungsdisziplin:** Die Einhaltung der festgelegten Programmierrichtlinien (insbesondere der Rust API und Style Guides), des Code-Review-Prozesses und der Teststrategie ist unerlässlich für die langfristige Gesundheit des Projekts.21
5. **Lebendige Dokumentation:** Diese Spezifikation und die zugehörige API-Dokumentation (`rustdoc`) müssen kontinuierlich gepflegt und als integraler Bestandteil des Entwicklungsprozesses behandelt werden. Veraltete Dokumentation ist ein erhebliches Projektrisiko.3 Die Verknüpfung von UX-Anforderungen mit technischen Spezifikationen ist hierbei ein wichtiger Aspekt.66
6. **Sicherheit als Fundament:** Insbesondere bei Systemkomponenten wie einem Compositor und bei der Integration von Erweiterungen oder Protokollen wie MCP müssen Sicherheitsaspekte (Least Privilege, Sandboxing, Validierung) höchste Priorität haben.19
7. **Iterative Entwicklung und Anpassungsfähigkeit:** Die Softwareentwicklung, insbesondere für ein komplexes System wie eine Desktop-Umgebung, ist ein iterativer Prozess. Die hier festgelegten Richtlinien sollten Flexibilität für Anpassungen und Weiterentwicklungen ermöglichen, beispielsweise durch agile Methoden und die Bereitschaft, auf Feedback und neue technologische Entwicklungen zu reagieren.65

**Empfehlungen für die weitere Vorgehensweise:**

1. **Implementierung der Kernarchitektur:** Fokus auf die stabile Implementierung des Wayland-Compositors, der grundlegenden Shell-Funktionen und der D-Bus-basierten Dienste als Fundament.
2. **Aufbau der CI/CD-Infrastruktur:** Frühzeitige Einrichtung von CI/CD-Pipelines, um automatisierte Tests und Qualitätsprüfungen von Beginn an zu etablieren.47
3. **Detaillierte API-Spezifikation und -Dokumentation:** Parallele Entwicklung der `rustdoc`-API-Dokumentation für alle öffentlichen Schnittstellen der Kern-Crates.
4. **Kontinuierliche Überprüfung und Anpassung dieser Spezifikation:** Regelmäßige Reviews dieses Dokuments im Entwicklungsteam, um sicherzustellen, dass es den aktuellen Stand und die zukünftige Ausrichtung von NovaDE widerspiegelt.
5. **Community-Einbindung (falls zutreffend):** Bei Open-Source-Projekten ist die frühzeitige Einbindung einer Community für Feedback und Beiträge wertvoll. Klare Dokumentation und Richtlinien sind hierfür eine Voraussetzung.

Die konsequente Anwendung der in diesem Dokument dargelegten Prinzipien und Richtlinien wird maßgeblich dazu beitragen, dass NovaDE zu einer robusten, performanten und benutzerfreundlichen Desktop-Umgebung wird, die den Anforderungen der Nutzer gerecht wird und eine solide Basis für zukünftige Erweiterungen bietet.


**Allgemeine Projekt-Gesamtspezifikation: Linux Desktop-Umgebung "NovaDE"**

**I. Vision und Projektziele**

- **Vision:** NovaDE (Nova Desktop Environment) ist eine innovative Linux-Desktop-Umgebung, die eine moderne, schnelle, intuitive und KI-gestützte Benutzererfahrung schafft. Sie ist optimiert für Entwickler, Kreative und alltägliche Nutzer und zielt darauf ab, Produktivität und Freude an der Interaktion mit dem System zu maximieren.
- **Kernziele:**
    1. **Performance:** Eine durchgehend schnelle und reaktionsschnelle Umgebung ohne spürbare Verzögerungen.
    2. **Intuition:** Eine Benutzeroberfläche, die sich natürlich anfühlt, leicht erlernbar ist und den Nutzer intelligent unterstützt, ohne bevormundend zu wirken.
    3. **Modernität:** Einsatz aktueller Technologien und Designprinzipien, um eine zeitgemäße und zukunftssichere Plattform zu bieten.
    4. **Modularität & Wartbarkeit:** Eine klare Architektur, die einfache Erweiterbarkeit, Testbarkeit und Wartung ermöglicht.
    5. **Anpassbarkeit:** Dem Benutzer weitreichende Möglichkeiten zur Personalisierung des Erscheinungsbildes und Verhaltens der Umgebung bieten.
    6. **KI-Integration:** Nahtlose und sichere Integration von KI-Funktionen als hilfreiche Assistenz, stets unter voller Benutzerkontrolle.
    7. **Stabilität & Sicherheit:** Höchste Priorität auf Systemstabilität und Datensicherheit durch den Einsatz geeigneter Technologien und Entwicklungspraktiken.

**II. Architektonischer Überblick: Geschichtete Architektur**

NovaDE basiert auf einer strengen, vier-schichtigen Architektur, um Modularität, lose Kopplung und hohe Kohäsion innerhalb der Schichten zu gewährleisten. Jede Schicht hat klar definierte Verantwortlichkeiten und kommuniziert mit anderen Schichten ausschließlich über wohldefinierte Schnittstellen.

1. **Kernschicht (Core Layer)**
    
    - **Verantwortlichkeiten:** Enthält die absolut grundlegendsten, systemweit genutzten Elemente. Dies umfasst:
        - Fundamentale Datentypen (z.B. `Point<T>`, `Size<T>`, `Rect<T>`, `Color`, `WorkspaceId`, `WindowIdentifier`, `TokenIdentifier`, `SettingKey`).
        - Allgemeine Dienstprogramme und Hilfsfunktionen (z.B. String-Manipulation, mathematische Helfer, die keine spezifische Domänenlogik enthalten).
        - Basis-Infrastruktur für Konfigurationsparsing und -zugriff (Primitive zum Laden/Speichern, aber nicht die Konfigurationswerte selbst).
        - Initialisierung und Konfiguration des globalen Logging-Frameworks (`tracing`).
        - Allgemeine Fehlerdefinitionen und -Traits (z.B. ein Basis-`CoreError`-Enum mit `thiserror`), die als Grundlage für spezifischere Fehler in höheren Schichten dienen.
    - **Abhängigkeiten:** Keine Abhängigkeiten zu anderen Schichten von NovaDE. Minimale externe Abhängigkeiten (Rust `std`, `uuid`, `chrono`, `thiserror`, `tracing`, `serde`, `toml`, `once_cell`).
    - **Interaktionen:** Stellt seine Funktionalität allen darüberliegenden Schichten (Domäne, System, UI) zur Verfügung.
2. **Domänenschicht (Domain Layer)**
    
    - **Verantwortlichkeiten:** Beinhaltet die gesamte Kernlogik und die Geschäftsregeln der Desktop-Umgebung, unabhängig von spezifischen UI-Implementierungen oder Systemdetails (wie D-Bus oder Wayland-Protokollen). Dies umfasst:
        - **`domain::theming`:** Logik der Theming-Engine, Verwaltung von Design-Tokens (`TokenIdentifier`, `TokenValue`, `RawToken`, `ThemeDefinition`), Regeln zur Anwendung von Themes (Hell/Dunkel, Akzentfarben), dynamische Theme-Wechsel. Stellt den `AppliedThemeState` bereit.
        - **`domain::workspaces`:** Umfassende Verwaltungslogik für Arbeitsbereiche ("Spaces"). Definiert die `Workspace`-Entität, Regeln für die Zuweisung von Fenstern (`WindowIdentifier`) zu `WorkspaceId`s, Orchestrierung aller Workspaces (`WorkspaceManager`), Verwaltung des aktiven Workspace und Persistenz der Workspace-Konfiguration (`WorkspaceConfigProvider`, `WorkspaceSnapshot`).
        - **`domain::user_centric_services`:**
            - **KI-Interaktionsmanagement:** Logik für KI-Interaktionen (`AIInteractionContext`), Verwaltung von Benutzereinwilligungen (`AIConsent`, `AIConsentStatus`) für KI-Modelle und Datenkategorien (`AIDataCategory`), Verwaltung von KI-Modellprofilen (`AIModelProfile`).
            - **Benachrichtigungsmanagement:** Kernlogik zur Verwaltung von Benachrichtigungen (`Notification`, `NotificationAction`), Historie, Filterung, Priorisierung (`NotificationUrgency`), "Bitte nicht stören"-Modus.
        - **`domain::notifications_rules`:** Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln (`NotificationRule`, `RuleCondition`, `RuleAction`).
        - **`domain::global_settings_and_state_management`:** Repräsentation, Logik zur Verwaltung und Konsistenz globaler Desktop-Einstellungen (`GlobalDesktopSettings`, `SettingPath`, `SettingValue`). Validierung und Persistenz von Einstellungen (delegiert an Kernschicht).
        - **`domain::window_management_policy`:** Definition von High-Level-Regeln und Richtlinien für Fensterplatzierung, Logik für automatisches Tiling (Layout-Typen wie Spalten, Spiralen), Snapping-Verhalten, Fenstergruppierung und Gap-Management. _Diese Schicht definiert die "Policy", die Systemschicht die "Mechanik"._
    - **Abhängigkeiten:** Nutzt ausschließlich die Kernschicht.
    - **Interaktionen:** Stellt Logik, Zustand und Geschäftsregeln für die Systemschicht und die Benutzeroberflächenschicht bereit, oft über definierte Service-Traits und durch das Aussenden von domain-spezifischen Events (z.B. `ThemeChangedEvent`, `WorkspaceEvent`, `SettingChangedEvent`).
3. **Systemschicht (System Layer)**
    
    - **Verantwortlichkeiten:** Implementiert die Interaktion mit dem zugrundeliegenden Betriebssystem, der Hardware und externen Systemdiensten. Setzt die von der Domänenschicht definierten Richtlinien technisch um.
        - **`system::compositor`:** Smithay-basierter Wayland-Compositor. Verwaltung von Wayland-Clients, Oberflächen (`WlSurface`), Pufferbehandlung (SHM, DMABUF), Implementierung von Wayland-Protokollen serverseitig (`xdg-shell`, `wlr-layer-shell-unstable-v1`, `xdg-decoration-unstable-v1`, `wlr-output-management-unstable-v1`, `wlr-output-power-management-unstable-v1` etc.), XWayland-Integration. Orchestriert das Rendering (delegiert an Renderer-Interface).
        - **`system::input`:** `libinput`-basierte Eingabeverarbeitung. Verarbeitung von Tastatur-, Maus-, Touchpad-Ereignissen. Gestenerkennung. Seat-Management (`SeatState`, `SeatHandler`), Fokus-Handling auf Wayland-Ebene, xkbcommon-Integration für Tastaturlayouts.
        - **`system::dbus`:** Schnittstellenmodule (via `zbus`) für die Interaktion mit System-D-Bus-Diensten: `NetworkManager`, `UPower`, `logind`, `org.freedesktop.Notifications` (Service-Seite, die `domain::user_centric_services::NotificationService` nutzt), `org.freedesktop.secrets` (Freedesktop Secret Service API), `PolicyKit (polkit)`. Enthält D-Bus Service- und Client-Implementierungen.
        - **`system::outputs`:** Verwaltung von Anzeigeausgängen. Implementierung der Server-Seite von `wlr-output-management-unstable-v1` und `wlr-output-power-management-unstable-v1`. Handhabung von Monitorkonfigurationen (Auflösung, Position, Aktivierung, Skalierung, DPMS).
        - **`system::audio`:** Client-Integration für PipeWire (via `pipewire-rs`) zur Steuerung der Systemlautstärke, Auswahl von Audio-Geräten und Verwaltung von Anwendungs-Streams.
        - **`system::mcp`:** Implementierung des Model Context Protocol (MCP) Clients (via `mcp_client_rs`), der die sichere Kommunikation mit MCP-Servern (lokal oder remote) abwickelt, basierend auf Anweisungen und Kontextdaten aus `domain::user_centric_services::AIInteractionLogicService`.
        - **`system::portals`:** Backend-Implementierung für XDG Desktop Portals (`org.freedesktop.portal.FileChooser`, `org.freedesktop.portal.Screenshot` etc.) zur Bereitstellung sicherer Schnittstellen für sandboxed und native Anwendungen.
        - **`system::window_mechanics`:** Konkrete Implementierung der Fenstermanagement-"Mechanik" basierend auf den Richtlinien aus `domain::window_management_policy`. Dies umfasst Fensterpositionierung, Größenänderung, Stapelreihenfolge, Anwendung von Tiling-Layouts, Fokusübergänge und die technische Umsetzung von Fensterdekorationen (serverseitig falls SSD oder in Koordination mit CSD). Stellt die technische Basis für die "Intelligente Tab-Leiste" bereit, indem sie Fensterinformationen und Gruppierungen verwaltet.
    - **Abhängigkeiten:** Nutzt Funktionalität der Kernschicht und der Domänenschicht (z.B. um Domänenregeln anzuwenden, Zustände abzufragen, Konfigurationen zu lesen).
    - **Interaktionen:** Stellt systemnahe Dienste und Ereignisse für die Benutzeroberflächenschicht bereit (z.B. Fenstergeometrie, Eingabeereignisse, Statusänderungen von Systemdiensten). Empfängt Befehle von der UI-Schicht (z.B. Fenster verschieben, Space wechseln, Fokus anfordern) und setzt diese technisch um.
4. **Benutzeroberflächenschicht (User Interface Layer)**
    
    - **Verantwortlichkeiten:** Ist verantwortlich für die Darstellung der gesamten grafischen Benutzeroberfläche und die direkte Interaktion mit dem Benutzer. Basiert vollständig auf GTK4 und den `gtk4-rs` Bindings.
        - **`ui::shell`:** Implementierung der Haupt-Shell-UI:
            - `PanelWidget`: Kontroll- und Systemleiste(n) mit Modulen (`AppMenuButton`, `WorkspaceIndicatorWidget`, `ClockDateTimeWidget`, `SystemTrayEquivalentWidget`, `QuickSettingsButtonWidget`, `NotificationCenterButtonWidget`, `NetworkIndicatorWidget`, `PowerIndicatorWidget`, `AudioIndicatorWidget`).
            - `SmartTabBarWidget`: Intelligente Tab-Leiste pro "Space" mit `ApplicationTabWidget`s.
            - `QuickSettingsPanelWidget`: Ausklappbares Panel für Schnelleinstellungen.
            - `WorkspaceSwitcherWidget`: Adaptive linke Seitenleiste mit `SpaceIconWidget`s zur Navigation zwischen "Spaces".
            - `QuickActionDockWidget`: Konfigurierbares Dock für Schnellzugriffe mit `DockItemWidget`s.
            - `NotificationCenterPanelWidget`: Anzeige von Benachrichtigungsliste und -historie mit `NotificationWidget`s.
        - **`ui::control_center`:** Modulare GTK4-Anwendung für alle Systemeinstellungen (`AppearanceSettingsWidget`, `NetworkSettingsWidget` etc.).
        - **`ui::widgets`:** Implementierung des Widget-Systems:
            - `RightSidebarWidget`: Adaptive rechte Seitenleiste.
            - `WidgetManagerService` (logische UI-Komponente).
            - `WidgetPickerPopover`.
            - `PlacedWidgetWidget` und `ActualWidget` (Basis für `ClockWidget`, `CalendarWidget`, `WeatherWidget`, `SystemMonitorWidget` etc.).
        - **`ui::window_manager_frontend`:** UI-Aspekte des Fenstermanagements:
            - Client-Side Decorations (CSD) Logik (z.B. via `Gtk::HeaderBar`).
            - `OverviewModeWidget`: Fenster- und Workspace-Übersicht.
            - `AltTabSwitcherWidget`: Traditioneller Fensterwechsler.
        - **`ui::notifications_frontend`:** `NotificationPopupWidget` zur Anzeige von Pop-up-Benachrichtigungen.
        - **`ui::theming_gtk`:** Anwendung der von `domain::theming` generierten CSS-Stile auf GTK-Widgets über `Gtk::CssProvider`. Logik zur Anforderung von Theme-Wechseln.
        - **`ui::components`:** Sammlung wiederverwendbarer, anwendungsspezifischer GTK4-Widgets (z.B. `StyledButtonWidget`, `ModalDialogWidget`).
        - **`ui::speed_dial`:** GTK4-Implementierung der Speed-Dial-Startansicht für leere Workspaces.
        - **`ui::command_palette`:** GTK4-Implementierung der kontextuellen Befehlspaletten-UI (`CommandPalettePopover`).
    - **Abhängigkeiten:** Nutzt Funktionalität aller darunterliegenden Schichten (Kern, Domäne, System).
    - **Interaktionen:** Empfängt Eingabeereignisse von der Systemschicht. Visualisiert Zustände und Daten aus der Domänen- und Systemschicht. Löst Aktionen und Zustandsänderungen in der Domänen- und Systemschicht aus, basierend auf Benutzerinteraktionen. Abonniert Events der unteren Schichten, um sich dynamisch zu aktualisieren.

**III. Technologie-Stack (Verbindliche Auswahl)**

|Bereich|Technologie/Standard|Begründung|
|:--|:--|:--|
|Programmiersprache|**Rust**|Überlegene Speichersicherheit ohne Garbage Collector, Performance "close-to-the-metal", starkes Typsystem zur Fehlervermeidung zur Kompilierzeit, moderne Nebenläufigkeitskonzepte. Zukunftssichere Wahl für Systemsoftware.|
|Build-System|**Meson**|Modern, einfach, schnell, exzellente Unterstützung für Rust und C/C++ (für externe Abhängigkeiten), Integration von CMake-basierten Abhängigkeiten via Subprojekte (WrapDB, CMake-Modul).|
|GUI-Toolkit|**GTK4** (mit `gtk4-rs` Bindings)|Modernes, aktiv entwickeltes Toolkit mit erstklassiger Wayland-Unterstützung, robusten Rust-Bindings. CSS-basiertes Theming für flexible und standardisierte Anpassung. Dynamischer Theme-Wechsel zur Laufzeit. Starke Integration ins GNOME-Ökosystem.|
|Wayland Compositor & Bibliotheken|**Smithay Toolkit**|In Rust geschriebene Bibliothek zum Erstellen von Wayland-Compositoren. Perfekte Passung zur Hauptprogrammiersprache Rust, vermeidet C-Bindings für Kernkomponenten des Compositors. Modular, flexibel, aktive Entwicklung, Fokus auf Sicherheit.|
|Essentielle Wayland-Protokolle|`wayland.xml` (Basis), `xdg-shell` (Fenster), `wlr-layer-shell-unstable-v1` (Shell-UI), `xdg-decoration-unstable-v1` (Dekorationen), `wlr-foreign-toplevel-management-unstable-v1` (Fensterliste), `wlr-output-management-unstable-v1` (Monitore), `wlr-output-power-management-unstable-v1` (Monitor-Energie), `input-method-unstable-v1`, `text-input-unstable-v3` (Eingabemethoden), Wayland Core (Zwischenablage/DND), `presentation-time`, `viewporter`, `linux-dmabuf-unstable-v1`, `idle-notify-unstable-v1`. XWayland für Kompatibilität (unterstützt durch Smithay).|Standardisierte Schnittstellen für alle Kernfunktionen einer Desktop-Umgebung unter Wayland. Die Auswahl von `wlr-*`-Protokollen erfolgt zugunsten der verfügbaren Funktionalität in der Rust/Smithay-Welt.|
|Inter-Prozess-Kommunikation (IPC)|**D-Bus** (mit `zbus` Crate)|De-facto-Standard für IPC im Linux-Desktop-Bereich. Nahtlose Integration mit essenziellen Systemdiensten (NetworkManager, UPower, logind, PolicyKit, Benachrichtigungsdienst, Secret Service).|
|KI-Integration|**Model Context Protocol (MCP)** (mit `mcp_client_rs` Crate)|Offener Standard für sichere, standardisierte Verbindung von KI-Modellen (LLMs) mit externen Werkzeugen und Anwendungen. Client-Server-Architektur, definierte Nachrichtenformate. Ermöglicht Anbindung lokaler und Cloud-basierter Modelle, Benutzerkontrolle über Datenzugriffe.|
|Eingabeverarbeitung|**libinput** (integriert via Smithay)|Standardbibliothek unter Linux für die Verarbeitung von Eingabeereignissen auf niedrigem Niveau. Robuste Unterstützung für Touchpad-Gesten. Konsistente und präzise Eingabebehandlung.|
|Audio-Management|**PipeWire** (mit `pipewire-rs` Crate)|Moderner Standard für Audio- und Video-Management unter Linux. Geringe Latenz, flexible Routing-Möglichkeiten, sandboxed Architektur. Kompatibilitätsschichten für PulseAudio-, JACK- und ALSA-Anwendungen.|
|Geheimnisverwaltung|**Freedesktop Secret Service API** (via D-Bus, z.B. mit `secret-service-rs` Crate)|Standardmechanismus zum sicheren Speichern von sensiblen Daten wie Passwörtern oder API-Schlüsseln. Implementierungen wie GNOME Keyring oder KWallet stellen diesen Dienst bereit.|
|Rechteverwaltung|**PolicyKit (polkit)** (via D-Bus)|Standardmechanismus unter Linux zur Autorisierung privilegierter Aktionen durch unprivilegierte Anwendungen nach Benutzerauthentifizierung.|
|Theming-Implementierung (UI)|**Token-basiertes System**, implementiert über **GTK4 CSS Custom Properties (`var()`)** und `@define-color` (als Fallback/Ergänzung).|Abstraktionsebene über konkreten Designwerten (Farben, Schriftgrößen, Abstände). Änderungen an Token-Definitionen (Domänenschicht) werden zur Laufzeit angewendet, was dynamische Theme-Umschaltung ohne Neustart ermöglicht.|
|Sandboxing-Interaktion|**XDG Desktop Portals** (via D-Bus, z.B. mit `xdg-portal-rs` Crate)|Standardisierte D-Bus-Schnittstellen für sandboxed Anwendungen (und native Apps) zum sicheren Zugriff auf Ressourcen außerhalb ihrer Sandbox (Dateidialoge, Kamera-/Mikrofonzugriff, Screencasting etc.). Backend-Implementierung durch NovaDE.|

In Google Sheets exportieren

**IV. Entwicklungsrichtlinien (Verbindlich)**

Diese Richtlinien gewährleisten Konsistenz, Qualität und Wartbarkeit des Codes über das gesamte Projekt.

1. **Programmiersprache Rust:**
    
    - **Stil und Formatierung:** Verbindliche Nutzung von `rustfmt` mit der Standardkonfiguration des Projekts. Maximale Zeilenlänge: 100 Zeichen. Einrückung: 4 Leerzeichen. Kommentare: `//` bevorzugt, `///` oder `//!` für `rustdoc`.
    - **API-Design:** Strikte Befolgung der Rust API Guidelines Checklist (Namensgebung RFC 430 Casing, Trait-Implementierungen, Fehlerbehandlung, Dokumentation, Generics, Newtypes, Builder-Pattern, private Felder, versiegelte Traits wo sinnvoll).
    - **Fehlerbehandlung:**
        - Ausschließliche Verwendung des `thiserror`-Crates zur Definition von benutzerdefinierten, spezifischen Fehler-Enums pro Modul in allen Schichten.
        - Fehler werden über `Result<T, E>` zurückgegeben.
        - Panics (`unwrap()`, `expect()`) sind in Bibliotheks-/Kern-/Domänen-/System-Code strengstens verboten. Ausnahme: `expect()` in Tests oder bei nachweislich nicht behebbaren internen Invariantenverletzungen mit aussagekräftiger Begründung im `expect()`-Aufruf.
        - `#[error("...")]`-Nachrichten müssen klar, prägnant und kontextbezogen sein. Sensible Daten dürfen niemals in Fehlermeldungen erscheinen.
        - Die `source()`-Kette von Fehlern muss durch korrekte Verwendung von `#[source]` und `#[from]` erhalten bleiben.
    - **Logging & Tracing:**
        - Verbindliche Nutzung des `tracing`-Crate-Frameworks für strukturiertes, kontextbezogenes Logging.
        - Verwendung von Spans (`#[tracing::instrument]`) für wichtige Funktionen und Operationen zur Kontextualisierung.
        - Definition und Einhaltung von Standard-Logging-Levels (ERROR, WARN, INFO, DEBUG, TRACE).
        - Sensible Daten dürfen niemals geloggt werden.
    - **Nebenläufigkeit:** Nutzung von Rusts `async/await` für I/O-gebundene oder langlaufende Operationen, insbesondere in der UI- und Systemschicht, um Blockaden zu vermeiden. Verwendung von `tokio` als primäre asynchrone Runtime, wo eine dedizierte Runtime benötigt wird (z.B. für Netzwerkdienste in der Systemschicht). Für GTK-spezifische asynchrone Aufgaben in der UI-Schicht `glib::MainContext::spawn_local`. Thread-sichere Datenstrukturen (`Arc`, `Mutex` von `parking_lot` oder `std::sync`) für geteilte Zustände.
    - **Crate-Struktur:** Logische Aufteilung des Projekts in mehrere Crates (z.B. `novade-core`, `novade-domain`, `novade-system`, `novade-ui`, sowie spezifische Crates für größere Komponenten wie `novade-compositor`, `novade-shell`). Klare öffentliche APIs (`pub`) und interne Modulstruktur (`pub(crate)`).
2. **Versionskontrolle & Branching:**
    
    - **System:** Git.
    - **Modell:** GitHub Flow. Der `main`-Branch repräsentiert stets den neuesten stabilen, potenziell auslieferbaren Zustand.
    - **Workflow:** Feature-Entwicklung erfolgt in kurzlebigen Branches, die von `main` abzweigen. Pull Requests (PRs) sind für das Mergen in `main` obligatorisch. Jeder PR erfordert mindestens ein positives Code-Review von einem anderen Teammitglied und das Bestehen aller CI-Prüfungen.
    - **Commit-Nachrichten:** Einhaltung der Conventional Commits Spezifikation zur Nachvollziehbarkeit und automatisierten Changelog-Generierung.
3. **Teststrategie:**
    
    - **Unit-Tests:** Obligatorisch für alle Komponenten der Kern- und Domänenschicht sowie für Logik-Komponenten der System- und UI-Schicht. Direkt neben dem zu testenden Code (`#[cfg(test)]`). Hohe Codeabdeckung wird angestrebt.
    - **Integrationstests:** Im `tests/`-Verzeichnis auf Crate-Ebene. Testen das Zusammenspiel verschiedener Module oder Schichten und die Interaktion mit (gemockten) externen Schnittstellen.
    - **Compositor-Tests (Systemschicht):** Evaluierung und Einsatz von verschachtelten/headless Wayland-Backends (unterstützt durch Smithay) oder spezialisierten Test-Clients zur Verifizierung der Kernlogik des Compositors (Fensterplatzierung, Protokollimplementierungen).
    - **UI-Tests (UI-Schicht):** Nutzung von Accessibility-APIs zur Inspektion und Steuerung von Widgets, Simulation von Eingabeereignissen auf Wayland-Ebene. Evaluierung von Frameworks für visuelle Regressionstests für GTK4/Rust.
    - **Continuous Integration (CI) Pipeline:**
        - Automatische Ausführung aller definierten Tests (Unit, Integration) bei jedem Push und PR.
        - Prüfungen für Code-Formatierung (`cargo fmt --check`).
        - Linting (`cargo clippy -- -D warnings` mit projektspezifischer Clippy-Konfiguration).
        - Prüfung auf Sicherheitslücken in Abhängigkeiten (`cargo audit`).
        - Ein Merge in `main` ist nur bei erfolgreichem Durchlauf aller CI-Prüfungen gestattet.
4. **Dokumentation:**
    
    - **Code-Dokumentation (`rustdoc`):**
        - Umfassende `rustdoc`-Kommentare (`///` oder `//!`) sind für alle öffentlichen APIs (Crates, Module, Funktionen, Typen, Felder, Traits) zwingend erforderlich.
        - Dokumentation muss nicht nur beschreiben, _was_ eine Komponente tut, sondern auch _warum_ sie existiert und _wie_ sie korrekt verwendet wird.
        - Muss Erklärungen zur Logik, zu Invarianten, zu möglichen Fehlerbedingungen (`# Errors`-Sektion) und zu Sicherheitsaspekten (`# Safety`-Sektion für `unsafe` Code, der strikt zu minimieren ist) enthalten.
        - Aussagekräftige Code-Beispiele (`#[doc(inline)]` oder in separaten `examples/`-Verzeichnissen) sind essenziell.
    - **Architektur-Dokumentation:**
        - Dieses Gesamtspezifikationsdokument dient als zentrales Referenzdokument.
        - High-Level-Architekturdiagramme (Schichtendiagramme, Komponentendiagramme, C4-Modell-Elemente wo sinnvoll) müssen erstellt und aktuell gehalten werden, um das Gesamtsystem und die Interaktionen zwischen den Hauptkomponenten zu beschreiben. Diese sind Teil dieses Dokuments oder als separate, verlinkte Artefakte zu pflegen.
    - **READMEs:** Jedes Crate und jede größere, eigenständige Komponente muss eine `README.md`-Datei besitzen, die den Zweck, die Hauptfunktionen, Build-Anweisungen und grundlegende Nutzungsanweisungen beschreibt.
    - **Metadaten:** Alle `Cargo.toml`-Dateien müssen vollständige und korrekte Metadaten enthalten (`authors`, `description`, `license`, `repository`, `homepage`, `documentation`, `keywords`, `categories`). Dies ist wichtig für die interne Verwaltung, potenzielle Veröffentlichung und Auffindbarkeit.
    - **Benutzer- und Entwicklerdokumentation:** Parallel zur Entwicklung sind Konzepte für eine separate Benutzerdokumentation (Anleitung zur Bedienung der Desktop-Umgebung) und weiterführende Entwicklerdokumentation (z.B. Anleitungen zum Erstellen von Widgets oder Plugins, detaillierte API-Referenzen über `rustdoc` hinaus) zu erstellen.

**V. Initiale Schicht- und Komponentenspezifikationen (Struktur)**

Die detaillierten Spezifikationen für jede Komponente jeder Schicht (wie in den vorherigen Antworten teilweise bereits skizziert) werden als separate, untergeordnete Dokumente oder Abschnitte dieser Gesamtspezifikation geführt. Sie folgen einer einheitlichen Struktur:

1. **Modul-/Komponentenübersicht:** Zweck, Verantwortlichkeiten, Design-Rationale.
2. **Datenstrukturen und Typdefinitionen:** Detaillierte Definition aller relevanten `struct`s, `enum`s, `trait`s und Typaliase in Rust-Syntax, inklusive aller Felder, Varianten und abgeleiteten Traits (z.B. `Debug`, `Clone`, `Serialize`, `Deserialize`, `Default`, `thiserror::Error`). Tabellarische Übersichten für komplexe Typen.
3. **Öffentliche API und Interne Schnittstellen:** Exakte Signaturen aller öffentlichen Funktionen/Methoden. Beschreibung von Vor- und Nachbedingungen, Logik/Algorithmen der Methoden. Spezifikation von Events (Payload-Struktur, Publisher, Subscriber, Auslösebedingungen).
4. **Fehlerbehandlung:** Definition des modulspezifischen Fehler-Enums mit `thiserror`, inklusive aller Varianten, `#[error(...)]`-Nachrichten und der Handhabung von `#[source]` und `#[from]`.
5. **Interaktionen und Abhängigkeiten:** Beschreibung der Interaktionen mit anderen Modulen/Komponenten derselben Schicht und mit Modulen/Komponenten anderer Schichten.
6. **Detaillierte Implementierungsschritte:** Eine schrittweise Anleitung für die Implementierung, die die Erstellung von Dateien, die Definition von Typen und die Implementierung von Methoden und Logik umfasst.
7. **Testaspekte:** Identifikation testkritischer Logik, Beispiele für Testfälle, Hinweise zu Mocking-Strategien.

**VI. Deployment-Überlegungen**

1. **Paketierung:**
    - **Zielformate:** Primär native Pakete für gängige Linux-Distributionen (z.B. `.deb` für Debian/Ubuntu, `.rpm` für Fedora/openSUSE).
    - **Flatpak:** Evaluierung und potenzielle Bereitstellung der gesamten Desktop-Umgebung oder wichtiger Teile davon als Flatpak zur distributionsunabhängigen Installation und für Entwickler-SDKs.
    - **Build-Prozess:** Der Meson-Build-Prozess muss Artefakte für diese Paketformate erstellen können, inklusive korrekter Handhabung von Abhängigkeiten, Installation von Desktop-Dateien (`.desktop`), Icons, Themes, Konfigurationsdateien und systemd-Units.
2. **Systemintegration:**
    - **Display Manager:** Konfiguration für gängige Display Manager (GDM, LightDM, SDDM) zur Auswahl von NovaDE als Sitzung.
    - **systemd User Sessions:** Korrekte Einrichtung von systemd User Sessions für NovaDE.
    - **PAM-Module:** Sicherstellung der Kompatibilität und ggf. Bereitstellung spezifischer PAM-Konfigurationen für Login und Authentifizierung.
    - **XDG Base Directory Specification:** Strikte Einhaltung für alle benutzer- und systemweiten Konfigurations-, Daten- und Cache-Dateien (`$XDG_CONFIG_HOME`, `$XDG_DATA_HOME`, `$XDG_CACHE_HOME`, `$XDG_CONFIG_DIRS`, `$XDG_DATA_DIRS`).
3. **Konfiguration:**
    - Bereitstellung einer sinnvollen Standardkonfiguration für alle Aspekte der Desktop-Umgebung.
    - Klare Mechanismen für Benutzer, um diese Standardeinstellungen über grafische Oberflächen (`ui::control_center`) und ggf. Konfigurationsdateien zu überschreiben.
    - Trennung von Systemkonfiguration (typischerweise in `/etc`) und Benutzerkonfiguration (in `$XDG_CONFIG_HOME`).
4. **Updates:**
    - **Strategie:** Primär über die Paketmanager der jeweiligen Distributionen. Für Flatpak-Installationen über den Flatpak-Update-Mechanismus.
    - **Versionierung:** Semantische Versionierung (SemVer) für das Gesamtprojekt und für kritische Bibliotheks-Crates.
    - **Konfigurationsmigration:** Mechanismen oder Richtlinien zur Handhabung von Änderungen an Konfigurationsformaten oder -schlüsseln bei Updates, um Datenverlust oder Inkompatibilitäten zu vermeiden (z.B. automatische Migration, klare Hinweise für Benutzer).

**VII. Schlussfolgerung**

Diese technische Gesamtspezifikation legt das verbindliche Fundament für die Entwicklung der Linux-Desktop-Umgebung NovaDE. Sie definiert eine klare, geschichtete Architektur, wählt einen modernen und robusten Technologie-Stack basierend auf Rust, Wayland, GTK4 und Smithay und etabliert detaillierte Entwicklungsrichtlinien für Qualität, Konsistenz und Wartbarkeit.

Die präzisen Entscheidungen bezüglich Architektur, Technologien und Richtlinien bilden die unumstößliche Grundlage für die nachfolgenden, detaillierten Implementierungsleitfäden der einzelnen Schichten und Komponenten. Durch die konsequente und disziplinierte Einhaltung dieser Spezifikation wird eine hochwertige, moderne, sichere, performante und anpassungsfähige Desktop-Umgebung entstehen, die den hohen Anforderungen von Entwicklern, Kreativen und alltäglichen Nutzern gerecht wird und eine intuitive, effiziente und persönliche Benutzererfahrung bietet. Dieses Dokument ist lebendig und wird bei Bedarf unter strenger Einhaltung der übergeordneten Vision und Architekturprinzipien aktualisiert.

## NovaDE: Spezifikation und Implementierungsleitfaden – Domänenschicht

Dieser Leitfaden beschreibt die Architektur, APIs, Datenstrukturen und Interaktionen der Domänenschicht (Crate: `novade-domain`). Diese Schicht kapselt die Kernlogik und den Zustand der NovaDE-Desktop-Umgebung und ist unabhängig von UI-Toolkit-spezifischen oder direkten System-Hardware-Interaktionen.

**Allgemeine Prinzipien der Domänenschicht:**

- **UI-Unabhängigkeit:** Keine direkten Abhängigkeiten von GTK4 oder anderen UI-Frameworks.
- **Systemunabhängigkeit:** Keine direkte Interaktion mit Wayland-Protokollen, D-Bus auf Low-Level-Ebene oder Hardware. Diese werden von der Systemschicht gehandhabt.
- **Fokus auf Geschäftslogik:** Definiert die Regeln, Zustände und Prozesse der Desktop-Umgebung.
- **API-Design:** Öffentliche Schnittstellen primär über Rust-Traits, die von Service-Strukturen implementiert werden, um Testbarkeit und lose Kopplung zu fördern.
- **Zustandsverwaltung:** Veränderliche Zustände innerhalb von Services werden threadsicher gekapselt (z.B. `Arc<Mutex<...>>` oder `Arc<RwLock<...>>`).
- **Asynchronität:** `async/await` und `async_trait` für potenziell blockierende Operationen oder wenn die Interaktion mit der Systemschicht dies erfordert.
- **Events:** Ein klar definierter Event-Mechanismus (z.B. `tokio::sync::broadcast`) für die Kommunikation von Zustandsänderungen.
- **Fehlerbehandlung:** Konsequente Nutzung von `thiserror` für modulspezifische Fehler-Enums. Fehler aus der Kernschicht (`novade-core`) werden gewrappt.
- **Abhängigkeiten:** Nutzt ausschließlich `novade-core` für fundamentale Typen und Fehlerbasis.

---

### Modul 1: `domain::theming`

**Zweck:** Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel (Farbschema, Akzentfarben).

**Referenz:** Siehe Dokument `B1 Domänenschicht.md` für eine bereits sehr detaillierte Ausarbeitung dieses Moduls. Die folgenden Punkte ergänzen oder verfeinern diese.

#### 1.1. APIs (Traits)

Rust

```
// domain/src/theming/service_api.rs

use async_trait::async_trait;
use std::path::PathBuf;
use tokio::sync::broadcast; // For eventing

use novade_core::types::Color as CoreColor; // Assuming Color is in novade-core

use super::types::{
    ThemeIdentifier, ColorSchemeType, AccentColor, AppliedThemeState,
    ThemingConfiguration, ThemeDefinition,
};
use super::errors::ThemingError;

/// Event that is broadcast when the theme state changes.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
pub struct ThemeChangedEvent {
    pub new_state: AppliedThemeState,
    pub old_state: Option<AppliedThemeState>, // Optional: previous state for comparison
}

#[async_trait]
pub trait ThemingEngineService: Send + Sync {
    /// Initializes the theming engine with a set of paths to load themes and tokens from,
    /// and an initial user configuration.
    async fn new(
        initial_config: ThemingConfiguration,
        theme_load_paths: Vec<PathBuf>,
        token_load_paths: Vec<PathBuf>,
        // Assuming a dependency on a core configuration service for file I/O abstraction
        config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, // From novade-core
        broadcast_capacity: usize,
    ) -> Result<Arc<Self>, ThemingError> where Self: Sized; // Arc<Self> for easy sharing

    /// Retrieves the currently applied and fully resolved theme state.
    /// This is the primary way for the UI layer to get current theme values.
    async fn get_current_theme_state(&self) -> AppliedThemeState;

    /// Lists all available (loaded and validated) theme definitions.
    async fn get_available_themes(&self) -> Vec<ThemeDefinition>;

    /// Retrieves the current user-defined theming configuration being used by the engine.
    async fn get_current_configuration(&self) -> ThemingConfiguration;

    /// Updates the theming configuration. This triggers a re-calculation of the
    /// AppliedThemeState and, if changed, broadcasts a ThemeChangedEvent.
    async fn update_configuration(
        &self,
        new_config: ThemingConfiguration,
    ) -> Result<(), ThemingError>;

    /// Reloads all theme definitions and token files from the configured paths.
    /// Applies the current ThemingConfiguration to the reloaded data.
    /// Broadcasts a ThemeChangedEvent if the AppliedThemeState changes.
    async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>;

    /// Allows other parts of the system to subscribe to theme change notifications.
    fn subscribe_to_theme_changes(&self) -> broadcast::Receiver<ThemeChangedEvent>;
}
```

#### 1.2. Datenstrukturen

Definiert in `domain/src/theming/types.rs`. Basierend auf `B1 Domänenschicht.md`, mit folgenden Präzisierungen:

- **`TokenIdentifier`**:
    - Invarianten: String nicht leer, enthält nur `a-zA-Z0-9.-`. Validierung in `new()` (z.B. via `debug_assert!` oder Rückgabe von `Result`).
- **`TokenValue`**:
    - `Opacity(f64)`: Wert muss zwischen 0.0 und 1.0 liegen (Validierung bei Erstellung/Parsing).
    - Die String-Werte in `Color`, `Dimension`, etc. sollten gültige CSS-Werte sein. Die Validierung dieser CSS-Strings erfolgt primär bei der Anwendung (UI-Schicht) oder durch Linting der Theme-Dateien. Die Domänenschicht stellt sicher, dass die Typen konsistent sind.
- **`TokenSet`**: `pub type TokenSet = std::collections::BTreeMap<TokenIdentifier, RawToken>;` (Verwendung von `BTreeMap` für deterministische Reihenfolge, was Tests und Debugging erleichtert. `TokenIdentifier` muss `Ord` implementieren).
- **`AccentColor`**:
    - `value: novade_core::types::Color`: Verwendet den `Color`-Typ aus `novade-core`.
- **`ThemeDefinition`**:
    - `supported_accent_colors: Option<Vec<AccentColor>>`
    - `accentable_tokens: Option<HashMap<TokenIdentifier, AccentModificationType>>`: (Neu) Definiert, welche Tokens von Akzentfarben beeinflusst werden und wie.
        - `AccentModificationType` (Enum): `DirectReplace`, `Lighten(f32)`, `Darken(f32)`, `DesaturateAndTint(f32)`.
- **`AppliedThemeState`**:
    - `resolved_tokens: std::collections::BTreeMap<TokenIdentifier, String>;`
- **`ThemingConfiguration`**:
    - `selected_accent_color: Option<novade_core::types::Color>;`

#### 1.3. Events

- **`ThemeChangedEvent`**: (Definiert in `service_api.rs` oder `events.rs`)
    - `pub new_state: AppliedThemeState`
    - `pub old_state: Option<AppliedThemeState>`

#### 1.4. Fehlerbehandlung

- **`ThemingError`** (in `domain/src/theming/errors.rs`): Basierend auf `B1 Domänenschicht.md`, erweitert um:
    - `InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String }`
    - `AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: CoreColor, details: String }`
    - `TokenResolutionError { token_id: TokenIdentifier, message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
    - `FilesystemError(#[from] novade_core::errors::CoreError)`: Für Fehler vom `ConfigServiceAsync`.

#### 1.5. Interaktionen

- **Mit `novade-core::config::ConfigServiceAsync`**: Zum asynchronen Laden von Token- und Theme-Dateien.
- **Mit `domain::global_settings_and_state_management`**: Kann globale Einstellungen lesen, die das Theming beeinflussen (z.B. eine globale "Hoher Kontrast"-Einstellung).

---

### Modul 2: `domain::workspaces`

**Zweck:** Umfassende Verwaltungslogik für Arbeitsbereiche ("Spaces").

**Referenz:** Siehe Dokument `B2 Domänenschicht.md` für eine bereits sehr detaillierte Ausarbeitung. Die folgenden Punkte ergänzen oder verfeinern diese.

#### 2.1. APIs (Traits)

Rust

```
// domain/src/workspaces/service_api.rs
use async_trait::async_trait;
use tokio::sync::broadcast;
use uuid::Uuid; // Assuming WorkspaceId = uuid::Uuid

use novade_core::types::RectInt; // For available_area in layout calculations

use super::types::{
    WorkspaceId, WindowIdentifier, WorkspaceLayoutType, Workspace,
    WorkspaceIconChangedData, WorkspaceAccentChangedData,
    WorkspaceCreationParams, // New struct for create_workspace
};
use super::config_types::WorkspaceSetSnapshot; // For config interaction
use super::errors::WorkspaceManagerError;
use crate::window_management_policy::types::WorkspaceWindowLayout; // Assuming this path

/// Event that is broadcast when workspace-related states change.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub enum WorkspaceEvent {
    WorkspaceCreated {
        id: WorkspaceId,
        name: String,
        persistent_id: Option<String>,
        icon_name: Option<String>,
        accent_color_hex: Option<String>,
        layout_type: WorkspaceLayoutType,
        position: usize, // Position in the ordered list
    },
    WorkspaceDeleted {
        id: WorkspaceId,
        windows_moved_to_workspace_id: Option<WorkspaceId>,
    },
    ActiveWorkspaceChanged {
        old_id: Option<WorkspaceId>,
        new_id: WorkspaceId,
    },
    WorkspaceRenamed { // Uses WorkspaceRenamedData from core::event_data
        id: WorkspaceId,
        old_name: String,
        new_name: String,
    },
    WorkspaceLayoutChanged { // Uses WorkspaceLayoutChangedData
        id: WorkspaceId,
        old_layout: WorkspaceLayoutType,
        new_layout: WorkspaceLayoutType,
    },
    WindowAddedToWorkspace { // Uses WindowAddedToWorkspaceData
        workspace_id: WorkspaceId,
        window_id: WindowIdentifier,
    },
    WindowRemovedFromWorkspace { // Uses WindowRemovedFromWorkspaceData
        workspace_id: WorkspaceId,
        window_id: WindowIdentifier,
    },
    WorkspaceOrderChanged(Vec<WorkspaceId>), // New, full ordered list of IDs
    WorkspacesReloaded {
        active_workspace_id: Option<WorkspaceId>,
        ordered_ids: Vec<WorkspaceId>,
    },
    WorkspaceIconChanged(WorkspaceIconChangedData),
    WorkspaceAccentChanged(WorkspaceAccentChangedData),
    // Event when the layout of windows within a workspace is recalculated
    WorkspaceLayoutApplied { // New event
        workspace_id: WorkspaceId,
        applied_layout: WorkspaceWindowLayout, // From window_management_policy
    }
}


#[async_trait]
pub trait WorkspaceConfigProvider: Send + Sync {
    async fn load_workspace_config(&self) -> Result<WorkspaceSetSnapshot, WorkspaceManagerError>;
    async fn save_workspace_config(&self, config_snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceManagerError>;
}

#[async_trait]
pub trait WorkspaceManagerService: Send + Sync {
    async fn new(
        config_provider: Arc<dyn WorkspaceConfigProvider>,
        broadcast_capacity: usize,
        ensure_unique_window_assignment: bool,
    ) -> Result<Arc<Self>, WorkspaceManagerError> where Self: Sized;

    async fn create_workspace(&self, params: WorkspaceCreationParams) -> Result<WorkspaceId, WorkspaceManagerError>;
    async fn delete_workspace(&self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>;

    async fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>; // Returns a clone
    async fn get_all_workspaces_ordered(&self) -> Vec<Workspace>; // Returns clones
    async fn get_active_workspace_id(&self) -> Option<WorkspaceId>;
    async fn get_active_workspace(&self) -> Option<Workspace>; // Returns a clone

    async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;

    async fn assign_window_to_active_workspace(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
    async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
    async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>; // Returns Option<WorkspaceId> it was removed from
    async fn move_window_to_specific_workspace(&self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
    async fn get_workspace_for_window(&self, window_id: &WindowIdentifier) -> Option<WorkspaceId>;


    async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>;
    async fn set_workspace_layout(&self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>;
    async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>;
    async fn set_workspace_accent_color(&self, id: WorkspaceId, color_hex: Option<String>) -> Result<(), WorkspaceManagerError>;
    async fn set_workspace_persistent_id(&self, id: WorkspaceId, persistent_id: Option<String>) -> Result<(), WorkspaceManagerError>;


    async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>;

    /// Explicitly triggers saving the current workspace configuration.
    async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>;

    fn subscribe_to_workspace_events(&self) -> broadcast::Receiver<WorkspaceEvent>;

    /// (Neu) Wird von der Systemschicht aufgerufen, wenn der Compositor ein neues Fenster erkennt.
    /// Die Domänenschicht entscheidet dann, welchem Workspace es zugeordnet wird (Policy).
    async fn handle_new_system_window(&self, window_id: WindowIdentifier, initial_properties: Option<crate::window_management_policy::types::WindowLayoutInfo>) -> Result<(), WorkspaceManagerError>;

    /// (Neu) Wird von der Systemschicht aufgerufen, wenn ein Fenster vom Compositor geschlossen/zerstört wird.
    async fn handle_system_window_closed(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;

}
```

#### 2.2. Datenstrukturen

Definiert in `domain/src/workspaces/types.rs` und `config_types.rs`.

- **`WindowIdentifier`**:
    
    - Die `new` Methode gibt `Result<Self, WorkspaceCoreError>` zurück und validiert, dass die ID nicht leer ist und optional weiteren Kriterien (z.B. keine Leerzeichen) genügt.
- **`Workspace`**:
    
    - Felder: `id`, `name`, `persistent_id`, `layout_type`, `window_ids: HashSet<WindowIdentifier>`, `created_at`, `icon_name: Option<String>`, `accent_color_hex: Option<String>` (validierter Hex-String).
    - Die `new` Methode validiert Namen, `persistent_id` und `accent_color_hex`.
    - Methoden für `set_icon_name` und `set_accent_color_hex` hinzugefügt (mit Validierung für Hex).
- **`WorkspaceCreationParams`** (Neu in `types.rs`):
    
    Rust
    
    ```
    #[derive(Debug, Clone, Default)]
    pub struct WorkspaceCreationParams {
        pub name: Option<String>,
        pub persistent_id: Option<String>,
        pub icon_name: Option<String>,
        pub accent_color_hex: Option<String>,
        pub layout_type_hint: Option<WorkspaceLayoutType>, // Vorschlag für das Layout
        pub activate_when_created: bool,
    }
    ```
    
- **`WorkspaceSnapshot`** (in `config_types.rs`): Enthält nun auch `icon_name` und `accent_color_hex`.
    

#### 2.3. Events

- **`WorkspaceEvent`** (in `events.rs`): Erweitert um `WorkspaceIconChanged` und `WorkspaceAccentChanged` (mit entsprechenden Payloads aus `core::event_data`). `WorkspaceLayoutApplied` hinzugefügt.

#### 2.4. Fehlerbehandlung

- **`WorkspaceCoreError`**: Erweitert um `InvalidAccentColorFormat(String)`.
- **`WorkspaceManagerError`**: Keine wesentlichen Änderungen, aber die Fehlerpropagation von den neuen Methoden muss berücksichtigt werden.

#### 2.5. Interaktionen

- **Mit `domain::window_management_policy`**: Der `WorkspaceManagerService::handle_new_system_window` ruft den `WindowManagementPolicyService` auf, um die initiale Platzierung und den Workspace für ein neues Fenster zu bestimmen.
- **Mit `domain::global_settings_service`**: Der `WorkspaceManagerService` kann globale Einstellungen lesen, die das Workspace-Verhalten beeinflussen (z.B. Standard-Layout, ob dynamische Workspaces erlaubt sind).

---

### Modul 3: `domain::user_centric_services`

**Zweck:** KI-Interaktionsmanagement (inkl. Einwilligungen) und Benachrichtigungsmanagement.

**Referenz:** Siehe Dokument `B3 Domänenschicht.md` und vorherige Antwort.

#### 3.1. Untermodul: `domain::user_centric_services::ai_interaction`

##### APIs (Traits)

Rust

```
// domain/src/user_centric_services/ai_interaction/service_api.rs
use async_trait::async_trait;
use tokio::sync::broadcast;
use uuid::Uuid;

use super::types::{
    AIInteractionContext, AIConsent, AIModelProfile, AIDataCategory, AttachmentData,
    AIConsentStatus, InteractionHistoryEntry, AIModelCapability, AIConsentScope,
    AIInteractionContextInput, // New struct for initiating interaction
};
use super::errors::AIInteractionError;
use crate::shared_types::ApplicationId; // Assuming ApplicationId is a shared type

/// Event enum for AI interaction related events.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub enum AIInteractionEvent {
    InteractionInitiated {
        context: AIInteractionContext, // Send the whole initial context
    },
    ConsentUpdated {
        user_id: String, // Or a more specific User ID type
        model_id: String,
        category: AIDataCategory,
        new_status: AIConsentStatus,
        scope: AIConsentScope,
    },
    ContextUpdated { // For changes like history additions, attachment changes
        context_id: Uuid,
        // Optionally, more specific information about what changed
        // e.g., new_history_entry_count: usize, new_attachment_count: usize
    },
    ModelProfilesReloaded {
        profiles: Vec<AIModelProfile>,
    },
    // Event to request UI to show a consent dialog
    ConsentRequiredForInteraction {
        context_id: Uuid,
        model_id: String,
        required_categories: Vec<AIDataCategory>,
        prompt_message: Option<String>, // Message for the user
    },
}


#[async_trait]
pub trait AIConsentProvider: Send + Sync {
    async fn load_consents_for_user(&self, user_id: &str) -> Result<Vec<AIConsent>, AIInteractionError>;
    async fn save_consent(&self, consent: &AIConsent) -> Result<(), AIInteractionError>;
    async fn save_consents(&self, consents: &[AIConsent]) -> Result<(), AIInteractionError>; // Batch save
    async fn revoke_consent(&self, consent_id: Uuid, user_id: &str) -> Result<(), AIInteractionError>;
    async fn get_consent(&self, user_id: &str, model_id: &str, category: AIDataCategory) -> Result<Option<AIConsent>, AIInteractionError>;
}

#[async_trait]
pub trait AIModelProfileProvider: Send + Sync {
    async fn load_model_profiles(&self) -> Result<Vec<AIModelProfile>, AIInteractionError>;
    // Optional: async fn save_model_profiles(&self, profiles: &[AIModelProfile]) -> Result<(), AIInteractionError>;
}


#[async_trait]
pub trait AIInteractionLogicService: Send + Sync {
    async fn new(
        consent_provider: Arc<dyn AIConsentProvider>,
        profile_provider: Arc<dyn AIModelProfileProvider>,
        broadcast_capacity: usize,
        // Potentially a handle to GlobalSettingsService for default user_id or global AI prefs
        // settings_service: Arc<dyn GlobalSettingsService>,
    ) -> Result<Arc<Self>, AIInteractionError> where Self: Sized;

    /// Initiates a new AI interaction context based on input.
    /// May trigger a ConsentRequiredForInteraction event if consent is missing.
    async fn initiate_interaction(
        &self,
        user_id: &str, // Explicit user context
        input: AIInteractionContextInput,
    ) -> Result<Uuid, AIInteractionError>; // Returns context_id

    async fn get_interaction_context(&self, context_id: Uuid) -> Result<Option<AIInteractionContext>, AIInteractionError>;

    /// Provides or updates consent for a specific model and data categories.
    async fn provide_user_consent(
        &self,
        user_id: &str,
        model_id: String,
        category: AIDataCategory, // Grant/deny per category
        scope: AIConsentScope,
        consent_decision: bool, // true for granted, false for denied
        expiry_timestamp: Option<DateTime<Utc>>, // Only if scope is SpecificDuration
    ) -> Result<(), AIInteractionError>;

    /// Retrieves the effective consent status for a model and a set of data categories.
    /// This will check all relevant stored AIConsent objects.
    async fn get_effective_consent_status(
        &self,
        user_id: &str,
        model_id: &str,
        data_categories: &[AIDataCategory],
    ) -> Result<AIConsentStatus, AIInteractionError>;

    async fn add_attachment_to_context(
        &self,
        context_id: Uuid,
        attachment: AttachmentData,
    ) -> Result<(), AIInteractionError>;

    async fn update_interaction_history(
        &self,
        context_id: Uuid,
        entry: InteractionHistoryEntry,
    ) -> Result<(), AIInteractionError>;

    async fn list_available_models(&self) -> Result<Vec<AIModelProfile>, AIInteractionError>;
    async fn get_model_profile(&self, model_id: &str) -> Result<Option<AIModelProfile>, AIInteractionError>;
    async fn get_default_model(&self) -> Result<Option<AIModelProfile>, AIInteractionError>;
    async fn reload_model_profiles(&self) -> Result<(), AIInteractionError>; // Triggers reload via provider

    /// Retrieves all stored (non-revoked, non-expired) consents for a user and optionally a model.
    async fn get_active_user_consents(&self, user_id: &str, model_id_filter: Option<&str>) -> Result<Vec<AIConsent>, AIInteractionError>;

    fn subscribe_to_ai_events(&self) -> broadcast::Receiver<AIInteractionEvent>;
}
```

##### Datenstrukturen

- **`AIInteractionContextInput`** (Neu in `types.rs`):
    
    Rust
    
    ```
    #[derive(Debug, Clone, Default)]
    pub struct AIInteractionContextInput {
        pub initial_prompt: Option<String>,
        pub target_model_id: Option<String>, // If a specific model is requested
        pub required_data_categories: Vec<AIDataCategory>, // What the user/action intends to use
        pub initial_attachments: Option<Vec<AttachmentData>>,
        pub source_application_id: Option<ApplicationId>, // Context: which app initiated
        pub source_workspace_id: Option<WorkspaceId>,     // Context: on which workspace
    }
    ```
    
- **`AIModelProfile`**: `capabilities` wird zu `Vec<AIModelCapability>`. `api_key_secret_name` bleibt wichtig.
    
- **`AIConsent`**: Einwilligungen sind nun pro `(user_id, model_id, data_category)`. `AIConsentScope` hinzugefügt.
    
- **`AIInteractionContext`**: `history_entries: Vec<InteractionHistoryEntry>`.
    

##### Fehlerbehandlung (`AIInteractionError`)

- Erweitert um spezifischere Fehler für Consent-Prüfung und API-Key-Handling.

##### Interaktionen

- Persistenz von `AIConsent` und `AIModelProfile` über die `AIConsentProvider` und `AIModelProfileProvider` Traits, deren Implementierungen (`Filesystem...Provider`) `novade-core::config::ConfigServiceAsync` nutzen.
- Interaktion mit `system::mcp_client::SystemMcpService`: Die `AIInteractionLogicService` entscheidet _ob_ und _mit welchen Daten_ eine KI-Anfrage (z.B. `CallTool`) gestellt werden darf. Dann ruft sie die Systemschicht-API auf.

#### 3.2. Untermodul: `domain::user_centric_services::notifications_core`

**Zweck:** Kernlogik für das Verwalten von Benachrichtigungen.

**Referenz:** Siehe Dokument `B4 Domänenschicht.md` (Abschnitt 4.3) und vorherige Antwort.

##### APIs (Traits)

Rust

```
// domain/src/user_centric_services/notifications_core/service_api.rs
use async_trait::async_trait;
use tokio::sync::broadcast;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

use crate::shared_types::ApplicationId; // Assuming ApplicationId
use crate::global_settings_and_state_management::GlobalSettingsService; // To get DND, history limits
use crate::notifications_rules::NotificationRulesEngine; // For rule processing

use super::types::{
    Notification, NotificationAction, NotificationUrgency, NotificationId,
    NotificationFilterCriteria, NotificationSortOrder, NotificationInput, NotificationStats,
    DismissReason,
};
use super::errors::NotificationError;


/// Event enum for notification related events.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub enum NotificationEvent {
    NotificationPosted {
        notification: Notification,
        was_suppressed_by_dnd: bool,
        was_suppressed_by_rule: Option<String>, // rule_id if suppressed
    },
    NotificationUpdated { // For updates to an existing notification (e.g., progress)
        notification: Notification,
    },
    NotificationDismissed {
        notification_id: NotificationId,
        reason: DismissReason,
    },
    NotificationActionInvoked {
        notification_id: NotificationId,
        action_key: String,
    },
    DoNotDisturbModeChanged {
        dnd_enabled: bool,
    },
    NotificationHistoryCleared,
    NotificationPopupExpired { // When an active notification is removed due to popup limit
        notification_id: NotificationId,
    },
}


#[async_trait]
pub trait NotificationService: Send + Sync {
    async fn new(
        rules_engine: Arc<dyn NotificationRulesEngine>,
        settings_service: Arc<dyn GlobalSettingsService>, // For DND, history limits
        broadcast_capacity: usize,
    ) -> Result<Arc<Self>, NotificationError> where Self: Sized;

    /// Posts a new notification to the system.
    /// Applies rules, checks DND, and manages active/history lists.
    async fn post_notification(&self, input: NotificationInput) -> Result<NotificationId, NotificationError>;

    /// Retrieves a specific notification (active or from history if found).
    async fn get_notification(&self, notification_id: NotificationId) -> Result<Option<Notification>, NotificationError>;

    /// Marks a notification as read. Does not remove it from active list.
    async fn mark_as_read(&self, notification_id: NotificationId) -> Result<(), NotificationError>;

    /// Dismisses a notification by the user or system.
    async fn dismiss_notification(&self, notification_id: NotificationId, reason: DismissReason) -> Result<(), NotificationError>;

    async fn get_active_notifications(
        &self,
        filter: Option<NotificationFilterCriteria>,
        sort_order: Option<NotificationSortOrder>,
        limit: Option<usize>,
    ) -> Result<Vec<Notification>, NotificationError>;

    async fn get_notification_history(
        &self,
        filter: Option<NotificationFilterCriteria>,
        sort_order: Option<NotificationSortOrder>,
        limit: Option<usize>,
        offset: Option<usize>,
    ) -> Result<Vec<Notification>, NotificationError>;

    async fn clear_history(&self) -> Result<(), NotificationError>;
    async fn clear_all_for_app(&self, app_id: &ApplicationId) -> Result<usize, NotificationError>; // Returns count dismissed

    async fn set_do_not_disturb(&self, enabled: bool) -> Result<(), NotificationError>;
    async fn is_do_not_disturb_enabled(&self) -> Result<bool, NotificationError>;

    async fn invoke_action(&self, notification_id: NotificationId, action_key: &str) -> Result<(), NotificationError>;

    async fn get_stats(&self) -> Result<NotificationStats, NotificationError>;

    fn subscribe_to_notification_events(&self) -> broadcast::Receiver<NotificationEvent>;
}
```

##### Datenstrukturen

- **`NotificationInput`** (Neu in `types.rs`): Struktur für das Erstellen von Benachrichtigungen. Enthält `app_name`, `replaces_id_domain: Option<NotificationId>` (umbenannt von `replaces_id` zur Klarheit, da D-Bus `u32` verwendet), `app_icon`, `summary`, `body`, `actions`, `urgency`, `category`, `hints`, `timeout_ms`, `transient`.
- **`Notification`**: `id` ist `NotificationId`. `replaces_id` entfernt. `timestamp` ist `DateTime<Utc>`. `hints` ist `HashMap<String, serde_json::Value>`.
- **`DismissReason`** (Enum in `events.rs` oder `types.rs`): `Expired`, `UserDismissed`, `AppClosed`, `ReplacedById(NotificationId)`, `SystemShutdown`, `AppScopeClear`, `RuleSuppressed`.

##### Interaktionen

- Der `DefaultNotificationService` hält `Arc<dyn NotificationRulesEngine>` und `Arc<dyn GlobalSettingsService>`.
- **`post_notification` Logik (verfeinert):**
    1. Generiert eine neue `NotificationId` und setzt `timestamp`.
    2. Erstellt `Notification` aus `NotificationInput`.
    3. Ruft `self.rules_engine.process_notification(temp_notification).await?`.
        - Wenn `RuleProcessingResult::Suppress { rule_id }`: Sendet `NotificationPostedEvent { ..., was_suppressed_by_rule: Some(rule_id), was_suppressed_by_dnd: false }`. Fügt ggf. zu `history` hinzu, wenn `final_notification.transient == false`. `Ok(final_notification.id)`.
    4. `let mut final_notification = allowed_notification_from_rules;`
    5. Prüft DND-Status (`self.settings_service.get_setting(SettingPath::Notifications(DndEnabledPath))`).
    6. Wenn DND aktiv und `final_notification.urgency < Critical`:
        - Sendet `NotificationPostedEvent { ..., was_suppressed_by_dnd: true, was_suppressed_by_rule: None }`.
        - Fügt ggf. zu `history` hinzu. `Ok(final_notification.id)`.
    7. Sonst (nicht unterdrückt):
        - Fügt zu `active_notifications` (FIFO-Limit `max_active_popups` aus Settings beachten). Wenn ein altes Popup entfernt wird, `NotificationPopupExpiredEvent` senden und es mit `DismissReason::Expired` schließen (verschiebt es ggf. in Historie).
        - Sendet `NotificationPostedEvent { ..., was_suppressed_by_dnd: false, was_suppressed_by_rule: None }`.
        - Wenn `!final_notification.transient`, zu `history` hinzufügen (FIFO-Limit `max_history_items` aus Settings beachten).
        - `Ok(final_notification.id)`.
- **`dismiss_notification`**: Sendet `NotificationDismissedEvent`. Wenn `!notification.transient` und Grund nicht `Expired` (oder ähnliche "automatische" Gründe), füge zu `history` hinzu.

---

### Modul 4: `domain::notifications_rules`

**Zweck:** Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln.

**Referenz:** Siehe Dokument `B4 Domänenschicht.md` (Abschnitt 4.4) und vorherige Antwort.

#### 4.1. APIs (Traits)

Rust

```
// domain/src/notifications_rules/service_api.rs
use async_trait::async_trait;
use uuid::Uuid;

use crate::user_centric_services::notifications_core::types::Notification;
use crate::global_settings_and_state_management::GlobalSettingsService; // Trait

use super::types::{NotificationRuleSet, NotificationRule};
use super::errors::NotificationRulesError;

#[derive(Debug, Clone, PartialEq)]
pub enum RuleProcessingResult {
    Allow(Notification),      // Notification (ggf. modifiziert) erlauben
    Suppress { rule_id: Uuid }, // Benachrichtigung aufgrund dieser Regel-ID unterdrücken
}

#[async_trait]
pub trait NotificationRulesProvider: Send + Sync { // Moved from persistence_iface
    async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>;
    async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>;
}

#[async_trait]
pub trait NotificationRulesEngine: Send + Sync {
    async fn new(
        rules_provider: Arc<dyn NotificationRulesProvider>,
        settings_service: Arc<dyn GlobalSettingsService>, // To access global settings for conditions
    ) -> Result<Arc<Self>, NotificationRulesError> where Self: Sized;

    /// Lädt oder aktualisiert die im System verwendeten Regeln.
    async fn reload_rules(&self) -> Result<usize, NotificationRulesError>; // Returns number of loaded rules

    /// Verarbeitet eine eingehende Benachrichtigung gegen die geladenen Regeln.
    /// Kann die Benachrichtigung modifizieren oder deren Unterdrückung signalisieren.
    async fn process_notification(
        &self,
        notification: Notification, // Takes ownership to modify
    ) -> Result<RuleProcessingResult, NotificationRulesError>;

    /// Gibt die aktuell geladenen Regeln zurück (z.B. für UI zur Anzeige/Bearbeitung).
    async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>;

    /// Speichert einen neuen Satz von Regeln und lädt sie neu.
    async fn update_rules(&self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>;

    /// Reagiert auf Änderungen globaler Einstellungen, die Regelbedingungen beeinflussen könnten.
    /// Wird typischerweise von einem Event-Listener auf SettingChangedEvent aufgerufen.
    async fn on_global_setting_changed(&self, /* setting_key: &SettingPath, new_value: &serde_json::Value */);
}
```

#### 4.2. Datenstrukturen

Definiert in `domain/src/notifications_rules/types.rs`.

- **`RuleConditionField`**: Erweitert um:
    - `ActionCount(ComparisonOperator, usize)` (z.B. Anzahl Aktionen ist `GreaterThan` 0).
    - `HintExistsWithValue { hint_key: String, operator: RuleConditionOperator, expected_value: RuleConditionValue }` (kombiniert `HintExists` und `HintValueIs`).
- **`RuleAction`**:
    - `SetHint(String, serde_json::Value)`: Verwendet `serde_json::Value` für Flexibilität, um direkt mit den `hints` der `Notification` zu arbeiten.
    - `SetAccentColor(Option<novade_core::types::Color>)`.
- **`NotificationRule`**: `id` ist `Uuid`. `name` hinzugefügt.

#### 4.3. Interaktionen

- Der `DefaultNotificationRulesEngine` wird einen `Arc<dyn GlobalSettingsService>` halten, um `SettingIsTrue`-Bedingungen auszuwerten.
- Der `DefaultNotificationService` wird den `NotificationRulesEngine::process_notification` aufrufen.

---

### Modul 5: `domain::window_management_policy`

**Zweck:** Definition von High-Level-Regeln für Fensterplatzierung, Tiling, Snapping, Fokus etc.

**Referenz:** Vorherige Antwort.

#### 5.1. APIs (Traits)

Rust

```
// domain/src/window_management_policy/service_api.rs
use async_trait::async_trait;
use std::collections::HashMap;
use uuid::Uuid;

use novade_core::types::{RectInt, Size, Point};
use crate::workspaces::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType}; // Corrected path
use crate::global_settings_and_state_management::GlobalSettingsService; // Corrected path

use super::types::{
    TilingMode, GapSettings, WindowSnappingPolicy, NewWindowPlacementStrategy, FocusPolicy,
    WorkspaceWindowLayout, WindowPolicyOverrides, WindowLayoutInfo, InitialWindowProperties, // New
};
use super::errors::WindowPolicyError;


#[derive(Debug, Clone, Default)]
pub struct WindowStateRequest { // Represents a client's or system's request to change state
    pub is_maximized: Option<bool>,
    pub is_fullscreen: Option<bool>,
    pub is_minimized: Option<bool>, // Minimieren ist eher eine Compositor-Aktion
    // pub new_tiling_mode: Option<TilingMode>, // Wenn Fenster individuelles Tiling anfordern könnten
}

#[derive(Debug, Clone, Default)]
pub struct WindowSizePositionRequest {
    pub position: Option<Point<i32>>, // Absolute Workspace-Koordinaten
    pub size: Option<Size<u32>>,
}


#[async_trait]
pub trait WindowManagementPolicyService: Send + Sync {
    async fn new(
        settings_service: Arc<dyn GlobalSettingsService>,
        // workspace_manager: Arc<dyn WorkspaceManagerService> // To get info about other windows/layout
    ) -> Result<Arc<Self>, WindowPolicyError> where Self: Sized;

    /// Berechnet das Layout für alle Fenster auf einem gegebenen Workspace.
    async fn calculate_workspace_layout(
        &self,
        workspace_id: WorkspaceId,
        windows_on_workspace: &[(WindowIdentifier, WindowLayoutInfo)], // Info über jedes Fenster
        available_area: RectInt, // Der für Fenster verfügbare Bereich
        workspace_current_tiling_mode: TilingMode,
        focused_window_id: Option<&WindowIdentifier>,
        window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>,
    ) -> Result<WorkspaceWindowLayout, WindowPolicyError>;

    /// Bestimmt die initiale Geometrie und den Zustand für ein neues Fenster.
    async fn get_initial_window_properties(
        &self,
        window_id: &WindowIdentifier, // Die ID des neuen Fensters
        requested_properties: &WindowLayoutInfo, // Vom Client gewünschte Start-Eigenschaften
        parent_window_id: Option<&WindowIdentifier>,
        parent_geometry: Option<RectInt>,
        target_workspace_id: WorkspaceId,
        current_layout_on_target_ws: &WorkspaceWindowLayout, // Um Überlappungen zu vermeiden
        workspace_available_area: RectInt,
        window_specific_overrides: &Option<WindowPolicyOverrides>,
    ) -> Result<InitialWindowProperties, WindowPolicyError>; // Gibt mehr als nur Geometrie zurück

    /// Berechnet ein potenzielles "Snap"-Ziel.
    async fn calculate_snap_target(
        &self,
        moving_window_id: &WindowIdentifier,
        current_geometry: RectInt,
        other_windows_geometries: &[(&WindowIdentifier, &RectInt)], // Nur Geometrien anderer Fenster
        workspace_area: RectInt,
        // Snapping-Policy und Gaps werden intern vom Service über GlobalSettings geholt
    ) -> Option<RectInt>; // Option, da nicht immer ein Snap-Ziel existiert

    // Methoden zum Abrufen der effektiven Policies
    async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>;
    async fn get_effective_gap_settings(&self) -> Result<GapSettings, WindowPolicyError>; // Global oder pro WS
    async fn get_effective_snapping_policy(&self) -> Result<WindowSnappingPolicy, WindowPolicyError>;
    async fn get_effective_focus_policy(&self) -> Result<FocusPolicy, WindowPolicyError>;
    async fn get_effective_new_window_placement_strategy(&self) -> Result<NewWindowPlacementStrategy, WindowPolicyError>;

    /// Entscheidet, ob eine angeforderte Zustandsänderung für ein Fenster erlaubt ist und
    /// wie sie ggf. modifiziert wird (z.B. Tiling vs. Floating bei Maximierungsanfrage).
    async fn determine_target_state_for_request(
        &self,
        window_id: &WindowIdentifier,
        current_geometry: RectInt,
        current_xdg_state: &smithay::wayland::shell::xdg::ToplevelState, // Vom Compositor
        requested_state_change: &WindowStateRequest,
        workspace_id: WorkspaceId,
        workspace_tiling_mode: TilingMode,
        workspace_available_area: RectInt,
        window_overrides: &Option<WindowPolicyOverrides>,
    ) -> Result<(RectInt, smithay::wayland::shell::xdg::ToplevelState), WindowPolicyError>; // Ziel-Geometrie und XDG-Status

    /// Entscheidet, ob eine angeforderte Größen-/Positionsänderung erlaubt ist und wie sie modifiziert wird.
    async fn determine_target_geometry_for_request(
         &self,
        window_id: &WindowIdentifier,
        current_geometry: RectInt,
        requested_change: &WindowSizePositionRequest, // Enthält neue Pos/Size
        workspace_id: WorkspaceId,
        workspace_tiling_mode: TilingMode,
        workspace_available_area: RectInt,
        window_overrides: &Option<WindowPolicyOverrides>,
        // Evtl. Infos über andere Fenster für Kollisionsvermeidung
    ) -> Result<RectInt, WindowPolicyError>; // Nur die Ziel-Geometrie
}
```

##### Datenstrukturen

- **`InitialWindowProperties`** (Neu in `types.rs`):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq)]
    pub struct InitialWindowProperties {
        pub geometry: RectInt,
        pub focus_on_creation: bool, // Soll das Fenster sofort Fokus bekommen?
        pub assigned_workspace_id: WorkspaceId, // Auf welchem Workspace es platziert wird
        pub initial_xdg_state: smithay::wayland::shell::xdg::ToplevelState, // z.B. Maximized, Activated
    }
    ```
    
- **`WindowLayoutInfo`**: Enthält nun auch `is_dialog_or_utility: bool`, `prefers_floating: bool` (Hinweise vom Client/Systemschicht).
    
- **`WindowPolicyOverrides`**: `min_size_override`, `max_size_override` verwenden `novade_core::types::Size<u32>`.
    

---

Diese Verfeinerungen und detaillierten API-Signaturen, Datenstrukturen, Event-Payloads und Fehler-Enums für die Domänenschicht bilden eine solide Grundlage für die Implementierung. Der Schlüssel ist die klare Trennung der Verantwortlichkeiten und die präzise Definition der Schnittstellen zwischen den Modulen und zu den umgebenden Schichten. Als Nächstes würde die Systemschicht-Spezifikation mit einer ähnlichen Detailtiefe für die Wayland/Smithay-Integration folgen.

Abschließend zur Domänenschicht:

**Zusammenfassende Implementierungsschritte für die gesamte Domänenschicht:**

1. **Projekt-Setup:** Erstellen Sie das `novade-domain` Crate mit den definierten Abhängigkeiten in `Cargo.toml`.
2. **Modulstruktur anlegen:** Erstellen Sie die Verzeichnisstruktur für alle spezifizierten Hauptmodule (`shared_types`, `common_events`, `theming`, `global_settings_and_state_management`, `workspaces`, `window_management_policy`, `user_centric_services`, `notifications_rules`) und deren jeweilige Untermodule (`types.rs`, `errors.rs`, `service_api.rs`, `service_impl.rs` (oder `engine.rs`), `persistence_iface.rs`, `persistence.rs` etc.).
3. **`shared_types.rs` und `common_events.rs` implementieren:** Definieren und testen Sie diese grundlegenden, modulübergreifenden Typen zuerst.
4. **Implementierung jedes Hauptmoduls (iterativ):**
    - **`types.rs`**: Alle öffentlichen und internen Datenstrukturen und Enums mit `serde`-Attributen, `Default`-Implementierungen und ggf. Validierungslogik oder Hilfsmethoden definieren. Unit-Tests für Serialisierung, Deserialisierung und Defaults.
    - **`errors.rs`**: Das modulspezifische Fehler-Enum mit `thiserror`, allen Varianten, `#[error(...)]`-Nachrichten und `#[source]` / `#[from]`-Annotationen definieren. Unit-Tests für Fehlerdarstellung.
    - **`persistence_iface.rs` (falls zutreffend):** Den oder die Provider-Trait(s) für die Persistenzlogik definieren.
    - **`persistence.rs` (intern, falls zutreffend):** Die konkrete(n) Implementierung(en) des Provider-Traits erstellen (z.B. `Filesystem...Provider`), die `Arc<dyn novade_core::config::ConfigServiceAsync>` für Dateizugriffe nutzen. Unit-Tests mit Mocking für den `ConfigServiceAsync`.
    - **`service_api.rs` (oder im Modul-`mod.rs`):** Den öffentlichen Service-Trait (z.B. `ThemingEngineService`, `WorkspaceManagerService`) mit allen `async` Methoden definieren. Die zugehörigen Event-Strukturen (oder ein gemeinsames Event-Enum für das Modul) hier oder in einem separaten `events.rs` definieren.
    - **`service_impl.rs` (oder `engine.rs`, Modul-`mod.rs`):** Die konkrete Service-Implementierung (z.B. `DefaultThemingEngineService`) erstellen.
        - Die Struktur mit ihren Feldern für internen Zustand (`Arc<tokio::sync::RwLock<...>>` oder `Arc<tokio::sync::Mutex<...>>`) und Abhängigkeiten (andere Domänenservices, Provider, `tokio::sync::broadcast::Sender`) definieren.
        - Den `new(...)`-Konstruktor implementieren, der Abhängigkeiten injiziert, initiale Zustände lädt (asynchron via Provider) und den `broadcast::Sender` initialisiert.
        - Alle Methoden des Service-Traits `async` implementieren. Dabei die spezifizierte Logik, Fehlerbehandlung und Event-Auslösung beachten.
        - Umfassende Unit-Tests für jede Methode schreiben, inklusive aller Erfolgs- und Fehlerpfade. Abhängigkeiten (andere Services, Provider) mocken. Die korrekte Verwendung von `RwLock`/`Mutex` und die Logik des Event-Versands testen.
    - **Modul-`mod.rs`**: Alle internen Submodule (`use crate::...`) deklarieren und die öffentliche API des Moduls (Service-Trait, wichtige öffentliche Typen, Fehler-Enum, Event-Typen) re-exportieren.
5. **`novade-domain/src/lib.rs` pflegen:** Alle öffentlichen Module der Domänenschicht deklarieren und die wichtigsten Service-Traits, Fehler-Enums und Event-Typen für die Nutzung durch andere Crates (Systemschicht, UI-Schicht) re-exportieren. Optional eine übergeordnete `initialize_domain_layer`-Funktion und `DomainServices`-Struktur für eine gebündelte Initialisierung bereitstellen.
6. **Kontinuierliche Integration und Testen:** Stellen Sie sicher, dass `rustfmt` und `clippy` regelmäßig ausgeführt werden und alle Tests (inklusive neuer Tests für hinzugefügte Funktionalität) in einer CI-Pipeline laufen.

Durch die konsequente Befolgung dieser Schritte und der detaillierten Spezifikationen für jedes Modul wird eine robuste, wartbare und gut strukturierte Domänenschicht für NovaDE entstehen.

---

Als Nächstes folgt die Spezifikation der **Systemschicht** mit Fokus auf die Wayland/Smithay-Integration.

## NovaDE: Spezifikation und Implementierungsleitfaden – Systemschicht

Dieser Leitfaden beschreibt die Architektur, APIs, Datenstrukturen und Interaktionen der Systemschicht (Crate: `novade-system`). Diese Schicht ist verantwortlich für die Interaktion mit dem Betriebssystem, der Hardware und externen Diensten. Sie implementiert die "Mechanik" der Desktop-Umgebung, die von der Domänenschicht definiert wird.

**Allgemeine Prinzipien der Systemschicht:**

- **Sprache:** Rust (Edition 2021+).
- **Abstraktion:** Abstrahiert Low-Level-Systemdetails und stellt klar definierte Schnittstellen für die UI-Schicht und ggf. für Rückmeldungen an die Domänenschicht bereit.
- **Technologie-Integration:** Nutzt Bibliotheken wie Smithay (Wayland Compositor), `libinput-rs` (Eingabe), `zbus` (D-Bus), `pipewire-rs` (Audio), `mcp_client_rs` (KI-Protokoll).
- **Asynchronität:** Viele Operationen sind inhärent asynchron (Event-Loops für Wayland und D-Bus, I/O). `calloop` wird oft von Smithay für die Wayland-Ereignisschleife verwendet. `tokio` kann für `zbus` und andere asynchrone Aufgaben genutzt werden. Die Integration verschiedener Event-Loops/Runtimes muss sorgfältig gehandhabt werden (z.B. über `calloop::channel` oder spezielle Adapter).
- **Fehlerbehandlung:** `thiserror` für modulspezifische Fehler. Fehler aus externen Bibliotheken oder der Domänenschicht werden gewrappt.
- **Events:** Nutzt das `system::event_bridge`-Modul für die systeminterne Event-Kommunikation und um relevante Systemereignisse an die Domänen- oder UI-Schicht weiterzuleiten.

---

### Modulübersicht der Systemschicht (`system::*`)

Basierend auf der bestehenden Dokumentation (`3. System-Details.md`):

1. **`system::compositor`**: Wayland-Compositor-Logik (Smithay-basiert).
    - `core`: Zentrale `DesktopState`-Definition, Basis-Handler.
    - `surface_management`: Verwaltung von `WlSurface`-bezogenen Daten.
    - `shm`, `xdg_shell`, `layer_shell`, `decoration`, `output_management`, `input_method`, `screencopy`, `data_device`, `xwayland`.
    - `renderer_interface`, `drm_gbm_renderer`, `winit_renderer`.
2. **`system::input`**: Eingabeverarbeitung (`libinput-rs`-basiert).
    - `seat_manager`, `libinput_handler`, `keyboard`, `pointer`, `touch`, `gestures`.
3. **`system::dbus_interfaces`**: Schnittstellen zu System-D-Bus-Diensten und Bereitstellung eigener.
    - `common` (ConnectionManager, Fehler).
    - `upower_client`, `logind_client`, `network_manager_client`, `notifications_server`, `secrets_service_client`, `policykit_client`.
    - `xdg_desktop_portal_backend_logic` (umbenannt von `xdg_desktop_portal_handler` für Klarheit, da es die Logik HINTER dem Portal-D-Bus-Server ist).
4. **`system::audio_management`**: PipeWire-Client-Integration.
    - `types`, `errors`, `client` (mit `pipewire_listener`).
5. **`system::mcp_client`**: Implementierung des Model Context Protocol Clients.
    - `types`, `errors`, `connection_manager`, `service` (implementiert `SystemMcpService`-Trait).
6. **`system::window_mechanics`**: Technische Umsetzung des Fenstermanagements.
    - `types`, `errors`, `layout_applier`, `interactive_ops`, `focus_manager`.
7. **`system::power_management`**: DPMS, Interaktion mit logind für Suspend/Hibernate.
    - `types`, `errors`, `service` (mit `PowerManagementControl`-Trait).
8. **`system::event_bridge`**: Zentrale Event-Verteilung für System-interne und System-zu-Domäne Events.

---

### Modul 1: `system::compositor`

**Zweck:** Implementierung des Wayland-Compositors unter Verwendung des Smithay-Toolkits.

**Referenz:** Siehe Dokument `C1 System Implementierungsplan.md` für eine bereits sehr detaillierte Ausarbeitung. Die folgenden Punkte ergänzen/verfeinern diese.

#### 1.1. `system::compositor::core`

##### `DesktopState` Struktur (Verfeinerungen)

- **Renderer-Integration:**
    - `pub renderer: Option<Arc<Mutex<Gles2Renderer>>>` (oder ein anderer Renderer-Typ, der den `FrameRenderer`-Trait implementiert). `Option`, da der Renderer ggf. erst nach Backend-Initialisierung verfügbar ist. `Arc<Mutex<>>` für geteilten, veränderlichen Zugriff.
    - `pub damage_tracker: Option<Arc<Mutex<smithay::backend::renderer::damage::OutputDamageTracker>>>` (Smithay's Damage-Tracking).
- **Domain Service Handles:**
    - `pub window_management_policy_service: Arc<dyn domain::window_management_policy::WindowManagementPolicyService>`
    - `pub workspace_manager_service: Arc<dyn domain::workspaces::WorkspaceManagerService>`
    - `pub global_settings_service: Arc<dyn domain::global_settings_and_state_management::GlobalSettingsService>`
    - `pub system_event_bridge: Arc<crate::event_bridge::SystemEventBridge>` (für interne Events)
- **XWayland Integration:**
    - `pub xwayland_handle: Option<smithay::xwayland::XWaylandHandle>`
    - `pub xwm: Option<Arc<Mutex<smithay::xwayland::xwm::X11Wm>>>` (Der X11 Window Manager für XWayland-Fenster).
- **Wichtige Smithay-Zustände (mit `Arc<Mutex<>>` für Handler-Methoden, die `&self` nehmen):**
    - `compositor_state: CompositorState` (oft direkt, da Handler `&mut self` nehmen)
    - `shm_state: ShmState`
    - `xdg_shell_state: XdgShellState`
    - `seat_state: SeatState<Self>`
    - `output_manager_state: OutputManagerState`
    - `data_device_state: DataDeviceState`
    - `layer_shell_state: WlrLayerShellState` (für `wlr-layer-shell`)
    - `kde_decoration_state: KdeDecorationManagerState` (für `kde-server-decoration`) oder `xdg_decoration_state: XdgDecorationState` (für `xdg-decoration`)
    - Weitere Protokoll-States...
- **Fenster-Tracking:**
    - `pub space: Space<ManagedWindow>` (Smithay's `Space` für Layout und Rendering von `ManagedWindow`-Elementen).
    - `pub windows_map: HashMap<WindowIdentifier /* domain::WindowIdentifier */, ManagedWindowIdentifier /* compositor-intern */>`
    - `ManagedWindowIdentifier` könnte `usize` (von `Window::id()`) oder `WlSurface` sein, um schnell auf das `ManagedWindow`-Objekt im `Space` zugreifen zu können.
- **Aktive Operationen:**
    - `pub current_interactive_op: Option<crate::window_mechanics::types::InteractiveOpState>` (Für Move/Resize).
- **Initialisierung von `wayland_globals`**: Im `DesktopState::new` oder einer dedizierten Funktion werden die Globals (`WlCompositor`, `WlShm`, `XdgWmBase` etc.) mit `display_handle.create_global(...)` erstellt und deren `GlobalId`s in `NovaDEWaylandState` gespeichert. Die `ClientData` für den `DisplayHandle` wird ebenfalls initialisiert.

##### `CompositorHandler` für `DesktopState`

- **`commit(&mut self, surface: &WlSurface)`**:
    1. Ruft `smithay::wayland::compositor::dispatch_client_compositor_updates(surface, self)` auf, um Puffer- und Rollenänderungen intern zu verarbeiten.
    2. Ruft `SurfaceData` ab: `let surface_data_guard = SurfaceData::from_wl(surface).unwrap();`
    3. **Schadensverfolgung:**
        - `surface_data_guard.damage_from_client(surface_attributes.damage.clone());` (Schaden in Pufferkoordinaten speichern).
    4. **Fenster-Rendering aktualisieren:**
        - Finde das zugehörige `ManagedWindow` im `self.space`.
        - `self.space.damage_element(window_ref, Option<surface_local_damage>, Option<initial_damage_screen_coords>);` (Smithay's API hierfür genau prüfen).
    5. **Subsurface-Synchronisation:** Wenn `surface.is_sync_subsurface()`, werden Commits von synchronisierten Subsurfaces zurückgehalten, bis die Elternoberfläche committet. Smithay's `CompositorState` und `SurfaceData` (`current_pre_commit_buffer`, `current_post_commit_buffer`) helfen hier. `smithay::desktop::utils::commit_surfaces_upwards` oder `commit_surfaces_downwards` kann verwendet werden.
- **`new_surface(&mut self, surface: Resource<WlSurface>, client_data: &Arc<ClientCompositorData>)`**:
    1. `SurfaceData::new()` erstellen und in `surface.data_map().insert_if_missing_threadsafe(...)` speichern.
    2. `add_destruction_hook(&surface, |data_map: &UserDataMap| { ... SurfaceData und zugehörige Ressourcen (Renderer-Texturen) bereinigen ... });`

#### 1.2. `system::compositor::xdg_shell`

##### `XdgShellHandler` für `DesktopState`

- **`new_toplevel(&mut self, surface: ToplevelSurface)`**:
    1. `domain_window_id = WindowIdentifier::new_v4();` (aus Domäne oder hier generiert und Domäne benachrichtigt).
    2. Rufe `self.workspace_manager_service.handle_new_system_window(domain_window_id, initial_props_from_client).await;` (aus Domäne). Dies sollte Workspace-Zuweisung und initiale Policy-Anwendung beinhalten.
    3. Die Domäne gibt über ein Event oder direkten Rückgabewert (schwieriger mit `async` in Handler) die `InitialWindowProperties` zurück (inkl. Geometrie, initialer XDG-Zustand).
    4. Erstelle `ManagedWindow::new_toplevel(surface.clone(), domain_window_id, initial_properties)`.
    5. Füge `XdgToplevelSurfaceData::new()` zur `surface.wl_surface().data_map()`.
    6. Sende initiale Konfiguration: `surface.send_configure(initial_xdg_state_vec, Some(initial_geometry.size));`
    7. Füge `managed_window` zu `self.space.map_window(...)` und `self.windows_map` hinzu.
    8. Wenn `initial_properties.focus_on_creation`, rufe Fokuslogik auf.
- **`new_popup(&mut self, surface: PopupSurface, _client_data: &XdgWmBaseClientData)`**:
    1. Eltern-`ManagedWindow` finden.
    2. `initial_geom = self.window_management_policy_service.get_initial_popup_geometry(parent_geom, surface.get_positioner()).await;`
    3. `ManagedWindow::new_popup(...)` erstellen, zu `space`/`windows_map` hinzufügen.
    4. `surface.send_configure(initial_geom);`
- **`map_toplevel(&mut self, surface: &ToplevelSurface)`**:
    1. Finde `ManagedWindow`. Setze `is_mapped = true`.
    2. Rufe `self.window_management_policy_service.apply_layout_for_workspace(...)` auf, um das Layout des betroffenen Workspace neu zu berechnen (oder `handle_window_mapped` in der Policy).
    3. Sende `system_event_bridge.publish(WindowMappedEvent { ... });`
- **`ack_configure(&mut self, surface: Resource<WlSurface>, configure: XdgSurfaceConfigure)`**:
    1. `smithay::desktop::utils::handle_ack_configure(&configure, &surface, &mut self.space, ...)` kann hier nützlich sein.
    2. Validiere `configure.serial`.
    3. Wenn die Konfiguration eine Größenänderung war, die vom Compositor initiiert wurde (z.B. durch Tiling), und der Client sie bestätigt hat, ist der Zustand konsistent.
    4. Wenn der Client eine neue Größe/Zustand anfordert, der von der letzten `configure`-Nachricht abweicht, muss die Policy ggf. erneut konsultiert werden.
- **`*_request_*` Methoden (z.B. `toplevel_request_set_maximized`, `move_request`, `resize_request`):**
    1. Finde `ManagedWindow`.
    2. Für `move_request`/`resize_request`:
        - Erstelle `InteractiveOpState` in `self.current_interactive_op`.
        - `self.seat.start_pointer_grab(client_seat, &surface_that_requested_grab, serial, PointerMoveResizeGrab::new(op_state, self.window_management_policy_service.clone(), self.system_event_bridge.clone()));`
    3. Für Zustandsänderungen (`set_maximized`, etc.):
        - Rufe `self.window_management_policy_service.determine_target_state_for_request(...)` auf.
        - Das Ergebnis (`target_geometry`, `target_xdg_state`) wird verwendet, um `surface.send_configure(...)` aufzurufen.
        - Aktualisiere `ManagedWindow.current_geometry` und interne Zustände.
        - `self.space.damage_window(...)`.
- **`toplevel_destroyed`, `popup_destroyed`**: Fenster aus `space` und `windows_map` entfernen. `self.workspace_manager_service.handle_system_window_closed(...)` aufrufen.

##### `PointerMoveResizeGrab` (Implementierung von `PointerGrab<DesktopState>`)

- **`motion(...)`**:
    1. Berechne neue Geometrie (`new_geom`) basierend auf `op_state.initial_window_geometry`, `event.location() - op_state.start_pointer_pos_global` und `op_state.op_type`.
    2. Rufe `self.window_policy_service.calculate_snap_target(..., new_geom, ...).await` auf. Wenn Some, verwende Snap-Ziel.
    3. Prüfe Min/Max-Größen aus `op_state.initial_window_size_constraints`.
    4. **Visuelles Feedback (ohne Configure an Client):**
        - `op_state.window_arc.current_geometry = clamped_snapped_geom;` (Aktualisiere nur die interne Repräsentation).
        - `self.desktop_state_accessor().lock().unwrap().space.damage_window(&op_state.window_arc, old_geom_for_damage, new_geom_for_damage);` (Schaden für alte und neue Position/Größe).
- **`button(...)`**:
    1. Wenn Maustaste losgelassen (`event.state == Released`):
        - `final_geometry = op_state.window_arc.current_geometry;`
        - Sende `configure` an Client mit `final_geometry` und dem aktuellen XDG-Zustand.
        - `pointer_handle.unset_grab(serial, time);`
        - `self.desktop_state_accessor().lock().unwrap().current_interactive_op = None;`
        - `self.system_event_bridge.publish(InteractiveOpEnded { ... final_geometry ... });`

#### 1.3. Integration mit der Domänenschicht

- **Fenstererstellung:**
    1. `XdgShellHandler::new_toplevel` empfängt Wayland-Anfrage.
    2. Ruft `workspace_manager_service.handle_new_system_window(window_id_compositor, client_hints)` auf.
    3. `WorkspaceManagerService` (Domäne):
        - Entscheidet (ggf. mit `WindowManagementPolicyService`), welchem Workspace das Fenster zugeordnet wird.
        - Sendet `WorkspaceEvent::WindowAddedToWorkspace`.
    4. `WindowManagementPolicyService` (Domäne):
        - Berechnet `InitialWindowProperties` (Geometrie, initialer XDG-Zustand, Fokus).
    5. `XdgShellHandler::new_toplevel` (zurück im Compositor):
        - Nimmt `InitialWindowProperties`.
        - Erstellt `ManagedWindow`, fügt zu `Space` hinzu.
        - Sendet `configure` an Wayland-Client.
- **Fokuswechsel (durch Benutzerklick in UI initiiert):**
    1. UI-Schicht -> `system::input::seat_manager::set_keyboard_focus(target_window_domain_id)`.
    2. `system::input` -> `system::window_mechanics::focus_manager::set_application_focus(target_window_domain_id)`.
    3. `set_application_focus` (System):
        - Findet `ManagedWindow` für `target_window_domain_id`.
        - Ruft `smithay::input::KeyboardHandle::set_focus(Some(target_wl_surface), serial)`.
        - Setzt `XDG_TOPLEVEL_STATE_ACTIVATED` für neues Fenster, entfernt für altes, sendet `configure`.
        - Informiert `workspace_manager_service.notify_focus_changed(target_window_domain_id)` (Domäne).
- **Layout-Änderung (durch Workspace oder Policy initiiert):**
    1. `WorkspaceManagerService` (Domäne) ändert `Workspace.layout_type` oder empfängt eine Policy-Änderung.
    2. `WorkspaceManagerService` ruft `window_management_policy_service.calculate_workspace_layout(...)` auf.
    3. Das Ergebnis (`WorkspaceWindowLayout`) wird als Event (`WorkspaceLayoutApplied`) publiziert.
    4. `system::window_mechanics::layout_applier` (System) empfängt dieses Event (oder wird direkt von Domäne/anderem Systemteil aufgerufen).
    5. `layout_applier` iteriert über die Geometrien im `WorkspaceWindowLayout`:
        - Findet `ManagedWindow`s im `DesktopState::space`.
        - Sendet `configure`-Events an die Wayland-Clients mit den neuen Geometrien/Zuständen.
        - Aktualisiert `ManagedWindow.current_geometry` und `DesktopState::space`.

#### 1.4. Wayland-Protokolle und Smithay-Typen

- **`xdg-shell`**:
    - `XdgShellState`, `XdgShellHandler` (in `DesktopState` implementiert).
    - `ToplevelSurface`, `PopupSurface` (Smithay-Typen, gewrappt in `ManagedWindow`).
    - `XdgToplevelSurfaceData`, `XdgPopupSurfaceData` (in `WlSurface::data_map()` für Zustände wie `min_size`, `max_size`, `parent`, `app_id`, `title`).
    - `PositionerState` für Popups.
- **`wlr-layer-shell-unstable-v1`**:
    - `WlrLayerShellState`, `LayerShellHandler` (in `DesktopState` implementiert).
    - `LayerSurfaceData` (in `WlSurface::data_map()`).
    - `LayerSurface` (Smithay-Typ, kann in `ManagedWindow` oder eine separate Struktur gewrappt werden).
    - Verwaltung von Layern (Background, Bottom, Top, Overlay) und Ankern.
- **`wlr-output-management-unstable-v1`**:
    - `OutputManagerState` (Teil von `DesktopState.output_manager_state`, welches `smithay::wayland::output::OutputManagerState` ist).
    - Die Handler (`GlobalDispatch`, `Dispatch` für `ZwlrOutputManagerV1`, `ZwlrOutputHeadV1`, `ZwlrOutputModeV1`, `ZwlrOutputConfigurationV1`) werden typischerweise von `DesktopState` oder einer dedizierten `OutputManagementLogic`-Struktur implementiert.
    - Interaktion mit `smithay::output::Output`-Objekten, die im `DesktopState.space` oder einer separaten Liste verwaltet werden.
- **`DisplayHandle`**:
    - Wird zum Erstellen von Globals (`create_global()`) und zum Verwalten von Clients (`dispatch_clients()`, `flush_clients()`) verwendet. Ist Teil von `DesktopState`.
- **`CompositorState`**:
    - Verwaltet `wl_compositor` und `wl_subcompositor` Globals.
    - `SurfaceAttributes` (in `WlSurface::data_map()` via `SurfaceCachedState`) hält Puffer, Skalierung, Transformation, Schaden.
- **Allgemeine Hinweise zu Smithay:**
    - **UserDataMap**: Jedes Wayland-Objekt (`WlSurface`, `WlSeat`, Protokoll-Objekte) hat eine `UserDataMap`, um anwendungsspezifische Daten zu speichern (z.B. `SurfaceData`, `XdgToplevelSurfaceData`).
    - **Handler-Traits**: Die Logik des Compositors wird durch Implementierung der Handler-Traits von Smithay (z.B. `CompositorHandler`, `XdgShellHandler`, `SeatHandler`) in `DesktopState` definiert.
    - **Ereignisschleife (`calloop`):** Wayland-Events, libinput-Events und Timer werden in einer `calloop`-Ereignisschleife verarbeitet. `DisplayHandle::dispatch_clients(&mut desktop_state)` wird im Callback für Wayland-FDs aufgerufen.

#### 1.5. Fehlerbehandlung

- **`CompositorError`** (aus `system::compositor::errors`):
    - Spezifische Varianten für Fehler bei der Globalerstellung, Rollenzuweisung, Oberflächen-Handling, Renderer-Initialisierung, XWayland-Probleme.
    - Wrappt Fehler von Smithay (z.B. `SurfaceRoleError`, `smithay::backend::renderer::RendererError`).
- Fehler aus der Domänenschicht (z.B. `WindowPolicyError`, `WorkspaceManagerError`) werden von der Systemschicht ggf. abgefangen, geloggt und in einen `CompositorError` oder einen anderen Systemfehler umgewandelt, falls die UI eine generische Fehlermeldung erhalten soll.

---

**Nächste Schritte für die Spezifikation der Systemschicht:**

Die Module `system::input`, `system::dbus_interfaces`, `system::audio_management` usw. würden mit ähnlicher Detailtiefe spezifiziert, wobei immer die Interaktion mit den relevanten externen Bibliotheken (libinput, zbus, pipewire-rs), den Smithay-Abstraktionen (falls zutreffend) und der Domänenschicht im Vordergrund steht.

**Beispiel für `system::input` (Kurzform):**

- **`LibinputInputBackend`**: Initialisierung mit einer `Session` (z.B. `LogindSession` für DRM oder eine Dummy-Session für Winit).
- **`SeatHandler` in `DesktopState`**:
    - `keyboard_focus`, `pointer_focus`, `touch_focus` verwalten.
    - `cursor_image`: Setzt `DesktopState.current_cursor_status` (Smithay-Typ), der vom Renderer verwendet wird. Für thematisierte Cursor Interaktion mit `domain::theming` (oder einer Cursor-Theming-Lib).
- **Event-Verarbeitung im `calloop`-Callback für libinput-FD:**
    - `InputEvent` von `LibinputInputBackend.dispatch_input()`.
    - `KeyboardKeyEvent`:
        - `XkbKeyboardData` (aus `DesktopState.keyboard_data_map`) verwenden.
        - `xkbcommon::State::update_key()`.
        - `smithay::input::KeyboardHandle::input()` und `modifiers()` aufrufen, um Wayland-Events an Client zu senden.
        - Tastenwiederholung mit `calloop::Timer`.
    - `PointerMotionEvent`:
        - `DesktopState.pointer_location` aktualisieren.
        - `smithay::desktop::utils::surface_under_pointer()` oder äquivalente Logik mit `DesktopState.space` verwenden, um Ziel-Surface zu finden.
        - `smithay::input::PointerHandle::motion()` aufrufen (sendet `enter`/`leave`/`motion`).
    - `PointerButtonEvent`:
        - `PointerHandle::button()`.
        - Fokuslogik auslösen: `system::window_mechanics::focus_manager::set_application_focus(...)`.
        - Wenn auf Fensterdekoration oder spezifischen Bereich geklickt: Interaktive Operation starten (`system::window_mechanics::interactive_ops::start_interactive_move(...)`).

Diese detaillierte Vorgehensweise stellt sicher, dass alle Aspekte der Integration und Logik klar definiert sind, bevor die eigentliche Implementierung beginnt.

### Protokoll-Implementierungen (D-Bus, XDG Desktop Portals, MCP)

#### 1. D-Bus (`system::dbus_interfaces`)

- **Spezifikation:** Siehe vorherige Antwort für `system::dbus_interfaces` und dessen Submodule (`common`, `upower_client`, `logind_client`, `network_manager_client`, `notifications_server`, `secrets_service_client`, `policykit_client`, `xdg_desktop_portal_backend_logic`).
- **Integration in Domänen-/Systemschichten:**
    - **Clients (z.B. `UPowerClientService`):**
        1. Werden typischerweise als Teil des `DesktopState` oder als separate, langlebige `tokio::task`s initialisiert.
        2. Nutzen den `DBusConnectionManager` für die `Arc<zbus::Connection>`.
        3. Erstellen Proxies für die Ziel-D-Bus-Interfaces.
        4. **Methodenaufrufe:** Öffentliche Methoden des Service-Wrappers (z.B. `UPowerClientService::is_on_battery()`) rufen asynchron Methoden auf dem `zbus`-Proxy auf. Fehler (`zbus::Error` oder `zbus::fdo::Error`) werden in den modulspezifischen `DBusInterfaceError` umgewandelt.
        5. **Signal-Handling:**
            - Beim Initialisieren (`initialize_and_listen()`) wird ein `tokio::task` gestartet, der `proxy.receive_my_signal().await?` in einer Schleife aufruft.
            - Empfangene Signale werden in interne System-Events (via `SystemEventBridge`) oder direkte Aufrufe an Domänenservices übersetzt. Beispiel: `UPowerProxy::PropertiesChanged` für `LidIsClosed` wird zu `SystemEventBridge::publish(SystemLayerEvent::Logind(LogindEvent::LidStateChanged{is_closed}))`.
    - **Server (z.B. `FreedesktopNotificationsServer`):**
        1. Wird als D-Bus-Objekt mit `#[dbus_interface(...)]` implementiert.
        2. Nimmt eine Referenz (`Arc<Mutex<dyn domain::user_centric_services::NotificationService>>`) auf den entsprechenden Domänenservice entgegen.
        3. D-Bus-Methodenaufrufe (z.B. `Notify`) werden an den Domänenservice delegiert.
        4. Um D-Bus-Signale zu senden (z.B. `NotificationClosed`), abonniert der D-Bus-Server-Task die entsprechenden Domänen-Events (z.B. `domain::user_centric_services::NotificationEvent::NotificationDismissed`) und sendet dann das D-Bus-Signal über den `zbus::SignalContext`.
        5. Der D-Bus-Server-Task wird beim Start von NovaDE gestartet und registriert den Dienst auf dem Session-Bus.

#### 2. XDG Desktop Portals (`system::portals` oder integriert in `system::dbus_interfaces::xdg_desktop_portal_backend_logic`)

- **Spezifikation:** Die _Backend_-Logik für Portale. Die eigentlichen D-Bus-Interfaces (`org.freedesktop.portal.FileChooser`, `Screenshot`, etc.) werden von einem separaten XDG-Desktop-Portal-Implementierungsprozess (z.B. `xdg-desktop-portal-novade`) bereitgestellt, der dann mit dieser Backend-Logik über D-Bus oder eine andere IPC kommuniziert ODER NovaDE implementiert diese Portal-D-Bus-Interfaces direkt als Teil seiner D-Bus-Services. Angesichts der Komplexität ist eine direkte Implementierung der Portal-D-Bus-Interfaces in NovaDE über `zbus` der bevorzugte Ansatz für eine engere Integration.
- **Implementierung der Portal-D-Bus-Interfaces (z.B. `org.freedesktop.portal.FileChooser`):**
    - Ein Struct (z.B. `NovaFileChooserPortal`) implementiert das D-Bus-Interface mit `#[dbus_interface(name = "org.freedesktop.portal.FileChooser")]`.
    - Benötigt Zugriff auf:
        - `system::compositor` (oder eine Abstraktion darüber): Um `parent_window` Handles zu validieren und Fensterinformationen zu erhalten.
        - UI-Schicht (indirekt): Um den nativen Dateiauswahldialog anzuzeigen. Dies geschieht typischerweise, indem der Portal-D-Bus-Handler einen Befehl an die UI-Schicht sendet (z.B. über einen dedizierten internen Mechanismus oder einen speziellen D-Bus-Aufruf an einen UI-eigenen Dienst), um den Dialog anzuzeigen. Die Antwort des Dialogs wird dann asynchron zurück an den Portal-Handler gemeldet.
    - **Methode `OpenFile(handle_token, parent_window, title, options)`:**
        1. Generiert einen eindeutigen Request-Handle für `zbus`.
        2. Sendet eine Anfrage an die UI-Schicht, einen Dateiauswahldialog mit den gegebenen Optionen anzuzeigen. Diese Anfrage enthält den Request-Handle.
        3. Gibt den D-Bus-Pfad des Request-Objekts zurück an den Portal-Client.
        4. Der Portal-Client (Anwendung) lauscht auf das `Response(u32, a{sv})`-Signal auf diesem Request-Objekt.
        5. Wenn die UI-Schicht die Auswahl des Benutzers erhält (Dateien oder Abbruch), sendet sie das Ergebnis (zusammen mit dem Request-Handle) zurück an den Portal-D-Bus-Handler.
        6. Der Portal-D-Bus-Handler sendet dann das `Response`-Signal auf dem Request-Objekt mit dem Ergebnis.
- **Integration:** Die Portal-D-Bus-Objekte werden auf dem Session-Bus registriert. Die Implementierung von `system::compositor::core::DesktopState` könnte eine Methode `get_parent_window_info(handle_string: &str) -> Option<ParentWindowDetails>` bereitstellen, die von den Portal-Handlern genutzt wird.

#### 3. Model Context Protocol (MCP) (`system::mcp_client`)

- **Spezifikation:** Siehe vorherige Antwort für `system::mcp_client` (Submodule `types`, `errors`, `connection_manager`, `service`).
- **Integration:**
    1. Der `DefaultSystemMcpService` (implementiert `SystemMcpService`-Trait) wird im `DesktopState` oder als globaler Service initialisiert.
    2. Die `server_configs: Vec<McpServerConfig>` werden von `domain::global_settings_service` geladen und an `DefaultSystemMcpService::configure_servers()` übergeben.
    3. Die Domänenschicht (`domain::user_centric_services::AIInteractionLogicService`) ruft Methoden des `SystemMcpService` auf (z.B. `call_tool`).
    4. `SystemMcpService`:
        - Nutzt den `McpConnectionManager`, um eine Verbindung zum entsprechenden `server_id` herzustellen (inkl. API-Key-Abruf via `SecretsServiceClientService`).
        - Sendet die MCP-Anfrage über die `mcp_client_rs::McpClient`-Instanz.
        - Verwendet `tokio::time::timeout` für Anfragen.
        - Verarbeitet die Antwort:
            - Erfolgreiche Antworten (`McpToolResult`) werden an den Aufrufer (Domäne) zurückgegeben und ein `McpClientSystemEvent::McpToolCallSuccessful` wird publiziert.
            - MCP-Fehlerantworten (`McpErrorResponse`) werden in `McpSystemClientError::McpServerErrorReply` umgewandelt, zurückgegeben, und ein `McpClientSystemEvent::McpRequestFailed` wird publiziert.
            - Kommunikationsfehler/Timeouts führen zu `McpSystemClientError` und `McpClientSystemEvent::McpCommunicationError`.
        - Der im `McpConnection` gestartete Task lauscht auf `client.receive_message()` für serverseitige Notifications und publiziert `McpClientSystemEvent::McpNotificationReceived`.

Diese detaillierten Integrationspläne stellen sicher, dass die Protokolle korrekt in die Schichtenarchitektur von NovaDE eingebettet werden und die Kommunikation zwischen den Komponenten klar definiert ist.

## Domänenschicht-Spezifikationen (`domain::*`)

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand von NovaDE. Sie ist unabhängig von UI-Details und direkten Systeminteraktionen.

### 1. Modul: `domain::theming`

#### 1.1. API (`ThemingEngineService` Trait)

- **Datei:** `domain/src/theming/service_api.rs`
- **Methoden (Signaturen wie in vorherigen Antworten, `async` wo zutreffend):**
    - `async fn new(...) -> Result<Arc<Self>, ThemingError>`
    - `async fn get_current_theme_state(&self) -> AppliedThemeState`
    - `async fn get_available_themes(&self) -> Vec<ThemeDefinition>`
    - `async fn get_current_configuration(&self) -> ThemingConfiguration`
    - `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
    - `async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`
    - `fn subscribe_to_theme_changes(&self) -> broadcast::Receiver<ThemeChangedEvent>`
- **Abhängigkeiten für `new()`:** `initial_config: ThemingConfiguration`, `theme_load_paths: Vec<PathBuf>`, `token_load_paths: Vec<PathBuf>`, `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`, `broadcast_capacity: usize`.

#### 1.2. Datenstrukturen (`domain::theming::types`)

- **`TokenIdentifier`**, **`TokenValue`**, **`RawToken`**, **`TokenSet`** (`BTreeMap`), **`ThemeIdentifier`**, **`ColorSchemeType`**, **`AccentColor`** (mit `novade_core::types::Color`), **`ThemeVariantDefinition`**, **`ThemeDefinition`** (mit `accentable_tokens: Option<HashMap<TokenIdentifier, AccentModificationType>>`), **`AppliedThemeState`** (mit `resolved_tokens: BTreeMap<TokenIdentifier, String>`), **`ThemingConfiguration`** (mit `selected_accent_color: Option<novade_core::types::Color>`).
- **`AccentModificationType` Enum:** `DirectReplace`, `Lighten(f32)`, `Darken(f32)`, `DesaturateAndTint(f32)`.

#### 1.3. Events (`domain::theming::service_api` oder `events.rs`)

- **`ThemeChangedEvent` Struct:** `new_state: AppliedThemeState`, `old_state: Option<AppliedThemeState>`.

#### 1.4. Fehlerbehandlung (`domain::theming::errors`)

- **`ThemingError` Enum:** Varianten für `TokenFileParseError`, `TokenFileIoError`, `InvalidTokenData`, `InvalidTokenValue`, `CyclicTokenReference`, `ThemeFileLoadError`, `ThemeFileIoError`, `InvalidThemeData`, `ThemeNotFound`, `MissingTokenReference`, `MaxReferenceDepthExceeded`, `ThemeApplicationError`, `FallbackThemeLoadError`, `InitialConfigurationError`, `InternalStateError`, `EventSubscriptionError`, `AccentColorApplicationError`, `TokenResolutionError`, `FilesystemError(#[from] novade_core::errors::CoreError)`.

#### 1.5. Interaktionen und Datenfluss

1. **Initialisierung (`ThemingEngineService::new`):**
    - Lädt globale Tokens und verfügbare Themes asynchron über den `config_service` von den `token_load_paths` und `theme_load_paths`.
    - Validiert Tokens (Zyklen) und Themes (Referenzen).
    - Berechnet den initialen `AppliedThemeState` basierend auf `initial_config` oder einem einkompilierten Fallback-Theme.
    - Initialisiert den `tokio::sync::broadcast::Sender` für `ThemeChangedEvent`.
2. **Konfigurationsupdate (`update_configuration`):**
    - Nimmt `ThemingConfiguration` entgegen.
    - Löst die Token-Resolution-Pipeline aus:
        1. Basissatz globaler Tokens.
        2. Merge mit Tokens des ausgewählten Themes (`ThemeDefinition.base_tokens`).
        3. Merge mit Tokens der passenden `ThemeVariantDefinition` (basierend auf `preferred_color_scheme`).
        4. Wendet `selected_accent_color` an (modifiziert Tokens gemäß `accentable_tokens` und `AccentModificationType`).
        5. Merge mit `custom_user_token_overrides`.
        6. Rekursive Auflösung aller `TokenValue::Reference` zu finalen String-Werten (CSS-kompatibel) mit Zyklenerkennung und Tiefenbegrenzung.
    - Erzeugt neuen `AppliedThemeState`.
    - Wenn sich der Zustand geändert hat, wird der interne Zustand aktualisiert und ein `ThemeChangedEvent` gesendet.
    - Der aufgelöste Zustand kann gecacht werden (Schlüssel: `(ThemeIdentifier, ColorSchemeType, Option<AccentColorHash>, UserOverridesHash)`).
3. **Zustandsverwaltung:** `ThemingEngineInternalState` (geschützt durch `tokio::sync::Mutex`) hält `current_config`, `available_themes`, `global_raw_tokens`, `applied_state`, Lade-Pfade, `config_service` und den Cache.

### 2. Modul: `domain::workspaces`

#### 2.1. API (`WorkspaceManagerService` Trait)

- **Datei:** `domain/src/workspaces/service_api.rs`
- **Methoden (Signaturen wie in vorherigen Antworten, `async` wo zutreffend):**
    - `async fn new(...) -> Result<Arc<Self>, WorkspaceManagerError>`
    - `async fn create_workspace(&self, params: WorkspaceCreationParams) -> Result<WorkspaceId, WorkspaceManagerError>`
    - `async fn delete_workspace(&self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>`
    - `async fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>` (gibt Klon zurück)
    - `async fn get_all_workspaces_ordered(&self) -> Vec<Workspace>` (gibt Klone zurück)
    - `async fn get_active_workspace_id(&self) -> Option<WorkspaceId>`
    - `async fn get_active_workspace(&self) -> Option<Workspace>` (gibt Klon zurück)
    - `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - `async fn assign_window_to_active_workspace(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>` (interne Logik: ruft `assignment::assign_window_to_workspace`)
    - `async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
    - `async fn move_window_to_specific_workspace(&self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `async fn get_workspace_for_window(&self, window_id: &WindowIdentifier) -> Option<WorkspaceId>`
    - `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
    - `async fn set_workspace_layout(&self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>`
    - `async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>`
    - `async fn set_workspace_accent_color(&self, id: WorkspaceId, color_hex: Option<String>) -> Result<(), WorkspaceManagerError>`
    - `async fn set_workspace_persistent_id(&self, id: WorkspaceId, persistent_id: Option<String>) -> Result<(), WorkspaceManagerError>`
    - `async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>`
    - `async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>`
    - `fn subscribe_to_workspace_events(&self) -> broadcast::Receiver<WorkspaceEvent>`
    - `async fn handle_new_system_window(&self, window_id: WindowIdentifier, initial_properties: Option<crate::window_management_policy::types::WindowLayoutInfo>) -> Result<(), WorkspaceManagerError>`
    - `async fn handle_system_window_closed(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
- **`WorkspaceConfigProvider` Trait:**
    - `async fn load_workspace_config(&self) -> Result<WorkspaceSetSnapshot, WorkspaceManagerError>` (Fehlertyp angepasst)
    - `async fn save_workspace_config(&self, config_snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceManagerError>`

#### 2.2. Datenstrukturen (`domain::workspaces::types`, `config_types.rs`)

- **`WorkspaceId`**, **`WindowIdentifier`** (mit `Result`-basiertem `new`), **`WorkspaceLayoutType`**.
- **`Workspace` Struct:** Enthält `id`, `name`, `persistent_id`, `layout_type`, `window_ids: HashSet<WindowIdentifier>`, `created_at`, `icon_name`, `accent_color_hex`. Methoden validieren Eingaben (Name, persistente ID, Hex-Farbe).
- **`WorkspaceCreationParams` Struct:** `name`, `persistent_id`, `icon_name`, `accent_color_hex`, `layout_type_hint`, `activate_when_created`.
- **`WorkspaceSnapshot` Struct:** `persistent_id`, `name`, `layout_type`, `icon_name`, `accent_color_hex`.
- **`WorkspaceSetSnapshot` Struct:** `workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`.

#### 2.3. Events (`domain::workspaces::events`)

- **`WorkspaceEvent` Enum:** Umfasst `WorkspaceCreated` (mit allen initialen Workspace-Properties), `WorkspaceDeleted`, `ActiveWorkspaceChanged`, `WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WindowAddedToWorkspace`, `WindowRemovedFromWorkspace`, `WorkspaceOrderChanged`, `WorkspacesReloaded`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`, `WorkspaceLayoutApplied` (mit `WorkspaceWindowLayout` von `window_management_policy`).

#### 2.4. Fehlerbehandlung (`domain::workspaces::core::errors`, `assignment::errors`, `config::errors`, `manager::errors`)

- **`WorkspaceCoreError`**: `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`, `WindowIdentifierEmpty`, `InvalidAccentColorFormat`.
- **`WindowAssignmentError`**: `WorkspaceNotFound`, `WindowAlreadyAssigned`, `WindowNotAssignedToWorkspace`, `SourceWorkspaceNotFound`, `TargetWorkspaceNotFound`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation`, `Internal`.
- **`WorkspaceConfigError`**: `LoadError` (wrappt `CoreConfigError`), `SaveError` (wrappt `CoreConfigError`), `InvalidData`, `SerializationError`, `DeserializationError`, `PersistentIdNotFoundInLoadedSet`, `DuplicatePersistentIdInLoadedSet`, `VersionMismatch`, `Internal`.
- **`WorkspaceManagerError`**: Wrappt `CoreError`, `AssignmentError`, `ConfigError`. Eigene Varianten: `WorkspaceNotFound`, `CannotDeleteLastWorkspace`, `DeleteRequiresFallbackForWindows`, `FallbackWorkspaceNotFound`, `SetActiveWorkspaceNotFound`, `NoActiveWorkspace`, `DuplicatePersistentId`, `Internal`.

#### 2.5. Interaktionen und Datenfluss

1. **Initialisierung (`WorkspaceManagerService::new`):**
    - Lädt Konfiguration über `WorkspaceConfigProvider` asynchron.
    - Wenn keine Konfig vorhanden oder fehlerhaft (außer "nicht gefunden"), wird ein Standard-Workspace ("Workspace 1") erstellt.
    - Rekonstruiert `Workspace`-Objekte, `ordered_workspace_ids`, `active_workspace_id`.
    - Sendet `WorkspacesReloaded` und `ActiveWorkspaceChanged`.
2. **Fensterzuweisung (`handle_new_system_window`):**
    - Ruft `domain::window_management_policy::WindowManagementPolicyService::get_initial_window_properties()` auf, um Ziel-Workspace und initiale Geometrie/Status zu bestimmen.
    - Ruft intern `domain::workspaces::assignment::assign_window_to_workspace()` mit der Policy-Entscheidung auf.
    - Sendet `WindowAddedToWorkspace`.
3. **Konfigurationsspeicherung (`save_configuration` intern nach Modifikationen):**
    - Erstellt `WorkspaceSetSnapshot` aus dem aktuellen Zustand (`ordered_workspace_ids` für Reihenfolge, `workspaces` für Details, `active_workspace_id` für aktiven).
    - Ruft `config_provider.save_workspace_config()` asynchron auf.
4. **Zustandsverwaltung:** `WorkspaceManagerInternalState` (geschützt durch `tokio::sync::Mutex`) hält `workspaces: HashMap`, `active_workspace_id`, `ordered_workspace_ids`, `config_provider`, `event_publisher`.

---

**(Die Spezifikationen für die Module 3 bis 8 der Domänenschicht würden analog detailliert, basierend auf den bereits existierenden Dokumenten und den hier etablierten Verfeinerungen.)**

---

## Wayland/Smithay-Integration (Systemschicht-Fokus)

Die Systemschicht (`novade-system`) ist primär für die Wayland-Compositor-Implementierung mit Smithay verantwortlich.

### 1. Smithay Compositor-Implementierung (`system::compositor`)

- **Kernstruktur `DesktopState` (in `system::compositor::core::state`):**
    - Implementiert alle relevanten Smithay Handler-Traits:
        - `smithay::wayland::compositor::CompositorHandler`
        - `smithay::wayland::shell::xdg::XdgShellHandler`
        - `smithay::wayland::shm::ShmHandler`, `smithay::wayland::buffer::BufferHandler`
        - `smithay::wayland::seat::SeatHandler`
        - `smithay::wayland::output::OutputHandler`
        - `smithay::wayland::selection::data_device::DataDeviceHandler`
        - `smithay::wayland::shell::wlr_layer::LayerShellHandler`
        - `smithay::wayland::decoration::xdg::XdgDecorationHandler` (oder `kde-server-decoration`)
        - Handler für `wlr-output-management-unstable-v1`, `wlr-output-power-management-unstable-v1`, `wlr-foreign-toplevel-management-unstable-v1`, etc.
    - Hält Instanzen der Smithay State-Objekte: `CompositorState`, `XdgShellState`, `ShmState`, `SeatState<Self>`, `OutputManagerState`, `DataDeviceState`, `WlrLayerShellState`, `XdgDecorationState`, etc. Diese werden im Konstruktor von `DesktopState` initialisiert.
    - Hält Handles zur Domänenschicht: `Arc<dyn WorkspaceManagerService>`, `Arc<dyn WindowManagementPolicyService>`, `Arc<dyn GlobalSettingsService>`.
    - Hält den Smithay `DisplayHandle` und `calloop::LoopHandle`.
    - Verwaltet eine `smithay::desktop::Space<ManagedWindow>` für das Fensterlayout und Rendering.
    - Verwaltet eine `HashMap<WindowIdentifier, ManagedWindowIdentifierCompositor>` für die Zuordnung von Domänen-Fenster-IDs zu Compositor-internen Fenster-Handles.
- **`ManagedWindow` Struct (in `system::compositor::xdg_shell::types` oder `surface_management`):**
    - Implementiert `smithay::desktop::Window` und `smithay::desktop::SpaceElement`.
    - Kapselt ein `smithay::wayland::shell::xdg::ToplevelSurface` oder `PopupSurface` oder `LayerSurface`.
    - Hält eine `domain::workspaces::core::types::WindowIdentifier` für die Verknüpfung zur Domäne.
    - Speichert die aktuelle Geometrie (`RectInt`), den XDG-Zustand (`ToplevelState`).
- **Wayland-Protokolle und Erweiterungen:**
    - **`xdg-shell` (Pflicht):** Für normale Anwendungsfenster. `XdgShellHandler` Methoden:
        - `new_toplevel`: Ruft `domain::WorkspaceManagerService::handle_new_system_window()` auf. Domäne liefert initiale Platzierung/Workspace via `WindowManagementPolicyService`. Compositor erstellt `ManagedWindow`, sendet `configure`.
        - `map_toplevel`: Informiert Domäne (`WorkspaceManagerService`), dass Fenster gemappt wurde. Löst Neuanordnung durch `WindowManagementPolicyService` aus.
        - `ack_configure`: Verarbeitet Client-Bestätigungen.
        - `*_request_*` (z.B. `set_title`, `set_app_id`, `set_maximized`, `move`, `resize`): Aktualisiert `ManagedWindow`-Zustand. Für Move/Resize wird ein `PointerGrab` (siehe `system::input`) gestartet; nach Abschluss wird `WindowManagementPolicyService` für finale Geometrie und Snapping konsultiert, dann `configure` gesendet. Für Zustandsänderungen wird `WindowManagementPolicyService::determine_target_state_for_request` aufgerufen.
    - **`wlr-layer-shell-unstable-v1` (Pflicht):** Für Panels, Wallpaper, Notifications. `LayerShellHandler` Methoden. Erstellt spezielle `LayerSurface`-Objekte. Domäne (z.B. `ThemingEngine` für Wallpaper, `NotificationService` für Popups) liefert Inhalt/Logik.
    - **`xdg-decoration-unstable-v1` (Server-Seite, Pflicht):** Für Fensterdekorationen. `XdgDecorationHandler`. Domäne (`ThemingEngine`, `GlobalSettingsService`) liefert Policy, ob SSD oder CSD bevorzugt wird.
    - **`wlr-output-management-unstable-v1` (Server-Seite, Pflicht):** `system::compositor::output_management` implementiert die Handler. Interagiert mit `smithay::output::Output`-Objekten (verwaltet im `DesktopState.space` oder einer Liste) und dem DRM-Backend. Domäne (`GlobalSettingsService`) liefert Standard-Output-Konfigs.
    - **Weitere Protokolle:** `wl_shm`, `wl_compositor`, `wl_subcompositor`, `wl_seat`, `wl_data_device`, `presentation-time`, `viewporter`, `linux-dmabuf-unstable-v1`, etc. werden durch entsprechende Smithay-States und Handler in `DesktopState` unterstützt.
- **Smithay `DisplayHandle` und `CompositorState`:**
    - `DisplayHandle` (in `DesktopState`): Dient zum Erstellen von Globals und Verwalten von Clients.
    - `CompositorState` (in `DesktopState`): Verwaltet `wl_compositor`, `wl_subcompositor`. `SurfaceAttributes` (via `SurfaceCachedState` an `WlSurface` UserData) halten Puffer, Skalierung, Transformation, Schaden.
- **Systemschicht empfängt Domänenbefehle:**
    - Der Compositor (über `DesktopState`) reagiert auf Events vom `SystemEventBridge` oder direkte Aufrufe von System-internen Services, die von Domänen-Events getriggert wurden.
    - **Workspace-Wechsel:** `WorkspaceEvent::ActiveWorkspaceChanged` von `WorkspaceManagerService`. `DesktopState` aktualisiert, welche Fenster im `Space` sichtbar sind, und wendet das Layout des neuen Workspace an (via `WindowManagementPolicyService` und `system::window_mechanics::layout_applier`). Sendet Fokus an das entsprechende Fenster.
    - **Fensterplatzierung:** `WorkspaceLayoutApplied`-Event von `WorkspaceManagerService`. `system::window_mechanics::layout_applier` iteriert die Geometrien und ruft `ManagedWindow.send_configure()` (oder äquivalente Methoden auf `ToplevelSurface`) für jedes Fenster auf.
- **Wayland-Ereignisse an Domänenschicht:**
    - Direkte Weiterleitung ist selten. Stattdessen:
        - Wayland-Client-Requests (z.B. `xdg_toplevel.set_title`) aktualisieren den Zustand im `ManagedWindow` (Systemschicht).
        - Wenn diese Änderung für die Domäne relevant ist (z.B. ein neues Fenster wird gemappt und muss einem Workspace zugeordnet werden), ruft die Systemschicht eine Methode des entsprechenden Domänenservice auf (z.B. `WorkspaceManagerService::handle_new_system_window`).
        - Domänen-Events werden dann von der Domänenschicht selbst ausgelöst (z.B. `WorkspaceEvent::WindowAddedToWorkspace`).

#### 1.6. Code-Skizzen und Algorithmen

- **`DesktopState::new(...)` (Initialisierung):**
    
    Rust
    
    ```
    // system/src/compositor/core/state.rs
    pub fn new(
        display_handle: DisplayHandle,
        loop_handle: LoopHandle<'static, Self>,
        // ... Domain Service Handles ...
        // ... SystemEventBridge ...
    ) -> Self {
        let clock = Clock::new(None); // No logger for brevity
    
        let compositor_state = CompositorState::new::<Self>(&display_handle, None);
        let shm_state = ShmState::new::<Self>(&display_handle, vec![], None); // No extra formats
        let xdg_shell_state = XdgShellState::new::<Self>(&display_handle, None);
        let mut seat_state = SeatState::new();
        let seat_name = "seat0".to_string();
        let seat = seat_state.new_wl_seat(&display_handle, seat_name.clone(), None);
        // ... Initialize other Smithay states (DataDeviceState, OutputManagerState, etc.) ...
        let space = Space::new(None);
    
        // Initialize all Wayland globals
        let shm_global = shm_state.global().clone();
        let xdg_shell_global = xdg_shell_state.global().clone();
        // ... create and store other global IDs ...
    
        let wayland_globals = Some(NovaDEWaylandState {
            shm_global, xdg_shell_global, /* ... */
        });
    
        Self {
            display_handle, loop_handle, clock,
            compositor_state, shm_state, xdg_shell_state, seat_state, seat, seat_name,
            space, windows_map: HashMap::new(), /* ... other fields ... */ wayland_globals,
            // ... Domain Service Handles ...
        }
    }
    ```
    
- **`XdgShellHandler::new_toplevel` (vereinfacht):**
    
    Rust
    
    ```
    // In DesktopState impl XdgShellHandler
    fn new_toplevel(&mut self, surface: ToplevelSurface) {
        let domain_window_id = WindowIdentifier::new_v4(); // Create a domain-level ID
        let client_app_id = surface.app_id(); // Get from client
        let client_title = surface.title();
    
        // Prepare initial info for domain policy
        let initial_props = WindowLayoutInfo {
            id: domain_window_id.clone(),
            requested_min_size: surface.min_size(), // And other client hints
            // ...
        };
    
        // This call needs to be carefully managed if it's async within a sync handler context.
        // Option 1: block_on (if handler context allows it, usually not ideal for event loop)
        // Option 2: Send a command to a separate tokio task that then calls the domain service
        // Option 3: Make the domain service call synchronous if it doesn't do I/O
        let initial_placement_result = block_on(
            self.workspace_manager_service.handle_new_system_window(domain_window_id.clone(), Some(initial_props))
            .then(|_| self.window_management_policy_service.get_initial_window_properties(
                &domain_window_id, /* ... other params from WorkspaceManager or client ... */
            ))
        );
    
        match initial_placement_result {
            Ok(initial_properties) => {
                let managed_window = ManagedWindow::new_toplevel(surface.clone(), domain_window_id, initial_properties.geometry);
                // Store XdgToplevelSurfaceData for this surface
                surface.wl_surface().data_map().insert_if_missing_threadsafe(XdgToplevelSurfaceData::new);
                // Configure the surface with initial state and geometry
                surface.send_configure(initial_properties.initial_xdg_state.into_abi(), Some(initial_properties.geometry.size));
    
                let window_arc = Arc::new(managed_window);
                self.windows_map.insert(domain_window_id, window_arc.id()); // Or map to WlSurface
                self.space.map_window(window_arc, initial_properties.geometry.loc, initial_properties.focus_on_creation);
    
                if initial_properties.focus_on_creation {
                    // Call internal focus logic
                    // self.set_focus_internal(Some(surface.wl_surface()), Serial::now());
                }
            }
            Err(e) => {
                tracing::error!("Failed to get initial placement for new toplevel: {:?}", e);
                // Potentially close the surface or mark it as unmanaged
                surface.send_close();
            }
        }
    }
    ```
    
- **Workspace-Wechsel (vereinfachter Datenfluss):**
    
    1. Domäne (`WorkspaceManagerService`) löst `WorkspaceEvent::ActiveWorkspaceChanged { new_id, .. }` aus.
    2. `SystemEventBridge` leitet dies weiter (oder ein direkter Listener im `DesktopState`).
    3. `DesktopState` empfängt das Event:
        - `current_layout = self.window_management_policy_service.calculate_workspace_layout(new_id, windows_on_new_ws, ...).await;`
        - `self.system_window_mechanics_apply_layout(current_layout);` (interne Methode)
    4. `system_window_mechanics_apply_layout`:
        - Iteriert `current_layout.window_geometries`.
        - Für jedes Fenster:
            - Sucht `ManagedWindow` im `self.space`.
            - `managed_window.xdg_surface.toplevel().send_configure(...)` mit neuer Geometrie/Status.
            - Aktualisiert Fenster im `self.space` (Sichtbarkeit, Position).
        - Setzt Fokus auf das zuletzt fokussierte Fenster des neuen Workspace.

---

Die Implementierung der Domänenschicht und deren Integration mit der Systemschicht ist ein komplexer Prozess, der sorgfältige Beachtung von Asynchronität, Zustandsmanagement und Fehlerbehandlung erfordert. Die hier skizzierten Spezifikationen bieten einen detaillierten Rahmen für die Entwicklung.

 Quellen
## Technische Spezifikationen und Implementierungsanleitungen: Domänenschicht NovaDE

Dieses Dokument detailliert die technischen Spezifikationen und Implementierungsanleitungen für die Domänenschicht des NovaDE-Projekts. Der Fokus liegt auf den internen APIs, Datenstrukturen, Ereignissen, der Fehlerbehandlung und der spezifischen Integration mit der Systemschicht, insbesondere dem Wayland/Smithay-basierten Compositor.

### 1. Domänenschicht-Spezifikationen

Die Domänenschicht (`novade-domain` Crate) kapselt die Kernlogik und den Zustand der Desktop-Umgebung, unabhängig von UI- oder Systemdetails. Sie ist in mehrere Module unterteilt, die jeweils spezifische Verantwortlichkeiten tragen.

#### 1.1. Modul: `domain::shared_types`

Dieses Modul definiert grundlegende, domänenspezifische Typen, die von mehreren anderen Domänenmodulen genutzt werden.

- **`ApplicationId`**: Ein typsicherer Wrapper für Anwendungsidentifikatoren.
    - **Definition:**
        
        Rust
        
        ```
        // src/domain/shared_types.rs
        use serde::{Serialize, Deserialize};
        use std::fmt;
        
        /// Eindeutiger Bezeichner für eine Anwendung.
        /// Repräsentiert typischerweise einen Reverse-DNS-Namen (z.B. "org.novade.FileExplorer")
        /// oder den Namen der .desktop-Datei ohne Erweiterung.
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default, PartialOrd, Ord)]
        pub struct ApplicationId(String);
        
        impl ApplicationId {
            /// Erstellt eine neue `ApplicationId`.
            ///
            /// # Panics
            /// Paniert, wenn die `id` leer ist (im Debug-Modus).
            pub fn new(id: impl Into<String>) -> Self {
                let id_str = id.into();
                debug_assert!(!id_str.is_empty(), "ApplicationId darf nicht leer sein.");
                // Weitere Validierungen (z.B. erlaubte Zeichen) könnten hier oder bei der Erzeugung erfolgen.
                Self(id_str)
            }
        
            /// Gibt die `ApplicationId` als String-Slice zurück.
            pub fn as_str(&self) -> &str {
                &self.0
            }
        }
        
        impl From<String> for ApplicationId {
            fn from(s: String) -> Self {
                debug_assert!(!s.is_empty(), "ApplicationId (from String) darf nicht leer sein.");
                Self(s)
            }
        }
        
        impl From<&str> for ApplicationId {
            fn from(s: &str) -> Self {
                debug_assert!(!s.is_empty(), "ApplicationId (from &str) darf nicht leer sein.");
                Self(s.to_string())
            }
        }
        
        impl fmt::Display for ApplicationId {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, "{}", self.0)
            }
        }
        ```
        
    - **Verantwortlichkeiten**: Repräsentation einer Anwendungs-ID.
    - **Invarianten**: Interner String darf nicht leer sein.
- **`UserSessionState`**: Repräsentiert den aktuellen Zustand der Benutzersitzung.
    - **Definition:**
        
        Rust
        
        ```
        // src/domain/shared_types.rs
        use serde::{Serialize, Deserialize};
        
        /// Repräsentiert den aktuellen Zustand der Benutzersitzung aus Sicht der Domäne.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
        pub enum UserSessionState {
            #[default]
            Active, // Normale Benutzersitzung, Benutzer ist aktiv
            Locked, // Sitzung gesperrt (z.B. durch Bildschirmsperre)
            Idle,   // Benutzer ist für eine definierte Zeit inaktiv
        }
        ```
        
    - **Verantwortlichkeiten**: Abstraktion des Sitzungszustands.
- **`ResourceIdentifier`**: Allgemeiner Bezeichner für eine Ressource.
    - **Definition:**
        
        Rust
        
        ```
        // src/domain/shared_types.rs
        use serde::{Serialize, Deserialize};
        use uuid::Uuid;
        
        /// Allgemeiner Bezeichner für eine Ressource.
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub struct ResourceIdentifier {
            /// Der Typ der Ressource (z.B. "file", "contact", "calendar-event", "web-url").
            pub r#type: String,
            /// Die eindeutige ID der Ressource innerhalb ihres Typs.
            pub id: String,
            /// Optionale menschenlesbare Beschreibung oder Name der Ressource.
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub label: Option<String>,
        }
        
        impl ResourceIdentifier {
            pub fn new(resource_type: impl Into<String>, resource_id: impl Into<String>, label: Option<String>) -> Self {
                let type_str = resource_type.into();
                let id_str = resource_id.into();
                debug_assert!(!type_str.is_empty(), "ResourceIdentifier type darf nicht leer sein.");
                debug_assert!(!id_str.is_empty(), "ResourceIdentifier id darf nicht leer sein.");
                Self {
                    r#type: type_str,
                    id: id_str,
                    label,
                }
            }
        
            pub fn file(path: impl Into<String>, label: Option<String>) -> Self {
                Self::new("file", path, label)
            }
        }
        ```
        
    - **Verantwortlichkeiten**: Repräsentation einer Ressource für KI-Interaktionen oder andere Dienste.
    - **Invarianten**: `r#type` und `id` dürfen nicht leer sein.

#### 1.2. Modul: `domain::common_events`

Dieses Modul definiert Event-Typen, die von mehreren Domänenmodulen ausgelöst oder konsumiert werden können.

- **`UserActivityType`**: Kategorisiert Benutzeraktivitäten.
    - **Definition:**
        
        Rust
        
        ```
        // src/domain/common_events.rs
        use serde::{Serialize, Deserialize};
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum UserActivityType {
            MouseMoved,
            MouseClicked,
            MouseWheelScrolled,
            KeyPressed,
            TouchInteraction,
            WorkspaceSwitched,
            ApplicationFocused,
            WindowOpened,
            WindowClosed,
        }
        ```
        
- **`UserActivityDetectedEvent`**: Wird ausgelöst, wenn eine Benutzeraktivität erkannt wird.
    - **Definition:**
        
        Rust
        
        ```
        // src/domain/common_events.rs
        use chrono::{DateTime, Utc};
        use serde::{Serialize, Deserialize};
        use crate::shared_types::{UserSessionState, ApplicationId}; // Pfad anpassen
        use super::UserActivityType;
        use uuid::Uuid;
        use crate::workspaces::core::types::WorkspaceId; // Pfad anpassen
        
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct UserActivityDetectedEvent {
            pub event_id: Uuid,
            pub timestamp: DateTime<Utc>,
            pub activity_type: UserActivityType,
            pub current_session_state: UserSessionState,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub active_application_id: Option<ApplicationId>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub active_workspace_id: Option<WorkspaceId>,
        }
        
        impl UserActivityDetectedEvent {
            pub fn new(
                activity_type: UserActivityType,
                current_session_state: UserSessionState,
                active_application_id: Option<ApplicationId>,
                active_workspace_id: Option<WorkspaceId>
            ) -> Self {
                Self {
                    event_id: Uuid::new_v4(),
                    timestamp: Utc::now(),
                    activity_type,
                    current_session_state,
                    active_application_id,
                    active_workspace_id,
                }
            }
        }
        ```
        
    - **Payload**: `event_id: Uuid`, `timestamp: DateTime<Utc>`, `activity_type: UserActivityType`, `current_session_state: UserSessionState`, `active_application_id: Option<ApplicationId>`, `active_workspace_id: Option<WorkspaceId>`.
    - **Publisher**: Systemschicht-Adapter für `system::input`, `domain::workspaces::manager`.
    - **Subscriber**: `domain::user_centric_services::ai_interaction`, `domain::power_management_policy`.
- **`SystemShutdownInitiatedEvent`**: Signalisiert bevorstehenden System-Shutdown/Neustart.
    - **Definition:**
        
        Rust
        
        ```
        // src/domain/common_events.rs
        use chrono::{DateTime, Utc};
        use serde::{Serialize, Deserialize};
        use uuid::Uuid;
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
        pub enum ShutdownReason {
            #[default]
            UserRequest,
            PowerButtonPress,
            LowBattery,
            SystemUpdate,
            ApplicationRequest,
            OsError,
            Unknown,
        }
        
        #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
        pub struct SystemShutdownInitiatedEvent {
            pub event_id: Uuid,
            pub timestamp: DateTime<Utc>,
            pub reason: ShutdownReason,
            pub is_reboot: bool,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub delay_seconds: Option<u32>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub message: Option<String>,
        }
        
        impl SystemShutdownInitiatedEvent {
            pub fn new(reason: ShutdownReason, is_reboot: bool, delay_seconds: Option<u32>, message: Option<String>) -> Self {
                Self {
                    event_id: Uuid::new_v4(),
                    timestamp: Utc::now(),
                    reason,
                    is_reboot,
                    delay_seconds,
                    message,
                }
            }
        }
        ```
        
    - **Payload**: `event_id: Uuid`, `timestamp: DateTime<Utc>`, `reason: ShutdownReason`, `is_reboot: bool`, `delay_seconds: Option<u32>`, `message: Option<String>`.
    - **Publisher**: Systemschicht-Adapter für `logind`.
    - **Subscriber**: Domänendienste, die Zustände speichern müssen.

#### 1.3. Modul: `domain::theming`

Verantwortlich für die Logik des Erscheinungsbilds (Theming).

- **Datenstrukturen** (in `src/theming/types.rs`):
    - `TokenIdentifier(String)`: Hierarchischer Bezeichner für Design-Tokens.
        - Invarianten: Nicht leer, nur ASCII-Alphanumerisch, Punkte, Bindestriche.
    - `TokenValue`: Enum für Token-Werte (Color(String), Dimension(String), ..., Reference(TokenIdentifier)).
        - Invarianten: `Opacity` zwischen 0.0 und 1.0. Strings für Farben/Dimensionen sollten CSS-kompatibel sein.
    - `RawToken { id: TokenIdentifier, value: TokenValue, description: Option<String>, group: Option<String> }`
    - `TokenSet = BTreeMap<TokenIdentifier, RawToken>`: Gewährleistet deterministische Reihenfolge.
    - `ThemeIdentifier(String)`: Bezeichner für ein Theme.
    - `ColorSchemeType`: Enum (`Light`, `Dark`).
    - `AccentColor { name: Option<String>, value: novade_core::types::Color }`: Verwendet `Color` aus der Kernschicht.
    - `ThemeVariantDefinition { applies_to_scheme: ColorSchemeType, tokens: TokenSet }`
    - `ThemeDefinition { id: ThemeIdentifier, name: String, ..., base_tokens: TokenSet, variants: Vec<ThemeVariantDefinition>, supported_accent_colors: Option<Vec<AccentColor>>, accentable_tokens: Option<HashMap<TokenIdentifier, AccentModificationType>> }`
        - `AccentModificationType`: Enum (`DirectReplace`, `Lighten(f32)`, `Darken(f32)`).
    - `AppliedThemeState { theme_id: ThemeIdentifier, color_scheme: ColorSchemeType, active_accent_color: Option<AccentColor>, resolved_tokens: BTreeMap<TokenIdentifier, String> }`
    - `ThemingConfiguration { selected_theme_id: ThemeIdentifier, preferred_color_scheme: ColorSchemeType, selected_accent_color: Option<novade_core::types::Color>, custom_user_token_overrides: Option<TokenSet> }`
- **Service API (`ThemingEngine` Trait)** (in `src/theming/service.rs` oder `mod.rs`):
    
    Rust
    
    ```
    // src/theming/service.rs
    use async_trait::async_trait;
    use std::path::PathBuf;
    use std::sync::Arc;
    use tokio::sync::broadcast;
    use super::types::{ThemingConfiguration, AppliedThemeState, ThemeDefinition, ThemeChangedEvent};
    use super::errors::ThemingError;
    use crate::core::config::ConfigServiceAsync; // Pfad anpassen
    
    #[async_trait]
    pub trait ThemingEngine: Send + Sync {
        async fn new(
            initial_config: ThemingConfiguration,
            theme_load_paths: Vec<PathBuf>,
            token_load_paths: Vec<PathBuf>,
            config_service: Arc<dyn ConfigServiceAsync>, // Für Dateizugriff
            broadcast_capacity: usize,
        ) -> Result<Self, ThemingError> where Self: Sized;
    
        async fn get_current_theme_state(&self) -> AppliedThemeState;
        async fn get_available_themes(&self) -> Vec<ThemeDefinition>;
        async fn get_current_configuration(&self) -> ThemingConfiguration;
        async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>;
        async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>;
        fn subscribe_to_theme_changes(&self) -> broadcast::Receiver<ThemeChangedEvent>;
    }
    ```
    
- **Events** (in `src/theming/types.rs`):
    - `ThemeChangedEvent { new_state: AppliedThemeState }`
- **Fehlerbehandlung** (in `src/theming/errors.rs`):
    - `ThemingError`: Enum mit Varianten wie `TokenFileParseError`, `ThemeFileLoadError`, `CyclicTokenReference`, `MissingTokenReference`, `ThemeNotFound`, `InvalidTokenValue`, `AccentColorApplicationError`, `MaxReferenceDepthExceeded`, `FallbackThemeLoadError`, `FilesystemError(#[from] novade_core::errors::CoreError)`.
- **Interne Logik** (in `src/theming/logic.rs`): Token Resolution Pipeline (asynchrones Laden, synchrone Auflösung), Caching, Fallback-Theme-Logik.

#### 1.4. Modul: `domain::global_settings_and_state_management`

Verantwortlich für globale Desktop-Einstellungen.

- **Datenstrukturen** (in `src/global_settings/types.rs`):
    - `GlobalDesktopSettings` und Unterstrukturen (`AppearanceSettings`, `InputBehaviorSettings`, etc.) mit `serde` und `Default`.
    - Jede Unterstruktur hat eine `validate(&self) -> Result<(), String>` Methode.
- **Einstellungspfade** (in `src/global_settings/paths.rs`):
    - `SettingPath`: Hierarchischer Enum, der alle Einstellungsfelder abbildet. Implementiert `Display` und `TryFrom<&str>`.
- **Persistenzschnittstelle** (in `src/global_settings/persistence_iface.rs`):
    - `SettingsPersistenceProvider` Trait: `async fn load_global_settings() -> Result<GlobalDesktopSettings, GlobalSettingsError>`, `async fn save_global_settings(settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`.
    - Implementierung `FilesystemSettingsProvider` (in `src/global_settings/persistence.rs`) nutzt `Arc<dyn novade_core::config::ConfigServiceAsync>`.
- **Service API (`GlobalSettingsService` Trait)** (in `src/global_settings/service.rs`):
    
    Rust
    
    ```
    // src/global_settings/service.rs
    use async_trait::async_trait;
    use tokio::sync::broadcast;
    use super::types::GlobalDesktopSettings;
    use super::paths::SettingPath;
    use super::errors::GlobalSettingsError;
    use super::events::SettingChangedEvent; // Events hier definieren
    use serde_json::Value as JsonValue;
    
    #[async_trait]
    pub trait GlobalSettingsService: Send + Sync {
        async fn load_settings(&self) -> Result<(), GlobalSettingsError>;
        async fn save_settings(&self) -> Result<(), GlobalSettingsError>;
        async fn get_current_settings_snapshot(&self) -> GlobalDesktopSettings; // Gibt Klon
        async fn update_setting(&self, path: SettingPath, value: JsonValue) -> Result<(), GlobalSettingsError>;
        async fn get_setting_as_json(&self, path: &SettingPath) -> Result<JsonValue, GlobalSettingsError>;
        async fn reset_to_defaults(&self) -> Result<(), GlobalSettingsError>;
        fn subscribe_to_changes(&self) -> broadcast::Receiver<SettingChangedEvent>;
    }
    ```
    
- **Events** (in `src/global_settings/events.rs`):
    - `SettingChangedEvent { path: SettingPath, new_value: JsonValue }`
    - `SettingsLoadedEvent { settings: GlobalDesktopSettings }`
    - `SettingsSavedEvent`
- **Fehlerbehandlung** (in `src/global_settings/errors.rs`):
    - `GlobalSettingsError`: Enum mit Varianten wie `PathNotFound { path: SettingPath }`, `InvalidValueType`, `ValidationError { path: SettingPath, reason: String }`, `PersistenceError { operation: String, #[source] source: novade_core::errors::CoreError }`.

#### 1.5. Modul: `domain::workspaces`

Verwaltet Arbeitsbereiche ("Spaces").

- **Datenstrukturen (`core` Submodul - `src/workspaces/core/types.rs`):**
    - `WorkspaceId = uuid::Uuid`
    - `WindowIdentifier(String)`: Invarianten: nicht leer.
    - `WorkspaceLayoutType`: Enum (`Floating`, `TilingHorizontal`, `TilingVertical`, `Maximized`).
    - `Workspace`: Struct (`id`, `name`, `persistent_id`, `layout_type`, `window_ids: HashSet<WindowIdentifier>`, `created_at`, `icon_name: Option<String>`, `accent_color_hex: Option<String>`). Validierung für `name` und `persistent_id`.
        - Methoden: `new`, `rename`, `set_layout_type`, `set_icon_name`, `set_accent_color_hex`, etc.
- **Fensterzuweisungslogik (`assignment` Submodul - `src/workspaces/assignment/mod.rs`):**
    - Funktionen: `assign_window_to_workspace`, `remove_window_from_workspace`, `move_window_to_workspace`, `find_workspace_for_window`. Operieren auf `&mut HashMap<WorkspaceId, Workspace>`.
- **Konfigurationspersistenz (`config` Submodul - `src/workspaces/config/mod.rs`):**
    - `WorkspaceSnapshot { persistent_id: String, name: String, layout_type: WorkspaceLayoutType, icon_name: Option<String>, accent_color_hex: Option<String> }`
    - `WorkspaceSetSnapshot { workspaces: Vec<WorkspaceSnapshot>, active_workspace_persistent_id: Option<String> }`
    - `WorkspaceConfigProvider` Trait: `async fn load_workspace_config()`, `async fn save_workspace_config()`.
- **Service API (`WorkspaceManagerService` Trait - `src/workspaces/manager/service.rs`):**
    
    Rust
    
    ```
    // src/workspaces/manager/service.rs
    use async_trait::async_trait;
    use tokio::sync::broadcast;
    use crate::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType, Workspace};
    use super::errors::WorkspaceManagerError;
    use super::events::WorkspaceEvent; // Events hier definieren
    
    #[async_trait]
    pub trait WorkspaceManagerService: Send + Sync {
        async fn create_workspace(&self, name: Option<String>, persistent_id: Option<String>, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<WorkspaceId, WorkspaceManagerError>;
        async fn delete_workspace(&self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>;
        async fn get_workspace_by_id(&self, id: WorkspaceId) -> Option<Workspace>; // Klon
        async fn get_all_workspaces_ordered(&self) -> Vec<Workspace>; // Klone
        async fn get_active_workspace_id(&self) -> Option<WorkspaceId>;
        async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;
        async fn assign_window_to_active_workspace(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>;
        async fn move_window_to_specific_workspace(&self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_layout(&self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_accent_color(&self, id: WorkspaceId, color_hex: Option<String>) -> Result<(), WorkspaceManagerError>;
        async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>;
        async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>;
        fn subscribe_to_workspace_events(&self) -> broadcast::Receiver<WorkspaceEvent>;
    }
    ```
    
- **Events (`manager` Submodul - `src/workspaces/manager/events.rs`):**
    - `WorkspaceEvent` Enum: `WorkspaceCreated { descriptor: Workspace }`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, `WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WindowAddedToWorkspace`, `WindowRemovedFromWorkspace`, `WorkspaceOrderChanged`, `WorkspacesReloaded`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`.
- **Fehlerbehandlung (`core`, `assignment`, `config`, `manager` Submodule):**
    - `WorkspaceCoreError`, `WindowAssignmentError`, `WorkspaceConfigError`, `WorkspaceManagerError`.

#### 1.6. Modul: `domain::window_management_policy`

Definiert High-Level-Regeln für Fensterplatzierung, Tiling, Snapping, etc.

- **Datenstrukturen** (in `src/window_management_policy/types.rs`):
    - `TilingMode`: Enum (`Manual`, `Columns`, `Rows`, `Spiral`, `MaximizedFocused`).
    - `GapSettings { screen_outer_horizontal: u16, screen_outer_vertical: u16, window_inner: u16 }`
    - `WindowSnappingPolicy { snap_to_screen_edges: bool, snap_to_other_windows: bool, snap_to_workspace_gaps: bool, snap_distance_px: u16 }`
    - `NewWindowPlacementStrategy`: Enum (`Smart`, `Center`, `Cascade`, `UnderMouse`).
    - `FocusPolicy { focus_follows_mouse: bool, click_to_focus: bool, focus_new_windows_on_creation: bool, ... }`
    - `WindowPolicyOverrides { preferred_tiling_mode: Option<TilingMode>, is_always_floating: Option<bool>, ... }` (pro Fenster)
    - `WorkspaceWindowLayout { window_geometries: HashMap<WindowIdentifier, novade_core::types::RectInt>, tiling_mode_applied: TilingMode, occupied_area: Option<RectInt> }`
    - `WindowLayoutInfo { id: WindowIdentifier, requested_min_size: Option<novade_core::types::Size<u32>>, ... }`
- **Service API (`WindowManagementPolicyService` Trait)** (in `src/window_management_policy/service.rs`):
    
    Rust
    
    ```
    // src/window_management_policy/service.rs
    use async_trait::async_trait;
    // ... imports ...
    use crate::core::types::{RectInt, Size, Point};
    use crate::workspaces::core::types::{WorkspaceId, WindowIdentifier};
    use crate::global_settings_and_state_management::types::GlobalDesktopSettings;
    use super::types::{TilingMode, GapSettings, WindowSnappingPolicy, NewWindowPlacementStrategy, WorkspaceWindowLayout, WindowPolicyOverrides, FocusPolicy, WindowLayoutInfo};
    use super::errors::WindowPolicyError;
    use std::collections::HashMap;
    
    #[async_trait]
    pub trait WindowManagementPolicyService: Send + Sync {
        async fn calculate_workspace_layout(
            &self,
            workspace_id: WorkspaceId,
            windows_to_layout: &[WindowLayoutInfo],
            available_area: RectInt,
            workspace_current_tiling_mode: TilingMode,
            focused_window_id: Option<&WindowIdentifier>,
            window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>,
            // Globale Settings werden intern über den GlobalSettingsService bezogen
        ) -> Result<WorkspaceWindowLayout, WindowPolicyError>;
    
        async fn get_initial_window_geometry(
            &self,
            window_info: &WindowLayoutInfo,
            is_transient_for: Option<&WindowIdentifier>,
            parent_geometry: Option<RectInt>,
            workspace_id: WorkspaceId,
            active_layout_on_workspace: &WorkspaceWindowLayout,
            available_area: RectInt,
            window_specific_overrides: &Option<WindowPolicyOverrides>,
        ) -> Result<RectInt, WindowPolicyError>;
    
        async fn calculate_snap_target(
            &self,
            moving_window_id: &WindowIdentifier,
            current_geometry: RectInt,
            other_windows_on_workspace: &[(&WindowIdentifier, &RectInt)],
            workspace_area: RectInt,
            // SnappingPolicy & GapSettings werden intern bezogen
        ) -> Option<RectInt>;
    
        async fn get_effective_focus_policy(&self) -> Result<FocusPolicy, WindowPolicyError>;
        async fn get_effective_new_window_placement_strategy(&self) -> Result<NewWindowPlacementStrategy, WindowPolicyError>;
        async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>;
        async fn get_effective_gap_settings(&self) -> Result<GapSettings, WindowPolicyError>; // Global oder pro Workspace
        async fn get_effective_snapping_policy(&self) -> Result<WindowSnappingPolicy, WindowPolicyError>;
    }
    ```
    
- **Fehlerbehandlung** (in `src/window_management_policy/errors.rs`):
    - `WindowPolicyError`: Enum (`LayoutCalculationError`, `InvalidPolicyConfiguration`, `WindowNotFoundForPolicy`).

#### 1.7. Modul: `domain::user_centric_services`

Umfasst KI-Interaktion und Benachrichtigungsmanagement.

- **`ai_interaction` Submodul:**
    - Datenstrukturen (`AIConsentStatus`, `AIDataCategory`, `AttachmentData`, `AIInteractionContext`, `InteractionHistoryEntry`, `AIConsent`, `AIConsentScope`, `AIModelProfile`, `AIModelCapability`).
    - Persistenzschnittstellen: `AIConsentProvider`, `AIModelProfileProvider`.
    - Service API: `AIInteractionLogicService` Trait.
    - Events: `AIInteractionEventEnum` (`AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`, `AIContextUpdatedEvent`, `AIModelProfilesReloadedEvent`).
    - Fehler: `AIInteractionError`.
- **`notifications_core` Submodul:**
    - Datenstrukturen (`NotificationUrgency`, `NotificationActionType`, `NotificationAction`, `Notification`, `NotificationInput`, `NotificationFilterCriteria`, `NotificationSortOrder`, `NotificationStats`, `DismissReason`).
    - Service API: `NotificationService` Trait.
    - Events: `NotificationEventEnum` (`NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `NotificationActionInvokedEvent`, `DoNotDisturbModeChangedEvent`, `NotificationHistoryClearedEvent`, `NotificationPopupExpiredEvent`).
    - Fehler: `NotificationError`.

#### 1.8. Modul: `domain::notifications_rules`

Regel-Engine für Benachrichtigungen.

- **Datenstrukturen** (in `src/notifications_rules/types.rs`):
    - `RuleConditionValue`, `RuleConditionOperator`, `RuleConditionField`, `SimpleRuleCondition`, `RuleCondition` (rekursiv), `RuleAction`, `NotificationRule`, `NotificationRuleSet`.
- **Persistenzschnittstelle** (in `src/notifications_rules/persistence_iface.rs`):
    - `NotificationRulesProvider` Trait: `async fn load_rules()`, `async fn save_rules()`.
- **Engine API (`NotificationRulesEngine` Trait)** (in `src/notifications_rules/engine.rs`):
    
    Rust
    
    ```
    // src/notifications_rules/engine.rs
    use async_trait::async_trait;
    use crate::user_centric_services::notifications_core::types::Notification; // Pfad anpassen
    use super::types::NotificationRuleSet;
    use super::errors::NotificationRulesError;
    
    #[derive(Debug, Clone, PartialEq)]
    pub enum RuleProcessingResult {
        Allow(Notification),
        Suppress { rule_id: uuid::Uuid },
    }
    
    #[async_trait]
    pub trait NotificationRulesEngine: Send + Sync {
        async fn reload_rules(&self) -> Result<(), NotificationRulesError>;
        async fn process_notification(
            &self,
            notification: Notification,
        ) -> Result<RuleProcessingResult, NotificationRulesError>;
        async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>;
        async fn update_rules(&self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>;
    }
    ```
    
- **Fehlerbehandlung** (in `src/notifications_rules/errors.rs`):
    - `NotificationRulesError`: Enum (`InvalidRuleDefinition`, `ConditionEvaluationError`, `SettingsAccessError`, `RulePersistenceError`).

### 2. Wayland/Smithay-Integration

Die Domänenschicht selbst interagiert **nicht direkt** mit Wayland oder Smithay. Die Systemschicht (`system::compositor`, `system::input`, `system::window_mechanics`) ist für diese Integration verantwortlich.

- **Kommunikation Domäne &lt;-> Systemschicht:**
    - **Domäne zu System**: Die Domänenschicht gibt Richtlinien und Zustände vor. Z.B. `domain::window_management_policy::WindowManagementPolicyService::calculate_workspace_layout()` gibt ein `WorkspaceWindowLayout` zurück. `system::window_mechanics` nimmt dieses Ergebnis und wendet es auf die `ManagedWindow`s im `DesktopState::space` an, indem es `configure`-Events via Smithay (`xdg_toplevel.send_configure()`) an die Wayland-Clients sendet.
    - **System zu Domäne**: Die Systemschicht meldet rohe Systemereignisse oder Client-Anfragen an die Domänenschicht, die dann die Geschäftslogik anwendet.
        - Beispiel: `system::input` verarbeitet einen Tastendruck. Wenn dieser eine globale Aktion auslöst (z.B. Workspace wechseln), ruft `system::input` (oder ein Handler in `DesktopState`) eine Methode auf `domain::workspaces::WorkspaceManagerService` auf (z.B. `switch_to_next_workspace()`). Der `WorkspaceManagerService` ändert seinen Zustand und sendet ein `WorkspaceEvent::ActiveWorkspaceChanged`.
        - Beispiel: Ein Wayland-Client (`xdg_toplevel`) sendet eine `set_title`-Anfrage. Der `XdgShellHandler` in `DesktopState` empfängt dies. Er könnte direkt den Titel im `ManagedWindow` setzen oder, falls Validierung oder zusätzliche Logik nötig ist, eine Methode eines Domänendienstes (z.B. `domain::window_properties_service::set_window_title(window_id, new_title)`) aufrufen.
- **Notwendige Wayland-Protokolle (implementiert in Systemschicht):**
    - `xdg-shell`: Für Toplevel-Fenster und Popups. Die Systemschicht (`system::compositor::xdg_shell`) implementiert den `XdgShellHandler`. Zustandsänderungen an `ManagedWindow`s (die `xdg_toplevel`-Instanzen wrappen) werden von `system::window_mechanics` oder direkt im `XdgShellHandler` basierend auf Domänen-Policy durchgeführt.
    - `wlr-layer-shell-unstable-v1`: Für Panels, Docks etc. (`system::compositor::layer_shell`). Die Domänenschicht gibt keine direkten Anweisungen für Layer-Shell-Objekte, aber die globalen Einstellungen (`GlobalSettingsService`) könnten beeinflussen, welche Panels standardmäßig aktiv sind oder wie sie sich verhalten.
    - Weitere Protokolle (`wlr-output-management-unstable-v1`, etc.) werden von der Systemschicht gehandhabt. Die Domänenschicht definiert ggf. Policies oder konsumiert abstrahierte Events (z.B. `OutputConfigurationChangedEvent` könnte von `domain::theming` konsumiert werden, um Skalierungsfaktoren anzupassen).
- **Smithay-Nutzung**:
    - `DesktopState` (in `system::compositor::core`) ist der zentrale `CompositorState` und implementiert viele Smithay-Handler-Traits.
    - `DisplayHandle` wird für die Interaktion mit dem Wayland-Display verwendet.
    - Domänenlogik wird _innerhalb_ dieser Handler aufgerufen, um Entscheidungen zu treffen. Beispiel im `XdgShellHandler::new_toplevel`: Nachdem die `ToplevelSurface` von Smithay erstellt wurde, könnte `system::window_mechanics` (das `WindowManagementPolicyService` nutzt) aufgerufen werden, um die initiale Geometrie und den Workspace zu bestimmen.
- **Empfang von Domänenbefehlen durch Compositor / Übersetzung in Wayland-Operationen**:
    1. **Auslöser**: UI-Aktion oder internes Domänen-Event.
    2. **Domänenschicht**: Ein Domänen-Service (z.B. `WorkspaceManagerService.set_active_workspace(id)`) ändert seinen internen Zustand und sendet ein Domänen-Event (z.B. `WorkspaceEvent::ActiveWorkspaceChanged`).
    3. **Systemschicht-Adapter/Listener**: Eine Komponente in der Systemschicht (oft Teil des `DesktopState` oder ein dedizierter Listener, der Domänen-Events abonniert) empfängt das Domänen-Event.
    4. **Übersetzung in Wayland-Aktionen**:
        - Bei `ActiveWorkspaceChanged`: Der Listener im `DesktopState` oder `system::window_mechanics` würde:
            - Alle Fenster auf dem alten Workspace "verstecken" (z.B. `unmap` oder Sichtbarkeit ändern, falls vom Compositor unterstützt).
            - Alle Fenster auf dem neuen Workspace "anzeigen" und gemäß Layout-Policy anordnen.
            - Den Fokus auf das entsprechende Fenster im neuen Workspace setzen (`set_keyboard_focus` via `system::input`).
        - Bei Anforderung zur Fenstergrößenänderung von `domain::window_management_policy`: `system::window_mechanics` ruft `toplevel_surface.send_configure()` mit den neuen Bounds auf.
- **Weiterleitung von Wayland-Ereignissen an Domänenschicht**:
    - **Client-Requests**: Wayland-Client-Anfragen (z.B. `xdg_toplevel.set_title`) werden vom Smithay-Handler im `DesktopState` empfangen. Der Handler kann:
        1. Die Anfrage direkt bearbeiten, wenn keine komplexe Domänenlogik erforderlich ist (z.B. Fenstertitel im `ManagedWindow` aktualisieren).
        2. Eine Methode eines Domänen-Service aufrufen, um die Anfrage zu validieren oder Geschäftsregeln anzuwenden. Das Ergebnis des Domänen-Service-Aufrufs bestimmt die Antwort an den Wayland-Client.
    - **Systemereignisse**: Hardware-Events (z.B. Input von `system::input`, Monitor-Hotplug von `system::outputs`) werden in der Systemschicht verarbeitet. Diese können dann:
        1. Direkt zu Aktionen führen (z.B. Fokus verschieben).
        2. In allgemeinere System-Events (`SystemLayerEvent` via `system::event_bridge`) umgewandelt werden, die von der Domänenschicht abonniert werden können.
        3. Direkt Methoden von Domänen-Services aufrufen, wenn eine enge Kopplung sinnvoll ist.

### 3. Protokoll-Implementierungen

Die Domänenschicht interagiert nicht direkt mit diesen Protokollen, sondern über Abstraktionen in der Systemschicht.

- **D-Bus (`system::dbus_interfaces`)**:
    - Domänen-Services (z.B. `NotificationService`, `AIInteractionLogicService`, `GlobalSettingsService`) werden _nicht_ direkt D-Bus-Methoden aufrufen oder Signale senden.
    - Die Systemschicht stellt D-Bus-Clients (z.B. `UPowerClientService`, `LogindClientService`) bereit. Diese Clients:
        - Rufen D-Bus-Methoden auf.
        - Empfangen D-Bus-Signale.
        - Übersetzen diese in `SystemLayerEvent`s (via `system::event_bridge`) ODER rufen direkt Methoden von Domänen-Services auf (z.B. `LogindClientService` ruft bei `PrepareForSleep` eine Methode von `domain::power_management_policy` auf).
        - Beispiel: `UPowerClientService` sendet `UPowerSystemEvent::OnBatteryChanged`. Ein Adapter in der System- oder Domänenschicht könnte dies in ein `domain::common_events::PowerSourceChangedEvent` umwandeln, auf das `domain::power_management_policy` reagiert.
    - Der `system::dbus_interfaces::notifications_server` implementiert den `org.freedesktop.Notifications`-D-Bus-Dienst und ruft intern den `domain::user_centric_services::NotificationService`.
- **XDG Desktop Portals (`system::portals`)**:
    - Die Systemschicht implementiert das Backend für Portale (z.B. `FileChooser`, `Screenshot`).
    - Wenn ein Portal eine UI erfordert (z.B. Dateiauswahldialog), kommuniziert das Portal-Backend in der Systemschicht mit der UI-Schicht.
    - Die Domänenschicht könnte beteiligt sein, um Standardwerte oder Policies bereitzustellen (z.B. Standard-Speicherpfad von `GlobalSettingsService` für `FileChooser`).
- **Model Context Protocol (MCP) (`system::mcp_client`)**:
    - Der `domain::user_centric_services::AIInteractionLogicService` definiert die Logik für KI-Interaktionen und Einwilligungen.
    - Wenn eine KI-Aktion ausgeführt werden soll, ruft der `AIInteractionLogicService` eine Methode auf dem `system::mcp_client::SystemMcpService` (Trait-Implementierung).
    - Der `SystemMcpService` (in der Systemschicht) kümmert sich um die MCP-Kommunikation (Anfrage an Server, Empfang von Antwort/Notification) und leitet das Ergebnis (oder MCP-Fehler) an den `AIInteractionLogicService` zurück oder sendet ein `McpClientSystemEvent`.
    - API-Schlüssel für MCP-Server werden vom `SystemMcpService` über den `system::dbus_interfaces::secrets_service_client` sicher abgerufen.

### 4. Implementierbare Lösungen (Code-Skizzen, Algorithmen, Datenstrukturen)

#### 4.1. Traits der Domänenschicht (Beispiele)

Rust

```
// In src/domain/workspaces/manager/service.rs
#[async_trait]
pub trait WorkspaceManagerService: Send + Sync {
    async fn create_workspace(&self, name: Option<String>, /* ... */) -> Result<WorkspaceId, WorkspaceManagerError>;
    async fn get_active_workspace_id(&self) -> Option<WorkspaceId>;
    // ... weitere Methoden ...
    fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>;
}

// In src/domain/global_settings/service.rs
#[async_trait]
pub trait GlobalSettingsService: Send + Sync {
    async fn update_setting(&self, path: SettingPath, value: serde_json::Value) -> Result<(), GlobalSettingsError>;
    async fn get_setting_as_json(&self, path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>;
    // ...
}
```

#### 4.2. Datenstrukturen (Beispiele)

Rust

```
// In src/domain/workspaces/core/types.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Workspace {
    id: WorkspaceId,
    name: String,
    persistent_id: Option<String>,
    layout_type: WorkspaceLayoutType,
    window_ids: HashSet<WindowIdentifier>,
    created_at: chrono::DateTime<chrono::Utc>,
    icon_name: Option<String>,
    accent_color_hex: Option<String>,
}

// In src/domain/global_settings/types.rs
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(default, rename_all = "kebab-case")]
pub struct AppearanceSettings {
    pub active_theme_name: String,
    pub color_scheme: ColorScheme,
    pub accent_color_token: String, // Token-Name für die Akzentfarbe
    pub custom_accent_color_value: Option<novade_core::types::Color>, // Wenn Benutzer eine spezifische Farbe wählt
    // ...
}
```

#### 4.3. Interaktion Domäne (WorkspaceManager) &lt;-> System (Compositor/WindowMechanics)

**Szenario: Workspace wechseln**

1. **UI-Schicht**: Benutzer klickt auf Workspace-Switcher. UI ruft `WorkspaceManagerService.set_active_workspace(new_ws_id).await`.
2. **`domain::workspaces::DefaultWorkspaceManager`**:
    - Sperrt internen Zustand (`internal_state.lock().await`).
    - Validiert `new_ws_id`.
    - Aktualisiert `internal_state.active_workspace_id`.
    - Sendet `WorkspaceEvent::ActiveWorkspaceChanged { old_id, new_id }` über `event_publisher`.
    - Ruft `internal_state.config_provider.save_workspace_config(...).await` auf (um aktiven Workspace zu persistieren).
3. **`system::compositor::DesktopState` (oder ein dedizierter Listener in `system`):**
    - Abonniert `WorkspaceEvent::ActiveWorkspaceChanged`.
    - Bei Empfang des Events:
        - Identifiziert Fenster auf dem alten (`old_id`) und neuen (`new_id`) Workspace.
        - Informiert `system::window_mechanics`, das Layout für den neuen Workspace anzuwenden und Fenster entsprechend anzuzeigen/zu verstecken.
        - `system::window_mechanics` würde `domain::window_management_policy::calculate_workspace_layout()` aufrufen.
        - `system::window_mechanics` sendet dann `configure`-Events an die Wayland-Clients, um sie über neue Geometrien oder Sichtbarkeitsänderungen zu informieren.
        - Der Fokus wird auf das entsprechende Fenster im neuen Workspace gesetzt (z.B. das zuletzt fokussierte oder gemäß Policy).

**Algorithmus: Token Resolution in `domain::theming::logic::resolve_tokens_for_config`**

(Wie detailliert in der vorherigen Antwort unter Abschnitt 3.3 `domain::theming::logic` der Domänenschicht-Spezifikation, einschließlich Basis-Tokens, Varianten, Akzentfarben, User-Overrides und rekursiver Referenzauflösung mit Zyklenerkennung.)

#### 4.4. Hinweise auf Bibliotheken

- **Domänenschicht**:
    - `uuid`: Für eindeutige IDs.
    - `chrono`: Für Zeitstempel.
    - `serde`, `serde_json`, `toml`: Für Serialisierung/Deserialisierung von Konfigurationen und Datenstrukturen.
    - `thiserror`: Für Fehlerbehandlung.
    - `async-trait`: Für Traits mit `async fn`.
    - `tokio::sync::{Mutex, RwLock, broadcast}`: Für interne Zustandsverwaltung und Eventing.
    - `regex` (optional): Für `RuleCondition::AppNameMatches` in `domain::notifications_rules`.
- **Systemschicht (für Interaktion mit Domäne und Wayland/Smithay)**:
    - `smithay`: Kern-Toolkit für Wayland-Compositor.
    - `wayland-server`, `wayland-protocols`: Basis-Wayland-Bibliotheken.
    - `zbus`: Für D-Bus-Kommunikation.
    - `libinput` (via Smithay oder direkt): Für Eingabeverarbeitung.
    - `pipewire-rs`: Für Audio-Management.
    - `mcp_client_rs`: Für MCP-Client-Implementierung.
    - `ashpd` (optional): Als Referenz oder Nutzung für XDG Desktop Portal Interaktionen.

#### 4.5. Annahmen und Einschränkungen

- **Event-Bus**: Es wird ein `tokio::sync::broadcast`-basierter Event-Bus für die interne Kommunikation in der Domänenschicht und für die Benachrichtigung der System-/UI-Schicht angenommen.
- **Persistenz**: Die Domänenschicht delegiert die eigentliche Persistenz an die Kernschicht (`core::config`) über Provider-Traits. Das Format ist typischerweise TOML oder JSON.
- **Asynchronität**: Die Domänenschicht ist auf eine `async` Runtime (wie Tokio) angewiesen, die von der Anwendung bereitgestellt wird.
- **Wayland-Fokus**: Die Domänenschicht definiert Policies für den Fokus, die technische Umsetzung (Setzen des Wayland-Fokus auf eine `WlSurface`) erfolgt in der Systemschicht.

### 5. Maximale Detailtiefe

Die vorangegangenen Abschnitte und die referenzierten Dokumente (`B1-B4 Domänenschicht.md`, etc.) zielen darauf ab, diese Detailtiefe zu erreichen, indem:

- **Atomare Schritte**: Komplexe Logik (z.B. Token-Auflösung, Layout-Berechnung, Regel-Auswertung) wird in kleinere, verständliche Schritte und Funktionen zerlegt.
- **Präzise Schnittstellen**: Traits definieren klare Verträge. Datenstrukturen (`struct`, `enum`) sind mit all ihren Feldern, Typen und Ableitungen spezifiziert. Event-Payloads sind vollständig definiert. Fehlertypen sind granular und kontextreich.
- **Detaillierte technische Erklärungen**: Die "Warum"- und "Wie"-Aspekte jeder Designentscheidung und jedes Mechanismus werden erläutert, insbesondere bei Interaktionen zwischen Modulen oder Schichten.

Diese Spezifikation zielt darauf ab, Interpretationsspielräume zu minimieren und eine solide, direkt umsetzbare Grundlage für die Entwicklung der Domänenschicht von NovaDE und deren Integration mit der Systemschicht (Compositor) zu bieten.

Zusätzliche Details zur **Interaktion zwischen `domain::window_management_policy` und `system::compositor` / `system::window_mechanics`**:

1. **Fenstererstellung**:
    - Ein Wayland-Client erstellt eine neue `xdg_toplevel`-Oberfläche.
    - Der `XdgShellHandler` in `system::compositor::DesktopState` wird benachrichtigt (`new_toplevel`).
    - Der Handler erstellt ein `ManagedWindow`-Objekt (Systemschicht-Repräsentation).
    - Er ruft `domain::window_management_policy::WindowManagementPolicyService::get_initial_window_geometry()` auf und übergibt Informationen über das neue Fenster (z.B. `WindowLayoutInfo`), den aktuellen Workspace und das Layout.
    - Der Domänen-Service gibt eine initiale `RectInt` zurück.
    - `system::window_mechanics` (oder der `XdgShellHandler` direkt) sendet eine `configure`-Nachricht mit dieser Geometrie an den Client. Das `ManagedWindow` wird im `DesktopState::space` platziert.
2. **Fenster-Resize/Move (Client-initiiert)**:
    - Client sendet `xdg_toplevel.resize` oder `xdg_toplevel.move`.
    - `XdgShellHandler` empfängt dies. Er startet einen interaktiven Grab-Vorgang (`system::window_mechanics::interactive_ops`).
    - Während des Grabs ruft der Grab-Handler `domain::window_management_policy::WindowManagementPolicyService::calculate_snap_target()`, um Snapping-Vorschläge zu erhalten und die Geometrie anzupassen.
    - Nach Abschluss des Grabs wird die finale Geometrie dem Client via `configure` mitgeteilt.
3. **Automatisches Tiling durch Workspace-Layout-Änderung**:
    - Benutzer ändert Layout-Typ für einen Workspace (UI -> `domain::workspaces::WorkspaceManagerService::set_workspace_layout()`).
    - `WorkspaceManagerService` sendet `WorkspaceEvent::WorkspaceLayoutChanged`.
    - Ein Listener in `system::window_mechanics` (oder `DesktopState`) empfängt dieses Event.
    - Der Listener ruft `domain::window_management_policy::WindowManagementPolicyService::calculate_workspace_layout()` für den betroffenen Workspace auf, um die neuen Geometrien für alle Fenster zu erhalten.
    - `system::window_mechanics` wendet diese neuen Geometrien auf die `ManagedWindow`s an und sendet `configure`-Events an die Clients.

Diese Beispiele verdeutlichen den Datenfluss und die Verantwortlichkeiten: Die Domänenschicht entscheidet über die _Policy_, die Systemschicht setzt diese _mechanisch_ um und kommuniziert mit den Wayland-Clients.

### Systemschicht-Spezifikationen

Die Systemschicht (`novade-system` Crate) bildet die Brücke zwischen der abstrakten Domänenlogik und der konkreten Hardware bzw. den Low-Level-Systemdiensten. Sie ist maßgeblich für die Implementierung des Wayland-Compositors, die Eingabeverarbeitung, die Kommunikation über D-Bus und die Steuerung von Systemressourcen wie Audio und Energie.

#### 1. Modul: `system::compositor` (Smithay-basierter Wayland Compositor)

Dieses Modul implementiert die Kernlogik des Wayland-Compositors unter Verwendung des Smithay-Toolkits.

##### 1.1. Untermodul: `system::compositor::core`

Zuständig für zentrale Compositor-Zustände, die `DesktopState`-Struktur und Basis-Handler-Implementierungen.

- **Struktur `DesktopState`** (Zentrale Zustandsstruktur)
    
    - Diese Struktur ist das Herz des Compositors und implementiert die meisten Handler-Traits von Smithay. Sie hält Referenzen auf alle wichtigen Zustände und Dienste.
    - **Definition (Auszug und Erweiterung basierend auf `C1 System Implementierungsplan.md` und `3. System-Details.md`):**
        
        Rust
        
        ```
        // src/system/compositor/core/state.rs
        use smithay::{
            backend::{
                renderer::{gles2::Gles2Renderer, Frame, Renderer, Texture, ImportShm, ImportMem}, // Ggf. generischer Renderer-Trait verwenden
                allocator::dmabuf::DmabufState,
            },
            desktop::{Space, Window, WindowSurfaceType, WindowElement, PopupManager, layer_map_for_output, LayerSurface},
            input::{Seat, SeatState, SeatHandler, pointer::CursorImageStatus, keyboard::KeyboardHandle, pointer::PointerHandle, touch::TouchHandle},
            reexports::{
                calloop::{LoopHandle, EventLoop, LoopSignal, Interest, Mode, PostAction},
                wayland_server::{Display, DisplayHandle, Client, backend::{GlobalId, ClientId}, protocol::{wl_surface::WlSurface, wl_output, wl_seat, wl_shm}},
            },
            utils::{Clock, Logical, Physical, Point, Rectangle, Scale, Serial, Transform, SERIAL_COUNTER, zindagi, Buffer as SmithayBuffer},
            wayland::{
                buffer::BufferHandler,
                compositor::{CompositorState, CompositorHandler, CompositorClientState, SurfaceAttributes as WlSurfaceAttributes, add_destruction_hook, TraversalAction},
                output::{OutputManagerState, Output, PhysicalProperties, Mode as WlMode, OutputHandler},
                shell::{
                    xdg::{XdgShellState, XdgShellHandler, XdgToplevelSurfaceData, XdgPopupSurfaceData, SurfaceCachedState, XdgWmBaseClientData, ToplevelSurface, PopupSurface, PositionerState, XdgShellSurfaceUserData, XdgSurfaceConfigure, xdg_toplevel_handle::XdgToplevelUserData},
                    kde_decoration::KdeDecorationManagerState, // Beispiel für SSD
                    wlr_layer::{WlrLayerShellState, LayerShellHandler, LayerShellSurfaceData, Layer as WlrLayer, KeyboardInteractivity as WlrKeyboardInteractivity, Anchor as WlrAnchor},
                },
                shm::{ShmState, ShmHandler, BufferData as ShmBufferData, ShmFormat},
                seat::{WaylandSeatData, SeatUserApi},
                selection::data_device::{DataDeviceState, DataDeviceHandler, ServerDndGrabHandler, DataDeviceUserData},
                selection::primary_selection::{PrimarySelectionState, PrimarySelectionHandler},
                input_method::InputMethodManagerState, // Für IME
                relative_pointer::RelativePointerManagerState,
                pointer_constraints::PointerConstraintsState,
                viewporter::ViewporterState,
                presentation::PresentationState,
                xdg_activation::{XdgActivationState, XdgActivationHandler, XdgActivationTokenData, XdgActivationTokenSurfaceData},
                foreign_toplevel::ForeignToplevelManagerState, // wlr-foreign-toplevel-management
                output_manager::OutputManagerHandler, // für xdg-output
                power_manager::OutputPowerManagementState, // für wlr-output-power-management
            },
            xwayland::{XWayland, XWaylandEvent, XWaylandClientData, xwm::{X11Wm, XwmHandler, X11Surface, XwmId}},
        };
        use crate::core::types::{RectInt, PointInt as CorePointInt, SizeInt as CoreSizeInt}; // NovaDE Core Typen
        use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier as DomainWindowIdentifier};
        use crate::domain::window_management_policy::{WindowManagementPolicyService, WindowPolicyOverrides, TilingMode, WorkspaceWindowLayout, WindowLayoutInfo};
        use crate::domain::workspaces::manager::WorkspaceManagerService;
        use crate::domain::theming::ThemingEngine; // Für Cursor-Theming, Fensterdekorationen
        use crate::domain::global_settings_and_state_management::GlobalSettingsService;
        use crate::system::input::keyboard::xkb_config::XkbKeyboardData;
        use super::surface_management::SurfaceData;
        use std::collections::HashMap;
        use std::sync::{Arc, Mutex as StdMutex}; // Mutex aus std oder parking_lot
        use tokio::sync::Mutex as TokioMutex; // Für async Domain Services
        use uuid::Uuid;
        use std::cell::RefCell;
        use std::rc::Rc;
        use std::time::Duration;
        
        pub const CLOCK_ID: usize = 0; // Für Smithay Clock
        
        // Repräsentiert ein Fenster im Compositor, das von Space verwaltet wird.
        // Muss WindowElement implementieren.
        #[derive(Debug, Clone, PartialEq)]
        pub struct NovaWindowElement {
            pub id: DomainWindowIdentifier, // Eigene ID für die Zuordnung zur Domäne
            pub xdg_toplevel: Option<ToplevelSurface>, // Smithay ToplevelSurface
            pub xdg_popup: Option<PopupSurface>,
            pub x11_surface: Option<X11Surface>, // Für XWayland
            pub layer_surface: Option<LayerSurface>, // Für wlr-layer-shell
            // Weitere Felder für internen Zustand des Compositors, z.B. ob es gemappt ist,
            // Geometrie, Workspace-Zugehörigkeit etc.
            pub current_geometry: RectInt,
            pub workspace_id: Option<WorkspaceId>,
            pub is_mapped: bool,
        }
        
        // Implementierung von WindowElement für NovaWindowElement
        impl WindowElement for NovaWindowElement {
            fn id(&self) -> usize {
                // Eine stabile usize ID generieren, z.B. aus der Uuid der DomainWindowIdentifier
                let mut hasher = std::collections::hash_map::DefaultHasher::new();
                self.id.hash(&mut hasher);
                std::hash::Hasher::finish(&hasher) as usize
            }
        
            fn wl_surface(&self) -> Option<WlSurface> {
                if let Some(toplevel) = &self.xdg_toplevel {
                    Some(toplevel.wl_surface().clone())
                } else if let Some(popup) = &self.xdg_popup {
                    Some(popup.wl_surface().clone())
                } else if let Some(x11) = &self.x11_surface {
                    Some(x11.wl_surface().clone())
                } else if let Some(layer) = &self.layer_surface {
                    Some(layer.wl_surface().clone())
                } else {
                    None
                }
            }
            // ... (weitere Methoden von WindowElement wie bbox, is_suspended, send_frame etc.)
            // müssen sorgfältig implementiert werden, oft durch Delegation an die
            // zugrundeliegende Smithay-Surface (ToplevelSurface, PopupSurface etc.)
            // oder basierend auf current_geometry und is_mapped.
        }
        
        
        pub struct DesktopState {
            pub display_handle: DisplayHandle,
            pub loop_handle: LoopHandle<'static, Self>,
            pub loop_signal: LoopSignal,
            pub clock: Clock<u64>,
        
            // Smithay States
            pub compositor_state: CompositorState,
            pub shm_state: ShmState,
            pub output_manager_state: OutputManagerState,
            pub seat_state: SeatState<Self>,
            pub data_device_state: DataDeviceState,
            pub xdg_shell_state: XdgShellState,
            pub xdg_activation_state: XdgActivationState,
            pub layer_shell_state: WlrLayerShellState,
            pub foreign_toplevel_state: ForeignToplevelManagerState,
            pub output_power_management_state: OutputPowerManagementState,
            pub presentation_state: PresentationState,
            // ... weitere States nach Bedarf ...
        
            // Compositor-interne Daten
            pub space: Space<NovaWindowElement>, // Verwaltet Fensterpositionen und Stapelreihenfolge
            pub popups: PopupManager,
            pub seat: Seat<Self>,
            pub seat_name: String,
            pub keyboard_data_map: HashMap<String /* seat_name or device_id */, XkbKeyboardData>,
            pub current_cursor_status: Arc<StdMutex<CursorImageStatus>>, // Für Cursor-Rendering
            pub pointer_location: Point<f64, Logical>, // Globale Zeigerposition
        
            // Liste aller Fenster (eigene Verwaltung parallel zu space, für leichtere Domänen-Interaktion)
            // Key: DomainWindowIdentifier, Value: NovaWindowElement (oder Arc<NovaWindowElement>)
            pub windows: HashMap<DomainWindowIdentifier, Arc<NovaWindowElement>>,
        
            // XWayland
            pub xwayland: Option<XWayland>,
            pub xwm: Option<Arc<TokioMutex<X11Wm>>>, // X11 Window Manager für XWayland
        
            // Domänen-Service Handles (Arc<TokioMutex<...>> da Domänenservices async sein können)
            pub window_policy_service: Arc<TokioMutex<dyn WindowManagementPolicyService>>,
            pub workspace_manager_service: Arc<TokioMutex<dyn WorkspaceManagerService>>,
            pub theming_engine: Arc<TokioMutex<dyn ThemingEngine>>, // Für Cursor, Dekorationen
            pub settings_service: Arc<TokioMutex<dyn GlobalSettingsService>>,
        
            // System Services (D-Bus Clients etc. - werden hier nicht direkt gehalten, sondern über
            // das SystemEventBridge oder spezifische Handler-Methoden angesprochen)
        
            // Renderer (Beispiel, konkreter Typ hängt von gewählter Implementierung ab)
            // pub renderer: Option<Gles2Renderer>,
            // pub dmabuf_state: Option<DmabufState>, // Wenn DMABUF unterstützt wird
        
            pub last_render_time_ns: u64, // Für Animationen und Frame-Timing
            pub running: Arc<std::sync::atomic::AtomicBool>, // Um den Event-Loop zu beenden
        }
        
        impl DesktopState {
            pub fn new(
                event_loop: &mut EventLoop<'static, Self>,
                display: &mut Display<Self>,
                // Domänen-Services werden injiziert
                window_policy_service: Arc<TokioMutex<dyn WindowManagementPolicyService>>,
                workspace_manager_service: Arc<TokioMutex<dyn WorkspaceManagerService>>,
                theming_engine: Arc<TokioMutex<dyn ThemingEngine>>,
                settings_service: Arc<TokioMutex<dyn GlobalSettingsService>>,
            ) -> Self {
                let display_handle = display.handle();
                let loop_handle = event_loop.handle();
                let loop_signal = event_loop.get_signal();
        
                let clock = Clock::new(None); // Optional: Logger
        
                // Smithay States initialisieren
                let compositor_state = CompositorState::new::<Self>(&display_handle, None);
                let shm_state = ShmState::new::<Self>(&display_handle, vec![], None); // Keine zusätzlichen SHM-Formate initial
                let output_manager_state = OutputManagerState::new_with_xdg_output::<Self>(&display_handle); // Integriert xdg-output
                let mut seat_state = SeatState::new();
                let data_device_state = DataDeviceState::new::<Self>(&display_handle, None);
                let xdg_shell_state = XdgShellState::new::<Self>(&display_handle, None);
                let xdg_activation_state = XdgActivationState::new::<Self>(&display_handle, None);
                let layer_shell_state = WlrLayerShellState::new::<Self>(&display_handle, None);
                let foreign_toplevel_state = ForeignToplevelManagerState::new::<Self>(&display_handle);
                let output_power_management_state = OutputPowerManagementState::new::<Self>(&display_handle);
                let presentation_state = PresentationState::new::<Self>(&display_handle, clock.id() as u32);
        
        
                // Seat erstellen
                let seat_name = "seat0".to_string();
                let seat = seat_state.new_wl_seat(&display_handle, seat_name.clone(), None);
                // Capabilities (Keyboard, Pointer, Touch) werden später hinzugefügt, wenn das Input-Backend initialisiert ist.
        
                let space = Space::new(None);
                let popups = PopupManager::new(None);
        
                Self {
                    display_handle,
                    loop_handle,
                    loop_signal,
                    clock,
                    compositor_state,
                    shm_state,
                    output_manager_state,
                    seat_state,
                    data_device_state,
                    xdg_shell_state,
                    xdg_activation_state,
                    layer_shell_state,
                    foreign_toplevel_state,
                    output_power_management_state,
                    presentation_state,
                    space,
                    popups,
                    seat,
                    seat_name,
                    keyboard_data_map: HashMap::new(),
                    current_cursor_status: Arc::new(StdMutex::new(CursorImageStatus::Default)),
                    pointer_location: (0.0, 0.0).into(),
                    windows: HashMap::new(),
                    xwayland: None, // Wird später initialisiert
                    xwm: None,      // Wird später initialisiert
                    window_policy_service,
                    workspace_manager_service,
                    theming_engine,
                    settings_service,
                    // renderer: None,
                    // dmabuf_state: None,
                    last_render_time_ns: 0,
                    running: Arc::new(std::sync::atomic::AtomicBool::new(true)),
                }
            }
        
            /// Fügt ein neues Fenster zum DesktopState hinzu (sowohl zu `space` als auch zur `windows` Map).
            pub fn map_window(&mut self, window: Arc<NovaWindowElement>, activate: bool) {
                let initial_pos: Point<i32, Logical> = window.geometry().loc; // Oder von Policy bestimmt
                self.space.map_window(window.clone(), initial_pos, activate);
                self.windows.insert(window.id.clone(), window);
                // Ggf. Schaden an Output hinzufügen, wo das Fenster erscheint
                self.damage_outputs_for_geometry(window.geometry());
            }
        
            pub fn unmap_window(&mut self, window_id: &DomainWindowIdentifier) {
                if let Some(window_arc) = self.windows.remove(window_id) {
                    let old_geometry = window_arc.geometry();
                    self.space.unmap_window(&window_arc);
                    self.damage_outputs_for_geometry(old_geometry); // Schaden, wo Fenster war
                }
            }
        
            fn damage_outputs_for_geometry(&self, geometry: RectInt) {
                let geo_logical: Rectangle<i32, Logical> = Rectangle::from_loc_and_size(
                    (geometry.x, geometry.y),
                    (geometry.width as i32, geometry.height as i32)
                );
                for output in self.space.outputs() {
                    let output_geo = self.space.output_geometry(output).unwrap_or_default();
                    if output_geo.overlaps(geo_logical) {
                        output.damage_whole(); // Vereinfacht, oder spezifischer Schaden
                    }
                }
            }
        
            pub fn window_by_domain_id(&self, id: &DomainWindowIdentifier) -> Option<Arc<NovaWindowElement>> {
                self.windows.get(id).cloned()
            }
        }
        ```
        
    - **Handler-Implementierungen für `DesktopState`**:
        - `CompositorHandler`:
            - `client_compositor_state`: Greift auf `ClientCompositorData` zu, das bei `Client::data_map()` gespeichert wird (muss beim Client-Connect initialisiert werden).
            - `commit(surface: &WlSurface)`:
                1. Ruft `smithay::wayland::compositor::with_states(surface, |states| { ... })` auf.
                2. Holt `SurfaceData` aus `states.data_map()`.
                3. Aktualisiert `SurfaceData.current_buffer_info` mit `states.cached_state.current::<WlSurfaceAttributes>().buffer` etc.
                4. Akkumuliert Schaden aus `states.cached_state.current::<WlSurfaceAttributes>().damage` in `SurfaceData.damage_buffer_coords`.
                5. Wenn die Oberfläche eine Rolle hat (z.B. Toplevel, Popup, Layer), wird die spezifische Commit-Logik dieser Rolle (oft in deren eigenem Handler oder durch Smithay's `Space`/`Window`) ausgelöst.
                6. Markiert die Oberfläche für Neuzeichnung durch das Rendering-Backend.
            - `new_surface(surface: &WlSurface)`: Initialisiert `SurfaceData::new(...)` und fügt es zu `surface.data_map()` hinzu. Registriert `add_destruction_hook`.
            - `destroyed(surface: &WlSurface)`: Bereinigt `SurfaceData` und andere Referenzen (oft im `destruction_hook`).
        - `ShmHandler`:
            - `shm_state()`: Gibt `&self.shm_state` zurück.
        - `BufferHandler`:
            - `buffer_destroyed(buffer: &wl_buffer::WlBuffer)`: Informiert den Renderer, die Textur für diesen Puffer freizugeben. Entfernt Puffer-Referenzen aus allen `SurfaceData`-Instanzen.
        - `OutputHandler`:
            - `output_state()`: Gibt `&mut self.output_manager_state` zurück.
            - `new_output(wl_output: &wl_output::WlOutput, output_data: &smithay::wayland::output::OutputData)`: Hier wird ein `Output` von Smithay (`output_data.inner()`) mit einem `NovaWindowElement` oder einer internen Repräsentation im `DesktopState.space` assoziiert. Domänendienste werden ggf. über den neuen Output informiert.
        - `SeatHandler`:
            - `seat_state()`: Gibt `&mut self.seat_state` zurück.
            - `focus_changed(seat: &Seat<Self>, focused: Option<&WlSurface>)`: Aktualisiert den internen Fokus-Zustand. Informiert die Domänenschicht (`WindowManagementPolicyService`) über die Fokusänderung, die dann entscheidet, ob z.B. Fensterdekorationen (aktiv/inaktiv) angepasst werden müssen. Der `KeyboardHandle` sendet bereits `wl_keyboard.enter/leave`.
            - `cursor_image(seat: &Seat<Self>, image: CursorImageStatus)`: Aktualisiert `self.current_cursor_status`. Der Renderer zeichnet diesen Cursor an `self.pointer_location`. Bei `CursorImageStatus::Named`, wird `ThemingEngine` konsultiert, um den Cursor-Namen in eine Textur aufzulösen.
        - `DataDeviceHandler`, `ServerDndGrabHandler`: Implementierungen für Zwischenablage und Drag & Drop, die oft mit `Seat` und Fokus interagieren.
        - `XdgShellHandler`: Detailliert im Untermodul `system::compositor::xdg_shell`.
        - `LayerShellHandler`: Detailliert im Untermodul `system::compositor::layer_shell`.
        - `XdgActivationHandler`: Handhabt Aktivierungs-Tokens.
        - `OutputManagerHandler` (für `xdg-output`): Sendet logische Größe/Position an Clients.
        - `XwmHandler` (für XWayland): Handhabt X11-Fenster-Interaktionen.
- **Globale Erstellung**: Funktionen wie `create_core_compositor_globals`, `create_shm_global`, `create_xdg_shell_global` (aus `C1 System Implementierungsplan.md`) werden beim Start des Compositors aufgerufen, um die Wayland-Globals zu registrieren und in `DesktopState` zu speichern.
    

##### 1.2. Untermodul: `system::compositor::surface_management`

- **Struktur `SurfaceData`**
    - Wie in `C1 System Implementierungsplan.md` definiert, mit Feldern für `id (Uuid)`, `client_id`, `role`, `current_buffer_info: Option<AttachedBufferInfo>`, `texture_handle: Mutex<Option<Box<dyn RenderableTexture>>>` (wobei `RenderableTexture` aus `renderer_interface` kommt), `damage_buffer_coords`, `damage_surface_coords` (transformierter Schaden), `opaque_region_surface_local`, `input_region_surface_local`, `parent`, `children`, Hooks, `surface_viewporter_state`, `surface_presentation_state`, `surface_scale_factor`.
    - **`AttachedBufferInfo { buffer: WlBuffer, scale: i32, transform: Transform, dimensions: Size<i32, SmithayBuffer> }`**
    - Methoden: `new`, `set_role`, `attach_buffer`, `take_damage_buffer_coords`.
- **Funktionen**: `get_surface_data(surface: &WlSurface) -> Option<Arc<StdMutex<SurfaceData>>>`.

##### 1.3. Untermodul: `system::compositor::shm`

- Handhabt `wl_shm`-Protokoll (SHM-Puffer).
- `ShmError` und Integration in `DesktopState` (Implementierung von `ShmHandler`, `BufferHandler`, `GlobalDispatch<WlShm, _>`).

##### 1.4. Untermodul: `system::compositor::xdg_shell`

Implementiert das `xdg_shell`-Protokoll für Toplevel-Fenster und Popups.

- **Fehler**: `XdgShellError` (z.B. `InvalidSurfaceRole`, `WindowHandlingError`, `InvalidAckConfigureSerial`).
- **Struktur `NovaWindowElement` (anstelle von `ManagedToplevel`/`ManagedPopup` aus C1, zur direkten Nutzung mit `Space<NovaWindowElement>`):**
    - Implementiert `smithay::desktop::WindowElement`.
    - Felder: `id: DomainWindowIdentifier`, `xdg_toplevel: Option<ToplevelSurface>`, `xdg_popup: Option<PopupSurface>`, `x11_surface: Option<X11Surface>`, `layer_surface: Option<LayerSurface>`, `current_geometry: RectInt`, `workspace_id: Option<WorkspaceId>`, `is_mapped: bool`.
    - Methoden: `new_toplevel`, `new_popup`, `wl_surface()`.
- **`XdgShellHandler` für `DesktopState`**:
    - `new_toplevel(surface: ToplevelSurface)`:
        1. Erstellt `DomainWindowIdentifier`.
        2. Ruft `domain::window_management_policy::WindowManagementPolicyService::get_initial_window_geometry()` auf, um initiale Geometrie und Workspace zu bestimmen.
        3. Erstellt `NovaWindowElement::new_toplevel(surface, domain_id)`.
        4. Speichert `XdgToplevelSurfaceData` in `surface.wl_surface().data_map()`.
        5. Sendet initiale `configure`-Events an den Client (`surface.send_configure()`).
        6. Fügt das `NovaWindowElement` zu `DesktopState.space` und `DesktopState.windows` hinzu (`DesktopState.map_window()`).
        7. Informiert `domain::workspaces::WorkspaceManagerService` über das neue Fenster.
    - `new_popup(surface: PopupSurface, _client_data: &XdgWmBaseClientData)`:
        1. Erstellt `NovaWindowElement::new_popup(...)`.
        2. Berechnet Popup-Geometrie basierend auf `PositionerState` und Elter-Geometrie.
        3. Sendet `configure`-Events.
        4. Fügt zu `DesktopState.popups` (PopupManager) hinzu.
    - `map_toplevel(surface: &ToplevelSurface)`: Wird aufgerufen, wenn der Client die Oberfläche mappen will. Setzt `window.is_mapped = true`. Informiert Domänenschicht (Workspace-Zuweisung). Aktualisiert `Space`.
    - `unmap_toplevel(surface: &ToplevelSurface)`: Setzt `window.is_mapped = false`. Informiert Domänenschicht. Entfernt ggf. aus `Space`.
    - `ack_configure(surface: WlSurface, configure_data: XdgSurfaceConfigure)`: Verarbeitet Bestätigung vom Client. Aktualisiert `SurfaceCachedState`.
    - **Request-Handler** (z.B. `toplevel_request_set_title`, `toplevel_request_set_maximized`, `toplevel_request_move`):
        1. Findet das zugehörige `NovaWindowElement` über `surface.wl_surface()`.
        2. Aktualisiert den internen Zustand des `NovaWindowElement` (z.B. Titel, angeforderter maximierter Zustand).
        3. Für Zustandsänderungen, die eine Policy-Entscheidung erfordern (z.B. Maximieren, Move, Resize): Ruft `domain::window_management_policy` auf.
        4. `system::window_mechanics` wendet die neue Geometrie/den neuen Zustand an und sendet `configure`-Events an den Client.
        5. Für interaktive Moves/Resizes: Startet einen Grab über `Seat::start_pointer_grab` (siehe `system::input` und `system::window_mechanics`).
    - `toplevel_destroyed(toplevel: ToplevelSurface)`: Bereinigt das `NovaWindowElement` aus `DesktopState.space` und `DesktopState.windows`. Informiert Domänenschicht.
    - `popup_destroyed(popup: PopupSurface)`: Analog für Popups.

##### 1.5. Untermodul: `system::compositor::renderer_interface`

- Definiert abstrakte Traits `FrameRenderer` und `RenderableTexture` sowie `RenderElement` Enum (wie in `C1 System Implementierungsplan.md`). Dies entkoppelt die Compositor-Logik von spezifischen Rendering-Backends (z.B. GLES2, Vulkan).

##### 1.6. Interaktion Compositor mit Domänenschicht (Fenstermanagement)

- Der `DesktopState` hält einen `Arc<TokioMutex<dyn WindowManagementPolicyService>>`.
- Wenn ein neues Fenster gemappt wird (`XdgShellHandler::map_toplevel`) oder ein Workspace-Layout sich ändert (Event von `WorkspaceManagerService`):
    1. Der Compositor (oder `system::window_mechanics`) ruft `window_policy_service.calculate_workspace_layout(workspace_id, windows_on_ws, available_area, ...).await`.
    2. Das Ergebnis (`WorkspaceWindowLayout`) enthält die Zielgeometrien für alle Fenster.
    3. Der Compositor (via `system::window_mechanics`) aktualisiert die `current_geometry` der `NovaWindowElement`s und sendet `configure`-Events an die Wayland-Clients.

##### 1.7. Smithay Typen und ihre Verwendung (Beispiele)

- **`DisplayHandle`**: Wird verwendet, um Globals zu erstellen, Clients zu flushen, den Event-Loop-Deskriptor zu erhalten.
- **`CompositorState`**: Verwaltet `wl_compositor` und `wl_subcompositor` Globals und Client-Zustände.
- **`XdgShellState`**: Verwaltet `xdg_wm_base` Global und Client-Zustände.
- **`ToplevelSurface`, `PopupSurface`**: Smithay-Repräsentationen von XDG-Oberflächen, die Methoden zum Senden von `configure`-Events, Setzen von Zuständen (maximiert, fokussiert etc.) bereitstellen.
- **`SurfaceAttributes`**: Wird im `CompositorHandler::commit` verwendet, um angehängte Puffer, Schadenregionen etc. abzurufen.
- **`Space<NovaWindowElement>`**: Hauptkomponente von Smithay zur Verwaltung von Fenstern im 2D-Raum, inklusive Stapelreihenfolge, Output-Zuordnung und Schadensberechnung für das Rendering.
- **`Output`**: Repräsentiert einen physischen Monitor. `DesktopState.space` verwaltet eine Liste von `Output`s.
- **`Seat`**: Repräsentiert einen Satz von Eingabegeräten. `KeyboardHandle`, `PointerHandle`, `TouchHandle` werden verwendet, um Wayland-Events an Clients zu senden.

#### 2. Modul: `system::input` (Libinput-basierte Eingabeverarbeitung)

Dieses Modul verarbeitet Eingaben von Tastaturen, Mäusen, Touchpads etc.

##### 2.1. Untermodul: `system::input::seat_manager`

- **`DesktopState` (Erweiterung für Input):** Hält `SeatState<Self>`, `Seat<Self>`, `seat_name`, `keyboard_data_map: HashMap<String, XkbKeyboardData>`, `current_cursor_status`, `pointer_location`.
- **`SeatHandler` für `DesktopState`**:
    - `focus_changed(seat: &Seat<Self>, focused: Option<&WlSurface>)`: Aktualisiert internen Fokus, benachrichtigt Domäne.
    - `cursor_image(seat: &Seat<Self>, image: CursorImageStatus)`: Aktualisiert `current_cursor_status`. Der Renderer verwendet dies und `pointer_location`.
- **Funktion `create_seat(state: &mut DesktopState, ...)`**: Erstellt `Seat` und fügt Capabilities (Tastatur, Zeiger, Touch) hinzu, wenn die entsprechenden Geräte vom Backend gemeldet werden.

##### 2.2. Untermodul: `system::input::libinput_handler`

- **`LibinputSessionInterface`**: Implementiert `smithay::backend::input::LibinputInterface` für das Öffnen/Schließen von Geräten (interagiert mit `systemd-logind` oder `libseat`).
- **`init_libinput_backend(...)`**: Erstellt `LibinputInputBackend`.
- **`process_input_event(desktop_state: &mut DesktopState, event: InputEvent<LibinputInputBackend>, seat_name: &str)`**: Haupt-Dispatcher für libinput-Events.
    - `DeviceAdded`/`DeviceRemoved`: Aktualisiert Seat-Capabilities.
    - Leitet spezifische Events (Keyboard, Pointer, Touch, Gesture) an die Übersetzer-Funktionen weiter.

##### 2.3. Untermodul: `system::input::keyboard`

- **`XkbKeyboardData { context, keymap, state, repeat_timer, ... }`**: Verwaltet XKB-Kontext, Keymap und Zustand pro Tastatur.
- **`handle_keyboard_key_event(...)`**:
    1. Aktualisiert `xkbcommon::State`.
    2. Ruft `KeyboardHandle::modifiers()` und `KeyboardHandle::key()` auf, um Wayland-Events an den Client mit Fokus zu senden.
    3. Handhabt Tastenwiederholung mit `calloop::TimerHandle`.
- **`set_keyboard_focus(desktop_state: &mut DesktopState, ..., surface: Option<&WlSurface>, serial: Serial)`**: Ruft `KeyboardHandle::set_focus()`.

##### 2.4. Untermodul: `system::input::pointer`

- **`handle_pointer_motion_event(...)`**:
    1. Aktualisiert `DesktopState.pointer_location`.
    2. Findet die Oberfläche unter dem Cursor (`find_surface_and_coords_at_global_point` iteriert über `DesktopState.space.elements_under(pos)`).
    3. Ruft `PointerHandle::motion()` auf (Smithay sendet `enter`/`leave` und `motion`).
- **`handle_pointer_button_event(...)`**:
    1. Ruft `PointerHandle::button()`.
    2. Wenn Taste gedrückt: Löst ggf. Fokusänderung (`set_keyboard_focus`) oder Start einer interaktiven Fensteroperation (`system::window_mechanics` startet Grab via `Seat::start_pointer_grab`) aus.
- **`handle_pointer_axis_event(...)`**: Ruft `PointerHandle::axis()`.

##### 2.5. Untermodul: `system::input::touch`

- Handhabt Touch-Events (`Down`, `Up`, `Motion`, `Frame`, `Cancel`) analog zur Zeigerverarbeitung, aber pro Touchpunkt (`slot_id`).
- Verwaltet den Fokus für jeden aktiven Touchpunkt.

#### 3. Protokoll-Implementierungen (Systemschicht-Perspektive)

- **D-Bus**: Die `system::dbus_interfaces` Clients (z.B. `UPowerClientService`) laufen als asynchrone Tasks, abonnieren D-Bus-Signale und stellen `async fn`-Methoden für Anfragen bereit. Ergebnisse/Events werden über den `system::event_bridge` (z.B. `tokio::sync::broadcast`) an andere System- oder Domänenkomponenten gesendet. Der `FreedesktopNotificationsServer` implementiert die D-Bus-Schnittstelle und ruft intern `domain::user_centric_services::NotificationService` auf.
- **XDG Desktop Portals**: Das `system::portals`-Backend implementiert die D-Bus-Schnittstellen für Portale. Bei Methodenaufrufen (z.B. `OpenFile`), die eine UI-Interaktion erfordern, kommuniziert es mit der UI-Schicht (z.B. über einen dedizierten Mechanismus oder den `SystemEventBridge`, um einen Dialog anzufordern) und wartet auf die Antwort, bevor es dem Portal-Client antwortet. Für Screenshots/ScreenCast interagiert es mit `system::compositor::screencopy` und PipeWire.
- **MCP**: Der `system::mcp_client::DefaultSystemMcpService` nutzt `McpConnectionManager`, um Verbindungen zu MCP-Servern (lokal/remote) herzustellen und zu verwalten. Er nimmt Anfragen von `domain::user_centric_services::AIInteractionLogicService` entgegen, formuliert MCP-Nachrichten, sendet sie über `mcp_client_rs::McpClient`, verarbeitet Antworten und leitet Notifications/Ergebnisse zurück an die Domänenschicht (via `McpClientSystemEvent` über den `SystemEventBridge`). API-Schlüssel werden vom `SecretsServiceClientService` geholt.

#### 4. Implementierbare Lösungen (Systemschicht-Code-Skizzen)

**Beispiel: `DesktopState` implementiert `CompositorHandler` (Auszug `commit`)**

Rust

```
// In src/system/compositor/core/handlers.rs (oder state.rs)
impl CompositorHandler for DesktopState {
    fn compositor_state(&mut self) -> &mut CompositorState {
        &mut self.compositor_state
    }

    fn client_compositor_state<'a>(&self, client: &'a Client) -> &'a CompositorClientState {
        // Annahme: ClientCompositorData ist in Client::data_map() gespeichert
        &client.get_data::<crate::system::compositor::core::state::ClientCompositorData>().unwrap().compositor_state
    }

    fn commit(&mut self, surface: &WlSurface) {
        tracing::debug!(surface_id = ?surface.id(), "Commit for WlSurface");

        // Schadenverfolgung und Puffer-Management mit Smithay-Helpern
        if let Err(err) = smithay::wayland::compositor::handle_commit_accumulate_damage_states(surface, |_, states| {
            // Zugriff auf SurfaceData, das an `states.data_map` hängt
            let data_guard = SurfaceData::from_states(states); // Hilfsmethode
            if let Some(mut data) = data_guard {
                data.update_buffer_info_from_states(states); // Aktualisiert current_buffer_info
            }
        }) {
            tracing::warn!("Error during commit for surface {:?}: {}", surface.id(), err);
        }

        // Finde das NovaWindowElement, das diese WlSurface repräsentiert
        let mut window_to_damage: Option<Arc<NovaWindowElement>> = None;
        for win_element_arc in self.space.elements() { // Iteriere über Elemente im Space
            if win_element_arc.wl_surface().as_ref() == Some(surface) {
                window_to_damage = Some(win_element_arc.clone());
                break;
            }
        }
        // Alternativ, wenn SurfaceData eine Referenz/ID zum NovaWindowElement hält:
        // let surface_data = SurfaceData::from_surface(surface);
        // let window_to_damage = surface_data.and_then(|sd| self.windows.get(&sd.domain_id)).cloned();


        if let Some(window_arc) = window_to_damage {
            // Markiere das Fenster im Space als beschädigt, damit es neu gezeichnet wird.
            // Smithay's Space kann dies oft automatisch handhaben, wenn der Schaden
            // auf der WlSurface korrekt registriert wurde.
            // Expliziter Schaden am Space-Element:
            self.space.damage_window(&window_arc, None, None);
        } else {
            // Layer-Surfaces, Cursor-Surfaces etc. müssen ggf. anders behandelt werden.
            // Für Popups verwaltet PopupManager den Schaden.
            if self.popups.surface_under(self.pointer_location, WindowSurfaceType::Wayland).map_or(false, |(p, _)| p.wl_surface() == surface) {
                 // Popup unter Cursor, PopupManager sollte Schaden handhaben
            } else if let Some(layer) = self.layer_shell_state.layer_for_surface(surface) {
                // Layer Surface Schaden
                layer_map_for_output(layer.output()).damage_surface(surface, (0,0), None);
            }
            // Hier könnte auch der Cursor-Surface-Commit behandelt werden.
        }

        // Wenn es sich um eine XDG-Oberfläche handelt, führt XdgShellHandler::surface_commit weitere Aktionen aus.
        // Smithay leitet den Commit oft automatisch an den XdgShellHandler weiter, wenn die Rolle gesetzt ist.
        // Manuelles Aufrufen ist selten nötig, außer für sehr spezifische Logik.
        if smithay::wayland::shell::xdg::is_xdg_surface(surface) {
            if let Err(e) = smithay::wayland::shell::xdg::handle_commit_xdg(surface, self) {
                 tracing::warn!("XDG commit handling failed for {:?}: {}", surface, e);
            }
        }
        // Ähnlich für wlr-layer-shell
        if smithay::wayland::shell::wlr_layer::is_layer_surface(surface) {
             if let Err(e) = smithay::wayland::shell::wlr_layer::handle_commit_layer(surface, self) {
                 tracing::warn!("Layer-shell commit handling failed for {:?}: {}", surface, e);
             }
        }
    }
    // ... (new_surface, destroyed etc.)
}
```

**Beispiel: `DesktopState` implementiert `SeatHandler` (Auszug `cursor_image`)**

Rust

```
// In src/system/input/seat_manager.rs (oder wo SeatHandler implementiert wird)
impl SeatHandler for DesktopState {
    type KeyboardFocus = WlSurface;
    type PointerFocus = WlSurface;
    type TouchFocus = WlSurface;

    fn seat_state(&mut self) -> &mut SeatState<Self> {
        &mut self.seat_state
    }

    fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&WlSurface>) {
        tracing::debug!(seat_name = %seat.name(), new_focus = ?focused.map(|s| s.id()), "Keyboard focus changed (SeatHandler)");
        // Logik hier sollte sich auf Compositor-interne Reaktionen auf den Fokuswechsel konzentrieren.
        // Die eigentliche Benachrichtigung des Clients (wl_keyboard.enter/leave) erfolgt
        // durch KeyboardHandle::set_focus().
        // Hier könnte man z.B. das aktive Fenster in der Domäne aktualisieren.
        let domain_window_id_option = focused.and_then(|s| {
            self.windows.iter().find_map(|(domain_id, window_element)| {
                if window_element.wl_surface().as_ref() == Some(s) {
                    Some(domain_id.clone())
                } else {
                    None
                }
            })
        });

        let workspace_manager = self.workspace_manager_service.clone(); // Arc<TokioMutex<...>>
        let focus_id_clone = domain_window_id_option.clone();
        // Dieser Aufruf muss non-blocking sein oder in einem Task erfolgen,
        // da wir uns im calloop Event-Handler befinden.
        // Hier vereinfacht als direkter Aufruf, in Realität ggf. über Kanal oder spawn_blocking.
        // tokio::runtime::Handle::current().block_on(async move {
        //     if let Err(e) = workspace_manager.lock().await.notify_keyboard_focus_changed(focus_id_clone).await {
        //         tracing::error!("Failed to notify domain about focus change: {}", e);
        //     }
        // });
        // Besser: Ein dedizierter SystemLayerEvent wird gesendet, auf den ein Domänen-Adapter hört.
         if let Some(bridge) = crate::system::event_bridge::global_system_event_bridge_option() {
            bridge.publish(crate::system::event_bridge::SystemLayerEvent::FocusChanged {
                newly_focused_window_id: domain_window_id_option,
                seat_name: seat.name().to_string(),
            });
        }
    }

    fn cursor_image(&mut self, _seat: &Seat<Self>, image: CursorImageStatus) {
        tracing::trace!(status = ?image, "Request to set cursor image");
        let mut guard = self.current_cursor_status.lock().unwrap();
        *guard = image;
        // Der Renderer wird diesen Status im nächsten Frame verwenden, um den Cursor zu zeichnen.
        // Es ist nicht nötig, hier explizit neu zu zeichnen, da der Cursor typischerweise
        // als Overlay im Rendering-Loop gehandhabt wird.
    }
}
```

Diese Code-Skizzen illustrieren die Art der Implementierung und die Interaktion mit Smithay-Komponenten und Domänendiensten. Die tatsächliche Implementierung erfordert eine sorgfältige Handhabung von Lebenszeiten, Fehlerbedingungen und der asynchronen Natur vieler Operationen.

Die maximale Detailtiefe wird durch die fortlaufende Verfeinerung jeder Komponente, Methode und Datenstruktur erreicht, wobei stets auf die Vermeidung von Ambiguitäten und die Bereitstellung klarer, umsetzbarer Anweisungen geachtet wird.

#### Zusätzliche Details zu wichtigen Protokollen in der Systemschicht

- **`wlr-output-management-unstable-v1` (system::compositor::output_management_wlr)**:
    - `DesktopState` implementiert `smithay::wayland::output_manager::OutputManagementHandler`.
    - `create_configuration(serial)`: Erstellt `OutputConfigurationRequest` (speichert `serial` und Client). Sendet aktuellen Output-Zustand (Heads, Modes) an die neue Konfigurationsressource.
    - `apply(config_resource)`:
        1. Prüft `OutputConfigurationRequest.serial` gegen `DesktopState.global_output_serial`. Bei Mismatch: `cancelled` senden.
        2. Validiert die angeforderte Konfiguration in `OutputConfigurationRequest.pending_changes` (existieren Outputs/Modes? Ist Konfig plausibel?).
        3. Versucht, die Konfiguration auf die `Output`s in `DesktopState.space` anzuwenden (via `output.change_current_state(...)` oder direkter DRM-Interaktion).
        4. Bei Erfolg: `succeeded` senden, `DesktopState.global_output_serial` inkrementieren, neuen Zustand an alle Manager-Clients senden.
        5. Bei Fehler: `failed` senden, ggf. Rollback.
- **`wlr-foreign-toplevel-management-unstable-v1` (system::compositor::foreign_toplevel)**:
    - `DesktopState` implementiert `smithay::wayland::foreign_toplevel::ForeignToplevelHandler`.
    - Wenn neue XDG-Toplevels erstellt oder ihr Zustand (Titel, AppID, maximiert etc.) sich ändert, werden die entsprechenden `zwlr_foreign_toplevel_handle_v1`-Events an Clients gesendet.
    - Handhabt Anfragen von Clients wie `request_close`, `set_maximized` etc. und leitet diese an die XDG-Toplevel-Logik weiter.
- **PipeWire-Interaktion (`system::audio_management::client`)**:
    - Der `PipeWireClientService` startet einen dedizierten Thread für den PipeWire `MainLoop`.
    - Innerhalb dieses Threads lauscht ein `RegistryListener` auf neue Nodes (Sinks, Sources) und Streams.
        - Beim Erkennen eines neuen Audio-Nodes (z.B. `media.class == "Audio/Sink"`):
            - Proxy zum Node binden: `registry.bind::<pipewire::node::Node>(...)`.
            - Eigenschaften des Nodes abrufen (`node.params("Props")` für `channelVolumes`, `mute`; `node.info()` für Beschreibung etc.).
            - `AudioDevice`-Struktur erstellen und in `PipeWireClientService.devices` (RwLock-geschützte Map) speichern.
            - Einen `Listener` auf dem Node-Proxy für `param_changed` registrieren. Wenn `param_changed` für "Props" ausgelöst wird, `AudioDevice` aktualisieren und `AudioEvent::DeviceVolumeChanged` senden.
            - `AudioEvent::DeviceListChanged` senden.
        - Analog für Streams (`media.class == "Stream/Output/Audio"`).
    - Setter-Methoden (z.B. `set_device_volume`) in `PipeWireClientService`:
        - Diese Methoden sind `async` und werden vom Haupt-Tokio-Executor aufgerufen.
        - Sie senden eine Nachricht (z.B. `AudioCommand::SetVolume { id, vol, mute }`) über einen `tokio::sync::mpsc::channel` an den PipeWire-MainLoop-Thread.
        - Der PipeWire-Thread empfängt den Befehl, holt den Node-Proxy und ruft `node.set_param("Props", ...)` mit den neuen Werten auf. Die Antwort von PipeWire (Erfolg/Fehler der Operation) wird über den `param_changed`-Listener des Nodes empfangen und löst dann das entsprechende `AudioEvent` aus.

Diese detaillierte Vorgehensweise, die klare Trennung von Verantwortlichkeiten und die Nutzung der Stärken der jeweiligen Bibliotheken (Smithay, Zbus, PipeWire-rs) bilden das Rückgrat für eine robuste und wartbare Systemschicht.

**Übergeordnetes Ziel:** Entwicklung einer modernen, performanten, intuitiven, anpassbaren und KI-unterstützten Benutzeroberfläche für NovaDE, basierend auf GTK4 und den `gtk4-rs` Bindings, die nahtlos mit den tieferliegenden Domänen- und Systemschichten interagiert.

---

**Teil 1: Grundlagen der UI-Schicht und Kern-Shell-Komponenten**

**I. Grundlagen der UI-Schicht (Wiederholung und Vertiefung)**

1. **Technologie-Stack (Verbindlich für UI):**
    - **GUI-Toolkit:** GTK4 mit `gtk4-rs` Bindings.
        - **Untersuchungsbedarf:**
            - Best Practices für die Strukturierung großer GTK4/Rust-Anwendungen (z.B. Aufteilung in wiederverwendbare Widgets, logische Module für UI-Bereiche).
            - State-Management-Patterns innerhalb von GTK4 (z.B. Model-View-ViewModel (MVVM)-ähnliche Ansätze, Komposition, effektive Nutzung von GTK-Properties und Bindings).
            - Fortgeschrittene Widget-Erstellung: Erben von GTK-Klassen, `#[derive(Boxed, Clone)]` für komplexe Daten in Signalen, `glib::ObjectSubclass` für benutzerdefinierte Widgets.
            - Effizienter Umgang mit dem GTK4-Event-Loop und Integration mit Rusts `async/await` (speziell `glib::MainContext::spawn_local`, `glib::clone!` Makro für sichere Callbacks).
            - Performance-Implikationen verschiedener GTK-Layout-Container und Zeichenoperationen.
    - **Theming:** Anwendung der von `domain::theming` generierten CSS-Stile über `Gtk::CssProvider`.
        - **Untersuchungsbedarf:**
            - Mechanismen zur dynamischen CSS-Aktualisierung zur Laufzeit bei Theme-Änderungen (Neuanwendung des `CssProvider`).
            - Effiziente Anwendung von Design-Tokens (als CSS Custom Properties) auf GTK-Widgets.
            - Performance-Implikationen komplexer CSS-Selektoren und -Regeln in GTK.
            - Erstellung benutzerdefinierter GTK-Widgets, die optimal auf dynamisches Theming und CSS-Styling reagieren (z.B. eigene CSS-Namen und -Eigenschaften definieren).
2. **Interaktion mit unteren Schichten (UI-Perspektive):**
    - Nutzung der APIs und Event-Systeme der Domänen- und Systemschicht.
        - **Untersuchungsbedarf:**
            - Patterns für die Datenkonvertierung und Kommunikation zwischen UI-Typen (GTK-spezifisch) und Domänen-/System-Typen (generisches Rust).
            - Fehlerbehandlung: Wie werden Fehler aus tieferen Schichten in der UI dargestellt (z.B. `Gtk::InfoBar`, `Gtk::AlertDialog`)? Wie werden technische Fehlermeldungen in benutzerfreundliche übersetzt?
            - Asynchrone Aufrufe an Domänen-/System-Services und Aktualisierung der UI bei Antwort.
3. **Allgemeine UI/UX-Prinzipien (Visionstreu):**
    - **Konsistenz:** Einheitliches Erscheinungsbild und Verhalten über alle UI-Komponenten hinweg.
    - **Feedback:** Visuelles Feedback auf Benutzeraktionen (z.B. Button-Pressed-Zustände, Ladeindikatoren).
    - **Effizienz:** Minimierung der Klicks/Aktionen für häufige Aufgaben.
    - **Zugänglichkeit (Accessibility):** Einhaltung von a11y-Standards (ATK/AT-SPI).
        - **Untersuchungsbedarf:** GTK4-spezifische Accessibility-Features (z.B. `AccessibleRole`, `AccessibleProperty`), Beschriftung von Widgets, Tastaturnavigation. Teststrategien für Accessibility mit GTK4/Rust.
    - **Performance:** Flüssige Animationen (GTK4 Animations API), schnelle Reaktionszeiten, geringer Ressourcenverbrauch der UI.
        - **Untersuchungsbedarf:** Profiling-Werkzeuge für GTK4/Rust-Anwendungen (z.B. GTK Inspector, `perf`), Optimierung von Rendering-Pfaden, Vermeidung von UI-Blockaden durch langlaufende Operationen (Delegation an Hintergrund-Threads).
    - **Anpassbarkeit:** Benutzerdefinierte Konfiguration von Layouts, Widgets und Verhalten (Details in spezifischen Komponenten).

**II. Kern-Shell-UI-Komponenten (`ui::shell` - Teil 1)**

Für jede Komponente: spezifische Verantwortlichkeiten, GTK-Widget-Struktur, Interaktionen mit anderen Modulen, visuelle Design-Aspekte (basierend auf der "Finale Beschreibung") und Implementierungsdetails definieren.

1. **`PanelWidget` (Kontroll-/Systemleiste(n)):**
    - **Design:**
        - Positionierung (oben/unten, konfigurierbar über `domain::global_settings_and_state_management`).
        - Höhe, Transparenzoptionen (ggf. basierend auf Theme-Tokens).
        - "Leuchtakzent"-Effekt (CSS-basiert).
    - **GTK-Struktur:** `Gtk::Box` oder `Gtk::CenterBox` als Hauptcontainer. Module als Kind-Widgets.
    - **Module (als einzelne, wiederverwendbare GTK-Widgets):**
        - **`AppMenuButton`:**
            - **GTK-Struktur:** `Gtk::MenuButton` oder `Gtk::Button` mit `Gtk::PopoverMenu`.
            - **Darstellung:** Zeigt ein globales Anwendungsmenü (falls vom aktiven Fenster unterstützt/exportiert, z.B. über `GActionGroup` des `Gtk::ApplicationWindow`).
            - **Interaktion (UI-Seite):** Reagiert auf Fokusänderungen der Systemschicht (`system::compositor` gibt aktive App-Info).
        - **`WorkspaceIndicatorWidget` (im Panel):**
            - **GTK-Struktur:** `Gtk::Box` mit `Gtk::Button` oder benutzerdefinierten kleinen Indikator-Widgets pro Workspace.
            - **Darstellung:** Kompakte visuelle Repräsentation der "Spaces". Hervorhebung des aktiven Space.
            - **Interaktion (UI-Seite):** Lauscht auf Events von `domain::workspaces::WorkspaceManager` (Liste und aktiver Space). Löst Workspace-Wechsel im Manager aus.
        - **`ClockDateTimeWidget`:**
            - **GTK-Struktur:** `Gtk::Label` (für Zeit/Datum), ggf. `Gtk::Button` mit `Gtk::Popover` für Kalender.
            - **Darstellung:** Anzeige von Uhrzeit und Datum. Optionales Kalender-Popup bei Klick.
            - **Konfiguration:** Datums-/Zeitformate (aus `domain::global_settings_and_state_management`).
        - **`SystemTrayEquivalentWidget`:**
            - **GTK-Struktur:** `Gtk::Box` oder `Gtk::FlowBox` für Icons.
            - **Darstellung:** Handhabung von Status-Icons (z.B. via `StatusNotifierItem` über D-Bus).
            - **Untersuchungsbedarf (UI-Fokus):** Implementierung eines `StatusNotifierWatcher` in Rust, der `StatusNotifierItem`-Proxies verwaltet und entsprechende `Gtk::Image` oder `Gtk::Button` Widgets dynamisch erzeugt/entfernt. Umgang mit Klick-Events und Menüs der Tray-Items.
        - **`QuickSettingsButtonWidget`:**
            - **GTK-Struktur:** `Gtk::Button` oder `Gtk::ToggleButton`.
            - **Darstellung:** Icon-Button.
            - **Funktionalität:** Öffnet/Schließt das `QuickSettingsPanelWidget`.
        - **`NotificationCenterButtonWidget`:**
            - **GTK-Struktur:** `Gtk::Button` oder `Gtk::ToggleButton`.
            - **Darstellung:** Icon-Button, zeigt eine Badge (z.B. `Gtk::Overlay` mit `Gtk::Label`) für neue Benachrichtigungen.
            - **Interaktion (UI-Seite):** Lauscht auf Events von `domain::user_centric_services::NotificationService` (neue/gelesene Benachrichtigungen). Öffnet/Schließt `NotificationCenterPanelWidget`.
    - **Layout:** Konfigurierbare Anordnung der Module im Panel (z.B. links, zentriert, rechts) über `Gtk::CenterBox` oder geschachtelte `Gtk::Box`-Container.

---

**Teil 2: Fortsetzung Kern-Shell-UI und Globale UI-Elemente**

**II. Kern-Shell-UI-Komponenten (`ui::shell` - Teil 2)**

1. **Panel-Module (Fortsetzung):**
    - **`NetworkIndicatorWidget`:**
        - **GTK-Struktur:** `Gtk::MenuButton` mit Icon. Popover-Menü (`Gtk::Box` mit ListBox für Verbindungen).
        - **Darstellung:** Anzeige des Netzwerkstatus (Icon, SSID). Menü für Verbindungsmanagement.
        - **Interaktion (UI-Seite):** Lauscht auf D-Bus-Signale des `NetworkManager` (über `system::dbus::networkmanager_client`) und aktualisiert Icon/Label. Löst Aktionen (Verbinden/Trennen) über die Systemschicht-API aus.
    - **`PowerIndicatorWidget`:**
        - **GTK-Struktur:** `Gtk::MenuButton` mit Icon.
        - **Darstellung:** Anzeige des Akkustatus/Ladezustands. Menü für Energieoptionen.
        - **Interaktion (UI-Seite):** Lauscht auf D-Bus-Signale von `UPower` (über `system::dbus::upower_client`).
    - **`AudioIndicatorWidget`:**
        - **GTK-Struktur:** `Gtk::MenuButton` mit Icon, `Gtk::Scale` für Lautstärke im Popover.
        - **Darstellung:** Anzeige der Lautstärke, Stummschaltungsstatus. Menü für Audioeinstellungen/-geräte.
        - **Interaktion (UI-Seite):** Lauscht auf Events/Properties von `PipeWire` (über `system::audio`). Sendet Befehle (Lautstärke ändern, Mute) an `system::audio`.
2. **`SmartTabBarWidget` (Intelligente Tab-Leiste pro "Space"):**
    - **Design:** Horizontale Leiste, abgerundete obere Ecken für Tabs. Hervorhebung des aktiven Tabs mit Akzentfarbe.
    - **GTK-Struktur:** `Gtk::Notebook` (ggf. stark angepasst oder komplett eigene Implementierung basierend auf `Gtk::Box` und benutzerdefinierten `ApplicationTabWidget`s).
    - **`ApplicationTabWidget` (benutzerdefiniertes Widget):**
        - **GTK-Struktur:** `Gtk::Box` mit `Gtk::Image` (für App-Icon) und `Gtk::Label` (für Fenstertitel).
        - **Darstellung:** Stellt einen einzelnen Tab dar. Reagiert auf Hover-Effekte, Schließen-Button.
    - **Funktionalität:**
        - Anzeige von `ApplicationTabWidget`s für "angepinnte" Apps/Split-Views (aus `domain::workspaces` Konfiguration).
        - Dynamische Anzeige von Tabs für weitere, nicht gepinnte Anwendungen im aktuellen "Space".
        - Überlauf-Logik für viele Tabs (z.B. Scrollbuttons, Dropdown-Liste).
        - Kontextmenü für Tabs (`Gtk::PopoverMenu`): "Schließen", "Zu anderem Space verschieben".
    - **Interaktion (UI-Seite):** Lauscht auf Events von `domain::workspaces::WorkspaceManager` (Fenster im aktuellen Space, Änderungen an gepinnten Apps). Holt Fensterinformationen (Icon, Titel) von `system::compositor` (oder einer Abstraktionsebene darüber). Löst Aktionen im `WorkspaceManager` oder `system::compositor` aus.
3. **`QuickSettingsPanelWidget` (Ausklappbares Schnelleinstellungs-Panel):**
    - **Design:** Ausklappbares Overlay/Menü (`Gtk::Popover` oder benutzerdefiniertes Widget), das vom `QuickSettingsButtonWidget` geöffnet wird.
    - **GTK-Struktur:** `Gtk::Box` mit verschiedenen Einstellungs-Widgets (z.B. `Gtk::Switch` für Dark Mode, `Gtk::Scale` für Lautstärke, `Gtk::ComboBoxText` für WLAN).
    - **Inhalt:** Schnellumschalter und -regler für WLAN, Bluetooth, Lautstärke, Dark Mode, etc.
    - **Interaktion (UI-Seite):** Liest und schreibt Werte über die entsprechenden Systemschicht-Schnittstellen (z.B. `system::dbus`, `system::audio`, `domain::theming::ThemingEngine` für Dark Mode).
4. **`WorkspaceSwitcherWidget` (Adaptive linke Seitenleiste):**
    - **Design:** Vertikale Leiste. Im eingeklappten Zustand nur `SpaceIconWidget`s. Aufklappbar (Mouse-Over/Geste) mit Namen/Vorschau der Spaces. Hervorhebung des aktiven Space.
    - **GTK-Struktur:** `Gtk::StackSidebar` oder `Gtk::ListBox` für die Icons/Namen. `Gtk::Revealer` für das Aufklappen.
    - **`SpaceIconWidget` (benutzerdefiniertes Widget):**
        - **GTK-Struktur:** `Gtk::Button` mit `Gtk::Image` (für App-Icon der gepinnten App oder benutzerdefiniertes Icon).
        - **Darstellung:** Visuelle Repräsentation eines einzelnen Space.
    - **Funktionalität:** Schnelle Navigation zwischen "Spaces". Drag & Drop von Fenstern auf Space-Icons zum Verschieben (im aufgeklappten Zustand mit Vorschau).
    - **Interaktion (UI-Seite):** Lauscht auf Events von `domain::workspaces::WorkspaceManager`. Löst Workspace-Wechsel und Fensterverschiebungen im Manager aus.
5. **`QuickActionDockWidget` (Konfigurierbares Schnellaktionsdock):**
    - **Design:** Schwebend oder am Bildschirmrand andockbar (konfigurierbar über `domain::global_settings_and_state_management`).
    - **GTK-Struktur:** `Gtk::Box` oder `Gtk::FlowBox`.
    - **`DockItemWidget` (benutzerdefiniertes Widget):**
        - **GTK-Struktur:** `Gtk::Button` mit `Gtk::Image` (App-Icon) und ggf. `Gtk::Label`.
        - **Darstellung:** Repräsentiert Apps, Dateien, Aktionen.
    - **Funktionalität:** Drag & Drop von Apps/Dateien ins Dock. Intelligente Vorschläge. Tastaturbedienung.
    - **Interaktion (UI-Seite):** Liest Konfiguration aus `domain::global_settings_and_state_management`. Startet Apps über die Systemschicht.

**III. Globale UI-Elemente und -Systeme**

1. **`NotificationCenterPanelWidget` (Benachrichtigungszentrum):**
    - **Design:** Ausklappbares Panel (`Gtk::Popover` oder eigenes Widget), typischerweise von der Systemleiste (`NotificationCenterButtonWidget`) erreichbar.
    - **GTK-Struktur:** `Gtk::ScrolledWindow` mit `Gtk::ListBox`.
    - **`NotificationWidget` (benutzerdefiniertes Widget):**
        - **GTK-Struktur:** `Gtk::Frame` oder `Gtk::Box` mit `Gtk::Image` (App-Icon), `Gtk::Label`s (App-Name, Zusammenfassung, Body), `Gtk::Box` für Aktionsbuttons.
        - **Darstellung:** Stellt eine einzelne Benachrichtigung dar. Layout anpassbar an Dringlichkeit/Aktionen.
    - **Funktionalität:** Anzeige einer Liste aktueller und historischer Benachrichtigungen. Möglichkeit zum Schließen/Interagieren mit Benachrichtigungen. "Bitte nicht stören"-Umschalter.
    - **Interaktion (UI-Seite):** Holt Benachrichtigungen von und sendet Aktionen an `domain::user_centric_services::NotificationService`. Lauscht auf dessen Events.
2. **`ui::theming_gtk` (Anwendung des Themes auf GTK-Widgets):**
    - **Verantwortlichkeiten:** Anwendung der von `domain::theming::ThemingEngine` generierten CSS-Stile auf alle GTK-Widgets.
    - **Kernfunktionen (UI-Seite):**
        - Abrufen des `AppliedThemeState` von der `ThemingEngine`.
        - Generieren einer CSS-Datei (String) aus den `resolved_tokens`.
        - Anwenden dieser CSS-Datei mittels `Gtk::CssProvider` auf den globalen `Gdk::Display` (`Gtk::StyleContext::add_provider_for_display`).
        - Abonnieren des `ThemeChangedEvent` von der `ThemingEngine`, um das CSS dynamisch zu aktualisieren.
    - **Untersuchungsbedarf (UI-Fokus):** Effiziente Generierung und Aktualisierung des CSS-Strings. Sicherstellung, dass benutzerdefinierte Widgets korrekt auf Theme-Änderungen reagieren und CSS-Klassen/Namen verwenden, die vom Theming-System beeinflusst werden können.
3. **`ui::components` (Sammlung wiederverwendbarer UI-Bausteine):**
    - **Verantwortlichkeiten:** Definition und Implementierung anwendungsspezifischer, aber wiederverwendbarer GTK4-Widgets, die das NovaDE-Erscheinungsbild und -Verhalten konsistent umsetzen.
    - **Beispiele (als `GtkWidget` Subklassen oder Kompositionen):**
        - **`StyledButtonWidget`:** Ein `Gtk::Button`, der konsistent mit dem NovaDE-Theming (Akzentfarben, Leuchteffekte, abgerundete Ecken) gestaltet ist und ggf. zusätzliche Style-Klassen für Varianten (z.B. "suggested-action", "destructive-action") bereitstellt.
        - **`ModalDialogWidget`:** Eine Subklasse von `Gtk::AlertDialog` oder eine benutzerdefinierte Komposition, die ein standardisiertes Aussehen und Verhalten für modale Dialoge (Header, Content-Bereich, Aktionsbuttons) sicherstellt.
        - **`SearchEntryWidget`:** Ein `Gtk::SearchEntry` mit konsistentem Design (z.B. abgerundete Ecken, integriertes Icon).
        - **`IconWidget`:** Ein Widget zur konsistenten Anzeige von Icons aus dem System-Theme mit Fallback-Logik und Unterstützung für symbolische Icons, das `Gtk::Image` kapselt und vereinfacht.
    - **Untersuchungsbedarf (UI-Fokus):** Identifikation weiterer wiederverwendbarer Komponenten während der Entwicklung der Haupt-UI-Module. Definition klarer APIs für diese Komponenten.

---

**Teil 3: Fenstermanagement-Frontend und Spezifische Ansichten**

**IV. `ui::window_manager_frontend` (UI-Aspekte des Fenstermanagements)**

Verantwortlichkeiten: Darstellung und Interaktion mit Fenstern, die von der Systemschicht (`system::compositor`) verwaltet werden. Dieses Modul stellt die visuellen Komponenten für das Fenstermanagement bereit.

1. **Client-Side Decorations (CSD) Logik und Darstellung:**
    - **Funktionalität (UI-Seite):**
        - Sicherstellung, dass von Anwendungen gezeichnete CSDs (z.B. via `Gtk::HeaderBar`) visuell mit dem globalen NovaDE-Theme harmonieren. Dies kann durch Setzen von globalen GTK-Einstellungen oder spezifischen CSS-Anweisungen für HeaderBars erreicht werden.
        - Anzeige von Fensteraktionen (Schließen, Maximieren, Minimieren) innerhalb der CSDs, falls die Anwendung diese nicht selbst bereitstellt oder falls eine konsistente Darstellung gewünscht ist (erfordert ggf. Interaktion mit `xdg-decoration`).
    - **Untersuchungsbedarf (UI-Fokus):** Wie kann das UI-Theming CSDs von GTK-Anwendungen (und ggf. Qt-Anwendungen via QGtkStyle) beeinflussen? Mechanismen zur Übernahme von Fensteraktionen, falls SSD bevorzugt wird.
2. **Server-Side Decorations (SSD) Rendering (falls vom `system::compositor` unterstützt und von der UI hier gezeichnet):**
    - **Funktionalität (UI-Seite, falls Rendering in der UI-Schicht stattfindet, was UNWAHRSCHEINLICH ist für SSDs – typischerweise macht das der Compositor):** Falls der Compositor nur die _Logik_ für SSDs bereitstellt, aber die _Darstellung_ an die Shell delegiert (seltenes Modell), müsste die UI hier Fensterrahmen und Titelleisten zeichnen.
    - **Design (UI-Seite):** Anpassbar und themenkonform. Verwendung von Theme-Tokens für Farben, Ränder, Schriftarten der Titelleiste.
    - **Interaktion (UI-Seite):** Eng mit `system::compositor` (für Fenstergeometrie, Zustand, Titel) und `domain::theming` (für Styling).
    - **Hinweis:** Typischerweise zeichnet der _Compositor_ SSDs. Die UI würde nur über `xdg-decoration` den Wunsch nach SSDs signalisieren oder deren Aussehen konfigurieren, falls das Protokoll dies zulässt.
3. **`OverviewModeWidget` (Fenster- und Workspace-Übersicht):**
    - **Design:**
        - Interaktive Kacheln mit Live-Vorschau (Thumbnails) der Fenster.
        - Hintergrund der Gesamtansicht abgedunkelt/unscharf, um den Fokus auf die Fensterkacheln zu legen.
        - Darstellung der Workspaces (z.B. als Miniaturen oder Leiste am Rand) für Drag & Drop von Fenstern.
    - **GTK-Struktur:** Benutzerdefiniertes Widget, das `Gtk::Fixed` oder einen Canvas-artigen Ansatz (`Gtk::DrawingArea` mit Cairo) für die flexible Anordnung und Skalierung der Fenster-Thumbnails verwendet. Animationen für Übergänge.
    - **Funktionalität (UI-Seite):**
        - Aktivierung durch Geste/Tastenkürzel (Signal von `system::input` weitergeleitet).
        - Fenster auswählen (führt zum Fokus des Fensters und Verlassen des Overview-Modus).
        - Fenster schließen (Button auf der Kachel).
        - Fenster per Drag & Drop zwischen Workspaces verschieben.
    - **Interaktion (UI-Seite):**
        - Holt Fensterliste und Thumbnails/Previews von `system::compositor` (z.B. über ein spezifisches Protokoll oder D-Bus-Schnittstelle, die der Compositor bereitstellt).
        - Interagiert mit `domain::workspaces::WorkspaceManager` für Workspace-Informationen und zum Auslösen von Fensterverschiebungen zwischen Workspaces.
4. **`AltTabSwitcherWidget` (Traditioneller Fensterwechsler):**
    - **Design:** Overlay-Anzeige (`Gtk::Window` vom Typ `Popup` oder `Tooltip`) mit Icons und Titeln der laufenden Anwendungen/Fenster für schnellen Wechsel.
    - **GTK-Struktur:** `Gtk::Box` mit `Gtk::ListBox` oder `Gtk::FlowBox` für die Anwendungs-Icons/-Labels.
    - **Funktionalität (UI-Seite):**
        - Aktivierung durch Alt+Tab (Signal von `system::input`).
        - Navigation durch die Liste mit Tab/Pfeiltasten.
        - Auswahl eines Fensters führt zum Fokus dieses Fensters und Schließen des Switchers.
    - **Interaktion (UI-Seite):** Holt Fensterliste und Fokusinformationen von `system::compositor`. Löst Fokuswechsel über `system::compositor` aus.

**V. Spezifische UI-Ansichten und -Dialoge**

1. **`ui::notifications_frontend` (Darstellung von Pop-up-Benachrichtigungen):**
    - **Verantwortlichkeiten:** Visuelle Präsentation von System- und Anwendungsbenachrichtigungen als Pop-ups.
    - **`NotificationPopupWidget` (benutzerdefiniertes Widget):**
        - **Design:** Dezent, im Dark Mode Stil mit Akzentfarbe je nach Dringlichkeit (aus `Notification.urgency`). Positionierung auf dem Bildschirm (z.B. obere rechte Ecke, konfigurierbar über `domain::global_settings_and_state_management`). Animationen für Erscheinen/Verschwinden.
        - **GTK-Struktur:** `Gtk::Window` (Typ `Popup`) oder ein Overlay-Layer. Enthält `Gtk::Image` (Icon), `Gtk::Label`s (App-Name, Zusammenfassung, Body), `Gtk::Box` für Aktionsbuttons.
        - **Funktionalität (UI-Seite):**
            - Anzeige von Icon, App-Name, Zusammenfassung, Body (optional), Aktionen (als `Gtk::Button`s).
            - Automatisches Schließen nach Timeout (konfigurierbar) oder manuell durch Klick auf Schließen-Button oder eine Aktion.
            - Stapeln mehrerer Pop-ups, falls sie schnell aufeinanderfolgen.
        - **Interaktion (UI-Seite):** Reagiert auf `NotificationPostedEvent` von `domain::user_centric_services::NotificationService`. Erstellt und zeigt ein `NotificationPopupWidget` an. Sendet Aktionen (Klick auf Aktionsbutton) zurück an den `NotificationService` (`invoke_action`).
2. **`ui::speed_dial` (Startansicht für leere Workspaces):**
    - **Verantwortlichkeiten:** Implementierung der GTK4-Oberfläche für die Speed-Dial-Funktionalität.
    - **Design:** Kachelbasierte Ansicht (`Gtk::FlowBox` oder `Gtk::GridView`). Jede Kachel (`Gtk::Button` mit `Gtk::Image` und `Gtk::Label`) repräsentiert einen Favoriten oder Vorschlag. Integrierte Suchfunktion (`Gtk::SearchEntry`). Anpassbares Layout (Größe/Anzahl der Kacheln).
    - **GTK-Struktur:** Hauptcontainer-Widget, das die Kacheln und das Suchfeld enthält.
    - **Interaktion (UI-Seite):**
        - Liest Favoriten und Konfiguration aus `domain::global_settings_and_state_management`.
        - Holt intelligente Vorschläge (kürzlich genutzte Apps/Dateien) von einer entsprechenden Domänen- oder Systemschicht-Komponente (ggf. `domain::user_centric_services::AIInteractionLogicService` oder eine dedizierte Verlaufs-Service).
        - Startet Anwendungen/öffnet Dateien über die Systemschicht.
3. **`ui::command_palette` (Kontextuelle Befehlspalette):**
    - **Verantwortlichkeiten:** GTK4-Implementierung der Befehlspaletten-UI.
    - **Design:** Overlay-Fenster (`Gtk::Window` Typ `Popup`, typischerweise zentriert oder am oberen Bildschirmrand), das bei Tastenkürzel (Super+Space, von `system::input` signalisiert) erscheint. `Gtk::Entry` für Texteingabe. `Gtk::ListBox` oder `Gtk::ListView` für dynamische Ergebnisliste mit Fuzzy-Matching.
    - **GTK-Struktur:** Eigenes `Gtk::Window` oder `Gtk::Popover`.
    - **Funktionalität (UI-Seite):**
        - Ausführung von Aktionen (repräsentiert als `GAction`s oder benutzerdefinierte Kommandos).
        - Starten von Apps.
        - Finden und direktes Ändern von Einstellungen.
        - Kontextsensitivität (zeigt relevante Befehle für aktive App/Desktop-Zustand).
    - **Interaktion (UI-Seite):**
        - Holt verfügbare Aktionen/Befehle von verschiedenen Quellen:
            - `domain::global_settings_and_state_management` (für Suche nach Einstellungen).
            - Systemschicht (für Starten von Apps, Ausführen von Systembefehlen).
            - Potenziell `domain::user_centric_services::AIInteractionLogicService` (für KI-gestützte Befehle oder Vorschläge).
            - Aktive Anwendung (falls sie Befehle über eine D-Bus-Schnittstelle oder `GAction`s exportiert).
        - Löst die ausgewählte Aktion aus.

---

**Teil 4: UI-Control-Center, Widgets-System und Übergreifende Aspekte**

**VI. `ui::control_center` (Modulare GTK4-Anwendung für Systemeinstellungen)**

1. **Verantwortlichkeiten:** Grafische Oberfläche zur Konfiguration aller Systemeinstellungen, die von `domain::global_settings_and_state_management` und anderen Domänen-/Systemdiensten verwaltet werden.
2. **Architektur (UI-Seite):**
    - Hauptfenster (`Gtk::ApplicationWindow`) mit einer Navigation (z.B. `Gtk::StackSidebar` oder `Gtk::ListBox` links) und einem Inhaltsbereich (`Gtk::Stack`), der das aktuell ausgewählte `SettingsModuleWidget` anzeigt.
    - Jede Einstellungskategorie (Erscheinungsbild, Netzwerk, Workspaces, etc.) ist ein eigenes, wiederverwendbares `SettingsModuleWidget` (benutzerdefiniertes GTK-Widget).
3. **Kernfunktionen (UI-Seite):**
    - **Navigation:** Klare Navigation zwischen den Einstellungsmodulen.
    - **Live-Vorschau:** Wo immer möglich, Änderungen an Einstellungen direkt in der UI des Control Centers oder auf dem Desktop (falls sicher) als Vorschau anzeigen.
    - **Suche:** Globale Suchfunktion (`Gtk::SearchEntry`) über alle Einstellungen hinweg (Interaktion mit `domain::global_settings_and_state_management`, um durchsuchbare Metadaten für Einstellungen zu erhalten).
    - **Zurücksetzen:** Buttons zum Zurücksetzen einzelner Einstellungen oder ganzer Module auf Standardwerte (löst Aktionen in `domain::global_settings_and_state_management` aus).
4. **Beispiel-Module (`SettingsModuleWidget` Implementierungen):**
    - **`AppearanceSettingsWidget`:**
        - **GTK-Struktur:** Enthält Widgets wie `Gtk::ComboBoxText` (für Theme-Auswahl), `Gtk::Switch` (für Dark Mode), Farbauswahl-Widget (für Akzentfarbe, z.B. `Gtk::ColorButton`), `Gtk::FontButton`, `Gtk::SpinButton` (für Skalierung).
        - **Interaktion (UI-Seite):** Liest und schreibt Einstellungen über `domain::theming::ThemingEngine` und `domain::global_settings_and_state_management::GlobalSettingsService`. Lauscht auf deren Events für dynamische Aktualisierungen.
    - **`NetworkSettingsWidget`:**
        - **GTK-Struktur:** `Gtk::ListBox` für verfügbare Netzwerke, Buttons für Hinzufügen/Bearbeiten, Detailansichten mit `Gtk::Entry` (Passwort), `Gtk::ComboBoxText` (Sicherheitstyp).
        - **Interaktion (UI-Seite):** Liest Netzwerkliste und -status von `system::dbus::networkmanager_client`. Löst Konfigurationsänderungen über dessen API aus.
    - **`WorkspaceSettingsWidget`:**
        - **GTK-Struktur:** `Gtk::Switch` (für dynamische Workspaces), `Gtk::SpinButton` (Standardanzahl), `Gtk::ComboBoxText` (Verhalten des Switchers).
        - **Interaktion (UI-Seite):** Liest und schreibt Einstellungen über `domain::global_settings_and_state_management::GlobalSettingsService`.
    - **Weitere Module:** Bluetooth, Audio, Energie, Eingabegeräte, Standardanwendungen, Datenschutz, Benutzerkonten, etc. Jedes Modul interagiert mit den entsprechenden Domänen- oder Systemschicht-APIs.
5. **Interaktion (UI-Seite):**
    - Primär mit `domain::global_settings_and_state_management::GlobalSettingsService` zum Lesen und Schreiben von Einstellungen (via `get_setting` und `update_setting`).
    - Für spezifische Einstellungen (Netzwerk, Audio, Theme) direkte Interaktion mit den jeweiligen Domänen- (`domain::theming`) oder Systemschicht-Schnittstellen (`system::dbus`, `system::audio`).

**VII. `ui::widgets` (System für anpassbare Widgets in Seitenleisten)**

1. **Verantwortlichkeiten:** Ermöglicht dem Benutzer das dynamische Platzieren und Konfigurieren von Informations-Widgets in den dafür vorgesehenen Seitenleisten.
2. **Komponenten und deren Untersuchungsbedarf (UI-Fokus):**
    - **`RightSidebarWidget` (und ggf. `LeftSidebarWidget`, falls dort auch Widgets platziert werden können):**
        - **Design:** Dezent transluzenter Hintergrund. Layout-Container für Widgets.
        - **GTK-Struktur:** `Gtk::Box` (vertikal), `Gtk::ScrolledWindow` falls nötig.
        - **Funktionalität (UI-Seite):** Container für `PlacedWidgetWidget`-Instanzen. Per Drag & Drop anpassbare Reihenfolge der Widgets.
    - **`WidgetManagerService` (Logische UI-Komponente, kein GTK-Widget):**
        - **Funktionalität (UI-Seite):** Verwaltet die Liste verfügbarer `ActualWidget`-Typen (Implementierungen des `ActualWidget`-Traits). Hält die Konfiguration (welche Widgets sind wo platziert, ihre spezifischen Einstellungen) und persistiert diese über `domain::global_settings_and_state_management`.
    - **`WidgetPickerPopover`:**
        - **GTK-Struktur:** `Gtk::Popover` mit einer `Gtk::ListBox` oder `Gtk::FlowBox`, die verfügbare Widget-Typen (Name, Icon, Beschreibung) anzeigt.
        - **Funktionalität (UI-Seite):** UI-Element zur Auswahl und Hinzufügung neuer Widgets zur Seitenleiste.
    - **`PlacedWidgetWidget` (benutzerdefiniertes Widget):**
        - **GTK-Struktur:** Wrapper-Widget (`Gtk::Frame` oder `Gtk::Box`), das ein spezifisches `ActualWidget` in der Seitenleiste anzeigt. Enthält Steuerelemente für Drag & Drop (via `Gtk::DragSource`, `Gtk::DropTarget`), Konfigurationszugriff (z.B. ein Einstellungs-Button, der einen Dialog öffnet) und Entfernen des Widgets.
    - **`ActualWidget` (Basis-Trait, das jedes konkrete Widget implementieren muss):**
        - **API-Definition (UI-Fokus):**
            - `fn get_gtk_widget(&self) -> Gtk::Widget;` (Gibt das darzustellende GTK-Widget zurück).
            - `fn get_config_spec() -> Vec<WidgetConfigOption>;` (Definiert konfigurierbare Optionen).
            - `fn apply_config(&mut self, config: WidgetConfigValues);`
            - `fn on_add(&mut self); fn on_remove(&mut self);` (Lebenszyklus-Hooks).
            - `fn get_name(&self) -> String; fn get_description(&self) -> String;`
        - **Beispiele für konkrete Widget-Implementierungen (als GTK-Widgets, die `ActualWidget` implementieren):**
            - **`ClockWidget`:** `Gtk::Label` oder komplexeres Layout.
            - **`CalendarWidget`:** `Gtk::Calendar` oder benutzerdefinierte Monatsansicht.
            - **`WeatherWidget`:** `Gtk::Box` mit `Gtk::Image` (Wettericon) und `Gtk::Label`s (Temperatur, Ort). Interagiert mit externen Wetter-APIs (über Systemschicht-Proxy oder direkt, falls sicher und mit `async` gehandhabt).
            - **`SystemMonitorWidget`:** `Gtk::Box` mit `Gtk::LevelBar`s oder kleinen Graphen (`Gtk::DrawingArea`) für CPU-, RAM-, Netzwerkauslastung. Liest Daten von Systemschicht-APIs oder `/proc` (asynchron!).
            - **`NotesWidget`:** `Gtk::TextView` oder `Gtk::Entry` für einfache Notizen.
            - **`MediaControllerWidget`:** `Gtk::Box` mit `Gtk::Image` (Album-Cover), `Gtk::Label`s (Titel, Künstler), `Gtk::Button`s (Play/Pause, Next, Prev). Interagiert mit MPRIS D-Bus-Schnittstelle (über `system::dbus`).
            - **`AIContextWidget` (optional):** Zeigt kontextbezogene KI-Informationen oder -Aktionen an. Interagiert mit `domain::user_centric_services::AIInteractionLogicService`.
3. **Untersuchungsbedarf (UI-Fokus):**
    - Definition einer klaren, erweiterbaren API für `ActualWidget`.
    - Implementierung eines robusten Drag & Drop-Systems für `PlacedWidgetWidget`s innerhalb der Seitenleisten.
    - Mechanismus zur (De-)Serialisierung der Widget-Konfigurationen.

**VIII. Übergreifende Untersuchungsbereiche und Abschluss für die UI-Schicht**

1. **State Management in der UI:**
    - **Problem:** Wie wird der Zustand von UI-Komponenten verwaltet, insbesondere wenn er von Daten aus tieferen Schichten abhängt oder über mehrere Widgets hinweg synchronisiert werden muss?
    - **Untersuchungsbedarf (UI-Fokus):**
        - Evaluation von Rust-spezifischen State-Management-Bibliotheken (falls vorhanden und passend für GTK, z.B. `relm4` Komponentenmodell, auch wenn NovaDE nicht komplett auf `relm4` basiert, können Ideen übernommen werden).
        - Adaption von Patterns wie MVVM (Model-View-ViewModel) oder MVC (Model-View-Controller) für GTK4/Rust. Nutzung von `glib::Object` Subclassing, um Modelle mit Properties zu erstellen, an die sich UI-Widgets binden.
        - Effektive Nutzung von GTK-Properties und Bindings (`GObject::bind_property`).
        - Verwendung von `glib::ParamSpec` für benutzerdefinierte Widget-Properties.
2. **Asynchrone Operationen und UI-Responsiveness:**
    - **Problem:** Wie werden langlaufende Operationen (z.B. Laden von Daten aus dem Netzwerk für ein Widget, komplexe Filterung von Benachrichtigungen) gehandhabt, ohne die UI zu blockieren?
    - **Untersuchungsbedarf (UI-Fokus):**
        - Konsequente Nutzung von `glib::MainContext::spawn_local` für UI-Aktualisierungen aus asynchronen Kontexten (`async fn` in Rust).
        - Kommunikation zwischen UI-Thread und Hintergrund-Threads (z.B. über `async_channel` oder `tokio::sync::mpsc`, wobei Ergebnisse dann im UI-Thread via `spawn_local` verarbeitet werden).
        - Design von UI-Feedback für laufende Operationen (z.B. `Gtk::Spinner`, `Gtk::ProgressBar`, Deaktivieren von Buttons).
3. **Teststrategien für die UI:**
    - **Problem:** Wie kann die Korrektheit und das Verhalten von GTK4-Widgets und der gesamten UI-Logik getestet werden?
    - **Untersuchungsbedarf (UI-Fokus):**
        - **Unit-Tests:** Testen der Logik von UI-Helferfunktionen und State-Management-Komponenten, die nicht direkt von GTK-Rendering abhängen. Mocking von Abhängigkeiten zu unteren Schichten und zu GTK-Interna (wo möglich).
        - **Widget-Tests:** Nutzung von GTK-Inspektionswerkzeugen (wie dem GTK Inspector) und Accessibility-APIs (`atk`) zur programmatischen Überprüfung von Widget-Zuständen, -Eigenschaften und -Hierarchien. Evaluierung von Frameworks oder Ansätzen wie `gtk4-rs-test-utils` (falls verfügbar/passend) oder Schreiben eigener Test-Helfer.
        - **Visuelle Regressionstests:** Evaluierung von Werkzeugen und Strategien für visuelle Vergleiche von UI-Zuständen (Screenshots). Dies ist oft komplex in dynamischen UIs.
        - **End-to-End-Tests (Integrationstests der UI):** Simulation von Benutzerinteraktionen auf Wayland-Ebene (sehr anspruchsvoll) oder über Accessibility-APIs und Überprüfung des UI-Verhaltens. Fokus auf kritische Benutzerpfade.
4. **Performance-Optimierung und Profiling der UI:**
    - **Problem:** Sicherstellung einer durchgehend performanten UI, insbesondere bei komplexen Layouts, vielen Widgets oder dynamischen Aktualisierungen.
    - **Untersuchungsbedarf (UI-Fokus):**
        - Identifikation und Nutzung von Profiling-Werkzeugen für Rust und GTK4 (z.B. `perf`, GTK-Debugger/Inspector, spezifische Rust-Profiler wie `flamegraph`).
        - Analyse von Rendering-Zeiten, Speicherverbrauch und CPU-Auslastung der UI-Komponenten.
        - Optimierung von Widget-Zeichnung (`Gtk::Snapshot` in GTK4), CSS-Anwendung und Datenbindung.
        - Lazy Loading von UI-Teilen oder Daten.
        - Verwendung von `Gtk::ListView` und `Gtk::GridView` für lange Listen anstelle von `Gtk::ListBox` oder `Gtk::FlowBox` wo Performance kritisch ist.
5. **Internationale und Lokalisierung (i18n/l10n) der UI:**
    - **Problem:** Vorbereitung der UI für die Übersetzung in verschiedene Sprachen und Anpassung an regionale Formate.
    - **Untersuchungsbedarf (UI-Fokus):**
        - Integration von Gettext (`gettext-rs` Crate) oder Fluent (`fluent-rs` Crate) mit GTK4/Rust.
        - Management von Übersetzungsdateien (`.po`, `.ftl`).
        - Sicherstellung, dass UI-Layouts mit unterschiedlich langen Texten umgehen können (Verwendung von GTK-Layout-Managern, die dynamische Größenanpassung unterstützen).
        - Formatierung von Zahlen, Daten und Zeiten gemäß der lokalen Einstellungen.
6. **Planungs- und Managementaspekte (UI-Fokus):**
    - **Priorisierung:** Welche UI-Komponenten und -Funktionen sind für einen ersten Prototyp/MVP (Minimum Viable Product) unerlässlich? (z.B. Panel, grundlegender Workspace-Switcher, einfache Fenster-Interaktion).
    - **Abhängigkeiten:** Welche UI-Komponenten hängen stark von der Fertigstellung bestimmter Domänen- oder Systemschichtfunktionen ab? (z.B. `NetworkIndicatorWidget` von `system::dbus::networkmanager_client`).
    - **Parallelisierung:** Welche UI-Module können parallel entwickelt werden? (z.B. `ControlCenter`-Module, verschiedene `ActualWidget`-Implementierungen).
    - **Design-Prozess:** Enge und kontinuierliche Zusammenarbeit mit UX/UI-Designern, um Mockups und Prototypen zu erstellen, zu validieren und Iterationen basierend auf Feedback durchzuführen. Verwendung von Werkzeugen, die Design-Spezifikationen (Farben, Abstände, Schriftarten als Tokens) an die Entwickler weitergeben können.
    - **Dokumentation:** Umfassende Dokumentation der UI-Komponenten, ihrer APIs, ihrer GTK-Struktur, ihrer Interaktionen und der Designentscheidungen dahinter.

Dieser detaillierte Recherche- und Untersuchungsplan für die UI-Schicht bildet die Grundlage für die erfolgreiche Konzeption und Implementierung der Benutzeroberfläche von NovaDE. Er dient als Leitfaden, um sicherzustellen, dass alle relevanten Aspekte berücksichtigt werden und eine hochwertige Benutzererfahrung entsteht.

**NovaDE Projektplan: Etappen und Aufgabenpakete**

**Etappe 0: Projekt-Setup und Fundamentale Infrastruktur**

- **Aufgabenpaket 0.1: Projektinitialisierung und Werkzeuge**
    - Einrichtung der Versionskontrolle (Git-Repository-Struktur für `novade-core`, `novade-domain`, `novade-system`, `novade-ui`).
    - Konfiguration des Build-Systems (Meson).
    - Definition der grundlegenden CI/CD-Pipeline (Formatierung mit `rustfmt`, Linting mit `clippy`, Basis-Builds).
    - Festlegung und Dokumentation von Coding-Styleguides und API-Design-Richtlinien.
    - Einrichtung der Entwicklungsumgebungen und Kommunikationskanäle.
- **Aufgabenpaket 0.2: Kernschicht – Basistypen und Fehlerbehandlung (`core::types`, `core::errors`)**
    - Implementierung fundamentaler Datentypen in `core::types` (`Point<T>`, `Size<T>`, `Rect<T>`, `RectInt`, `Color`, `Orientation`, Re-Export von `uuid::Uuid`, `chrono::DateTime<Utc>`).
    - Definition der Basis-Fehlerbehandlungsstrategie in `core::errors` (`CoreError` mit `thiserror`, `ColorParseError`, Richtlinien für Modul-spezifische Fehler).
    - Umfassende Unit-Tests für alle Typen und Fehlerdefinitionen.
- **Aufgabenpaket 0.3: Kernschicht – Logging und Konfiguration (`core::logging`, `core::config`)**
    - Implementierung der Logging-Infrastruktur in `core::logging` (`initialize_logging()` mit `tracing`, `LogFormat`, `LoggingError`).
    - Implementierung der Konfigurationsprimitive in `core::config` (`ConfigError`, `CoreConfig`-Struktur für TOML, `load_core_config()`, globaler Zugriff via `OnceCell`).
    - Unit-Tests für Logging-Initialisierung (konzeptionell) und Konfigurationsladen/-zugriff.
- **Aufgabenpaket 0.4: Kernschicht – Utilities (`core::utils`)**
    - Implementierung initial identifizierter, allgemeiner Hilfsfunktionen (z.B. `file_utils`, `string_utils`).
    - Definition spezifischer Fehler für Utilities, falls notwendig.
    - Umfassende Unit-Tests.

**Etappe 1: Domänenschicht (Domain Layer) – Definition der Kernlogik und -zustände**

- **Aufgabenpaket 1.1: Fundamentale Domänen-Typen und -Events (`domain::shared_types`, `domain::common_events`)**
    - Implementierung von `ApplicationId`, `UserSessionState`, `ResourceIdentifier`.
    - Implementierung von `UserActivityType`, `UserActivityDetectedEvent`, `ShutdownReason`, `SystemShutdownInitiatedEvent`.
- **Aufgabenpaket 1.2: Theming-Engine (`domain::theming`)**
    - Implementierung aller Theming-Datenstrukturen (von `TokenIdentifier` bis `ThemingConfiguration`).
    - Definition des `ThemingError`-Enums.
    - Implementierung der Logik für Token-Management (Laden, Validieren, Auflösungspipeline inklusive Akzentfarben, Fallback-Theme). (Dateizugriffe `async`).
    - Implementierung des `ThemingEngine`-Service-Traits und der `DefaultThemingEngine` (interner Zustand mit `tokio::sync::Mutex`, Event-Versand mit `tokio::sync::broadcast`).
- **Aufgabenpaket 1.3: Globale Einstellungen (`domain::global_settings_and_state_management`)**
    - Definition aller Einstellungsstrukturen (`GlobalDesktopSettings` etc.) und des `SettingPath`-Enums.
    - Definition des `GlobalSettingsError`-Enums.
    - Implementierung des `SettingsPersistenceProvider`-Traits und des `FilesystemSettingsProvider` (async, nutzt `core::config::ConfigServiceAsync`).
    - Implementierung des `GlobalSettingsService`-Traits und der `DefaultGlobalSettingsService` (interner Zustand mit `tokio::sync::RwLock`, Event-Versand).
- **Aufgabenpaket 1.4: Workspace-Verwaltung (`domain::workspaces`)**
    - `core`: `Workspace`-Entität, `WindowIdentifier`, `WorkspaceLayoutType`, `WorkspaceCoreError`, Event-Payloads.
    - `assignment`: Fensterzuweisungslogik, `WindowAssignmentError`.
    - `config`: `WorkspaceSnapshot`-Strukturen, `WorkspaceConfigProvider`-Trait und `FilesystemConfigProvider` (async). `WorkspaceConfigError`.
    - `manager`: `WorkspaceManagerService`-Trait und `DefaultWorkspaceManager` (async, Event-Versand). `WorkspaceEvent`-Enum.
- **Aufgabenpaket 1.5: Benachrichtigungs-Subsysteme (`domain::notifications_core`, `domain::notifications_rules`)**
    - `notifications_core`: `Notification`-Datenstrukturen, `NotificationInput`, `NotificationService`-Trait und `DefaultNotificationService` (async, interagiert mit `NotificationRulesEngine`). `NotificationError`. `NotificationEventEnum`.
    - `notifications_rules`: Regel-Datenstrukturen (`RuleCondition`, `RuleAction`, `NotificationRule`), `NotificationRulesProvider`-Trait und Implementierung. `NotificationRulesEngine`-Trait und Implementierung (async). `NotificationRulesError`.
- **Aufgabenpaket 1.6: KI-Interaktionslogik (`domain::user_centric_services::ai_interaction`)**
    - KI-Datenstrukturen (`AIInteractionContext`, `AIConsent`, `AIModelProfile`, `AttachmentData`). `AIInteractionError`.
    - `AIConsentProvider`- und `AIModelProfileProvider`-Traits und Implementierungen (async, nutzen `core::config`).
    - `AIInteractionLogicService`-Trait und `DefaultAIInteractionLogicService` (async). `AIInteractionEventEnum`.
- **Aufgabenpaket 1.7: Fensterverwaltungsrichtlinien (`domain::window_management_policy`)**
    - Policy-Datenstrukturen (`TilingMode`, `GapSettings`, `WindowSnappingPolicy`, `WorkspaceWindowLayout`). `WindowPolicyError`.
    - `WindowManagementPolicyService`-Trait und `DefaultWindowManagementPolicyService` (async, interagiert mit `GlobalSettingsService`). Implementierung der Layout-Algorithmen.

**Etappe 2: Systemschicht (System Layer) – OS-Interaktion und Technische Umsetzung**

- **Aufgabenpaket 2.1: Fundament des Wayland Compositors (`system::compositor`)**
    - `compositor::core`: `DesktopState`-Grundstruktur (mit Smithay-States), `CompositorHandler`, `SurfaceData`.
    - `compositor::shm`: SHM-Pufferbehandlung (`ShmHandler`, `ShmError`).
    - `compositor::xdg_shell`: `XdgShellHandler`, `ManagedWindow`-Struktur (implementiert `smithay::desktop::Window`), `XdgShellError`.
    - `compositor::renderer_interface`: Definition der abstrakten Renderer-Traits (`FrameRenderer`, `RenderableTexture`).
- **Aufgabenpaket 2.2: Eingabeverarbeitung (`system::input`)**
    - `input::seat_manager`: `SeatHandler`-Implementierung für `DesktopState`, `XkbKeyboardData`-Verwaltung.
    - `input::libinput_handler`: `LibinputInputBackend`-Initialisierung, `calloop`-Integration.
    - `input::keyboard`, `input::pointer`, `input::touch`: Event-Übersetzer, Fokuslogik für Basiseingaben.
    - Definition des `InputError`-Enums.
- **Aufgabenpaket 2.3: D-Bus Basisinfrastruktur und erste Dienste (`system::dbus_interfaces`)**
    - `dbus_interfaces::common`: `DBusConnectionManager` (`OnceLock` für Bus-Verbindungen), `DBusInterfaceError`.
    - `dbus_interfaces::upower_client`: Client für `org.freedesktop.UPower`. Typen, Proxies, Service-Implementierung, Event-Publishing.
    - `dbus_interfaces::logind_client`: Client für `org.freedesktop.login1`.
- **Aufgabenpaket 2.4: Hardware- und Protokollmanagement (Basis)**
    - `system::outputs`: Basis-Output-Verwaltung (`OutputDevice`), Implementierung der Handler für `wl_output` und `xdg-output-unstable-v1`.
    - `system::audio_management`: PipeWire-Client-Grundstruktur (`PipeWireClientService`), Verbindung und `MainLoop`-Management.
- **Aufgabenpaket 2.5: Event-Brücke (`system::event_bridge`)**
    - Implementierung des `SystemEventBridge` mit `tokio::sync::broadcast` für `SystemLayerEvent`.
    - Definition erster System-interner Events (z.B. `InputDeviceHotplugEvent`).

**Etappe 3: Systemschicht – Erweiterte Funktionen und Protokolle**

- **Aufgabenpaket 3.1: Erweiterte Compositor-Funktionen (`system::compositor`)**
    - `compositor::layer_shell`: Handler für `wlr-layer-shell-unstable-v1`.
    - `compositor::decoration`: Handler für `xdg-decoration-unstable-v1`.
    - `compositor::output_management`: Handler für `wlr-output-management-unstable-v1`.
    - `compositor::power_management`: Handler für `wlr-output-power-management-unstable-v1`.
    - `compositor::xwayland`: Basis-Integration für XWayland.
- **Aufgabenpaket 3.2: Weitere D-Bus-Schnittstellen (`system::dbus_interfaces`)**
    - `dbus_interfaces::network_manager_client`: Client für NetworkManager.
    - `dbus_interfaces::notifications_server`: Implementierung des `org.freedesktop.Notifications`-Servers.
    - `dbus_interfaces::secrets_service_client`: Client für `org.freedesktop.secrets`.
    - `dbus_interfaces::policykit_client`: Client für PolicyKit.
- **Aufgabenpaket 3.3: Vervollständigung Hardware-Management**
    - `system::audio_management`: Vollständige Implementierung von Geräte-/Stream-Erkennung, Lautstärkeregelung, Default-Geräte-Management.
    - `system::power_management`: Implementierung des `PowerManagementService` (DPMS, Idle-Timer, Interaktion mit `logind`).
- **Aufgabenpaket 3.4: Fortgeschrittene Systemdienste**
    - `system::mcp_client`: Implementierung des MCP-Clients, Prozessmanagement, API-Key-Handling.
    - `system::portals`: Implementierung der Backends für XDG FileChooser und Screenshot.
    - `system::window_mechanics`: Implementierung der technischen Fenster-Mechaniken (Layout-Anwendung, interaktive Operationen, Fokus).
    - `system::input::gestures`: Implementierung der Gestenerkennung.

**Etappe 4: Benutzeroberflächenschicht (UI Layer) – Darstellung und Interaktion**

- **Aufgabenpaket 4.1: UI-Grundgerüst und Kern-Shell-Elemente**
    - `ui::app_initializer`, `ApplicationState`, `MasterActionHandler`.
    - `ui::main_window` (Basis-Layout).
    - `ui::theming_gtk` (Anbindung an `domain::theming`).
    - `ui::shell::PanelWidget` (Basis-Panel, `AppMenuButton`, Uhr-Widget).
    - `ui::shell::WorkspaceSwitcherWidget` (Basis-Implementierung, Anbindung an `WorkspaceManagerService`).
- **Aufgabenpaket 4.2: Erweiterte Shell-Funktionen und Kern-Interaktionskomponenten**
    - `ui::shell::SmartTabBarWidget`.
    - `ui::shell::QuickSettingsPanelWidget` und Anbindung der System-Indikatoren (Netzwerk, Audio, Energie über Systemschicht-APIs).
    - `ui::shell::QuickActionDockWidget`.
    - `ui::command_palette` (Basis-Widget und Anbindung an `MasterActionHandler`).
    - `ui::notifications_frontend::NotificationPopupWidget` (Anzeige via `gtk4-layer-shell`).
    - `ui::shell::NotificationCenterPanelWidget`.
- **Aufgabenpaket 4.3: Fenstermanagement-UI und Systemeinstellungen**
    - `ui::window_manager_frontend::OverviewModeWidget`.
    - `ui::window_manager_frontend::AltTabSwitcherWidget`.
    - `ui::control_center` (Grundstruktur, erste Module wie "Erscheinungsbild" mit Anbindung an `GlobalSettingsService` und `ThemingEngine`).
    - `ui::speed_dial` (Startansicht).
- **Aufgabenpaket 4.4: Widgets und fortgeschrittene UI-Funktionen**
    - `ui::widgets::RightSidebarWidget` und Widget-System (WidgetManagerService, WidgetPicker).
    - Implementierung spezifischer Widgets (Kalender, Wetter, Systemmonitor).
    - Vollständige Integration von KI-Funktionen in die UI (Befehlspalette, kontextuelle Aktionen).
    - UI-Seite der XDG Desktop Portal-Nutzung (z.B. Dateiauswahldialoge über `system::portals`).

**Etappe 5: Integration, Tests, Verfeinerung und Release-Vorbereitung**

- **Aufgabenpaket 5.1: Schichtübergreifende Integration und Tests**
    - Durchführung umfassender Integrationstests für alle Kern-Workflows.
    - End-to-End-Szenariotests basierend auf `Beschreibung Nutzung.md`.
- **Aufgabenpaket 5.2: Performance-Analyse und -Optimierung**
    - Profiling kritischer Pfade (Compositor, Input, UI-Rendering, Startzeit).
    - Optimierung des Ressourcenverbrauchs.
- **Aufgabenpaket 5.3: UI/UX-Feinschliff und Benutzerfeedback**
    - Überprüfung der gesamten Benutzererfahrung auf Konsistenz, Intuitivität und Ästhetik.
    - Anpassung von Animationen, Layouts, Interaktionen.
    - Einholung und Verarbeitung von Benutzerfeedback (Alpha-/Beta-Tests).
- **Aufgabenpaket 5.4: Sicherheitsüberprüfungen und Dokumentation**
    - Sicherheitsaudit für KI-Integration, D-Bus-Schnittstellen, Portal-Backends, Geheimnisverwaltung.
    - Vervollständigung der Benutzer-, Entwickler- und Architekturdokumentation.
- **Aufgabenpaket 5.5: Release-Management**
    - Erstellung von Release Notes.
    - Vorbereitung der finalen Builds.

**Etappe 6: Deployment und Post-Release**

- **Aufgabenpaket 6.1: Paketierung und Distribution**
    - Erstellung von Paketen für Ziel-Distributionen (.deb, .rpm).
    - Evaluierung und ggf. Erstellung eines Flatpak-Pakets.
    - Testen der Installations- und Update-Prozesse.
- **Aufgabenpaket 6.2: Community-Aufbau und Wartung**
    - Einrichtung von Kanälen für Benutzer-Support und Feedback.
    - Etablierung von Prozessen für Bugfixing und die Veröffentlichung von Wartungsupdates.
    - Planung zukünftiger Feature-Releases.

---

Dieser Plan ist ein High-Level-Entwurf und muss im Laufe des Projekts weiter verfeinert und angepasst werden. Er dient jedoch als grundlegende Struktur für die Organisation der Entwicklungsaufwände.

Sie haben Recht, die bisherigen Spezifikationen konzentrieren sich auf die Kern-Desktop-Umgebung und lassen typische Desktop-Anwendungen wie einen Dateimanager, Texteditor, Bildbetrachter usw. außen vor. Die Frage, ob NovaDE eher ein spezialisierter Fenstermanager oder eine vollwertige Desktop-Umgebung mit eigenen Anwendungen sein soll, ist fundamental.

Basierend auf der Vision ("intuitive und KI-gestützte Benutzererfahrung", "optimiert für Entwickler, Kreative und alltägliche Nutzer") und den detaillierten UI-Beschreibungen (Control Center, Speed Dial etc.) deutet vieles darauf hin, dass NovaDE mehr als nur ein Fenstermanager sein soll. Es zielt auf eine **integrierte Erfahrung** ab.

**Was wäre noch für ein vollwertiges System nötig?**

Um NovaDE zu einem System zu machen, das mit GNOME oder KDE Plasma vergleichbar ist (als vollständige Desktop-Umgebungen), wären zusätzlich zu den bereits spezifizierten Komponenten mindestens folgende Elemente und Anwendungen notwendig:

**1. Kernanwendungen (Eigene oder angepasste Drittanwendungen):**

- **Dateimanager:**
    - Grundfunktionen: Durchsuchen von Verzeichnissen, Dateioperationen (Kopieren, Verschieben, Löschen, Umbenennen), Erstellen von Ordnern/Dateien, Vorschauen.
    - Integration mit NovaDE: Theming, "Spaces"-Bewusstsein (falls relevant), KI-Dateiaufgaben (Zusammenfassen, Analysieren), XDG-Portals für sicheren Zugriff.
    - Technologie: Wahrscheinlich GTK4 für Konsistenz.
- **Texteditor:**
    - Einfacher Editor für schnelle Notizen und Code-Snippets.
    - Syntax-Hervorhebung (ggf. über existierende Bibliotheken).
    - Theming-Integration.
- **Terminalemulator:**
    - Essentiell für Entwickler und Power-User.
    - Integration mit Shell-Features, ggf. Tabs, Split-Views.
    - Theming.
- **Bildbetrachter:**
    - Anzeige gängiger Bildformate.
    - Basis-Operationen (Drehen, Zoom).
- **Dokumentenbetrachter (PDF, etc.):**
    - Anzeige von PDFs und ggf. anderen Dokumentformaten.
- **Software-Center / App Store:**
    - Suchen, Installieren und Verwalten von Anwendungen (z.B. Flatpaks, native Pakete).
    - Integration mit Systemupdates.
- **Archivmanager:**
    - Erstellen und Entpacken von Archiven (zip, tar.gz etc.).
- **Systemmonitor (detaillierter):**
    - Ergänzend zum Widget, eine Anwendung zur detaillierten Anzeige von Prozessen, Ressourcenverbrauch, Netzwerkauslastung.
- **Mediaplayer (Audio/Video):**
    - Abspielen gängiger Multimedia-Formate.
    - Integration mit dem PipeWire-Backend der Systemschicht.

**2. System-Utilities und -Dienste (Erweiterungen):**

- **Druckerverwaltung:**
    - Einrichtung und Verwaltung von Druckern (oft über CUPS-Integration via D-Bus).
- **Benutzer- und Gruppenverwaltung:**
    - UI zur Verwaltung von Benutzerkonten.
- **Energieverwaltung (UI-Erweiterung):**
    - Detailliertere Einstellungen und Profile im Control Center als nur die Policies in der Domänenschicht.
- **Barrierefreiheits-Werkzeuge:**
    - Bildschirmlupe, Bildschirmtastatur, Screenreader-Integration (Orca). Die UI-Schicht muss ATK/AT-SPI unterstützen.
- **Backup-Lösung:**
    - System zur Sicherung von Benutzerdaten.
- **Login-Manager / Display-Manager (Greeter):**
    - Der Login-Bildschirm, der Benutzerauthentifizierung vor dem Start der Desktop-Session durchführt.
    - Muss mit `systemd-logind` und PAM integriert sein.
    - Sollte das NovaDE-Theming widerspiegeln.
- **Bildschirmsperre (Lock Screen):**
    - Sperrt die Sitzung bei Inaktivität oder manuell.
    - Benötigt Integration mit `logind`.
- **System-Update-Mechanismus (UI):**
    - Eine UI zur Benachrichtigung über und Durchführung von System- und Anwendungsupdates.
- **Zwischenablage-Manager (fortgeschritten):**
    - Verlauf, Anpinnen von Einträgen (aktuell ist nur die Basis-Daten-Device-Funktionalität in der Systemschicht skizziert).
- **Screenshot- und Screencast-Werkzeug (UI):**
    - Eine Benutzeroberfläche für die Screenshot-/Screencast-Funktionalität, die von `system::portals` oder `system::compositor::screencopy` bereitgestellt wird.
- **Farbwähler-Werkzeug (UI):**
    - Eine UI für die Farbauswahlfunktion des Screenshot-Portals.

**3. Entwicklungs- und Design-Philosophie für Anwendungen:**

- **Eigene Anwendungen vs. Kompatibilität:**
    - **Eigene Anwendungen:** Bieten die beste Integration mit dem NovaDE-Theming, den KI-Funktionen und der Designphilosophie. Erfordern aber erheblichen Entwicklungsaufwand.
    - **Kompatibilität mit GNOME/KDE-Apps:** NovaDE als Wayland-Compositor mit XWayland-Unterstützung wird GNOME (GTK) und KDE (Qt) Anwendungen grundsätzlich ausführen können. Die Herausforderung liegt im einheitlichen Erscheinungsbild.

**Wie kompliziert ist es, KDE (Qt) und GNOME (GTK) Apps gleich aussehen zu lassen?**

Es ist **sehr kompliziert** und oft nur bis zu einem gewissen Grad erreichbar, ein _perfekt_ einheitliches Erscheinungsbild über Qt- und GTK-Anwendungen hinweg zu erzielen, besonders wenn NovaDE selbst primär auf GTK4 basiert.

- **Theming-Engines und Stil-Abstraktionen:**
    
    - **GTK-Themes:** GTK-Anwendungen (GNOME, XFCE, etc.) verwenden GTK-Themes (CSS-basiert). NovaDEs Theming-Engine wird GTK4-CSS generieren. Das bedeutet, GTK-Anwendungen können relativ gut an das NovaDE-Theme angepasst werden, solange sie Standard-GTK-Widgets verwenden und das Theme korrekt interpretieren.
    - **Qt-Themes/Styles:** KDE Plasma und Qt-Anwendungen verwenden Qt-Styles (z.B. Breeze, Kvantum) und Farbschemata. Qt hat eigene Mechanismen zur Stilanpassung, die sich von GTK unterscheiden.
    - **Abstraktionsversuche:** Projekte wie `QGtkStyle` oder `Adwaita-Qt` versuchen, GTK-Themes auf Qt-Anwendungen anzuwenden oder das Aussehen von Qt-Anwendungen an Adwaita (das Standard-GNOME-Theme) anzupassen. Diese funktionieren oft gut für grundlegende Widget-Stile, aber es gibt Grenzen, besonders bei komplexen Anwendungen oder benutzerdefinierten Widgets.
    - **Icon-Themes:** Freedesktop-Icon-Themes (die NovaDE unterstützt) werden von den meisten GTK- und Qt-Anwendungen respektiert, was zu konsistenten Icons führt.
    - **Cursor-Themes:** Werden ebenfalls systemweit gesetzt und meist respektiert.
    - **Schriftarten:** Globale Schrifteinstellungen werden in der Regel von beiden Toolkits übernommen.
- **Herausforderungen für ein einheitliches Erscheinungsbild:**
    
    - **Fensterdekorationen (CSD vs. SSD):**
        - GNOME-Apps verwenden stark Client-Side Decorations (CSD), bei denen die Titelleiste Teil des Anwendungsfensters ist.
        - Traditionelle Qt/KDE-Apps verwenden oft Server-Side Decorations (SSD), bei denen der Fenstermanager die Titelleiste zeichnet. Unter Wayland wird mit `xdg-decoration` versucht, dies zu vereinheitlichen, wobei der Client Präferenzen äußern kann.
        - NovaDE plant die Unterstützung für `xdg-decoration`. Um ein einheitliches Aussehen zu erzielen, müsste NovaDE entweder sehr gute SSDs für Qt-Apps bereitstellen, die zum CSD-Stil der eigenen (GTK4) Apps passen, oder hoffen, dass Qt-Apps zunehmend Wayland-konforme CSDs implementieren (was bei KDE der Fall ist) oder das `xdg-decoration`-Protokoll nutzen, um dem Server die Kontrolle zu überlassen.
    - **Widget-Toolkits:** GTK und Qt haben fundamental unterschiedliche Widget-Sets und Rendering-Philosophien. Feine Unterschiede in Abständen, Animationen, Verhalten von Widgets (z.B. Scrollbalken, Menüs) sind schwer vollständig zu eliminieren.
    - **Farbschemata und Akzentfarben:** Während NovaDE eine systemweite Akzentfarbe plant, müssen sowohl GTK- als auch Qt-Theming-Engines diese korrekt interpretieren und anwenden. Für GTK ist dies über das eigene Theming-System machbar. Für Qt-Apps müsste ein passender Qt-Style oder eine Konfiguration existieren, die diese Akzentfarbe übernimmt. KDE Plasma hat eigene Mechanismen für Akzentfarben.
    - **Dialoge:** Systemdialoge (Datei öffnen/speichern) werden idealerweise über XDG Desktop Portals gehandhabt, was zu konsistenten Dialogen führt, die vom Host-System (NovaDE) bereitgestellt werden. NovaDE plant, Backend-Logik für Portale bereitzustellen.
    - **Anwendungsspezifisches Styling:** Viele Anwendungen (besonders große wie Browser, Office-Suiten) bringen ihr eigenes, stark angepasstes UI-Design mit, das sich nur begrenzt durch System-Themes beeinflussen lässt.
- **Wie machen es andere (z.B. Fenstermanager wie Hyprland)?**
    
    - **Fokus auf Fenstermanagement:** Tiling Window Manager wie Hyprland konzentrieren sich primär auf die Anordnung und Verwaltung von Fenstern (oft ohne eigene Titelleisten – "borderless"). Das Aussehen _innerhalb_ der Anwendungsfenster wird weitgehend den Anwendungen und ihren Toolkits überlassen.
    - **Konfigurationsbasierte Anpassung:** Nutzer solcher WMs passen oft Konfigurationsdateien an, um GTK- und Qt-Themes zu setzen, die visuell ähnlich sind (z.B. ein dunkles Materia-Theme für GTK und ein passendes Kvantum-Theme für Qt).
    - **Konsistenz durch Minimalismus:** Viele Nutzer von Tiling WMs bevorzugen ohnehin einen minimalistischen Look und wählen Themes, die nicht stark toolkit-spezifisch sind.
    - **Keine vollständige Kontrolle:** Sie versuchen nicht, eine pixelgenaue Übereinstimmung zu erzwingen, sondern eine generelle visuelle Harmonie über Schriftarten, Grundfarben und Icon-Themes.
    - **XSettings / GSettings Daemons:** Einige Fenstermanager oder leichtgewichtige Desktops nutzen Daemons, die GSettings (von GNOME) lesen und diese Einstellungen (Theme-Namen, Schriftarten etc.) an GTK- und teilweise auch an Qt-Anwendungen (über Qt-Platform-Themes wie `qt5ct`/`qt6ct` oder `QGnomePlatform`) weitergeben.

**Fazit für NovaDE:**

- **Vollständige DE vs. Fenstermanager:** Die Spezifikationen deuten stark auf den Anspruch einer **vollständigen Desktop-Umgebung** hin, nicht nur eines Fenstermanagers. Die Planung eigener Komponenten wie Control Center, Speed Dial, Panel-Widgets etc. unterstreicht dies.
- **Erscheinungsbild:**
    - Für **eigene NovaDE-Anwendungen (GTK4)** wird ein sehr einheitliches Erscheinungsbild erreichbar sein, da sie direkt das `domain::theming`-System nutzen.
    - Für **andere GTK-Anwendungen** wird ein gutes Maß an Konsistenz möglich sein, wenn diese Standard-GTK4-Widgets verwenden und die von NovaDE generierten CSS-Variablen (Tokens) respektieren.
    - Für **Qt/KDE-Anwendungen** wird es schwieriger. Der beste Ansatz ist:
        1. Bereitstellung eines hochwertigen **Standard-GTK-Themes** durch NovaDE.
        2. Bereitstellung oder Empfehlung eines **Qt-Styles/Kvantum-Themes**, das optisch sehr gut zum NovaDE-Standardtheme passt.
        3. Sicherstellung, dass **globale Einstellungen** (Schriftarten, Icons, Cursor, Akzentfarbe) so exponiert werden (z.B. über GSettings oder einen XSettings-Daemon), dass Qt-Platform-Themes sie lesen und an Qt-Anwendungen weitergeben können.
        4. Konsequente Nutzung von **XDG Desktop Portals** für Systemdialoge.
        5. Korrekte Handhabung von **Server-Side Decorations** für Qt-Apps, die optisch zu den CSDs der GTK-Apps passen, wenn der Client SSDs anfordert.

Ein _perfekt_ identisches Aussehen ist unrealistisch, aber eine hohe visuelle Kohärenz ist durch sorgfältige Theme-Gestaltung und Nutzung von Standards erreichbar. Der Aufwand hierfür ist beträchtlich und erfordert Expertise in GTK- und Qt-Theming.


**I. Grundlagen der UI-Schicht (Wiederholung und Vertiefung)**

1. **Technologie-Stack (Verbindlich):**
    
    - **GUI-Toolkit:** GTK4 mit `gtk4-rs` Bindings.
        - _Untersuchungsbedarf:_ Best Practices für Strukturierung großer GTK4/Rust-Anwendungen, State-Management-Patterns innerhalb von GTK4 (z.B. Model-View-ViewModel (MVVM)-ähnliche Ansätze, Komposition, Properties/Bindings), fortgeschrittene Widget-Erstellung und -Anpassung. Umgang mit dem GTK4-Event-Loop und Integration mit Rusts `async/await` (speziell `glib::MainContext::spawn_local`).
    - **Theming:** Anwendung der von `domain::theming` generierten CSS-Stile über `Gtk::CssProvider`.
        - _Untersuchungsbedarf:_ Dynamische CSS-Aktualisierung zur Laufzeit, effiziente Anwendung von Design-Tokens auf GTK-Widgets, Performance-Implikationen komplexer CSS-Selektoren und -Regeln. Erstellung benutzerdefinierter GTK-Widgets, die optimal auf dynamisches Theming reagieren.
    - **Interaktion mit unteren Schichten:**
        - Nutzung der APIs und Event-Systeme der Domänen- und Systemschicht.
        - _Untersuchungsbedarf:_ Patterns für die Kommunikation und Datenkonvertierung zwischen UI-Typen und Domänen-/System-Typen. Fehlerbehandlung und Darstellung von Fehlern aus tieferen Schichten.
2. **Allgemeine UI/UX-Prinzipien (Visionstreu):**
    
    - **Konsistenz:** Einheitliches Erscheinungsbild und Verhalten über alle UI-Komponenten hinweg.
    - **Feedback:** Visuelles und haptisches (wo sinnvoll) Feedback auf Benutzeraktionen.
    - **Effizienz:** Minimierung der Klicks/Aktionen für häufige Aufgaben.
    - **Zugänglichkeit (Accessibility):** Einhaltung von a11y-Standards (ATK/AT-SPI).
        - _Untersuchungsbedarf:_ GTK4-spezifische Accessibility-Features, Teststrategien für Accessibility.
    - **Performance:** Flüssige Animationen, schnelle Reaktionszeiten, geringer Ressourcenverbrauch.
        - _Untersuchungsbedarf:_ Profiling-Werkzeuge für GTK4/Rust, Optimierung von Rendering-Pfaden, Vermeidung von UI-Blockaden durch langlaufende Operationen.
    - **Anpassbarkeit:** Benutzerdefinierte Konfiguration von Layouts, Widgets und Verhalten.

**II. Detaillierte Untersuchung der UI-Komponenten (Module)**

Für jede der folgenden Komponenten sind die spezifischen Verantwortlichkeiten, Datenstrukturen, Interaktionen, visuellen Design-Aspekte und Implementierungsdetails zu definieren:

1. **`ui::shell` (Haupt-Shell-UI)**
    
    - **Verantwortlichkeiten:** Implementierung der primären Desktop-Interaktionselemente.
    - **Komponenten und deren Untersuchungsbedarf:**
        - **`PanelWidget` (Kontroll-/Systemleiste(n))**:
            - _Design:_ Positionierung (oben/unten, konfigurierbar), Höhe, Transparenzoptionen, "Leuchtakzent"-Effekt.
            - _Module (als einzelne GTK-Widgets):_
                - `AppMenuButton`: Darstellung eines globalen Anwendungsmenüs (falls vom aktiven Fenster unterstützt/exportiert).
                    - _Interaktion:_ Mit `system::compositor` (Information über aktive App) und ggf. D-Bus (AppMenu-Standard).
                - `WorkspaceIndicatorWidget`: Visuelle Repräsentation der "Spaces" innerhalb des Panels.
                    - _Interaktion:_ Mit `domain::workspaces::WorkspaceManager` (Liste und aktiver Space).
                - `ClockDateTimeWidget`: Anzeige von Uhrzeit und Datum, ggf. Kalender-Popup bei Klick.
                    - _Konfiguration:_ Datums-/Zeitformate.
                - `SystemTrayEquivalentWidget`: Handhabung von Status-Icons (z.B. via `StatusNotifierItem` über D-Bus oder Alternativen unter Wayland).
                    - _Untersuchungsbedarf:_ Aktuelle Best Practices für System-Tray-Äquivalente unter Wayland/GTK4.
                - `QuickSettingsButtonWidget`: Button zum Öffnen des `QuickSettingsPanelWidget`.
                - `NotificationCenterButtonWidget`: Button zum Öffnen/Schließen des `NotificationCenterPanelWidget`, Anzeige einer Badge für neue Benachrichtigungen.
                - `NetworkIndicatorWidget`: Anzeige des Netzwerkstatus (Icon, SSID), Menü für Verbindungsmanagement.
                    - _Interaktion:_ Mit `system::dbus::networkmanager_client`.
                - `PowerIndicatorWidget`: Anzeige des Akkustatus/Ladezustands, Menü für Energieoptionen.
                    - _Interaktion:_ Mit `system::dbus::upower_client`.
                - `AudioIndicatorWidget`: Anzeige der Lautstärke, Stummschaltungsstatus, Menü für Audioeinstellungen/-geräte.
                    - _Interaktion:_ Mit `system::audio`.
            - _Layout:_ Konfigurierbare Anordnung der Module im Panel.
        - **`SmartTabBarWidget` (Intelligente Tab-Leiste pro "Space")**:
            - _Design:_ Horizontale Leiste, abgerundete obere Ecken für Tabs, Hervorhebung des aktiven Tabs mit Akzentfarbe.
            - _Funktionalität:_
                - Anzeige von `ApplicationTabWidgets` für "angepinnte" Apps/Split-Views.
                - Anzeige von Tabs für weitere, nicht gepinnte Anwendungen im aktuellen "Space".
                - Überlauf-Logik für viele Tabs.
                - Kontextmenü für Tabs (z.B. "Schließen", "Zu anderem Space verschieben").
            - _Interaktion:_ Mit `domain::workspaces::WorkspaceManager` (Fenster im aktuellen Space), `system::compositor` (Fensterinformationen, App-Icons, Titel).
        - **`QuickSettingsPanelWidget` (Ausklappbares Schnelleinstellungs-Panel)**:
            - _Design:_ Ausklappbares Overlay/Menü, das vom `QuickSettingsButtonWidget` geöffnet wird.
            - _Inhalt:_ Schnellumschalter und -regler für WLAN, Bluetooth, Lautstärke, Dark Mode, etc.
            - _Interaktion:_ Mit den jeweiligen Systemdiensten über Systemschicht-Schnittstellen.
        - **`WorkspaceSwitcherWidget` (Adaptive linke Seitenleiste)**:
            - _Design:_ Vertikale Leiste, im eingeklappten Zustand nur `SpaceIconWidgets`. Aufklappbar (Mouse-Over/Geste) mit Namen/Vorschau der Spaces. Hervorhebung des aktiven Space.
            - _`SpaceIconWidget`_: Anzeige des Icons der gepinnten App oder benutzerdefiniertes Icon für den Space.
            - _Funktionalität:_ Schnelle Navigation zwischen "Spaces".
            - _Interaktion:_ Mit `domain::workspaces::WorkspaceManager`.
        - **`QuickActionDockWidget` (Konfigurierbares Schnellaktionsdock)**:
            - _Design:_ Schwebend oder am Bildschirmrand andockbar (konfigurierbar).
            - _`DockItemWidget`_: Repräsentiert Apps, Dateien, Aktionen.
            - _Funktionalität:_ Drag & Drop von Apps/Dateien ins Dock. Intelligente Vorschläge. Tastaturbedienung.
            - _Interaktion:_ Mit `domain::global_settings_and_state_management` (Konfiguration), Systemschicht (Starten von Apps).
        - **`NotificationCenterPanelWidget` (Benachrichtigungszentrum)**:
            - _Design:_ Ausklappbares Panel, typischerweise von der Systemleiste erreichbar.
            - _`NotificationWidget`_: Stellt eine einzelne Benachrichtigung dar (Icon, App-Name, Zusammenfassung, Body, Aktionen, Zeitstempel).
            - _Funktionalität:_ Anzeige einer Liste aktueller und historischer Benachrichtigungen. Möglichkeit zum Schließen/Interagieren mit Benachrichtigungen. "Bitte nicht stören"-Umschalter.
            - _Interaktion:_ Mit `domain::user_centric_services::NotificationService`.
2. **`ui::control_center` (Modulare GTK4-Anwendung für Systemeinstellungen)**
    
    - **Verantwortlichkeiten:** Grafische Oberfläche zur Konfiguration aller Systemeinstellungen.
    - **Architektur:** Modulare Struktur, bei der jede Einstellungskategorie (Erscheinungsbild, Netzwerk, Workspaces, etc.) ein eigenes GTK-Widget (`SettingsModuleWidget`) ist.
    - **Kernfunktionen:**
        - Navigation zwischen Modulen (z.B. Seitenleiste oder Icon-Grid).
        - Live-Vorschau von Änderungen, wo immer möglich.
        - Suchfunktion für Einstellungen.
        - Zurücksetzen auf Standardwerte.
    - **Beispiel-Module (`SettingsModuleWidget` Implementierungen):**
        - `AppearanceSettingsWidget`: Konfiguration von Theme, Akzentfarbe, Schriftarten, Icons, Animationen, Skalierung.
            - _Interaktion:_ Mit `domain::theming::ThemingEngine` und `domain::global_settings_and_state_management::GlobalSettingsService`.
        - `NetworkSettingsWidget`: Konfiguration von Netzwerkverbindungen (WLAN, Ethernet, VPN).
            - _Interaktion:_ Mit `system::dbus::networkmanager_client`.
        - `WorkspaceSettingsWidget`: Konfiguration von dynamischen Workspaces, Standardanzahl, Verhalten des Workspace-Switchers.
            - _Interaktion:_ Mit `domain::global_settings_and_state_management::GlobalSettingsService` (für Workspace-bezogene Einstellungen).
        - _Weitere Module:_ Bluetooth, Audio, Energie, Eingabegeräte, Standardanwendungen, Datenschutz, Benutzerkonten, etc.
    - _Interaktion:_ Primär mit `domain::global_settings_and_state_management::GlobalSettingsService` zum Lesen und Schreiben von Einstellungen. Für spezifische Einstellungen (Netzwerk, Audio) direkte Interaktion mit den entsprechenden Systemschicht-Schnittstellen.
3. **`ui::widgets` (System für anpassbare Widgets in Seitenleisten)**
    
    - **Verantwortlichkeiten:** Ermöglicht dem Benutzer das Platzieren und Konfigurieren von Informations-Widgets.
    - **Komponenten und deren Untersuchungsbedarf:**
        - **`RightSidebarWidget` (Adaptive rechte Seitenleiste)**:
            - _Design:_ Dezent transluzenter Hintergrund.
            - _Funktionalität:_ Container für `PlacedWidgetWidget`-Instanzen. Per Drag & Drop anpassbar.
        - **`WidgetManagerService` (Logische UI-Komponente)**:
            - _Funktionalität:_ Verwaltet die Liste verfügbarer Widget-Typen, deren Konfigurationen und Platzierungen.
            - _Interaktion:_ Mit `domain::global_settings_and_state_management` (Persistenz der Widget-Konfiguration).
        - **`WidgetPickerPopover`**: UI-Element zur Auswahl und Hinzufügung neuer Widgets zur Seitenleiste.
        - **`PlacedWidgetWidget`**: Wrapper-Widget, das ein spezifisches `ActualWidget` in der Seitenleiste anzeigt und dessen Drag & Drop sowie Konfigurationszugriff ermöglicht.
        - **`ActualWidget` (Basis-Trait/Klasse für konkrete Widgets)**:
            - _Beispiele für konkrete Widget-Implementierungen:_
                - `ClockWidget`: Erweiterte Uhrenfunktionen.
                - `CalendarWidget`: Monatsansicht, Termine.
                - `WeatherWidget`: Aktuelles Wetter, Vorhersage.
                    - _Interaktion:_ Mit externen Wetter-APIs (ggf. über Systemschicht-Proxy).
                - `SystemMonitorWidget`: CPU-, RAM-, Netzwerkauslastung.
                    - _Interaktion:_ Mit Systemschicht-APIs oder `/proc`.
                - `NotesWidget`: Einfache Notizen.
                - `MediaControllerWidget`: Steuerung der Medienwiedergabe.
                    - _Interaktion:_ Mit MPRIS D-Bus-Schnittstelle.
                - `AIContextWidget` (optional): Zeigt kontextbezogene KI-Informationen oder -Aktionen an.
                    - _Interaktion:_ Mit `domain::user_centric_services::AIInteractionLogicService`.
            - _Untersuchungsbedarf:_ Definition einer klaren API für `ActualWidget` (Konfiguration, Datenaktualisierung, Interaktion).
4. **`ui::window_manager_frontend` (UI-Aspekte des Fenstermanagements)**
    
    - **Verantwortlichkeiten:** Darstellung und Interaktion mit Fenstern, die von der Systemschicht verwaltet werden.
    - **Komponenten und deren Untersuchungsbedarf:**
        - **Client-Side Decorations (CSD) Logik**:
            - _Funktionalität:_ Handhabung von Fensterdekorationen, die von den Anwendungen selbst gezeichnet werden (z.B. via `Gtk::HeaderBar`). Sicherstellung der Konsistenz mit dem globalen Theme.
            - _Untersuchungsbedarf:_ Integration mit dem `xdg-decoration-unstable-v1` Protokoll, um zwischen CSD und Server-Side Decorations (SSD) zu verhandeln.
        - **Server-Side Decorations (SSD) Rendering** (falls implementiert):
            - _Funktionalität:_ Zeichnen von Fensterrahmen und Titelleisten durch den Compositor, falls Anwendungen keine CSDs bereitstellen. Design muss anpassbar und themenkonform sein.
            - _Interaktion:_ Mit `system::compositor` und `domain::theming`.
        - **`OverviewModeWidget` (Fenster- und Workspace-Übersicht)**:
            - _Design:_ Interaktive Kacheln mit Live-Vorschau der Fenster. Hintergrund abgedunkelt/unscharf. Darstellung von Workspaces für Drag & Drop von Fenstern.
            - _Funktionalität:_ Aktivierung durch Geste/Tastenkürzel. Fenster auswählen, schließen, zwischen Workspaces verschieben.
            - _Interaktion:_ Mit `system::compositor` (Fensterliste, Thumbnails/Previews), `domain::workspaces::WorkspaceManager`.
        - **`AltTabSwitcherWidget` (Traditioneller Fensterwechsler)**:
            - _Design:_ Overlay-Anzeige der laufenden Anwendungen/Fenster für schnellen Wechsel.
            - _Funktionalität:_ Aktivierung durch Alt+Tab.
            - _Interaktion:_ Mit `system::compositor`.
5. **`ui::notifications_frontend` (Darstellung von Benachrichtigungen)**
    
    - **Verantwortlichkeiten:** Visuelle Präsentation von System- und Anwendungsbenachrichtigungen.
    - **Komponenten und deren Untersuchungsbedarf:**
        - **`NotificationPopupWidget` (Pop-up-Benachrichtigungen)**:
            - _Design:_ Dezent, im Dark Mode Stil mit Akzentfarbe je nach Dringlichkeit. Positionierung auf dem Bildschirm (z.B. obere rechte Ecke). Animationen für Erscheinen/Verschwinden.
            - _Funktionalität:_ Anzeige von Icon, App-Name, Zusammenfassung, Body (optional), Aktionen. Automatisches Schließen nach Timeout oder manuell.
            - _Interaktion:_ Reagiert auf `NotificationPostedEvent` von `domain::user_centric_services::NotificationService`. Sendet Aktionen zurück an den Service.
6. **`ui::theming_gtk` (Anwendung des Themes auf GTK-Widgets)**
    
    - **Verantwortlichkeiten:** Anwendung der von `domain::theming::ThemingEngine` generierten CSS-Stile auf alle GTK-Widgets.
    - **Kernfunktionen:**
        - Abrufen des `AppliedThemeState` von der `ThemingEngine`.
        - Generieren einer CSS-Datei aus den `resolved_tokens`.
        - Anwenden dieser CSS-Datei mittels `Gtk::CssProvider` auf den globalen GTK-Kontext (`Gtk::StyleContext::add_provider_for_display`).
        - Abonnieren des `ThemeChangedEvent`, um das CSS dynamisch zu aktualisieren.
    - _Untersuchungsbedarf:_ Effiziente Generierung und Aktualisierung des CSS. Umgang mit GTK4-spezifischen CSS-Eigenschaften und -Selektoren. Sicherstellung, dass benutzerdefinierte Widgets korrekt auf Theme-Änderungen reagieren.
7. **`ui::components` (Sammlung wiederverwendbarer UI-Bausteine)**
    
    - **Verantwortlichkeiten:** Definition und Implementierung anwendungsspezifischer, aber wiederverwendbarer GTK4-Widgets.
    - **Beispiele:**
        - `StyledButtonWidget`: Ein Button, der konsistent mit dem NovaDE-Theming (Akzentfarben, Leuchteffekte) gestaltet ist.
        - `ModalDialogWidget`: Standardisiertes Aussehen und Verhalten für modale Dialoge.
        - `SearchEntryWidget`: Suchfeld mit konsistentem Design und Verhalten.
        - `IconWidget`: Widget zur konsistenten Anzeige von Icons aus dem System-Theme.
    - _Untersuchungsbedarf:_ Identifikation weiterer wiederverwendbarer Komponenten während der Entwicklung.
8. **`ui::speed_dial` (Startansicht für leere Workspaces)**
    
    - **Verantwortlichkeiten:** Implementierung der GTK4-Oberfläche für die Speed-Dial-Funktionalität.
    - **Design:** Kachelbasierte Ansicht mit Favoriten, intelligenten Vorschlägen (basierend auf Nutzungsverhalten, Kontext), integrierte Suchfunktion. Anpassbar.
    - **Interaktion:** Mit `domain::global_settings_and_state_management` (Favoriten, Konfiguration), potenziell mit `domain::user_centric_services::AIInteractionLogicService` für intelligente Vorschläge, Systemschicht (Starten von Apps).
9. **`ui::command_palette` (Kontextuelle Befehlspalette)**
    
    - **Verantwortlichkeiten:** GTK4-Implementierung der Befehlspaletten-UI.
    - **Design:** Overlay-Fenster (typischerweise zentriert oder am oberen Bildschirmrand), das bei Tastenkürzel (`Super+Space`) erscheint. Eingabefeld für Text, dynamische Ergebnisliste mit Fuzzy-Matching.
    - **Funktionalität:** Ausführung von Aktionen, Starten von Apps, Finden von Einstellungen. Kontextsensitivität (zeigt relevante Befehle für aktive App/Desktop-Zustand).
    - **Interaktion:** Mit `domain::global_settings_and_state_management` (Suche nach Einstellungen), Systemschicht (Starten von Apps, Ausführen von Systembefehlen), potenziell `domain::user_centric_services::AIInteractionLogicService` (für KI-gestützte Befehle oder Vorschläge).

**III. Übergreifende Untersuchungsbereiche für die UI-Schicht**

1. **State Management in der UI:**
    - _Problem:_ Wie wird der Zustand von UI-Komponenten verwaltet, insbesondere wenn er von Daten aus tieferen Schichten abhängt oder über mehrere Widgets hinweg synchronisiert werden muss?
    - _Untersuchungsbedarf:_ Evaluation von Rust-spezifischen State-Management-Bibliotheken (falls vorhanden und passend für GTK), Adaption von Patterns wie MVVM oder MVC für GTK4/Rust, Nutzung von GTK-Properties und Bindings, `glib::Object` Subclassing.
2. **Asynchrone Operationen und UI-Responsiveness:**
    - _Problem:_ Wie werden langlaufende Operationen (z.B. Laden von Daten aus dem Netzwerk, komplexe Berechnungen in der Domänenschicht) gehandhabt, ohne die UI zu blockieren?
    - _Untersuchungsbedarf:_ Konsequente Nutzung von `glib::MainContext::spawn_local` für UI-Aktualisierungen aus asynchronen Kontexten. Kommunikation zwischen UI-Thread und Hintergrund-Threads (z.B. über `async_channel` oder `tokio::sync::mpsc`). Design von UI-Feedback für laufende Operationen (Spinner, Fortschrittsbalken).
3. **Teststrategien für die UI:**
    - _Problem:_ Wie kann die Korrektheit und das Verhalten von GTK4-Widgets und der gesamten UI-Logik getestet werden?
    - _Untersuchungsbedarf:_
        - **Unit-Tests:** Testen der Logik von UI-Komponenten, die nicht direkt von GTK-Rendering abhängt. Mocking von Abhängigkeiten zu unteren Schichten.
        - **Widget-Tests:** Nutzung von GTK-Inspektionswerkzeugen und Accessibility-APIs zur programmatischen Überprüfung von Widget-Zuständen und -Eigenschaften. Evaluierung von Frameworks wie `gtk4-rs-test-utils` oder ähnlichen Ansätzen.
        - **Visuelle Regressionstests:** Evaluierung von Werkzeugen für visuelle Vergleiche von UI-Zuständen.
        - **End-to-End-Tests (Integrationstests):** Simulation von Benutzerinteraktionen auf Wayland-Ebene und Überprüfung des Systemverhaltens (herausfordernd, aber wichtig für kritische Pfade).
4. **Performance-Optimierung und Profiling:**
    - _Problem:_ Sicherstellung einer durchgehend performanten UI.
    - _Untersuchungsbedarf:_ Identifikation und Nutzung von Profiling-Werkzeugen für Rust und GTK4 (z.B. `perf`, GTK-Debugger, spezifische Rust-Profiler). Analyse von Rendering-Zeiten, Speicherverbrauch und CPU-Auslastung der UI-Komponenten. Optimierung von Widget-Zeichnung, CSS-Anwendung und Datenbindung.
5. **Internationale und Lokalisierung (i18n/l10n):**
    - _Problem:_ Vorbereitung der UI für die Übersetzung in verschiedene Sprachen.
    - _Untersuchungsbedarf:_ Integration von Gettext oder ähnlichen Bibliotheken mit GTK4/Rust. Management von Übersetzungsdateien. Sicherstellung, dass UI-Layouts mit unterschiedlich langen Texten umgehen können.

**IV. Planungs- und Managementaspekte**

1. **Priorisierung:** Welche UI-Komponenten sind für einen ersten Prototyp/MVP (Minimum Viable Product) unerlässlich?
2. **Abhängigkeiten:** Welche UI-Komponenten hängen stark von der Fertigstellung bestimmter Domänen- oder Systemschichtfunktionen ab?
3. **Parallelisierung:** Welche UI-Module können parallel entwickelt werden?
4. **Design-Prozess:** Enge Zusammenarbeit mit UX/UI-Designern, um Mockups und Prototypen zu erstellen und Iterationen basierend auf Feedback durchzuführen.
5. **Dokumentation:** Umfassende Dokumentation der UI-Komponenten, ihrer APIs und ihrer Interaktionen.

Dieser detaillierte Recherche- und Untersuchungsplan bildet die Grundlage für die erfolgreiche Konzeption und Implementierung der Benutzeroberflächenschicht von NovaDE. Er dient als Leitfaden, um sicherzustellen, dass alle relevanten Aspekte berücksichtigt werden und eine hochwertige Benutzererfahrung entsteht.

Technische Gesamtspezifikation und EntwicklungsrichtlinienI. EinleitungDieses Dokument dient als umfassende technische Spezifikation und Sammlung von Entwicklungsrichtlinien für die Erstellung einer neuartigen Linux-Desktop-Umgebung. Ziel ist es, eine moderne, schnelle, intuitive und KI-gestützte Benutzererfahrung zu schaffen, die sowohl für Entwickler, Kreative als auch für alltägliche Nutzer optimiert ist.Der Zweck dieser Spezifikation ist es, eine solide technische Grundlage zu legen und klare Richtlinien für das Entwicklungsteam bereitzustellen. Sie definiert die übergeordnete Architektur, den Technologie-Stack, die Kernkomponenten und die grundlegenden Entwicklungsprinzipien. Dieses Dokument ist die Basis für die nachfolgenden, detaillierten Implementierungsleitfäden für jede Architekturschicht und soll sicherstellen, dass Entwickler die Umgebung direkt implementieren können, ohne grundlegende technologische oder architektonische Entscheidungen selbst treffen zu müssen.Die vorgeschlagene Desktop-Umgebung basiert auf einer klaren, geschichteten Architektur, um Modularität, Wartbarkeit und Testbarkeit zu maximieren.II. Architektonischer Überblick (Schichtenarchitektur)Das System ist in vier logische Schichten unterteilt, die jeweils spezifische Verantwortlichkeiten tragen und über definierte Schnittstellen miteinander kommunizieren. Diese Trennung fördert die Kohäsion innerhalb der Schichten und reduziert die Kopplung zwischen ihnen.
Kernschicht (Core Layer):

Verantwortlichkeiten: Enthält die grundlegendsten Datentypen, Dienstprogramme, Konfigurationsgrundlagen, Logging-Infrastruktur und allgemeine Fehlerdefinitionen, die von allen anderen Schichten verwendet werden. Diese Schicht hat keine Abhängigkeiten zu den anderen Schichten.
Interaktionen: Stellt Funktionalität für alle darüberliegenden Schichten bereit.


Domänenschicht (Domain Layer):

Verantwortlichkeiten: Beinhaltet die Kernlogik und die Geschäftsregeln der Desktop-Umgebung. Dies umfasst die Verwaltung von Workspaces ("Spaces"), das Theming-System, die Logik für KI-Interaktionen (inkl. Einwilligungsmanagement), die Verwaltung von Benachrichtigungen und die Definition von Richtlinien für das Fenstermanagement (z.B. Tiling-Regeln). Diese Schicht ist unabhängig von spezifischen UI-Implementierungen oder Systemdetails wie D-Bus oder Wayland.
Interaktionen: Nutzt Funktionalität der Kernschicht. Stellt Logik und Zustand für die System- und Benutzeroberflächenschicht bereit.


Systemschicht (System Layer):

Verantwortlichkeiten: Implementiert die Interaktion mit dem zugrundeliegenden Betriebssystem und externen Diensten. Dies beinhaltet den Wayland-Compositor, die Eingabeverarbeitung (libinput), die Kommunikation über D-Bus mit Systemdiensten (Netzwerk, Energie, Audio, Secrets, PolicyKit), die Implementierung von Wayland-Protokollen, die XWayland-Integration, die MCP-Client-Implementierung und die Interaktion mit XDG Desktop Portals.
Interaktionen: Nutzt Funktionalität der Kern- und Domänenschicht (z.B. um Domänenregeln anzuwenden oder Zustände abzufragen). Stellt systemnahe Dienste und Ereignisse für die Benutzeroberflächenschicht bereit. Implementiert die konkrete "Mechanik" des Fenstermanagements basierend auf den Richtlinien der Domänenschicht.


Benutzeroberflächenschicht (User Interface Layer):

Verantwortlichkeiten: Ist verantwortlich für die Darstellung der Benutzeroberfläche und die Interaktion mit dem Benutzer. Dies umfasst die Shell-UI (Panels, Dock, etc.), das Control Center, das Widget-System, den Übersichtsmodus, die Befehlspalette und alle anderen sichtbaren Elemente. Diese Schicht verwendet das gewählte GUI-Toolkit (GTK4) und interagiert mit der Systemschicht, um Aktionen auszuführen und Systemzustände darzustellen.
Interaktionen: Nutzt Funktionalität aller darunterliegenden Schichten, insbesondere der Systemschicht (um Fenster zu verwalten, Eingaben zu empfangen, Systemdienste anzusprechen) und der Domänenschicht (um Zustände darzustellen und Geschäftslogik auszulösen).


Diese Schichtung stellt sicher, dass Änderungen in einer Schicht (z.B. der Austausch des GUI-Toolkits) minimale Auswirkungen auf andere Schichten haben, insbesondere auf die Kern- und Domänenschicht.III. Technologie-StackDie Auswahl des Technologie-Stacks basiert auf den Anforderungen an Modernität, Leistung, Sicherheit, Wartbarkeit und der Verfügbarkeit von qualitativ hochwertigen Bibliotheken und Werkzeugen im Linux-Ökosystem.
3.1. Programmiersprache:

Entscheidung: Rust.1
Begründung: Rust bietet eine überzeugende Kombination aus Leistung ("close-to-the-metal" ähnlich C++) und Speichersicherheit ohne Garbage Collector, was für Systemsoftware wie eine Desktop-Umgebung entscheidend ist.1 Sein starkes Typsystem und das Ownership-Modell verhindern viele gängige Fehlerklassen (z.B. Null Pointer, Data Races) bereits zur Kompilierzeit, was die Stabilität und Sicherheit erhöht.1 Rust fördert zudem moderne Nebenläufigkeitskonzepte, was für eine reaktionsschnelle UI wichtig ist.3 Obwohl C++ eine längere Historie im Embedded-/Systembereich hat und über umfangreichere Bibliotheken verfügt 1, wird Rust aufgrund seiner Sicherheitsgarantien und seiner wachsenden Popularität und Ökosystemreife als zukunftssicherere Wahl für dieses Projekt angesehen.1 Die Lernkurve für Rust, insbesondere das Ownership-Modell, wird als investitionswürdig betrachtet, um die langfristigen Vorteile in Bezug auf Codequalität und Wartbarkeit zu realisieren.3


3.2. Build-System:

Entscheidung: Meson.4
Begründung: Meson ist ein modernes Meta-Build-System, das oft als einfacher und schneller als CMake wahrgenommen wird, insbesondere für Projekte, die nicht tief in der CMake-Welt verwurzelt sind.4 Es bietet eine klare Syntax und ein "opinionated" Design, das zu konsistenteren Build-Skripten führen kann.4 Meson hat gute Unterstützung für Rust und C/C++ und kann CMake-basierte Abhängigkeiten über sein Subprojekt-System (WrapDB, CMake-Modul) integrieren.5 Obwohl CMake eine breitere Akzeptanz und mächtigere Features für komplexe Szenarien haben mag, wird Meson aufgrund seiner Einfachheit, Geschwindigkeit und guten Integration verschiedener Sprachen als passender für dieses Projekt eingeschätzt. Die Verwaltung von Abhängigkeiten über WrapDB und Subprojekte wird als ausreichend für die Projektanforderungen bewertet.5


3.3. GUI-Toolkit:

Entscheidung: GTK4.6
Begründung: GTK4 ist ein modernes, aktiv entwickeltes Toolkit mit erstklassiger Wayland-Unterstützung.6 Es bietet offizielle und gut gepflegte Rust-Bindings (gtk4-rs). GTK4 verwendet CSS für das Theming, was eine flexible und standardisierte Anpassung des Erscheinungsbildes ermöglicht und gut zur geplanten Token-basierten Theming-Architektur passt.6 Während Qt6 ebenfalls eine leistungsstarke Alternative mit guter Wayland-Unterstützung und breiter Plattformabdeckung (inkl. Mobile/Embedded) darstellt 6, wird GTK4 aufgrund seiner starken Integration in das GNOME-Ökosystem (aus dem viele Linux-Technologien stammen), seiner LGPL-Lizenzierung 6 und der als etwas einfacher empfundenen Lernkurve für reine Desktop-Anwendungen bevorzugt. Die Möglichkeit, das Erscheinungsbild von Qt-Anwendungen an GTK anzupassen (und umgekehrt), existiert, erfordert aber zusätzliche Konfiguration.8 Die Fokussierung auf GTK4 vereinfacht die Entwicklung und sorgt für eine konsistente Basis. Die Fähigkeit von GTK4, Themes zur Laufzeit zu wechseln (z.B. über CSS-Änderungen oder GtkStyleContext), ist entscheidend für die dynamische Theme-Umschaltung.9


3.4. Wayland Compositor & Bibliotheken:

Entscheidung: Smithay Toolkit.11
Begründung: Smithay ist eine in Rust geschriebene Bibliothek zum Erstellen von Wayland-Compositors.11 Dies passt perfekt zur Wahl von Rust als Hauptprogrammiersprache und vermeidet die Notwendigkeit von C-Bindings für Kernkomponenten des Compositors. Smithay ist modular aufgebaut ("kein Framework, das einschränkt") und ermöglicht die selektive Nutzung benötigter Komponenten.11 Es bietet Unterstützung für wichtige Wayland-Protokolle, XWayland-Integration 13 und Abstraktionen für Backends (DRM, libinput, etc.). Obwohl wlroots 15 eine etablierte C-Bibliothek ist, die von vielen bekannten Compositors (wie Sway, Hyprland) genutzt wird 15, bietet Smithay den Vorteil einer nativen Rust-Implementierung, was die Integration in das Rust-basierte Projekt vereinfacht und potenzielle Probleme an der Sprachgrenze reduziert. Die aktive Entwicklung und der Fokus auf Sicherheit und Modularität machen Smithay zu einer vielversprechenden Wahl.11


3.5. Essentielle Wayland-Protokolle:

Kern: wayland.xml (Basisprotokoll).17
Fensterverwaltung: xdg-shell (Standard für Desktop-Fenster).
Shell-UI-Elemente: wlr-layer-shell-unstable-v1 (Für Panels, Docks, Benachrichtigungen etc., die über normalen Fenstern liegen).18 Smithay bietet Unterstützung hierfür.
Fensterdekorationen: xdg-decoration-unstable-v1 (Verhandlung zwischen Client und Server über Fensterrahmen/-steuerungen).20
Taskleisten/Docks: wlr-foreign-toplevel-management-unstable-v1 (Auflisten und Steuern von Fenstern anderer Anwendungen).22
Display-Konfiguration: wlr-output-management-unstable-v1 (Lesen und Ändern von Monitorkonfigurationen wie Auflösung, Position, Aktivierungsstatus).26 Smithay unterstützt dies.
Energieverwaltung (Displays): wlr-output-power-management-unstable-v1 (Steuern des Energiesparmodus von Monitoren).26 Smithay unterstützt dies.
Eingabemethoden: input-method-unstable-v1, text-input-unstable-v3 (Für On-Screen-Keyboards, CJK-Eingabe etc.).
Zwischenablage & DND: Wayland Core (wl_data_device_manager), ggf. wlr-data-control-unstable-v1.
Screencasting/Screenshots: XDG Desktop Portal APIs (siehe unten) oder ggf. wlr-screencopy-unstable-v1.
X11-Kompatibilität: XWayland (unterstützt durch Smithay).13
Weitere: presentation-time, viewporter, linux-dmabuf-unstable-v1, idle-notify-unstable-v1, etc. je nach Bedarf.
Hinweis: Die Verwendung von wlr-*-Protokollen bindet die Funktionalität primär an Compositors, die diese unterstützen (wlroots-basiert, Smithay-basiert, KWin).19 GNOME verwendet oft eigene Protokolle oder Ansätze. Dies ist eine bewusste Entscheidung zugunsten der verfügbaren Funktionalität in der Rust/Smithay-Welt.


3.6. Inter-Prozess-Kommunikation (IPC):

Entscheidung: D-Bus.30
Begründung: D-Bus ist der De-facto-Standard für IPC im Linux-Desktop-Bereich.30 Es wird von essenziellen Systemdiensten wie NetworkManager, UPower (Energieverwaltung), logind (Session-Management), PolicyKit (Rechteverwaltung), dem Benachrichtigungsdienst (org.freedesktop.Notifications) und dem Secret Service (org.freedesktop.secrets) verwendet. Die Nutzung von D-Bus ermöglicht eine nahtlose Integration mit diesen Diensten. Es gibt etablierte Rust-Bibliotheken für D-Bus (z.B. zbus, oder das ältere dbus 31).


3.7. KI-Integration:

Entscheidung: Model Context Protocol (MCP).32
Begründung: MCP ist ein offener Standard, der speziell für die sichere und standardisierte Verbindung von KI-Modellen (LLMs) mit externen Werkzeugen, Datenquellen und Anwendungen (wie der Desktop-Umgebung) entwickelt wurde.32 Es bietet eine Client-Server-Architektur und definierte Nachrichtenformate (Requests, Responses, Notifications) 33, was die Integration vereinfacht und Vendor Lock-in vermeidet.32 Dies passt gut zur Anforderung, sowohl lokale als auch Cloud-basierte Modelle sicher anzubinden und dem Benutzer die Kontrolle über Datenzugriffe zu geben (Einwilligungsmanagement).


3.8. Eingabeverarbeitung:

Entscheidung: libinput [User Query].
Begründung: libinput ist die Standardbibliothek unter Linux für die Verarbeitung von Eingabeereignissen von Tastaturen, Mäusen, Touchpads etc. auf niedrigem Niveau.34 Wayland-Compositors wie die, die mit Smithay oder wlroots gebaut werden, integrieren libinput typischerweise, um rohe Hardware-Events zu verarbeiten und in Wayland-Events umzusetzen.15 libinput bietet robuste Unterstützung für Touchpad-Gesten (Pinch, Swipe, Hold).35 Die Verwendung von libinput über den Compositor stellt eine konsistente und präzise Eingabebehandlung sicher.


3.9. Audio-Management:

Entscheidung: PipeWire.34
Begründung: PipeWire ist der moderne Standard für Audio- (und Video-) Management unter Linux und ersetzt zunehmend PulseAudio und JACK.34 Es bietet geringe Latenz, flexible Routing-Möglichkeiten und eine sandboxed Architektur. Es stellt Kompatibilitätsschichten für PulseAudio-, JACK- und ALSA-Anwendungen bereit.34 Für die Interaktion mit PipeWire aus Rust gibt es Bibliotheken wie pipewire-rs oder spezifischere Wrapper/Anwendungen.37 Die Nutzung von PipeWire ermöglicht die Steuerung von Lautstärke, Geräteauswahl und Anwendungs-Streams.


3.10. Geheimnisverwaltung:

Entscheidung: Freedesktop Secret Service API.
Begründung: Dies ist der Standardmechanismus auf Linux-Desktops zum sicheren Speichern von sensiblen Daten wie Passwörtern oder API-Schlüsseln.39 Implementierungen wie GNOME Keyring oder KWallet stellen diesen Dienst über D-Bus bereit (org.freedesktop.secrets).39 Die Verwendung dieser API stellt sicher, dass sensible Daten (z.B. API-Keys für Cloud-LLMs) nicht im Klartext gespeichert werden und durch die Mechanismen des Systems geschützt sind. Es gibt Rust-Bibliotheken (secret-service-rs) für die Interaktion mit dieser API.39


3.11. Rechteverwaltung:

Entscheidung: PolicyKit (polkit).
Begründung: PolicyKit ist der Standardmechanismus unter Linux, um privilegierten Aktionen (wie Systemaktualisierungen, Änderung von Energieeinstellungen, Installation von Software) durch unprivilegierte Anwendungen zu erlauben, typischerweise nach Authentifizierung des Benutzers [User Query]. Die Interaktion erfolgt über D-Bus. Die Nutzung von PolicyKit ist unerlässlich, um sicherzustellen, dass administrative Aufgaben nur mit expliziter Benutzerzustimmung durchgeführt werden.


3.12. Theming-Implementierung:

Entscheidung: Token-basiertes System, implementiert über GTK4 CSS Custom Properties (var()) und @define-color (als Fallback/Ergänzung).7
Begründung: Ein Token-basiertes System bietet eine Abstraktionsebene über konkreten Werten (Farben, Schriftgrößen, Abstände).41 Designentscheidungen werden als benannte Tokens gespeichert (z.B. --background-color, --accent-color). GTK4 unterstützt CSS Custom Properties (--name: value;) und deren Verwendung (var(--name)) 7, was eine direkte Umsetzung dieses Konzepts ermöglicht. Änderungen an den Token-Definitionen (z.B. Wechsel von Hell- zu Dunkelmodus) können zur Laufzeit angewendet werden, indem die CSS-Definitionen aktualisiert werden, was die dynamische Theme-Umschaltung ohne Neustart ermöglicht.41 Tokens werden in Schichten organisiert (Foundation/Core -> Alias/Semantic -> Component-specific) 42, um Konsistenz und Wartbarkeit zu gewährleisten. Die generierten CSS-Dateien werden über GtkCssProvider geladen.


3.13. Desktop Portals:

Entscheidung: XDG Desktop Portals.43
Begründung: XDG Desktop Portals bieten standardisierte D-Bus-Schnittstellen für sandboxed Anwendungen (wie Flatpaks, aber auch native Apps), um sicher auf Ressourcen außerhalb ihrer Sandbox zuzugreifen.43 Dies umfasst Funktionen wie Datei öffnen/speichern-Dialoge, Kamera-/Mikrofonzugriff, Standortdienste, Hintergrunddienste, Screencasting/Screenshots und mehr.43 Die Nutzung dieser Portale ist der empfohlene Weg, um solche Funktionen unter Wayland sicher zu implementieren, anstatt direkte System-APIs zu verwenden. Es gibt Rust-Bibliotheken (xdg-portal) für die Interaktion mit diesen Portalen.43 Die Desktop-Umgebung muss ggf. Backend-Implementierungen für einige dieser Portale bereitstellen oder sicherstellen, dass vorhandene (z.B. xdg-desktop-portal-gtk) korrekt funktionieren.


Zusammenfassung Technologiestack:
BereichTechnologie/StandardBegründungReferenzenProgrammierspracheRustSicherheit, Performance, Concurrency, Modernität1Build-SystemMesonModern, Einfach, Rust/C++ Integration, WrapDB4GUI-ToolkitGTK4Modern, Wayland, Rust Bindings, CSS Theming6Compositor-ToolkitSmithayRust-nativ, Modular, Wayland Protokolle, XWayland11Display-Server-ProtokollWaylandModern, Sicher, Performant17Wayland-ProtokolleXDG Shell, WLR Layer Shell, XDG Decoration, etc.Standardisierte Schnittstellen für Desktop-Funktionen19IPCD-BusLinux Standard, Integration mit Systemdiensten30KI-IntegrationModel Context Protocol (MCP)Offener Standard, Sichere LLM-Anbindung, Flexibel32Eingabeverarbeitunglibinput (via Smithay)Standard Linux Eingabe, Gestenunterstützung34AudioPipeWireModerner Linux Standard, Flexibel, Kompatibel34GeheimnisverwaltungFreedesktop Secret Service APIStandard, Sicher, Integration mit Keyring/KWallet39RechteverwaltungPolicyKit (polkit)Standard für privilegierte Aktionen[User Query]ThemingToken-basiert via GTK4 CSS Custom PropertiesFlexibel, Standardisiert, Laufzeit-Änderungen7Sandboxing-InteraktionXDG Desktop PortalsSicherer Zugriff auf Systemressourcen für Anwendungen43
IV. EntwicklungsrichtlinienDiese Richtlinien sollen Konsistenz, Qualität und Wartbarkeit des Codes über das gesamte Projekt hinweg sicherstellen.
4.1. Coding Style & Formatierung:

Entscheidung: Standard rustfmt Konfiguration plus Einhaltung der Rust API Guidelines.45
Begründung: Die Verwendung eines automatischen Formatierungswerkzeugs wie rustfmt stellt einen konsistenten Code-Stil sicher, reduziert Diskussionen über Formatierung und verbessert die Lesbarkeit.45 Die Rust API Guidelines bieten bewährte Praktiken für die Gestaltung von öffentlichen Schnittstellen in Rust-Bibliotheken und -Anwendungen.46
Implementierung: rustfmt wird als Teil des CI-Prozesses ausgeführt, um die Einhaltung zu überprüfen. Entwickler müssen rustfmt vor dem Committen ausführen. Die Richtlinien umfassen Einrückung (4 Leerzeichen), maximale Zeilenlänge (100 Zeichen), Kommentierungsstil (bevorzugt //), Modulorganisation und Namenskonventionen (RFC 430 Casing, as_, to_, into_, iter, iter_mut, into_iter etc.).45 Doc Comments (/// oder //!) werden für die Dokumentation verwendet.45


4.2. API-Design:

Entscheidung: Befolgung der Rust API Guidelines Checklist.46
Begründung: Konsistente und idiomatisches Rust-APIs verbessern die Benutzerfreundlichkeit und Wartbarkeit der Bibliotheken und Komponenten des Desktops. Die Guidelines decken Aspekte wie Namensgebung, Trait-Implementierungen, Fehlerbehandlung, Dokumentation, Flexibilität und Typsicherheit ab.46
Implementierung: Entwickler müssen sich mit den Guidelines vertraut machen. Wichtige Punkte sind:

Implementierung gängiger Traits (Debug, Clone, Send, Sync, Default, From, AsRef, etc.) wo sinnvoll.46
Sinnvolle Fehlertypen (std::error::Error).46
Klare Unterscheidung zwischen &self, &mut self und self Methoden.
Verwendung von Generics zur Minimierung von Annahmen über Parameter.46
Verwendung von Newtypes für Typsicherheit und Kapselung.46
Vermeidung von bool oder Option für Argumente, wo spezifischere Typen (Enums, Structs, Bitflags) aussagekräftiger sind.46
Bereitstellung von Builder-Patterns für komplexe Typen.46
Private Felder in Structs und versiegelte Traits (#[doc(hidden)] pub trait Sealed {}) zum Schutz vor Breaking Changes.46




4.3. Fehlerbehandlung:

Entscheidung: Verwendung des thiserror Crates zur Definition von benutzerdefinierten, spezifischen Fehler-Enums pro Modul.48
Begründung: thiserror vereinfacht die Erstellung idiomatischer Rust-Fehlertypen, die das std::error::Error Trait implementieren und gute Fehlermeldungen über das #[error(...)] Attribut bereitstellen.48 Die Verwendung von spezifischen Enums pro Modul (z.B. ThemingError, CompositorError) bietet einen guten Kompromiss zwischen Granularität und Verwaltbarkeit.49 Es ermöglicht dem aufrufenden Code, Fehler spezifisch zu behandeln (falls nötig) oder sie einfach mittels des ?-Operators weiterzugeben.48 Panics durch unwrap() oder expect() sind in Bibliotheks-/Kerncode zu vermeiden; sie sind nur für unrecoverable Fehler oder in Tests/Beispielen akzeptabel.48 Das #[from] Attribut in thiserror erleichtert das Umwandeln von Fehlern aus Abhängigkeiten oder unteren Schichten.48 Diese strukturierte Herangehensweise ist der Verwendung eines einzigen, globalen Fehler-Enums oder unspezifischer Fehler (wie Box<dyn Error>) in den meisten Fällen vorzuziehen, da sie mehr Kontext und Typsicherheit bietet.49 Die Konsistenz in der Fehlerbehandlungsstruktur über ein großes Projekt hinweg ist entscheidend. Ohne eine klare Regel zur Granularität könnten verschiedene Teams unterschiedliche Ansätze verfolgen, was zu einer inkonsistenten und schwerer zu nutzenden API-Oberfläche für die Fehlerbehandlung führt. Eine Regel pro Modul bietet eine vernünftige Balance zwischen Spezifität und der Vermeidung einer übermäßigen Verbreitung von Fehlertypen.
Implementierung: In der Kernschicht wird ggf. ein Basis-Fehler-Enum oder Trait definiert. Jedes Modul (z.B. compositor, theming_engine, mcp_client) definiert sein eigenes Error-Enum mit #. Varianten repräsentieren spezifische Fehlerfälle des Moduls. Fehler aus Abhängigkeiten werden mittels #[from] in passende Varianten des Modul-Fehlers konvertiert.


4.4. Logging & Tracing:

Entscheidung: Nutzung des tracing Crate-Frameworks.50
Begründung: tracing bietet strukturiertes, kontextbezogenes Logging mit Unterstützung für Spans (Zeitmessung von Codeabschnitten), was leistungsfähiger ist als das traditionelle log-Crate für die Fehlersuche in komplexen, asynchronen Systemen wie einer Desktop-Umgebung.51 Es ermöglicht die Unterscheidung zwischen Ereignissen (Momente) und Zeitspannen und deren hierarchische Verschachtelung.51 tracing integriert sich gut in asynchronen Rust-Code und verfügt über ein wachsendes Ökosystem von Subscribers und Layern für verschiedene Ausgabeformate (Text, JSON, Bunyan) und Analysewerkzeuge (OpenTelemetry, Jaeger, etc.).50
Implementierung: Standard-Logging-Levels (ERROR, WARN, INFO, DEBUG, TRACE) werden definiert. Die Verwendung von Spans (z.B. via #[tracing::instrument] Makro oder manuell erzeugten Spans) für wichtige Funktionen, Operationen oder Bearbeitungszyklen ist vorgeschrieben, um Kontext zu liefern. Ein Standard-Subscriber (z.B. tracing_subscriber::fmt für menschenlesbare Ausgabe oder tracing-bunyan-formatter 51 für strukturierte Logs) wird für Entwicklungs-Builds konfiguriert. Es werden Richtlinien definiert, was auf welchem Level geloggt werden soll (z.B. Fehler und Warnungen immer, INFO für wichtige Lebenszyklusereignisse, DEBUG für detaillierte Abläufe, TRACE für sehr feingranulare Informationen) und dass sensible Daten (Passwörter, Geheimnisse) niemals geloggt werden dürfen.


4.5. Versionskontrolle & Branching:

Entscheidung: Verwendung von Git mit dem GitHub Flow Branching-Modell.52
Begründung: GitHub Flow ist ein schlankeres Modell als das komplexere Gitflow. Es fördert Agilität und Continuous Integration/Delivery, da der main-Branch stets den neuesten stabilen (potenziell auslieferbaren) Zustand repräsentiert.52 Feature-Entwicklung geschieht in kurzlebigen Branches, die direkt von main abzweigen und nach Code-Review und erfolgreichen CI-Prüfungen wieder in main gemerged werden.52 Dies passt gut zu einem Projekt, das auf schnelle Iteration abzielt. Langwierige develop- oder release-Branches werden vermieden, was den Prozess vereinfacht.53 Die Wahl von GitHub Flow, das die kontinuierliche Auslieferung betont, erfordert zwingend eine robuste Continuous Integration Pipeline, um die Stabilität des main-Branches sicherzustellen.52 Jeder Merge in main sollte idealerweise auslieferbar sein. Ohne starke automatisierte Tests steigt das Risiko, Regressionen in die Hauptentwicklungslinie einzuführen. Die explizite Verknüpfung der Wahl des Branching-Modells mit der Notwendigkeit einer umfassenden Teststrategie unterstreicht diese Abhängigkeit und stellt sicher, dass Tests priorisiert werden.
Implementierung: Der main-Branch ist geschützt (direkte Pushes sind verboten). Alle Entwicklungsarbeiten erfolgen in Feature-Branches, die von main erstellt werden (z.B. feature/neues-widget, fix/crash-im-compositor). Pull Requests (PRs) sind für das Mergen in main obligatorisch. Jeder PR erfordert mindestens ein positives Code-Review von einem anderen Teammitglied und das Bestehen aller CI-Checks (Kompilierung, Tests, Linter, Formatter). Es werden Konventionen für Commit-Nachrichten festgelegt (z.B. Conventional Commits), um die Historie nachvollziehbar zu gestalten und automatisierte Changelog-Generierung zu ermöglichen.


4.6. Teststrategie:

Unit-Tests: Umfassende Unit-Tests für Komponenten der Kern- und Domänenschicht sind obligatorisch. Tests sollen direkt neben dem zu testenden Code im selben Modul oder in einem Untermodul tests liegen (#[cfg(test)]). Eine hohe Codeabdeckung durch Unit-Tests wird angestrebt.
Integrationstests: Integrationstests sind im tests/-Verzeichnis auf Crate-Ebene erforderlich. Sie testen das Zusammenspiel verschiedener Module oder Schichten (z.B. ein UI-Befehl löst eine Aktion in der Systemschicht aus, die den Zustand in der Domänenschicht ändert) und die Interaktion mit externen Schnittstellen (z.B. gemockte D-Bus-Dienste, simulierte Wayland-Ereignisse).
Compositor-Tests: Die Testbarkeit des Compositors (Systemschicht) ist eine Herausforderung. Es sollen Möglichkeiten evaluiert werden, wie z.B. die Verwendung von verschachtelten/headless Wayland-Backends (falls von Smithay oder Abhängigkeiten unterstützt) oder spezialisierte Test-Clients, um Kernlogiken des Compositors (Fensterplatzierung, Protokollimplementierungen) zu verifizieren.
UI-Tests: Das Testen der grafischen Benutzeroberfläche (UI-Schicht) ist komplex. Der Ansatz muss noch definiert werden. Mögliche Strategien umfassen die Nutzung von Accessibility-APIs zur Inspektion und Steuerung von Widgets, die Simulation von Eingabeereignissen auf Wayland-Ebene oder den Einsatz von Frameworks für visuelle Regressionstests (falls für GTK4/Rust verfügbar). Aufgrund der Komplexität wird zunächst ein Fokus auf Tests der unteren Schichten gelegt.
CI-Pipeline: Alle definierten Tests (Unit, Integration) müssen in der Continuous Integration (CI) Pipeline erfolgreich durchlaufen, bevor Code in den main-Branch gemerged werden darf. Die CI-Pipeline beinhaltet außerdem Prüfungen für Code-Formatierung (cargo fmt --check), Linting (cargo clippy -- -D warnings) und Sicherheitslücken in Abhängigkeiten (cargo audit).


4.7. Dokumentation:

Code-Dokumentation: Umfassende rustdoc-Kommentare sind für alle öffentlichen APIs (Crates, Module, Funktionen, Typen, Felder) zwingend erforderlich.46 Die Dokumentation soll nicht nur beschreiben, was eine Komponente tut, sondern auch warum und wie sie verwendet wird. Sie muss Erklärungen zur Logik, zu Invarianten, zu möglichen Fehlerbedingungen (Errors-Sektion) und zu Sicherheitsaspekten (# Safety-Sektion für unsafe Code) enthalten.46 Aussagekräftige Code-Beispiele (#[doc(inline)] oder in separaten examples/-Verzeichnissen) sind essenziell.46
Architektur-Dokumentation: High-Level-Architekturdiagramme (z.B. C4-Modell, Schichtendiagramme, Komponentendiagramme) müssen erstellt und aktuell gehalten werden, um das Gesamtsystem zu beschreiben. Dieses Spezifikationsdokument dient als zentrales Referenzdokument.
READMEs: Jedes Crate und jede größere Komponente muss eine README.md-Datei besitzen, die den Zweck, die Hauptfunktionen und grundlegende Nutzungsanweisungen beschreibt.
Metadaten: Alle Cargo.toml-Dateien müssen vollständige und korrekte Metadaten enthalten, einschließlich authors, description, license, repository, homepage, documentation, keywords und categories.46 Dies ist wichtig für die Veröffentlichung und Auffindbarkeit.


V. Initiale Schichtspezifikationen (Grobe Komponentenübersicht)Diese Übersicht dient dazu, Entwicklern eine erste Vorstellung von den Hauptkomponenten innerhalb jeder Schicht zu geben und den Kontext für die detaillierten Implementierungsleitfäden zu schaffen.
5.1. Kernschicht (Core Layer) Komponenten:

core::types: Fundamentale Datenstrukturen (z.B. Point, Rect, Size, Color), gemeinsam genutzte Enums (z.B. Orientation).
core::errors: Basis-Fehlertypen/-Traits (z.B. ein generischer CoreError), ggf. unter Verwendung von thiserror.
core::logging: Makros und Initialisierungsfunktionen für das tracing-Framework.
core::config: Primitive zum Laden und Parsen von Basiskonfigurationen (z.B. aus Dateien).
core::utils: Allgemeine Hilfsfunktionen (String-Manipulation, mathematische Helfer, etc.).


5.2. Domänenschicht (Domain Layer) Komponenten:

domain::theming: Logik der Theming-Engine, Verwaltung von Design-Tokens, Regeln zur Anwendung von Themes (Hell/Dunkel, Akzentfarben).
domain::workspaces: Verwaltungslogik für Arbeitsbereiche (Erstellung, Löschung, Wechsel, Zuweisung von Fenstern). Implementiert Konzepte wie "Spaces".
domain::ai: Kernlogik für KI-Interaktionen, Verwaltung von Einwilligungsrichtlinien, Kontextaufbau für MCP-Anfragen.
domain::settings: Repräsentation und Logik zur Verwaltung des Zustands der Desktop-Einstellungen (unabhängig von der Speicherung oder UI).
domain::notifications: Logik zur Verwaltung des Benachrichtigungszustands, Historie, Filterung und Priorisierung.
domain::window_management: High-Level-Regeln und Richtlinien für Fensterplatzierung, Logik für automatisches Tiling und Snapping (die "Policy").


5.3. Systemschicht (System Layer) Komponenten:

system::compositor: Die eigentliche Smithay-basierte Wayland-Compositor-Implementierung. Verwaltet Wayland-Surfaces, integriert Rendering-Backends (z.B. OpenGL ES via EGL), implementiert Wayland-Protokolle (xdg-shell, wlr-layer-shell, xdg-decoration, etc.).
system::input: Integration von libinput, Verarbeitung von Tastatur-, Maus- und Touchpad-Ereignissen, Gestenerkennung, Verwaltung von Tastaturlayouts, Fokus-Handling auf Wayland-Ebene.
system::dbus: Schnittstellenmodule für die Interaktion mit spezifischen System-D-Bus-Diensten (NetworkManager, UPower, logind, org.freedesktop.Notifications, Secret Service, PolicyKit). Enthält D-Bus Service- und Client-Implementierungen.
system::outputs: Implementierung der wlr-output-management und wlr-output-power-management Protokolle serverseitig; Handhabung von Display-Konfigurationsänderungen (via D-Bus oder direkt).
system::xwayland: Logik zur Integration und Verwaltung des XWayland-Servers unter Verwendung der von Smithay bereitgestellten Hilfsmittel.13
system::audio: Client-Integration für PipeWire zur Steuerung der Systemlautstärke, Auswahl von Audio-Geräten und ggf. Verwaltung von Anwendungs-Streams.37
system::mcp: Implementierung des MCP-Clients, der die sichere Kommunikation mit MCP-Servern (lokal oder remote) abwickelt.32
system::portals: Logik zur Interaktion mit XDG Desktop Portal D-Bus-Schnittstellen, um Anfragen von Anwendungen (z.B. Datei öffnen) zu bedienen.43


5.4. Benutzeroberflächenschicht (User Interface Layer) Komponenten:

ui::shell: Implementierung der Haupt-Shell-UI mit GTK4 und wlr-layer-shell. Enthält Panels/Leisten, die dynamische Tab-Leiste/Panel, Anwendungsmenü/-starter, System-Tray-Äquivalent.
ui::control_center: GTK4-Implementierung der modularen Einstellungsoberfläche. Kommuniziert über D-Bus oder interne APIs mit der System-/Domänenschicht.
ui::widgets: Implementierung des Widget-Systems. Enthält die Seitenleiste, Logik zum Laden, Anzeigen und Verwalten von Widgets (inkl. Drag & Drop). Beinhaltet Standard-Widgets (Uhr, Kalender, Wetter, Systemmonitor) als GTK4-Komponenten.
ui::window_manager_frontend: Verantwortlich für UI-Aspekte des Fenstermanagements: Client-seitige Dekorationen (falls CSD verwendet wird, Verhandlung via xdg-decoration), Fensterwechsler-UI (Übersichtsmodus/"Exposé", Alt-Tab). Interagiert mit dem Compositor (via wlr-foreign-toplevel-management Client-seitig) und internen APIs.
ui::notifications: Frontend-Komponente (GTK4) zur Anzeige von Benachrichtigungen, die über den D-Bus-Benachrichtigungsdienst empfangen werden. Implementiert das Benachrichtigungszentrum.
ui::theming_gtk: Wendet die von der Domänenschicht (Theming Engine) generierten CSS-Stile auf GTK-Widgets an. Implementiert die Logik zur Anforderung von Theme-Wechseln zur Laufzeit.
ui::components: Sammlung wiederverwendbarer, anwendungsspezifischer GTK4-Widgets und UI-Komponenten (z.B. spezielle Buttons, Layout-Container).
ui::speed_dial: GTK4-Implementierung der Speed-Dial-Startansicht.
ui::command_palette: GTK4-Implementierung der kontextuellen Befehlspaletten-UI.


VI. Deployment-ÜberlegungenDie Auslieferung und Installation einer vollständigen Desktop-Umgebung ist komplexer als die einer einzelnen Anwendung. Es erfordert eine tiefere Integration in das Basissystem.
6.1. Paketierung:

Es müssen Ziel-Paketierungsformate definiert werden (z.B. native Pakete wie .deb/.rpm, möglicherweise auch Flatpak für Teile der Umgebung oder für die SDK-Bereitstellung). Der Build-Prozess zur Erstellung dieser Artefakte muss spezifiziert werden, inklusive der Handhabung von Abhängigkeiten. Standardverfahren für Linux-Systembereitstellungen 54 können als Referenz dienen, müssen aber für die Bereitstellung einer Kern-Desktop-Umgebung (statt nur eines Agenten) angepasst werden. Die Bereitstellung einer Desktop-Umgebung erfordert eine tiefere Systemintegration (z.B. Display-Manager-Konfiguration, systemd User-Sessions, PAM-Module) als die in den Referenzen beschriebene Agenten-Installation. Diese Komplexität muss bei der Planung der Installationsroutine berücksichtigt werden.


6.2. Konfiguration:

Die Bereitstellung von Standardkonfigurationen und die Möglichkeit für Benutzer, diese zu überschreiben, muss spezifiziert werden. Dabei ist die XDG Base Directory Specification strikt einzuhalten ($XDG_CONFIG_HOME, $XDG_DATA_HOME, $XDG_STATE_HOME) 34, um eine saubere Trennung von Benutzerdaten und Systemkonfiguration zu gewährleisten.


6.3. Updates:

Eine Strategie für die Auslieferung von Updates muss definiert werden (z.B. über die Paketmanager der Distributionen, Flatpak-Updates). Dies beinhaltet Überlegungen zur Versionierung und zur Handhabung von Konfigurationsänderungen bei Updates.


VII. SchlussfolgerungDiese technische Gesamtspezifikation legt das Fundament für die Entwicklung der neuen Linux-Desktop-Umgebung. Sie definiert eine klare, geschichtete Architektur, wählt einen modernen und robusten Technologie-Stack basierend auf Rust, Wayland, GTK4 und Smithay und etabliert wesentliche Entwicklungsrichtlinien für Qualität, Konsistenz und Wartbarkeit.Die getroffenen Entscheidungen bezüglich Architektur, Technologien (wie Rust für Sicherheit und Leistung, Smithay für einen nativen Wayland-Compositor, GTK4 für die UI und Theming, MCP für KI-Integration) und Richtlinien (wie GitHub Flow, thiserror für Fehlerbehandlung, tracing für Logging) bilden die Grundlage für die nachfolgenden, detaillierten Implementierungsleitfäden der einzelnen Schichten und Komponenten.Durch die konsequente Einhaltung dieser Spezifikation soll eine hochwertige, moderne, sichere und anpassungsfähige Desktop-Umgebung entstehen, die den Anforderungen von Entwicklern, Kreativen und alltäglichen Nutzern gerecht wird und eine intuitive, effiziente und persönliche Benutzererfahrung bietet.

# Ultra-Detaillierter Implementierungsplan: Linux-Desktop-Umgebung

## 1. Einleitung

### 1.1. Zweck und Umfang

Dieses Dokument stellt einen detaillierten, schichtweisen Implementierungsplan für das Linux-Desktop-Umgebungsprojekt dar. Es dient als technischer Leitfaden für das Entwicklungsteam und beschreibt die Schritte, Komponenten und Überlegungen, die für die erfolgreiche Umsetzung des Projekts gemäß den (angenommenen) technischen Gesamtspezifikationen und Entwicklungsrichtlinien erforderlich sind. Der Plan deckt alle architektonischen Schichten ab – Core, Domain, System und UI – und geht detailliert auf Aspekte wie API-Definitionen, Fehlerbehandlung, Logging, Tests und Dokumentation ein. Der Umfang dieses Plans umfasst den gesamten Lebenszyklus der Desktop-Umgebungssoftware, von der Initialisierung bis zur Benutzerinteraktion und Systemintegration.

### 1.2. Angenommene Technische Grundlage

Dieser Implementierungsplan basiert auf der Annahme, dass moderne, robuste Technologien als Fundament dienen. Konkret wird davon ausgegangen, dass **Wayland** als Display-Server-Protokoll und **Rust** als primäre Implementierungssprache verwendet werden. Diese Wahl wird durch die Notwendigkeit von Sicherheit, Performance und moderner Architektur getrieben. Rust bietet Speichersicherheit ohne Garbage Collection, was für Systemsoftware wie eine Desktop-Umgebung von entscheidender Bedeutung ist. Wayland bietet gegenüber älteren Systemen wie X11 Vorteile in Bezug auf Sicherheit, Performance und Einfachheit des Protokolls.

Zentral für die Implementierung ist die Nutzung der **Smithay-Bibliothek**.1 Smithay stellt modulare Bausteine für die Erstellung von Wayland-Kompositoren in Rust bereit. Seine Designziele – gut dokumentiert, sicherheitsorientiert, modular und abstrahierend – passen gut zu den Qualitätsanforderungen dieses Projekts.2 Smithay ist explizit keine einschränkende Framework-Lösung, sondern bietet Werkzeuge, die eine flexible Architektur ermöglichen. Dies erfordert jedoch eine sorgfältige Planung der Architektur und der Komponenteninteraktion, wie sie in diesem Dokument dargelegt wird. Die Verwendung von Smithay beschleunigt die Entwicklung, indem sie grundlegende Wayland-Interaktionen und Zustandsverwaltung abstrahiert.1

### 1.3. Architektonische Übersicht

Die Architektur der Desktop-Umgebung ist in vier logische Schichten unterteilt, um eine klare Trennung der Verantwortlichkeiten und eine hohe Modularität zu gewährleisten:

- **Core:** Die unterste Schicht, verantwortlich für den grundlegenden Prozessstart, die Ereignisschleife, die Initialisierung der Wayland-Verbindung und grundlegende Dienstprogramme wie Logging und Fehlerdefinitionen.
- **Domain:** Enthält die Kernlogik und die Zustandsrepräsentation der Desktop-Umgebung. Sie verwaltet abstrakte Konzepte wie Fenster, Arbeitsbereiche, Ausgaben und Eingabegeräte unabhängig von spezifischen Protokollen oder Rendering-Details.
- **System:** Vermittelt zwischen der Domain-Schicht und der Außenwelt. Implementiert Wayland-Protokollschnittstellen, interagiert mit Grafik-Backends und Systemdiensten (z. B. `logind`).
- **UI:** Verantwortlich für die visuelle Darstellung der Desktop-Elemente (Shell-Komponenten, Fensterinhalte) und die Verarbeitung von Benutzerinteraktionen, die die Präsentation direkt beeinflussen.

Die folgenden Abschnitte detaillieren den Implementierungsplan für jede dieser Schichten sowie übergreifende Aspekte wie Fehlerbehandlung, Logging und Tests.

## 2. Gesamtarchitektur

### 2.1. Schichtverantwortlichkeiten

Eine klare Definition der Verantwortlichkeiten jeder Schicht ist entscheidend für eine saubere Architektur und Wartbarkeit:

- **Core:**
    - Initialisierung und Verwaltung der Haupt-Ereignisschleife (`calloop`).
    - Herstellen und Verwalten der Wayland-Display-Verbindung.
    - Grundlegendes Ressourcenmanagement (z. B. Speicher, Dateideskriptoren).
    - Bereitstellung fundamentaler Hilfsprogramme (zentrale Fehler-Typen, Logging-Initialisierung).
- **Domain:**
    - Definition und Verwaltung der internen Zustandsrepräsentation (z. B. Fensterhierarchien, Fokus, Arbeitsbereichszuordnungen, Ausgabekonfigurationen).
    - Implementierung der "Geschäftslogik" der Desktop-Umgebung (z. B. Fensterplatzierungsregeln, Fokuswechsel-Logik, Workspace-Management).
    - Abstraktion über rohe Wayland-Objekte (z. B. ein "Fenster"-Konzept, das eine `wl_surface` mit einer Rolle kapselt).
    - Zustandsverwaltung für Oberflächen (`wl_surface`) unter Verwendung von Smithay-Primitiven.1
- **System:**
    - Implementierung spezifischer Wayland-Protokoll-Handler (z. B. `xdg-shell`, `wlr-layer-shell`, `wl_seat`).
    - Interaktion mit dem Grafik-Subsystem (z. B. EGL, WGPU, DRM/KMS) für Buffer-Management und Rendering-Kontext.
    - Kommunikation mit Systemdiensten (z. B. `logind` für Sitzungsverwaltung und Geräteberechtigungen).2
    - Verarbeitung von Eingabeereignissen vom Backend (z. B. `libinput`) und Weiterleitung an Clients über Wayland-Protokolle.
- **UI:**
    - Implementierung der Rendering-Pipeline (Zeichnen von Fenstern, Shell-Elementen).
    - Implementierung von Damage Tracking zur Optimierung des Renderings.3
    - Entwicklung und Darstellung von Desktop-Shell-Komponenten (Panel, Launcher, Benachrichtigungen) unter Verwendung von Protokollen wie `wlr-layer-shell`.4
    - Verarbeitung direkter UI-Interaktionen (z. B. Klicks auf Buttons im Panel).
    - Anwendung von Theming und visuellen Stilen.

### 2.2. Komponenteninteraktion

Die Schichten interagieren auf klar definierten Wegen. Ein typischer Ablauf könnte wie folgt aussehen:

1. Ein Hardware-Ereignis (z. B. Tastendruck) wird vom System-Backend (z. B. `libinput`) erfasst.
2. Die Core-Ereignisschleife nimmt das Ereignis entgegen und leitet es an den entsprechenden Handler in der System-Schicht weiter.
3. Die System-Schicht (z. B. `wl_seat`-Handler) interpretiert das Ereignis im Kontext des Wayland-Protokolls.
4. Die System-Schicht interagiert mit der Domain-Schicht, um den relevanten Zustand zu ermitteln (z. B. welches Fenster hat den Fokus?).
5. Basierend auf dem Zustand entscheidet die System-Schicht, das Ereignis an einen Wayland-Client zu senden oder eine Aktion in der Domain-Schicht auszulösen (z. B. Fokuswechsel anfordern).
6. Wenn eine Zustandsänderung in der Domain-Schicht erfolgt (z. B. Fokus wechselt), wird dies registriert.
7. Die UI-Schicht wird über die Zustandsänderung informiert (direkt oder indirekt durch die Notwendigkeit eines Neuzeichnens).
8. Die UI-Schicht rendert die betroffenen Bereiche neu, möglicherweise unter Verwendung von Damage Tracking, um nur die geänderten Teile zu aktualisieren.3 Sie greift dabei auf Zustandsinformationen aus der Domain-Schicht (z. B. Fensterpositionen, Inhalte) und System-Schicht (z. B. Buffer von Clients) zu.

### 2.3. Wichtige Architekturprinzipien

Die Entwicklung folgt diesen Leitprinzipien:

- **Modularität:** Aufbauend auf Smithays Philosophie 2, werden Komponenten so entworfen, dass sie möglichst unabhängig und austauschbar sind.
- **Trennung der Verantwortlichkeiten (Separation of Concerns):** Strikte Einhaltung der Schichtgrenzen, um Abhängigkeiten zu minimieren und die Testbarkeit zu erhöhen.
- **Testbarkeit:** Design für Testbarkeit auf allen Ebenen (Unit, Integration, E2E).
- **Robustheit:** Umfassende Fehlerbehandlung, sicheres Ressourcenmanagement (unterstützt durch Rust) und graceful degradation bei Fehlern.
- **Performance:** Effiziente Algorithmen, insbesondere im Rendering-Pfad (z. B. Damage Tracking 3) und bei der Ereignisverarbeitung.

### 2.4. _Wertvolle Tabelle:_ Matrix der Schichtverantwortlichkeiten

Die folgende Matrix bietet eine Übersicht, welche Schicht primär (P) oder unterstützend (S) für wichtige Funktionalitäten verantwortlich ist.

|   |   |   |   |   |
|---|---|---|---|---|
|**Funktionalität**|**Core**|**Domain**|**System**|**UI**|
|Ereignisverarbeitung (Loop)|P||S||
|Wayland-Verbindung|P||S||
|Zustandsverwaltung (intern)||P|S|S|
|Fenstergeometrie/-logik||P|S|S|
|Workspace-Management||P|S|S|
|Wayland-Protokoll-Impl.|S|S|P||
|Grafik-Backend-Interaktion|S||P|S|
|Rendering||S|S|P|
|Damage Tracking||S|S|P|
|Eingabeverarbeitung (System)|S|S|P||
|Eingabeverarbeitung (Client)||S|P||
|Shell-Komponenten (Logik)||S|S|P|
|Shell-Komponenten (Darst.)|||S|P|
|Konfiguration (Speicher)|S|P|S||
|Konfiguration (Anwendung)||P|S|P|
|Logging|P|S|S|S|
|Fehlerbehandlung (Kern)|P|S|S|S|
|Fehlerbehandlung (Protokoll)||S|P||

Diese Matrix dient als Referenz, um sicherzustellen, dass die Logik in der korrekten Schicht implementiert wird und die Prinzipien der Modularität und Trennung der Verantwortlichkeiten eingehalten werden.

## 3. Core Layer Implementierung

### 3.1. Event Loop Integration (`calloop`)

Die zentrale Ereignisverarbeitung wird mittels der `calloop`-Bibliothek implementiert.5 `calloop` ist eine auf Rückrufen basierende Ereignisschleife, die sich gut für I/O-gebundene Anwendungen wie einen Wayland-Kompositor eignet, der die meiste Zeit auf Ereignisse wartet.

Die Initialisierung erfolgt typischerweise durch `EventLoop::try_new()`. Ein `handle` wird verwendet, um neue Ereignisquellen hinzuzufügen (`handle.insert_source()`). Jede Quelle wird mit einem Callback assoziiert, der bei Eintreten von Ereignissen ausgeführt wird. Die `event_loop.run()`-Methode startet die Schleife und verarbeitet Ereignisse. Sie ermöglicht die Übergabe gemeinsamer Daten (`shared_data`), auf die Callbacks zugreifen können, beispielsweise ein `LoopSignal` zum Beenden der Schleife.5

Eine besondere Herausforderung stellt die Integration von Wayland-Ereignisquellen dar. Der Dateideskriptor der Wayland-Display-Verbindung muss in die `calloop`-Schleife integriert werden. Es ist jedoch entscheidend, die Verwaltung der Wayland-Ereigniswarteschlangen korrekt zu handhaben, insbesondere wenn mehrere Komponenten oder Threads mit der Wayland-Verbindung interagieren könnten (z. B. durch Bibliotheken wie `winit` oder separate Threads für Aufgaben wie die Zwischenablage).6 Die Wayland-Client-Bibliothek erfordert, dass `wl_display_prepare_read_queue` aufgerufen wird, _bevor_ die Ereignisschleife blockiert (z. B. mittels `epoll_wait`), um Race Conditions zu vermeiden und sicherzustellen, dass keine Ereignisse verloren gehen oder falsch verarbeitet werden.6 Ein einfaches Hinzufügen des Wayland-FDs zu `calloop` ist möglicherweise nicht ausreichend, wenn die Warteschlange auch von anderer Stelle beeinflusst werden kann.

Daher muss eine klare Strategie für die Verwaltung der Wayland-Warteschlange definiert werden. Mögliche Ansätze sind:

a) Sicherstellen, dass alle Wayland-Interaktionen ausschließlich über den Haupt-Thread der calloop-Schleife und die von ihr verwalteten Quellen erfolgen.

b) Sorgfältige manuelle Verwendung von wl_display_prepare_read_queue, falls eine tiefere Integration notwendig ist.

c) Isolation von Komponenten mit komplexen Wayland-Interaktionen (wie der in 6 erwähnten Zwischenablage) in separate Threads mit eigenen, sorgfältig verwalteten Verbindungen/Warteschlangen, die über in calloop integrierte Kanäle (z. B. MPSC-Kanäle 5) mit der Hauptschleife kommunizieren.

Diese architektonische Entscheidung hat erhebliche Auswirkungen auf die Komplexität, Performance und das Potenzial für Deadlocks und muss frühzeitig getroffen werden.

### 3.2. Wayland Display & Core Initialisierung

Der Prozess beginnt mit dem Aufbau der Verbindung zum Wayland-Display. Dies kann entweder als verschachtelter Client innerhalb einer bestehenden Wayland- oder X11-Sitzung geschehen (nützlich für Entwicklung und Tests 2) oder direkt auf der Hardware über ein TTY mit DRM/KMS und `udev`-Unterstützung.2

Nach erfolgreicher Verbindung werden die globalen Wayland-Objekte initialisiert. Eine zentrale `State`-Struktur wird definiert, die alle kompositorweiten Ressourcen und Zustände enthält. Hierzu gehört auch die Initialisierung von Smithays `CompositorState`, wie im Beispiel in 1 gezeigt, um die Basis für die Verwaltung von Oberflächen zu legen.

### 3.3. Fundamentales Logging

Ein robustes Logging-System ist von Anfang an unerlässlich. Es wird empfohlen, die `tracing`-Bibliothek oder die `log`-Fassade mit einem geeigneten Backend wie `env_logger` 7 zu verwenden.

Zu Beginn werden grundlegende Logging-Levels (z. B. ERROR, WARN, INFO, DEBUG, TRACE) definiert. Log-Nachrichten sollten standardmäßig Zeitstempel, Modulpfad und Schweregrad enthalten. Wo immer sinnvoll, sollte strukturiertes Logging (z. B. Key-Value-Paare) verwendet werden, um die spätere Analyse und Filterung von Logs zu erleichtern. Die Konfiguration der Log-Levels sollte zur Laufzeit möglich sein (z. B. über Umgebungsvariablen).

### 3.4. Grundlegende Fehlerbehandlung

Ein konsistentes Fehlerbehandlungssystem wird etabliert. Es wird empfohlen, `thiserror` oder eine benutzerdefinierte `enum`-Struktur zu verwenden, um spezifische Fehlertypen für die Core-Schicht (`CoreError`) und potenziell andere Schichten zu definieren. Die Konvention für die Fehlerweitergabe ist `Result<T, ErrorType>`.

Ein grundlegender Panic-Handler wird implementiert, um bei unerwarteten Fehlern aussagekräftige Informationen zu loggen oder anzuzeigen, anstatt stillschweigend abzustürzen. Rusts Ownership- und Borrowing-System hilft, viele Fehlerklassen zur Kompilierzeit zu vermeiden, aber Laufzeitfehler (z. B. I/O-Fehler, Protokollverletzungen durch Clients) müssen explizit behandelt werden.

## 4. Domain Layer Implementierung

### 4.1. Compositor State Management

Die Verwaltung des Zustands von Wayland-Oberflächen (`wl_surface`) ist eine Kernaufgabe des Kompositors. Smithays `CompositorState` und das zugehörige `CompositorHandler`-Trait werden hierfür zentral genutzt.1 Diese Komponenten übernehmen die automatische Verwaltung von Oberflächen, Unteroberflächen (`subsurfaces`) und Regionen, speichern den Zustand kohärent und behandeln die Anwendung von doppelt gepufferten Zuständen.

Der Zugriff auf den Zustand einer Oberfläche erfolgt über die Funktion `with_states`, die Zugriff auf die `SurfaceData`-Instanz der Oberfläche gewährt. `SurfaceData` dient als allgemeiner Container, um anwendungsspezifische Daten (gepuffert oder nicht) mit einer Oberfläche zu assoziieren.1

Der Commit-Lebenszyklus einer Oberfläche wird durch Hooks gesteuert:

- `add_pre_commit_hook`: Wird vor der Anwendung des neuen Zustands aufgerufen. Nützlich für Protokollerweiterungen, um ungültige Zustandsanfragen von Clients zu validieren, bevor sie angewendet werden.
- `add_post_commit_hook`: Wird nach der Anwendung des neuen Zustands aufgerufen. Nützlich für Abstraktionen, die den neuen Zustand weiterverarbeiten müssen.
- `add_destruction_hook`: Wird aufgerufen, wenn die Oberfläche zerstört wird, um zugeordnete Zustände aufzuräumen.1

Die Implementierung von `CompositorHandler::commit` ist der zentrale Punkt, an dem die Domain-Logik auf den neuen, aktuellen Zustand einer Oberfläche reagieren kann, nachdem dieser (und der Zustand synchronisierter Kind-Unteroberflächen) angewendet wurde.1

Wayland verlangt, dass jede darstellbare Oberfläche eine "Rolle" zugewiesen bekommt (z. B. `toplevel`, `popup`, `subsurface`, `layer-surface`). Smithay repräsentiert dies durch einen statischen String-Identifier, der nur einmal pro Oberfläche gesetzt werden kann (`give_role`, `get_role`).1 Die Domain-Schicht ist verantwortlich für die Verwaltung dieser Rollen und die Sicherstellung, dass sie korrekt und konsistent verwendet werden.

### 4.2. Window Management Abstraction

Während Smithay die Mechanismen zur Verwaltung von `wl_surface`-Zuständen bereitstellt 1, benötigt die Desktop-Umgebung höherstufige Konzepte wie "Fenster", "Fokus" und "Stapelanordnung".3 Es ist daher notwendig, innerhalb der Domain-Schicht eine explizite Abstraktionsebene für das Fenstermanagement zu implementieren. Diese Abstraktion kapselt typischerweise eine Wurzel-`wl_surface` mit einer bestimmten Rolle (z. B. `xdg_toplevel`) und verwaltet die damit verbundenen Metadaten und Verhaltensweisen.

Diese Abstraktion ist verantwortlich für:

- **Geometrieverwaltung:** Verfolgung und Verwaltung der Position und Größe von Fenstern im logischen Koordinatensystem des Desktops.3 Dies beinhaltet auch die Handhabung von Geometrie-Constraints, wie z. B. minimale/maximale Größen oder spezielle Begrenzungsrahmen für Popups (möglicherweise pro Ausgabe, wie in 3 vorgeschlagen, um Popups auf einem Monitor zu halten).
- **Stapelanordnung (Z-Order):** Implementierung der Logik zur Verwaltung der Sichtbarkeitsreihenfolge von Fenstern. Dies ist entscheidend für das korrekte Rendering, bei dem Fenster (und ihre Unteroberflächen und Popups) in der richtigen Z-Reihenfolge durchlaufen werden müssen. Optimierungen wie das Überspringen von Oberflächen, die vollständig von anderen opaken Oberflächen verdeckt werden, sollten hier berücksichtigt werden.3
- **Fokusmanagement:** Verfolgung des aktiven Fensters (das Eingabeereignisse empfängt) und Implementierung der Logik für Fokuswechsel (z. B. durch Benutzeraktion oder programmatisch).

Die Schaffung dieser internen Abstraktion ist kritisch. Sie entkoppelt die höhere Fensterverwaltungslogik von den Details der `wl_surface`-Commit-Hooks und der Baumstruktur von Unteroberflächen.1 Ohne diese Abstraktion besteht die Gefahr, dass sich Low-Level-Oberflächenbehandlung und High-Level-Fensterlogik vermischen, was zu schwer wartbarem Code führt. Die API dieser Abstraktion muss klar definiert sein, um eine saubere Interaktion mit der System- und UI-Schicht zu ermöglichen.

### 4.3. Input Abstraction

Die Domain-Schicht verwaltet den _Zustand_ der Eingabegeräte, während die System-Schicht die _Protokoll_-Interaktion übernimmt. Hier werden interne Repräsentationen für Tastaturen, Zeigergeräte (Mäuse, Touchpads) und Touchscreens definiert.

Diese Schicht ist verantwortlich für die Verwaltung von:

- Gerätefähigkeiten (z. B. Anzahl der Maustasten, Touchscreen-Funktionen).
- Gerätezuständen (z. B. aktuell aktives Tastaturlayout, Zeigerbeschleunigungseinstellungen, Tastenzustände wie Caps Lock).
- Zuordnung von Geräten zu "Seats" (logische Gruppierungen von Eingabe- und Ausgabegeräten für einen Benutzer).

### 4.4. Output Configuration

Analog zur Eingabeabstraktion verwaltet die Domain-Schicht den internen Zustand der angeschlossenen Ausgabegeräte (Monitore).

Verantwortlichkeiten umfassen:

- Definition interner Repräsentationen für Ausgaben.
- Verwaltung von Ausgabeeigenschaften: Auflösung (Mode), Position im globalen Koordinatenraum, Skalierungsfaktor, Aktivierungszustand (enabled/disabled), Orientierung.
- Logik zur Anordnung mehrerer Monitore.

Diese Zustandsinformationen werden von der System-Schicht verwendet, um das `wl_output`-Protokoll zu implementieren und von der UI-Schicht für das Rendering.

### 4.5. Workspace/Virtual Desktop Logic

Falls das Desktop-Paradigma virtuelle Desktops oder Workspaces vorsieht, wird die entsprechende Logik in der Domain-Schicht implementiert.

Dies beinhaltet:

- Datenstrukturen zur Darstellung von Workspaces und deren Zuordnung zu Ausgaben.
- Logik zur Verwaltung der Zugehörigkeit von Fenstern zu Workspaces.
- Implementierung von Workspace-Wechsel-Aktionen und deren Auswirkungen auf Fenster-Sichtbarkeit und Fokus.

## 5. System Layer Implementierung

### 5.1. Wayland Protocol Implementation

Diese Schicht ist maßgeblich für die Implementierung der verschiedenen Wayland-Protokolle verantwortlich, die die Kommunikation zwischen dem Kompositor und den Client-Anwendungen ermöglichen. Smithay bietet hierfür zahlreiche Handler und Hilfsprogramme.

- **`wl_compositor` / `wl_subcompositor`:** Die grundlegende Funktionalität wird weitgehend durch Smithays `CompositorState` bereitgestellt.1 Die Integration in die Haupt-`State`-Struktur und die Ereignisschleife ist jedoch erforderlich.
- **Shell Protocols (`xdg-shell`):** Dies ist eines der wichtigsten Protokolle für Desktop-Anwendungen. Es müssen Handler für `xdg_wm_base` (das globale Objekt), `xdg_surface` (bindet eine `wl_surface` an `xdg-shell`), `xdg_toplevel` (für Hauptfenster) und `xdg_popup` (für Menüs, Tooltips etc.) implementiert werden. Anfragen von Clients (z. B. `move`, `resize`, `set_title`, `set_maximized`, `set_fullscreen`) müssen empfangen und in Aktionen auf der Fenstermanagement-Abstraktion der Domain-Schicht übersetzt werden. Ebenso müssen Konfigurationsereignisse (`configure`) an die Clients gesendet und deren Bestätigungen (`ack_configure`) verarbeitet werden.
- **Decoration Protocol (`xdg-decoration`):** Dieses Protokoll dient der Aushandlung zwischen Client und Kompositor, ob Fensterdekorationen vom Client (Client-Side Decorations, CSD) oder vom Kompositor (Server-Side Decorations, SSD) gezeichnet werden sollen.
    - Die Implementierung erfolgt durch Bereitstellung des `zxdg_decoration_manager_v1`-Globals mithilfe von `XdgDecorationState`.8
    - Handler für `zxdg_toplevel_decoration_v1`-Anfragen wie `set_mode` und `unset_mode` müssen implementiert werden.
    - Es ist von entscheidender Bedeutung, die _Semantik_ des Protokolls korrekt umzusetzen. Wie in 9 am Beispiel von SDL dargelegt, dient das Protokoll der _Aushandlung_, nicht ausschließlich der Signalisierung von SSD. Clients könnten fälschlicherweise annehmen, dass SSD verfügbar ist, nur weil der Manager existiert. Der Kompositor muss klar seine bevorzugte Dekorationsart (oder die Fähigkeit zum Wechsel) signalisieren und auf Client-Anfragen entsprechend reagieren. Es muss entschieden werden, ob der Kompositor nur CSD, nur SSD oder beides (ggf. dynamisch umschaltbar) unterstützt, und die Protokoll-Implementierung muss dies widerspiegeln. Die Implementierung muss robust gegenüber potenziell missverständlichen Client-Anfragen sein und die Teststrategie (Abschnitt 7.4) muss die Korrektheit dieser Aushandlung mit verschiedenen Clients überprüfen.
- **Layer Shell Protocol (`wlr-layer-shell-unstable-v1`):** Dieses Protokoll ermöglicht es Clients, Oberflächen zu erstellen, die als Teil der Desktop-Shell fungieren (z. B. Panels, Hintergrundbilder, Benachrichtigungs-Popups, Lock Screens).4
    - Das `zwlr_layer_shell_v1`-Global und die `zwlr_layer_surface_v1`-Schnittstelle müssen implementiert werden.
    - Anfragen wie `get_layer_surface`, `set_layer` (Hintergrund, Unten, Oben, Überlagerung), `set_anchor` (Anheften an Bildschirmkanten), `set_exclusive_zone` (Reservieren von Platz, der von normalen Fenstern freigehalten wird) und `set_keyboard_interactivity` müssen verarbeitet werden.4
    - Der Konfigurationszyklus (initialer Commit ohne Buffer, `configure`-Ereignis vom Kompositor, `ack_configure` vom Client, dann Buffer anhängen) muss korrekt implementiert werden.4
    - Die Eigenschaften dieser Layer-Oberflächen müssen in der Domain-Schicht repräsentiert und in die Rendering-Pipeline der UI-Schicht integriert werden. Die Möglichkeit, `xdg_popup`s relativ zu Layer-Oberflächen zu positionieren (`get_popup`), muss ebenfalls berücksichtigt werden.4
- **Seat & Input Protocols (`wl_seat`, `wl_keyboard`, `wl_pointer`, `wl_touch`):** Das `wl_seat`-Global repräsentiert eine Gruppe von Ein- und Ausgabegeräten für einen Benutzer. Zugehörige Schnittstellen (`wl_keyboard`, `wl_pointer`, etc.) dienen der Übermittlung von Eingabeereignissen an fokussierte Clients. Die System-Schicht empfängt rohe Eingabeereignisse vom Backend (z. B. `libinput`), verarbeitet sie gemäß dem Zustand in der Domain-Schicht (z. B. Fokus, Tastaturlayout) und sendet die entsprechenden Wayland-Ereignisse an die Clients. Die Verwaltung von Tastatur-Keymaps erfordert typischerweise die `libxkbcommon`-Bibliothek.7
- **Output Protocol (`wl_output`):** Das `wl_output`-Global repräsentiert einen Monitor. Die System-Schicht implementiert dieses Global und sendet Ereignisse über Geometrie (`geometry`), verfügbare Modi (`mode`), Skalierungsfaktor (`scale`) und Abschluss der Konfiguration (`done`) an die Clients, basierend auf dem Zustand, der in der Domain-Schicht verwaltet wird.
- **Andere Protokolle:** Je nach Anforderung müssen weitere Protokolle implementiert werden, z. B.:
    - Datenübertragung (`wl_data_device_manager` für Drag-and-Drop und Copy-Paste).
    - Primäre Auswahl (`gtk_primary_selection_device_manager`).
    - Präsentationszeit (`wp_presentation` für Frame-Callbacks und Timing).
    - Bildschirmaufnahme (`xdg-desktop-portal` oder spezifische Protokolle wie `wlr-screencopy-unstable-v1`).

### 5.2. _Wertvolle Tabelle:_ Wayland-Protokoll-Implementierungsplan

Diese Tabelle dient der Nachverfolgung des Implementierungsstatus und wichtiger Aspekte der einzelnen Protokolle.

|   |   |   |   |
|---|---|---|---|
|**Protokoll/Interface**|**Status**|**Smithay Handler/Util**|**Wichtige Überlegungen**|
|`wl_compositor`|Benötigt|`CompositorState`, `CompositorHandler`|Basis für Oberflächenverwaltung, von Smithay weitgehend abgedeckt.1|
|`wl_subcompositor`|Benötigt|`CompositorState`|Verwaltung von Unteroberflächen, Teil von `CompositorState`.1|
|`xdg_wm_base`|Benötigt|`XdgShellState`, `XdgShellHandler`|Zentral für Desktop-Anwendungen; komplexe Zustandsverwaltung (Konfiguration, Rollen).|
|`xdg_surface`, `xdg_toplevel`|Benötigt|`XdgShellState`, `ToplevelSurface`|Handling von Fenster-Requests (move, resize, maximize etc.), Konfigurationszyklus.|
|`xdg_popup`|Benötigt|`XdgShellState`, `PopupSurface`|Positionierung relativ zu Eltern, Greifen von Eingaben.|
|`zxdg_decoration_manager_v1`|Benötigt|`XdgDecorationState` 8|Korrekte Implementierung der CSD/SSD-Aushandlung ist kritisch, Client-Verhalten beachten.9|
|`zwlr_layer_shell_v1`|Benötigt|`LayerShellState` (oder Äquivalent)|Für Shell-UI-Elemente; Konfigurationszyklus, `exclusive_zone`, `anchor` beachten.4|
|`wl_seat`|Benötigt|`SeatState`, `SeatHandler`|Verwaltung von Fähigkeiten (Tastatur, Zeiger, Touch) und Fokus.|
|`wl_keyboard`|Benötigt|`KeyboardHandle`|Keymap-Handling (via `libxkbcommon` 7), Senden von Tastenereignissen.|
|`wl_pointer`|Benötigt|`PointerHandle`|Senden von Bewegungs-, Tasten-, Achsenereignissen; Cursor-Management.|
|`wl_touch`|Optional|`TouchHandle`|Senden von Touch-Ereignissen (down, up, motion).|
|`wl_output`|Benötigt|`OutputManagerState` (oder Äquiv.)|Senden von Geometrie, Modus, Skalierung an Clients.|
|`wl_data_device_manager`|Empfohlen|`DataDeviceState`|Für Copy-Paste und Drag-and-Drop.|
|`wp_presentation`|Empfohlen|`PresentationState` (oder Äquiv.)|Für präzise Frame-Callbacks und Timing-Informationen.|
|`wlr-screencopy-unstable-v1`|Optional|Eigene Implementierung|Für Bildschirmaufnahmen/Screenshots.|

_Status: Benötigt, Empfohlen, Optional, In Arbeit, Implementiert, Getestet_

### 5.3. Graphics Backend Abstraction

Die System-Schicht muss mit dem Grafik-Subsystem des Hosts interagieren, um Fensterinhalte darzustellen. Eine Abstraktionsschicht ist hier sinnvoll, um die Kopplung an eine spezifische Grafik-API zu minimieren.

Mögliche Backends sind:

- **EGL + OpenGL ES:** Der traditionelle Ansatz für viele Wayland-Kompositoren.
- **WGPU:** Eine moderne Grafikabstraktion in Rust, die über verschiedene native Backends (Vulkan, Metal, DirectX 12, OpenGL ES) laufen kann. Die Verwendung von `wgpu` wird in der Wayland/Smithay-Community untersucht und eingesetzt.7

Die Abstraktion muss folgende Aufgaben übernehmen:

- **Backend-Initialisierung:** Laden der Grafiktreiber, Erstellen von Kontexten (EGL-Kontext, WGPU-Instanz/Device).
- **Buffer-Management:** Handhabung von Client-bereitgestellten Buffern über `wl_buffer`. Dies umfasst Shared Memory Buffers (SHM) und idealerweise DMA-BUFs für effiziente, kopierfreie Übergabe von Grafikdaten von Clients (insbesondere GPUs) an den Kompositor.
- **Rendering-Synchronisation:** Sicherstellen, dass Frames zum richtigen Zeitpunkt (z. B. VSync) auf dem Bildschirm angezeigt werden.
- **Integration mit DRM/KMS:** Bei Ausführung direkt auf der Hardware (`--tty-udev`-Backend 2) ist eine direkte Interaktion mit dem Direct Rendering Manager (DRM) und Kernel Mode Setting (KMS) zur Ansteuerung der Monitore erforderlich. Smithay bietet hierfür Hilfsmittel.

Die Wahl des Backends hat Auswirkungen auf die Systemanforderungen und die Komplexität der Implementierung. WGPU bietet potenziell breitere Kompatibilität und modernere Features, kann aber auch komplexer in der Handhabung sein.

### 5.4. Session & Permissions Integration

Wenn der Kompositor direkt auf der Hardware läuft (nicht verschachtelt), benötigt er spezielle Berechtigungen für den Zugriff auf Eingabe- und Ausgabegeräte (DRM/KMS, `libinput`). Diese Berechtigungen werden typischerweise über einen Session Manager wie `logind` (Teil von `systemd`) oder `seatd` (eine leichtere Alternative) verwaltet.

Die System-Schicht muss:

- Mit dem aktiven Session Manager über dessen D-Bus-Schnittstelle oder Client-Bibliothek kommunizieren.
- Geräte-Dateideskriptoren sicher öffnen und Berechtigungen wieder freigeben, wenn der Kompositor beendet wird oder die Sitzung wechselt.
- Auf Ereignisse wie Geräte-Hotplugging (An-/Abstecken von Monitoren, Mäusen etc.) und Sitzungswechsel reagieren.

Smithay bietet Unterstützung für die Integration mit `libinput` und DRM/KMS, oft in Verbindung mit `logind` oder `seatd`. Die korrekte Handhabung von Berechtigungen ist entscheidend für die Sicherheit und Stabilität des Systems.2

## 6. UI Layer Implementierung

### 6.1. Rendering Pipeline

Die UI-Schicht ist verantwortlich für das tatsächliche Zeichnen jedes Frames auf dem Bildschirm. Die Rendering-Pipeline umfasst typischerweise folgende Schritte:

1. **Szenenbeschreibung erstellen:** Basierend auf dem Zustand in der Domain-Schicht (Fensterpositionen, Z-Order, Sichtbarkeit, Workspace) und System-Schicht (verfügbare Client-Buffer) wird eine Liste der darzustellenden Elemente erstellt.
2. **Oberflächen durchlaufen:** Iteration durch die sichtbaren Oberflächen (Fenster, Layer-Shell-Elemente, Popups, Unteroberflächen) in der korrekten Z-Reihenfolge (von hinten nach vorne).3
3. **Oberflächeninhalte abrufen:** Zugriff auf die Texturen oder Pixeldaten der Oberflächen. Dies können SHM-Buffer sein, die auf die GPU hochgeladen werden müssen, oder direkt verwendbare DMA-BUF-Texturen.
4. **Komposition:** Zeichnen der Oberflächeninhalte auf den Ziel-Framebuffer (des Bildschirms). Dies beinhaltet Transformationen (Positionierung, Skalierung), Clipping und Blending (für Transparenz). Opake Regionen von Oberflächen können genutzt werden, um das Zeichnen dahinterliegender Oberflächen zu überspringen.3
5. **Shell-Elemente zeichnen:** Rendern von UI-Komponenten wie Panels, Cursor usw.
6. **Frame einreichen:** Übergabe des fertigen Frames an das Grafik-Backend zur Anzeige.

**Damage Tracking:** Ein entscheidender Aspekt für die Performance ist das Damage Tracking. Anstatt jeden Frame komplett neu zu zeichnen, sollten nur die Bereiche des Bildschirms aktualisiert werden, die sich seit dem letzten Frame geändert haben.3 Dies reduziert die GPU-Last und den Energieverbrauch erheblich.

Die Implementierung von Damage Tracking ist jedoch komplex:

- Es muss nicht nur der Inhalt von Oberflächen verfolgt werden (was Smithay teilweise für SHM-Buffer unterstützt), sondern auch Änderungen an der Szene selbst: Fensterbewegungen, Größenänderungen, das Erscheinen oder Verschwinden von Fenstern/Oberflächen.3
- Ein möglicher Algorithmus (angelehnt an 3):
    1. Sammle alle "beschädigten" Rechtecke auf dem Bildschirm: die Bounding Box von neuen Fenstern, die _alte_ Bounding Box von entfernten Fenstern, die _alte und neue_ Bounding Box von bewegten/skalierten Fenstern, und die von Clients gemeldeten Schadensregionen auf Oberflächen (übersetzt in globale Koordinaten).
    2. Optimiere optional die Liste der Schadensrechtecke (z. B. durch Zusammenfassen überlappender Rechtecke).
    3. Für jedes Schadensrechteck: Ermittle alle Oberflächen, die dieses Rechteck überlappen. Zeichne die relevanten Teile dieser Oberflächen (unter Berücksichtigung der Z-Order und opaker Regionen) innerhalb des Schadensrechtecks neu.

Die Implementierung von effektivem Damage Tracking erfordert sorgfältige Zustandsverwaltung (Speichern des vorherigen Frame-Zustands) und geometrische Berechnungen. Es ist keine triviale Optimierung, sondern ein Kernmerkmal für eine performante Desktop-Umgebung. Es sollte als eigenständiges, komplexes Teilprojekt betrachtet werden, das iterative Entwicklung, Tests und Performance-Profiling erfordert.

### 6.2. Desktop Shell Components

Die UI-Schicht implementiert die sichtbaren Komponenten der Desktop-Shell. Dazu gehören typischerweise:

- **Panel/Taskleiste:** Anzeige von laufenden Anwendungen, System-Tray, Uhrzeit, Menüs.
- **Application Launcher:** Menü oder Übersicht zum Starten von Anwendungen.
- **Notification System:** Anzeige von Benachrichtigungen von Anwendungen.
- **Background Manager:** Anzeige und Verwaltung des Desktophintergrunds.
- **Lock Screen:** Bildschirmsperre bei Inaktivität oder auf Anforderung.
- **Cursor:** Darstellung des Mauszeigers.

Diese Komponenten werden oft als spezielle Wayland-Clients implementiert, die das `wlr-layer-shell-unstable-v1`-Protokoll verwenden, um sich korrekt auf dem Bildschirm zu positionieren (z. B. Panel am oberen Rand), Platz zu reservieren (`exclusive_zone`) und Eingabeverhalten zu steuern.4 Alternativ könnten einige Komponenten direkt im Kompositor-Prozess gerendert werden, was jedoch die Modularität verringern kann. Die Wahl hängt von der gewünschten Architektur ab. Bestehende Werkzeuge oder Bibliotheken aus dem Ökosystem (z. B. Konzepte aus `wlr-screen-fade` 7 für Übergänge) könnten als Inspiration dienen oder wiederverwendet werden.

### 6.3. Client Toolkit Integration (Optional)

Wenn die Shell-Komponenten selbst mit einem UI-Toolkit (wie GTK, Qt oder einem Rust-basierten Toolkit) erstellt werden, muss die Integration dieses Toolkits mit Wayland berücksichtigt werden. Wenn diese Komponenten als separate Prozesse laufen, agieren sie als normale Wayland-Clients. Das `smithay-client-toolkit` 7 könnte relevant sein, wenn UI-Komponenten ebenfalls in Rust geschrieben werden und Wayland-Client-Funktionalität benötigen.

### 6.4. Theming and Configuration API

Die UI-Schicht muss Mechanismen zur Anpassung des Erscheinungsbilds und Verhaltens bereitstellen:

- **Theming:** Laden und Anwenden von visuellen Themen (Icons, Cursor-Themes, Stile für Shell-Komponenten). Dies erfordert definierte Schnittstellen und Konventionen für Theme-Dateien.
- **Konfiguration:** Eine API oder ein Mechanismus (z. B. D-Bus-Schnittstelle, Konfigurationsdateien), über den Benutzer oder Einstellungs-Tools das Verhalten der Desktop-Umgebung anpassen können (z. B. Tastenkürzel, Erscheinungsbild, Ausgabeeinstellungen, Panel-Konfiguration). Der Zustand dieser Konfiguration wird typischerweise in der Domain-Schicht gehalten, während die UI-Schicht ihn anwendet und ggf. Einstellungsdialoge bereitstellt.

## 7. Cross-Cutting Concerns Implementation Strategy

Diese Aspekte betreffen alle Schichten und erfordern eine konsistente Strategie.

### 7.1. API Design & Documentation

- **Interne APIs:** Es werden strenge Richtlinien für das Design interner Rust-APIs festgelegt (Modulstruktur, Namenskonventionen, Nutzung des Typsystems zur Sicherstellung von Invarianten, Sichtbarkeitsregeln).
- **Dokumentation:** Umfassende Dokumentation aller öffentlichen APIs, Module und komplexen Funktionen mittels `rustdoc` ist obligatorisch. Besonderes Augenmerk liegt auf der Dokumentation der Zustandsverwaltung, der erwarteten Invarianten, der Thread-Sicherheit (falls zutreffend) und potenzieller Fehlerbedingungen. Das Ziel ist eine Dokumentationsqualität ähnlich der von Smithay selbst.2

### 7.2. Error Handling Strategy

Aufbauend auf den grundlegenden Fehlertypen der Core-Schicht wird eine detaillierte Strategie definiert:

- **Fehler-Typen:** Spezifische Fehlertypen für jede Schicht oder Hauptkomponente können definiert werden, um den Ursprung von Fehlern besser zu lokalisieren.
- **Fehlerweitergabe:** Klare Regeln für die Weitergabe von Fehlern über Schichtgrenzen hinweg. Interne Fehler sollten geloggt werden, während Protokollfehler (durch fehlerhaftes Client-Verhalten) ggf. zum Schließen der Client-Verbindung führen (`wl_display.error`).
- **Graceful Degradation:** Wo möglich, sollte das System versuchen, bei Fehlern in nicht-kritischen Komponenten weiterzuarbeiten.
- **Ressourcenbereinigung:** Robuste Mechanismen (unterstützt durch Rusts RAII) zur Freigabe von Ressourcen (Speicher, Dateideskriptoren, Wayland-Objekte) im Fehlerfall sind essenziell.

### 7.3. Structured Logging Implementation

Das grundlegende Logging wird erweitert:

- **Strukturiertes Logging:** Konsequente Verwendung von strukturiertem Logging (z. B. mit `tracing` und Feldern), um Logs maschinenlesbar und leichter analysierbar zu machen. Wichtige Identifikatoren (z. B. Client-ID, Surface-ID) sollten in den Logs enthalten sein.
- **Log-Punkte:** Definierte Log-Punkte für kritische Ereignisse (z. B. Start/Ende von Rendering-Phasen, Fokuswechsel, Fenstererstellung/-zerstörung, wichtige Protokollanfragen, Fehler).
- **Dynamische Konfiguration:** Die Log-Levels sollten zur Laufzeit anpassbar sein, um die Fehlersuche im Betrieb zu erleichtern.

### 7.4. Testing Strategy

Ein mehrschichtiger Testansatz ist erforderlich:

- **Unit Tests:** Testen isolierter Funktionen und Module, insbesondere für die reine Logik in der Domain-Schicht (z. B. Fensterplatzierungsalgorithmen, Zustandsübergänge). Rusts integriertes Test-Framework (`#[test]`) wird hierfür genutzt.
- **Integration Tests:** Testen das Zusammenspiel von Komponenten innerhalb einer Schicht oder über Schichtgrenzen hinweg. Beispiel: Überprüfen, ob eine `xdg-toplevel.set_maximized`-Anfrage (System-Schicht) korrekt den Zustand des entsprechenden Fensters in der Domain-Schicht ändert.
- **End-to-End (E2E) Tests:** Testen vollständiger Benutzerszenarien aus der Sicht eines Clients oder Benutzers. Dies ist die komplexeste Testebene.
    - **Testumgebungen:** Ähnlich wie bei Smithays Beispielkompositor Anvil 2 sollten Tests in verschiedenen Umgebungen laufen können:
        - **Verschachtelt (Nested):** Ausführung des Kompositors als Client innerhalb einer bestehenden X11- oder Wayland-Sitzung (mittels `--winit` oder `--x11` Backends). Dies ist ideal für automatisierte Tests in CI/CD-Pipelines, da keine spezielle Hardware benötigt wird.
        - **TTY/DRM:** Ausführung direkt auf der Hardware (`--tty-udev` Backend). Notwendig, um die Interaktion mit DRM/KMS, `libinput` und die Sitzungsverwaltung zu testen.
    - **Test-Clients:** Verwendung von Standard-Wayland-Clients (`weston-terminal`, `gedit`, etc.), spezialisierten Test-Clients oder Frameworks (z. B. Wayland-Konformitätstestsuiten) zur Simulation von Client-Verhalten und Überprüfung der Protokollimplementierung. Spezifische Tests sind erforderlich, um die korrekte Handhabung von Protokoll-Nuancen wie der `xdg-decoration`-Aushandlung mit verschiedenen Clients (z. B. SDL-basierten 9) sicherzustellen.

Die Einrichtung und Wartung zuverlässiger Testumgebungen, insbesondere für E2E- und Hardware-Tests, stellt eine erhebliche Herausforderung dar. Die Komplexität ergibt sich aus der Abhängigkeit von spezifischer Hardware (GPUs), Kernel-Modulen (DRM), Systembibliotheken (`libinput`, EGL/WGPU, `libxkbcommon` 7) und dem Verhalten externer Clients.10 Daher müssen explizit Ressourcen für den Aufbau und die Pflege der Testinfrastruktur eingeplant werden. Dies umfasst CI-Pipelines, die verschachtelte Tests ausführen können, und potenziell dedizierte Test-Hardware für den TTY/DRM-Backend. Manuelle Testverfahren bleiben für Aspekte wie subjektive Benutzererfahrung oder schwer automatisierbare Szenarien (z. B. komplexe Multi-Monitor-Setups 10) notwendig.

### 7.5. _Wertvolle Tabelle:_ Komponenten-Teststrategie

|   |   |   |   |   |
|---|---|---|---|---|
|**Komponente/Modul**|**Unit Test Coverage**|**Integration Test Scenarios**|**E2E Test Scenarios**|**Spezifische Tools/Backends**|
|Event Loop (`calloop`)|Mittel|Hinzufügen/Entfernen von Quellen, Timer-Auslösung|Start/Stopp des Kompositors, Reaktion auf Signale|`calloop`-API, MPSC-Kanäle|
|Window Manager (Domain)|Hoch|Fenster erstellen/zerstören, Fokuswechsel, Geometrieänderung|Fenster überlappen, maximieren, minimieren, Workspace wechseln|Interne APIs, Mock-Oberflächen|
|XDG-Shell Handler (System)|Mittel|Client verbindet sich, erstellt Toplevel/Popup, sendet Requests|Starten/Bedienen einer XDG-Client-Anwendung (z. B. `gedit`)|Wayland Test Clients, `xdg-shell`-Protokolltests|
|Layer-Shell Handler (System)|Mittel|Client erstellt Layer Surface, setzt Anchor/Layer/Zone|Starten eines Panels/Docks (als Layer-Client), Interaktion mit normalen Fenstern|Wayland Test Clients (Layer Shell), `wlr-layer-shell`-Tests|
|Renderer (UI)|Niedrig|-|Fenster anzeigen, bewegen, Transparenz, Vollbild|Verschachtelte Backends (`--winit`, `--x11`), Visueller Vergleich|
|Damage Tracker (UI)|Mittel|Berechnung von Schadensregionen für Bewegung/Resize/Inhalt|Fenster bewegen/verändern, nur beschädigte Bereiche neu zeichnen (Profiling)|Verschachtelte Backends, Frame-Analyse-Tools, Profiler|
|Panel UI (UI/System)|Mittel|Interaktion mit Layer Shell, Klick-Handler|Panel anzeigen, Fensterliste aktualisieren, auf Klicks reagieren|Layer Shell Client, Verschachtelte Backends|
|Input Handling (System)|Mittel|Verarbeitung von `libinput`-Events, Weiterleitung an Domain|Tippen in fokussiertem Fenster, Mausbewegung, Klicks|Mock `libinput`, Wayland Test Clients|

_Coverage: Ziel-Codeabdeckung (%), Schlüsselbereiche_

### 7.6. Dependency Management

- **Rust Crates:** Abhängigkeiten werden über `Cargo.toml` verwaltet. Es wird eine Strategie für regelmäßige Updates (`cargo update`) und die Überprüfung auf bekannte Sicherheitslücken benötigt. Tools wie `cargo-deny` oder externe Dienste (wie der in 2 erwähnte) können zur Überwachung eingesetzt werden. Die Auswahl der Abhängigkeiten sollte deren Wartungszustand und Popularität berücksichtigen.2
- **System Dependencies:** Externe Bibliotheken wie `libwayland-client`, `libwayland-server`, `libxkbcommon`, `pkg-config`, `libinput`, EGL/OpenGL/Vulkan-Loader und Treiber müssen auf dem Zielsystem vorhanden sein.7 Der Build-Prozess muss diese Abhängigkeiten überprüfen (z. B. mittels `pkg-config`). Dokumentation und ggf. Build-Skripte müssen die Installation dieser Abhängigkeiten erleichtern.

### 7.7. Build System & CI/CD

- **Build System:** Der Standard `cargo build`-Prozess wird verwendet. Build-Profile (Debug, Release) werden konfiguriert.
- **Continuous Integration (CI):** Eine CI-Pipeline (z. B. GitHub Actions, GitLab CI) wird eingerichtet. Diese sollte bei jedem Commit/Pull Request automatisch:
    - Den Code kompilieren (`cargo build`).
    - Linting-Checks durchführen (`cargo clippy`).
    - Code formatieren (`cargo fmt --check`).
    - Unit- und Integrationstests ausführen (`cargo test`).
    - Idealerweise E2E-Tests in einer verschachtelten Umgebung durchführen.
- **Continuous Deployment (CD):** Optional kann eine CD-Pipeline eingerichtet werden, um z. B. Nightly Builds oder Releases automatisch zu erstellen und zu veröffentlichen.

## 8. Implementation Phasing & High-Level Roadmap

### 8.1. Logical Sequencing

Eine phasierte Implementierung wird vorgeschlagen, um schrittweise Funktionalität aufzubauen und frühes Feedback zu ermöglichen:

- **Phase 1 (Core Setup & Grundstruktur):**
    - Projekt-Setup (Repository, Lizenz, Readme).
    - Implementierung der Core-Schicht: `calloop`-Ereignisschleife, grundlegende Wayland-Verbindung, Logging, Fehlerbehandlung.
    - Einrichtung des Build-Systems und der CI-Pipeline.
    - _Ziel:_ Kompositor startet, verbindet sich mit Wayland (als Client), loggt Nachrichten und kann beendet werden.
- **Phase 2 (System Basics & Rendering-Grundlagen):**
    - Implementierung der System-Schicht-Grundlagen: Grafik-Backend-Initialisierung (z. B. EGL/WGPU), grundlegende DRM/KMS-Integration (falls TTY-Backend benötigt wird).
    - Implementierung wesentlicher Wayland-Protokolle: `wl_compositor`, `wl_output`, `wl_seat`.
    - Minimales Rendering: Fähigkeit, einen einfarbigen Hintergrund oder einen einfachen Client-Buffer anzuzeigen.
    - _Ziel:_ Ein minimaler Wayland-Client (z. B. `weston-simple-shm`) kann sich verbinden und seine Oberfläche wird angezeigt.
- **Phase 3 (Domain & Windowing):**
    - Implementierung der Domain-Schicht: `CompositorState` 1, Fenstermanagement-Abstraktion (Geometrie, Fokus).
    - Implementierung von `xdg-shell` (Toplevels).
    - Grundlegende Fensterinteraktion: Fenster verschieben, Größe ändern (initial ohne Client-Feedback), Fokus per Klick setzen.
    - _Ziel:_ Mehrere `xdg-shell`-Clients können gestartet, angezeigt und rudimentär manipuliert werden.
- **Phase 4 (UI & Shell-Grundlagen):**
    - Implementierung der Rendering-Pipeline mit Komposition mehrerer Oberflächen.
    - Implementierung von grundlegendem Damage Tracking.3
    - Implementierung von `wlr-layer-shell`.4
    - Entwicklung erster Shell-Komponenten (z. B. Hintergrundmanager, einfaches Panel als Layer-Shell-Client).
    - Implementierung von `xdg-popup` und `xdg-decoration` (mit korrekter Aushandlung 9).
    - _Ziel:_ Eine grundlegende Desktop-Shell ist sichtbar, Fenster haben Dekorationen (CSD/SSD), Popups funktionieren.
- **Phase 5 (Advanced Features & Polish):**
    - Implementierung weiterer Wayland-Protokolle (Datenübertragung, etc.).
    - Verbessertes Damage Tracking und Performance-Optimierungen.
    - Vollständige Implementierung aller geplanten Shell-Features (Launcher, Notifications, etc.).
    - Implementierung von Theming und Konfigurationsmechanismen.
    - Umfassende Tests (insbesondere E2E und auf Hardware).
    - Dokumentation vervollständigen.
    - _Ziel:_ Eine funktionsreiche, performante und stabile Desktop-Umgebung.

### 8.2. Key Milestones

Messbare Meilensteine für jede Phase:

- **M1 (Ende Phase 1):** Kompositor läuft stabil in verschachtelter Umgebung, grundlegendes Logging funktioniert, CI ist grün.
- **M2 (Ende Phase 2):** Ein einfacher SHM-Client wird korrekt angezeigt (verschachtelt und/oder TTY). `wl_output` und `wl_seat` sind funktional.
- **M3 (Ende Phase 3):** Mehrere `xdg-toplevel`-Fenster können angezeigt, verschoben und fokussiert werden.
- **M4 (Ende Phase 4):** Grundlegendes Damage Tracking ist aktiv. Ein Panel (Layer Shell) ist sichtbar. Fensterdekorationen (CSD/SSD) funktionieren gemäß Aushandlung. Popups werden korrekt angezeigt.
- **M5 (Ende Phase 5):** Alle Kernfunktionen sind implementiert und getestet. Die Performance ist akzeptabel. Theming und Konfiguration sind möglich.

## 9. Schlussfolgerung

### 9.1. Zusammenfassung

Dieser Plan skizziert einen detaillierten, schichtweisen Ansatz zur Implementierung einer modernen Linux-Desktop-Umgebung. Er basiert auf der Verwendung von Wayland als Protokoll, Rust als Sprache und der Smithay-Bibliothek als Fundament.1 Der Fokus liegt auf Modularität, klarer Trennung der Verantwortlichkeiten zwischen den Schichten (Core, Domain, System, UI), Robustheit durch sorgfältige Fehlerbehandlung und umfassende Tests sowie Performance durch Techniken wie Damage Tracking.3 Besondere Aufmerksamkeit gilt der korrekten Implementierung von Wayland-Protokollen unter Berücksichtigung ihrer Semantik und potenzieller Client-Verhaltensweisen 9, der Notwendigkeit klar definierter interner Abstraktionen (z. B. Fenstermanagement) 1 und der Komplexität der Integration verschiedener Systemkomponenten wie der Ereignisschleife 5 und Testumgebungen.2
Technologien (z. B. Grafik-Backend WGPU vs. EGL/GLES), falls noch nicht festgelegt.

Die konsequente Verfolgung dieses Plans, kombiniert mit agilen Praktiken zur Anpassung an neue Erkenntnisse, legt den Grundstein für die erfolgreiche Entwicklung einer robusten und performanten Linux-Desktop-Umgebung.

# Finale Beschreibung

**Willkommen zu Ihrer neuen Linux Desktop-Erfahrung – Intelligent, Intuitiv, Persönlich**

Stellen Sie sich eine Desktop-Umgebung vor, die nicht nur modern aussieht und sich unglaublich schnell anfühlt, sondern auch mitdenkt und sich Ihnen anpasst. Wir haben den Linux-Desktop von Grund auf neu gestaltet, um Ihnen ein Werkzeug an die Hand zu geben, das Ihre Kreativität beflügelt, Ihre Produktivität steigert und Ihnen bei alltäglichen Aufgaben als intelligenter Partner zur Seite steht – egal ob Sie gestalten, entwickeln, kommunizieren oder einfach die digitale Welt erkunden.

**Eine Benutzeroberfläche, die begeistert und intuitiv führt**

Das Herzstück ist eine Benutzeroberfläche, die Eleganz und Funktionalität meisterhaft vereint. Freuen Sie sich auf eine klare, dunkle Ästhetik (tiefe Grau- und Blautöne bilden eine beruhigende Basis), die durch gezielte, von Ihnen wählbare Akzentfarben – vielleicht ein dynamisches Korallrot oder ein beruhigendes Hellblau – zum Leben erweckt wird. Präzise Konturen und subtile Effekte wie optionale Transluzenz bestimmter Panel-Hintergründe oder ein feines Leuchten aktiver Elemente schaffen eine hochwertige Anmutung.

- **Mühelose Navigation, klare Sicht:** Finden Sie sich sofort zurecht. Menüs, Einstellungen und Systeminformationen sind logisch aufgebaut und leicht erreichbar. Weniger Suchen, mehr Erledigen – das ist unser Versprechen. Die Darstellung ist stets scharf und gut lesbar, dank heller Schrift auf dunklem Grund.
- **Reaktionsschnell und flüssig:** Erleben Sie eine Oberfläche, die ohne Verzögerung auf jede Ihrer Aktionen reagiert. Fenster öffnen sich zügig, Animationen – beispielsweise beim Ein- und Ausklappen der Seitenleisten oder beim Wechseln der Ansichten – sind geschmeidig und unterstützen ein angenehmes, modernes Bediengefühl, ohne jemals aufdringlich zu wirken. Die moderne Wayland-Technologie im Hintergrund macht dies möglich.
- **Ihr persönlicher Stil (Theming):** Machen Sie diesen Desktop zu Ihrem ganz persönlichen Arbeitsplatz. Ein fortschrittliches Theming-System erlaubt es Ihnen, dynamisch zur Laufzeit zwischen verschiedenen Designs zu wechseln – beispielsweise von einem konzentrierten Dunkelmodus zu einem helleren Arbeitsmodus für sonnige Tage. Und das Beste: Wählen Sie Ihre systemweite Lieblings-Akzentfarbe, die sich konsistent durch die gesamte Umgebung und unterstützte Anwendungen zieht. All das, ohne dass Sie etwas neu starten müssen.
- **Intelligente Anpassung:** Die Umgebung lernt mit Ihnen. Häufig genutzte Funktionen und Anwendungen können priorisiert und Layouts basierend auf Ihren Gewohnheiten angepasst werden. Das Ziel: Ihren Arbeitsfluss optimieren und unnötige Kontextwechsel minimieren.
- **Fensterkontrolle – Meisterhaft einfach:** Sie haben die volle Kontrolle. Ändern Sie Fenstertitel, passen Sie Größen stufenlos an oder wechseln Sie mühelos zwischen minimierten, maximierten und ablenkungsfreien Vollbildzuständen. Die Fensterverwaltung ist so intelligent gestaltet, dass Ihr Multitasking-Erlebnis nahtlos und effizient wird.

**Ihre Schaltzentrale – Die Interaktionskomponenten im Detail**

Wir haben jede Komponente sorgfältig entworfen, um Ihnen die Arbeit so angenehm und effizient wie nur möglich zu gestalten:

- **Ihre Hauptoberfläche (Shell-UI):**
    - **Kontroll- und Systemleiste(n):** Am oberen (oder unteren, je nach Wunsch) Bildschirmrand finden Sie eine elegante Leiste. Von hier aus haben Sie schnellen Zugriff auf wichtige Systemfunktionen wie Netzwerk, Lautstärke und Akkuanzeige. Auch das neue, zentrale Benachrichtigungszentrum und eine Übersicht Ihrer laufenden Anwendungen sind hier integriert. Ein optionaler, feiner Leuchtakzent am Rand der Leiste unterstreicht das hochwertige Design.
    - **Intelligente Tab-Leiste pro "Space":** Jeder Ihrer Arbeitsbereiche ("Spaces") verfügt über eine eigene, horizontale Tab-Leiste direkt im Hauptbereich. Hier sehen Sie prominent die Anwendung(en), die Sie für diesen Space als "gepinnt" definiert haben – sei es eine einzelne Anwendung oder eine praktische Split-View-Ansicht. Die Tabs selbst sind modern gestaltet mit abgerundeten oberen Ecken, wobei der aktive Tab durch Ihre gewählte Akzentfarbe hervorgehoben wird. Weitere, nicht gepinnte Anwendungen des Spaces erscheinen dezent als kleinere Tabs oder in einer Überlauf-Liste.
    - **Quick-Settings-Panel:** Direkt aus der Systemleiste herausgeklappt, bietet dieses Panel schnellen Zugriff auf häufig benötigte Einstellungen wie WLAN, Bluetooth, Lautstärke oder den Wechsel in den Dark Mode – ganz ohne den Umweg über das vollständige Control Center.
- **Control Center (Alle Einstellungen fest im Griff):** Eine zentrale, klar strukturierte und modular aufgebaute Ansicht für sämtliche Systemeinstellungen. Konfigurieren Sie Ihr Netzwerk, Bluetooth-Geräte, Audioeinstellungen, Bildschirmhelligkeit und vieles mehr. Dank kontextsensitiver Schnelleinstellungen erledigen Sie viele Anpassungen mit nur wenigen Klicks und sehen bei vielen Optionen direkt eine Live-Vorschau Ihrer Änderungen.
- **Schnellaktionsdock (Ihr persönlicher Schnellzugriff):** Ein von Ihnen frei konfigurierbarer Bereich – schwebend oder am Rand angedockt – in dem Sie Ihre wichtigsten Anwendungen, häufig benötigte Dateien oder oft ausgeführte Aktionen ablegen können. Das Dock kann Ihnen basierend auf Ihrem Kontext auch intelligente Aktionsvorschläge machen und lässt sich vollständig über Tastaturkürzel bedienen.
- **Seitenleisten und Widgets (Information und Organisation auf einen Blick):**
    - **Adaptive Seitenleisten:** Optional können Sie links und rechts des Bildschirms adaptive Seitenleisten einblenden. Diese haben einen leicht abgesetzten, dezent transluzenten Hintergrund und dienen als Heimat für Navigationselemente und nützliche Widgets.
    - **Linke Seitenleiste (Navigation & "Spaces"):** Hier finden Sie den innovativen **Workspace-Switcher**. Im eingeklappten Zustand zeigt er für jeden Ihrer "Spaces" (Arbeitsbereiche) nur ein Icon – entweder das der dort primär "angepinnten" Anwendung oder ein von Ihnen gewähltes Symbol für den Space. Dies ermöglicht einen extrem schnellen visuellen Wechsel zwischen Ihren Arbeitskontexten. Der aktive Space wird dabei dezent hervorgehoben. Bei Mouse-Over oder einer spezifischen Geste klappt der Switcher auf und zeigt zusätzlich den Namen des Spaces sowie optional eine Miniaturansicht oder eine Liste der darin geöffneten Fenster. Auch Elemente wie eine globale Suche oder Schnellzugriffe auf den Anwendungsstarter und die Einstellungen sind hier elegant integriert.
    - **Rechte Seitenleiste (Informative Widgets):** Hier können Sie eine Vielzahl von Widgets platzieren, die Ihnen wichtige Informationen auf einen Blick liefern – von der Uhrzeit und dem Kalender über Wettervorhersagen bis hin zu einem Systemmonitor für CPU- und RAM-Auslastung. Die Widgets sind interaktiv und erlauben oft schnelle Aktionen direkt aus dem Widget heraus (z.B. die Musikwiedergabe steuern oder ein To-Do-Element abhaken).
    - **Drag & Drop Anpassung:** Sowohl die Inhalte der Seitenleisten als auch die Widgets selbst lassen sich einfach per Drag & Drop an Ihre persönlichen Bedürfnisse anpassen.
- **Speed-Dial und Übersichtsmodus (Navigation und Fenster-Management neu definiert):**
    - **Speed-Dial:** Ihre persönliche Startansicht, wenn Sie einen neuen, leeren Arbeitsbereich öffnen. Hier finden Sie nicht nur Ihre Favoriten, sondern auch intelligente Vorschläge für häufig genutzte Anwendungen, kürzlich geöffnete Dokumente oder oft ausgeführte Aktionen – basierend auf Ihren Nutzungsmustern und dem aktuellen Kontext. Die Oberfläche ist anpassbar und verfügt über eine integrierte Suchfunktion.
    - **Übersichtsmodus (Ihr Fenster-Cockpit):** Mit einer einfachen Geste oder einem Tastendruck wechseln Sie in einen eleganten Übersichtsmodus. Hier sehen Sie alle geöffneten Fenster des aktuellen Arbeitsbereichs (oder optional aller Bereiche) als interaktive, verkleinerte Kacheln mit einer Live-Vorschau ihres Inhalts. Der Hintergrund tritt dabei dezent in den Hintergrund (abgedunkelt oder mit Unschärfe), um den Fokus klar auf Ihre Fenster zu legen. Wählen Sie Fenster direkt aus, schließen Sie sie oder verschieben Sie sie mühelos per Drag & Drop zwischen Ihren "Spaces", die im Übersichtsmodus ebenfalls übersichtlich dargestellt werden. Optional können Sie sich Fenster auch gruppiert pro Anwendung anzeigen lassen.
- **Eingabe- und Fokusmanagement (Präzise und komfortabel):**
    - Die Navigation mit der Tastatur ist ein integraler Bestandteil. Logische Tab-Reihenfolgen und eine durchgängige Pfeiltastensteuerung ermöglichen eine effiziente Bedienung auch ohne Maus.
    - Das System stellt sicher, dass immer klar ersichtlich ist, welches Element gerade den Fokus hat, beispielsweise durch einen feinen Rahmen in Ihrer gewählten Akzentfarbe.
    - Für Geräte mit Touchpad bieten wir eine nahtlos integrierte **Gestensteuerung**, die auf präziser `libinput`-Verarbeitung basiert. Wechseln Sie Arbeitsflächen, öffnen Sie die Übersicht oder zeigen Sie alle Fenster einer Anwendung mit intuitiven Multi-Touch-Gesten.
- **Kontextuelle Befehlspalette (Der direkte Draht zu Aktionen):** Für Power-User und alle, die gerne tippen: Eine textbasierte Befehlspalette (standardmäßig aufrufbar via `Super+Space`) ermöglicht es Ihnen, durch Eingabe von Suchbegriffen blitzschnell Aktionen auszuführen, die für den _aktuellen Anwendungs- oder Desktop-Kontext_ relevant sind. Starten Sie Anwendungen, finden Sie spezifische Einstellungen, führen Sie kontextbezogene Befehle aus (z.B. "Neuen Ordner erstellen", wenn der Dateimanager aktiv ist) oder rufen Sie Systemfunktionen auf. Intelligentes Fuzzy-Matching hilft Ihnen dabei, auch dann das Richtige zu finden, wenn Sie sich nicht an den exakten Namen erinnern.

**Der Intelligente Kern – Ihre KI-Assistenz mit Sicherheit und Kontrolle**

Diese Desktop-Umgebung integriert künstliche Intelligenz als unaufdringlichen, hilfreichen Assistenten – stets unter Ihrer vollen Kontrolle und mit höchstem Augenmerk auf Sicherheit und Datenschutz.

- **Sicher und Standardisiert:** Wir nutzen das offene **Model Context Protocol (MCP)**, um Ihren Desktop sicher mit lokalen oder Cloud-basierten Sprachmodellen (LLMs) zu verbinden. Das ermöglicht leistungsstarke KI-Funktionen, ohne Ihre Daten unnötig preiszugeben oder Sie an einen bestimmten Anbieter zu binden.
- **Ihre Zustimmung zählt:** Keine KI-Aktion ohne Ihr Wissen! Bevor eine KI-Funktion auf Ihre Daten zugreift (z.B. eine Datei analysiert) oder eine Systemeinstellung ändert, werden Sie über einen klaren, verständlichen Dialog um Ihre **explizite Zustimmung** gebeten. Sie sehen genau, _was_ die KI tun möchte und _warum_, und können jederzeit "Erlauben" oder "Ablehnen". Sie behalten die volle Kontrolle über Ihre Daten und Ihr System.
- **Feingranulare Berechtigungen:** Ein intelligentes System verwaltet detailliert, welche Aktionen die KI oder bestimmte Widgets durchführen dürfen, basierend auf dem Prinzip der geringsten notwendigen Rechte.
- **Praktische KI-Funktionen im Alltag:**
    - **Intelligente Sprachsteuerung:** Sprechen Sie Befehle wie "Öffne meine E-Mails", "Wie wird das Wetter morgen?" oder "Aktiviere den Nicht-Stören-Modus". Die KI interpretiert Ihre Anweisungen und führt die Aktionen sicher aus – nach Ihrer Zustimmung, falls erforderlich.
    - **Automatisierte Dateiaufgaben:** Lassen Sie die KI den Inhalt von Dokumenten zusammenfassen, Daten aus Verzeichnissen analysieren oder Textentwürfe für E-Mails erstellen. Sie entscheiden, auf welche Dateien oder Ordner die KI zugreifen darf.
    - **Kontextbezogene Web-Informationen in Widgets:** Widgets in Ihrer Seitenleiste können dynamisch relevante Informationen aus dem Web anzeigen, die von der KI basierend auf Ihrer aktuellen Aufgabe vorgeschlagen werden – sicher und ohne Ihre Privatsphäre zu gefährden, da Inhalte vor der Anzeige entsprechend aufbereitet werden.
- **Sichere Speicherung:** Sensible Daten wie Ihre API-Schlüssel für Cloud-basierte KI-Dienste werden sicher im System über die etablierte Freedesktop Secret Service API gespeichert und niemals im Klartext abgelegt.

**Systemintegration und Plattformfunktionen – Nahtlos, Leistungsstark und Sicher**

Diese Desktop-Umgebung ist tief mit den modernen Technologien Ihres Linux-Systems verwoben, um Ihnen eine stabile, sichere und performante Erfahrung zu bieten.

- **Moderne Display-Technologie (Wayland):** Die Basis bildet Wayland, ein modernes und sicheres Display-Server-Protokoll. Das bedeutet für Sie eine ruckelfreie Darstellung, verbesserte Sicherheit und eine zukunftssichere Plattform. Für ältere Anwendungen, die Wayland noch nicht nativ unterstützen, sorgt XWayland für nahtlose Kompatibilität. Die Fensterverwaltung nutzt standardisierte Protokolle wie XDG-Shell für ein konsistentes und vorhersagbares Verhalten.
- **Reibungslose Kommunikation (D-Bus):** Unsichtbar, aber essentiell: D-Bus ermöglicht die reibungslose Kommunikation zwischen verschiedenen Teilen des Desktops und wichtigen Systemdiensten – beispielsweise für die Energieverwaltung (UPower), Netzwerkkonfigurationen (NetworkManager), das Empfangen und Anzeigen von Benachrichtigungen oder die sichere Speicherung von Passwörtern und Schlüsseln.
- **Sicherheit bei wichtigen Aktionen (PolicyKit):** Wenn eine Anwendung oder eine Einstellung erweiterte Rechte benötigt (z.B. um System-Updates zu installieren oder Energieeinstellungen wie den Ruhezustand zu ändern), stellt PolicyKit sicher, dass solche Operationen nur mit Ihrer ausdrücklichen Zustimmung erfolgen, typischerweise nach Eingabe Ihres Passworts.
- **Präzise Eingabeverarbeitung (libinput):** Ihre Eingaben über Tastatur, Maus oder Touchpad werden dank der Integration von libinput präzise und zuverlässig verarbeitet, was zu einer direkten und genauen Interaktion führt.
- **Optimale Darstellung auf allen Bildschirmen:** Verwalten Sie mühelos mehrere Monitore. Die Umgebung unterstützt unterschiedliche Auflösungen, individuelle Skalierungsfaktoren für hochauflösende Displays (HiDPI) und flexible Anordnungen Ihrer Bildschirme.
- **Volle Klangkontrolle (Audio-Management):** Passen Sie die Systemlautstärke einfach an, wählen Sie Ihre bevorzugten Audio-Ein- und Ausgabegeräte und verwalten Sie die Klangeinstellungen für ein optimales Hörerlebnis.
- **Effiziente Energienutzung:** Die Umgebung arbeitet intelligent mit den Energiediensten Ihres Systems zusammen, um Energieprofile zu unterstützen und einen reibungslosen Übergang in den Standby- oder Ruhezustand und wieder zurück zu gewährleisten.

**Anwendungs- und Workspace-Management – Perfekt Organisiert und Hocheffizient**

Behalten Sie stets den Überblick und die Kontrolle über Ihre Anwendungen und Aufgaben.

- **Fortschrittliche Fensterverwaltung mit Intelligenz:** Neben den grundlegenden Funktionen bietet die Umgebung erweiterte Möglichkeiten zur Anordnung Ihrer Fenster. Nutzen Sie Funktionen wie **automatisches Kacheln (Tiling)**, bei dem Fenster den Bildschirm optimal ausnutzen, oder **Snapping**, bei dem Fenster an Bildschirmrändern oder anderen Fenstern "einrasten". Sie können aus verschiedenen **konfigurierbaren Tiling-Layouts** (z.B. Kacheln, Spalten, Spiralen) wählen und sogar Tiling-, Stacking- (überlappend) und Floating-Fenster (frei beweglich) nahtlos innerhalb desselben Arbeitsbereichs mischen. Einstellbare **Lücken (Gaps)** zwischen den Fenstern sorgen für visuelle Klarheit. Das System bietet zudem intelligente Vorschläge für Fensteranordnungen, ähnlich den Snap Layouts unter Windows, die sich an den verfügbaren Bildschirmplatz anpassen. Auch die Darstellung von Fensterdekorationen (Rahmen, Titelleisten) wird flexibel und stilkonsistent gehandhabt.
- **Virtuelle Desktops als "Spaces" (Workspace-Management):** Organisieren Sie Ihre Arbeit in verschiedenen, thematisch getrennten Arbeitsbereichen, genannt "Spaces". Erstellen Sie Spaces dynamisch, wenn Sie sie benötigen – vielleicht einen für Arbeit, einen für private Projekte und einen weiteren für Kommunikation. Weisen Sie jedem Space optional ein **eigenes Icon, eine individuelle Akzentfarbe oder sogar ein spezifisches Hintergrundbild** zu, um sie visuell sofort unterscheiden zu können. "Pinnen" Sie Ihre Hauptanwendung(en) oder eine Split-View-Ansicht an jeden Space, um Ihren Fokus zu definieren. Wechseln Sie blitzschnell zwischen diesen Spaces über Gesten, Tastenkürzel oder den eleganten Workspace-Switcher in der Seitenleiste. Ihre Workspace-Konfigurationen und Fensteranordnungen können zwischen Sitzungen gespeichert werden.
- **Intelligente Anwendungssteuerung:** Starten, beenden und überwachen Sie Ihre Anwendungen mit Leichtigkeit. Das System merkt sich kürzlich und häufig genutzte Anwendungen, um Ihnen im Speed-Dial oder der Befehlspalette intelligente und zeitsparende Vorschläge zu machen.

**Diese Desktop-Umgebung ist mehr als nur eine Oberfläche. Sie ist Ihr persönlicher, intelligenter und sicherer digitaler Arbeitsplatz, der sich Ihren Bedürfnissen anpasst und Ihnen hilft, das Beste aus Ihrem Linux-System herauszuholen – intuitiv, effizient und mit Stil.**


# **Nova A1 Kernschicht Implementierungsleitfaden: Modul 1 \- Fundamentale Datentypen (core::types)**

## **1\. Modulübersicht: core::types**

### **1.1. Zweck und Verantwortlichkeit**

Dieses Modul, core::types, bildet das Fundament der Kernschicht (core) und somit des gesamten Systems. Seine primäre Verantwortung liegt in der Definition grundlegender, universell einsetzbarer Datentypen, die von allen anderen Schichten und Modulen der Desktop-Umgebung benötigt werden. Dazu gehören geometrische Primitive (wie Punkte, Größen, Rechtecke), Farbdarstellungen und allgemeine Enumerationen (wie Orientierungen).  
Die in diesem Modul definierten Typen sind bewusst einfach gehalten und repräsentieren reine Datenstrukturen ohne komplexe Geschäftslogik oder Abhängigkeiten zu höheren Schichten oder externen Systemen. Sie dienen als Bausteine für komplexere Operationen und Zustandsrepräsentationen in den Domänen-, System- und Benutzeroberflächenschichten.

### **1.2. Designphilosophie**

Das Design von core::types folgt den Prinzipien der Modularität, Wiederverwendbarkeit und minimalen Kopplung. Die Typen sind generisch gehalten (wo sinnvoll, z.B. bei geometrischen Primitiven), um Flexibilität für verschiedene numerische Darstellungen (z.B. i32 für Koordinaten, f32 für Skalierungsfaktoren) zu ermöglichen.  
Ein wesentlicher Aspekt ist die klare Trennung von Datenrepräsentation (in core::types) und Fehlerbehandlung. Während dieses Modul die Datenstrukturen definiert, werden die spezifischen Fehler, die bei Operationen mit diesen Typen auftreten können (z.B. durch ungültige Werte), in den Modulen definiert, die diese Operationen durchführen (typischerweise in core::errors oder modulspezifischen Fehler-Enums höherer Schichten).

### **1.3. Zusammenspiel mit Fehlerbehandlung**

Obwohl core::types selbst keine Error-Typen definiert, ist das Design der hier enthaltenen Typen entscheidend für eine robuste und konsistente Fehlerbehandlungsstrategie im gesamten Projekt. Die übergeordnete Richtlinie sieht die Verwendung des thiserror-Crates vor, um spezifische Fehler-Enums pro Modul zu definieren. Dies ermöglicht eine granulare Fehlerbehandlung, ohne die Komplexität übermäßig zu erhöhen.  
Die Typen in core::types unterstützen diese Strategie, indem sie:

1. **Standard-Traits implementieren:** Alle Typen implementieren grundlegende Traits wie Debug und Display. Dies ist essenziell, damit Instanzen dieser Typen effektiv in Fehlermeldungen und Log-Ausgaben eingebettet werden können, die von höheren Schichten unter Verwendung von thiserror generiert werden. Eine gute Fehlerdarstellung ist entscheidend für die Fehlersuche und das Verständnis von Problemen im Laufzeitbetrieb.  
2. **Invarianten dokumentieren:** Für Typen wie Rect\<T\> existieren logische Invarianten (z.B. nicht-negative Breite und Höhe). Diese Invarianten werden klar dokumentiert.  
3. **Validierung ermöglichen:** Wo sinnvoll, werden Methoden zur Überprüfung der Gültigkeit bereitgestellt (z.B. Rect::is\_valid()). Diese Methoden erlauben es aufrufendem Code in höheren Schichten, Zustände zu überprüfen, *bevor* Operationen ausgeführt werden, die fehlschlagen könnten.  
4. **Keine Panics in Kernfunktionen:** Konstruktoren und einfache Zugriffsmethoden in core::types lösen keine Panics aus und geben keine Result-Typen zurück, um die API auf dieser fundamentalen Ebene einfach und vorhersagbar zu halten. Die Verantwortung für die Handhabung potenziell ungültiger Zustände (z.B. ein Rect mit negativer Breite, das an eine Rendering-Funktion übergeben wird) liegt bei den konsumierenden Funktionen, die dann die definierten Fehlerpfade (mittels Result\<T, E\> 3 und den thiserror-basierten E-Typen) nutzen.

Diese Designentscheidungen stellen sicher, dass die fundamentalen Typen nahtlos in das übergeordnete Fehlerbehandlungskonzept integriert werden können, ohne selbst die Komplexität der Fehlerdefinition tragen zu müssen. Die gewählte Fehlerstrategie mit thiserror pro Modul wird als ausreichend für die Bedürfnisse der Kernschicht erachtet, auch wenn alternative Ansätze wie snafu für komplexere Szenarien existieren, in denen z.B. die Unterscheidung von Fehlern aus derselben Quelle kritisch ist. Für die Kernschicht wird die Einfachheit und Direktheit von thiserror bevorzugt.

### **1.4. Modulabhängigkeiten**

Dieses Modul ist darauf ausgelegt, minimale externe Abhängigkeiten zu haben, um seine grundlegende Natur und breite Anwendbarkeit zu gewährleisten.

* **Erlaubte Abhängigkeiten:**  
  * std (Rust Standardbibliothek)  
* **Optionale Abhängigkeiten (derzeit nicht verwendet):**  
  * num-traits: Nur hinzufügen, falls generische numerische Operationen benötigt werden, die über std::ops hinausgehen.  
  * serde (mit derive-Feature): Nur hinzufügen, wenn Serialisierung/Deserialisierung dieser Basistypen *direkt auf dieser Ebene* zwingend erforderlich ist (z.B. für Konfigurationsdateien, die diese Typen direkt verwenden). Aktuell wird davon ausgegangen, dass Serialisierungslogik in höheren Schichten implementiert wird, um unnötige Abhängigkeiten zu vermeiden.

### **1.5. Ziel-Dateistruktur**

Die Implementierung dieses Moduls erfolgt innerhalb des core-Crates mit folgender Verzeichnisstruktur:

src/  
└── core/  
    ├── Cargo.toml         \# (Definiert das 'core' Crate)  
    └── src/  
        ├── lib.rs             \# (Deklariert Kernmodule: pub mod types; pub mod errors;...)  
        └── types/  
            ├── mod.rs         \# (Deklariert und re-exportiert Typen: pub mod geometry; pub mod color;...)  
            ├── geometry.rs    \# (Enthält Point\<T\>, Size\<T\>, Rect\<T\>)  
            ├── color.rs       \# (Enthält Color)  
            └── enums.rs       \# (Enthält Orientation, etc.)

## **2\. Spezifikation: Geometrische Primitive (geometry.rs)**

Diese Datei definiert grundlegende 2D-Geometrietypen, die für Layout, Positionierung und Rendering unerlässlich sind.

### **2.1. Struct: Point\<T\>**

* **2.1.1. Definition und Zweck:** Repräsentiert einen Punkt im 2D-Raum mit x- und y-Koordinaten. Generisch über den Typ T.  
* **2.1.2. Felder:**  
  * pub x: T  
  * pub y: T  
* **2.1.3. Assoziierte Konstanten:**  
  * pub const ZERO\_I32: Point\<i32\> \= Point { x: 0, y: 0 };  
  * pub const ZERO\_U32: Point\<u32\> \= Point { x: 0, y: 0 };  
  * pub const ZERO\_F32: Point\<f32\> \= Point { x: 0.0, y: 0.0 };  
  * pub const ZERO\_F64: Point\<f64\> \= Point { x: 0.0, y: 0.0 };  
* **2.1.4. Methoden:**  
  * pub const fn new(x: T, y: T) \-\> Self  
    * Erstellt einen neuen Punkt.  
  * pub fn distance\_squared(\&self, other: \&Point\<T\>) \-\> T  
    * Berechnet das Quadrat der euklidischen Distanz.  
    * *Constraints:* T:Copy+std::ops::Add\<Output=T\>+std::ops::Sub\<Output=T\>+std::ops::Mul\<Output=T\>  
  * pub fn distance(\&self, other: \&Point\<T\>) \-\> T  
    * Berechnet die euklidische Distanz.  
    * *Constraints:* T:Copy+std::ops::Add\<Output=T\>+std::ops::Sub\<Output=T\>+std::ops::Mul\<Output=T\>+numt​raits::Float (Implementierung nur für Float-Typen sinnvoll oder über sqrt-Funktion). Vorerst nur für f32,f64 implementieren.  
  * pub fn manhattan\_distance(\&self, other: \&Point\<T\>) \-\> T  
    * Berechnet die Manhattan-Distanz (∣x1​−x2​∣+∣y1​−y2​∣).  
    * *Constraints:* T:Copy+std::ops::Add\<Output=T\>+std::ops::Sub\<Output=T\>+numt​raits::Signed (Benötigt abs()).  
* **2.1.5. Trait Implementierungen:**  
  * \#  
    * *Bedingung:* T muss die jeweiligen Traits ebenfalls implementieren. Default setzt x und y auf T::default().  
  * impl\<T: Send \+ 'static\> Send for Point\<T\> {}  
  * impl\<T: Sync \+ 'static\> Sync for Point\<T\> {}  
  * impl\<T: std::ops::Add\<Output \= T\>\> std::ops::Add for Point\<T\>  
  * impl\<T: std::ops::Sub\<Output \= T\>\> std::ops::Sub for Point\<T\>  
* **2.1.6. Generische Constraints (Basis):** T:Copy+Debug+PartialEq+Default+Send+Sync+′static. Weitere Constraints werden pro Methode spezifiziert.

### **2.2. Struct: Size\<T\>**

* **2.2.1. Definition und Zweck:** Repräsentiert eine 2D-Dimension (Breite und Höhe). Generisch über den Typ T.  
* **2.2.2. Felder:**  
  * pub width: T  
  * pub height: T  
* **2.2.3. Assoziierte Konstanten:**  
  * pub const ZERO\_I32: Size\<i32\> \= Size { width: 0, height: 0 };  
  * pub const ZERO\_U32: Size\<u32\> \= Size { width: 0, height: 0 };  
  * pub const ZERO\_F32: Size\<f32\> \= Size { width: 0.0, height: 0.0 };  
  * pub const ZERO\_F64: Size\<f64\> \= Size { width: 0.0, height: 0.0 };  
* **2.2.4. Methoden:**  
  * pub const fn new(width: T, height: T) \-\> Self  
    * Erstellt eine neue Größe.  
  * pub fn area(\&self) \-\> T  
    * Berechnet die Fläche (width×height).  
    * *Constraints:* T:Copy+std::ops::Mul\<Output=T\>  
  * pub fn is\_empty(\&self) \-\> bool  
    * Prüft, ob Breite oder Höhe null ist.  
    * *Constraints:* T:PartialEq+numt​raits::Zero  
  * pub fn is\_valid(\&self) \-\> bool  
    * Prüft, ob Breite und Höhe nicht-negativ sind. Nützlich für Typen wie i32.  
    * *Constraints:* T:PartialOrd+numt​raits::Zero  
* **2.2.5. Trait Implementierungen:**  
  * \#  
    * *Bedingung:* T muss die jeweiligen Traits ebenfalls implementieren. Default setzt width und height auf T::default().  
  * impl\<T: Send \+ 'static\> Send for Size\<T\> {}  
  * impl\<T: Sync \+ 'static\> Sync for Size\<T\> {}  
* **2.2.6. Generische Constraints (Basis):** T:Copy+Debug+PartialEq+Default+Send+Sync+′static. Weitere Constraints werden pro Methode spezifiziert. Die Invariante nicht-negativer Dimensionen wird durch is\_valid prüfbar gemacht, aber nicht durch den Typ erzwungen.

### **2.3. Struct: Rect\<T\>**

* **2.3.1. Definition und Zweck:** Repräsentiert ein 2D-Rechteck, definiert durch einen Ursprungspunkt (oben-links) und eine Größe. Generisch über den Typ T.  
* **2.3.2. Felder:**  
  * pub origin: Point\<T\>  
  * pub size: Size\<T\>  
* **2.3.3. Assoziierte Konstanten:**  
  * pub const ZERO\_I32: Rect\<i32\> \= Rect { origin: Point::ZERO\_I32, size: Size::ZERO\_I32 };  
  * pub const ZERO\_U32: Rect\<u32\> \= Rect { origin: Point::ZERO\_U32, size: Size::ZERO\_U32 };  
  * pub const ZERO\_F32: Rect\<f32\> \= Rect { origin: Point::ZERO\_F32, size: Size::ZERO\_F32 };  
  * pub const ZERO\_F64: Rect\<f64\> \= Rect { origin: Point::ZERO\_F64, size: Size::ZERO\_F64 };  
* **2.3.4. Methoden:**  
  * pub const fn new(origin: Point\<T\>, size: Size\<T\>) \-\> Self  
  * pub fn from\_coords(x: T, y: T, width: T, height: T) \-\> Self  
    * *Constraints:* T muss die Constraints von Point::new und Size::new erfüllen.  
  * pub fn x(\&self) \-\> T (*Constraints:* T:Copy)  
  * pub fn y(\&self) \-\> T (*Constraints:* T:Copy)  
  * pub fn width(\&self) \-\> T (*Constraints:* T:Copy)  
  * pub fn height(\&self) \-\> T (*Constraints:* T:Copy)  
  * pub fn top(\&self) \-\> T (Alias für y, *Constraints:* T:Copy)  
  * pub fn left(\&self) \-\> T (Alias für x, *Constraints:* T:Copy)  
  * pub fn bottom(\&self) \-\> T (y+height, *Constraints:* T:Copy+std::ops::Add\<Output=T\>)  
  * pub fn right(\&self) \-\> T (x+width, *Constraints:* T:Copy+std::ops::Add\<Output=T\>)  
  * pub fn center(\&self) \-\> Point\<T\>  
    * Berechnet den Mittelpunkt.  
    * *Constraints:* T:Copy+std::ops::Add\<Output=T\>+std::ops::Div\<Output=T\>+numt​raits::FromPrimitive (Benötigt Division durch 2).  
  * pub fn contains\_point(\&self, point: \&Point\<T\>) \-\> bool  
    * Prüft, ob der Punkt innerhalb des Rechtecks liegt (Grenzen inklusiv für top/left, exklusiv für bottom/right).  
    * *Constraints:* T:Copy+PartialOrd+std::ops::Add\<Output=T\>  
  * pub fn intersects(\&self, other: \&Rect\<T\>) \-\> bool  
    * Prüft, ob sich dieses Rechteck mit einem anderen überschneidet.  
    * *Constraints:* T:Copy+PartialOrd+std::ops::Add\<Output=T\>  
  * pub fn intersection(\&self, other: \&Rect\<T\>) \-\> Option\<Rect\<T\>\>  
    * Berechnet das Schnittrechteck. Gibt None zurück, wenn keine Überschneidung vorliegt.  
    * *Constraints:* T:Copy+Ord+std::ops::Add\<Output=T\>+std::ops::Sub\<Output=T\>+numt​raits::Zero  
  * pub fn union(\&self, other: \&Rect\<T\>) \-\> Rect\<T\>  
    * Berechnet das umschließende Rechteck beider Rechtecke.  
    * *Constraints:* T:Copy+Ord+std::ops::Add\<Output=T\>+std::ops::Sub\<Output=T\>  
  * pub fn translated(\&self, dx: T, dy: T) \-\> Rect\<T\>  
    * Verschiebt das Rechteck um (dx,dy).  
    * *Constraints:* T:Copy+std::ops::Add\<Output=T\>  
  * pub fn scaled(\&self, sx: T, sy: T) \-\> Rect\<T\>  
    * Skaliert das Rechteck relativ zum Ursprung (0,0). Beachtet, dass dies Ursprung und Größe skaliert.  
    * *Constraints:* T:Copy+std::ops::Mul\<Output=T\>  
  * pub fn is\_valid(\&self) \-\> bool  
    * Prüft, ob size.is\_valid() wahr ist.  
    * *Constraints:* T:PartialOrd+numt​raits::Zero  
* **2.3.5. Trait Implementierungen:**  
  * \#  
    * *Bedingung:* T muss die jeweiligen Traits ebenfalls implementieren. Default verwendet Point::default() und Size::default().  
  * impl\<T: Send \+ 'static\> Send for Rect\<T\> {}  
  * impl\<T: Sync \+ 'static\> Sync for Rect\<T\> {}  
* **2.3.6. Generische Constraints (Basis):** T:Copy+Debug+PartialEq+Default+Send+Sync+′static. Weitere Constraints werden pro Methode spezifiziert.  
* **2.3.7. Invarianten und Validierung (Verbindung zur Fehlerbehandlung):**  
  * **Invariante:** Logisch sollten width und height der size-Komponente nicht-negativ sein.  
  * **Kontext:** Die Verwendung von vorzeichenbehafteten Typen wie i32 für Koordinaten ist üblich, erlaubt aber technisch negative Dimensionen. Eine Erzwingung nicht-negativer Dimensionen auf Typebene (z.B. durch u32) wäre zu restriktiv für Koordinatensysteme.  
  * **Konsequenz:** Die Flexibilität, Rect\<i32\> zu verwenden, verlagert die Verantwortung für die Validierung auf die Nutzer des Rect-Typs. Funktionen in höheren Schichten (z.B. Layout-Algorithmen, Rendering-Engines), die ein Rect konsumieren, müssen potenziell ungültige Rechtecke (mit negativer Breite oder Höhe) behandeln. Solche Fälle stellen Laufzeitfehler dar, die über das etablierte Fehlerbehandlungssystem (basierend auf Result\<T, E\> und thiserror-definierten E-Typen) signalisiert werden müssen.  
  * **Implementierung in core::types:** Das Modul erzwingt die Invariante nicht zur Compilezeit oder in Konstruktoren. Stattdessen wird die Methode pub fn is\_valid(\&self) \-\> bool bereitgestellt. Nutzer von Rect\<T\> (insbesondere mit T=i32) *sollten* diese Methode aufrufen, um die Gültigkeit sicherzustellen, bevor Operationen durchgeführt werden, die eine positive Breite und Höhe voraussetzen. Die Dokumentation des Rect-Typs muss explizit auf diese Invariante und die Notwendigkeit der Validierung durch den Aufrufer hinweisen. Die Verantwortung für das *Melden* eines Fehlers bei Verwendung eines ungültigen Rect liegt beim Aufrufer, der dafür die Fehlerinfrastruktur (z.B. core::errors oder modulspezifische Fehler) nutzt.

## **3\. Spezifikation: Farbdarstellung (color.rs)**

Diese Datei definiert einen Standard-Farbtyp für die Verwendung im gesamten System.

### **3.1. Struct: Color (RGBA)**

* **3.1.1. Definition und Zweck:** Repräsentiert eine Farbe mit Rot-, Grün-, Blau- und Alpha-Komponenten. Verwendet f32-Komponenten im Bereich \[0.0,1.0\] für hohe Präzision und Flexibilität bei Farboperationen wie Mischen und Transformationen.  
* **3.1.2. Felder:**  
  * pub r: f32 (Rotkomponente, 0.0 bis 1.0)  
  * pub g: f32 (Grünkomponente, 0.0 bis 1.0)  
  * pub b: f32 (Blaukomponente, 0.0 bis 1.0)  
  * pub a: f32 (Alphakomponente, 0.0=transparent bis 1.0=opak)  
* **3.1.3. Assoziierte Konstanten:**  
  * pub const TRANSPARENT: Color \= Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };  
  * pub const BLACK: Color \= Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 };  
  * pub const WHITE: Color \= Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };  
  * pub const RED: Color \= Color { r: 1.0, g: 0.0, b: 0.0, a: 1.0 };  
  * pub const GREEN: Color \= Color { r: 0.0, g: 1.0, b: 0.0, a: 1.0 };  
  * pub const BLUE: Color \= Color { r: 0.0, g: 0.0, b: 1.0, a: 1.0 };  
  * *(Weitere Standardfarben nach Bedarf hinzufügen)*  
* **3.1.4. Methoden:**  
  * pub const fn new(r: f32, g: f32, b: f32, a: f32) \-\> Self  
    * Erstellt eine neue Farbe. Werte außerhalb \[0.0,1.0\] werden nicht automatisch geklemmt, dies liegt in der Verantwortung des Aufrufers oder nachfolgender Operationen. debug\_assert\! kann zur Laufzeitprüfung in Debug-Builds verwendet werden.  
  * pub fn from\_rgba8(r: u8, g: u8, b: u8, a: u8) \-\> Self  
    * Konvertiert von 8-Bit-Ganzzahlkomponenten (0−255) zu f32 (0.0−1.0). value/255.0.  
  * pub fn to\_rgba8(\&self) \-\> (u8, u8, u8, u8)  
    * Konvertiert von f32 zu 8-Bit-Ganzzahlkomponenten. Klemmt Werte auf \[0.0,1.0\] und skaliert dann auf $$. (value.clamp(0.0,1.0)∗255.0).round()asu8.  
  * pub fn with\_alpha(\&self, alpha: f32) \-\> Self  
    * Erstellt eine neue Farbe mit dem angegebenen Alpha-Wert, wobei RGB beibehalten wird. Klemmt Alpha auf \[0.0,1.0\].  
  * pub fn blend(\&self, background: \&Color) \-\> Color  
    * Führt Alpha-Blending ("source-over") dieser Farbe über einer Hintergrundfarbe durch. Formel: Cout​=Cfg​×αfg​+Cbg​×αbg​×(1−αfg​). αout​=αfg​+αbg​×(1−αfg​). Annahme: Farben sind nicht vormultipliziert.  
  * pub fn lighten(\&self, amount: f32) \-\> Color  
    * Hellt die Farbe um einen Faktor amount auf (z.B. durch lineare Interpolation zu Weiß). Klemmt das Ergebnis auf gültige Farbwerte. amount im Bereich \[0.0,1.0\].  
  * pub fn darken(\&self, amount: f32) \-\> Color  
    * Dunkelt die Farbe um einen Faktor amount ab (z.B. durch lineare Interpolation zu Schwarz). Klemmt das Ergebnis. amount im Bereich \[0.0,1.0\].  
* **3.1.5. Trait Implementierungen:**  
  * \#  
    * PartialEq: Verwendet den Standard-Float-Vergleich. Für präzisere Vergleiche könnten benutzerdefinierte Implementierungen mit Epsilon erforderlich sein, dies wird jedoch für die Kernschicht als unnötige Komplexität betrachtet.  
    * Default: Implementiert Default manuell, um Color::TRANSPARENT zurückzugeben.  
  * impl Send for Color {}  
  * impl Sync for Color {}

## **4\. Spezifikation: Allgemeine Enumerationen (enums.rs)**

Diese Datei enthält häufig verwendete, einfache Enumerationen.

### **4.1. Enum: Orientation**

* **4.1.1. Definition und Zweck:** Repräsentiert eine horizontale oder vertikale Ausrichtung, häufig verwendet in UI-Layouts und Widgets.  
* **4.1.2. Varianten:**  
  * Horizontal  
  * Vertical  
* **4.1.3. Methoden:**  
  * pub fn toggle(\&self) \-\> Self  
    * Gibt die jeweils andere Orientierung zurück (Horizontal \-\> Vertical, Vertical \-\> Horizontal).  
* **4.1.4. Trait Implementierungen:**  
  * \#  
  * impl Default for Orientation { fn default() \-\> Self { Orientation::Horizontal } } (Standard ist Horizontal).  
  * impl Send for Orientation {}  
  * impl Sync for Orientation {}

## **5\. Zusammenfassung: Standard Trait Implementierungen**

Die folgende Tabelle gibt einen Überblick über die Implementierung gängiger Standard-Traits für die in diesem Modul definierten Typen. Dies dient als schnelle Referenz für Entwickler.

| Typ | Debug | Clone | Copy | PartialEq | Eq | Default | Hash | Send | Sync |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| Point\<T\> | Ja | Ja | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) |
| Size\<T\> | Ja | Ja | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) |
| Rect\<T\> | Ja | Ja | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) | Ja (wenn T) |
| Color | Ja | Ja | Ja | Ja | Nein | Ja | Nein | Ja | Ja |
| Orientation | Ja | Ja | Ja | Ja | Ja | Ja | Ja | Ja | Ja |

Anmerkungen:  
Eq und Hash sind aufgrund von Präzisionsproblemen generell nicht für Fließkommazahlen geeignet.  
Default::default() ergibt Color::TRANSPARENT.  
Default::default() ergibt Orientation::Horizontal.

## **6\. Schritt-für-Schritt Implementierungsplan**

Die Implementierung des core::types-Moduls folgt diesen Schritten:

* **6.1. Setup: Verzeichnis- und Dateierstellung:**  
  * Sicherstellen, dass das core-Crate existiert (ggf. cargo new core \--lib ausführen).  
  * Erstellen des Verzeichnisses src/core/src/types.  
  * Erstellen der Dateien:  
    * src/core/src/types/mod.rs  
    * src/core/src/types/geometry.rs  
    * src/core/src/types/color.rs  
    * src/core/src/types/enums.rs  
* **6.2. Implementierung geometry.rs: Point\<T\>, Size\<T\>, Rect\<T\>:**  
  * Definieren der Point\<T\>-Struktur mit Feldern x, y. Hinzufügen der spezifizierten generischen Basis-Constraints (T:Copy+Debug+PartialEq+Default+Send+Sync+′static). Implementieren von new, Konstanten (ZERO\_I32 etc.), Methoden (distance\_squared, distance (für Floats), manhattan\_distance) mit ihren spezifischen Constraints und Ableiten/Implementieren der spezifizierten Traits (Add, Sub).  
  * Definieren der Size\<T\>-Struktur mit Feldern width, height. Hinzufügen der Basis-Constraints. Implementieren von new, Konstanten (ZERO\_I32 etc.), Methoden (area, is\_empty, is\_valid) mit ihren Constraints und Ableiten/Implementieren der Traits.  
  * Definieren der Rect\<T\>-Struktur mit Feldern origin, size. Hinzufügen der Basis-Constraints. Implementieren von new, from\_coords, Konstanten (ZERO\_I32 etc.), Zugriffsmethoden (x, y, width, height, top, left, bottom, right), geometrischen Methoden (center, contains\_point, intersects, intersection, union, translated, scaled), Validierungsmethode (is\_valid) mit ihren Constraints und Ableiten/Implementieren der Traits.  
  * Hinzufügen notwendiger use-Anweisungen (z.B. std::ops, num\_traits).  
* **6.3. Implementierung color.rs: Color:**  
  * Definieren der Color-Struktur mit Feldern r, g, b, a (alle f32).  
  * Implementieren von new, Konstanten (TRANSPARENT, BLACK, WHITE, etc.), Konvertierungsmethoden (from\_rgba8, to\_rgba8), Hilfsmethoden (with\_alpha, blend, lighten, darken) und Ableiten/Implementieren der Traits (Default manuell).  
* **6.4. Implementierung enums.rs: Orientation:**  
  * Definieren des Orientation-Enums mit Varianten Horizontal, Vertical.  
  * Implementieren der toggle-Methode.  
  * Ableiten/Implementieren der spezifizierten Traits (Default manuell).  
* **6.5. Implementierung Moduldeklaration (mod.rs):**  
  * In src/core/src/types/mod.rs:  
    Rust  
    // src/core/src/types/mod.rs  
    pub mod color;  
    pub mod enums;  
    pub mod geometry;

    // Re-exportiere die primären Typen für einfacheren Zugriff  
    pub use color::Color;  
    pub use enums::Orientation;  
    pub use geometry::{Point, Rect, Size};

  * In src/core/src/lib.rs:  
    Rust  
    // src/core/src/lib.rs  
    // Deklariere das types-Modul  
    pub mod types;

    // Deklariere andere Kernmodule (werden später hinzugefügt)  
    // pub mod errors;  
    // pub mod logging;  
    // pub mod config;  
    // pub mod utils;

* **6.6. Unit-Testing Anforderungen:**  
  * Erstellen eines \#\[cfg(test)\]-Moduls innerhalb jeder Implementierungsdatei (geometry.rs, color.rs, enums.rs).  
  * Schreiben von Unit-Tests, die Folgendes abdecken:  
    * Konstruktorfunktionen (new, from\_coords, from\_rgba8).  
    * Konstantenwerte (deren Eigenschaften überprüfen).  
    * Methodenlogik (z.B. distance\_squared, area, is\_empty, bottom, right, contains\_point, intersects, intersection, union, toggle, blend). Testen von Grenzfällen (Nullwerte, überlappende/nicht überlappende Rechtecke, identische Punkte, Farbblending mit transparent/opak).  
    * Trait-Implementierungen (insbesondere Default, PartialEq, Add/Sub, wo zutreffend).  
    * Invariantenprüfungen (z.B. is\_valid für Rect und Size testen).  
  * Anstreben einer hohen Testabdeckung für diesen fundamentalen Code.  
* **6.7. Dokumentationsanforderungen (rustdoc):**  
  * Hinzufügen von ///-Dokumentationskommentaren zu *allen* öffentlichen Elementen: Module (mod.rs-Dateien), Structs, Enums, Felder, Konstanten, Methoden, Typ-Aliase.  
  * Modul-Level-Kommentare sollen den Zweck des Moduls erklären (geometry.rs, color.rs, etc.).  
  * Typ-Level-Kommentare sollen den Zweck und die Invarianten der Struktur/des Enums erklären (besonders wichtig für Rect-Invarianten).  
  * Feld-Level-Kommentare sollen die Bedeutung des Feldes erklären (z.B. Wertebereich für Color-Komponenten).  
  * Methoden-Level-Kommentare sollen erklären, was die Methode tut, ihre Parameter, Rückgabewerte, mögliche Panics (sollten hier idealerweise keine auftreten, außer bei unwrap/expect in Tests), relevante Vor-/Nachbedingungen oder verwendete Algorithmen (z.B. Alpha-Blending-Formel). \# Examples-Abschnitte verwenden, wo sinnvoll.  
  * Strikte Einhaltung der Rust API Guidelines für Dokumentation.  
  * Ausführen von cargo doc \--open zur Überprüfung der generierten Dokumentation.

## **7\. Schlussfolgerung**

Dieses Dokument spezifiziert das Modul core::types, welches die grundlegendsten Datentypen für die neue Linux-Desktop-Umgebung bereitstellt. Die definierten Typen (Point\<T\>, Size\<T\>, Rect\<T\>, Color, Orientation) sind mit Fokus auf Einfachheit, Wiederverwendbarkeit und minimalen Abhängigkeiten entworfen. Besonderes Augenmerk wurde auf die klare Trennung zwischen Datenrepräsentation und Fehlerbehandlung gelegt, wobei die Typen so gestaltet sind, dass sie die übergeordnete, auf thiserror basierende Fehlerstrategie des Projekts unterstützen, ohne selbst Fehlerdefinitionen zu enthalten. Die Bereitstellung von Validierungsfunktionen wie Rect::is\_valid und die klare Dokumentation von Invarianten sind entscheidend, um Robustheit in den konsumierenden Schichten zu ermöglichen. Der detaillierte Implementierungsplan inklusive Test- und Dokumentationsanforderungen stellt sicher, dass dieses fundamentale Modul mit hoher Qualität und Konsistenz entwickelt werden kann.

#### **Referenzen**

1. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)  
2. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)  
3. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
4. std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/index.html](https://doc.rust-lang.org/std/error/index.html)

# **A2 Implementierungsleitfaden: Kernschicht – Teil 2: Fehlerbehandlung (core::errors)**

## **1\. Einleitung**

### **1.1. Zweck und Geltungsbereich**

Dieser Abschnitt des Implementierungsleitfadens spezifiziert die verbindliche Strategie und Implementierung der Fehlerbehandlung innerhalb der Kernschicht (Core Layer) des Projekts. Er stellt Teil 2 der Spezifikation für die Kernschicht dar und baut direkt auf der technischen Gesamtspezifikation auf, insbesondere auf Abschnitt III (Technologie-Stack) und IV (Entwicklungsrichtlinien). Die hier dargelegten Definitionen und Richtlinien konkretisieren die Anforderungen für das Modul core::errors. Das Ziel ist die Bereitstellung einer lückenlosen, präzisen Spezifikation, die Entwicklern die direkte Implementierung der Fehlerbehandlungsmechanismen ermöglicht, ohne eigene architektonische Entscheidungen treffen oder grundlegende Logiken entwerfen zu müssen.

### **1.2. Bezug zur Gesamtspezifikation**

Wie in Abschnitt IV. 4.3 der technischen Gesamtspezifikation festgelegt, ist die Verwendung des thiserror Crates für die Definition von benutzerdefinierten Fehlertypen obligatorisch. Diese Entscheidung basiert auf der Notwendigkeit, idiomatisches, wartbares und kontextreiches Fehlerhandling für Code zu implementieren, der als Bibliothek für andere Schichten dient – eine primäre Funktion der Kernschicht.1 thiserror erleichtert die Erstellung von Fehlertypen, die das std::error::Error Trait implementieren, erheblich.1

### **1.3. Anforderungen an die Spezifikation**

Die folgenden Anforderungen gelten für diesen Implementierungsleitfaden:

* **Höchste Präzision:** Alle Typen, Enums, Traits und Methoden im Zusammenhang mit der Fehlerbehandlung müssen exakt definiert werden, einschließlich ihrer Signaturen, Felder und abgeleiteten Traits.  
* **Eindeutigkeit:** Benennung und Semantik aller Fehlerarten müssen klar und unmissverständlich sein.  
* **Vollständigkeit:** Alle relevanten Aspekte der Fehlerbehandlungsstrategie und \-implementierung müssen abgedeckt sein.  
* **Detaillierte Anleitungen:** Schritt-für-Schritt-Anleitungen für typische Implementierungsaufgaben im Zusammenhang mit Fehlern müssen bereitgestellt werden.

## **2\. Kernschicht Fehlerbehandlungsstrategie (core::errors)**

### **2.1. Grundlagen und Prinzipien**

#### **Verwendung von thiserror**

Die Entscheidung für das thiserror Crate, wie in der Gesamtspezifikation (IV. 4.3) festgelegt, wird hier bekräftigt und als verbindlich erklärt. thiserror stellt ein deklaratives Makro (\#\[derive(Error)\]) bereit, das den Boilerplate-Code für die Implementierung des std::error::Error Traits und verwandter Traits (wie std::fmt::Display) signifikant reduziert.1 Alle benutzerdefinierten Fehler-Enums, die innerhalb der Kernschicht definiert werden, *müssen* thiserror::Error ableiten.

#### **$Result\<T, E\>$ vs. $panic\!$**

Eine strikte und konsequente Trennung zwischen der Verwendung von $Result\<T, E\>$ und $panic\!$ ist für die Stabilität und Vorhersagbarkeit des Systems unerlässlich.3 Die folgenden Regeln sind einzuhalten:

* **$Result\<T, E\>$:** Dieses Konstrukt, wobei E das std::error::Error Trait implementiert, ist der Standardmechanismus zur Signalisierung von *erwarteten*, potenziell behebbaren Fehlerzuständen zur Laufzeit. Beispiele hierfür sind fehlgeschlagene I/O-Operationen (Datei nicht gefunden), ungültige Benutzereingaben, Fehler bei der Netzwerkkommunikation oder Probleme beim Parsen von Daten. Funktionen in der Kernschicht, die solche Fehlerzustände antizipieren, *müssen* einen $Result\<T, E\>$ zurückgeben, wobei E typischerweise CoreError oder ein spezifischerer Modul-Fehler ist (siehe Abschnitt 2.2 und 2.3).  
* **$panic\!$:** Der $panic\!-Mechanismus ist ausschließlich für die Signalisierung von *nicht behebbaren Programmierfehlern* (Bugs) reserviert.3 Ein Panic tritt ein, wenn eine Funktion in einem Zustand aufgerufen wird, der gegen ihre dokumentierten Vorbedingungen (Invariants) verstößt, oder wenn ein interner Systemzustand erreicht wird, der logisch unmöglich sein sollte und auf einen Fehler in der Programmlogik hindeutet. Panics signalisieren, dass das Programm in einem inkonsistenten Zustand ist, von dem es sich nicht sicher erholen kann.

#### **Umgang mit $unwrap()$ und $expect()$**

Die Methoden $unwrap()$ und $expect()$ auf $Result$ oder $Option$ führen bei einem Err- bzw. None-Wert zu einem $panic\!$. Ihre Verwendung in produktivem Code der Kernschicht ist daher **strengstens zu vermeiden**, da sie die strukturierte Fehlerbehandlung umgehen und die Kontrolle über den Fehlerfluss dem Aufrufer entziehen.1  
Es gibt nur eine seltene Ausnahme: Wenn ein Err- oder None-Zustand an einer bestimmten Stelle *nachweislich* und *unwiderlegbar* einen Bug darstellt (d.h., eine interne Invariante wurde verletzt, die unter normalen Umständen niemals verletzt sein dürfte), *darf* $expect()$ verwendet werden. In diesem Fall *muss* die übergebene Nachricht dem "expect as precondition"-Stil folgen.3 Diese Nachricht sollte klar artikulieren, *warum* der Entwickler an dieser Stelle einen Ok- oder Some-Wert erwartet hat und welche Bedingung verletzt wurde. Beispiel:

Rust

// FALSCH (unzureichende Begründung):  
// let config\_value \= config\_map.get("required\_key").expect("Config key missing\!");

// RICHTIG (Begründung der Erwartung):  
let config\_value \= config\_map.get("required\_key")  
   .expect("Internal invariant violated: Configuration map should always contain 'required\_key' after initialization phase.");

Die Verwendung von $unwrap()$ ist generell zu unterlassen, da es keine Begründung für die Erwartung liefert.

#### **Anforderungen an Fehlermeldungen**

Fehlermeldungen, die durch das \#\[error("...")\] Attribut von thiserror für die Display-Implementierung generiert werden, müssen folgende Kriterien erfüllen:

* **Klarheit und Präzision:** Die Meldung muss das aufgetretene Problem eindeutig beschreiben.  
* **Kontext:** Sie sollte genügend Kontextinformationen enthalten (oft durch eingebettete Feldwerte wie {field\_name} im Formatstring), um Entwicklern die Diagnose des Problems zu ermöglichen, idealerweise ohne sofortigen Blick in den Quellcode.1  
* **Zielgruppe:** Die primäre Zielgruppe dieser Meldungen sind Entwickler (für Logging und Debugging). Sie können jedoch als Grundlage für benutzerfreundlichere Fehlermeldungen dienen, die in höheren Schichten (insbesondere der UI-Schicht) generiert werden.  
* **Format:** Fehlermeldungen sollten typischerweise knappe, klein geschriebene Sätze ohne abschließende Satzzeichen sein, wie in der std::error::Error Dokumentation empfohlen.4

#### **Akzeptierte Einschränkungen bei thiserror**

Die Wahl von thiserror bietet Einfachheit und reduziert Boilerplate für den häufigen Anwendungsfall der Fehlerdefinition in Bibliotheken.1 Es ist jedoch wichtig, eine spezifische Einschränkung zu verstehen, die sich aus der Funktionsweise von thiserror ergibt, insbesondere bei der Verwendung des \#\[from\]-Attributs zur automatischen Konvertierung von Quellfehlern. thiserror implementiert das std::convert::From-Trait, um die nahtlose Verwendung des ?-Operators zu ermöglichen.1 Eine Konsequenz daraus ist, dass ein bestimmter Quellfehlertyp (z.B. std::io::Error) nicht ohne Weiteres über \#\[from\] in *mehrere verschiedene Varianten* desselben Ziel-Enums (z.B. CoreError) konvertiert werden kann, da die From-Implementierung eindeutig sein muss.1  
Wenn beispielsweise ein std::io::Error sowohl beim Lesen einer Konfigurationsdatei als auch beim Schreiben in eine Log-Datei auftreten kann, können nicht einfach zwei Varianten wie ConfigReadIo(\#\[from\] std::io::Error) und LogWriteIo(\#\[from\] std::io::Error) innerhalb von CoreError definiert werden. Diese Einschränkung unterscheidet thiserror von flexibleren, aber potenziell komplexeren Fehlerbehandlungs-Frameworks wie snafu, die explizit darauf ausgelegt sind, Kontext aus dem Fehlerpfad abzuleiten.1  
Diese systembedingte Eigenschaft von thiserror erfordert eine bewusste Gestaltung der Fehlerhierarchie. Um dennoch semantisch unterschiedliche Fehlerfälle zu behandeln, die auf denselben zugrunde liegenden Fehlertyp zurückzuführen sind, wird die Strategie der Modul-spezifischen Fehler verfolgt (siehe Abschnitt 2.3). Diese spezifischen Fehler können dann eindeutig in eine dedizierte Variante des übergeordneten Fehlers (CoreError) gekapselt werden, wobei der notwendige Kontext entweder im Modul-Fehler selbst oder in der Kapselungsvariante hinzugefügt wird. Dieser Ansatz stellt sicher, dass der semantische Kontext des Fehlers erhalten bleibt, auch wenn der unmittelbare Quelltyp mehrdeutig sein könnte.

### **2.2. Definition des Basis-Fehlertyps: $CoreError$**

#### **Spezifikation**

Im Modul core::errors wird ein zentrales, öffentliches Enum namens CoreError definiert. Dieses Enum stellt die primäre Schnittstelle für Fehler dar, die von öffentlichen Funktionen der Kernschicht nach außen propagiert werden. Es aggregiert sowohl allgemeine Fehlerarten als auch spezifischere Fehler aus den Untermodulen der Kernschicht.

Rust

// In core/src/errors.rs  
use thiserror::Error;  
use std::path::PathBuf; // Beispiel für einen benötigten Typ

// Import von Modul-spezifischen Fehlern (Beispiel)  
use crate::config::errors::ConfigError;  
// use crate::utils::errors::UtilsError; // Falls vorhanden

\#  
pub enum CoreError {  
    /// Fehler bei Ein-/Ausgabeoperationen. Enthält den ursprünglichen I/O-Fehler.  
    \#\[error("I/O error accessing '{path}': {source}")\]  
    Io {  
        path: PathBuf, // Pfad zur Ressource, bei der der Fehler auftrat  
        \#\[source\] // \#\[source\] statt \#\[from\], um Kontext (path) hinzuzufügen  
        source: std::io::Error,  
    },

    /// Fehler im Zusammenhang mit der Konfigurationsverwaltung. Kapselt spezifischere ConfigError-Typen.  
    \#\[error("Configuration error: {0}")\]  
    Configuration(\#\[from\] ConfigError), // Nutzt \#\[from\] für nahtlose Konvertierung

    /// Fehler bei der Serialisierung oder Deserialisierung von Daten (z.B. JSON, TOML).  
    /// Enthält eine Beschreibung des Fehlers. Ggf. spezifischere Varianten für Serde etc. hinzufügen.  
    \#  
    Serialization { description: String },

    /// Eine ungültige ID oder ein ungültiger Bezeichner wurde verwendet.  
    \#\[error("Invalid identifier provided: '{invalid\_id}'")\]  
    InvalidId { invalid\_id: String },

    /// Ein angeforderter Wert oder eine Ressource wurde nicht gefunden.  
    \#  
    NotFound { resource\_description: String },

    /// Ein allgemeiner Fehler in einem Hilfsmodul (Beispiel für Kapselung).  
    // \#\[error("Utility error: {0}")\]  
    // Utility(\#\[from\] UtilsError), // Beispiel für Integration eines weiteren Modul-Fehlers

    /// Platzhalter für einen unerwarteten oder nicht näher spezifizierten internen Fehler.  
    /// Sollte möglichst vermieden und durch spezifischere Varianten ersetzt werden.  
    \#\[error("Internal error: {0}")\]  
    Internal(String),  
}

// Manuelle Implementierung von From\<std::io::Error\>, falls \#\[source\] verwendet wird  
// und man dennoch eine einfache Konvertierung für bestimmte Fälle braucht,  
// aber hier wollen wir Kontext (den Pfad) hinzufügen, daher ist eine manuelle  
// Erzeugung von CoreError::Io an der Fehlerquelle notwendig.  
// Beispiel:  
// std::fs::read("some/path").map\_err(|e| CoreError::Io { path: "some/path".into(), source: e })?;

#### **Ableitungen**

Das CoreError-Enum *muss* mindestens die folgenden Traits ableiten oder implementieren:

* \#: Unerlässlich für Debugging und Diagnosezwecke.  
* \#\[derive(thiserror::Error)\]: Implementiert automatisch std::error::Error und std::fmt::Display basierend auf den \#\[error(...)\]-Attributen und \#\[source\]-/\#\[from\]-Annotationen.1

#### **Fehlerverkettung (source())**

Varianten, die andere Fehler kapseln (entweder durch \#\[from\] oder \#\[source\] annotierte Felder), stellen den ursprünglichen, zugrunde liegenden Fehler über die source()-Methode des std::error::Error-Traits zur Verfügung.4 Dies ist ein fundamentaler Mechanismus für die Fehleranalyse über Schicht- und Modulgrenzen hinweg, da er es ermöglicht, die Kette der verursachenden Fehler bis zur Wurzel zurückzuverfolgen. thiserror implementiert die source()-Methode automatisch korrekt für annotierte Felder.

#### **Tabelle 1: CoreError Varianten (Initial)**

Die folgende Tabelle dient als Referenz für Entwickler und definiert den initialen "Fehlervertrag" der Kernschicht-API. Sie listet die Varianten des CoreError-Enums auf und beschreibt deren Semantik und Struktur.

| Variantenname | \#\[error("...")\] Formatstring | Enthaltene Felder | Beschreibung / Typischer Auslöser | Kapselung (\#\[from\] / \#\[source\]) |
| :---- | :---- | :---- | :---- | :---- |
| Io | I/O error accessing '{path}': {source} | path: PathBuf, source: std::io::Error | Fehler beim Lesen/Schreiben von Dateien oder anderen I/O-Ressourcen. | \#\[source\] (std::io::Error) |
| Configuration | Configuration error: {0} | ConfigError (intern) | Fehler beim Laden, Parsen oder Validieren von Konfigurationen. Kapselt ConfigError. | \#\[from\] (ConfigError) |
| Serialization | Serialization/Deserialization error: {description} | description: String | Fehler beim Umwandeln von Datenstrukturen in/aus Formaten wie JSON, TOML, etc. | \- |
| InvalidId | Invalid identifier provided: '{invalid\_id}' | invalid\_id: String | Eine verwendete ID (z.B. für eine Ressource) ist syntaktisch oder semantisch ungültig. | \- |
| NotFound | Resource not found: {resource\_description} | resource\_description: String | Eine angeforderte Ressource oder ein Wert konnte nicht gefunden werden (z.B. Schlüssel in Map). | \- |
| Internal | Internal error: {0} | String | Allgemeiner interner Fehler, der nicht spezifischer kategorisiert werden konnte. | \- |

Diese Tabelle stellt eine klare Referenz dar, welche Fehlerarten von der Kernschicht erwartet werden können und wie sie strukturiert sind. Sie ist ein wesentlicher Bestandteil der "Ultra-Feinspezifikation", da sie Entwicklern die genaue Struktur der Fehler mitteilt, die sie behandeln oder erzeugen müssen.

### **2.3. Modul-spezifische Fehler und Integration**

#### **Richtlinie**

Während CoreError den zentralen, nach außen sichtbaren Fehlertyp der Kernschicht darstellt, *dürfen* und *sollen* komplexere Module innerhalb der Kernschicht (z.B. core::config, core::utils, core::types falls dort komplexe Validierungen stattfinden) ihre eigenen, spezifischeren Fehler-Enums definieren. Diese Modul-Fehler *müssen* ebenfalls thiserror::Error ableiten.

#### **Begründung**

Diese Vorgehensweise verfolgt einen hybriden Ansatz, der die Vorteile spezifischer Fehler 2 mit der Notwendigkeit einer zentralen Fehlerschnittstelle verbindet. Sie adressiert auch direkt die zuvor beschriebene Einschränkung von thiserror bezüglich mehrdeutiger \#\[from\]-Konvertierungen. Die Definition von Modul-Fehlern bietet folgende Vorteile:

* **Feinere Granularität:** Ermöglicht eine detailliertere Darstellung von Fehlerzuständen, die spezifisch für die Logik eines Moduls sind.  
* **Bessere Kapselung:** Hält die Fehlerdefinitionen und die zugehörige Logik nahe am Code, der die Fehler erzeugt.  
* **Vermeidung von Überladung:** Verhindert, dass das zentrale CoreError-Enum mit einer übermäßigen Anzahl sehr spezifischer Varianten überladen wird, was dessen Übersichtlichkeit und Wartbarkeit beeinträchtigen würde.2

#### **Integrationsmechanismus**

Modul-spezifische Fehler müssen nahtlos in CoreError integrierbar sein, um die Fehlerpropagation mittels des ?-Operators zu gewährleisten. Der **bevorzugte Mechanismus** hierfür ist die Definition einer dedizierten Variante in CoreError, die den Modul-Fehler als einziges Feld enthält und das \#\[from\]-Attribut verwendet.

Rust

// Beispiel in core/src/config/errors.rs  
use thiserror::Error;  
use std::path::PathBuf;

\#  
pub enum ConfigError {  
    \#\[error("Failed to parse configuration file '{file\_path}': {source}")\]  
    ParseError {  
        file\_path: PathBuf,  
        // Box\<dyn Error\> für Flexibilität bei verschiedenen Parser-Fehlern (z.B. TOML, JSON)  
        \#\[source\] source: Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>,  
    },

    \#\[error("Missing required configuration key: '{key}' in section '{section}'")\]  
    MissingKey { key: String, section: String },

    \#\[error("Invalid value for key '{key}': {reason}")\]  
    InvalidValue { key: String, reason: String },

    // Spezifischer I/O-Fehler im Kontext der Konfiguration  
    \#\[error("I/O error while accessing config '{path}': {source}")\]  
    Io {  
        path: PathBuf,  
        \#\[source\] source: std::io::Error, // Hier \#\[source\], da Kontext (path) hinzugefügt wird  
    },  
}

// Integration in core/src/errors.rs (Erweiterung von CoreError)  
// (bereits oben im CoreError Beispiel gezeigt)  
// \#\[error("Configuration error: {0}")\]  
// Configuration(\#\[from\] ConfigError),

Die Verwendung von \#\[from\] auf der CoreError::Configuration-Variante ermöglicht die automatische Konvertierung eines Result\<\_, ConfigError\> in ein Result\<\_, CoreError\> durch den ?-Operator.1

#### **Etablierung einer strukturierten Fehlerhierarchie**

Der Ansatz, einen zentralen CoreError mit integrierten, Modul-spezifischen Fehlern über \#\[from\] zu kombinieren, etabliert eine klare, zweistufige Fehlerhierarchie innerhalb der Kernschicht. Diese Struktur bietet eine gute Balance:

1. **Zentrale Schnittstelle:** Höhere Schichten interagieren primär mit dem wohldefinierten CoreError, was die Komplexität für die Nutzer der Kernschicht reduziert.  
2. **Lokale Spezifität:** Entwickler, die innerhalb eines Kernschicht-Moduls arbeiten, können mit spezifischeren, kontextbezogenen Fehlertypen (ConfigError, UtilsError, etc.) arbeiten, was die interne Logik klarer und wartbarer macht.  
3. **Nahtlose Propagation:** Die \#\[from\]-Integration stellt sicher, dass die Vorteile des ?-Operators für die Fehlerpropagation über Modulgrenzen hinweg erhalten bleiben.

Diese bewusste Strukturierung ist entscheidend für die Skalierbarkeit und Wartbarkeit der Fehlerbehandlung in einem größeren Projekt. Sie verhindert sowohl eine unübersichtliche Flut von Fehlertypen auf der obersten Ebene als auch den Verlust von spezifischem Fehlerkontext.

### **2.4. Fehlerkontext und Diagnose**

#### **Anreicherung mit Kontext**

Fehlervarianten *sollen* über die reine Fehlermeldung hinaus relevante Kontextinformationen als Felder enthalten. Diese Informationen sind entscheidend für eine effektive Diagnose und Fehlersuche.1 Beispiele für nützliche Kontextfelder sind:

* Dateipfade oder Ressourcennamen (path: PathBuf)  
* Ungültige Werte oder Eingaben (invalid\_value: String)  
* Betroffene Schlüssel oder Bezeichner (key: String, item\_id: Uuid)  
* Zustandsinformationen zum Zeitpunkt des Fehlers (z.B. index: usize, state: String)  
* Zeitstempel (falls relevant)

Rust

// Beispiel für eine Variante mit Kontextfeldern  
\#  
pub enum ProcessingError {  
    \#\[error("Failed to process item '{item\_id}' at index {index} due to: {reason}")\]  
    ItemFailure {  
        item\_id: String,  
        index: usize,  
        reason: String, // Könnte auch ein \#\[source\] Fehler sein  
    },  
    //...  
}

Die Auswahl der Kontextfelder sollte darauf abzielen, die Frage "Was ist passiert und unter welchen Umständen?" möglichst präzise zu beantworten.

#### **Backtraces**

Das thiserror-Crate bettet standardmäßig keine Backtraces in die erzeugten Fehlertypen ein, wie es bei anyhow oder eyre der Fall ist. Backtraces sind primär mit dem $panic\!-Mechanismus assoziiert und können durch Setzen der Umgebungsvariable RUST\_BACKTRACE=1 (oder full) aktiviert werden, um den Call Stack zum Zeitpunkt des Panics anzuzeigen.1  
Für die Diagnose von Fehlern, die über $Result::Err$ zurückgegeben werden, sind die primären Werkzeuge:

1. **Fehlerverkettung (source()):** Verfolgung der Ursache über die source()-Methode.4  
2. **Kontextfelder:** Analyse der in den Fehlervarianten gespeicherten Daten.  
3. **Logging:** Korrelation mit Log-Einträgen, die zum Zeitpunkt des Fehlers erstellt wurden (siehe Abschnitt 4).

Es ist nicht vorgesehen, Backtraces manuell in CoreError oder Modul-Fehler einzubetten, um die Komplexität gering zu halten und sich auf die strukturierte Fehlerinformation zu konzentrieren.

#### **Keine sensiblen Daten**

Es ist absolut entscheidend, dass Fehlermeldungen (\#\[error("...")\]) und die Werte von Kontextfeldern in Fehlervarianten **niemals** sensible Informationen enthalten. Dazu gehören insbesondere:

* Passwörter  
* API-Schlüssel oder Tokens  
* Private Benutzerdaten (Namen, Adressen, etc.)  
* Andere vertrauliche Informationen

Diese Daten dürfen unter keinen Umständen in Logs oder Diagnosedateien gelangen. Wenn solche Daten Teil des Kontexts sind, der zum Fehler führt, müssen sie vor der Aufnahme in den Fehlertyp maskiert, entfernt oder durch Platzhalter ersetzt werden.

## **3\. Implementierungsleitfaden für Entwickler**

### **3.1. Fehlerdefinition**

#### **Neue Variante zu $CoreError$ hinzufügen**

1. **Bedarf prüfen:** Stellen Sie sicher, dass der neue Fehlerfall eine allgemeine Bedeutung für die Kernschicht hat und nicht besser durch einen bestehenden oder einen neuen Modul-Fehler abgedeckt wird.  
2. **Variante definieren:** Fügen Sie eine neue Variante zum CoreError-Enum in core/src/errors.rs hinzu.  
3. **Attribute hinzufügen:** Versehen Sie das CoreError-Enum (falls noch nicht geschehen) mit \#.  
4. **Fehlermeldung (\#\[error\])**: Definieren Sie einen klaren und informativen \#\[error("...")\]-Formatstring für die neue Variante. Nutzen Sie {field\_name}-Platzhalter für Kontextfelder.  
5. **Kontextfelder:** Fügen Sie der Variante die notwendigen Felder hinzu, um den Fehlerkontext zu speichern. Definieren Sie deren Typen.  
6. **Kapselung (\#\[source\] / \#\[from\]):** Falls die Variante einen anderen Fehler kapselt:  
   * Verwenden Sie \#\[source\] auf dem Feld, wenn Sie zusätzlichen Kontext hinzufügen möchten oder der Quelltyp nicht direkt konvertiert werden soll. Die Erzeugung des Fehlers erfolgt dann manuell (z.B. via .map\_err(|e| CoreError::SomeVariant {..., source: e })).  
   * Verwenden Sie \#\[from\] auf dem Feld, wenn eine direkte, automatische Konvertierung vom Quelltyp zur Variante gewünscht ist (nur möglich, wenn der Quelltyp eindeutig dieser Variante zugeordnet werden kann).  
7. **Dokumentation:** Fügen Sie die neue Variante zur Tabelle 1 (oder einer Folgetabelle in der Dokumentation) hinzu und beschreiben Sie ihre Bedeutung und Verwendung. Aktualisieren Sie ggf. Doc-Kommentare.

#### **Neuen Modul-Fehler erstellen und integrieren**

1. **Datei erstellen:** Legen Sie eine neue Datei für die Fehler des Moduls an, typischerweise errors.rs im Modulverzeichnis (z.B. core/src/neues\_modul/errors.rs).  
2. **Enum definieren:** Definieren Sie ein neues, öffentliches Enum (z.B. pub enum NeuesModulError) und leiten Sie \# ab.  
3. **Varianten definieren:** Fügen Sie spezifische Fehlervarianten für das Modul hinzu, wie im vorherigen Abschnitt beschrieben (inkl. \#\[error\], Kontextfeldern, \#\[source\]/\#\[from\] falls interne Fehler gekapselt werden).  
4. **Integration in CoreError:**  
   * Importieren Sie den neuen Modul-Fehler in core/src/errors.rs (z.B. use crate::neues\_modul::errors::NeuesModulError;).  
   * Fügen Sie eine neue Variante zu CoreError hinzu, die den Modul-Fehler kapselt. Der bevorzugte Weg ist:  
     Rust  
     \#\[error("Neues Modul error: {0}")\] // Display delegiert an Modul-Fehler  
     NeuesModul(\#\[from\] NeuesModulError),

5. **Dokumentation:** Dokumentieren Sie den neuen Modul-Fehler (in seiner eigenen Datei) und die Integrationsvariante in CoreError (in core/src/errors.rs und der Tabelle).

### **3.2. Fehlerbehandlung im Code**

#### **Verwendung des ?-Operators**

Der ?-Operator ist das idiomatisches Mittel zur Fehlerpropagation in Rust und *sollte* standardmäßig verwendet werden, wenn eine Funktion, die $Result$ zurückgibt, eine andere Funktion aufruft, die ebenfalls $Result$ zurückgibt.

Rust

use crate::errors::CoreError;  
use crate::config::errors::ConfigError; // Beispiel Modul-Fehler

// Funktion, die einen Modul-Fehler zurückgibt  
fn load\_setting\_internal() \-\> Result\<String, ConfigError\> {  
    //... Logik...  
    if condition {  
        Ok("value".to\_string())  
    } else {  
        Err(ConfigError::MissingKey { key: "foo".to\_string(), section: "bar".to\_string() })  
    }  
}

// Funktion, die CoreError zurückgibt und intern load\_setting\_internal aufruft  
pub fn get\_setting() \-\> Result\<String, CoreError\> {  
    // Das '?' hier konvertiert ConfigError automatisch zu CoreError::Configuration  
    // dank der \#\[from\]-Annotation auf der CoreError::Configuration Variante.  
    let setting \= load\_setting\_internal()?;  
    //... weitere Logik...  
    Ok(setting)  
}

Der ?-Operator funktioniert nahtlos, solange die Fehlertypen entweder identisch sind oder eine From-Implementierung existiert (was thiserror mit \#\[from\] bereitstellt).

#### **Fehler-Matching (match)**

Wenn ein Fehler nicht nur propagiert, sondern spezifisch behandelt werden muss (z.B. um einen Standardwert zu verwenden, einen alternativen Pfad zu wählen oder den Fehler anzureichern), verwenden Sie eine match-Anweisung auf das $Result$.

Rust

use crate::errors::CoreError;  
use crate::config::errors::ConfigError;  
use tracing::warn; // Beispiel für Logging

fn handle\_config\_loading() {  
    match get\_setting() {  
        Ok(setting) \=\> {  
            println\!("Einstellung erfolgreich geladen: {}", setting);  
            //... mit der Einstellung arbeiten...  
        }  
        Err(CoreError::Configuration(ConfigError::MissingKey { ref key, ref section })) \=\> {  
            warn\!(key \= %key, section \= %section, "Konfigurationsschlüssel fehlt, verwende Standardwert.");  
            //... Standardwert verwenden...  
        }  
        Err(CoreError::Io { ref path, ref source }) \=\> {  
            // Kritischer Fehler, kann oft nicht sinnvoll behandelt werden  
            eprintln\!("FATAL: I/O Fehler beim Zugriff auf {:?}: {}", path, source);  
            // Ggf. Programm beenden oder Fehler weiter nach oben geben  
            // return Err(CoreError::Io { path: path.clone(), source: \*source }); // Beispiel für Weitergabe  
        }  
        Err(ref other\_error) \=\> {  
            // Alle anderen CoreError-Varianten behandeln  
            eprintln\!("Ein unerwarteter Kernschicht-Fehler ist aufgetreten: {}", other\_error);  
            // Allgemeine Fehlerbehandlung, ggf. weiter propagieren  
            // return Err(other\_error.clone()); // Klonen nur wenn Fehler Clone implementiert  
        }  
    }  
}

Behandeln Sie nur die Fehlerfälle, für die eine spezifische Logik sinnvoll ist. Für alle anderen Fälle sollte der Fehler entweder weiter propagiert oder in einen allgemeineren Fehler umgewandelt werden.

#### **Umgang mit externen Crates**

Fehler, die von externen Bibliotheken (Crates) zurückgegeben werden (z.B. serde\_json::Error, toml::de::Error, std::io::Error), *müssen* in einen geeigneten Fehlertyp der Kernschicht (CoreError oder einen Modul-Fehler) gekapselt werden, bevor sie die Grenzen der Kernschicht verlassen.

* **Bevorzugt mit \#\[from\]:** Wenn eine eindeutige Zuordnung des externen Fehlers zu einer Variante sinnvoll ist und keine zusätzliche Kontextinformation benötigt wird, verwenden Sie \#\[from\] auf einem Feld dieser Variante. Dies ist oft bei std::io::Error der Fall, wobei hier entschieden wurde, Kontext (path) hinzuzufügen, was \#\[source\] erfordert (siehe CoreError::Io).  
* **Mit \#\[source\]:** Wenn zusätzlicher Kontext hinzugefügt werden soll oder der externe Fehler nicht direkt einer Variante zugeordnet werden kann, verwenden Sie \#\[source\] auf einem Feld und erzeugen Sie die Fehlervariante manuell im Code mittels .map\_err().  
  Rust  
  use serde\_json;  
  use crate::errors::CoreError;

  fn parse\_json\_data(data: \&str) \-\> Result\<serde\_json::Value, CoreError\> {  
      serde\_json::from\_str(data).map\_err(|e| CoreError::Serialization {  
          description: format\!("Failed to parse JSON: {}", e),  
          // Hier wird der Fehler in einen String umgewandelt.  
          // Alternativ könnte man den Fehler boxen: source: Box::new(e)  
          // und die Variante anpassen, wenn der Originalfehler benötigt wird.  
      })  
  }

* **Manuelle Konvertierung:** In komplexeren Fällen kann eine explizite match-Anweisung auf den externen Fehler notwendig sein, um ihn auf verschiedene Varianten des Kernschicht-Fehlers abzubilden.

## **4\. Zusammenspiel mit Logging (core::logging)**

### **4.1. Verweis**

Die detaillierte Spezifikation des Logging-Frameworks (tracing) und dessen Initialisierung ist Gegenstand eines separaten Abschnitts des Kernschicht-Implementierungsleitfadens (Teil 3 oder 4, basierend auf Gesamtspezifikation IV. 4.4). Die hier beschriebenen Richtlinien beziehen sich auf die *Verwendung* des Logging-Frameworks im Kontext der Fehlerbehandlung.

### **4.2. Vorgabe: Logging von Fehlern**

Jeder Fehler, der mittels $Result::Err$ zurückgegeben wird, *sollte* an der Stelle seines Ursprungs oder an einer geeigneten übergeordneten Stelle, die über ausreichend Kontext verfügt, geloggt werden. Das Logging *muss* mindestens auf dem ERROR-Level erfolgen. Das Makro tracing::error\! ist hierfür zu verwenden.  
Das Logging sollte typischerweise *vor* der Propagation des Fehlers mittels ? oder return Err(...) geschehen, um sicherzustellen, dass der Fehler erfasst wird, auch wenn er in höheren Schichten möglicherweise abgefangen oder ignoriert wird.

### **4.3. Strukturiertes Logging**

Das tracing-Framework ermöglicht strukturiertes Logging, bei dem Schlüssel-Wert-Paare an Log-Ereignisse angehängt werden können. Es ist **dringend empfohlen**, den aufgetretenen Fehler selbst als strukturiertes Feld im Log-Eintrag mitzugeben. Dies erleichtert die automatisierte Analyse und Filterung von Logs erheblich.

Rust

use tracing::{error, instrument};  
use crate::errors::CoreError;

\#\[instrument\] // Instrumentiert die Funktion für Tracing (Span)  
fn perform\_critical\_operation(config\_path: \&std::path::Path) \-\> Result\<(), CoreError\> {  
    match std::fs::read\_to\_string(config\_path) {  
        Ok(content) \=\> {  
            //... Operation mit content...  
            Ok(())  
        }  
        Err(io\_error) \=\> {  
            // Fehler loggen, bevor er gekapselt und zurückgegeben wird  
            let core\_err \= CoreError::Io {  
                path: config\_path.to\_path\_buf(),  
                source: io\_error, // Beachten: io::Error implementiert nicht Copy/Clone  
            };

            // Strukturiertes Logging mit dem Fehler als Feld  
            // %core\_err nutzt die Display-Implementierung  
            //?core\_err würde die Debug-Implementierung nutzen  
            error\!(  
                error \= %core\_err, // Fehlerobjekt als Feld 'error'  
                file\_path \= %config\_path.display(), // Zusätzlicher Kontext  
                "Failed during critical operation while reading config" // Log-Nachricht  
            );

            Err(core\_err) // Fehler zurückgeben  
        }  
    }  
}

Die Verwendung von error \= %e (wobei e der Fehler ist) nutzt die Display-Implementierung des Fehlers für die Log-Ausgabe, während error \=?e die Debug-Implementierung verwenden würde. Die Display-Implementierung ist oft für die primäre Log-Nachricht vorzuziehen, während die Debug-Darstellung bei Bedarf für detailliertere Analysen herangezogen werden kann.

### **4.4. Fehler als integraler Bestandteil der Observability**

Die konsequente Verknüpfung von $Result::Err$-Rückgaben mit strukturiertem tracing::error\!-Logging hebt die Fehlerbehandlung über reines Debugging hinaus. Sie macht Fehler zu einem integralen Bestandteil der System-Observability. Die Kombination aus wohldefinierten, typisierten Fehlern (thiserror) und einem strukturierten Logging-Framework (tracing) schafft einen Datenstrom von Fehlerereignissen, der für Monitoring und Alerting genutzt werden kann.  
Systeme zur Log-Aggregation und \-Analyse (wie z.B. Elasticsearch/Kibana, Loki/Grafana oder spezialisierte Tracing-Backends) können diesen strukturierten Datenstrom verarbeiten. Dies ermöglicht:

* **Visualisierung:** Erstellung von Dashboards, die Fehlerraten über Zeit anzeigen, aufgeschlüsselt nach Fehlertyp (z.B. CoreError::Io vs. CoreError::Configuration).  
* **Filterung und Suche:** Gezielte Suche nach spezifischen Fehlervarianten oder Fehlern, die bestimmte Kontextdaten enthalten (z.B. alle Fehler im Zusammenhang mit einer bestimmten Datei).  
* **Alerting:** Konfiguration von Alarmen, die ausgelöst werden, wenn die Häufigkeit bestimmter Fehler einen Schwellenwert überschreitet.

Diese systematische Erfassung und Analyse von Fehlern ist entscheidend für die Aufrechterhaltung der Stabilität und Zuverlässigkeit des Systems im Betrieb und verbessert die Reaktionsfähigkeit auf Probleme erheblich.

## **5\. Ausblick**

Dieser Implementierungsleitfaden für core::errors legt das Fundament für eine robuste und konsistente Fehlerbehandlung in der gesamten Desktop-Umgebung. Die hier definierten Prinzipien, der CoreError-Typ und die Mechanismen zur Integration von Modul-Fehlern sind verbindlich für alle weiteren Entwicklungen innerhalb der Kernschicht und dienen als Vorbild für die Fehlerbehandlung in den darüberliegenden Schichten (Domäne, System, UI).  
Die nachfolgenden Teile der Kernschicht-Spezifikation, beginnend mit core::logging (Implementierung der tracing-Integration), core::config (Laden und Parsen von Konfigurationen unter Verwendung von CoreError::Configuration und ConfigError) und core::types (Definition fundamentaler Datenstrukturen mit entsprechender Fehlerbehandlung bei Validierungen), werden die hier etablierten Fehlerkonventionen konsequent anwenden und darauf aufbauen. Die disziplinierte Einhaltung dieser Fehlerstrategie ist von zentraler Bedeutung für die Entwicklung einer qualitativ hochwertigen, stabilen und wartbaren Software.

#### **Referenzen**

1. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
2. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)  
3. std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/index.html](https://doc.rust-lang.org/std/error/index.html)  
4. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)
## **A3 Kernschicht Fehlerbehandlung** **1\. Fehlerbehandlung (core::errors)**

Die Fehlerbehandlung ist ein kritischer Aspekt der Systemstabilität und Wartbarkeit. Dieses Kapitel definiert die Strategien und Mechanismen für die Fehlerbehandlung innerhalb der Kernschicht (Core Layer). Ziel ist es, eine konsistente, informative und robuste Fehlerpropagierung und \-behandlung im gesamten System sicherzustellen. Die hier festgelegten Richtlinien basieren auf den allgemeinen Entwicklungsrichtlinien (Abschnitt IV.3. Fehlerbehandlung) und spezifizieren deren Anwendung innerhalb der Kernschicht.

### **1.1. Definition des Basis-Fehlertyps (CoreError)**

Zweck:  
Ein grundlegender, allgemeiner Fehlertyp für die Kernschicht, CoreError, wird definiert. Dieser dient dazu, Fehler zu repräsentieren, die direkt von generischen Kern-Dienstprogrammen stammen oder als gemeinsame Basis für Fehler innerhalb des core::errors-Moduls selbst dienen. Die Existenz von CoreError verhindert die Ad-hoc-Verwendung von unspezifischen Fehlertypen wie Box\<dyn std::error::Error\> für nicht klassifizierte Kernprobleme und stellt ein kanonisches Beispiel für die Verwendung von thiserror dar. Es ist jedoch entscheidend, dass CoreError nicht zu einem Sammelbecken für alle Arten von Fehlern wird, da die primäre Strategie auf modul-spezifischen Fehlertypen beruht (siehe Abschnitt 1.3), um Präzision und Klarheit in der Fehlerbehandlung zu gewährleisten.1  
Spezifikation:  
Der CoreError-Enum wird wie folgt definiert:

Rust

\#  
pub enum CoreError {  
    \#\[error("Core component '{component}' failed to initialize")\]  
    InitializationFailed {  
        component: String,  
        \#\[source\]  
        source: Option\<Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>\>,  
    },

    \#\[error("Core configuration error: {message}")\]  
    ConfigurationError {  
        message: String,  
        \#\[source\]  
        source: Option\<Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>\>,  
    },

    \#\[error("An I/O operation failed at the core level")\]  
    Io {  
        \#\[from\] // Beispiel für direkte Konvertierung eines häufigen, eindeutigen Fehlers  
        source: std::io::Error,  
    },

    \#\[error("Core internal assertion failed: {context}")\]  
    InternalAssertionFailed {  
        context: String,  
        // Diese Variante hat typischerweise keine \`source\`, da sie einen internen Logikfehler darstellt.  
    },

    // Weitere wirklich generische Core Layer Fehlervarianten können hier bei Bedarf ergänzt werden.  
    // Es ist zu vermeiden, Varianten hinzuzufügen, die spezifischen Submodulen wie config, utils etc. zugeordnet werden sollten.  
}

* **Display (\#\[error(...)\]) Nachrichten:**  
  * Die Fehlermeldungen, die durch das \#\[error(...)\]-Attribut generiert werden, *müssen* den Rust API Guidelines entsprechen: prägnant, in Kleinbuchstaben und ohne abschließende Satzzeichen (z.B. "invalid digit found in string" 3).  
  * Die Nachrichten *müssen* klar artikulieren, welches spezifische Problem aus der Perspektive des Betriebs der Kernschicht aufgetreten ist.  
  * Platzhalter (z.B. {component}, {message}) *müssen* verwendet werden, um dynamische kontextuelle Informationen in die Nachricht zu integrieren.  
  * Die Sprache *muss* so gewählt werden, dass sie für einen Entwickler, der das System debuggt, verständlich ist.  
* **Debug Format:**  
  * Die abgeleitete Debug-Implementierung ist Standard. Sie wird für detailliertes Logging und Debugging-Sitzungen verwendet, bei denen die vollständige Struktur des Fehlers, einschließlich aller Felder und der Debug-Repräsentation jeglicher \#\[source\]-Fehler, erforderlich ist.  
* **std::error::Error Trait Implementierung:**  
  * Diese wird automatisch durch \#\[derive(thiserror::Error)\] bereitgestellt. Die source()-Methode ist verfügbar, wenn eine Variante ein Feld enthält, das mit \#\[source\] oder \#\[from\] annotiert ist.

Die Varianten von CoreError *müssen* strikt auf wirklich generische Situationen beschränkt bleiben. Dieser Enum darf nicht zu einem "Catch-all"-Typ werden, da dies die Vorteile spezifischer, modulbezogener Fehlertypen untergraben würde, die eine präzise Fehlerbehandlung durch Aufrufer ermöglichen.1 Eine übermäßige Ansammlung diverser Varianten, die eigentlich zu Submodulen gehören (z.B. ConfigParseError, UtilsStringFormatError), würde CoreError zu einem monolithischen Fehlertyp machen. Die Behandlung eines solchen Fehlers würde dann umfangreiches Pattern-Matching und möglicherweise die Inspektion von Zeichenketten erfordern, was die Vorteile spezifischer Enums zunichtemacht. Daher wird sichergestellt, dass CoreError schlank bleibt und sich auf genuinely schichtweite oder spezifische Probleme des core::errors-Moduls konzentriert.  
**Tabelle 1: CoreError Enum Spezifikation**  
Die folgende Tabelle dient als eindeutige Referenz für Entwickler und als Vertrag für den CoreError-Typ, um Konsistenz über das gesamte Projekt hinweg sicherzustellen und die Anforderung einer "Ultra-Feinspezifikation" zu erfüllen.

| Variantenname | Felder | \#\[error(...)\] Format-String | Beschreibung / Verwendungszweck |
| :---- | :---- | :---- | :---- |
| InitializationFailed | component: String, source: Option\<Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>\> (\#\[source\]) | Core component '{component}' failed to initialize | Wird verwendet, wenn eine Kernkomponente nicht initialisiert werden konnte. Enthält optional den zugrundeliegenden Fehler. |
| ConfigurationError | message: String, source: Option\<Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>\> (\#\[source\]) | Core configuration error: {message} | Repräsentiert einen allgemeinen Konfigurationsfehler auf Kernschichtebene. |
| Io | source: std::io::Error (\#\[from\]) | An I/O operation failed at the core level | Für generische E/A-Fehler, die direkt auf der Kernschichtebene auftreten und von std::io::Error konvertiert werden können. |
| InternalAssertionFailed | context: String | Core internal assertion failed: {context} | Zeigt einen internen Logikfehler oder eine verletzte Invariante innerhalb der Kernschicht an. |

Diese tabellarische Darstellung ermöglicht es Entwicklern, alle kritischen Attribute jeder Fehlervariante – Name, enthaltene Daten, Display-Format und Zweck – sofort zu erfassen. Diese Präzision minimiert Mehrdeutigkeiten und stellt sicher, dass alle Entwickler CoreError identisch implementieren und verwenden.

### **1.2. Fehlerquellenverkettung und Kontext (Error Source Chaining and Context)**

Zweck:  
Es werden verbindliche Praktiken zur Bewahrung und Offenlegung der zugrundeliegenden Ursachen von Fehlern etabliert. Dies stellt sicher, dass ein vollständiger Diagnosepfad verfügbar ist, was das Debugging erleichtert, indem Entwickler einen Fehler bis zu seiner ursprünglichen Ursache zurückverfolgen können.1 Ein Fehlerbericht sollte die grundlegende Ursache und den vollständigen Kontext-Stack für das Debugging enthalten.  
**Spezifikationen:**

* **Verbindliche Verwendung von \#\[from\] für eindeutige direkte Konvertierungen:**  
  * Wenn eine Funktion der Kernschicht eine andere Funktion aufruft (intern, aus std oder aus einer externen Crate), die ein Result zurückgibt, und der Fehlertyp des Aufgerufenen *eindeutig und direkt* einer spezifischen Variante des thiserror-Enums des Aufrufers zugeordnet werden kann, *muss* das \#\[from\]-Attribut auf einem Feld dieser Variante verwendet werden, um eine automatische Konvertierung über den ?-Operator zu ermöglichen.  
  * Beispiel:  
    Rust  
    // In core/src/some\_module/errors.rs  
    \#  
    pub enum SomeModuleError {  
        \#\[error("A core I/O operation failed")\]  
        CoreIo(\#\[from\] std::io::Error), // Eindeutige Konvertierung von std::io::Error

        \#\[error("Failed to parse item data")\]  
        Parsing(\#\[from\] serde\_json::Error), // Eindeutige Konvertierung von serde\_json::Error  
    }

* **Manuelles Wrappen zur Hinzufügung von Kontext oder zur Auflösung von Mehrdeutigkeiten:**  
  * **Hinzufügen von Kontext:** Wenn ein Fehler eines Aufgerufenen gewrappt werden muss, um *zusätzliche kontextuelle Informationen* bereitzustellen, die für das Verständnis des Fehlers im Kontext des Aufrufers entscheidend sind (z.B. die spezifische Datei, die verarbeitet wird, der gesuchte Schlüssel), *muss* eine dedizierte Fehlervariante definiert werden. Diese Variante *muss* Felder für den zusätzlichen Kontext und ein Feld, das mit \#\[source\] annotiert ist, zur Speicherung des ursprünglichen Fehlers enthalten.  
    Rust  
    // In core/src/config/errors.rs  
    use std::path::PathBuf; // Hinzugefügt für Vollständigkeit

    \#  
    pub enum ConfigError {  
        \#\[error("Failed to load configuration from '{path}'")\]  
        LoadFailed {  
            path: PathBuf,  
            \#\[source\]  
            source: std::io::Error, // Manuell gewrappt, um 'path'-Kontext hinzuzufügen  
        },  
        //... andere Varianten  
    }

  * **Auflösung von \#\[from\]-Mehrdeutigkeiten:** Die thiserror-Crate erlaubt nicht mehrere \#\[from\]-Annotationen für den *gleichen Quellfehlertyp* innerhalb eines einzelnen Enums.1 Wenn die Operationen eines Moduls denselben zugrundeliegenden Fehlertyp (z.B. std::io::Error) aus logisch unterschiedlichen Operationen (z.B. Lesen einer Datei vs. Schreiben einer Datei) ergeben können, kann \#\[from\] nicht für beide verwendet werden. In diesem Szenario:  
    1. Es *müssen* unterschiedliche Fehlervarianten für jede logische Operation erstellt werden.  
    2. Jede solche Variante *muss* den gemeinsamen zugrundeliegenden Fehlertyp manuell unter Verwendung eines mit \#\[source\] annotierten Feldes wrappen.  
    3. Die \#\[error("...")\]-Nachricht und alle zusätzlichen kontextuellen Felder dieser Varianten *müssen* die logischen Operationen klar unterscheiden.

Rust  
// In core/src/some\_module/errors.rs  
use std::path::PathBuf; // Hinzugefügt für Vollständigkeit

\#  
pub enum FileOperationError {  
    \#\[error("Failed to read data from file '{path}'")\]  
    ReadError {  
        path: PathBuf,  
        \#\[source\]  
        source: std::io::Error, // std::io::Error aus einer Leseoperation  
    },

    \#\[error("Failed to write data to file '{path}'")\]  
    WriteError {  
        path: PathBuf,  
        \#\[source\]  
        source: std::io::Error, // std::io::Error aus einer Schreiboperation  
    },  
}  
Diese Vorgehensweise erhält die semantische Spezifität des Fehlers und ermöglicht es Aufrufern, Fehlermodi zu unterscheiden, was für eine robuste Fehlerbehandlungslogik entscheidend ist. Es wandelt eine potenzielle Einschränkung von thiserror (bei unsachgemäßer Verwendung) in ein Muster um, das zu aussagekräftigeren Fehlervarianten anregt.

* **Nutzung der source()-Methode:**  
  * Die Methode std::error::Error::source() (verfügbar bei thiserror-abgeleiteten Enums) ist der Standardmechanismus für den Zugriff auf die zugrundeliegende Ursache eines Fehlers.3  
  * Entwickler, die Fehler der Kernschicht (oder Fehler anderer Schichten) konsumieren, *müssen* sich dieser Methode bewusst sein und *sollten* sie in Logging- und Debugging-Routinen verwenden, um die Fehlerkette zu durchlaufen und die vollständige Abfolge der Ursachen zu melden.  
  * Der experimentelle sources()-Iterator 3 wäre, falls stabilisiert, der bevorzugte Weg, um die gesamte Kette zu iterieren. Bis dahin ist eine manuelle Schleife erforderlich:  
    Rust  
    // fn log\_full\_error\_chain(err: &(dyn std::error::Error \+ 'static)) {  
    //     tracing::error\!("Error: {}", err);  
    //     let mut current\_source \= err.source();  
    //     while let Some(source) \= current\_source {  
    //         tracing::error\!("  Caused by: {}", source);  
    //         current\_source \= source.source();  
    //     }  
    // }

Die Bequemlichkeit von \#\[from\] ist verlockend, aber die Einschränkung, dass nicht zwei Fehlervarianten vom selben Quelltyp abgeleitet werden können 1, kann zu einem Verlust an semantischer Unterscheidung führen, wenn sie nicht sorgfältig gehandhabt wird. Die Spezifikation begegnet dem direkt, indem sie manuelles Wrappen mit unterschiedlichen Varianten vorschreibt, wenn eine solche Mehrdeutigkeit auftritt. Dies erhält die Klarheit und nutzt thiserror dennoch effektiv. Effektives Debugging hängt von ausreichendem Kontext ab. Die \#\[source\]-Kette liefert das "Warum" ein Fehler auf einer niedrigeren Ebene aufgetreten ist, während benutzerdefinierte Felder in Fehlervarianten das "Was" und "Wo" spezifisch für die aktuelle Operation liefern.1 Durch die Vorschrift, solche Kontextfelder einzuschließen und \#\[source\] zu verwenden, wird sichergestellt, dass Fehlertypen reich an Informationen sind, was die Debugfähigkeit direkt verbessert.

### **1.3. Modul-spezifische Fehler innerhalb der Kernschicht**

Zweck:  
Durchsetzung eines modularen und spezifischen Ansatzes zur Fehlerbehandlung gemäß Richtlinie 4.3 ("spezifischen Fehler-Enums pro Modul"). Jedes logische Submodul innerhalb der Kernschicht (z.B. core::config, core::utils::string\_processing, core::types\_validation) muss seinen eigenen, distinkten Fehler-Enum definieren. Dies verbessert die Kapselung, erhöht die Klarheit für die Konsumenten des Moduls und steht im Einklang mit bewährten Praktiken.2  
**Spezifikationen:**

* **Verbindliche modul-level Fehler-Enums:**  
  * Jedes nicht-triviale öffentliche Submodul innerhalb der Kernschicht, das behebbare Fehler erzeugen kann, *muss* seinen eigenen öffentlichen Fehler-Enum definieren (z.B. pub enum ConfigError {... } in core::config::errors, pub enum ValidationRuleError {... } in core::types::validation::errors).  
  * Diese Enums *müssen* mittels \# definiert werden.  
  * Sie *müssen* allen Spezifikationen bezüglich Display-Nachrichten (Abschnitt 1.1) und Fehlerquellenverkettung/Kontext (Abschnitt 1.2) entsprechen.  
* **Granularität und Kohäsion:**  
  * Die Granularität der Fehler-Enums sollte sich an Modulgrenzen und logischen Funktionsbereichen orientieren. Ein einzelnes, großes Modul könnte einen umfassenden Fehler-Enum für seine Operationen definieren. Wenn ein Modul übermäßig groß wird oder seine Fehlerzustände zu vielfältig werden, *sollte* eine Refaktorierung in kleinere Submodule in Betracht gezogen werden, von denen jedes einen fokussierteren Fehler-Enum besitzt. Dies folgt dem Geist der Diskussion in 2 über das Gleichgewicht zwischen der Verbreitung von Fehlertypen und der Spezifität.  
  * Die Erstellung von Fehlertypen für einzelne Funktionen ist zu vermeiden, es sei denn, diese Funktion stellt eine signifikante, distinkte Einheit fehlbarer Arbeit dar.  
* **Keine direkte Propagierung von CoreError aus Submodulen:**  
  * Submodule der Kernschicht (z.B. core::config) *dürfen typischerweise nicht* den generischen CoreError (definiert in Abschnitt 1.1) zurückgeben. Sie *müssen* ihre eigenen spezifischen Fehlertypen zurückgeben (z.B. ConfigError).  
  * CoreError ist für Fehler reserviert, die innerhalb von core::errors selbst entstehen, oder für wirklich schichtweite, nicht klassifizierbare Probleme, die keinem spezifischen Submodul zugeordnet werden können.  
* **Intermodul-Fehlerkonvertierung/-wrapping (innerhalb der Kernschicht):**  
  * Wenn ein Kernschichtmodul Alpha eine Funktion eines anderen Kernschichtmoduls Beta aufruft und die Funktion von Beta Result\<T, BetaError\> zurückgibt, dann *muss* der Fehler-Enum von Alpha (AlphaError) eine Variante definieren, um BetaError zu wrappen, falls dieser Fehler propagiert werden soll.  
  * Dieses Wrapping *sollte* typischerweise \#\[from\] für die Kürze verwenden, wenn die Zuordnung innerhalb von AlphaError eindeutig ist.  
    Rust  
    // In core/src/module\_alpha/errors.rs  
    use crate::module\_beta::errors::BetaError; // Annahme: BetaError ist korrekt importiert

    \#  
    pub enum AlphaError {  
        \#\[error("An error occurred in the beta subsystem")\]  
        BetaSystemFailure(\#\[from\] BetaError),  
        //... andere AlphaError Varianten  
    }

  * Dies stellt sicher, dass Konsumenten von module\_alpha nur direkt auf AlphaError-Varianten matchen müssen, aber immer noch über AlphaError::BetaSystemFailure(...).source() auf den zugrundeliegenden BetaError zugreifen können.  
* **Handhabung von \#\[from\]-Konflikten (Wiederholung für Modulfehler):**  
  * Die Regel aus Abschnitt 1.2 bezüglich des manuellen Wrappings für mehrdeutige \#\[from\]-Quellen gilt gleichermaßen für modul-spezifische Fehler-Enums. Wenn core::config::ConfigError std::io::Error sowohl von einer Lese- als auch einer Schreiboperation repräsentieren muss, *muss* es distinkte Varianten wie ReadIoError { \#\[source\] source: std::io::Error,... } und WriteIoError { \#\[source\] source: std::io::Error,... } haben.

Modul-spezifische Fehler sind ein Eckpfeiler der Kapselung. Konsumenten eines Moduls (z.B. core::config) müssen nur ConfigError kennen, nicht die internen Fehlertypen (wie serde\_json::Error oder std::io::Error), die core::config möglicherweise handhabt und wrappt.2 Dies reduziert die Kopplung zwischen Modulen und Schichten erheblich. Würde core::config die Fehler seiner internen Abhängigkeiten direkt exponieren, wären alle Nutzer von core::config auch an diese Abhängigkeiten gekoppelt. Eine spätere Änderung der JSON-Parsing-Bibliothek in core::config würde dann alle seine Konsumenten brechen. Durch die Definition von ConfigError mit Varianten wie ParseFailure(\#\[from\] serde\_json::Error) schirmt core::config seine Konsumenten ab.  
Indem jedes Modul nur seinen eigenen Fehler-Enum definiert und exponiert, stellt die Kernschicht den höheren Schichten (Domäne, System, UI) eine abstraktere und handhabbare Menge von Fehlertypen zur Verfügung. Diese höheren Schichten wrappen dann Fehler der Kernschicht in ihre eigenen, abstrakteren Fehlertypen. Dies erzeugt eine saubere Hierarchie der Fehlerabstraktion und verhindert eine überwältigende Verbreitung spezifischer Fehlertypen auf höheren Ebenen.2 Die detaillierten Regeln für die Verwendung von thiserror, insbesondere bezüglich \#\[from\]-Mehrdeutigkeiten und manuellem Wrappen für Kontext, stellen sicher, dass die gewählte Bibliothek ihr volles Potenzial entfaltet und Fehlertypen erzeugt werden, die sowohl ergonomisch für Entwickler als auch reich an diagnostischen Informationen sind. Dies begegnet potenziellen Fallstricken, die in 1 erwähnt werden, durch die Bereitstellung konkreter, handlungsorientierter Muster.

### **1.4. Durchsetzung der Strategie für Panic vs. Error**

Zweck:  
Es wird eine strikte, unzweideutige Unterscheidung zwischen behebbaren Laufzeitfehlern (die zwingend mittels Result\<T, E\> und den oben definierten Fehlertypen behandelt werden müssen) und nicht behebbaren Programmierfehlern oder kritischen Invariantenverletzungen (die zu einem panic führen sollten) etabliert und durchgesetzt. Dies entspricht der fundamentalen Fehlerbehandlungsphilosophie von Rust.4  
**Spezifikationen:**

* **Striktes Verbot von .unwrap() und .expect() in Bibliotheks-Code der Kernschicht:**  
  * Die Verwendung der Methoden .unwrap() oder .expect() auf Result\<T, E\>- oder Option\<T\>-Typen ist in jeglichem Bibliotheks-Code der Kernschicht *strikt verboten*. Bibliotheks-Code ist definiert als jeder Code innerhalb der core-Crate, der für die Verwendung durch andere Schichten (Domäne, System, UI) oder andere Module innerhalb der Kernschicht vorgesehen ist.  
  * Alle Operationen, die auf einen behebbaren Fehler stoßen können, *müssen* explizit Result\<T, E\> zurückgeben, wobei E ein geeigneter Fehlertyp gemäß den Spezifikationen in den Abschnitten 1.1-1.3 ist. Diese strikte Regel ist der primäre Mechanismus, um sicherzustellen, dass alle potenziellen behebbaren Fehlerpfade explizit berücksichtigt und durch Rückgabe von Result behandelt werden, was fundamental für die Entwicklung robuster Software in Rust ist.4 Jeder Aufruf von .unwrap() oder .expect() in Bibliotheks-Code ist ein versteckter panic, der die gesamte Desktop-Umgebung zum Absturz bringen kann.  
* **Zulässige, wohlüberlegte Verwendung von .expect() (Nicht-Bibliotheks-Kontexte):**  
  * .expect() *darf nur* in den folgenden, gut begründeten Nicht-Bibliotheks-Kontexten verwendet werden:  
    * **Tests:** Innerhalb von Unit-Tests (\#\[test\]) und Integrationstests (in tests/), wo ein Fehlschlag einen Fehler im Test-Setup, ein Missverständnis der getesteten Komponente oder einen echten, durch den Test aufgedeckten Bug anzeigt. Der Test selbst ist die Grenze der Wiederherstellbarkeit.  
    * **Interne Werkzeuge/Binaries:** In main.rs oder Hilfsfunktionen von internen Kommandozeilenwerkzeugen, Build-Skripten oder Dienstprogrammen, die *nicht* Teil der Kernschicht-Bibliothek selbst sind und bei denen ein Fehlerzustand für die Ausführung *dieses spezifischen Werkzeugs* tatsächlich nicht behebbar ist.  
    * **Kritische Invarianten (selten):** In äußerst seltenen Situationen innerhalb des Bibliotheks-Codes, in denen eine Bedingung aufgrund vorheriger validierter Logik *garantiert* wahr ist (z.B. Zugriff auf ein Array-Element nach einer Grenzenprüfung). Wenn diese Invariante verletzt wird, signalisiert dies einen kritischen, nicht behebbaren internen Logikfehler (einen Bug). Eine solche Verwendung *muss* ausführlich kommentiert und begründet werden. Dies ist eine Ausnahme, nicht die Regel.  
* **Verbindlicher Stil für .expect()-Nachrichten:**  
  * Wenn .expect() zulässigerweise verwendet wird (wie oben definiert), *muss* die bereitgestellte Nachrichtenzeichenkette dem Stil "expect as precondition" entsprechen, wie in 4 befürwortet.  
  * Die Nachricht *darf nicht* lediglich den aufgetretenen Fehler beschreiben (was oft redundant mit der Display-Nachricht des zugrundeliegenden Fehlers ist, falls das Result ein Err enthielt).  
  * Stattdessen *muss* die Nachricht die *Vorbedingung* oder *Invariante* beschreiben, von der erwartet wurde, dass sie zutrifft, und erklären, *warum* erwartet wurde, dass die Operation erfolgreich ist.  
  * **Korrektes Beispiel (Precondition Style):**  
    Rust  
    // In einem Test oder internen Werkzeug:  
    // let config \= get\_config\_somehow(); // Platzhalter für Konfigurationsbeschaffung  
    // let user\_count: u32 \= config.get\_max\_users()  
    //    .expect("System configuration 'max\_users' should be present and valid at this point");

  * **Falsches Beispiel (Error Message Style \- NICHT VERWENDEN):**  
    Rust  
    // let user\_count \= config.get\_max\_users().expect("Failed to get max\_users"); // SCHLECHTER STIL

Die Übernahme des "expect as precondition"-Stils für Panic-Nachrichten 4 verwandelt Panics von einfachen Absturzberichten in wertvolle Diagnosewerkzeuge. Diese Nachrichten erklären die verletzten Annahmen des Programmierers und lenken die Debugging-Bemühungen direkt auf den logischen Fehler. Eine Nachricht wie "env variable 'IMPORTANT\_PATH' should be set by 'wrapper\_script.sh'" 4 ist weitaus informativer als "env variable 'IMPORTANT\_PATH' is not set".

* **Direkte Verwendung des panic\!-Makros:**  
  * Direkte Aufrufe von panic\!("message") *sollten* Situationen vorbehalten bleiben, in denen das Programm einen nicht wiederherstellbaren Zustand, eine verletzte kritische Invariante oder eine logische Unmöglichkeit feststellt, die eindeutig auf einen Bug im eigenen Code der Kernschicht hinweist.  
  * Die Panic-Nachricht *sollte* klar und informativ sein und Entwicklern bei der Diagnose des Bugs helfen.  
  * Panicking ist angebracht, wenn eine Fortsetzung der Ausführung zu weiteren Fehlern, Datenkorruption oder undefiniertem Verhalten führen würde.

#### **Referenzen**

1. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
2. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)  
3. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)  
4. std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/index.html](https://doc.rust-lang.org/std/error/index.html)
# **A4 Kernschicht: Kerninfrastruktur (Teil 4/4)**

## **1\. Einleitung**

Dieses Dokument ist Teil 4 der Spezifikation für die Kernschicht (Core Layer) und konzentriert sich auf die Definition der fundamentalen Infrastrukturkomponenten. Diese Komponenten bilden das Rückgrat für alle darüberliegenden Schichten der Desktop-Umgebung und umfassen die Fehlerbehandlung, das Logging-System, Mechanismen zur Konfigurationsverwaltung sowie grundlegende Datentypen und Hilfsfunktionen.  
Ziel dieses Dokuments ist es, eine ultra-feingranulare Spezifikation bereitzustellen, die es Entwicklern ermöglicht, diese Kerninfrastrukturelemente direkt zu implementieren. Jede Komponente, Methode, Datenstruktur und Richtlinie wird detailliert beschrieben, um Klarheit zu gewährleisten und Designentscheidungen vorwegzunehmen. Die hier definierten Systeme sind entscheidend für die Stabilität, Wartbarkeit, Diagnosefähigkeit und Konsistenz der gesamten Desktop-Umgebung.  
Die folgenden Abschnitte behandeln:

* **Fehlerbehandlungsinfrastruktur (core::errors)**: Definition eines robusten und konsistenten Ansatzes zur Fehlerbehandlung unter Verwendung der thiserror-Crate.  
* **Core Logging Infrastruktur (core::logging)**: Spezifikation eines strukturierten Logging-Systems basierend auf der tracing-Crate.  
* **Core Konfigurationsprimitive (core::config)**: Festlegung von Mechanismen zum Laden, Parsen und Zugreifen auf Basiskonfigurationen.  
* **Core Utilities (core::utils)**: Richtlinien für allgemeine Hilfsfunktionen.  
* **Core Datentypen (core::types)**: Definition fundamentaler, systemweit genutzter Datentypen.

Die sorgfältige Implementierung dieser Infrastrukturkomponenten ist unerlässlich, da sie die Qualität und Zuverlässigkeit aller anderen Teile des Systems maßgeblich beeinflussen.

## **2\. Fehlerbehandlungsinfrastruktur (core::errors)**

Eine robuste und aussagekräftige Fehlerbehandlung ist das Fundament stabiler Software. Für die Kernschicht, die von allen anderen Schichten genutzt wird, ist dies von besonderer Bedeutung. Die hier definierte Infrastruktur zielt auf Klarheit, Konsistenz und einfache Nutzung für Entwickler ab.

### **2.1. Grundlagen und Wahl von thiserror**

Die Fehlerbehandlung in Rust basiert auf dem Result\<T, E\>-Enum, wobei E typischerweise den std::error::Error-Trait implementiert.1 Für die Definition benutzerdefinierter Fehlertypen wird die Crate thiserror eingesetzt. Diese Wahl begründet sich dadurch, dass thiserror speziell für Bibliotheken konzipiert ist, im Gegensatz zu anyhow, das eher für Applikationen (Binaries) gedacht ist.1 Die Kernschicht und viele Teile der Domänen- und Systemschicht fungieren als Bibliotheken für andere Teile der Desktop-Umgebung.  
thiserror bietet folgende Vorteile:

* Es generiert Boilerplate-Code für die Implementierung des std::error::Error-Traits.  
* Es ermöglicht die einfache Definition von Fehlermeldungen über das \#\[error(...)\]-Attribut.  
* Es unterstützt die Konvertierung von zugrundeliegenden Fehlern mittels des \#\[from\]-Attributs, was die Verwendung des ?-Operators erleichtert.1

### **2.2. Granularität: Ein Fehler-Enum pro Modul**

Um eine klare Struktur und gute Verwaltbarkeit der Fehlertypen zu gewährleisten, wird festgelegt, dass jedes signifikante Modul innerhalb der Kernschicht (und konsequenterweise auch in den höheren Schichten) sein eigenes, spezifisches Fehler-Enum definiert.2 Dies stellt einen guten Kompromiss zwischen der Notwendigkeit spezifischer Fehlerbehandlung und der Vermeidung einer übermäßigen Anzahl globaler oder unspezifischer Fehlertypen dar.  
Eine potenzielle Einschränkung von thiserror ist, dass man nicht zwei Fehlervarianten vom selben Ursprungstyp (source type) definieren kann, wenn man \#\[from\] direkt verwendet, was dazu führen könnte, dass der Kontext verloren geht (z.B. ob ein std::io::Error beim Lesen oder Schreiben auftrat).1 Die Strategie, pro Modul ein eigenes Fehler-Enum zu definieren, mildert dieses Problem erheblich. Selbst wenn sowohl ModuleAError als auch ModuleBError einen std::io::Error wrappen, liefert bereits der Typ des Fehler-Enums (ModuleAError vs. ModuleBError) wichtigen Kontext. Innerhalb eines Modul-Enums können zudem spezifische Varianten erstellt werden, die denselben zugrundeliegenden Fehlertyp wrappen, aber unterschiedliche Operationen oder Kontexte repräsentieren. Zum Beispiel könnte ein ConfigError-Enum Varianten wie ReadError { path: PathBuf, \#\[source\] source: std::io::Error } und ParseError { path: PathBuf, \#\[source\] source: serde\_toml::Error } haben. Dies stellt sicher, dass der Kontext nicht "verwischt" wird, wie in 1 als potenzielle Herausforderung beschrieben. Die Kombination aus modul-spezifischen Enums und sorgfältig benannten Varianten mit kontextuellen Feldern sorgt für die notwendige Klarheit.

### **2.3. thiserror Implementierungsrichtlinien und Pro-Modul Fehler-Enums**

Für jedes Modul, das Fehler erzeugen kann, muss ein Fehler-Enum mit thiserror definiert werden.  
Strukturbeispiel:  
Angenommen, es gibt ein Modul core::some\_module:

Rust

// In core::some\_module::error.rs (oder direkt im Modul)  
use std::path::PathBuf;  
use thiserror::Error;

\#  
pub enum SomeModuleError {  
    \#\[error("Fehler bei der Initialisierung der Komponente: {reason}")\]  
    InitializationFailure { reason: String },

    \#\[error("Ungültiger Parameter '{parameter\_name}': {details}")\]  
    InvalidParameter { parameter\_name: String, details: String },

    \#  
    IoError {  
        operation: String,  
        path: PathBuf,  
        \#\[source\]  
        source: std::io::Error,  
    },

    \#  
    DeserializationError {  
        path: PathBuf,  
        \#\[source\]  
        source: serde\_json::Error, // Beispiel für einen spezifischen Deserialisierungsfehler  
    },

    \#\[error("Feature '{feature\_name}' ist nicht verfügbar.")\]  
    FeatureUnavailable { feature\_name: String },

    \#  
    DependentServiceError {  
        service\_name: String,  
        \#\[source\]  
        source: Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>, // Für generische Fehler von Abhängigkeiten  
    },  
}

**\#\[error(...)\]-Annotationen:**

* Die Fehlermeldungen müssen primär entwicklerorientiert sein: präzise, informativ und klar verständlich.  
* Sie müssen den Grund des Fehlers erläutern und wichtige kontextuelle Parameter (z.B. Dateipfade, Parameternamen, fehlerhafte Werte) über die Felder der Enum-Variante einbinden (z.B. {parameter\_name}).  
* Der Stil der Meldungen soll konsistent sein: typischerweise in Kleinschreibung, prägnant und ohne abschließende Satzzeichen, es sei denn, diese sind Teil eines zitierten Literals.3  
* Die Meldungen sollen dazu beitragen, die "Grundursache" des Fehlers zu verstehen.1 Obwohl die "Benutzerperspektive" in 1 erwähnt wird, ist der "Benutzer" eines Core-Layer-Fehlers typischerweise ein anderer Entwickler, der diese Schicht verwendet.

**\#\[from\]-Annotationen:**

* Das \#\[from\]-Attribut wird verwendet, um Fehler von anderen Typen (z.B. std::io::Error, Fehler aus anderen Kernschichtmodulen oder externen Crates) transparent in eine Variante des aktuellen Modul-Fehler-Enums zu konvertieren.  
* Dies ist entscheidend für die ergonomische Fehlerweitergabe mittels des ?-Operators.  
* **Spezifikation**: \#\[from\] ist dann angemessen, wenn ein externer Fehlertyp direkt einer *semantisch eindeutigen* Fehlerbedingung innerhalb des Moduls zugeordnet werden kann. Falls ein externer Fehlertyp aus mehreren unterschiedlichen Operationen innerhalb des Moduls resultieren kann, sind spezifische Varianten zu erstellen, die den Ursprungsfehler mit zusätzlichem Kontext umhüllen (wie im IoError-Beispiel oben, das ein operation-Feld und path-Feld enthält). Dies vermeidet Ambiguität und stellt sicher, dass der Fehlertyp selbst bereits maximalen Kontext liefert.

**Kontextuelle Informationen:**

* Fehlervarianten müssen Felder enthalten, die relevante kontextuelle Informationen zum Zeitpunkt der Fehlererzeugung erfassen (z.B. Dateipfade, betroffene Werte, Operationsnamen). Dies unterstützt die Forderung nach einem "vollständigen Kontext-Stack" für Debugging-Zwecke.1

**Tabelle: Übersicht der Kernmodul-Fehler-Enums (Auszug)**

| Modulpfad | Fehler-Enum-Name | Schlüssekvarianten (illustrativ) | Primäre \#\[from\] Quellen (Beispiele) |
| :---- | :---- | :---- | :---- |
| core::config | ConfigError | FileReadError, DeserializationError, MissingKeyError | std::io::Error, serde\_toml::de::Error |
| core::utils::json | JsonUtilError | SerializationError, DeserializationError | serde\_json::Error |
| core::ipc | IpcError | ConnectionFailed, MessageSendError, ResponseTimeout | zbus::Error (falls zbus verwendet wird) |
| core::types::color | ColorParseError | InvalidHexFormat, InvalidHexDigit | std::num::ParseIntError |

*Begründung für den Wert der Tabelle*:

1. **Auffindbarkeit**: Bietet Entwicklern einen schnellen Überblick über alle benutzerdefinierten Fehlertypen innerhalb der Kernschicht.  
2. **Konsistenz**: Fördert einen standardisierten Ansatz für die Benennung und Strukturierung von Fehler-Enums über Module hinweg.  
3. **Modulübergreifendes Verständnis**: Hilft Entwicklern zu verstehen, welche Arten von Fehlern beim Aufruf von Funktionen aus verschiedenen Kernmodulen zu erwarten sind, was eine bessere Fehlerbehandlung im aufrufenden Code ermöglicht.  
4. **Wartung**: Dient als Checkliste bei Code-Reviews, um sicherzustellen, dass neue Module ihre Fehlertypen gemäß den Projektspezifikationen korrekt definiert haben.

### **2.4. Fehlerweitergabe, \-konvertierung und \-verkettung**

* **?-Operator**: Die Verwendung des ?-Operators ist für die Weitergabe von Result-Fehlern den Aufrufstack hinauf verbindlich vorgeschrieben. Dies ist idiomatisches Rust und verbessert die Lesbarkeit des Codes erheblich.  
* **\#\[from\] zur Konvertierung**: Wie oben detailliert, ist \#\[from\] (bereitgestellt durch thiserror) der primäre Mechanismus zur Konvertierung eines Fehlertyps in einen anderen, was die Nutzung von ? erleichtert.  
* **source()-Verkettung**: Es ist sicherzustellen, dass das \#\[source\]-Attribut von thiserror auf dem Feld verwendet wird, das den zugrundeliegenden Fehler enthält. Dies ermöglicht es Konsumenten, die vollständige Fehlerkette über std::error::Error::source() zu inspizieren, was für das Debugging komplexer Probleme, die sich über mehrere Module oder Operationen erstrecken, unerlässlich ist.3 Die source()-Kette ist das programmatische Äquivalent des in 1 erwähnten "virtuellen Benutzer-Stacks". Jede Ebene der source()-Aufrufe enthüllt eine tiefere Ursache des Fehlers. Wenn ein Fehler E1 einen Ursprungsfehler E2 (der wiederum E3 usw. wrappen könnte) umschließt, rekonstruiert die Iteration durch e1.source(), dann e1.source().unwrap().source() usw. effektiv die kausale Fehlerkette. Diese Kette liefert den "vollständigen Kontext-Stack", indem sie zeigt, wie sich ein Low-Level-Fehler durch verschiedene Abstraktionsschichten fortgepflanzt und transformiert hat. Daher ist die konsistente und korrekte Verwendung von \#\[source\] für die Erreichung der Debugging-Ziele von entscheidender Bedeutung.

### **2.5. Fehlerkontext und entwicklerorientiertes Reporting**

* **Hinzufügen von Kontext**: Über die \#\[error(...)\]-Nachricht hinaus müssen Funktionen, die Result zurückgeben, sicherstellen, dass die von ihnen konstruierten Fehlerwerte genügend Informationen enthalten, damit ein Entwickler den Zustand verstehen kann, der zum Fehler geführt hat. Dies bedeutet oft, Fehlervarianten mit spezifischen Feldern zu erstellen, die diesen Zustand erfassen.  
* **Integration mit core::logging**: Wenn ein Fehler behandelt wird (d.h. nicht weiter mit ? propagiert wird), sollte er typischerweise mit der core::logging-Infrastruktur (siehe Abschnitt 3\) protokolliert werden. Der Log-Eintrag sollte die vollständigen Fehlerinformationen enthalten, oft durch Protokollierung der Debug-Repräsentation des Fehlers, die die source-Kette einschließt.  
  * Beispiel: tracing::error\!(error \=?e, "Kritische Operation X fehlgeschlagen");  
* **Keine sensiblen Daten**: Es wird die strikte Richtlinie wiederholt: Fehlermeldungen und protokollierte Fehlerdetails dürfen *niemals* Passwörter, API-Schlüssel, personenbezogene Daten (PII) oder andere sensible Informationen enthalten. Redaktion oder Auslassung ist erforderlich, wenn solche Daten peripher an einer Fehlerbedingung beteiligt sind.

### **2.6. Panic-Strategie (Core Layer Spezifika)**

Panics signalisieren nicht behebbare Fehler, die typischerweise auf Programmierfehler hinweisen.4 Ihre Verwendung in der Kernschicht muss streng kontrolliert werden.

* **Verbot in Bibliothekscode**: Panics (unwrap(), expect(), panic\!) sind in Code der Kernschicht, der für die allgemeine Nutzung durch andere Schichten vorgesehen ist, strikt verboten. Funktionen und Methoden müssen für alle fehleranfälligen Operationen Result zurückgeben.  
* **Zulässige Verwendungen**:  
  * **Nicht behebbare Initialisierung**: In den frühesten Phasen des Anwendungsstarts, wenn eine fundamentale Ressource nicht initialisiert werden kann und die Anwendung unmöglich fortfahren kann (z.B. eine kritische Konfigurationsdatei ist fehlerhaft und es gibt keine Standardwerte), kann ein Panic als letztes Mittel akzeptabel sein.  
  * **Tests**: unwrap() und expect() sind in Testcode zulässig und oft idiomatisch, um Bedingungen zu assertieren, die *unbedingt* gelten müssen.  
  * **Interne Invarianten**: In seltenen Fällen kann expect() verwendet werden, um eine interne Invariante zu assertieren, die logischerweise *niemals* verletzt werden sollte. Wenn sie es doch wird, deutet dies auf einen Fehler in der Kernschicht selbst hin.  
* **expect()-Nachrichtenstil**: Wenn expect() in den zulässigen Szenarien verwendet wird, *muss* die Nachricht dem Stil "expect as precondition" (Erwartung als Vorbedingung) folgen.4 Die Nachricht sollte beschreiben, *warum* erwartet wurde, dass die Operation erfolgreich ist, und nicht nur den Fehler wiederholen.  
  * Beispiel: let config\_value \= map.get("critical\_key").expect("critical\_key sollte in der beim Start geladenen Standardkonfiguration vorhanden sein"); Der Stil "expect as precondition" ist dem Stil "expect as error message" überlegen, da er dem Entwickler, der den Panic debuggt, neue Informationen hinzufügt.4 Er erklärt die verletzte Annahme, während "expect as error message" oft nur wiederholt, was der zugrundeliegende Fehler bereits aussagt (z.B. Panic-Nachricht: "...ist nicht gesetzt: Nicht vorhanden"). Durch die Fokussierung auf das, was hätte wahr sein *sollen*, wird der Kontext über den beabsichtigten Zustand und die Annahmen des Programms verdeutlicht. Dies erleichtert das Debugging, da es unmittelbar auf eine fehlerhafte Annahme oder einen Fehler in einem vorangegangenen Schritt hinweist, der diese Vorbedingung hätte herstellen sollen. Für die Kernschicht, wo Robustheit und Klarheit an erster Stelle stehen, verbessert die Durchsetzung dieses Stils für die seltenen Fälle von expect() die Wartbarkeit und Fehlerdiagnose.

## **3\. Core Logging Infrastruktur Spezifikation (core::logging)**

Diese Sektion definiert die standardisierte Logging-Infrastruktur für die gesamte Desktop-Umgebung, basierend auf der tracing-Crate, wie in der Gesamtarchitektur (Abschnitt 4.4) festgelegt. Das Modul core::logging wird Initialisierungsroutinen und potenziell gemeinsame Logging-Makros oder Hilfsfunktionen bereitstellen, obwohl die Makros von tracing selbst in der Regel ausreichend sind.

### **3.1. tracing Framework Integrationsdetails**

* **Initialisierung**:  
  * Eine dedizierte Funktion, z.B. pub fn initialize\_logging(level\_filter: tracing::LevelFilter, format: LogFormatEnum) \-\> Result\<(), LoggingError\>, muss bereitgestellt werden. Diese Funktion wird sehr früh im Anwendungslebenszyklus aufgerufen (z.B. in main.rs).  
  * Sie konfiguriert einen globalen Standard tracing\_subscriber.  
  * LogFormatEnum könnte Varianten wie PlainTextDevelopment, JsonProduction definieren.  
  * LoggingError wäre ein Enum, das mit thiserror im Modul core::logging definiert wird (z.B. für Fehler beim Setzen des globalen Subscribers).  
* **Subscriber-Konfiguration**:  
  * Für Entwicklungs-Builds (LogFormatEnum::PlainTextDevelopment): tracing\_subscriber::fmt() mit with\_ansi(true) (falls Terminal es unterstützt), with\_target(true) (zeigt Modulpfad), with\_file(true), with\_line\_number(true) und dem übergebenen level\_filter. Dies liefert eine reichhaltige, menschenlesbare Ausgabe.  
  * Für Release-Builds (LogFormatEnum::JsonProduction): Es wird ein strukturiertes Format wie JSON empfohlen, um die Log-Aggregation und maschinelle Analyse zu erleichtern.2 Dies kann über tracing\_subscriber::fmt::json() oder spezialisierte Formatter wie tracing-bunyan-formatter erreicht werden. Die Wahl des Formats kann ein Argument für initialize\_logging sein.  
* **Dynamische Log-Level-Änderungen**: Obwohl keine V1-Anforderung für core::logging selbst, sollte das Subscriber-Setup im Hinblick auf mögliche zukünftige Anforderungen an dynamische Log-Level-Anpassungen (z.B. über ein D-Bus-Signal oder Neuladen einer Konfigurationsdatei) gestaltet sein. tracing\_subscriber::filter::EnvFilter oder benutzerdefinierte Filter-Implementierungen können dies unterstützen. EnvFilter erlaubt es, den Log-Level über eine Umgebungsvariable (z.B. RUST\_LOG) zu steuern.

### **3.2. Standardisierte Log-Makros und tracing::instrument Verwendung**

* **Standard-Makros**: Die direkte Verwendung der tracing-Makros (trace\!, debug\!, info\!, warn\!, error\!) ist verbindlich vorgeschrieben.  
* **Log-Nachrichtenstruktur**:  
  * Nachrichten sollten prägnant und beschreibend sein.  
  * Für strukturierte Daten sind Schlüssel-Wert-Paare zu verwenden: tracing::info\!(user\_id \= %user.id, action \= "login", "Benutzer hat sich angemeldet"); (Verwendung von % für Display-Implementierungen, ? für Debug).  
  * Fehler sollten mit dem Feld error protokolliert werden: tracing::error\!(error \=?err, "Anfrage konnte nicht verarbeitet werden");. Das ?-Zeichen stellt sicher, dass die Debug-Repräsentation des Fehlers (einschließlich der source-Kette) erfasst wird.  
* **\#\[tracing::instrument\] Verwendung**:  
  * **Zweck**: Erzeugt Spans für Funktionen oder Codeblöcke, die kontextuelle Informationen (einschließlich Timing) liefern und nachfolgende Log-Ereignisse innerhalb dieses Spans gruppieren.  
  * **Richtlinien**:  
    * Anwendung auf öffentliche API-Funktionen signifikanter Module, insbesondere solche, die I/O oder komplexe Berechnungen beinhalten.  
    * Anwendung auf Funktionen, die abgeschlossene operative Einheiten oder Phasen in einem Prozess darstellen.  
    * Verwendung von skip(...) oder skip\_all, um die Protokollierung sensibler oder übermäßig ausführlicher Argumente zu vermeiden.  
    * Verwendung von fields(...), um dem Span spezifischen Kontext hinzuzufügen, z.B. \#\[tracing::instrument(fields(entity.id \= %entity.id))\].  
    * Die Option err kann verwendet werden, um Fehler automatisch auf dem ERROR-Level zu erfassen, wenn die instrumentierte Funktion ein Result::Err zurückgibt: \#\[tracing::instrument(err)\].  
    * Das level Attribut kann verwendet werden, um das Level des Spans selbst zu steuern (z.B. \#\[tracing::instrument(level \= "debug")\]).

**Tabelle: tracing::instrument Verwendungsmuster**

| Szenario | \#\[tracing::instrument\] Attribute | Begründung |
| :---- | :---- | :---- |
| Öffentlicher API-Einstiegspunkt | level \= "debug" (oder info für sehr wichtige APIs) | Nachverfolgung aller Aufrufe öffentlicher APIs für Audit- und Debugging-Zwecke. |
| I/O-Operation (z.B. Datei lesen) | fields(path \= %file\_path.display()), err | Kontextualisierung der Operation mit relevanten Daten (Dateipfad) und automatische Fehlerprotokollierung. |
| Komplexe Berechnung | skip\_all (falls Argumente groß/komplex), fields(param\_count \= args.len()) | Vermeidung der Protokollierung großer Datenstrukturen, aber Erfassung von Metadaten über die Eingabe. |
| Ereignisbehandlung | fields(event.type \= %event.kind()) | Verknüpfung von Log-Einträgen mit spezifischen Ereignistypen für eine einfachere Analyse. |
| Funktion mit sensiblen Argumenten | skip(password, api\_key) oder skip\_all | Sicherstellung, dass keine sensiblen Daten versehentlich protokolliert werden. |

*Begründung für den Wert der Tabelle*:

1. **Konsistenz**: Stellt sicher, dass \#\[tracing::instrument\] einheitlich und effektiv im gesamten Code verwendet wird.  
2. **Performance-Bewusstsein**: Leitet Entwickler an, wann und wie skip verwendet werden sollte, um Performance-Overhead durch übermäßige Protokollierung von Argumenten zu vermeiden.  
3. **Debuggabilität**: Fördert die Erstellung gut definierter Spans, die das Verständnis des Kontrollflusses und die Diagnose von Problemen in verteilten oder asynchronen Operationen erheblich erleichtern.  
4. **Best Practices**: Kodifiziert bewährte Verfahren für die Instrumentierung verschiedener Arten von Funktionen und reduziert das Rätselraten für Entwickler.

### **3.3. Log-Daten Sensibilität und Redaktionsrichtlinie**

* **Striktes Verbot**: Absolut keine sensiblen Daten (Passwörter, API-Schlüssel, PII, Finanzdetails, Gesundheitsinformationen usw.) dürfen im Klartext protokolliert werden.  
* **Redaktion/Auslassung**: Wenn auf eine Variable, die sensible Daten enthält, Bezug genommen werden *muss* (z.B. wegen ihrer Existenz oder ihres Typs), sollte sie redigiert (z.B. password: "\*\*\*") oder vollständig aus den Log-Feldern entfernt werden.  
* **Debug-Trait-Bewusstsein**: Vorsicht ist geboten beim Ableiten von Debug für Strukturen, die sensible Informationen enthalten. Wenn solche Strukturen über ? protokolliert werden (z.B. error \=?sensitive\_struct), muss ihre Debug-Implementierung eine Redaktion durchführen. Benutzerdefinierte Debug-Implementierungen oder Wrapper-Typen, die die Redaktion handhaben, sind in Betracht zu ziehen.  
* **\#\[tracing::instrument(skip\_all)\]**: Ein primäres Werkzeug, um die versehentliche Protokollierung aller Funktionsargumente zu verhindern. Selektive fields können dann wieder hinzugefügt werden.

Die Verantwortung für die Datensensibilität in Logs ist verteilt. Während core::logging den Mechanismus bereitstellt, muss jedes Modul und jeder Entwickler, der Logging-Anweisungen schreibt oder Debug ableitet, wachsam sein. Das tracing-Framework protokolliert Daten basierend auf dem, was Entwickler in Makros bereitstellen oder was Debug-Implementierungen ausgeben. \#\[tracing::instrument\] kann Funktionsargumente automatisch protokollieren, wenn sie nicht übersprungen werden. Eine zentrale Logging-Richtlinie (wie "keine sensiblen Daten") ist unerlässlich. Das Modul core::logging selbst kann diese Richtlinie jedoch nicht für den *Inhalt* der Logs erzwingen; es stellt nur die Infrastruktur bereit. Daher muss die Richtlinie von den Entwicklern im gesamten Code durch sorgfältige Logging-Praktiken, skip-Attribute und gegebenenfalls benutzerdefinierte Debug-Implementierungen aktiv umgesetzt werden. Dies impliziert die Notwendigkeit von Entwicklerschulungen und Code-Review-Checklisten, die sich auf die Sensibilität von Log-Daten konzentrieren.

## **4\. Core Konfigurationsprimitive Spezifikation (core::config)**

Dieser Abschnitt definiert, wie die Kernschicht und nachfolgend andere Schichten grundlegende Konfigurationseinstellungen laden, parsen und darauf zugreifen. Der Fokus liegt auf Einfachheit, Robustheit und der Einhaltung von XDG-Standards, wo dies für benutzerspezifische Überschreibungen relevant ist (obwohl Konfigurationen der Kernschicht wahrscheinlich systemweit oder Standardeinstellungen sind).

### **4.1. Konfigurationsdateiformat(e) und Parsing-Logik**

* **Format**: TOML (Tom's Obvious, Minimal Language) wird aufgrund seiner guten Lesbarkeit für Menschen und der einfachen Verarbeitung durch Maschinen ausgewählt.  
* **Parsing-Bibliothek**: Das serde-Framework in Verbindung mit der toml-Crate (serde\_toml) wird für die Deserialisierung verwendet.  
* **Ladelogik**:  
  1. Definition von Standard-Konfigurationspfaden (z.B. /usr/share/YOUR\_DESKTOP\_ENV\_NAME/core.toml für Systemstandards, /etc/YOUR\_DESKTOP\_ENV\_NAME/core.toml für systemweite Überschreibungen, und potenziell ein Pfad für Entwicklungstests, z.B. relativ zum Projekt-Root). Die XDG Base Directory Specification ($XDG\_CONFIG\_DIRS, $XDG\_CONFIG\_HOME) sollte für benutzerspezifische Konfigurationen in höheren Schichten berücksichtigt werden, ist aber für core.toml (als Basiskonfiguration) möglicherweise weniger relevant, wenn es sich um reine Systemstandards handelt.  
  2. Eine Funktion wie pub fn load\_core\_config(custom\_path: Option\<PathBuf\>) \-\> Result\<CoreConfig, ConfigError\> wird verantwortlich sein. Sie würde eine definierte Suchreihenfolge für Konfigurationsdateien implementieren (z.B. custom\_path falls gegeben, dann Entwicklungspfad, dann Systempfade).  
  3. Sie versucht, den Inhalt der TOML-Datei vom ersten gefundenen Pfad zu lesen.  
  4. Verwendet serde\_toml::from\_str() zur Deserialisierung des Inhalts in die CoreConfig-Struktur.  
  5. Behandelt I/O-Fehler (Datei nicht gefunden, Zugriff verweigert) und Parsing-Fehler (fehlerhaftes TOML, Typ-Inkonsistenzen) und konvertiert sie in entsprechende Varianten von core::config::ConfigError.  
* **Fehlerbehandlung**: Ein core::config::ConfigError-Enum (unter Verwendung von thiserror) wird definiert, mit Varianten wie:  
  Rust  
  use std::path::PathBuf;  
  use thiserror::Error;

  \#  
  pub enum ConfigError {  
      \#\[error("Fehler beim Lesen der Konfigurationsdatei '{path:?}': {source}")\]  
      FileReadError {  
          path: PathBuf,  
          \#\[source\]  
          source: std::io::Error,  
      },  
      \#\[error("Fehler beim Parsen der Konfigurationsdatei '{path:?}': {source}")\]  
      DeserializationError {  
          path: PathBuf,  
          \#\[source\]  
          source: serde\_toml::de::Error,  
      },  
      \#\[error("Keine Konfigurationsdatei gefunden an den geprüften Pfaden: {checked\_paths:?}")\]  
      NoConfigurationFileFound { checked\_paths: Vec\<PathBuf\> },  
      // Ggf. weitere Varianten für Validierungsfehler, falls nicht in Deserialisierung abgedeckt  
  }

### **4.2. Konfigurationsdatenstrukturen (Ultra-Fein)**

* **CoreConfig-Struktur**: Eine primäre Struktur, z.B. CoreConfig, wird in core::config definiert, um alle spezifischen Konfigurationen der Kernschicht zu halten.  
  Rust  
  use serde::Deserialize;  
  use std::path::PathBuf; // Beispiel für einen komplexeren Typ

  // Beispiel für ein Enum, das in der Konfiguration verwendet wird  
  \#  
  \#\[serde(rename\_all \= "lowercase")\] // Erlaubt "info", "debug" etc. in TOML  
  pub enum LogLevelConfig {  
      Trace,  
      Debug,  
      Info,  
      Warn,  
      Error,  
  }

  impl Default for LogLevelConfig {  
      fn default() \-\> Self { LogLevelConfig::Info }  
  }

  \#  
  \#\[serde(deny\_unknown\_fields)\] // Strikte Prüfung auf unbekannte Felder  
  pub struct CoreConfig {  
      \#\[serde(default \= "default\_log\_level")\]  
      pub log\_level: LogLevelConfig,

      \#\[serde(default \= "default\_feature\_flags")\]  
      pub feature\_flags: FeatureFlags,

      \#\[serde(default)\] // Verwendet FeatureXConfig::default()  
      pub feature\_x\_config: FeatureXConfig,

      \#\[serde(default \= "default\_some\_path")\]  
      pub some\_critical\_path: PathBuf,  
  }

  fn default\_log\_level() \-\> LogLevelConfig { LogLevelConfig::default() }  
  fn default\_feature\_flags() \-\> FeatureFlags { FeatureFlags::default() }  
  fn default\_some\_path() \-\> PathBuf { PathBuf::from("/usr/share/YOUR\_DESKTOP\_ENV\_NAME/default\_resource") }

  impl Default for CoreConfig {  
      fn default() \-\> Self {  
          Self {  
              log\_level: default\_log\_level(),  
              feature\_flags: default\_feature\_flags(),  
              feature\_x\_config: FeatureXConfig::default(),  
              some\_critical\_path: default\_some\_path(),  
          }  
      }  
  }

  \#  
  \#\[serde(deny\_unknown\_fields)\]  
  pub struct FeatureFlags {  
      \#\[serde(default)\] // bool-Felder standardmäßig auf false  
      pub enable\_alpha\_feature: bool,  
      \#\[serde(default \= "default\_beta\_timeout\_ms")\]  
      pub beta\_feature\_timeout\_ms: u64,  
  }

  fn default\_beta\_timeout\_ms() \-\> u64 { 1000 }

  \#  
  \#\[serde(deny\_unknown\_fields)\]  
  pub struct FeatureXConfig {  
      \#\[serde(default \= "default\_retries")\]  
      pub retries: u32,  
      \#\[serde(default)\]  
      pub some\_string\_option: Option\<String\>,  
  }

  fn default\_retries() \-\> u32 { 3 }

  impl Default for FeatureXConfig {  
      fn default() \-\> Self {  
          Self {  
              retries: default\_retries(),  
              some\_string\_option: None,  
          }  
      }  
  }

* **Felder**: Alle Felder müssen explizit definierte Typen haben.  
* **serde::Deserialize**: Die Struktur und ihre verschachtelten Strukturen müssen Deserialize ableiten.  
* **\#\[serde(default \= "path")\]**: Wird umfassend verwendet, um Standardwerte für fehlende Felder in der TOML-Datei bereitzustellen, was die Robustheit erhöht. Die referenzierte Funktion muss den Typ des Feldes zurückgeben. Für Felder, deren Typ Default implementiert, kann auch \#\[serde(default)\] verwendet werden.  
* **\#\[serde(deny\_unknown\_fields)\]**: Wird erzwungen, um zu verhindern, dass Tippfehler oder nicht erkannte Felder in Konfigurationsdateien stillschweigend ignoriert werden.  
* **Validierung**:  
  * Grundlegende Validierung kann durch Typen erfolgen (z.B. u32 für eine Anzahl).  
  * Komplexere Validierungen (z.B. log\_level muss ein gültiger Wert sein, was hier durch das LogLevelConfig-Enum und serde(rename\_all \= "lowercase") bereits gut gehandhabt wird) sollten *nach* der Deserialisierung durchgeführt werden. Dies kann entweder in einem TryFrom\<CoreConfigRaw\>-Muster geschehen, bei dem CoreConfigRaw die deserialisierte Struktur ohne komplexe Validierung ist und CoreConfig die validierte Version, oder durch eine dedizierte validate()-Methode auf CoreConfig, die ein Result\<(), ConfigError\> zurückgibt. Für die Kernschicht kann die initiale Validierung auf die Fähigkeiten von serde und Typbeschränkungen beschränkt sein. Komplexere, semantische Validierungen können bei Bedarf in höheren Schichten oder durch benutzerdefinierte Deserialisierungsfunktionen mit \#\[serde(deserialize\_with \= "...")\] hinzugefügt werden.  
* **Invarianten**: Als Kommentare dokumentiert oder durch Validierungslogik erzwungen (z.B. timeout\_ms \> 0).

**Tabelle: Definitionen der Core-Konfigurationsparameter (Auszug)**

| Parameterpfad | Typ | serde Default-Funktion/Wert | Validierungsregeln (Beispiele) | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| log\_level | LogLevelConfig | default\_log\_level() | Muss einer der Enum-Werte sein (implizit durch Deserialize) | Globaler Standard-Log-Level für die Anwendung. |
| feature\_flags.enable\_alpha\_feature | bool | false (implizit) | \- | Schaltet ein experimentelles Alpha-Feature ein oder aus. |
| feature\_flags.beta\_feature\_timeout\_ms | u64 | default\_beta\_timeout\_ms() | Muss \>= 0 sein (implizit durch u64) | Timeout-Wert in Millisekunden für ein Beta-Feature. |
| feature\_x\_config.retries | u32 | default\_retries() | Muss \>= 0 sein (implizit durch u32) | Anzahl der Wiederholungsversuche für eine bestimmte Operation in Feature X. |
| some\_critical\_path | PathBuf | default\_some\_path() | Pfad sollte idealerweise existieren (Laufzeitprüfung nötig) | Pfad zu einer kritischen Ressource. |

*Begründung für den Wert der Tabelle*:

1. **Klarheit**: Bietet eine einzige, maßgebliche Referenz für alle verfügbaren Kernkonfigurationen, ihre Typen und Standardwerte.  
2. **Dokumentation**: Unerlässlich für Benutzer/Administratoren, die diese Kerneinstellungen möglicherweise anpassen müssen.  
3. **Entwicklungshilfe**: Hilft Entwicklern, die verfügbaren Konfigurationen zu verstehen und neue konsistent hinzuzufügen.  
4. **Validierungsreferenz**: Zentralisiert die Definition gültiger Werte und Bereiche und unterstützt sowohl die automatisierte Validierung als auch die manuelle Konfiguration.

### **4.3. Konfigurationszugriffs-API**

* **Globaler Zugriff**: Die geladene CoreConfig-Instanz sollte so gespeichert werden, dass sie im gesamten Anwendungskontext effizient zugänglich ist. Hierfür wird eine threadsichere statische Variable verwendet, typischerweise mittels once\_cell::sync::OnceCell.  
  Rust  
  // In core::config  
  use once\_cell::sync::OnceCell;  
  //... CoreConfig Strukturendefinition und andere...

  static CORE\_CONFIG: OnceCell\<CoreConfig\> \= OnceCell::new();

  /// Initialisiert die globale Core-Konfiguration.  
  /// Darf nur einmal während des Anwendungsstarts aufgerufen werden.  
  ///  
  /// \# Errors  
  ///  
  /// Gibt einen Fehler zurück, wenn die Konfiguration bereits initialisiert wurde.  
  pub fn initialize\_core\_config(config: CoreConfig) \-\> Result\<(), CoreConfig\> {  
      CORE\_CONFIG.set(config)  
  }

  /// Gibt eine Referenz auf die global initialisierte Core-Konfiguration zurück.  
  ///  
  /// \# Panics  
  ///  
  /// Paniert, wenn \`initialize\_core\_config()\` nicht zuvor erfolgreich aufgerufen wurde.  
  /// Dies signalisiert einen schwerwiegenden Programmierfehler in der Anwendungsinitialisierung.  
  pub fn get\_core\_config() \-\> &'static CoreConfig {  
      CORE\_CONFIG.get().expect("CoreConfig wurde nicht initialisiert. initialize\_core\_config() muss zuerst aufgerufen werden.")  
  }  
  Das expect im get\_core\_config() ist hier vertretbar, da es einen Programmierfehler darstellt: der Versuch, auf die Konfiguration zuzugreifen, bevor sie geladen wurde, was ein fatales Setup-Problem ist und nicht zur Laufzeit normal behandelt werden kann.  
* **Zugriffsmethoden**: Einfache Getter-Funktionen oder direkter Feldzugriff auf die abgerufene &'static CoreConfig-Instanz.  
* **Thread-Sicherheit**: Der gewählte statische Speichermechanismus (OnceCell) gewährleistet eine threadsichere Initialisierung und einen threadsicheren Zugriff. Die CoreConfig-Struktur selbst sollte Send \+ Sync sein (was sie typischerweise ist, wenn ihre Felder dies sind). Clone wird abgeleitet für Fälle, in denen Teile der Konfiguration herumgereicht oder in einem lokalen Kontext modifiziert werden müssen, ohne den globalen Zustand zu beeinflussen.  
* **Immutabilität**: Die global zugängliche Konfiguration sollte nach der Initialisierung unveränderlich sein, um Laufzeitinkonsistenzen zu vermeiden. Wenn dynamische Konfigurationsaktualisierungen erforderlich sind, würde dies einen komplexeren Mechanismus erfordern (z.B. mit RwLock und einem dedizierten Aktualisierungsprozess), der außerhalb des Rahmens dieser initialen Kernschichtspezifikation liegt, aber architektonisch für zukünftige Erweiterbarkeit berücksichtigt werden sollte.

Die Ableitung von Clone für CoreConfig ermöglicht es Komponenten, bei Bedarf eine Momentaufnahme der Konfiguration zu einem bestimmten Zeitpunkt zu erstellen oder für Testzwecke. Der primäre Zugriff sollte jedoch über die statische Referenz erfolgen, um sicherzustellen, dass alle Teile des Systems denselben konsistenten Konfigurationszustand verwenden. Beispielsweise könnte eine langlaufende Aufgabe den relevanten Teil der Konfiguration bei ihrem Start klonen, um sicherzustellen, dass sie während ihrer gesamten Lebensdauer mit konsistenten Einstellungen arbeitet, selbst wenn später ein globaler Mechanismus zum Neuladen der Konfiguration eingeführt würde.

## **5\. Core Utilities Spezifikation (core::utils) (Ausgewählte kritische Utilities)**

Das Modul core::utils wird allgemeine Hilfsfunktionen und kleine, in sich geschlossene Utilities beherbergen, die nicht in spezifischere Module wie types oder config passen, aber über mehrere Teile der Kernschicht oder von anderen Schichten verwendet werden. Nur Utilities mit nicht-trivialer Logik oder spezifischen Designentscheidungen rechtfertigen hier eine detaillierte Spezifikation. Einfache Einzeiler-Helfer tun dies nicht.  
Für die initiale Kernschicht wird davon ausgegangen, dass keine hochkomplexen, neuartigen Utilities identifiziert wurden, die eine tiefergehende Spezifikation erfordern. Sollte sich dies ändern (z.B. ein benutzerdefinierter ID-Generator, ein spezialisierter String-Interner oder eine komplexe Pfad-Normalisierungsroutine), würde die Spezifikation dem untenstehenden Muster folgen.

* **5.X.1. Utility:**  
  * **Zweck, Begründung und Designentscheidungen**: (z.B. "Stellt ein robustes, plattformübergreifendes Dienstprogramm zur Pfadnormalisierung bereit, das Symlinks und relative Pfade konsistenter behandelt als Standardbibliotheksfunktionen in spezifischen Grenzfällen, die für die Desktop-Umgebung relevant sind.")  
  * **API**:  
    * **Strukturen/Enums**:  
      Rust  
      // pub struct NormalizedPath { /\*... \*/ }  
      // pub enum NormalizationError { /\*... \*/ } // Verwendet thiserror

    * **Methoden**:  
      Rust  
      // impl ComplexPathNormalizer {  
      //     pub fn new(/\*... \*/) \-\> Self;  
      //     pub fn normalize(base: \&Path, input: \&Path) \-\> Result\<NormalizedPath, NormalizationError\>;  
      // }  
      Vollständige Signaturen: fn normalize(base: \&std::path::Path, input: \&std::path::Path) \-\> Result\<NormalizedPath, NormalizationError\>; (Rusts noexcept ist implizit für Funktionen, die nicht unsafe deklariert sind und nicht paniken; die explizite Erwähnung der Panic-Vermeidung ist jedoch entscheidend).  
  * **Interne Algorithmen**: (Schritt-für-Schritt-Logik für komplexe Teile, z.B. Symlink-Auflösungsschleife, Behandlung von ..).  
  * **Fehlerbedingungen**: Abbildung auf NormalizationError-Varianten (z.B. PathNotFound, MaxSymlinkDepthExceeded).  
  * **Invarianten, Vorbedingungen, Nachbedingungen**: (z.B. "Eingabepfad muss für bestimmte Operationen existieren", "Zurückgegebener Pfad ist absolut und frei von . oder .. Komponenten").  
* **Allgemeine Richtlinien für core::utils:**  
  * **Geltungsbereich**: Utilities müssen wirklich allgemeiner Natur sein. Wenn ein Utility nur von einem anderen Modul verwendet wird, sollte es wahrscheinlich innerhalb dieses Moduls angesiedelt sein.  
  * **Einfachheit**: Einfache Funktionen sind komplexen Strukturen vorzuziehen, es sei denn, Zustand ist wirklich erforderlich.  
  * **Reinheit**: Reine Funktionen sind wo möglich zu bevorzugen (Ausgabe hängt nur von der Eingabe ab, keine Seiteneffekte).  
  * **Fehlerbehandlung**: Jede fehleranfällige Utility-Funktion muss Result\<T, YourUtilError\> zurückgeben, wobei YourUtilError unter Verwendung von thiserror innerhalb des Submoduls des Utilities definiert wird (z.B. core::utils::path\_utils::Error).  
  * **Dokumentation**: Alle öffentlichen Utilities müssen umfassende rustdoc-Kommentare haben, einschließlich Beispielen.  
  * **Tests**: Gründliche Unit-Tests sind für alle Utilities zwingend erforderlich.

## **6\. Core Datentypen Spezifikation (core::types) (Ausgewählte kritische Datentypen)**

Das Modul core::types definiert fundamentale Datenstrukturen und Enums, die in der gesamten Desktop-Umgebung verwendet werden. Diese unterscheiden sich von Konfigurationsstrukturen und sind eher primitive Bausteine für die Anwendungslogik. Beispiele hierfür sind Point, Size, Rect, Color, ResourceId usw.

### **6.1. Datentyp: RectInt (Integer-basiertes Rechteck)**

* **Zweck und Begründung**: Repräsentiert ein achsenparalleles Rechteck, das durch ganzzahlige Koordinaten und Dimensionen definiert ist. Unerlässlich für Fenstergeometrie, Positionierung von UI-Elementen und pixelbasierte Berechnungen. Die Verwendung von i32 für Koordinaten und u32 für Größen ist üblich für Bildschirmkoordinaten.  
* **Definition**:  
  Rust  
  use serde::{Serialize, Deserialize};

  \#  
  pub struct PointInt {  
      pub x: i32,  
      pub y: i32,  
  }

  impl PointInt {  
      pub const ZERO: Self \= Self { x: 0, y: 0 };

      \#\[must\_use\]  
      pub fn new(x: i32, y: i32) \-\> Self {  
          Self { x, y }  
      }

      // Weitere Methoden wie add, sub, etc. können hier hinzugefügt werden.  
      // pub fn add(self, other: Self) \-\> Self { Self { x: self.x \+ other.x, y: self.y \+ other.y } }  
  }

  \#  
  pub struct SizeInt {  
      pub width: u32,  
      pub height: u32,  
  }

  impl SizeInt {  
      pub const ZERO: Self \= Self { width: 0, height: 0 };

      \#\[must\_use\]  
      pub fn new(width: u32, height: u32) \-\> Self {  
          Self { width, height }  
      }

      \#\[must\_use\]  
      pub fn is\_empty(\&self) \-\> bool {  
          self.width \== 0 |

| self.height \== 0  
}  
}

\#  
pub struct RectInt {  
    pub x: i32,  
    pub y: i32,  
    pub width: u32,  
    pub height: u32,  
}  
\`\`\`

* **Methoden für RectInt**:  
  * pub const fn new(x: i32, y: i32, width: u32, height: u32) \-\> Self: Konstruktor.  
  * \#\[must\_use\] pub fn from\_points(p1: PointInt, p2: PointInt) \-\> Self: Erstellt ein Rechteck, das zwei Punkte umschließt.  
    * Vorbedingung: Keine.  
    * Nachbedingung: x ist min(p1.x, p2.x), y ist min(p1.y, p2.y), width ist abs(p1.x \- p2.x) as u32, height ist abs(p1.y \- p2.y) as u32. Die Umwandlung in u32 ist sicher, da die Differenz absolut ist.  
  * \#\[must\_use\] pub fn top\_left(\&self) \-\> PointInt: Gibt PointInt { x: self.x, y: self.y } zurück.  
  * \#\[must\_use\] pub fn size(\&self) \-\> SizeInt: Gibt SizeInt { width: self.width, height: self.height } zurück.  
  * \#\[must\_use\] pub fn right(\&self) \-\> i32: Gibt self.x.saturating\_add(self.width as i32) zurück. Verwendet saturating\_add um Überlauf zu vermeiden, obwohl dies bei typischen Bildschirmkoordinaten unwahrscheinlich ist.  
  * \#\[must\_use\] pub fn bottom(\&self) \-\> i32: Gibt self.y.saturating\_add(self.height as i32) zurück.  
  * \#\[must\_use\] pub fn contains\_point(\&self, p: PointInt) \-\> bool: Prüft, ob ein Punkt innerhalb des Rechtecks liegt (einschließlich der Ränder).  
    * Logik: p.x \>= self.x && p.x \< self.right() && p.y \>= self.y && p.y \< self.bottom(). Beachten Sie, dass right() und bottom() exklusiv sind.  
  * \#\[must\_use\] pub fn intersects(\&self, other: RectInt) \-\> bool: Prüft, ob dieses Rechteck ein anderes schneidet.  
    * Logik: self.x \< other.right() && self.right() \> other.x && self.y \< other.bottom() && self.bottom() \> other.y.  
  * \#\[must\_use\] pub fn intersection(\&self, other: RectInt) \-\> Option\<RectInt\>: Gibt das Schnittrechteck zurück oder None, wenn sie sich nicht schneiden.  
    * Logik: Berechne x\_intersect \= max(self.x, other.x), y\_intersect \= max(self.y, other.y). Berechne right\_intersect \= min(self.right(), other.right()), bottom\_intersect \= min(self.bottom(), other.bottom()). Wenn right\_intersect \> x\_intersect und bottom\_intersect \> y\_intersect, dann ist das Ergebnis RectInt::new(x\_intersect, y\_intersect, (right\_intersect \- x\_intersect) as u32, (bottom\_intersect \- y\_intersect) as u32). Sonst None.  
  * \#\[must\_use\] pub fn union(\&self, other: RectInt) \-\> RectInt: Gibt das kleinste Rechteck zurück, das beide umschließt.  
    * Logik: x\_union \= min(self.x, other.x), y\_union \= min(self.y, other.y). right\_union \= max(self.right(), other.right()), bottom\_union \= max(self.bottom(), other.bottom()). Ergebnis ist RectInt::new(x\_union, y\_union, (right\_union \- x\_union) as u32, (bottom\_union \- y\_union) as u32).  
  * \#\[must\_use\] pub fn translate(\&self, dx: i32, dy: i32) \-\> RectInt: Gibt ein neues, um (dx, dy) verschobenes Rechteck zurück.  
    * Logik: RectInt::new(self.x.saturating\_add(dx), self.y.saturating\_add(dy), self.width, self.height).  
  * \#\[must\_use\] pub fn inflate(\&self, dw: i32, dh: i32) \-\> RectInt: Gibt ein neues Rechteck zurück, das auf jeder Seite um dw (links/rechts) bzw. dh (oben/unten) erweitert (oder verkleinert, wenn dw, dh negativ sind) wird. Die resultierende Breite/Höhe darf nicht negativ werden.  
    * Logik: new\_x \= self.x.saturating\_sub(dw), new\_y \= self.y.saturating\_sub(dh). new\_width \= (self.width as i64).saturating\_add(2 \* dw as i64), new\_height \= (self.height as i64).saturating\_add(2 \* dh as i64). RectInt::new(new\_x, new\_y, max(0, new\_width) as u32, max(0, new\_height) as u32).  
  * \#\[must\_use\] pub fn is\_empty(\&self) \-\> bool: Gibt self.width \== 0 | | self.height \== 0 zurück.  
* **Invarianten**: width \>= 0, height \>= 0\. (Durch den u32-Typ erzwungen).  
* **Serialisierung**: Leitet Serialize, Deserialize für einfache Verwendung in Konfigurationen oder IPC ab.  
* **Traits**: Debug, Clone, Copy, PartialEq, Eq, Hash, Default.

### **6.2. Datentyp: Color (RGBA Farbrepräsentation)**

* **Zweck und Begründung**: Repräsentiert eine Farbe mit Rot-, Grün-, Blau- und Alpha-Komponenten. Fundamental für Theming, UI-Rendering und Grafik. Die Verwendung von f32 für Komponenten im Bereich \[0.0, 1.0\] ist üblich für Grafikpipelines. GTK4 verwendet intern oft f64, aber f32 bietet einen guten Kompromiss zwischen Präzision und Speicherbedarf und ist weit verbreitet.  
* **Definition**:  
  Rust  
  use serde::{Serialize, Deserialize, Deserializer, Serializer};  
  use thiserror::Error;  
  use std::num::ParseIntError;

  \#  
  pub struct Color {  
      pub r: f32, // Bereich \[0.0, 1.0\]  
      pub g: f32, // Bereich \[0.0, 1.0\]  
      pub b: f32, // Bereich \[0.0, 1.0\]  
      pub a: f32, // Bereich \[0.0, 1.0\]  
  }

  \#  
  pub enum ColorParseError {  
      \#  
      InvalidHexFormat(String),  
      \#\[error("Ungültige Hex-Ziffer in '{0}'")\]  
      InvalidHexDigit(String, \#\[source\] ParseIntError),  
      \#  
      InvalidHexLength(String),  
  }

* **Methoden für Color**:  
  * \#\[must\_use\] pub fn new(r: f32, g: f32, b: f32, a: f32) \-\> Self: Konstruktor. Klemmt Werte auf den Bereich \[0.0, 1.0\].  
    * Implementierung: Self { r: r.clamp(0.0, 1.0), g: g.clamp(0.0, 1.0), b: b.clamp(0.0, 1.0), a: a.clamp(0.0, 1.0) }.  
    * Nachbedingung: 0.0 \<= self.r \<= 1.0, usw.  
  * pub const OPAQUE\_BLACK: Color \= Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 };  
  * pub const OPAQUE\_WHITE: Color \= Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };  
  * pub const TRANSPARENT: Color \= Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };  
  * pub fn from\_hex(hex\_string: \&str) \-\> Result\<Self, ColorParseError\>: Parst aus den Formaten "\#RRGGBB", "\#RGB", "\#RRGGBBAA" oder "\#RGBA".  
    * Logik: String validieren (Präfix \#, Länge), dann entsprechende Paare von Hex-Ziffern parsen, zu u8 konvertieren und dann zu f32 normalisieren (/ 255.0). Für Kurzformate (\#RGB, \#RGBA) Ziffern verdoppeln (z.B. "F" wird zu "FF").  
  * \#\[must\_use\] pub fn to\_hex\_string(\&self, include\_alpha: bool) \-\> String: Konvertiert in einen Hex-String ("\#RRGGBB" oder "\#RRGGBBAA").  
    * Logik: Komponenten mit 255.0 multiplizieren, zu u8 runden/casten, dann als Hex formatieren.  
  * \#\[must\_use\] pub fn with\_alpha(\&self, alpha: f32) \-\> Self: Gibt eine neue Farbe mit dem angegebenen Alpha-Wert zurück (geklemmt).  
  * \#\[must\_use\] pub fn lighten(\&self, amount: f32) \-\> Self: Hellt die Farbe auf. Eine einfache Methode ist, amount zu R, G und B zu addieren und dann zu klemmen. Komplexere Methoden würden im HSL/HSV-Raum arbeiten. Für die Kernschicht ist eine einfache RGB-Aufhellung zunächst ausreichend.  
  * \#\[must\_use\] pub fn darken(\&self, amount: f32) \-\> Self: Dunkelt die Farbe ab (analog zu lighten).  
  * \#\[must\_use\] pub fn interpolate(\&self, other: Color, t: f32) \-\> Self: Lineare Interpolation zwischen dieser Farbe und other. t wird auf \[0.0, 1.0\] geklemmt.  
    * Logik: r \= self.r \* (1.0 \- t) \+ other.r \* t, analog für g, b, a.  
* **Serialisierung**: Color soll Serialize und Deserialize implementieren, um als Hex-String in Konfigurationsdateien (z.B. TOML, JSON) dargestellt zu werden. Dies macht Konfigurationen (z.B. für Theming) wesentlich benutzerfreundlicher.  
  Rust  
  impl Serialize for Color {  
      fn serialize\<S\>(\&self, serializer: S) \-\> Result\<S::Ok, S::Error\>  
      where  
          S: Serializer,  
      {  
          serializer.serialize\_str(\&self.to\_hex\_string(true)) // Immer mit Alpha serialisieren für Konsistenz  
      }  
  }

  impl\<'de\> Deserialize\<'de\> for Color {  
      fn deserialize\<D\>(deserializer: D) \-\> Result\<Self, D::Error\>  
      where  
          D: Deserializer\<'de\>,  
      {  
          let s \= String::deserialize(deserializer)?;  
          Color::from\_hex(\&s).map\_err(serde::de::Error::custom)  
      }  
  }  
  Die Verwendung von serde(try\_from \= "String", into \= "String") ist eine Alternative, erfordert aber die Implementierung von TryFrom\<String\> for Color und From\<Color\> for String. Der oben gezeigte Weg mit manueller Implementierung von Serialize und Deserialize gibt volle Kontrolle. Die Möglichkeit, Farben als Hex-Codes ("\#CC331A") anstelle von Arrays von Fließkommazahlen (\[0.8, 0.2, 0.1, 1.0\]) in Konfigurationsdateien anzugeben, ist ein erheblicher Gewinn für die Benutzerfreundlichkeit, sowohl für Entwickler (bei der Erstellung von Standardkonfigurationen) als auch für Endbenutzer (bei der Anpassung von Themes). Dies erfordert eine robuste ColorParseError-Behandlung, um ungültige Hex-Strings abzufangen.  
* **Traits**: Debug, Clone, Copy, PartialEq, Default (kann auf OPAQUE\_BLACK oder TRANSPARENT gesetzt werden, OPAQUE\_BLACK ist eine gängige Wahl).

## **7\. Schlussfolgerung und Schichtübergreifende Integrationsrichtlinien (Fokus Kerninfrastruktur)**

* **Zusammenfassung der Kerninfrastruktur**: Dieser Teil der Spezifikation hat die fundamentalen Elemente der Kernschicht detailliert beschrieben: ein robustes Fehlerbehandlungsframework (core::errors) basierend auf thiserror und modul-spezifischen Enums; ein strukturiertes Logging-System (core::logging) unter Verwendung von tracing; Primitive für das Laden und den Zugriff auf Konfigurationen (core::config) über TOML und serde; sowie Definitionen für essentielle gemeinsame Datentypen (core::types) wie RectInt und Color. Diese Komponenten sind darauf ausgelegt, eine solide, wartbare und performante Basis für die gesamte Desktop-Umgebung zu schaffen.  
* **Richtlinien für die Nutzung durch andere Schichten**:  
  * **Fehlerbehandlung**: Alle Module in der Domänen-, System- und UI-Schicht *müssen* ihre eigenen thiserror-basierten Fehler-Enums definieren. Fehler, die von Funktionen der Kernschicht stammen, müssen entweder behandelt oder mittels ? weitergegeben werden, wobei sie potenziell unter Verwendung von \#\[from\] in die eigenen Fehlertypen der aufrufenden Schicht umgewandelt werden. Die Fehlerkette (source()) muss dabei erhalten bleiben.  
  * **Logging**: Alle Schichten *müssen* die tracing-Makros (trace\!, info\!, etc.) für sämtliche Logging-Aktivitäten verwenden. Die Funktion core::logging::initialize\_logging() muss vom Hauptanwendungsbinary beim Start aufgerufen werden. Die Einhaltung der Log-Level und der Richtlinien zur Datensensibilität ist zwingend erforderlich.  
  * **Konfiguration**: Höhere Schichten können ihre eigenen Konfigurationsstrukturen definieren, die als Teil eines größeren Anwendungskonfigurationsobjekts geladen werden können. Sie greifen auf Konfigurationen der Kernschicht über core::config::get\_core\_config() zu. Sie sollten nicht versuchen, die Konfiguration der Kernschicht zur Laufzeit zu modifizieren, da diese als statisch und nach der Initialisierung unveränderlich betrachtet wird.  
  * **Typen und Utilities**: Kerndatentypen (RectInt, Color usw.) und Utilities (core::utils) sollten direkt verwendet werden, wo dies angemessen ist, um Konsistenz zu gewährleisten und Neuimplementierungen zu vermeiden. Wenn eine höhere Schicht eine spezialisierte Version eines Kerntyps benötigt, sollte sie Komposition oder Newtype-Wrapper um den Kerntyp in Betracht ziehen, anstatt den Typ neu zu definieren.  
* **Immutabilität und Stabilität**: Die API der Kernschicht sollte nach ihrer Stabilisierung als äußerst stabil behandelt werden. Änderungen hier haben weitreichende Auswirkungen auf das gesamte System. Alle spezifizierten Komponenten sind so konzipiert, dass sie Send \+ Sync sind, wo dies sinnvoll ist, was ihre Verwendung in einer multithreaded Umgebung ermöglicht – ein Schlüsselmerkmal von Rust und wichtig für eine reaktionsschnelle Desktop-Umgebung. Die strikte Einhaltung der hier definierten Schnittstellen und Richtlinien ist entscheidend für den langfristigen Erfolg und die Wartbarkeit des Projekts.

#### **Referenzen**

1. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
2. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)  
3. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)  
4. std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/index.html](https://doc.rust-lang.org/std/error/index.html)
# **Domänenschicht: Theming-Engine – Ultra-Feinspezifikation (Teil 1/4)**

## **1\. Einleitung zum Modul domain::theming**

Das Modul domain::theming ist eine Kernkomponente der Domänenschicht und trägt die Verantwortung für die gesamte Logik des Erscheinungsbilds (Theming) der Desktop-Umgebung. Seine Hauptaufgabe besteht darin, Design-Tokens zu verwalten, Theme-Definitionen zu interpretieren, Benutzereinstellungen für das Theming zu berücksichtigen und den finalen, aufgelösten Theme-Zustand für die Benutzeroberflächenschicht bereitzustellen. Dieses Modul ermöglicht dynamische Theme-Wechsel zur Laufzeit, einschließlich Änderungen des Farbschemas (Hell/Dunkel) und der Akzentfarben, basierend auf einem robusten, Token-basierten System. Es ist so konzipiert, dass es unabhängig von spezifischen UI-Toolkits oder Systemdetails agiert und eine klare Trennung zwischen der Logik des Erscheinungsbilds und dessen Darstellung gewährleistet. Diese Spezifikation dient als direkter Implementierungsleitfaden für Entwickler.

## **2\. Datenstrukturen (domain::theming::types)**

Die folgenden Datenstrukturen definieren die Entitäten und Wertobjekte, die für die Verwaltung und Anwendung von Themes und Design-Tokens notwendig sind. Sie sind für die Serialisierung und Deserialisierung mittels serde vorbereitet, um das Laden von Konfigurationen und Definitionen aus Dateien (z.B. JSON) zu ermöglichen.

### **2.1. Token-bezogene Datenstrukturen**

Diese Strukturen repräsentieren einzelne Design-Tokens und deren Werte.

* TokenIdentifier (Wertobjekt):  
  Ein eindeutiger, hierarchischer Bezeichner für ein Design-Token (z.B. "color.background.primary", "font.size.default"). Die hierarchische Struktur erleichtert die Organisation und das Verständnis der Tokens.  
  Rust  
  \#  
  pub struct TokenIdentifier(String);

  impl TokenIdentifier {  
      pub fn new(id: impl Into\<String\>) \-\> Self {  
          Self(id.into())  
      }  
      pub fn as\_str(\&self) \-\> \&str {  
          \&self.0  
      }  
  }

  impl std::fmt::Display for TokenIdentifier {  
      fn fmt(\&self, f: \&mut std::fmt::Formatter\<'\_\>) \-\> std::fmt::Result {  
          write\!(f, "{}", self.0)  
      }  
  }

* TokenValue (Enum):  
  Repräsentiert die möglichen Wertetypen eines Design-Tokens. Die String-Werte für Farben, Dimensionen etc. sind so gestaltet, dass sie direkt CSS-kompatibel sind. Die Variante Reference ermöglicht die Erstellung von Alias-Tokens, die auf andere Tokens verweisen, was die Wiederverwendbarkeit und Konsistenz fördert.  
  Rust  
  \#  
  \#\[serde(rename\_all \= "kebab-case")\]  
  pub enum TokenValue {  
      Color(String),      // z.B., "\#FF0000", "rgba(255,0,0,0.5)", "transparent"  
      Dimension(String),  // z.B., "16px", "2rem", "100%"  
      FontSize(String),   // z.B., "12pt", "1.5em"  
      FontFamily(String), // z.B., "Inter, sans-serif"  
      FontWeight(String), // z.B., "normal", "bold", "700"  
      LineHeight(String), // z.B., "1.5", "150%"  
      LetterSpacing(String),// z.B., "0.5px", "0.05em"  
      Border(String),     // z.B., "1px solid \#CCCCCC"  
      Shadow(String),     // z.B., "2px 2px 5px rgba(0,0,0,0.3)"  
      Radius(String),     // z.B., "4px", "50%"  
      Spacing(String),    // z.B., "8px" (generische Abstände für padding, margin)  
      ZIndex(i32),  
      Opacity(f64),       // 0.0 bis 1.0  
      Text(String),       // Für beliebige String-Werte  
      Reference(TokenIdentifier), // Alias zu einem anderen Token  
  }

* RawToken (Struct):  
  Repräsentiert ein einzelnes Design-Token, wie es typischerweise aus einer Konfigurationsdatei (z.B. JSON) geladen wird. Enthält den Identifikator, den Wert und optionale Metadaten wie Beschreibung und Gruppierung.  
  Rust  
  \#  
  pub struct RawToken {  
      pub id: TokenIdentifier,  
      pub value: TokenValue,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub description: Option\<String\>,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub group: Option\<String\>, // z.B., "colors", "spacing", "typography"  
  }

* TokenSet (Typalias):  
  Eine Sammlung von RawTokens, die für eine effiziente Suche und Verwaltung als HashMap implementiert ist, wobei der TokenIdentifier als Schlüssel dient.  
  Rust  
  pub type TokenSet \= std::collections::HashMap\<TokenIdentifier, RawToken\>;

### **2.2. Theme-Definitionsstrukturen**

Diese Strukturen definieren ein vollständiges Theme, seine Varianten (z.B. Hell/Dunkel) und unterstützte Anpassungen.

* ThemeIdentifier (Wertobjekt):  
  Ein eindeutiger Bezeichner für ein Theme (z.B. "adwaita-ng", "material-you-like").  
  Rust  
  \#  
  pub struct ThemeIdentifier(String);

  impl ThemeIdentifier {  
      pub fn new(id: impl Into\<String\>) \-\> Self {  
          Self(id.into())  
      }  
      pub fn as\_str(\&self) \-\> \&str {  
          \&self.0  
      }  
  }  
  impl std::fmt::Display for ThemeIdentifier {  
      fn fmt(\&self, f: \&mut std::fmt::Formatter\<'\_\>) \-\> std::fmt::Result {  
          write\!(f, "{}", self.0)  
      }  
  }

* ColorSchemeType (Enum):  
  Definiert die grundlegenden Farbschemata, die ein Theme unterstützen kann.  
  Rust  
  \#  
  pub enum ColorSchemeType {  
      Light,  
      Dark,  
  }

* AccentColor (Struct / Wertobjekt):  
  Repräsentiert eine Akzentfarbe, die entweder einen vordefinierten Namen oder einen direkten Farbwert haben kann.  
  Rust  
  \#  
  pub struct AccentColor {  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub name: Option\<String\>, // z.B., "Blue", "ForestGreen"  
      pub value: String,        // z.B., "\#3498db" (tatsächlicher CSS-Farbwert)  
  }

* ThemeVariantDefinition (Struct):  
  Definiert die spezifischen Token-Werte oder Überschreibungen für eine bestimmte Variante eines Themes (z.B. das Dunkel-Schema). Der TokenSet hier enthält nur die Tokens, die sich von den base\_tokens des Themes unterscheiden oder spezifisch für diese Variante sind.  
  Rust  
  \#  
  pub struct ThemeVariantDefinition {  
      pub applies\_to\_scheme: ColorSchemeType,  
      pub tokens: TokenSet, // Token-Überschreibungen oder spezifische Definitionen für diese Variante  
  }

* ThemeDefinition (Struct):  
  Die vollständige Definition eines Themes, inklusive Metadaten, Basis-Tokens, Varianten und unterstützten Akzentfarben.  
  Rust  
  \#  
  pub struct ThemeDefinition {  
      pub id: ThemeIdentifier,  
      pub name: String, // Anzeigename, z.B. "Adwaita Next Generation"  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub description: Option\<String\>,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub author: Option\<String\>,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub version: Option\<String\>,  
      pub base\_tokens: TokenSet, // Grundlegende Tokens, die für alle Varianten gelten  
      \#\[serde(default, skip\_serializing\_if \= "Vec::is\_empty")\]  
      pub variants: Vec\<ThemeVariantDefinition\>, // Definitionen für Hell, Dunkel etc.  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub supported\_accent\_colors: Option\<Vec\<AccentColor\>\>, // Vordefinierte Akzentfarben  
  }

### **2.3. Konfigurations- und Zustandsstrukturen**

Diese Strukturen repräsentieren die vom Benutzer gewählten Theming-Einstellungen und den daraus resultierenden, angewendeten Theme-Zustand.

* AppliedThemeState (Struct):  
  Repräsentiert den aktuell im System aktiven Theme-Zustand. Entscheidend ist hier das Feld resolved\_tokens, welches alle Design-Tokens auf ihre endgültigen, CSS-kompatiblen String-Werte abbildet. Diese Struktur ist das primäre Ergebnis der Theming-Logik und wird von der UI-Schicht konsumiert.  
  Eine wichtige Invariante ist, dass resolved\_tokens keine TokenValue::Reference mehr enthalten darf; alle Werte müssen endgültig aufgelöst sein.  
  Rust  
  \# // Deserialize ist hier nicht zwingend nötig  
  pub struct AppliedThemeState {  
      pub theme\_id: ThemeIdentifier,  
      pub color\_scheme: ColorSchemeType,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub active\_accent\_color: Option\<AccentColor\>,  
      // Schlüssel: TokenIdentifier (z.B., "color.background.default")  
      // Wert: Final aufgelöster CSS-String (z.B., "\#FFFFFF")  
      pub resolved\_tokens: std::collections::HashMap\<TokenIdentifier, String\>,  
  }

* ThemingConfiguration (Struct):  
  Speichert die benutzerspezifischen Einstellungen für das Theming. Diese Konfiguration wird typischerweise von einer übergeordneten Einstellungsverwaltung (domain::settings) bereitgestellt und dient als Eingabe für die ThemingEngine. Sie ermöglicht es Benutzern, ihr bevorzugtes Theme, Farbschema, Akzentfarbe und sogar einzelne Tokens global zu überschreiben.  
  Rust  
  \#  
  pub struct ThemingConfiguration {  
      pub selected\_theme\_id: ThemeIdentifier,  
      pub preferred\_color\_scheme: ColorSchemeType, // Präferenz des Benutzers  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      pub selected\_accent\_color: Option\<AccentColor\>,  
      \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\]  
      // Ermöglicht Power-Usern, spezifische Tokens für jedes Theme zu überschreiben  
      pub custom\_user\_token\_overrides: Option\<TokenSet\>,  
  }

### **2.4. Tabellen für Datenstrukturen**

Die folgenden Tabellen fassen die Schlüsseleigenschaften der wichtigsten Datenstrukturen zusammen und dienen als schnelle Referenz für Entwickler. Sie verdeutlichen die Struktur und die Bedeutung der einzelnen Felder, was für die korrekte Implementierung und Nutzung dieser Typen unerlässlich ist. Die explizite Angabe von serde-Attributen und abgeleiteten Traits stellt sicher, dass die Strukturen direkt für die Datenpersistenz und den internen Gebrauch geeignet sind.

* **Tabelle 2.1: RawToken Felder**

| Feldname | Rust-Typ | Sichtbarkeit | Initialwert (JSON Default) | Invarianten/Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| id | TokenIdentifier | pub | N/A (erforderlich) | Eindeutiger, hierarchischer Bezeichner des Tokens. |
| value | TokenValue | pub | N/A (erforderlich) | Der Wert des Tokens, kann ein primitiver Typ oder eine Referenz auf ein anderes Token sein. |
| description | Option\<String\> | pub | None | Optionale Beschreibung des Tokens und seines Verwendungszwecks. |
| group | Option\<String\> | pub | None | Optionale Gruppierung (z.B. "Farben", "Typografie") zur besseren Organisation. |

* **Tabelle 2.2: ThemeDefinition Felder**

| Feldname | Rust-Typ | Sichtbarkeit | Initialwert (JSON Default) | Invarianten/Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| id | ThemeIdentifier | pub | N/A (erforderlich) | Eindeutiger Bezeichner des Themes. |
| name | String | pub | N/A (erforderlich) | Menschenlesbarer Name des Themes. |
| description | Option\<String\> | pub | None | Optionale Beschreibung des Themes. |
| author | Option\<String\> | pub | None | Optionaler Autor des Themes. |
| version | Option\<String\> | pub | None | Optionale Version des Themes. |
| base\_tokens | TokenSet | pub | N/A (erforderlich, kann leer sein) | Set von Basis-Tokens, die für alle Varianten gelten, falls nicht spezifisch überschrieben. |
| variants | Vec\<ThemeVariantDefinition\> | pub | \`\` (leerer Vektor) | Definitionen für spezifische Varianten (z.B. Hell, Dunkel). |
| supported\_accent\_colors | Option\<Vec\<AccentColor\>\> | pub | None | Optionale Liste vordefinierter Akzentfarben, die gut mit diesem Theme harmonieren. |

* **Tabelle 2.3: AppliedThemeState Felder**

| Feldname | Rust-Typ | Sichtbarkeit | Beschreibung |
| :---- | :---- | :---- | :---- |
| theme\_id | ThemeIdentifier | pub | ID des aktuell angewendeten Themes. |
| color\_scheme | ColorSchemeType | pub | Das aktuell angewendete Farbschema (Hell/Dunkel). |
| active\_accent\_color | Option\<AccentColor\> | pub | Die aktuell angewendete Akzentfarbe, falls eine ausgewählt wurde. |
| resolved\_tokens | std::collections::HashMap\<TokenIdentifier, String\> | pub | Eine Map aller Design-Tokens, aufgelöst zu ihren finalen, CSS-kompatiblen String-Werten. Enthält keine Referenzen. |

## **3\. Kernlogik und Geschäftsregeln (domain::theming::logic)**

Dieser Abschnitt beschreibt die internen Algorithmen und Regeln, die das Verhalten der Theming-Engine steuern. Diese Logik wird in privaten (priv) oder modul-internen (pub(crate)) Funktionen und Untermodulen innerhalb von domain::theming implementiert und von der in Abschnitt 4 definierten öffentlichen API genutzt.

### **3.1. Laden, Parsen und Validieren von Token- und Theme-Definitionen**

Die Theming-Engine muss in der Lage sein, Token- und Theme-Definitionen aus externen Quellen, typischerweise JSON-Dateien, zu laden, zu parsen und auf ihre Gültigkeit zu überprüfen.

* **Token-Dateien (\*.tokens.json):**  
  * **Ladepfade:** Token-Definitionen werden von standardisierten Pfaden geladen. Systemweite Tokens befinden sich beispielsweise unter /usr/share/desktop-environment/themes/tokens/, während benutzerspezifische Tokens unter $XDG\_CONFIG\_HOME/desktop-environment/themes/tokens/ (gemäß XDG Base Directory Specification) abgelegt werden können. Benutzerspezifische Dateien haben Vorrang und können systemweite Tokens überschreiben oder ergänzen.  
  * **Einlesen und Parsen:** Es wird eine Logik implementiert, die JSON-Dateien einliest, welche entweder ein Vec\<RawToken\> oder direkt ein TokenSet (als JSON-Objekt, bei dem Schlüssel Token-IDs sind) enthalten. Für das Parsen wird die serde\_json-Bibliothek verwendet.  
  * **Validierung:**  
    * **Eindeutigkeit der TokenIdentifier:** Beim Laden mehrerer Token-Dateien muss sichergestellt werden, dass Token-Identifier eindeutig sind. Bei Konflikten (gleiche ID aus verschiedenen Quellen) wird eine klare Strategie verfolgt: Benutzerspezifische Tokens haben Vorrang vor systemweiten Tokens. Bei gleichrangigen Konflikten wird eine Warnung geloggt, und das zuletzt geladene Token überschreibt das vorherige.  
    * **Zyklische Referenzen:** Es muss geprüft werden, ob TokenValue::Reference-Abhängigkeiten Zyklen bilden (z.B. Token A verweist auf B, B verweist auf A). Dies erfordert einen Graphenalgorithmus, wie z.B. eine Tiefensuche (DFS), um solche Zyklen zu erkennen. Ein erkannter Zyklus führt zu einem ThemingError::CyclicTokenReference.  
    * **Fehlerbehandlung:** Parse-Fehler (ungültiges JSON) oder ungültige Werte innerhalb der Tokens (z.B. ein fehlerhaftes Farbformat, das nicht CSS-kompatibel ist) führen zu einem ThemingError::TokenFileParseError bzw. ThemingError::InvalidTokenData.  
* **Theme-Definitionsdateien (\*.theme.json):**  
  * **Ladepfade:** Analog zu Token-Dateien, z.B. /usr/share/desktop-environment/themes/\[theme\_id\]/\[theme\_id\].theme.json für systemweite Themes und $XDG\_CONFIG\_HOME/desktop-environment/themes/\[theme\_id\]/\[theme\_id\].theme.json für benutzerspezifische Themes.  
  * **Einlesen und Parsen:** Es wird eine Logik implementiert, die JSON-Dateien einliest, die eine ThemeDefinition-Struktur repräsentieren. Auch hier kommt serde\_json zum Einsatz.  
  * **Validierung:**  
    * **Referenzierte Tokens:** Es muss sichergestellt werden, dass Tokens, die in base\_tokens oder variants\[\*\].tokens als TokenValue::Reference definiert sind, entweder auf bekannte globale Tokens (aus den geladenen \*.tokens.json-Dateien) verweisen oder innerhalb derselben ThemeDefinition (z.B. in base\_tokens) definiert sind. Fehlende Referenzen führen zu einem Fehler.  
    * **Vollständigkeit der Varianten:** Es sollte geprüft werden, ob für gängige ColorSchemeType-Werte (insbesondere Light und Dark) entsprechende ThemeVariantDefinitions existieren oder ob die base\_tokens als ausreichend für alle Schemata betrachtet werden können. Fehlende, aber erwartete Varianten könnten zu Warnungen führen.  
    * **Fehlerbehandlung:** Fehler beim Parsen oder ungültige Datenstrukturen führen zu ThemingError::ThemeFileLoadError oder ThemingError::InvalidThemeData.  
* **Logging:** Während des Lade-, Parse- und Validierungsprozesses wird das tracing-Framework intensiv genutzt:  
  * tracing::debug\!: Für Informationen über geladene Dateien und erfolgreich geparste Definitionen.  
  * tracing::warn\!: Für nicht-kritische Probleme, wie das Überschreiben von Tokens durch benutzerspezifische Definitionen oder kleinere Validierungsfehler, die nicht das Laden des gesamten Themes verhindern.  
  * tracing::error\!: Für kritische Fehler, die das Laden oder die Verwendung eines Tokensets oder einer Theme-Definition unmöglich machen (z.B. Parse-Fehler, zyklische Referenzen).

### **3.2. Mechanismus zur Auflösung und Vererbung von Tokens (Token Resolution Pipeline)**

Dies ist die zentrale Logikkomponente der Theming-Engine. Sie ist dafür verantwortlich, aus den rohen RawTokens, der ausgewählten ThemeDefinition und der aktuellen ThemingConfiguration die endgültigen, anwendbaren Token-Werte zu berechnen, die im AppliedThemeState.resolved\_tokens gespeichert werden. Dieser Prozess stellt sicher, dass alle Referenzen aufgelöst, Überschreibungen korrekt angewendet und spezifische Anpassungen (wie Akzentfarben) berücksichtigt werden.  
Die Auflösung erfolgt in einer klar definierten Reihenfolge von Schritten für eine gegebene ThemingConfiguration:

1. **Basissatz globaler Tokens bestimmen:**  
   * Lade alle RawTokens aus den systemweiten und benutzerspezifischen Token-Dateien (\*.tokens.json).  
   * Diese Sammlung bildet den "Foundation Layer" oder den globalen Token-Pool, auf den sich Themes beziehen können. Bei Namenskonflikten haben benutzerspezifische Tokens Vorrang.  
2. **Theme-spezifische Tokens laden und anwenden:**  
   * Identifiziere und lade die ThemeDefinition für die in ThemingConfiguration.selected\_theme\_id angegebene ID.  
   * Beginne mit einer Kopie der base\_tokens aus dieser ThemeDefinition. Diese Tokens können entweder eigenständige Werte definieren oder Referenzen auf Tokens im globalen Pool (aus Schritt 1\) sein.  
3. **Varianten-spezifische Tokens anwenden:**  
   * Ermittle die preferred\_color\_scheme (z.B. Light oder Dark) aus der ThemingConfiguration.  
   * Suche in der ThemeDefinition.variants nach einer ThemeVariantDefinition, deren applies\_to\_scheme mit der bevorzugten Einstellung übereinstimmt.  
   * Wenn eine passende Variante gefunden wird, merge deren tokens über das bisherige Set (aus Schritt 2). "Merging" bedeutet hier, dass Tokens aus der Variante gleichnamige Tokens aus den base\_tokens (oder dem globalen Pool, falls die Basis-Tokens Referenzen waren) überschreiben.  
4. **Akzentfarben-Logik anwenden (falls ThemingConfiguration.selected\_accent\_color vorhanden ist):**  
   * Dieser Schritt ist komplex und hängt stark davon ab, wie ein Theme die Integration von Akzentfarben definiert.  
   * **Ansatz 1: Direkte Ersetzung über spezielle Token-IDs:** Das Theme definiert Tokens mit speziellen, reservierten IDs (z.B. color.accent.primary.value, color.accent.secondary.value). Die Werte dieser Tokens werden direkt durch den value-Teil der selected\_accent\_color (z.B. "\#3498db") ersetzt. Das Theme kann auch Tokens definieren, die auf diese Akzent-Tokens verweisen (z.B. button.background.active verweist auf color.accent.primary.value).  
   * **Ansatz 2: Farbmanipulation (fortgeschritten):** Basierend auf der selected\_accent\_color.value könnten andere verwandte Farben dynamisch generiert werden (z.B. hellere/dunklere Schattierungen für Hover/Active-Zustände, kontrastierende Textfarben). Dies würde eine Farbmanipulationsbibliothek erfordern. Für die Erstimplementierung wird die direkte Ersetzung (Ansatz 1\) bevorzugt, da sie einfacher umzusetzen ist und weniger Abhängigkeiten erfordert.  
   * Die ThemeDefinition könnte ein Feld enthalten, das auflistet, welche ihrer Tokens als "akzentfähig" gelten und wie sie von der selected\_accent\_color beeinflusst werden.  
5. **Benutzerdefinierte globale Token-Overrides anwenden:**  
   * Wenn in der ThemingConfiguration ein custom\_user\_token\_overrides-Set vorhanden ist, merge diese Tokens über das bisherige, aus den vorherigen Schritten resultierende Set. Diese benutzerdefinierten Überschreibungen haben die höchste Priorität und überschreiben jeden zuvor festgelegten Wert für ein Token mit derselben ID.  
6. **Referenzen auflösen (rekursiv):**  
   * Nachdem alle Überschreibungen angewendet wurden, iteriere durch alle Tokens im aktuellen Set.  
   * Wenn ein Token den Wert TokenValue::Reference(target\_id) hat:  
     * Suche das Token mit der target\_id im aktuellen Set.  
     * **Erfolgreiche Auflösung:** Wenn target\_id gefunden wird und dessen Wert *kein* weiterer Reference ist (d.h., es ist ein konkreter Wert wie Color, Dimension etc.), ersetze den Wert des ursprünglichen Tokens (das die Referenz enthielt) durch den aufgelösten Wert des Ziel-Tokens.  
     * **Kaskadierte Referenz:** Wenn target\_id gefunden wird, aber dessen Wert ebenfalls ein Reference ist, muss diese Referenz ebenfalls aufgelöst werden. Dieser Prozess wird rekursiv fortgesetzt.  
     * **Fehlende Referenz:** Wenn target\_id nicht im aktuellen Set gefunden wird, ist dies ein Fehler, der als ThemingError::MissingTokenReference behandelt wird. Das referencing Token kann nicht aufgelöst werden.  
     * **Zyklenerkennung:** Während der rekursiven Auflösung muss ein Mechanismus zur Erkennung von Zyklen aktiv sein (z.B. durch Verfolgung des Auflösungspfads). Ein Zyklus (z.B. A → B → C → A) würde zu einer Endlosschleife führen und muss als ThemingError::CyclicTokenReference abgefangen werden. Die Validierung in Schritt 3.1 sollte Zyklen bereits erkennen, aber eine zusätzliche Prüfung hier dient als Sicherheitsnetz.  
     * **Maximale Rekursionstiefe:** Eine maximale Tiefe für die Auflösung von Referenzen (z.B. 10-20 Ebenen) sollte festgelegt werden, um bei unentdeckten Fehlern oder extrem verschachtelten (aber gültigen) Strukturen eine Endlosschleife zu verhindern und einen ThemingError::MaxReferenceDepthExceeded auszulösen.  
7. **Finale Wertkonvertierung und Erstellung des AppliedThemeState:**  
   * Nachdem alle Referenzen erfolgreich aufgelöst wurden, enthält das Token-Set nur noch konkrete TokenValue-Varianten (außer Reference).  
   * Konvertiere alle diese TokenValues in ihre finalen String-Repräsentationen, die direkt von der UI-Schicht (z.B. als CSS-Werte) verwendet werden können. Beispielsweise wird TokenValue::Color("\#aabbcc".to\_string()) zu String::from("\#aabbcc").  
   * Das Ergebnis dieser Konvertierung ist eine HashMap\<TokenIdentifier, String\>, die zusammen mit der theme\_id, color\_scheme und active\_accent\_color aus der ThemingConfiguration den neuen AppliedThemeState bildet.  
* **Caching:** Da die Token-Auflösung potenziell rechenintensiv sein kann (insbesondere bei vielen Tokens, komplexen Referenzen und häufigen Theme-Wechseln), sollte ein Caching-Mechanismus in Betracht gezogen werden.  
  * Ein aufgelöstes AppliedThemeState (oder zumindest das resolved\_tokens-Set) kann für eine gegebene Kombination aus (ThemeIdentifier, ColorSchemeType, Option\<AccentColor\>, HashOfUserOverrides) gecacht werden.  
  * Der Cache muss invalidiert werden, wenn sich zugrundeliegende Token-Dateien (\*.tokens.json) oder Theme-Definitionen (\*.theme.json) ändern (z.B. durch Aufruf von reload\_themes\_and\_tokens() in der ThemingEngine) oder wenn sich die custom\_user\_token\_overrides ändern.

### **3.3. Regeln für dynamische Theme-Wechsel und Aktualisierung des Theme-Zustands**

Die Theming-Engine muss in der Lage sein, auf Änderungen der ThemingConfiguration (z.B. durch Benutzereingaben in den Einstellungen) dynamisch zur Laufzeit zu reagieren.

1. **Benachrichtigung über Konfigurationsänderung:** Die ThemingEngine wird über eine Änderung der ThemingConfiguration informiert, typischerweise durch einen Methodenaufruf ihrer öffentlichen API (z.B. update\_configuration(new\_config)).  
2. **Neuberechnung des Theme-Zustands:** Nach Erhalt der neuen Konfiguration führt die ThemingEngine die vollständige Token Resolution Pipeline (wie in Abschnitt 3.2 beschrieben) erneut aus, unter Verwendung der new\_config.  
3. **Aktualisierung des internen Zustands:** Der resultierende AppliedThemeState wird zum neuen internen aktuellen Zustand der ThemingEngine.  
4. **Event-Benachrichtigung:** Wenn sich der neu berechnete AppliedThemeState vom vorherigen Zustand unterscheidet, emittiert die ThemingEngine ein ThemeChangedEvent. Dieses Event enthält den neuen AppliedThemeState und ermöglicht es anderen Teilen des Systems (insbesondere der UI-Schicht), auf die Änderung zu reagieren und ihr Erscheinungsbild entsprechend zu aktualisieren.

### **3.4. Invarianten und Konsistenzprüfungen**

Um die Stabilität und Korrektheit des Theming-Systems zu gewährleisten, müssen bestimmte Invarianten jederzeit gelten:

* **Keine Referenzen im AppliedThemeState:** Das Feld resolved\_tokens eines AppliedThemeState-Objekts darf unter keinen Umständen TokenValue::Reference-Typen (oder deren String-Äquivalente, falls die Auflösung fehlschlägt) enthalten. Alle Werte müssen endgültig und direkt verwendbar sein.  
* **Gültiger Fallback-Zustand:** Die ThemingEngine muss auch dann einen gültigen (wenn auch möglicherweise minimalen) AppliedThemeState bereitstellen können, wenn Konfigurationsdateien fehlerhaft, unvollständig oder nicht vorhanden sind. Hierfür ist ein Default-Fallback-Theme erforderlich. Dieses Fallback-Theme sollte entweder fest im Code einkompiliert sein (z.B. über include\_str\! aus eingebetteten JSON-Ressourcen) oder aus einer garantierten, immer verfügbaren Quelle geladen werden können. Ein Fehlschlagen beim Laden des Fallback-Themes ist ein kritischer Fehler (ThemingError::FallbackThemeLoadError).  
* **Zuverlässige Zyklenerkennung:** Zyklische Abhängigkeiten in Token-Referenzen müssen bei der Validierung (3.1) und spätestens bei der Auflösung (3.2) zuverlässig erkannt und als Fehler (ThemingError::CyclicTokenReference) behandelt werden, um Endlosschleifen und Systeminstabilität zu verhindern.  
* **Konsistenz der ThemeIdentifier:** Alle in ThemingConfiguration oder intern verwendeten ThemeIdentifier müssen auf tatsächlich geladene und validierte ThemeDefinitions verweisen, es sei denn, es handelt sich um den expliziten Fallback-Zustand.

## **4\. Öffentliche API-Spezifikation (domain::theming::api)**

Dieser Abschnitt definiert die öffentliche Schnittstelle des domain::theming-Moduls. Die Interaktion mit der Theming-Logik erfolgt primär über den ThemingEngine-Service. Diese API ist so gestaltet, dass sie klar, robust und einfach von anderen Modulen, insbesondere der UI-Schicht und der Einstellungsverwaltung, genutzt werden kann.

### **4.1. Haupt-Service: ThemingEngine**

Der ThemingEngine-Service ist die zentrale Struktur, die die gesamte Theming-Logik kapselt, den aktuellen Theme-Zustand verwaltet und als Schnittstelle für andere Systemteile dient. Er wird typischerweise als eine gemeinsam genutzte, langlebige Instanz im System existieren (z.B. als Singleton oder über Dependency Injection bereitgestellt).  
Die Implementierung muss Thread-Sicherheit gewährleisten (Send \+ Sync), da von verschiedenen Threads (z.B. UI-Thread, Hintergrund-Threads für Konfigurationsaktualisierungen) darauf zugegriffen werden könnte. Dies wird üblicherweise durch die Verwendung von Arc\<Mutex\<ThemingEngineInternalState\>\> für den internen, veränderlichen Zustand erreicht.

Rust

// Angenommen in domain::theming::mod.rs oder domain::theming::api.rs

use crate::core::errors::CoreError; // Basis-Fehlertyp, falls benötigt  
use super::types::\*;  
use super::errors::ThemingError;  
use std::sync::{Arc, Mutex};  
use std::path::PathBuf;  
// Für Eventing wird eine robuste Multi-Producer, Multi-Consumer (MPMC) Broadcast-Lösung  
// oder eine sorgfältig verwaltete Liste von mpsc-Sendern empfohlen.  
// Hier als Beispiel mit einer Liste von mpsc::Sendern für Einfachheit,  
// aber tokio::sync::broadcast oder crossbeam\_channel::Sender (cloneable) wären bessere Optionen.  
use std::sync::mpsc;

pub struct ThemingEngine {  
    internal\_state: Arc\<Mutex\<ThemingEngineInternalState\>\>,  
    // Hält Sender-Enden für alle Subscriber.  
    event\_subscribers: Arc\<Mutex\<Vec\<mpsc::Sender\<ThemeChangedEvent\>\>\>\>,  
}

struct ThemingEngineInternalState {  
    current\_config: ThemingConfiguration,  
    available\_themes: Vec\<ThemeDefinition\>, // Geladen beim Start/Refresh  
    global\_raw\_tokens: TokenSet, // Globale Tokens, nicht Teil eines Themes  
    applied\_state: AppliedThemeState,  
    // Pfade, von denen Tokens und Themes geladen wurden, für \`reload\_themes\_and\_tokens\`  
    theme\_load\_paths: Vec\<PathBuf\>,  
    token\_load\_paths: Vec\<PathBuf\>,  
    // Optional: Cache für aufgelöste Token-Sets  
    // resolved\_state\_cache: HashMap\<CacheKey, AppliedThemeState\>,  
}

impl ThemingEngine {  
    // Konstruktor und Methoden werden unten definiert  
}

#### **4.1.1. Deklarierte Eigenschaften (Properties)**

Diese Eigenschaften repräsentieren den Kernzustand der ThemingEngine. Der Zugriff erfolgt ausschließlich über die unten definierten Methoden, um Kapselung und kontrollierte Zustandsänderungen zu gewährleisten.

* **Aktueller AppliedThemeState:** Der vollständig aufgelöste und angewendete Theme-Zustand. Zugänglich über get\_current\_theme\_state().  
* **Liste der verfügbaren Themes (Vec\<ThemeDefinition\>):** Eine Liste aller erfolgreich geladenen und validierten Theme-Definitionen. Zugänglich über get\_available\_themes().  
* **Aktuelle ThemingConfiguration:** Die derzeit von der Engine verwendete Benutzerkonfiguration. Zugänglich über get\_current\_configuration().

#### **4.1.2. Methoden**

Die Methoden der ThemingEngine ermöglichen die Initialisierung, Abfrage des Zustands, Aktualisierung der Konfiguration und die Registrierung für Benachrichtigungen über Zustandsänderungen.

* **Konstruktoren/Builder:**  
  * pub fn new(initial\_config: ThemingConfiguration, theme\_load\_paths: Vec\<PathBuf\>, token\_load\_paths: Vec\<PathBuf\>) \-\> Result\<Self, ThemingError\>  
    * **Beschreibung:** Initialisiert die ThemingEngine. Lädt alle verfügbaren Themes und Tokens von den angegebenen theme\_load\_paths und token\_load\_paths. Wendet die initial\_config an, um den ersten AppliedThemeState zu berechnen. Wenn dieser Prozess fehlschlägt, wird versucht, ein Fallback-Theme zu laden.  
    * **Parameter:**  
      * initial\_config: ThemingConfiguration: Die anfängliche Benutzerkonfiguration für das Theming.  
      * theme\_load\_paths: Vec\<PathBuf\>: Eine Liste von Verzeichnispfaden, in denen nach Theme-Definitionen (\*.theme.json) gesucht wird.  
      * token\_load\_paths: Vec\<PathBuf\>: Eine Liste von Verzeichnispfaden, in denen nach globalen Token-Dateien (\*.tokens.json) gesucht wird.  
    * **Rückgabe:** Result\<Self, ThemingError\>. Gibt die initialisierte ThemingEngine oder einen Fehler zurück.  
    * **Vorbedingungen:** initial\_config sollte semantisch valide sein (obwohl die Engine dies prüft). Die angegebenen Pfade müssen für das Programm lesbar sein.  
    * **Nachbedingungen:** Bei Erfolg ist die Engine initialisiert, verfügt über einen gültigen applied\_state (entweder basierend auf initial\_config oder einem Fallback) und hat alle verfügbaren Themes/Tokens geladen. event\_subscribers ist initialisiert (leer).  
    * **Mögliche Fehler:** ThemingError::TokenFileParseError, ThemingError::ThemeFileLoadError, ThemingError::CyclicTokenReference, ThemingError::InitialConfigurationError (wenn initial\_config zu einem unauflösbaren Zustand führt), ThemingError::FallbackThemeLoadError (wenn selbst das Laden des Fallback-Themes fehlschlägt).  
* **Zustandsabfrage:**  
  * pub fn get\_current\_theme\_state(\&self) \-\> Result\<AppliedThemeState, ThemingError\>  
    * **Beschreibung:** Gibt eine Kopie (Clone) des aktuellen AppliedThemeState zurück. Dies ist der primäre Weg für die UI-Schicht, die aktuellen Theme-Werte abzurufen.  
    * **Rückgabe:** Result\<AppliedThemeState, ThemingError\>. Ein Fehler ist hier unwahrscheinlich, könnte aber bei schwerwiegenden internen Inkonsistenzen auftreten (z.B. ThemingError::InternalStateError).  
    * **Thread-Sicherheit:** Diese Methode ist lesend und greift auf den internen Zustand über einen Mutex zu.  
  * pub fn get\_available\_themes(\&self) \-\> Result\<Vec\<ThemeDefinition\>, ThemingError\>  
    * **Beschreibung:** Gibt eine Kopie (Clone) der Liste aller geladenen und validierten ThemeDefinitions zurück. Nützlich für UI-Elemente, die eine Theme-Auswahl anbieten.  
    * **Rückgabe:** Result\<Vec\<ThemeDefinition\>, ThemingError\>. Fehler wie bei get\_current\_theme\_state().  
  * pub fn get\_current\_configuration(\&self) \-\> Result\<ThemingConfiguration, ThemingError\>  
    * **Beschreibung:** Gibt eine Kopie (Clone) der aktuell von der Engine verwendeten ThemingConfiguration zurück.  
    * **Rückgabe:** Result\<ThemingConfiguration, ThemingError\>. Fehler wie bei get\_current\_theme\_state().  
* **Zustandsänderung:**  
  * pub fn update\_configuration(\&self, new\_config: ThemingConfiguration) \-\> Result\<(), ThemingError\>  
    * **Beschreibung:** Aktualisiert die Konfiguration der ThemingEngine mit der new\_config. Dies löst die Token Resolution Pipeline (Abschnitt 3.2) neu aus. Der interne applied\_state wird aktualisiert. Wenn sich der applied\_state dadurch tatsächlich ändert, wird ein ThemeChangedEvent an alle registrierten Subscriber gesendet.  
    * **Parameter:**  
      * new\_config: ThemingConfiguration: Die neue anzuwendende Benutzerkonfiguration.  
    * **Rückgabe:** Result\<(), ThemingError\>.  
    * **Vorbedingungen:** new\_config sollte semantisch valide sein.  
    * **Nachbedingungen:** Der interne Zustand (current\_config, applied\_state) ist aktualisiert. Bei einer relevanten Änderung wurde ein ThemeChangedEvent gesendet.  
    * **Mögliche Fehler:** ThemingError::ThemeNotFound (wenn new\_config.selected\_theme\_id ungültig ist), ThemingError::TokenResolutionError (z.B. MissingTokenReference, CyclicTokenReference während der Anwendung der neuen Konfiguration), ThemingError::ThemeApplicationError für allgemeinere Probleme.  
  * pub fn reload\_themes\_and\_tokens(\&self) \-\> Result\<(), ThemingError\>  
    * **Beschreibung:** Veranlasst die ThemingEngine, alle Theme-Definitionen und Token-Dateien von den beim Konstruktor angegebenen Pfaden neu zu laden. Dies ist nützlich, wenn der Benutzer z.B. neue Themes manuell installiert oder bestehende Token-Dateien extern bearbeitet hat. Nach dem Neuladen wird die *aktuell gespeicherte* ThemingConfiguration auf die neu geladenen Daten angewendet. Wenn sich der applied\_state dadurch ändert, wird ein ThemeChangedEvent gesendet.  
    * **Rückgabe:** Result\<(), ThemingError\>.  
    * **Nachbedingungen:** Der interne Bestand an available\_themes und global\_raw\_tokens ist aktualisiert. Der applied\_state ist basierend auf der aktuellen Konfiguration und den neuen Daten neu berechnet. Ein Event wurde ggf. gesendet.  
    * **Mögliche Fehler:** ThemingError::TokenFileIoError, ThemingError::TokenFileParseError, ThemingError::ThemeFileIoError, ThemingError::ThemeFileLoadError (beim Neuladen), sowie Fehler, die auch bei update\_configuration auftreten können, da der Zustand neu angewendet wird.  
* **Event-Handling (Subscription):**  
  * pub fn subscribe\_to\_theme\_changes(\&self) \-\> Result\<mpsc::Receiver\<ThemeChangedEvent\>, ThemingError\>  
    * **Beschreibung:** Ermöglicht anderen Teilen des Systems (Subscriber), sich für Benachrichtigungen über Änderungen am AppliedThemeState zu registrieren. Jeder Aufruf dieser Methode erstellt einen neuen Kommunikationskanal.  
    * **Rückgabe:** Result\<mpsc::Receiver\<ThemeChangedEvent\>, ThemingError\>. Der zurückgegebene Receiver kann verwendet werden, um ThemeChangedEvents asynchron zu empfangen.  
    * **Implementierungsdetails:** Die ThemingEngine hält eine Liste von mpsc::Sender\<ThemeChangedEvent\>-Enden (in event\_subscribers). Diese Methode erstellt ein neues mpsc::channel(), fügt den Sender-Teil zur Liste hinzu und gibt den Receiver-Teil zurück. Beim Senden eines Events iteriert die Engine über alle gespeicherten Sender und versucht, das Event zu senden. Sender, deren korrespondierender Receiver nicht mehr existiert (Kanal geschlossen), werden aus der Liste entfernt.  
    * **Mögliche Fehler:** ThemingError::EventSubscriptionError (z.B. bei Problemen mit der internen Verwaltung der Subscriber-Liste, obwohl dies bei korrekter Implementierung selten sein sollte).

#### **4.1.3. Signale/Events**

Die ThemingEngine verwendet Events, um andere Systemkomponenten über relevante Zustandsänderungen zu informieren, ohne eine enge Kopplung zu erfordern.

* **ThemeChangedEvent (Struct):**  
  * **Beschreibung:** Dieses Event wird von der ThemingEngine immer dann gesendet, wenn sich der AppliedThemeState erfolgreich geändert hat, sei es durch eine neue Benutzerkonfiguration oder durch das Neuladen von Theme-Daten.  
  * **Payload:**  
    Rust  
    \# // Clone ist wichtig, damit das Event an mehrere Subscriber gesendet werden kann.  
                            // Serialize ist nicht unbedingt nötig für interne Events.  
    pub struct ThemeChangedEvent {  
        pub new\_state: AppliedThemeState,  
        // Optional könnte hier auch der alte Zustand für Vergleiche mitgesendet werden:  
        // pub old\_state: Option\<AppliedThemeState\>,  
    }

  * **Typischer Publisher:** Die ThemingEngine selbst, innerhalb der Methoden update\_configuration und reload\_themes\_and\_tokens.  
  * **Typische Subscriber:**  
    * ui::theming\_gtk (oder ein äquivalentes Modul in der UI-Schicht): Um die GTK4-CSS-Provider mit den neuen, in new\_state.resolved\_tokens enthaltenen Werten zu aktualisieren.  
    * Andere UI-Komponenten oder Widgets, die direkt auf spezifische Token-Werte reagieren müssen, ohne den Umweg über CSS (obwohl dies seltener sein sollte).  
    * Potenziell andere Domänen- oder Systemdienste, die ihr Verhalten an das aktuelle Theme anpassen müssen.

### **4.2. Tabellen für API-Spezifikation**

Diese Tabellen bieten eine kompakte Übersicht über die Methoden der ThemingEngine und die von ihr emittierten Events. Sie sind entscheidend für Entwickler, die die Engine nutzen, da sie klare Erwartungen an Signaturen, Verhalten und Fehlerfälle setzen.

* **Tabelle 4.1: ThemingEngine-Methoden**

| Name | Signatur | Zugriff | Kurzbeschreibung | Vorbedingungen | Nachbedingungen | ThemingError-Varianten (Beispiele) |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| new | (initial\_config: ThemingConfiguration, theme\_load\_paths: Vec\<PathBuf\>, token\_load\_paths: Vec\<PathBuf\>) \-\> Result\<Self, ThemingError\> | pub | Konstruktor. Initialisiert Engine, lädt Themes/Tokens, wendet Erstkonfiguration an, richtet Fallback ein. | initial\_config valide, Pfade lesbar. | Engine initialisiert, applied\_state gültig. | ThemeLoadError, TokenParseError, InitialConfigurationError, FallbackThemeLoadError |
| get\_current\_theme\_state | (\&self) \-\> Result\<AppliedThemeState, ThemingError\> | pub | Gibt den aktuell angewendeten AppliedThemeState zurück. | Engine muss initialisiert sein. | Eine Kopie des Zustands wird zurückgegeben. | InternalStateError (selten) |
| get\_available\_themes | (\&self) \-\> Result\<Vec\<ThemeDefinition\>, ThemingError\> | pub | Gibt eine Liste aller verfügbaren, geladenen Theme-Definitionen zurück. | Engine muss initialisiert sein. | Eine Kopie der Liste wird zurückgegeben. | InternalStateError (selten) |
| get\_current\_configuration | (\&self) \-\> Result\<ThemingConfiguration, ThemingError\> | pub | Gibt die aktuell verwendete ThemingConfiguration zurück. | Engine muss initialisiert sein. | Eine Kopie der Konfiguration wird zurückgegeben. | InternalStateError (selten) |
| update\_configuration | (\&self, new\_config: ThemingConfiguration) \-\> Result\<(), ThemingError\> | pub | Aktualisiert Konfiguration, berechnet neuen Zustand und sendet ggf. ThemeChangedEvent. | new\_config valide. | Interner Zustand aktualisiert, ThemeChangedEvent ggf. gesendet. | ThemeApplicationError, TokenResolutionError, ThemeNotFound |
| reload\_themes\_and\_tokens | (\&self) \-\> Result\<(), ThemingError\> | pub | Lädt alle Theme- und Token-Dateien neu und wendet aktuelle Konfiguration an. Sendet ggf. ThemeChangedEvent. | Konfigurierte Pfade müssen weiterhin zugänglich sein. | Interner Datenbestand aktualisiert, ThemeChangedEvent ggf. gesendet. | ThemeLoadError, TokenParseError, ThemeApplicationError |
| subscribe\_to\_theme\_changes | (\&self) \-\> Result\<mpsc::Receiver\<ThemeChangedEvent\>, ThemingError\> | pub | Registriert einen Listener für ThemeChangedEvent und gibt einen Receiver zurück. | Engine muss initialisiert sein. | Ein mpsc::Receiver wird zurückgegeben, Sender intern registriert. | EventSubscriptionError |

* **Tabelle 4.2: ThemeChangedEvent**

| Event-Name/Typ | Payload-Struktur (pub fields: Type) | Typische Publisher | Typische Subscriber | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| ThemeChangedEvent | new\_state: AppliedThemeState | ThemingEngine | ui::theming\_gtk (und Äquivalente), UI-Komponenten, die direkt auf Tokens reagieren | Wird ausgelöst, nachdem der AppliedThemeState der ThemingEngine erfolgreich aktualisiert und geändert wurde. |

## **5\. Fehlerbehandlung (domain::theming::errors)**

Eine robuste und aussagekräftige Fehlerbehandlung ist entscheidend für die Stabilität und Wartbarkeit des domain::theming-Moduls. Gemäß den übergeordneten Entwicklungsrichtlinien (Abschnitt 4.3 der Gesamtspezifikation) wird das thiserror-Crate verwendet, um spezifische, benutzerdefinierte Fehler-Enums pro Modul zu definieren. Dies ermöglicht eine klare Kommunikation von Fehlerzuständen sowohl innerhalb des Moduls als auch an dessen Aufrufer.  
Die Fehlerbehandlung in Rust, die sich um das Result\<T, E\>-Enum dreht 1, erfordert eine sorgfältige Definition der Fehlertypen E. Während std::error::Error eine Basistrait ist 2, bieten Crates wie thiserror erhebliche Erleichterungen bei der Erstellung benutzerdefinierter Fehlertypen, die diesen Trait implementieren.1

### **5.1. Definition des ThemingError Enums**

Das ThemingError-Enum fasst alle spezifischen Fehler zusammen, die innerhalb des domain::theming-Moduls auftreten können. Jede Variante des Enums repräsentiert einen distinkten Fehlerfall und ist mit einer aussagekräftigen Fehlermeldung versehen, die Kontextinformationen für Entwickler bereitstellt. Die Verwendung von \#\[from\] für Fehler aus tieferliegenden Bibliotheken (wie std::io::Error oder serde\_json::Error) ermöglicht eine einfache Fehlerkonvertierung und erhält die Kausalkette (source()).

Rust

// In domain::theming::errors.rs  
use thiserror::Error;  
use super::types::{TokenIdentifier, ThemeIdentifier}; // Annahme: types.rs ist im selben Modul  
use std::path::PathBuf;

\#  
pub enum ThemingError {  
    \#\[error("Failed to parse token file '{path}': {source}")\]  
    TokenFileParseError {  
        path: PathBuf,  
        \#\[source\]  
        source: serde\_json::Error,  
    },

    \#\[error("I/O error while processing token file '{path}': {source}")\]  
    TokenFileIoError {  
        path: PathBuf,  
        \#\[source\]  
        source: std::io::Error,  
    },

    \#\[error("Invalid token data in file '{path}': {message}")\]  
    InvalidTokenData {  
        path: PathBuf,  
        message: String,  
    },

    \#\[error("Cyclic dependency detected involving token '{token\_id}' during token validation or resolution")\]  
    CyclicTokenReference {  
        token\_id: TokenIdentifier,  
        // Optional: path\_to\_cycle: Vec\<TokenIdentifier\> // Zur besseren Diagnose  
    },

    \#\[error("Failed to load theme definition '{theme\_id}' from file '{path}': {source}")\]  
    ThemeFileLoadError {  
        theme\_id: ThemeIdentifier,  
        path: PathBuf,  
        \#\[source\]  
        source: serde\_json::Error,  
    },

    \#\[error("I/O error while loading theme definition '{theme\_id}' from file '{path}': {source}")\]  
    ThemeFileIoError {  
        theme\_id: ThemeIdentifier,  
        path: PathBuf,  
        \#\[source\]  
        source: std::io::Error,  
    },

    \#\[error("Invalid theme data for theme '{theme\_id}' in file '{path}': {message}")\]  
    InvalidThemeData {  
        theme\_id: ThemeIdentifier,  
        path: PathBuf,  
        message: String,  
    },

    \#  
    ThemeNotFound {  
        theme\_id: ThemeIdentifier,  
    },

    \#  
    MissingTokenReference {  
        referencing\_token\_id: TokenIdentifier,  
        target\_token\_id: TokenIdentifier,  
    },

    \#  
    MaxReferenceDepthExceeded {  
        token\_id: TokenIdentifier,  
    },

    \#\[error("Failed to apply theming configuration: {message}")\]  
    ThemeApplicationError {  
        message: String,  
        // Optional: \#\[source\] source: Option\<Box\<dyn std::error::Error \+ Send \+ Sync \+ 'static\>\>,  
    },

    \#\[error("Critical error: Failed to initialize theming engine because no suitable fallback theme could be loaded.")\]  
    FallbackThemeLoadError,

    \#  
    InitialConfigurationError(String),  
      
    \#  
    InternalStateError(String),

    \#\[error("Failed to subscribe to theme change events: {0}")\]  
    EventSubscriptionError(String),

    // Beispiel für einen Wrapper für Core-Fehler, falls das Projekt einen zentralen CoreError hat.  
    // Dies ist oft weniger spezifisch als dedizierte Fehler, kann aber für die Integration nützlich sein.  
    // \#\[error("Core system error: {source}")\]  
    // CoreError(\#\[from\] crate::core::errors::CoreError),  
}

Die gewählte Granularität – ein Fehler-Enum pro Modul (ThemingError) mit spezifischen Varianten – stellt einen guten Kompromiss dar. Es vermeidet eine übermäßige Anzahl von Fehlertypen über das gesamte Projekt hinweg, bietet aber dennoch genügend Spezifität, um Fehlerquellen innerhalb des Moduls klar zu identifizieren und darauf reagieren zu können.4 Die Fehlermeldungen sind so gestaltet, dass sie möglichst viel Kontext liefern (z.B. Dateipfade, Token-IDs), was die Fehlersuche erheblich erleichtert und der Anforderung nach aussagekräftigen Fehlerberichten entspricht.1  
Die \#\[from\]-Annotation von thiserror wird genutzt, um Fehler von Abhängigkeiten wie serde\_json::Error und std::io::Error nahtlos in spezifische ThemingError-Varianten zu überführen. Dies vereinfacht den Code, da der ?-Operator direkt verwendet werden kann, und stellt sicher, dass die ursprüngliche Fehlerquelle (source) erhalten bleibt.1 Die Unterscheidung zwischen TokenFileIoError und ThemeFileIoError, obwohl beide potenziell von std::io::Error stammen, ist hier gerechtfertigt, da sie unterschiedliche logische Operationen (Lesen einer Token-Datei vs. Lesen einer Theme-Datei) und unterschiedliche Kontextinformationen (nur path vs. theme\_id und path) repräsentieren. Dies vermeidet die in 1 erwähnte Problematik, dass der Kontext bei der reinen Verwendung von \#\[from\] für denselben Quelltyp verschwimmen kann, wenn nicht genügend differenzierende Felder vorhanden sind.

### **5.2. Richtlinien zur Fehlerbehandlung und \-weitergabe innerhalb des Moduls**

* **Fehlerkonvertierung:** Innerhalb der privaten Logikfunktionen des domain::theming-Moduls (Abschnitt 3\) werden auftretende Fehler (z.B. I/O-Fehler beim Dateizugriff, Parsing-Fehler von serde\_json) systematisch in die entsprechenden Varianten von ThemingError umgewandelt. Dies geschieht häufig automatisch durch die Verwendung des ?-Operators in Verbindung mit den \#\[from\]-Annotationen im ThemingError-Enum oder, falls notwendig, manuell durch Aufrufe von .map\_err().  
* **Vermeidung von Panics:** Panics, ausgelöst durch unwrap() oder expect(), sind im Code des domain::theming-Moduls strikt zu vermeiden. Die einzige Ausnahme bilden potenziell Situationen, in denen ein absolut inkonsistenter Zustand eine sichere Fortführung des Programms unmöglich macht (z.B. ein kritischer, nicht behebbarer Fehler beim Laden des essentiellen Fallback-Themes während der Initialisierung der ThemingEngine). Solche Fälle müssen extrem selten sein, sorgfältig dokumentiert und begründet werden. Falls ein expect() in einer solchen Ausnahmesituation verwendet wird, sollte die Nachricht dem "expect as precondition"-Stil folgen, der beschreibt, warum der Entwickler erwartet hat, dass die Operation erfolgreich sein würde.2  
* **Fehlerweitergabe durch die API:** Alle öffentlichen Methoden der ThemingEngine (Abschnitt 4), die fehlschlagen können, geben Result\<T, ThemingError\> zurück. Dies zwingt den aufrufenden Code, Fehler explizit zu behandeln und ermöglicht eine differenzierte Reaktion auf verschiedene Fehlerzustände.  
* **Nutzung der source()-Kette:** Durch die korrekte Verwendung von \#\[source\] in den thiserror-Definitionen wird die Kausalkette von Fehlern bewahrt. Dies ist besonders nützlich für das Debugging, da es ermöglicht, einen Fehler bis zu seiner ursprünglichen Ursache zurückzuverfolgen, auch über Modul- oder Bibliotheksgrenzen hinweg.3

### **5.3. Tabelle für Fehlerbehandlung**

Die folgende Tabelle listet eine Auswahl der wichtigsten ThemingError-Varianten auf, beschreibt ihre Bedeutung und die typischen Umstände ihres Auftretens. Dies dient Entwicklern als Referenz für die Implementierung der Fehlerbehandlung im aufrufenden Code und für das Debugging.

* **Tabelle 5.1: ThemingError-Varianten (Auswahl)**

| Variante | \#\[error("...")\] String (Beispiel) | Gekapselter Quellfehler (via \#\[from\] oder Feld) | Beschreibung des Fehlerfalls |
| :---- | :---- | :---- | :---- |
| TokenFileParseError | "Failed to parse token file '{path}': {source}" | path: PathBuf, source: serde\_json::Error | Fehler beim Parsen einer JSON-Datei, die Tokens enthält (z.B. Syntaxfehler im JSON). |
| TokenFileIoError | "I/O error while processing token file '{path}': {source}" | path: PathBuf, source: std::io::Error | Ein-/Ausgabefehler beim Lesen oder Schreiben einer Token-Datei (z.B. Datei nicht gefunden, keine Leserechte). |
| CyclicTokenReference | "Cyclic dependency detected involving token '{token\_id}'..." | token\_id: TokenIdentifier | Eine zirkuläre Referenz zwischen Tokens wurde gefunden (z.B. Token A verweist auf B, und B verweist zurück auf A). |
| ThemeNotFound | "Theme with ID '{theme\_id}' not found among available themes" | theme\_id: ThemeIdentifier | Ein angefordertes Theme (z.B. in ThemingConfiguration) konnte nicht in den geladenen Definitionen gefunden werden. |
| MissingTokenReference | "Token resolution failed: Referenced token '{target\_token\_id}' not found (referenced by '{referencing\_token\_id}')" | referencing\_token\_id: TokenIdentifier, target\_token\_id: TokenIdentifier | Ein Token verweist auf ein anderes Token (target\_token\_id), das jedoch nicht im aktuellen Auflösungskontext existiert. |
| ThemeApplicationError | "Failed to apply theming configuration: {message}" | message: String | Allgemeiner Fehler während des Prozesses, eine neue ThemingConfiguration anzuwenden und den AppliedThemeState zu generieren. |
| FallbackThemeLoadError | "Critical error: Failed to initialize theming engine because no suitable fallback theme could be loaded." | \- | Kritischer Initialisierungsfehler: Das essentielle Fallback-Theme konnte nicht geladen oder verarbeitet werden. |
| InternalStateError | "An internal, unrecoverable error occurred in the ThemingEngine: {0}" | String (Fehlermeldung) | Ein unerwarteter, interner Fehler in der Engine, der auf einen Programmierfehler oder eine Datenkorruption hindeutet. |

## **6\. Vorgeschlagene Dateistruktur für das Modul domain::theming**

Eine klare und logische Dateistruktur ist entscheidend für die Wartbarkeit und Verständlichkeit eines Moduls. Für domain::theming wird folgende Struktur vorgeschlagen:

domain/  
└── theming/  
    ├── mod.rs           // Hauptmoduldatei (public API: ThemingEngine, Re-Exports)  
    ├── types.rs         // Definition aller Datenstrukturen (Token\*, Theme\*, Config\*, Event\*)  
    ├── errors.rs        // Definition des ThemingError Enums und zugehöriger Typen  
    ├── logic.rs         // Interne Implementierung der Kernlogik (Token-Laden, \-Auflösung etc.)  
    │                    // Kann bei Bedarf in Untermodule aufgeteilt werden:  
    │                    //   logic/token\_parser.rs  
    │                    //   logic/theme\_loader.rs  
    │                    //   logic/token\_resolver.rs  
    │                    //   logic/accent\_color\_processor.rs  
    ├── default\_themes/  // Verzeichnis für eingebettete Fallback-Theme-Dateien (JSON)  
    │   └── fallback.theme.json  
    │   └── base.tokens.json // Minimale Basis-Tokens für das Fallback-Theme  
    └──Cargo.toml        // Falls domain::theming als eigenes Crate innerhalb eines Workspace konzipiert ist

* **Begründung der Struktur:**  
  * mod.rs: Dient als Fassade des Moduls. Es deklariert die ThemingEngine-Struktur und re-exportiert die öffentlich zugänglichen Typen aus types.rs und errors.rs. Hier wird die öffentliche API des Moduls definiert und zugänglich gemacht.  
  * types.rs: Zentralisiert alle theming-spezifischen Datenstrukturen (wie RawToken, ThemeDefinition, AppliedThemeState etc.). Dies verbessert die Übersichtlichkeit und hilft, zyklische Abhängigkeiten zu vermeiden, da diese Typen sowohl von der API (mod.rs) als auch von der internen Logik (logic.rs) benötigt werden.  
  * errors.rs: Enthält ausschließlich die Definition des ThemingError-Enums und eventuell zugehöriger Hilfstypen für Fehler. Dies entspricht der Richtlinie, Fehlerdefinitionen pro Modul zu gruppieren.  
  * logic.rs: Kapselt die gesamte interne Implementierungslogik der Theming-Engine. Dazu gehören das Laden, Parsen und Validieren von Token- und Theme-Dateien, die komplexe Token Resolution Pipeline und die Handhabung von dynamischen Theme-Wechseln. Um die Komplexität zu bewältigen, kann logic.rs selbst wiederum in spezialisierte Untermodule (z.B. token\_parser.rs, token\_resolver.rs) aufgeteilt werden, die jeweils einen spezifischen Teilaspekt der Logik behandeln. Diese internen Module und Funktionen sind nicht Teil der öffentlichen API (pub(crate)).  
  * default\_themes/: Dieses Verzeichnis enthält die JSON-Dateien für das Fallback-Theme und die dafür notwendigen Basis-Tokens. Diese Dateien können zur Kompilierzeit mittels include\_str\! direkt in die Binärdatei eingebettet werden, um sicherzustellen, dass das Fallback-Theme immer verfügbar ist, selbst wenn externe Konfigurationsdateien fehlen oder beschädigt sind.  
  * Cargo.toml: Wäre vorhanden, wenn domain::theming als separates Crate innerhalb eines Rust-Workspace verwaltet wird. In diesem Fall würde es die Abhängigkeiten (wie serde, serde\_json, thiserror, tracing) und Metadaten spezifisch für dieses Crate deklarieren.

Diese Struktur fördert eine klare Trennung der Belange ("Separation of Concerns"): Die API-Definition ist von der Implementierungslogik getrennt, Datentypen sind zentralisiert, und Fehlerbehandlung sowie Ressourcen sind ebenfalls in eigenen Bereichen organisiert. Dies erleichtert neuen Entwicklern den Einstieg und vereinfacht die Wartung und Weiterentwicklung des Moduls.

## **7\. Detaillierter Implementierungsleitfaden (Schritt-für-Schritt)**

Dieser Leitfaden beschreibt die empfohlene Reihenfolge und die Details für die Implementierung des domain::theming-Moduls. Jeder Schritt sollte von umfassenden Unit-Tests begleitet werden, um die Korrektheit der Implementierung sicherzustellen.

### **7.1. Schrittweise Implementierung der Datenstrukturen (Abschnitt 2\)**

1. **Datei erstellen:** domain/theming/types.rs.  
2. **TokenIdentifier implementieren:**  
   * Struct-Definition mit String-Feld.  
   * new()-Methode, as\_str()-Methode.  
   * Ableitungen: Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize.  
   * Implementierung von std::fmt::Display.  
3. **TokenValue implementieren:**  
   * Enum-Definition mit allen Varianten (Color, Dimension,..., Reference(TokenIdentifier)).  
   * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
   * \#\[serde(rename\_all \= "kebab-case")\] Attribut für konsistente JSON-Serialisierung.  
4. **RawToken implementieren:**  
   * Struct-Definition mit Feldern id: TokenIdentifier, value: TokenValue, description: Option\<String\>, group: Option\<String\>.  
   * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
   * \#\[serde(default, skip\_serializing\_if \= "Option::is\_none")\] für optionale Felder.  
5. **TokenSet Typalias definieren:**  
   * pub type TokenSet \= std::collections::HashMap\<TokenIdentifier, RawToken\>;  
6. **ThemeIdentifier implementieren:** Analog zu TokenIdentifier.  
7. **ColorSchemeType implementieren:**  
   * Enum-Definition mit Varianten Light, Dark.  
   * Ableitungen: Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize.  
8. **AccentColor implementieren:**  
   * Struct-Definition mit Feldern name: Option\<String\>, value: String.  
   * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
9. **ThemeVariantDefinition implementieren:**  
   * Struct-Definition mit Feldern applies\_to\_scheme: ColorSchemeType, tokens: TokenSet.  
   * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
10. **ThemeDefinition implementieren:**  
    * Struct-Definition mit allen Feldern (id, name, description, author, version, base\_tokens, variants, supported\_accent\_colors).  
    * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
    * \#\[serde(default,...)\] für optionale Felder und Vektoren.  
11. **AppliedThemeState implementieren:**  
    * Struct-Definition mit Feldern theme\_id, color\_scheme, active\_accent\_color, resolved\_tokens: std::collections::HashMap\<TokenIdentifier, String\>.  
    * Ableitungen: Debug, Clone, PartialEq, serde::Serialize. Deserialize ist hier optional, da dieser Zustand typischerweise von der Engine konstruiert wird.  
12. **ThemingConfiguration implementieren:**  
    * Struct-Definition mit Feldern selected\_theme\_id, preferred\_color\_scheme, selected\_accent\_color, custom\_user\_token\_overrides.  
    * Ableitungen: Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize.  
13. **Unit-Tests für Datenstrukturen:**  
    * Für jede serialisierbare Struktur Tests schreiben, die die korrekte Serialisierung zu JSON und Deserialisierung von JSON überprüfen.  
    * Beispieldaten für JSON-Strings verwenden, die alle Felder und Varianten abdecken.  
    * Korrektheit der serde-Attribute (rename\_all, default, skip\_serializing\_if) verifizieren.  
    * Die Display-Implementierung für TokenIdentifier und ThemeIdentifier testen.

### **7.2. Implementierung des ThemingError Enums (Abschnitt 5\)**

1. **Datei erstellen:** domain/theming/errors.rs.  
2. **Abhängigkeit hinzufügen:** thiserror zur Cargo.toml des domain-Crates (oder des Workspace-Root, falls domain::theming ein eigenes Crate wird, bzw. zum Projekt-Crate).  
   Ini, TOML  
   \[dependencies\]  
   thiserror \= "1.0"  
   serde\_json \= "1.0" // Bereits für Typen benötigt, aber auch für Fehlerquellen relevant  
   \# weitere Abhängigkeiten

3. **ThemingError Enum definieren:**  
   * Das Enum wie in Abschnitt 5.1 spezifiziert implementieren.  
   * Alle Varianten mit den entsprechenden Feldern für Kontextinformationen (Pfade, IDs etc.) definieren.  
   * \#\[error("...")\] Attribute für jede Variante mit aussagekräftigen Fehlermeldungen versehen.  
   * \#\[source\] für gekapselte Fehler und \#\[from\] für automatische Konvertierung von std::io::Error und serde\_json::Error verwenden, wo passend.  
4. **Unit-Tests für ThemingError:**  
   * Tests schreiben, die sicherstellen, dass die Display-Implementierung (generiert durch \#\[error("...")\]) die erwarteten, formatierten Fehlermeldungen erzeugt.  
   * Für Fehler-Varianten, die einen \#\[source\]-Fehler kapseln, testen, ob die source()-Methode den korrekten zugrundeliegenden Fehler zurückgibt.  
   * Testen der From-Implementierungen (generiert durch \#\[from\]), indem Quellfehler manuell erzeugt und in ThemingError konvertiert werden.

### **7.3. Implementierung der Kernlogik-Funktionen und Geschäftsregeln (Abschnitt 3\)**

Diese Funktionen werden typischerweise in domain/theming/logic.rs oder dessen Untermodulen implementiert und als pub(crate) deklariert.

* **7.3.1. Token- und Theme-Definitionen laden, parsen und validieren:**  
  1. **Funktion pub(crate) fn load\_raw\_tokens\_from\_file(path: \&std::path::Path) \-\> Result\<TokenSet, ThemingError\>:**  
     * Datei öffnen und Inhalt lesen (std::fs::read\_to\_string). Fehlerbehandlung für I/O (ThemingError::TokenFileIoError).  
     * JSON-Inhalt parsen (serde\_json::from\_str) zu Vec\<RawToken\>. Fehlerbehandlung für Parsing (ThemingError::TokenFileParseError).  
     * Vec\<RawToken\> in TokenSet (HashMap) konvertieren. Dabei auf doppelte TokenIdentifier prüfen. Bei Duplikaten eine Warnung loggen (tracing::warn\!) und das zuletzt gelesene Token verwenden oder einen Fehler (ThemingError::InvalidTokenData) auslösen, je nach definierter Strategie (z.B. Duplikate innerhalb einer Datei sind ein Fehler).  
     * tracing::debug\! für erfolgreiches Laden verwenden.  
  2. **Funktion pub(crate) fn load\_theme\_definition\_from\_file(path: \&std::path::Path, theme\_id\_from\_path: ThemeIdentifier) \-\> Result\<ThemeDefinition, ThemingError\>:**  
     * Datei öffnen und Inhalt lesen. Fehlerbehandlung (ThemingError::ThemeFileIoError mit theme\_id und path).  
     * JSON-Inhalt parsen zu ThemeDefinition. Fehlerbehandlung (ThemingError::ThemeFileLoadError mit theme\_id und path).  
     * Validieren, ob theme\_def.id mit theme\_id\_from\_path (abgeleitet vom Dateinamen/Pfad) übereinstimmt. Bei Diskrepanz ThemingError::InvalidThemeData.  
  3. **Funktion pub(crate) fn validate\_tokenset\_for\_cycles(tokens: \&TokenSet) \-\> Result\<(), ThemingError\>:**  
     * Implementiert einen Algorithmus zur Zyklenerkennung (z.B. Tiefensuche) für TokenValue::Reference-Beziehungen.  
     * Hält eine Liste der besuchten Tokens während eines Auflösungspfads, um Zyklen zu erkennen.  
     * Gibt bei Zykluserkennung ThemingError::CyclicTokenReference { token\_id } zurück (wobei token\_id das erste im Zyklus erkannte Token ist oder ein Token, das Teil des Zyklus ist).  
  4. **Funktion pub(crate) fn validate\_theme\_definition\_references(theme\_def: \&ThemeDefinition, global\_tokens: \&TokenSet) \-\> Result\<(), ThemingError\>:**  
     * Iteriert durch alle Tokens in theme\_def.base\_tokens und in allen theme\_def.variants\[\*\].tokens.  
     * Für jedes Token, das ein TokenValue::Reference(target\_id) ist, prüfen, ob target\_id entweder in global\_tokens oder in theme\_def.base\_tokens (falls das aktuelle Token aus einer Variante stammt und sich auf ein Basistoken des Themes bezieht) existiert.  
     * Gibt bei einer fehlenden Referenz ThemingError::InvalidThemeData (oder einen spezifischeren Fehler wie MissingThemeTokenReference) zurück.  
  5. **Unit-Tests für Lade- und Validierungsfunktionen:**  
     * Tests mit gültigen JSON-Dateien für Tokens und Themes.  
     * Tests mit fehlerhaften JSON-Dateien (Syntaxfehler, falsche Typen).  
     * Tests mit semantisch ungültigen Daten (z.B. doppelte Token-IDs in einer Datei, zyklische Referenzen in einem TokenSet, fehlende Referenzen in einer ThemeDefinition).  
     * Sicherstellen, dass die korrekten ThemingError-Varianten zurückgegeben werden.  
* **7.3.2. Token Resolution Pipeline implementieren:**  
  1. **Hauptfunktion pub(crate) fn resolve\_applied\_state(config: \&ThemingConfiguration, available\_themes: &, global\_tokens: \&TokenSet) \-\> Result\<AppliedThemeState, ThemingError\>:**  
     * Implementiere die in Abschnitt 3.2 detailliert beschriebenen Schritte:  
       * **Theme auswählen:** Finde die ThemeDefinition für config.selected\_theme\_id in available\_themes. Bei Nichtauffinden ThemingError::ThemeNotFound.  
       * **Initiales Token-Set:** Beginne mit einer Kopie von global\_tokens. Merge (überschreibe) mit selected\_theme.base\_tokens.  
       * **Variante anwenden:** Finde die passende ThemeVariantDefinition für config.preferred\_color\_scheme. Merge deren tokens.  
       * **Akzentfarbe anwenden:** Implementiere die Logik zur Verarbeitung von config.selected\_accent\_color. Für die Erstimplementierung: Ersetze spezielle Token-IDs (z.B. {{ACCENT\_COLOR\_VALUE}} oder token.system.accent) durch accent\_color.value.  
       * **Benutzer-Overrides anwenden:** Merge config.custom\_user\_token\_overrides.  
       * **Referenzen auflösen:** Implementiere eine rekursive Funktion resolve\_references(current\_tokens: \&mut TokenSet, max\_depth: u8) \-\> Result\<(), ThemingError\>. Diese Funktion iteriert, bis keine TokenValue::Reference mehr vorhanden sind oder max\_depth erreicht ist. Sie muss Zyklenerkennung beinhalten (kann validate\_tokenset\_for\_cycles nutzen oder eine eigene Implementierung haben) und Fehler wie ThemingError::MissingTokenReference und ThemingError::MaxReferenceDepthExceeded behandeln.  
       * **Finale Werte konvertieren:** Konvertiere die nun aufgelösten TokenValues in String-Werte für das resolved\_tokens-Feld des AppliedThemeState.  
     * Konstruiere und gib den AppliedThemeState zurück.  
  2. **Hilfsfunktionen:**  
     * merge\_token\_sets(base: \&mut TokenSet, overrides: \&TokenSet): Fügt Tokens aus overrides zu base hinzu, wobei bestehende Tokens in base überschrieben werden.  
  3. **Unit-Tests für die Resolution Pipeline:**  
     * Szenarien mit einfachen Themes ohne Varianten oder Overrides.  
     * Szenarien mit Hell/Dunkel-Varianten.  
     * Szenarien mit Akzentfarben (einfache Ersetzung testen).  
     * Szenarien mit Benutzer-Overrides.  
     * Tests für mehrstufige Token-Referenzen (Aliase).  
     * Explizite Tests für Fehlerfälle: fehlende Referenzen, zyklische Referenzen während der Auflösung, Überschreitung der maximalen Tiefe.  
* **7.3.3. Fallback-Theme Logik:**  
  1. **Fallback-Ressourcen erstellen:** Erstelle domain/theming/default\_themes/fallback.theme.json und domain/theming/default\_themes/base.tokens.json mit minimalen, aber funktionsfähigen Werten. Diese sollten keine externen Referenzen enthalten und in sich geschlossen sein.  
  2. **Funktion pub(crate) fn load\_fallback\_applied\_state() \-\> Result\<AppliedThemeState, ThemingError\>:**  
     * Verwende include\_str\! Makros, um den Inhalt der JSON-Dateien zur Kompilierzeit einzubetten.  
     * Parse die eingebetteten Strings zu ThemeDefinition und TokenSet.  
     * Erzeuge einen AppliedThemeState direkt aus diesen Fallback-Daten (die Auflösung sollte hier trivial sein, da keine komplexen Referenzen erwartet werden).  
     * Diese Funktion sollte robust sein und nur im äußersten Notfall fehlschlagen (z.B. wenn die eingebetteten JSONs fehlerhaft sind, was ein Build-Problem wäre). Ein Fehler hier wäre ThemingError::FallbackThemeLoadError.

### **7.4. Implementierung des ThemingEngine-Service und seiner API (Abschnitt 4\)**

1. **Datei anpassen/erstellen:** domain/theming/mod.rs.  
2. **Strukturen definieren:**  
   * pub struct ThemingEngine { internal\_state: Arc\<Mutex\<ThemingEngineInternalState\>\>, event\_subscribers: Arc\<Mutex\<Vec\<mpsc::Sender\<ThemeChangedEvent\>\>\>\> }  
   * struct ThemingEngineInternalState {... } (Felder wie in 4.1 definiert, inklusive theme\_load\_paths, token\_load\_paths für reload).  
3. **Event-Struktur ThemeChangedEvent in types.rs definieren** (bereits in 7.1, hier nur zur Erinnerung).  
4. **Konstruktor ThemingEngine::new(...) implementieren:**  
   * Initialisiere event\_subscribers mit Arc::new(Mutex::new(Vec::new())).  
   * Initialisiere internal\_state.theme\_load\_paths und internal\_state.token\_load\_paths mit den übergebenen Pfaden.  
   * **Laden der globalen Tokens:** Iteriere über token\_load\_paths, rufe logic::load\_raw\_tokens\_from\_file für jede Datei auf und merge die Ergebnisse in internal\_state.global\_raw\_tokens. Führe logic::validate\_tokenset\_for\_cycles für das finale Set aus.  
   * **Laden der verfügbaren Themes:** Iteriere über theme\_load\_paths, finde \*.theme.json-Dateien, lade sie mit logic::load\_theme\_definition\_from\_file. Validiere jede ThemeDefinition mit logic::validate\_theme\_definition\_references gegen die global\_raw\_tokens. Sammle gültige Themes in internal\_state.available\_themes.  
   * **Anfänglichen Zustand anwenden:**  
     * Versuche, logic::resolve\_applied\_state mit initial\_config, internal\_state.available\_themes und internal\_state.global\_raw\_tokens aufzurufen.  
     * Bei Erfolg: Speichere initial\_config als internal\_state.current\_config und das Ergebnis als internal\_state.applied\_state.  
     * Bei Fehler: Logge den Fehler (tracing::warn\!). Versuche, logic::load\_fallback\_applied\_state() aufzurufen.  
       * Wenn Fallback erfolgreich: Speichere eine entsprechende Fallback-ThemingConfiguration (z.B. mit der ID des Fallback-Themes) und den Fallback-AppliedThemeState.  
       * Wenn Fallback fehlschlägt: Gib ThemingError::FallbackThemeLoadError zurück.  
   * Konstruiere und gib Ok(Self) zurück.  
5. **Implementiere get\_current\_theme\_state():** Sperre internal\_state-Mutex, klone internal\_state.applied\_state, gib Ok(cloned\_state) zurück.  
6. **Implementiere get\_available\_themes():** Sperre Mutex, klone internal\_state.available\_themes, gib Ok(cloned\_list) zurück.  
7. **Implementiere get\_current\_configuration():** Sperre Mutex, klone internal\_state.current\_config, gib Ok(cloned\_config) zurück.  
8. **Implementiere update\_configuration(new\_config: ThemingConfiguration):**  
   * Sperre internal\_state-Mutex.  
   * Speichere den alten applied\_state (für späteren Vergleich).  
   * Rufe logic::resolve\_applied\_state mit new\_config, \&self.internal\_state.available\_themes und \&self.internal\_state.global\_raw\_tokens auf.  
   * Bei Erfolg (Ok(new\_applied\_state)):  
     * Aktualisiere self.internal\_state.current\_config \= new\_config.  
     * Aktualisiere self.internal\_state.applied\_state \= new\_applied\_state.  
     * Wenn self.internal\_state.applied\_state sich vom alten applied\_state unterscheidet:  
       * Erzeuge ThemeChangedEvent { new\_state: self.internal\_state.applied\_state.clone() }.  
       * Sperre event\_subscribers-Mutex. Iteriere über die Sender und sende das geklonte Event. Entferne Sender, bei denen send() fehlschlägt (Kanal geschlossen).  
     * Gib Ok(()) zurück.  
   * Bei Fehler (Err(e)): Gib Err(e) zurück.  
9. **Implementiere reload\_themes\_and\_tokens():**  
   * Sperre internal\_state-Mutex.  
   * Lade globale Tokens und verfügbare Themes neu (wie im Konstruktor, unter Verwendung der gespeicherten theme\_load\_paths und token\_load\_paths). Aktualisiere internal\_state.global\_raw\_tokens und internal\_state.available\_themes. Fehler hierbei sollten geloggt und ggf. zurückgegeben werden.  
   * Speichere den alten applied\_state.  
   * Rufe logic::resolve\_applied\_state mit der *aktuellen* self.internal\_state.current\_config (die nicht geändert wurde) und den neu geladenen Daten auf.  
   * Aktualisiere self.internal\_state.applied\_state und sende Event wie bei update\_configuration, falls eine Änderung vorliegt.  
   * Gib Ok(()) oder den entsprechenden Lade-/Anwendungsfehler zurück.  
10. **Implementiere subscribe\_to\_theme\_changes():**  
    * Erzeuge ein neues mpsc::channel().  
    * Sperre event\_subscribers-Mutex. Füge den sender-Teil des Kanals zur Liste self.event\_subscribers hinzu.  
    * Gib Ok(receiver) zurück.  
11. **Unit-Tests für ThemingEngine:**  
    * **new():** Teste erfolgreiche Initialisierung mit gültigen Konfigurationen und Pfaden. Teste das Fallback-Verhalten, wenn initiale Konfigurationen fehlerhaft sind oder Pfade ungültig. Teste kritischen Fehler, wenn selbst Fallback fehlschlägt.  
    * **get\_\*() Methoden:** Teste, ob die korrekten Daten (Klone des internen Zustands) zurückgegeben werden.  
    * **update\_configuration():** Teste erfolgreiche Zustandsänderungen. Verifiziere, dass der applied\_state korrekt aktualisiert wird. Teste, dass ThemeChangedEvent nur gesendet wird, wenn sich der applied\_state tatsächlich ändert. Teste Fehlerfälle (z.B. ungültige ThemeIdentifier in new\_config).  
    * **reload\_themes\_and\_tokens():** Erstelle temporäre Theme-/Token-Dateien, modifiziere sie und teste, ob reload die Änderungen korrekt aufnimmt und den Zustand aktualisiert. Teste Event-Auslösung.  
    * **Event-System (subscribe\_to\_theme\_changes und Senden):** Registriere mehrere Subscriber. Löse eine Zustandsänderung aus und verifiziere, dass alle aktiven Subscriber das Event empfangen. Teste, dass Subscriber, deren Receiver fallengelassen wurde, korrekt aus der internen Liste entfernt werden und keine Fehler verursachen.  
    * **Thread-Sicherheit (konzeptionell):** Obwohl direkte Unit-Tests für Thread-Sicherheit komplex sind, stelle sicher, dass alle Zugriffe auf internal\_state und event\_subscribers korrekt durch Mutexe geschützt sind. Integrationstests könnten parallele Aufrufe simulieren.

### **7.5. Richtlinien für Unit-Tests (Zusammenfassung)**

* **Hohe Codeabdeckung:** Strebe eine hohe Testabdeckung für alle Logik-Komponenten in logic.rs und alle öffentlichen API-Methoden der ThemingEngine in mod.rs an.  
* **Fokus der Testfälle:**  
  * **Parsing und Validierung:** Korrekte Verarbeitung gültiger und ungültiger Eingabedaten (JSON-Dateien, Token-Strukturen).  
  * **Token-Auflösung:** Korrekte Auflösung von einfachen und komplexen Token-Referenzen (Aliase, Vererbung). Explizite Tests für Fehlerfälle wie fehlende Referenzen und zyklische Abhängigkeiten.  
  * **Theme-Anwendung:** Korrekte Anwendung von Basis-Themes, Varianten (Hell/Dunkel), Akzentfarben und Benutzer-Overrides.  
  * **ThemingEngine-Verhalten:** Korrekte Zustandsübergänge, Event-Auslösung und Fehlerbehandlung für alle API-Methoden.  
  * **Grenzwertanalyse:** Teste Randbedingungen (z.B. leere Token-Sets, Themes ohne Varianten, maximale Rekursionstiefe bei Referenzen).  
* **Testdaten und Fixtures:** Verwende kleine, fokussierte JSON-Beispieldateien für Tokens und Themes als Test-Fixtures. Diese können als Strings direkt in die Testfunktionen eingebettet oder aus einem Test-Ressourcenverzeichnis geladen werden.  
* **Mocking:** Für dieses Modul der Domänenschicht ist Mocking von externen Abhängigkeiten (hauptsächlich das Dateisystem) in der Regel nicht notwendig für Unit-Tests der Kernlogik. Die Ladefunktionen können mit temporären Dateien oder In-Memory-Daten getestet werden. Der Fokus liegt auf der internen Verarbeitungslogik.  
* **Testorganisation:** Unit-Tests sollten direkt neben dem zu testenden Code in Untermodulen tests liegen (\#\[cfg(test)\] mod tests {... }).

Durch die konsequente Befolgung dieses Implementierungsleitfadens und die sorgfältige Erstellung von Unit-Tests kann ein robustes, korrekt funktionierendes und wartbares domain::theming-Modul entwickelt werden.

#### **Referenzen**

1. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
2. std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/index.html](https://doc.rust-lang.org/std/error/index.html)  
3. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)  
4. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)
# **Domänenschicht: Implementierungsleitfaden Teil 2/4 – Workspaces (domain::workspaces)**

## **1\. Einleitung zur Komponente domain::workspaces**

Die Komponente domain::workspaces ist ein zentraler Bestandteil der Domänenschicht und verantwortlich für die gesamte Logik und Verwaltung von Arbeitsbereichen, oft als "Spaces" oder virtuelle Desktops bezeichnet. Sie definiert die Struktur eines einzelnen Workspace, die Regeln für die Zuweisung von Fenstern zu Workspaces, die Orchestrierung aller Workspaces inklusive des aktiven Workspace und die Persistenz der Workspace-Konfiguration. Diese Komponente ist UI-unabhängig und stellt ihre Funktionalität über klar definierte Schnittstellen bereit, die von der System- und Benutzeroberflächenschicht genutzt werden können.  
Die Implementierung ist in vier primäre Module unterteilt, um eine hohe Kohäsion und lose Kopplung zu gewährleisten:

* workspaces::core: Definiert die grundlegende Entität eines Workspace und zugehörige Typen.  
* workspaces::assignment: Beinhaltet die Logik für die Zuweisung von Fenstern zu Workspaces.  
* workspaces::manager: Orchestriert die Verwaltung aller Workspaces und publiziert relevante Events.  
* workspaces::config: Verantwortlich für das Laden und Speichern der Workspace-Konfiguration.

Dieser Implementierungsleitfaden spezifiziert jedes dieser Module im Detail, einschließlich Datenstrukturen, APIs, Fehlerbehandlung und Implementierungsschritten, um eine direkte Umsetzung durch das Entwicklungsteam zu ermöglichen.

## **2\. Entwicklungsmodul 1: workspaces::core – Fundamentale Workspace-Definition**

Das Modul workspaces::core legt das Fundament für das Workspace-System, indem es die Kernentität Workspace sowie die damit verbundenen grundlegenden Datentypen und Fehlerdefinitionen bereitstellt.

### **2.1. Verantwortlichkeiten und Design-Rationale**

Dieses Modul ist ausschließlich dafür zuständig, die intrinsischen Eigenschaften und das Verhalten eines einzelnen, isolierten Workspace zu definieren. Es kapselt Attribute wie Name, ID, Layout-Typ und die Menge der zugeordneten Fensteridentifikatoren. Die Design-Entscheidung, diese Kernfunktionalität zu isolieren, stellt sicher, dass die grundlegende Definition eines Workspace unabhängig von komplexerer Verwaltungs- oder Zuweisungslogik bleibt, was die Wartbarkeit und Testbarkeit des Moduls verbessert. Es hat keine Kenntnis von anderen Workspaces oder dem Konzept eines "aktiven" Workspace.

### **2.2. Datentypen und Entitäten**

Die folgenden Rust-Datentypen sind für die Definition eines Workspace und seiner Attribute spezifiziert.

#### **2.2.1. Struct: Workspace**

Das Workspace-Struct repräsentiert einen einzelnen Arbeitsbereich.

* **Rust-Definition:**  
  Rust  
  // src/domain/workspaces/core/mod.rs  
  use std::collections::HashSet;  
  use uuid::Uuid;  
  use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};  
  use crate::domain::workspaces::core::errors::WorkspaceCoreError;

  \#  
  pub struct Workspace {  
      id: WorkspaceId,  
      name: String,  
      persistent\_id: Option\<String\>, // Für Persistenz über Sitzungen hinweg  
      layout\_type: WorkspaceLayoutType,  
      window\_ids: HashSet\<WindowIdentifier\>, // IDs der Fenster auf diesem Workspace  
      created\_at: chrono::DateTime\<chrono::Utc\>, // Zeitstempel der Erstellung  
  }

* **Attribute und deren Bedeutung:**  
  * id: WorkspaceId: Ein eindeutiger Laufzeit-Identifikator für den Workspace, generiert bei der Erstellung (z.B. mittels uuid::Uuid::new\_v4()).  
  * name: String: Der vom Benutzer definierbare oder automatisch generierte Name des Workspace (z.B. "Arbeit", "Workspace 1").  
    * Invarianten: Darf nicht leer sein. Muss eine maximale Länge (z.B. 255 Zeichen) einhalten. Validierung erfolgt bei Erstellung und Umbenennung.  
  * persistent\_id: Option\<String\>: Eine optionale, eindeutige ID, die über Sitzungen hinweg stabil bleibt und zum Wiederherstellen von Workspaces verwendet wird. Kann vom Benutzer festgelegt oder automatisch generiert werden.  
    * Invarianten: Falls Some, darf der String nicht leer sein und sollte bestimmten Formatierungsregeln folgen (z.B. keine Sonderzeichen, um Dateisystem- oder Konfigurationsprobleme zu vermeiden).  
  * layout\_type: WorkspaceLayoutType: Definiert das aktuelle Layout-Verhalten für Fenster auf diesem Workspace (z.B. Floating, TilingHorizontal).  
  * window\_ids: HashSet\<WindowIdentifier\>: Eine Menge von eindeutigen Identifikatoren für Fenster, die aktuell diesem Workspace zugeordnet sind. Die Reihenfolge der Fenster ist hier nicht relevant; diese wird ggf. von der Systemschicht (Compositor) oder domain::window\_management verwaltet.  
  * created\_at: chrono::DateTime\<chrono::Utc\>: Der Zeitstempel der Erstellung des Workspace-Objekts.

#### **2.2.2. Struct: WindowIdentifier**

Ein Newtype für Fensteridentifikatoren zur Verbesserung der Typsicherheit.

* **Rust-Definition:**  
  Rust  
  // src/domain/workspaces/core/types.rs  
  \#  
  pub struct WindowIdentifier(String);

  impl WindowIdentifier {  
      pub fn new(id: String) \-\> Result\<Self, &'static str\> {  
          if id.is\_empty() {  
              Err("WindowIdentifier cannot be empty")  
          } else {  
              Ok(Self(id))  
          }  
      }

      pub fn as\_str(\&self) \-\> \&str {  
          \&self.0  
      }  
  }

  impl From\<String\> for WindowIdentifier {  
      fn from(s: String) \-\> Self {  
          // In einem realen Szenario könnte hier eine Validierung stattfinden oder  
          // es wird davon ausgegangen, dass der String bereits validiert ist.  
          // Für die einfache Konvertierung wird hier keine Validierung erzwungen,  
          // die \`new\` Methode ist für explizite Validierung vorgesehen.  
          Self(s)  
      }  
  }

  impl std::fmt::Display for WindowIdentifier {  
      fn fmt(\&self, f: \&mut std::fmt::Formatter\<'\_\>) \-\> std::fmt::Result {  
          write\!(f, "{}", self.0)  
      }  
  }

* **Verwendung:** Repräsentiert einen eindeutigen Identifikator für ein Fenster. Dieser Identifikator wird typischerweise von der Systemschicht (z.B. als Wayland Surface ID oder eine interne Anwendungs-ID) vergeben. Die Domänenschicht behandelt diesen Identifikator als einen opaken Wert, dessen genaues Format und Ursprung für die Logik innerhalb von domain::workspaces nicht von primärer Bedeutung sind, solange er Eindeutigkeit gewährleistet.  
* **Invarianten:** Der interne String darf nicht leer sein. Diese Invariante wird durch die new-Methode sichergestellt.

#### **2.2.3. Enum: WorkspaceLayoutType**

Definiert die möglichen Layout-Modi eines Workspace.

* **Rust-Definition:**  
  Rust  
  // src/domain/workspaces/core/types.rs  
  \#  
  pub enum WorkspaceLayoutType {  
      Floating,  
      TilingHorizontal,  
      TilingVertical,  
      Maximized, // Ein einzelnes Fenster ist maximiert, andere sind ggf. verborgen oder minimiert  
  }

  impl Default for WorkspaceLayoutType {  
      fn default() \-\> Self {  
          WorkspaceLayoutType::Floating  
      }  
  }

* **Verwendung:** Steuert, wie Fenster innerhalb des Workspace standardmäßig angeordnet oder verwaltet werden. Die konkrete Implementierung der Layout-Logik erfolgt in domain::window\_management und der Systemschicht, basierend auf diesem Typ.  
* **Standardwert:** Floating.

#### **2.2.4. Typalias: WorkspaceId**

Ein Typalias für die ID eines Workspace zur Verbesserung der Lesbarkeit und Konsistenz.

* **Rust-Definition:**  
  Rust  
  // src/domain/workspaces/core/types.rs  
  pub type WorkspaceId \= uuid::Uuid;

### **2.3. Öffentliche API: Methoden und Funktionen**

Alle hier definierten Methoden sind Teil der impl Workspace {... }.  
**Tabelle: API-Methoden für workspaces::core::Workspace**

| Methode (Rust-Signatur) | Kurzbeschreibung | Vorbedingungen | Nachbedingungen | Ausgelöste Events (indirekt) | Mögliche Fehler (WorkspaceCoreError) |
| :---- | :---- | :---- | :---- | :---- | :---- |
| pub fn new(name: String, persistent\_id: Option\<String\>) \-\> Result\<Self, WorkspaceCoreError\> | Erstellt einen neuen Workspace. | name darf nicht leer sein und muss die Längenbeschränkung einhalten. persistent\_id (falls Some) muss gültig sein. | Ein neues Workspace-Objekt wird mit einer eindeutigen id und created\_at Zeitstempel initialisiert. | \- | InvalidName, NameCannotBeEmpty, NameTooLong, InvalidPersistentId |
| pub fn id(\&self) \-\> WorkspaceId | Gibt die eindeutige Laufzeit-ID des Workspace zurück. | \- | \- | \- | \- |
| pub fn name(\&self) \-\> \&str | Gibt den aktuellen Namen des Workspace zurück. | \- | \- | \- | \- |
| pub fn rename(\&mut self, new\_name: String) \-\> Result\<(), WorkspaceCoreError\> | Benennt den Workspace um. | new\_name darf nicht leer sein und muss die Längenbeschränkung einhalten. | Der name des Workspace ist auf new\_name gesetzt. | WorkspaceRenamed (via manager) | InvalidName, NameCannotBeEmpty, NameTooLong |
| pub fn layout\_type(\&self) \-\> WorkspaceLayoutType | Gibt den aktuellen Layout-Typ des Workspace zurück. | \- | \- | \- | \- |
| pub fn set\_layout\_type(\&mut self, layout\_type: WorkspaceLayoutType) \-\> () | Setzt den Layout-Typ des Workspace. | \- | Der layout\_type des Workspace ist auf den übergebenen Wert gesetzt. | WorkspaceLayoutChanged (via manager) | \- |
| pub(crate) fn add\_window\_id(\&mut self, window\_id: WindowIdentifier) \-\> bool | Fügt eine Fenster-ID zur Menge der Fenster auf diesem Workspace hinzu. Intern verwendet vom assignment-Modul. | \- | window\_id ist in window\_ids enthalten. Gibt true zurück, wenn die ID neu hinzugefügt wurde, sonst false. | WindowAddedToWorkspace (via manager) | \- |
| pub(crate) fn remove\_window\_id(\&mut self, window\_id: \&WindowIdentifier) \-\> bool | Entfernt eine Fenster-ID aus der Menge der Fenster auf diesem Workspace. Intern verwendet vom assignment-Modul. | \- | window\_id ist nicht mehr in window\_ids enthalten. Gibt true zurück, wenn die ID entfernt wurde, sonst false. | WindowRemovedFromWorkspace (via manager) | \- |
| pub fn window\_ids(\&self) \-\> \&HashSet\<WindowIdentifier\> | Gibt eine unveränderliche Referenz auf die Menge der Fenster-IDs zurück. | \- | \- | \- | \- |
| pub fn persistent\_id(\&self) \-\> Option\<\&str\> | Gibt die optionale persistente ID des Workspace zurück. | \- | \- | \- | \- |
| pub fn set\_persistent\_id(\&mut self, pid: Option\<String\>) \-\> Result\<(), WorkspaceCoreError\> | Setzt oder entfernt die persistente ID des Workspace. | pid (falls Some) muss gültig sein. | Die persistent\_id des Workspace ist entsprechend gesetzt. | \- | InvalidPersistentId |
| pub fn created\_at(\&self) \-\> chrono::DateTime\<chrono::Utc\> | Gibt den Erstellungszeitstempel des Workspace zurück. | \- | \- | \- | \- |

Diese Tabelle definiert die exakte Schnittstelle für die Interaktion mit einem Workspace-Objekt. Die präzise Spezifikation von Signaturen, Vor- und Nachbedingungen sowie potenziellen Fehlern ist entscheidend für eine korrekte Implementierung und Nutzung durch andere Systemkomponenten.

### **2.4. Interner Zustand und Lebenszyklusmanagement**

Ein Workspace-Objekt wird typischerweise vom workspaces::manager-Modul erstellt und dessen Lebensdauer von diesem verwaltet. Es besitzt keinen komplexen internen Zustandsautomaten; sein Zustand wird vollständig durch seine Attribute (Felder des Structs) definiert. Änderungen am Zustand erfolgen durch Aufruf der in Abschnitt 2.3 definierten Methoden.

### **2.5. Events: Definition und Semantik (Event-Datenstrukturen)**

Das Modul workspaces::core definiert selbst keine Event-Enums und ist auch nicht für das Publizieren von Events zuständig. Es stellt jedoch die Datenstrukturen (Payloads) bereit, die von höherliegenden Modulen (insbesondere workspaces::manager) verwendet werden, um den Inhalt von Events zu definieren, die sich auf Änderungen an Workspace-Objekten beziehen.

* Beispielhafte Event-Datenstrukturen (Payloads):  
  Diese Strukturen werden im Untermodul event\_data definiert (src/domain/workspaces/core/event\_data.rs).  
  Rust  
  // src/domain/workspaces/core/event\_data.rs  
  use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};

  \#  
  pub struct WorkspaceRenamedData {  
      pub id: WorkspaceId,  
      pub old\_name: String,  
      pub new\_name: String,  
  }

  \#  
  pub struct WorkspaceLayoutChangedData {  
      pub id: WorkspaceId,  
      pub old\_layout: WorkspaceLayoutType,  
      pub new\_layout: WorkspaceLayoutType,  
  }

  \#  
  pub struct WindowAddedToWorkspaceData {  
      pub workspace\_id: WorkspaceId,  
      pub window\_id: WindowIdentifier,  
  }

  \#  
  pub struct WindowRemovedFromWorkspaceData {  
      pub workspace\_id: WorkspaceId,  
      pub window\_id: WindowIdentifier,  
  }

  \#  
  pub struct WorkspacePersistentIdChangedData {  
      pub id: WorkspaceId,  
      pub old\_persistent\_id: Option\<String\>,  
      pub new\_persistent\_id: Option\<String\>,  
  }

  Die eigentlichen Event-Enums (z.B. WorkspaceEvent), die diese Datenstrukturen verwenden, werden im workspaces::manager-Modul definiert.

### **2.6. Fehlerbehandlung: WorkspaceCoreError**

Für die Fehlerbehandlung innerhalb des workspaces::core-Moduls wird ein spezifisches Error-Enum WorkspaceCoreError definiert. Dieses Enum nutzt das thiserror-Crate, um die Erstellung idiomatischer Fehlertypen zu vereinfachen, wie in Richtlinie 4.3 der Gesamtspezifikation und basierend auf etablierten Praktiken 1 empfohlen.

* **Definition:**  
  Rust  
  // src/domain/workspaces/core/errors.rs  
  use thiserror::Error;  
  use crate::core::errors::ValidationError; // Annahme: Ein allgemeiner Validierungsfehler aus der Kernschicht

  pub const MAX\_WORKSPACE\_NAME\_LENGTH: usize \= 64; // Beispielhafte Maximallänge

  \#  
  pub enum WorkspaceCoreError {  
      \#  
      InvalidName(String), // Enthält den ungültigen Namen

      \#\[error("Workspace name cannot be empty.")\]  
      NameCannotBeEmpty,

      \#\[error("Workspace name exceeds maximum length of {max\_len} characters: '{name}' is {actual\_len} characters long.")\]  
      NameTooLong { name: String, max\_len: usize, actual\_len: usize },

      \#  
      InvalidPersistentId(String), // Enthält die ungültige ID

      \#\[error("A core validation rule was violated: {0}")\]  
      ValidationError(\#\[from\] ValidationError), // Ermöglicht das Wrapping von Fehlern aus der Kernschicht

      \#\[error("An internal error occurred in workspace core logic: {context}")\]  
      Internal { context: String }, // Für unerwartete interne Fehlerzustände  
  }

* Erläuterung und Anwendung von Fehlerbehandlungsprinzipien:  
  Die Gestaltung von WorkspaceCoreError folgt mehreren wichtigen Prinzipien der Fehlerbehandlung in Rust:  
  1. **Spezifität und Kontext:** Jede Variante des Enums repräsentiert einen klar definierten Fehlerfall, der innerhalb des workspaces::core-Moduls auftreten kann. Varianten wie InvalidName(String) und NameTooLong { name, max\_len, actual\_len } enthalten die problematischen Werte oder relevanten Kontextinformationen direkt im Fehlertyp. Dies ist entscheidend, um das Problem des "Context Blurring" zu vermeiden, bei dem ein generischer Fehlertyp nicht genügend Informationen über die Fehlerursache liefert.1 Durch die Aufnahme dieser Daten kann der aufrufende Code nicht nur den Fehlertyp programmatisch behandeln, sondern auch detaillierte Fehlermeldungen für Benutzer oder Entwickler generieren.  
  2. **thiserror für Ergonomie:** Die Verwendung von \#\[derive(Error)\] und dem \#\[error("...")\]-Attribut von thiserror reduziert Boilerplate-Code erheblich und stellt sicher, dass das std::error::Error-Trait korrekt implementiert wird, inklusive einer sinnvollen Display-Implementierung.1  
  3. **Fehler-Wrapping mit \#\[from\]:** Die Variante ValidationError(\#\[from\] ValidationError) demonstriert die Nutzung von \#\[from\]. Dies ermöglicht die automatische Konvertierung eines ValidationError (aus crate::core::errors) in einen WorkspaceCoreError mittels des ?-Operators. Entscheidend ist hierbei, dass die source()-Methode des Error-Traits automatisch so implementiert wird, dass der ursprüngliche ValidationError als Ursache des WorkspaceCoreError zugänglich bleibt.3 Dies ist für die Fehlerdiagnose über Modulgrenzen hinweg unerlässlich.  
  4. **Vermeidung von Panics:** Die API-Methoden von Workspace geben Result\<\_, WorkspaceCoreError\> zurück. Dies stellt sicher, dass vorhersehbare Fehlerzustände (z.B. ungültige Eingaben) explizit behandelt und nicht durch panic\! abgebrochen werden, was für Bibliotheks- und Domänencode als Best Practice gilt.4  
  5. **Klare Fehlernachrichten:** Die \#\[error("...")\]-Nachrichten sind primär für Entwickler konzipiert (z.B. für Logging und Debugging). Sie sind präzise und beschreiben das technische Problem. Die Benutzeroberflächenschicht ist dafür verantwortlich, diese technischen Fehler gegebenenfalls in benutzerfreundlichere Meldungen zu übersetzen.

Ein wichtiger Aspekt bei der Fehlerdefinition ist die Balance zwischen der Anzahl der Fehlervarianten und der Notwendigkeit, spezifische Informationen für die Fehlerbehandlung bereitzustellen. Wenn ein generischer Fehler wie ValidationError aus einer tieferen Schicht stammt, ist es oft nicht ausreichend, ihn einfach nur zu wrappen. Wenn der Kontext, *welche* spezifische Validierung innerhalb von workspaces::core fehlgeschlagen ist, für den Aufrufer relevant ist, sollte eine spezifischere Variante in WorkspaceCoreError in Betracht gezogen werden. Alternativ kann die Internal { context: String }-Variante genutzt werden, wobei context die fehlgeschlagene Operation detailliert beschreibt. Entwickler müssen beim Mappen von Fehlern (z.B. mittels map\_err) darauf achten, präzise Kontextinformationen hinzuzufügen, falls \#\[from\] allein nicht genügend semantische Information transportiert.  
**Tabelle: WorkspaceCoreError Varianten**

| Variante | \#\[error("...")\]-Meldung (Auszug) | Semantische Bedeutung/Ursache | Enthaltene Datenfelder | Mögliche Quellfehler (source()) |
| :---- | :---- | :---- | :---- | :---- |
| InvalidName(String) | "Invalid workspace name: {0}..." | Der angegebene Workspace-Name ist ungültig (z.B. aufgrund von Formatierungsregeln, die über Leerstring/Länge hinausgehen). | Der ungültige Name (String). | \- |
| NameCannotBeEmpty | "Workspace name cannot be empty." | Es wurde versucht, einen Workspace mit einem leeren Namen zu erstellen oder einen bestehenden Workspace in einen leeren Namen umzubenennen. | \- | \- |
| NameTooLong | "Workspace name exceeds maximum length..." | Der angegebene Name überschreitet die definierte Maximallänge. | name: String, max\_len: usize, actual\_len: usize. | \- |
| InvalidPersistentId(String) | "Persistent ID is invalid: {0}..." | Die angegebene persistente ID ist ungültig (z.B. leer oder falsches Format). | Die ungültige ID (String). | \- |
| ValidationError(\#\[from\] ValidationError) | "A core validation rule was violated: {0}" | Eine allgemeine Validierungsregel aus der Kernschicht wurde verletzt. | Der ursprüngliche ValidationError. | ValidationError |
| Internal { context: String } | "An internal error occurred..." | Ein unerwarteter Fehler oder eine nicht behandelte Bedingung innerhalb der Modullogik. | context: String (Beschreibung des internen Fehlers). | Variiert |

Diese Tabelle dient Entwicklern als Referenz, um die möglichen Fehlerursachen im workspaces::core-Modul zu verstehen und eine robuste Fehlerbehandlung in aufrufenden Modulen zu implementieren.

### **2.7. Detaillierte Implementierungsschritte und Dateistruktur**

* **Dateistruktur innerhalb von src/domain/workspaces/core/:**  
  * mod.rs: Enthält die Definition des Workspace-Structs und die Implementierung seiner Methoden (impl Workspace). Exportiert öffentliche Typen und Module.  
  * types.rs: Beinhaltet die Definitionen von WorkspaceId, WindowIdentifier und WorkspaceLayoutType.  
  * errors.rs: Enthält die Definition des WorkspaceCoreError-Enums und zugehörige Konstanten wie MAX\_WORKSPACE\_NAME\_LENGTH.  
  * event\_data.rs: Enthält die Definitionen der Event-Payload-Strukturen (z.B. WorkspaceRenamedData).  
* **Implementierungsschritte:**  
  1. Definiere die Typen WorkspaceId, WindowIdentifier (inkl. new, as\_str, From\<String\>, Display) und WorkspaceLayoutType (inkl. Default) in types.rs.  
  2. Definiere das WorkspaceCoreError-Enum in errors.rs gemäß der Spezifikation in Abschnitt 2.6. Implementiere die Konstante MAX\_WORKSPACE\_NAME\_LENGTH.  
  3. Definiere die Event-Payload-Strukturen (z.B. WorkspaceRenamedData, WorkspaceLayoutChangedData, etc.) in event\_data.rs.  
  4. Implementiere das Workspace-Struct in mod.rs mit allen Attributen wie in Abschnitt 2.2.1 spezifiziert.  
  5. Implementiere die Methode pub fn new(name: String, persistent\_id: Option\<String\>) \-\> Result\<Self, WorkspaceCoreError\>:  
     * Validiere name: Prüfe auf Leerstring (Fehler: NameCannotBeEmpty) und Überschreitung von MAX\_WORKSPACE\_NAME\_LENGTH (Fehler: NameTooLong). Ggf. weitere Validierungen für InvalidName.  
     * Validiere persistent\_id (falls Some): Prüfe auf Leerstring und ggf. Format (Fehler: InvalidPersistentId).  
     * Initialisiere id mit Uuid::new\_v4().  
     * Initialisiere created\_at mit chrono::Utc::now().  
     * Initialisiere window\_ids als leeres HashSet.  
     * Initialisiere layout\_type mit WorkspaceLayoutType::default().  
     * Gib bei Erfolg Ok(Self {... }) zurück.  
  6. Implementiere alle Getter-Methoden (id(), name(), layout\_type(), window\_ids(), persistent\_id(), created\_at()) als einfache Rückgaben der entsprechenden Felder.  
  7. Implementiere pub fn rename(\&mut self, new\_name: String) \-\> Result\<(), WorkspaceCoreError\>:  
     * Validiere new\_name analog zur new()-Methode.  
     * Bei Erfolg: self.name \= new\_name; Ok(()).  
  8. Implementiere pub fn set\_layout\_type(\&mut self, layout\_type: WorkspaceLayoutType) \-\> (): self.layout\_type \= layout\_type;.  
  9. Implementiere pub fn set\_persistent\_id(\&mut self, pid: Option\<String\>) \-\> Result\<(), WorkspaceCoreError\>:  
     * Validiere pid (falls Some) analog zur new()-Methode.  
     * Bei Erfolg: self.persistent\_id \= pid; Ok(()).  
  10. Implementiere die pub(crate) Methoden add\_window\_id(\&mut self, window\_id: WindowIdentifier) \-\> bool und remove\_window\_id(\&mut self, window\_id: \&WindowIdentifier) \-\> bool unter Verwendung der entsprechenden HashSet-Methoden (insert bzw. remove) und gib deren booleschen Rückgabewert zurück.  
  11. Stelle sicher, dass alle öffentlichen Typen, Methoden und Felder (falls öffentlich) umfassend mit rustdoc-Kommentaren dokumentiert sind. Die Kommentare müssen Vor- und Nachbedingungen, ausgelöste Fehler (mit Verweis auf die WorkspaceCoreError-Varianten) und ggf. Code-Beispiele enthalten, gemäß Richtlinie 4.7 der Gesamtspezifikation.  
  12. Erstelle Unit-Tests im Untermodul tests (d.h. \#\[cfg(test)\] mod tests {... }) innerhalb von mod.rs. Teste jede Methode gründlich, insbesondere:  
      * Erfolgreiche Erstellung von Workspace-Objekten.  
      * Fehlerfälle bei der Erstellung (ungültige Namen, ungültige persistente IDs).  
      * Erfolgreiche Umbenennung und Fehlerfälle dabei.  
      * Setzen und Abrufen des Layout-Typs.  
      * Setzen und Abrufen der persistenten ID und Fehlerfälle dabei.  
      * Hinzufügen und Entfernen von Fenster-IDs, inklusive Überprüfung der Rückgabewerte und des Zustands von window\_ids.  
      * Überprüfung der Invarianten (z.B. dass id und created\_at korrekt initialisiert werden).

## **3\. Entwicklungsmodul 2: workspaces::assignment – Logik zur Fensterzuweisung**

Das Modul workspaces::assignment ist für die spezifische Geschäftslogik zuständig, die das Zuweisen von Fenstern zu Workspaces und das Entfernen von Fenstern aus Workspaces regelt.

### **3.1. Verantwortlichkeiten und Design-Rationale**

Die Hauptverantwortung dieses Moduls liegt in der Implementierung der Regeln und Operationen, die steuern, wie Fenster (repräsentiert durch WindowIdentifier) Workspaces zugeordnet werden. Dies beinhaltet die Durchsetzung von Regeln wie "ein Fenster darf nur einem Workspace gleichzeitig zugewiesen sein" (falls diese Regel gilt). Das Modul agiert als Dienstleister für den workspaces::manager, der die übergeordnete Workspace-Sammlung hält.  
Die Auslagerung dieser Logik in ein eigenes Modul dient mehreren Zwecken:

* **Trennung der Belange (Separation of Concerns):** Das workspaces::core-Modul bleibt fokussiert auf die Definition eines einzelnen Workspace, während workspaces::manager sich um die Verwaltung der Sammlung und Lebenszyklen kümmert. workspaces::assignment spezialisiert sich auf die Interaktionslogik zwischen Fenstern und Workspaces.  
* **Komplexitätsmanagement:** Regeln für Fensterzuweisungen können komplex werden (z.B. automatische Zuweisung basierend auf Fenstertyp, Anwendungsregeln). Ein dediziertes Modul erleichtert die Handhabung dieser Komplexität.  
* **Testbarkeit:** Die Zuweisungslogik kann isoliert getestet werden.

Dieses Modul interagiert eng mit workspaces::core (um Fenster-IDs in einem Workspace-Objekt zu modifizieren) und wird typischerweise vom workspaces::manager aufgerufen.

### **3.2. Datenstrukturen und Interaktionen**

Dieses Modul operiert primär mit Workspace-Instanzen (aus workspaces::core) und WindowIdentifier-Typen. Es führt selbst keine persistenten Datenstrukturen ein, sondern modifiziert die ihm übergebenen Workspace-Objekte. Für seine Operationen benötigt es Zugriff auf die Sammlung aller relevanten Workspaces, die typischerweise vom workspaces::manager als HashMap\<WorkspaceId, Workspace\> bereitgestellt wird.  
Spezifische temporäre Datenstrukturen könnten hier definiert werden, falls komplexe Zuweisungsalgorithmen (z.B. für automatische Platzierung in Tiling-Layouts) implementiert werden müssten. Für die grundlegende Zuweisung eines Fensters zu einem bestimmten Workspace sind solche Strukturen jedoch in der Regel nicht erforderlich. Die Logik für Layout-spezifische Platzierung ist eher im Modul domain::window\_management angesiedelt.

### **3.3. Öffentliche API: Methoden und Funktionen**

Die Funktionalität dieses Moduls wird durch freistehende Funktionen bereitgestellt, die auf einer veränderbaren Sammlung von Workspaces operieren. Diese Funktionen befinden sich im Modul domain::workspaces::assignment.  
**Tabelle: API-Funktionen für workspaces::assignment**

| Funktion (Rust-Signatur) | Kurzbeschreibung | Vorbedingungen | Nachbedingungen | Ausgelöste Events (indirekt) | Mögliche Fehler (WindowAssignmentError) |
| :---- | :---- | :---- | :---- | :---- | :---- |
| pub fn assign\_window\_to\_workspace(workspaces: \&mut std::collections::HashMap\<WorkspaceId, Workspace\>, target\_workspace\_id: WorkspaceId, window\_id: \&WindowIdentifier, ensure\_unique\_assignment: bool) \-\> Result\<(), WindowAssignmentError\> | Weist ein Fenster einem spezifischen Workspace zu. | target\_workspace\_id muss als Schlüssel in workspaces existieren. | Das Fenster window\_id ist dem Workspace target\_workspace\_id zugeordnet. Falls ensure\_unique\_assignment true ist, wird das Fenster von allen anderen Workspaces in der workspaces-Sammlung entfernt. | WindowAddedToWorkspace, WindowRemovedFromWorkspace (via manager) | WorkspaceNotFound (für target\_workspace\_id), WindowAlreadyAssigned (falls bereits auf Ziel-WS und ensure\_unique\_assignment ist false oder irrelevant), RuleViolation |
| pub fn remove\_window\_from\_workspace(workspaces: \&mut std::collections::HashMap\<WorkspaceId, Workspace\>, source\_workspace\_id: WorkspaceId, window\_id: \&WindowIdentifier) \-\> Result\<bool, WindowAssignmentError\> | Entfernt ein Fenster von einem spezifischen Workspace. | source\_workspace\_id muss als Schlüssel in workspaces existieren. | Das Fenster window\_id ist nicht mehr dem Workspace source\_workspace\_id zugeordnet. Gibt true zurück, wenn das Fenster entfernt wurde, false wenn es nicht auf dem Workspace war. | WindowRemovedFromWorkspace (via manager) | WorkspaceNotFound (für source\_workspace\_id) |
| pub fn move\_window\_to\_workspace(workspaces: \&mut std::collections::HashMap\<WorkspaceId, Workspace\>, source\_workspace\_id: WorkspaceId, target\_workspace\_id: WorkspaceId, window\_id: \&WindowIdentifier) \-\> Result\<(), WindowAssignmentError\> | Verschiebt ein Fenster von einem Quell-Workspace zu einem Ziel-Workspace. | source\_workspace\_id und target\_workspace\_id müssen in workspaces existieren. window\_id muss dem source\_workspace\_id zugeordnet sein. source\_workspace\_id und target\_workspace\_id dürfen nicht identisch sein. | Das Fenster window\_id ist vom source\_workspace\_id entfernt und dem target\_workspace\_id hinzugefügt. Andere Workspaces bleiben unberührt (d.h. es wird nicht implizit von einem dritten Workspace entfernt, falls es dort auch war, es sei denn, die interne Logik von assign\_window\_to\_workspace mit ensure\_unique\_assignment=true wird genutzt). | WindowRemovedFromWorkspace, WindowAddedToWorkspace (via manager) | SourceWorkspaceNotFound, TargetWorkspaceNotFound, WindowNotOnSourceWorkspace, CannotMoveToSameWorkspace, RuleViolation |
| pub fn find\_workspace\_for\_window(workspaces: \&std::collections::HashMap\<WorkspaceId, Workspace\>, window\_id: \&WindowIdentifier) \-\> Option\<WorkspaceId\> | Findet die ID des Workspace, dem ein bestimmtes Fenster aktuell zugeordnet ist. | \- | Gibt Some(WorkspaceId) zurück, wenn das Fenster einem Workspace in der Sammlung zugeordnet ist, sonst None. | \- | \- |

Die explizite Übergabe der workspaces-Sammlung an jede Funktion unterstreicht die Rolle dieses Moduls als Dienstleister, der auf Daten operiert, die vom workspaces::manager gehalten und verwaltet werden. Der Parameter ensure\_unique\_assignment in assign\_window\_to\_workspace ermöglicht es dem Aufrufer (typischerweise dem manager), die globale Regel "ein Fenster nur auf einem Workspace" durchzusetzen.

### **3.4. Events: Definition und Semantik**

Das Modul workspaces::assignment löst selbst keine Events aus. Änderungen an den Workspace-Objekten (Hinzufügen oder Entfernen von window\_ids) werden direkt auf diesen Objekten vorgenommen. Der workspaces::manager, der die Funktionen dieses Moduls aufruft, ist dafür verantwortlich, die entsprechenden Events zu publizieren (z.B. WindowAddedToWorkspace oder WindowRemovedFromWorkspace, unter Verwendung der in workspaces::core::event\_data definierten Payload-Strukturen). Diese Entkopplung hält das assignment-Modul fokussiert auf seine Kernlogik.

### **3.5. Fehlerbehandlung: WindowAssignmentError**

Für Fehler, die spezifisch bei Fensterzuweisungsoperationen auftreten, wird das WindowAssignmentError-Enum definiert.

* **Definition:**  
  Rust  
  // src/domain/workspaces/assignment/errors.rs  
  use thiserror::Error;  
  use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier};

  \#  
  pub enum WindowAssignmentError {  
      \#  
      WorkspaceNotFound(WorkspaceId), // Gilt für Ziel- oder Quell-Workspaces, je nach Kontext

      \#\[error("Window '{window\_id}' is already assigned to workspace '{workspace\_id}'. No action taken.")\]  
      WindowAlreadyAssigned { workspace\_id: WorkspaceId, window\_id: WindowIdentifier },

      \#\[error("Window '{window\_id}' is not assigned to workspace '{workspace\_id}', so it cannot be removed from it.")\]  
      WindowNotAssigned { workspace\_id: WorkspaceId, window\_id: WindowIdentifier }, // Spezifischer für Entfernungsoperationen

      \#  
      SourceWorkspaceNotFound(WorkspaceId),

      \#  
      TargetWorkspaceNotFound(WorkspaceId),

      \#\[error("Window '{window\_id}' not found on source workspace '{workspace\_id}' and thus cannot be moved.")\]  
      WindowNotOnSourceWorkspace { workspace\_id: WorkspaceId, window\_id: WindowIdentifier },

      \#\[error("Cannot move window '{window\_id}' from workspace '{workspace\_id}' to itself.")\]  
      CannotMoveToSameWorkspace { workspace\_id: WorkspaceId, window\_id: WindowIdentifier },

      \#  
      RuleViolation {  
          reason: String,  
          window\_id: Option\<WindowIdentifier\>,  
          target\_workspace\_id: Option\<WorkspaceId\>,  
      }, // Für spezifische, nicht abgedeckte Regeln

      \#\[error("An internal error occurred in window assignment logic: {context}")\]  
      Internal { context: String },  
  }

* Erläuterung und Anwendung von Fehlerbehandlungsprinzipien:  
  Die Definition von WindowAssignmentError folgt denselben Prinzipien wie WorkspaceCoreError unter Verwendung von thiserror.1 Die Varianten sind spezifisch für Zuweisungsoperationen und beinhalten relevante Identifikatoren, um den Kontext des Fehlers klar zu machen.1  
  Ein wichtiger Aspekt ist die Behandlung von Geschäftsregeln. Die Variante RuleViolation { reason,... } dient als flexibler Mechanismus, um Verletzungen von Zuweisungsregeln zu signalisieren, die nicht durch spezifischere Fehlervarianten abgedeckt sind. Es ist jedoch zu bedenken, dass eine programmatische Reaktion auf einen Fehler, der nur einen allgemeinen reason: String enthält, schwierig ist. Daher gilt: Für klar definierte, häufig auftretende oder kritische Geschäftsregeln der Fensterzuweisung *sollten* spezifische Fehlervarianten erstellt werden. Beispielsweise, wenn eine Regel besagt, dass bestimmte Fenstertypen nicht auf bestimmten Workspaces platziert werden dürfen, wäre ein Fehler wie DisallowedWindowTypeForWorkspace { window\_type: String, workspace\_id: WorkspaceId } aussagekräftiger als eine generische RuleViolation. Die RuleViolation-Variante dient dann als Fallback für dynamischere oder weniger häufige Regeln. Die Spezifikation sollte die wichtigsten Zuweisungsregeln identifizieren und dafür sorgen, dass dedizierte Fehler definiert werden, falls eine spezifische programmatische Behandlung durch den Aufrufer erforderlich ist. Dies steht im Einklang mit der Diskussion über die Granularität von Fehlertypen.2

**Tabelle: WindowAssignmentError Varianten**

| Variante | \#\[error("...")\]-Meldung (Auszug) | Semantische Bedeutung/Ursache | Enthaltene Datenfelder |
| :---- | :---- | :---- | :---- |
| WorkspaceNotFound(WorkspaceId) | "Workspace with ID '{0}' not found." | Ein angegebener Workspace (Quelle oder Ziel) existiert nicht in der übergebenen Sammlung. | Die ID des nicht gefundenen Workspace (WorkspaceId). |
| WindowAlreadyAssigned | "Window '{window\_id}' is already assigned..." | Es wurde versucht, ein Fenster einem Workspace zuzuweisen, dem es bereits zugeordnet ist (und keine weitere Aktion ist nötig/erwünscht). | workspace\_id: WorkspaceId, window\_id: WindowIdentifier. |
| WindowNotAssigned | "Window '{window\_id}' is not assigned..." | Es wurde versucht, ein Fenster von einem Workspace zu entfernen, dem es nicht zugeordnet ist. | workspace\_id: WorkspaceId, window\_id: WindowIdentifier. |
| SourceWorkspaceNotFound(WorkspaceId) | "Source workspace with ID '{0}' not found..." | Der Quell-Workspace für eine Verschiebungsoperation wurde nicht gefunden. | Die ID des Quell-Workspace (WorkspaceId). |
| TargetWorkspaceNotFound(WorkspaceId) | "Target workspace with ID '{0}' not found..." | Der Ziel-Workspace für eine Verschiebungsoperation wurde nicht gefunden. | Die ID des Ziel-Workspace (WorkspaceId). |
| WindowNotOnSourceWorkspace | "Window '{window\_id}' not found on source..." | Das zu verschiebende Fenster befindet sich nicht auf dem angegebenen Quell-Workspace. | workspace\_id: WorkspaceId, window\_id: WindowIdentifier. |
| CannotMoveToSameWorkspace | "Cannot move window... to itself." | Es wurde versucht, ein Fenster auf denselben Workspace zu verschieben, auf dem es sich bereits befindet. | workspace\_id: WorkspaceId, window\_id: WindowIdentifier. |
| RuleViolation | "A window assignment rule was violated: {reason}..." | Eine spezifische Geschäftsregel der Fensterzuweisung wurde verletzt. | reason: String, window\_id: Option\<WindowIdentifier\>, target\_workspace\_id: Option\<WorkspaceId\>. |
| Internal { context: String } | "An internal error occurred..." | Ein unerwarteter Fehler in der Zuweisungslogik. | context: String. |

### **3.6. Detaillierte Implementierungsschritte und Dateistruktur**

* **Dateistruktur innerhalb von src/domain/workspaces/assignment/:**  
  * mod.rs: Enthält die Implementierung der öffentlichen Zuweisungsfunktionen (assign\_window\_to\_workspace, remove\_window\_from\_workspace, move\_window\_to\_workspace, find\_workspace\_for\_window).  
  * errors.rs: Enthält die Definition des WindowAssignmentError-Enums.  
  * rules.rs (optional): Dieses Modul könnte interne Hilfsfunktionen oder Datenstrukturen enthalten, die spezifische Zuweisungsregeln kapseln (z.B. Überprüfung der "Fenster-Exklusivität"). Diese würden dann von den Hauptfunktionen in mod.rs genutzt.  
* **Implementierungsschritte:**  
  1. Definiere das WindowAssignmentError-Enum in errors.rs gemäß der Spezifikation in Abschnitt 3.5.  
  2. Implementiere pub fn assign\_window\_to\_workspace(...) in mod.rs:  
     * Überprüfe, ob target\_workspace\_id in workspaces existiert. Falls nicht, gib Err(WindowAssignmentError::WorkspaceNotFound(target\_workspace\_id)) zurück.  
     * Hole eine veränderbare Referenz auf den target\_workspace.  
     * Falls ensure\_unique\_assignment true ist:  
       * Iteriere über alle Workspaces in der workspaces-Sammlung (außer dem target\_workspace).  
       * Wenn ein anderer Workspace das window\_id enthält, rufe dessen remove\_window\_id(window\_id) Methode auf.  
     * Rufe target\_workspace.add\_window\_id(window\_id.clone()) auf. Wenn diese false zurückgibt (Fenster war bereits vorhanden), und dies als Fehlerfall betrachtet wird (abhängig von der genauen Semantik/Regeln), gib Err(WindowAssignmentError::WindowAlreadyAssigned {... }) zurück.  
     * Gib Ok(()) zurück.  
  3. Implementiere pub fn remove\_window\_from\_workspace(...) in mod.rs:  
     * Überprüfe, ob source\_workspace\_id in workspaces existiert. Falls nicht, gib Err(WindowAssignmentError::WorkspaceNotFound(source\_workspace\_id)) zurück.  
     * Hole eine veränderbare Referenz auf den source\_workspace.  
     * Rufe source\_workspace.remove\_window\_id(window\_id) auf und gib Ok(result) zurück. (Der Fehlerfall WindowNotAssigned wird hier nicht direkt von dieser Funktion erzeugt, da Workspace::remove\_window\_id nur bool zurückgibt. Der manager könnte dies interpretieren oder es wird angenommen, dass ein Aufruf zum Entfernen eines nicht vorhandenen Fensters kein Fehler ist, sondern einfach keine Aktion bewirkt und false zurückgibt). Alternativ könnte hier geprüft werden, ob das Fenster vorher drin war und bei false ein WindowNotAssigned Fehler erzeugt werden, falls das die gewünschte Semantik ist. Gemäß der Tabelle soll remove\_window\_from\_workspace Result\<bool,...\> zurückgeben, also ist die aktuelle Signatur von Workspace::remove\_window\_id ausreichend.  
  4. Implementiere pub fn move\_window\_to\_workspace(...) in mod.rs:  
     * Überprüfe, ob source\_workspace\_id und target\_workspace\_id identisch sind. Falls ja, gib Err(WindowAssignmentError::CannotMoveToSameWorkspace {... }) zurück.  
     * Überprüfe Existenz von source\_workspace (Fehler: SourceWorkspaceNotFound) und target\_workspace (Fehler: TargetWorkspaceNotFound).  
     * Hole Referenzen zu beiden Workspaces.  
     * Versuche, window\_id vom source\_workspace zu entfernen. Rufe source\_workspace.remove\_window\_id(window\_id) auf. Wenn dies false zurückgibt (Fenster war nicht auf Quelle), gib Err(WindowAssignmentError::WindowNotOnSourceWorkspace {... }) zurück.  
     * Füge window\_id zum target\_workspace hinzu. Rufe target\_workspace.add\_window\_id(window\_id.clone()) auf. (Die ensure\_unique\_assignment-Logik ist hier nicht direkt anwendbar, da wir explizit von einer Quelle zu einem Ziel verschieben. Es wird angenommen, dass das Fenster nach dem Entfernen von der Quelle nur noch dem Ziel hinzugefügt werden muss.)  
     * Gib Ok(()) zurück.  
  5. Implementiere pub fn find\_workspace\_for\_window(...) in mod.rs:  
     * Iteriere über die workspaces-Sammlung.  
     * Für jeden Workspace, prüfe, ob dessen window\_ids das gesuchte window\_id enthält.  
     * Wenn gefunden, gib Some(workspace.id()) zurück.  
     * Wenn die Iteration ohne Fund endet, gib None zurück.  
  6. Füge umfassende rustdoc-Kommentare für alle öffentlichen Funktionen hinzu.  
  7. Erstelle Unit-Tests im Untermodul tests in mod.rs. Teste alle Funktionen gründlich, einschließlich:  
     * Erfolgreiche Zuweisung, Entfernung und Verschiebung von Fenstern.  
     * Korrekte Handhabung der ensure\_unique\_assignment-Logik.  
     * Alle Fehlerfälle (nicht gefundene Workspaces, Fenster nicht auf Quell-Workspace, etc.).  
     * Randbedingungen (z.B. leere workspaces-Sammlung).  
     * Funktionalität von find\_workspace\_for\_window.

## **4\. Entwicklungsmodul 3: workspaces::manager – Orchestrierung und übergeordnete Verwaltung**

Das Modul workspaces::manager agiert als zentraler Orchestrator für alle Workspace-bezogenen Operationen. Es verwaltet die Gesamtheit der Workspaces, den Zustand des aktiven Workspace und dient als primäre Schnittstelle für andere Systemteile.

### **4.1. Verantwortlichkeiten und Design-Rationale**

Die Kernverantwortlichkeiten des WorkspaceManager sind:

* **Verwaltung der Workspace-Sammlung:** Halten und Pflegen einer Liste aller existierenden Workspace-Instanzen.  
* **Lebenszyklusmanagement:** Erstellung, Löschung und Modifikation von Workspaces.  
* **Zustandsmanagement des aktiven Workspace:** Verfolgen, welcher Workspace aktuell aktiv ist, und Ermöglichen des Wechsels.  
* **Orchestrierung von Operationen:** Koordination von Aktionen, die mehrere Workspaces betreffen oder globale Auswirkungen haben.  
* **Event-Publikation:** Benachrichtigung anderer Systemteile über signifikante Änderungen im Workspace-System (z.B. Erstellung, Löschung, Aktivierung eines Workspace, Fensterzuweisungen).  
* **Schnittstelle:** Bereitstellung einer kohärenten API für die System- und UI-Schicht zur Interaktion mit dem Workspace-System.

Das Design zielt darauf ab, die Komplexität der Workspace-Verwaltung an einem zentralen Ort zu bündeln. Dies fördert die Konsistenz des Gesamtzustands und vereinfacht die Interaktion für andere Komponenten, da sie nur mit dem WorkspaceManager und nicht mit einzelnen Workspace-Objekten oder dem assignment-Modul direkt kommunizieren müssen.

### **4.2. Interaktion mit anderen Modulen und externen Schnittstellen**

Der WorkspaceManager interagiert mit mehreren anderen Modulen:

* **workspaces::core:** Erstellt und hält Instanzen von Workspace-Objekten. Ruft Methoden auf diesen Objekten auf (z.B. rename, set\_layout\_type).  
* **workspaces::assignment:** Nutzt die Funktionen dieses Moduls (z.B. assign\_window\_to\_workspace) zur Durchführung der Logik für Fensterzuweisungen.  
* **workspaces::config:** Interagiert mit einem WorkspaceConfigProvider (aus workspaces::config), um die Workspace-Konfiguration beim Start zu laden und Änderungen zu persistieren.  
* **Event-System (nicht spezifiziert, aber implizit):** Benötigt einen Mechanismus zum Publizieren von WorkspaceEvents. Dies könnte ein interner Event-Bus, ein tokio::sync::broadcast Channel oder eine ähnliche Struktur sein. Für diese Spezifikation wird angenommen, dass ein solcher Mechanismus existiert und vom WorkspaceManager genutzt werden kann.  
* **Systemschicht:** Wird vom WorkspaceManager über Änderungen informiert (z.B. welcher Workspace aktiv ist, welche Fenster wo sind) und informiert den WorkspaceManager über Systemereignisse (z.B. neue Fenster).  
* **UI-Schicht:** Nutzt die API des WorkspaceManager zur Darstellung und Manipulation von Workspaces und reagiert auf WorkspaceEvents.

### **4.3. Öffentliche API: Methoden und Funktionen**

Die öffentliche API wird durch das WorkspaceManager-Struct und dessen Methoden bereitgestellt.

* **Struct-Definition:**  
  Rust  
  // src/domain/workspaces/manager/mod.rs  
  use std::collections::HashMap;  
  use std::sync::Arc;  
  use uuid::Uuid;  
  use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};  
  use crate::domain::workspaces::core::Workspace;  
  use crate::domain::workspaces::core::event\_data::\*;  
  use crate::domain::workspaces::assignment;  
  use crate::domain::workspaces::config::{WorkspaceConfigProvider, WorkspaceSetSnapshot, WorkspaceSnapshot};  
  use crate::domain::workspaces::manager::errors::WorkspaceManagerError;  
  use crate::domain::workspaces::manager::events::WorkspaceEvent; // Und Event-Publisher

  // Annahme: Ein Event-Publisher Trait oder eine konkrete Implementierung  
  pub trait EventPublisher\<E\>: Send \+ Sync {  
      fn publish(\&self, event: E);  
  }

  pub struct WorkspaceManager {  
      workspaces: HashMap\<WorkspaceId, Workspace\>,  
      active\_workspace\_id: Option\<WorkspaceId\>,  
      // Hält die Reihenfolge der Workspaces für UI-Darstellung oder Wechsel-Logik  
      ordered\_workspace\_ids: Vec\<WorkspaceId\>,  
      next\_workspace\_number: u32, // Für Standardnamen wie "Workspace 1"  
      config\_provider: Arc\<dyn WorkspaceConfigProvider\>,  
      event\_publisher: Arc\<dyn EventPublisher\<WorkspaceEvent\>\>, // Zum Publizieren von Events  
      ensure\_unique\_window\_assignment: bool, // Konfigurierbare Regel  
  }

  Die ordered\_workspace\_ids sind wichtig, um eine konsistente Reihenfolge für UI-Elemente wie Pager oder für "Nächster/Vorheriger Workspace"-Aktionen zu gewährleisten. ensure\_unique\_window\_assignment macht die wichtige Regel der Fensterzuweisung explizit konfigurierbar.  
* **Methoden der impl WorkspaceManager:**

**Tabelle: API-Methoden für workspaces::manager::WorkspaceManager**

| Methode (Rust-Signatur) | Kurzbeschreibung | Vor-/Nachbedingungen | Ausgelöste Events | Mögliche Fehler (WorkspaceManagerError) |
| :---- | :---- | :---- | :---- | :---- |
| pub fn new(config\_provider: Arc\<dyn WorkspaceConfigProvider\>, event\_publisher: Arc\<dyn EventPublisher\<WorkspaceEvent\>\>, ensure\_unique\_window\_assignment: bool) \-\> Result\<Self, WorkspaceManagerError\> | Initialisiert den Manager. Lädt Konfiguration, setzt Standard-Workspaces falls keine Konfig vorhanden. | \- | Manager ist initialisiert. Workspaces sind geladen oder Standard-Workspaces erstellt. active\_workspace\_id ist gesetzt. | WorkspaceCreated (falls Standard-WS erstellt), ActiveWorkspaceChanged |
| pub fn create\_workspace(\&mut self, name: Option\<String\>, persistent\_id: Option\<String\>) \-\> Result\<WorkspaceId, WorkspaceManagerError\> | Erstellt einen neuen Workspace, fügt ihn zur Sammlung hinzu. | Name (falls Some) und persistent\_id (falls Some) müssen gültig sein. | Neuer Workspace ist erstellt, zur Sammlung und ordered\_workspace\_ids hinzugefügt. | WorkspaceCreated |
| pub fn delete\_workspace(\&mut self, id: WorkspaceId, fallback\_id\_for\_windows: Option\<WorkspaceId\>) \-\> Result\<(), WorkspaceManagerError\> | Löscht einen Workspace. Fenster werden ggf. auf einen Fallback-Workspace verschoben. | Darf nicht der letzte Workspace sein. fallback\_id\_for\_windows muss existieren, falls Fenster verschoben werden müssen und der Workspace nicht leer ist. | Workspace ist gelöscht. Fenster sind verschoben. Ggf. neuer aktiver Workspace. | WorkspaceDeleted, ActiveWorkspaceChanged, WindowRemovedFromWorkspace, WindowAddedToWorkspace |
| pub fn get\_workspace(\&self, id: WorkspaceId) \-\> Option\<\&Workspace\> | Gibt eine Referenz auf einen Workspace anhand seiner ID zurück. | \- | \- | \- |
| pub fn get\_workspace\_mut(\&mut self, id: WorkspaceId) \-\> Option\<\&mut Workspace\> | Gibt eine veränderbare Referenz auf einen Workspace anhand seiner ID zurück. | \- | \- | \- |
| pub fn all\_workspaces\_ordered(\&self) \-\> Vec\<\&Workspace\> | Gibt eine geordnete Liste aller Workspaces zurück. | \- | \- | \- |
| pub fn active\_workspace\_id(\&self) \-\> Option\<WorkspaceId\> | Gibt die ID des aktuell aktiven Workspace zurück. | \- | \- | \- |
| pub fn set\_active\_workspace(\&mut self, id: WorkspaceId) \-\> Result\<(), WorkspaceManagerError\> | Setzt den aktiven Workspace. | id muss ein existierender Workspace sein. | active\_workspace\_id ist auf id gesetzt. | ActiveWorkspaceChanged |
| pub fn assign\_window\_to\_active\_workspace(\&mut self, window\_id: \&WindowIdentifier) \-\> Result\<(), WorkspaceManagerError\> | Weist ein Fenster dem aktiven Workspace zu. | Ein aktiver Workspace muss existieren. | Fenster ist dem aktiven Workspace zugeordnet. | WindowAddedToWorkspace, WindowRemovedFromWorkspace (falls ensure\_unique\_window\_assignment) |
| pub fn assign\_window\_to\_specific\_workspace(\&mut self, workspace\_id: WorkspaceId, window\_id: \&WindowIdentifier) \-\> Result\<(), WorkspaceManagerError\> | Weist ein Fenster einem spezifischen Workspace zu. | workspace\_id muss existieren. | Fenster ist dem workspace\_id zugeordnet. | WindowAddedToWorkspace, WindowRemovedFromWorkspace (falls ensure\_unique\_window\_assignment) |
| pub fn remove\_window\_from\_its\_workspace(\&mut self, window\_id: \&WindowIdentifier) \-\> Result\<Option\<WorkspaceId\>, WorkspaceManagerError\> | Entfernt ein Fenster von dem Workspace, dem es aktuell zugeordnet ist. Gibt die ID des Workspace zurück, von dem es entfernt wurde. | \- | Fenster ist keinem Workspace mehr zugeordnet (oder dem, dem es explizit zugewiesen war). | WindowRemovedFromWorkspace |
| pub fn move\_window\_to\_specific\_workspace(\&mut self, target\_workspace\_id: WorkspaceId, window\_id: \&WindowIdentifier) \-\> Result\<(), WorkspaceManagerError\> | Verschiebt ein Fenster von seinem aktuellen Workspace zu einem spezifischen Ziel-Workspace. | target\_workspace\_id muss existieren. Fenster muss einem Workspace zugeordnet sein. | Fenster ist dem target\_workspace\_id zugeordnet und vom vorherigen entfernt. | WindowRemovedFromWorkspace, WindowAddedToWorkspace |
| pub fn rename\_workspace(\&mut self, id: WorkspaceId, new\_name: String) \-\> Result\<(), WorkspaceManagerError\> | Benennt einen Workspace um. | id muss existieren. new\_name muss gültig sein. | Workspace ist umbenannt. | WorkspaceRenamed |
| pub fn set\_workspace\_layout(\&mut self, id: WorkspaceId, layout\_type: WorkspaceLayoutType) \-\> Result\<(), WorkspaceManagerError\> | Ändert den Layout-Typ eines Workspace. | id muss existieren. | Layout-Typ ist geändert. | WorkspaceLayoutChanged |
| pub fn save\_configuration(\&self) \-\> Result\<(), WorkspaceManagerError\> | Speichert die aktuelle Workspace-Konfiguration (Namen, persistente IDs, Reihenfolge, aktiver Workspace). | \- | Konfiguration ist gespeichert. | \- |

### **4.4. Events: Definition und Semantik**

Der WorkspaceManager ist der primäre Publisher für alle Workspace-bezogenen Events. Diese Events informieren andere Teile des Systems über Zustandsänderungen.

* **Event-Enum: WorkspaceEvent**  
  Rust  
  // src/domain/workspaces/manager/events.rs  
  use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};  
  use crate::domain::workspaces::core::event\_data::\*; // Importiert Payloads wie WorkspaceRenamedData

  \#  
  pub enum WorkspaceEvent {  
      WorkspaceCreated {  
          id: WorkspaceId,  
          name: String,  
          persistent\_id: Option\<String\>,  
          position: usize, // Position in der geordneten Liste  
      },  
      WorkspaceDeleted {  
          id: WorkspaceId,  
          // ID des Workspace, auf den Fenster verschoben wurden, falls zutreffend  
          windows\_moved\_to\_workspace\_id: Option\<WorkspaceId\>,  
      },  
      ActiveWorkspaceChanged {  
          old\_id: Option\<WorkspaceId\>,  
          new\_id: WorkspaceId,  
      },  
      WorkspaceRenamed(WorkspaceRenamedData), // Nutzt Payload aus core::event\_data  
      WorkspaceLayoutChanged(WorkspaceLayoutChangedData), // Nutzt Payload aus core::event\_data  
      WindowAddedToWorkspace(WindowAddedToWorkspaceData), // Nutzt Payload aus core::event\_data  
      WindowRemovedFromWorkspace(WindowRemovedFromWorkspaceData), // Nutzt Payload aus core::event\_data  
      WorkspaceOrderChanged(Vec\<WorkspaceId\>), // Die neue, vollständige Reihenfolge der Workspace-IDs  
      WorkspacesReloaded(Vec\<WorkspaceId\>), // Signalisiert, dass Workspaces neu geladen wurden (z.B. aus Konfig)  
      WorkspacePersistentIdChanged(WorkspacePersistentIdChangedData), // Nutzt Payload aus core::event\_data  
  }

* **Publisher:** WorkspaceManager (über den injizierten event\_publisher).  
* **Typische Subscriber:**  
  * **UI-Schicht:** Aktualisiert die Darstellung von Workspaces, Panels, Fensterlisten etc.  
  * **domain::window\_management:** Reagiert auf Layout-Änderungen oder Änderungen des aktiven Workspace, um Fenster entsprechend anzuordnen oder Fokus zu setzen.  
  * **Systemschicht (Compositor):** Passt die Sichtbarkeit von Fenstern/Surfaces an, wenn sich der aktive Workspace ändert.  
  * **Logging/Tracing-Systeme:** Protokollieren Workspace-bezogene Aktivitäten.

**Tabelle: WorkspaceEvent Varianten**

| Event-Variante | Payload-Struktur/Daten | Semantische Bedeutung | Typische Auslöser (Manager-Methode) |
| :---- | :---- | :---- | :---- |
| WorkspaceCreated | id, name, persistent\_id, position | Ein neuer Workspace wurde erstellt und der Sammlung hinzugefügt. | create\_workspace, Initialisierung |
| WorkspaceDeleted | id, windows\_moved\_to\_workspace\_id | Ein Workspace wurde gelöscht. | delete\_workspace |
| ActiveWorkspaceChanged | old\_id, new\_id | Der aktive Workspace hat sich geändert. | set\_active\_workspace, delete\_workspace (falls aktiver gelöscht) |
| WorkspaceRenamed | WorkspaceRenamedData | Ein Workspace wurde umbenannt. | rename\_workspace |
| WorkspaceLayoutChanged | WorkspaceLayoutChangedData | Der Layout-Typ eines Workspace wurde geändert. | set\_workspace\_layout |
| WindowAddedToWorkspace | WindowAddedToWorkspaceData | Ein Fenster wurde einem Workspace hinzugefügt. | assign\_window\_to\_active\_workspace, assign\_window\_to\_specific\_workspace, move\_window\_to\_specific\_workspace |
| WindowRemovedFromWorkspace | WindowRemovedFromWorkspaceData | Ein Fenster wurde von einem Workspace entfernt. | remove\_window\_from\_its\_workspace, move\_window\_to\_specific\_workspace, delete\_workspace |
| WorkspaceOrderChanged | Vec\<WorkspaceId\> | Die Reihenfolge der Workspaces hat sich geändert. | (Noch nicht spezifizierte Methoden wie move\_workspace\_left/right) |
| WorkspacesReloaded | Vec\<WorkspaceId\> | Die Workspace-Konfiguration wurde neu geladen. | new (bei Initialisierung aus Konfig) |
| WorkspacePersistentIdChanged | WorkspacePersistentIdChangedData | Die persistente ID eines Workspace wurde geändert. | (Indirekt durch Workspace::set\_persistent\_id via Manager) |

### **4.5. Fehlerbehandlung: WorkspaceManagerError**

Das WorkspaceManagerError-Enum fasst Fehler zusammen, die auf der Ebene des Managers auftreten können, einschließlich Fehlern aus den unterlagerten Modulen.

* **Definition:**  
  Rust  
  // src/domain/workspaces/manager/errors.rs  
  use thiserror::Error;  
  use crate::domain::workspaces::core::types::WorkspaceId;  
  use crate::domain::workspaces::core::errors::WorkspaceCoreError;  
  use crate::domain::workspaces::assignment::errors::WindowAssignmentError;  
  use crate::domain::workspaces::config::errors::WorkspaceConfigError;

  \#  
  pub enum WorkspaceManagerError {  
      \#  
      WorkspaceNotFound(WorkspaceId),

      \#\[error("Cannot delete the last workspace. At least one workspace must remain.")\]  
      CannotDeleteLastWorkspace,

      \#  
      DeleteRequiresFallbackForWindows(WorkspaceId),

      \#  
      FallbackWorkspaceNotFound(WorkspaceId),

      \#\[error("A workspace core operation failed: {source}")\]  
      CoreError { \#\[from\] source: WorkspaceCoreError },

      \#\[error("A window assignment operation failed: {source}")\]  
      AssignmentError { \#\[from\] source: WindowAssignmentError },

      \#\[error("A workspace configuration operation failed: {source}")\]  
      ConfigError { \#\[from\] source: WorkspaceConfigError },

      \#\[error("Attempted to set a non-existent workspace '{0}' as active.")\]  
      SetActiveWorkspaceNotFound(WorkspaceId),

      \#\[error("No active workspace is set, but the operation requires one.")\]  
      NoActiveWorkspace,

      \#  
      DuplicatePersistentId(String),

      \#\[error("An internal error occurred in the workspace manager: {context}")\]  
      Internal { context: String },  
  }

* Erläuterung und Anwendung von Fehlerbehandlungsprinzipien:  
  WorkspaceManagerError verwendet thiserror und das \#\[from\]-Attribut, um Fehler aus den Modulen core, assignment und config elegant zu wrappen.1 Dies ist ein zentrales Muster für die Fehleraggregation in übergeordneten Komponenten. Die source()-Kette bleibt dabei erhalten, was für die Fehlerdiagnose kritisch ist.3 Wenn beispielsweise WorkspaceManager::rename\_workspace aufgerufen wird und intern Workspace::rename einen WorkspaceCoreError::NameTooLong zurückgibt, wird dieser Fehler in einen WorkspaceManagerError::CoreError { source: WorkspaceCoreError::NameTooLong } umgewandelt. Der Aufrufer des WorkspaceManager kann dann error.source() verwenden, um an den ursprünglichen WorkspaceCoreError zu gelangen und dessen spezifische Details zu untersuchen. Diese Fähigkeit, die Fehlerursache über mehrere Abstraktionsebenen hinweg zurückzuverfolgen, ist für die Entwicklung robuster Software unerlässlich und wird durch die konsequente Anwendung von \#\[from\] und dem std::error::Error-Trait ermöglicht.1  
  Zusätzlich definiert das Enum spezifische Fehler, die nur in der Logik des Managers auftreten können, wie CannotDeleteLastWorkspace oder NoActiveWorkspace.

**Tabelle: WorkspaceManagerError Varianten**

| Variante | \#\[error("...")\]-Meldung (Auszug) | Semantische Bedeutung/Ursache | Enthaltene Daten/Quellfehler |
| :---- | :---- | :---- | :---- |
| WorkspaceNotFound(WorkspaceId) | "Workspace with ID '{0}' not found." | Ein referenzierter Workspace existiert nicht. | WorkspaceId des nicht gefundenen Workspace. |
| CannotDeleteLastWorkspace | "Cannot delete the last workspace..." | Es wurde versucht, den einzigen verbleibenden Workspace zu löschen. | \- |
| DeleteRequiresFallbackForWindows(WorkspaceId) | "Cannot delete workspace '{0}' because it contains windows..." | Ein Workspace mit Fenstern soll gelöscht werden, ohne einen Fallback anzugeben. | WorkspaceId des zu löschenden Workspace. |
| FallbackWorkspaceNotFound(WorkspaceId) | "The specified fallback workspace with ID '{0}' was not found..." | Der angegebene Fallback-Workspace existiert nicht. | WorkspaceId des nicht gefundenen Fallback-Workspace. |
| CoreError | "A workspace core operation failed..." | Fehler aus workspaces::core. | source: WorkspaceCoreError. |
| AssignmentError | "A window assignment operation failed..." | Fehler aus workspaces::assignment. | source: WindowAssignmentError. |
| ConfigError | "A workspace configuration operation failed..." | Fehler aus workspaces::config. | source: WorkspaceConfigError. |
| SetActiveWorkspaceNotFound(WorkspaceId) | "Attempted to set a non-existent workspace '{0}' as active." | Ein nicht existierender Workspace sollte als aktiv gesetzt werden. | WorkspaceId des nicht gefundenen Workspace. |
| NoActiveWorkspace | "No active workspace is set..." | Eine Operation wurde aufgerufen, die einen aktiven Workspace erfordert, aber keiner ist gesetzt. | \- |
| DuplicatePersistentId(String) | "Attempted to create a workspace with a persistent ID ('{0}') that already exists." | Eine persistente ID, die bereits verwendet wird, wurde für einen neuen Workspace angegeben. | Die duplizierte String ID. |
| Internal { context: String } | "An internal error occurred..." | Ein unerwarteter interner Fehler im Manager. | context: String. |

### **4.6. Detaillierte Implementierungsschritte und Dateistruktur**

* **Dateistruktur innerhalb von src/domain/workspaces/manager/:**  
  * mod.rs: Enthält die Definition des WorkspaceManager-Structs und die Implementierung seiner Methoden.  
  * errors.rs: Enthält die Definition des WorkspaceManagerError-Enums.  
  * events.rs: Enthält die Definition des WorkspaceEvent-Enums und ggf. des EventPublisher-Traits.  
* **Implementierungsschritte:**  
  1. Definiere WorkspaceEvent (und EventPublisher-Trait, falls nicht global vorhanden) in events.rs.  
  2. Definiere WorkspaceManagerError in errors.rs.  
  3. Implementiere das WorkspaceManager-Struct in mod.rs.  
  4. Implementiere pub fn new(...) \-\> Result\<Self, WorkspaceManagerError\>:  
     * Initialisiere workspaces als leere HashMap, ordered\_workspace\_ids als leeren Vec.  
     * Setze next\_workspace\_number auf 1\.  
     * Speichere config\_provider, event\_publisher, ensure\_unique\_window\_assignment.  
     * Versuche, die Konfiguration mittels self.config\_provider.load\_workspace\_config() zu laden.  
       * Bei Erfolg (Ok(snapshot)): Rekonstruiere Workspace-Objekte aus snapshot.workspaces. Füge sie zu self.workspaces und self.ordered\_workspace\_ids hinzu (Reihenfolge aus Snapshot beachten). Setze self.active\_workspace\_id basierend auf snapshot.active\_workspace\_persistent\_id (Suche nach Workspace mit passender persistent\_id). Aktualisiere next\_workspace\_number ggf. basierend auf den Namen der geladenen Workspaces. Publiziere WorkspacesReloaded und ActiveWorkspaceChanged.  
       * Bei Fehler (Err(config\_err)):  
         * Wenn der Fehler anzeigt, dass keine Konfiguration vorhanden ist (z.B. CoreConfigError::NotFound), erstelle einen Standard-Workspace (z.B. "Workspace 1"). Füge ihn hinzu, setze ihn als aktiv. Publiziere WorkspaceCreated, ActiveWorkspaceChanged.  
         * Andernfalls mappe den config\_err zu WorkspaceManagerError::ConfigError und gib ihn zurück.  
  5. Implementiere pub fn create\_workspace(...) \-\> Result\<WorkspaceId, WorkspaceManagerError\>:  
     * Falls persistent\_id Some ist, prüfe, ob bereits ein Workspace mit dieser persistent\_id existiert. Falls ja, Fehler DuplicatePersistentId.  
     * Bestimme den Namen: Falls name None ist, generiere einen Standardnamen (z.B. "Workspace {next\_workspace\_number}").  
     * Erstelle ein neues Workspace-Objekt via Workspace::new(final\_name, persistent\_id). Mappe WorkspaceCoreError zu CoreError.  
     * Füge den neuen Workspace zu self.workspaces und self.ordered\_workspace\_ids hinzu (z.B. am Ende).  
     * Inkrementiere next\_workspace\_number falls ein Standardname verwendet wurde.  
     * Publiziere WorkspaceEvent::WorkspaceCreated mit ID, Name, persistent\_id und Position.  
     * Rufe self.save\_configuration() auf.  
     * Gib Ok(new\_workspace.id()) zurück.  
  6. Implementiere pub fn delete\_workspace(...) \-\> Result\<(), WorkspaceManagerError\>:  
     * Prüfe, ob id existiert (Fehler: WorkspaceNotFound).  
     * Prüfe, ob es der letzte Workspace ist (Fehler: CannotDeleteLastWorkspace).  
     * Hole den zu löschenden Workspace. Wenn er Fenster enthält und fallback\_id\_for\_windows None ist, Fehler DeleteRequiresFallbackForWindows.  
     * Falls Fenster verschoben werden müssen:  
       * Prüfe, ob fallback\_id\_for\_windows existiert (Fehler: FallbackWorkspaceNotFound).  
       * Nutze assignment::move\_window\_to\_workspace (oder eine ähnliche Logik) für jedes Fenster, um es vom zu löschenden Workspace zum Fallback-Workspace zu verschieben. Mappe WindowAssignmentError zu AssignmentError. Publiziere WindowRemovedFromWorkspace und WindowAddedToWorkspace für jedes verschobene Fenster.  
     * Entferne den Workspace aus self.workspaces und self.ordered\_workspace\_ids.  
     * Falls der gelöschte Workspace der aktive war: Setze einen anderen Workspace als aktiv (z.B. den ersten in ordered\_workspace\_ids). Publiziere ActiveWorkspaceChanged.  
     * Publiziere WorkspaceEvent::WorkspaceDeleted.  
     * Rufe self.save\_configuration() auf.  
     * Gib Ok(()) zurück.  
  7. Implementiere die Getter-Methoden (get\_workspace, get\_workspace\_mut, all\_workspaces\_ordered, active\_workspace\_id). Für all\_workspaces\_ordered iteriere über ordered\_workspace\_ids und hole die entsprechenden Workspace-Referenzen aus workspaces.  
  8. Implementiere pub fn set\_active\_workspace(...) \-\> Result\<(), WorkspaceManagerError\>:  
     * Prüfe, ob id existiert (Fehler: SetActiveWorkspaceNotFound).  
     * Wenn id bereits aktiv ist, keine Aktion.  
     * Setze self.active\_workspace\_id \= Some(id).  
     * Publiziere WorkspaceEvent::ActiveWorkspaceChanged mit alter und neuer ID.  
     * Rufe self.save\_configuration() auf (optional, je nachdem ob der aktive Workspace persistiert werden soll).  
     * Gib Ok(()) zurück.  
  9. Implementiere Fensterzuweisungsmethoden (assign\_window\_to\_active\_workspace, assign\_window\_to\_specific\_workspace, remove\_window\_from\_its\_workspace, move\_window\_to\_specific\_workspace):  
     * Nutze die entsprechenden Funktionen aus dem workspaces::assignment-Modul.  
     * Übergebe \&mut self.workspaces und self.ensure\_unique\_window\_assignment (wo relevant).  
     * Mappe WindowAssignmentError zu WorkspaceManagerError::AssignmentError.  
     * Publiziere die relevanten Events (WindowAddedToWorkspace, WindowRemovedFromWorkspace) nach erfolgreicher Operation.  
  10. Implementiere rename\_workspace und set\_workspace\_layout:  
      * Hole \&mut Workspace (Fehler: WorkspaceNotFound).  
      * Rufe die entsprechende Methode auf dem Workspace-Objekt auf (rename oder set\_layout\_type). Mappe WorkspaceCoreError zu CoreError.  
      * Publiziere das entsprechende Event (WorkspaceRenamed oder WorkspaceLayoutChanged).  
      * Rufe self.save\_configuration() auf.  
  11. Implementiere pub fn save\_configuration(\&self) \-\> Result\<(), WorkspaceManagerError\>:  
      * Erstelle ein WorkspaceSetSnapshot. Fülle workspaces durch Iteration über self.ordered\_workspace\_ids und Erstellung von WorkspaceSnapshots für jeden Workspace (Name, persistente ID, Layout).  
      * Setze active\_workspace\_persistent\_id im Snapshot basierend auf der persistent\_id des aktuellen active\_workspace\_id.  
      * Rufe self.config\_provider.save\_workspace\_config(\&snapshot) auf. Mappe WorkspaceConfigError zu ConfigError.  
  12. Stelle sicher, dass alle Methoden umfassend mit rustdoc dokumentiert sind.  
  13. Erstelle Unit- und Integrationstests, die das Zusammenspiel der Module core, assignment, config und des Event-Publishings testen. Mocke WorkspaceConfigProvider und EventPublisher für die Tests.

## **5\. Entwicklungsmodul 4: workspaces::config – Konfigurations- und Persistenzlogik**

Das Modul workspaces::config ist dediziert für das Laden und Speichern der Konfiguration des Workspace-Systems zuständig.

### **5.1. Verantwortlichkeiten und Design-Rationale**

Die Hauptverantwortung dieses Moduls besteht darin, eine Abstraktion für die Persistenz von Workspace-bezogenen Daten bereitzustellen. Dies umfasst typischerweise:

* Namen und persistente IDs der Workspaces.  
* Standard-Layout-Typen pro Workspace.  
* Die Reihenfolge der Workspaces.  
* Die ID des zuletzt aktiven Workspace.

Es interagiert mit der core::config-Komponente der Kernschicht, um die tatsächlichen Lese- und Schreiboperationen aus bzw. in Konfigurationsdateien (oder andere Persistenzmechanismen) durchzuführen.  
Das Design-Rationale für dieses separate Modul ist die Entkopplung der Workspace-Verwaltungslogik (workspaces::manager) von den spezifischen Details der Konfigurationsspeicherung. Dies ermöglicht es, das Speicherformat (z.B. JSON, TOML, SQLite) oder den Speicherort zu ändern, ohne den WorkspaceManager modifizieren zu müssen, solange die WorkspaceConfigProvider-Schnittstelle eingehalten wird.

### **5.2. Datenstrukturen für Konfiguration und Interaktion mit core::config**

Für die Serialisierung und Deserialisierung der Workspace-Konfiguration werden spezielle Snapshot-Strukturen verwendet. Diese Strukturen sind so gestaltet, dass sie nur die Daten enthalten, die tatsächlich persistiert werden sollen.

* Struct: WorkspaceSnapshot  
  Eine serialisierbare Repräsentation der zu persistierenden Daten eines einzelnen Workspace.  
  Rust  
  // src/domain/workspaces/config/mod.rs  
  use serde::{Serialize, Deserialize};  
  use crate::domain::workspaces::core::types::{WorkspaceLayoutType, WorkspaceId}; // WorkspaceId nur für Referenz, nicht persistiert

  \#  
  pub struct WorkspaceSnapshot {  
      // Die \`persistent\_id\` ist der Schlüssel zur Wiedererkennung eines Workspace über Sitzungen.  
      // Die Laufzeit-\`WorkspaceId\` (uuid) wird bei jedem Start neu generiert und ist nicht Teil des Snapshots.  
      pub persistent\_id: String,  
      pub name: String,  
      pub layout\_type: WorkspaceLayoutType,  
      // \`window\_ids\` werden nicht persistiert, da sie von laufenden Anwendungen abhängen und transient sind.  
      // \`created\_at\` wird ebenfalls nicht standardmäßig persistiert, es sei denn, es gibt eine Anforderung dafür.  
  }

* Struct: WorkspaceSetSnapshot  
  Eine serialisierbare Repräsentation der gesamten Workspace-Konfiguration, die eine Liste von WorkspaceSnapshot-Instanzen und die persistente ID des aktiven Workspace enthält.  
  Rust  
  // src/domain/workspaces/config/mod.rs  
  \#  
  pub struct WorkspaceSetSnapshot {  
      pub workspaces: Vec\<WorkspaceSnapshot\>,  
      // Speichert die \`persistent\_id\` des Workspace, der beim letzten Speichern aktiv war.  
      pub active\_workspace\_persistent\_id: Option\<String\>,  
      // Die Reihenfolge der \`workspaces\` in diesem Vec definiert die persistierte Reihenfolge.  
  }

* Trait: WorkspaceConfigProvider  
  Definiert die Schnittstelle, die dieses Modul dem WorkspaceManager zur Verfügung stellt. Dies ermöglicht die Entkopplung von der konkreten Implementierung der Persistenzlogik.  
  Rust  
  // src/domain/workspaces/config/mod.rs  
  use crate::domain::workspaces::config::errors::WorkspaceConfigError;

  pub trait WorkspaceConfigProvider: Send \+ Sync {  
      fn load\_workspace\_config(\&self) \-\> Result\<WorkspaceSetSnapshot, WorkspaceConfigError\>;  
      fn save\_workspace\_config(\&self, config\_snapshot: \&WorkspaceSetSnapshot) \-\> Result\<(), WorkspaceConfigError\>;  
  }

* Struct: FilesystemConfigProvider (Beispielimplementierung)  
  Eine konkrete Implementierung von WorkspaceConfigProvider, die core::config (oder eine ähnliche Abstraktion der Kernschicht für Dateizugriffe) nutzt, um die Konfiguration als Datei (z.B. JSON oder TOML) zu speichern und zu laden.  
  Rust  
  // src/domain/workspaces/config/mod.rs  
  use std::sync::Arc;  
  use crate::core::config::ConfigService; // Annahme: Ein Service aus der Kernschicht

  pub struct FilesystemConfigProvider {  
      config\_service: Arc\<dyn ConfigService\>, // Service aus der Kernschicht  
      config\_file\_name: String, // z.B. "workspaces\_v1.json"  
  }

  impl FilesystemConfigProvider {  
      pub fn new(config\_service: Arc\<dyn ConfigService\>, config\_file\_name: String) \-\> Self {  
          Self { config\_service, config\_file\_name }  
      }  
  }

  // Die Implementierung von \`WorkspaceConfigProvider\` für \`FilesystemConfigProvider\` folgt in Abschnitt 5.6

### **5.3. Öffentliche API: Methoden und Funktionen**

Die öffentliche API dieses Moduls wird durch das WorkspaceConfigProvider-Trait definiert. Konkrete Implementierungen wie FilesystemConfigProvider setzen dieses Trait um.  
**Tabelle: API-Methoden für WorkspaceConfigProvider**

| Methode (Rust-Signatur) | Kurzbeschreibung | Mögliche Fehler (WorkspaceConfigError) |
| :---- | :---- | :---- |
| fn load\_workspace\_config(\&self) \-\> Result\<WorkspaceSetSnapshot, WorkspaceConfigError\> | Lädt die Workspace-Konfiguration aus dem persistenten Speicher. | LoadError, InvalidData, DeserializationError, PersistentIdNotFound (falls Konsistenzchecks fehlschlagen) |
| fn save\_workspace\_config(\&self, config\_snapshot: \&WorkspaceSetSnapshot) \-\> Result\<(), WorkspaceConfigError\> | Speichert die übergebene Workspace-Konfiguration in den persistenten Speicher. | SaveError, SerializationError |

Diese Schnittstelle ermöglicht es dem WorkspaceManager, die Konfiguration zu laden und zu speichern, ohne Details über den Speicherort oder das Format kennen zu müssen. Dies verbessert die Testbarkeit, da der WorkspaceConfigProvider im WorkspaceManager leicht durch eine Mock-Implementierung ersetzt werden kann.

### **5.4. Events: Definition und Semantik**

Das Modul workspaces::config ist typischerweise nicht dafür verantwortlich, eigene Events zu publizieren. Ein erfolgreicher Lade- oder Speichervorgang wird durch Result::Ok(()) signalisiert, während Fehler über das WorkspaceConfigError-Enum zurückgegeben werden. Der WorkspaceManager kann nach einem erfolgreichen Ladevorgang (z.B. bei der Initialisierung) ein WorkspacesReloaded-Event auslösen, um andere Systemteile über die Verfügbarkeit der geladenen Konfiguration zu informieren.

### **5.5. Fehlerbehandlung: WorkspaceConfigError**

Für Fehler, die spezifisch bei Konfigurations- und Persistenzoperationen auftreten, wird das WorkspaceConfigError-Enum definiert.

* **Definition:**  
  Rust  
  // src/domain/workspaces/config/errors.rs  
  use thiserror::Error;  
  // Annahme: Ein allgemeiner Konfigurationsfehler aus der Kernschicht,  
  // der I/O-Fehler, Berechtigungsfehler etc. kapseln kann.  
  use crate::core::config::ConfigError as CoreConfigError;

  \#  
  pub enum WorkspaceConfigError {  
      \#\[error("Failed to load workspace configuration from '{path}': {source}")\]  
      LoadError {  
          path: String,  
          \#\[source\]  
          source: CoreConfigError,  
      },

      \#\[error("Failed to save workspace configuration to '{path}': {source}")\]  
      SaveError {  
          path: String,  
          \#\[source\]  
          source: CoreConfigError,  
      },

      \#\[error("Workspace configuration data is invalid or corrupt: {reason}. Path: '{path:?}'")\]  
      InvalidData { reason: String, path: Option\<String\> },

      \#  
      SerializationError {  
          message: String,  
          \#\[source\]  
          source: Option\<serde\_json::Error\>, // Beispiel für serde\_json  
      },

      \#  
      DeserializationError {  
          message: String,  
          snippet: Option\<String\>, // Ein kleiner Teil des fehlerhaften Inhalts  
          \#\[source\]  
          source: Option\<serde\_json::Error\>, // Beispiel für serde\_json  
      },

      \#  
      PersistentIdNotFound { persistent\_id: String },

      \#  
      DuplicatePersistentId { persistent\_id: String },

      \#  
      VersionMismatch { expected: Option\<String\>, found: Option\<String\> },

      \#\[error("An internal error occurred in workspace configuration logic: {context}")\]  
      Internal { context: String },  
  }

* Erläuterung und Anwendung von Fehlerbehandlungsprinzipien:  
  Auch WorkspaceConfigError nutzt thiserror. Die Varianten LoadError und SaveError verwenden \#\[source\], um den zugrundeliegenden CoreConfigError (aus core::config) als Ursache einzubetten.3 Dies ist wichtig, um die Fehlerkette bis zum ursprünglichen I/O- oder Berechtigungsfehler zurückverfolgen zu können.  
  Ein besonderer Aspekt ist der Umgang mit Fehlern aus externen Bibliotheken, wie z.B. serde\_json::Error für die (De-)Serialisierung. Die Varianten SerializationError und DeserializationError sind so gestaltet, dass sie den ursprünglichen serde-Fehler als source aufnehmen können. Dies ist der direkten Konvertierung des Fehlers in einen String vorzuziehen, da so mehr Informationen für die Diagnose erhalten bleiben.  
  * Wenn serde\_json::Error direkt als source verwendet wird (z.B. \#\[source\] source: serde\_json::Error), kann der Aufrufer den Fehler heruntercasten und spezifische Details des serde-Fehlers untersuchen.  
  * Die message-Felder in diesen Varianten können entweder die Display-Ausgabe des serde-Fehlers oder eine benutzerdefinierte, kontextreichere Nachricht enthalten.  
  * Das Feld snippet in DeserializationError kann einen kleinen Ausschnitt der fehlerhaften Daten enthalten, was die Fehlersuche erheblich erleichtert.

Die Varianten PersistentIdNotFound und DuplicatePersistentId dienen der Validierung der semantischen Korrektheit der geladenen Konfigurationsdaten. VersionMismatch ist vorgesehen, um zukünftige Änderungen am Konfigurationsformat handhaben zu können.  
**Tabelle: WorkspaceConfigError Varianten**

| Variante | \#\[error("...")\]-Meldung (Auszug) | Semantische Bedeutung/Ursache | Enthaltene Daten/Quellfehler |
| :---- | :---- | :---- | :---- |
| LoadError | "Failed to load workspace configuration from '{path}'..." | Fehler beim Lesen der Konfigurationsdatei (I/O, Berechtigungen). | path: String, source: CoreConfigError. |
| SaveError | "Failed to save workspace configuration to '{path}'..." | Fehler beim Schreiben der Konfigurationsdatei (I/O, Berechtigungen, Speicherplatz). | path: String, source: CoreConfigError. |
| InvalidData | "Workspace configuration data is invalid or corrupt: {reason}..." | Die gelesenen Daten sind nicht im erwarteten Format oder semantisch inkonsistent (über (De-)Serialisierungsfehler hinaus). | reason: String, path: Option\<String\>. |
| SerializationError | "Serialization error for workspace configuration: {message}" | Fehler bei der Umwandlung der WorkspaceSetSnapshot-Struktur in ein serialisiertes Format (z.B. JSON). | message: String, source: Option\<serde\_json::Error\>. |
| DeserializationError | "Deserialization error for workspace configuration: {message}..." | Fehler bei der Umwandlung von serialisierten Daten (z.B. JSON-String) in die WorkspaceSetSnapshot-Struktur. | message: String, snippet: Option\<String\>, source: Option\<serde\_json::Error\>. |
| PersistentIdNotFound | "Persistent ID '{persistent\_id}' referenced in configuration..." | Eine in der Konfiguration referenzierte persistente ID (z.B. für den aktiven Workspace) existiert nicht in der Liste der geladenen Workspaces. | persistent\_id: String. |
| DuplicatePersistentId | "Duplicate persistent ID '{persistent\_id}' found..." | Mindestens zwei Workspaces in der Konfiguration haben dieselbe persistente ID. | persistent\_id: String. |
| VersionMismatch | "The configuration version is incompatible..." | Die Version der geladenen Konfigurationsdatei stimmt nicht mit der erwarteten Version überein. | expected: Option\<String\>, found: Option\<String\>. |
| Internal { context: String } | "An internal error occurred..." | Ein unerwarteter interner Fehler in der Konfigurationslogik. | context: String. |

### **5.6. Detaillierte Implementierungsschritte und Dateistruktur**

* **Dateistruktur innerhalb von src/domain/workspaces/config/:**  
  * mod.rs: Enthält die Definitionen der Snapshot-Strukturen (WorkspaceSnapshot, WorkspaceSetSnapshot), des WorkspaceConfigProvider-Traits und der konkreten Implementierung(en) wie FilesystemConfigProvider.  
  * errors.rs: Enthält die Definition des WorkspaceConfigError-Enums.  
* **Implementierungsschritte für FilesystemConfigProvider (Beispiel):**  
  1. Definiere das WorkspaceConfigError-Enum in errors.rs.  
  2. Definiere die Structs WorkspaceSnapshot und WorkspaceSetSnapshot in mod.rs und leite serde::Serialize sowie serde::Deserialize für sie ab.  
  3. Definiere das WorkspaceConfigProvider-Trait in mod.rs.  
  4. Implementiere das FilesystemConfigProvider-Struct (wie in 5.2 gezeigt) in mod.rs.  
  5. Implementiere das WorkspaceConfigProvider-Trait für FilesystemConfigProvider:  
     * **load\_workspace\_config():**  
       1. Rufe self.config\_service.read\_config\_file(\&self.config\_file\_name) auf, um den Inhalt der Konfigurationsdatei als String zu lesen.  
       2. Bei einem Fehler vom config\_service (z.B. Datei nicht gefunden, keine Leseberechtigung), mappe diesen CoreConfigError zu WorkspaceConfigError::LoadError { path: self.config\_file\_name.clone(), source: core\_err } und gib ihn zurück.  
          * Speziell der Fall "Datei nicht gefunden" (CoreConfigError::NotFound oder ähnlich) sollte vom Aufrufer (dem WorkspaceManager) ggf. als nicht-kritischer Fehler behandelt werden (z.B. um Standard-Workspaces zu erstellen). Diese Methode sollte den Fehler jedoch korrekt signalisieren.  
       3. Versuche, den gelesenen String-Inhalt mittels serde\_json::from\_str::\<WorkspaceSetSnapshot\>(content\_str) (oder dem entsprechenden Parser für das gewählte Format) zu deserialisieren.  
       4. Bei einem Deserialisierungsfehler, mappe den serde\_json::Error zu WorkspaceConfigError::DeserializationError { message: serde\_err.to\_string(), snippet: Some(...), source: Some(serde\_err) } und gib ihn zurück. Der snippet sollte einen kleinen Teil des problematischen Inhalts enthalten.  
       5. Führe nach erfolgreicher Deserialisierung Validierungen auf dem WorkspaceSetSnapshot durch:  
          * Prüfe auf doppelte persistent\_ids in snapshot.workspaces. Falls Duplikate gefunden werden, gib Err(WorkspaceConfigError::DuplicatePersistentId {... }) zurück.  
          * Wenn snapshot.active\_workspace\_persistent\_id Some(active\_pid) ist, prüfe, ob ein Workspace mit dieser persistent\_id auch in snapshot.workspaces existiert. Falls nicht, gib Err(WorkspaceConfigError::PersistentIdNotFound {... }) zurück.  
       6. Gib bei Erfolg Ok(snapshot) zurück.  
     * **save\_workspace\_config(config\_snapshot: \&WorkspaceSetSnapshot):**  
       1. Serialisiere das config\_snapshot-Objekt mittels serde\_json::to\_string\_pretty(config\_snapshot) (oder dem entsprechenden Serialisierer) in einen String. to\_string\_pretty wird für bessere Lesbarkeit der Konfigurationsdatei empfohlen.  
       2. Bei einem Serialisierungsfehler, mappe den serde\_json::Error zu WorkspaceConfigError::SerializationError { message: serde\_err.to\_string(), source: Some(serde\_err) } und gib ihn zurück.  
       3. Rufe self.config\_service.write\_config\_file(\&self.config\_file\_name, serialized\_content) auf, um den serialisierten String in die Konfigurationsdatei zu schreiben.  
       4. Bei einem Fehler vom config\_service (z.B. keine Schreibberechtigung, kein Speicherplatz), mappe diesen CoreConfigError zu WorkspaceConfigError::SaveError { path: self.config\_file\_name.clone(), source: core\_err } und gib ihn zurück.  
       5. Gib bei Erfolg Ok(()) zurück.  
  6. Stelle sicher, dass alle öffentlichen Elemente (Traits, Structs, Methoden) umfassend mit rustdoc dokumentiert sind.  
  7. Erstelle Unit-Tests für FilesystemConfigProvider. Diese Tests sollten:  
     * Einen gemockten ConfigService verwenden, um Lese- und Schreiboperationen zu simulieren, ohne auf das tatsächliche Dateisystem zuzugreifen.  
     * Erfolgreiches Laden und Speichern von gültigen WorkspaceSetSnapshot-Daten testen.  
     * Alle Fehlerfälle testen: I/O-Fehler (simuliert durch den Mock), (De-)Serialisierungsfehler mit ungültigen Daten, Validierungsfehler (doppelte IDs, nicht gefundene aktive ID).  
     * Testen des Verhaltens, wenn die Konfigurationsdatei nicht existiert (simulierter CoreConfigError::NotFound).

## **6\. Integrationsleitfaden für die Komponente domain::workspaces**

Dieser Abschnitt beschreibt das Zusammenspiel der vier Module innerhalb der domain::workspaces-Komponente und deren Interaktion mit anderen Teilen des Systems.

### **6.1. Zusammenwirken der Module**

Die vier Module (core, assignment, manager, config) der domain::workspaces-Komponente sind so konzipiert, dass sie eng zusammenarbeiten, wobei jedes Modul klar definierte Verantwortlichkeiten hat:

1. **workspaces::manager als zentraler Koordinator:**  
   * Der WorkspaceManager ist die Hauptschnittstelle und der Orchestrator für alle Workspace-Operationen.  
   * Er initialisiert sich selbst, indem er über einen WorkspaceConfigProvider (aus workspaces::config) die gespeicherte Workspace-Konfiguration lädt.  
   * Er hält eine interne Sammlung (HashMap und Vec) von Workspace-Instanzen (definiert in workspaces::core).  
   * Für Operationen, die die Zuweisung von Fenstern zu Workspaces betreffen (z.B. assign\_window\_to\_active\_workspace), delegiert der WorkspaceManager die Logik an die Funktionen des workspaces::assignment-Moduls und übergibt dabei seine interne Workspace-Sammlung.  
   * Bei Änderungen, die persistiert werden müssen (z.B. Erstellung eines neuen Workspace, Umbenennung, Änderung der Reihenfolge, Änderung des aktiven Workspace), erstellt der WorkspaceManager einen WorkspaceSetSnapshot und nutzt den WorkspaceConfigProvider aus workspaces::config, um diesen zu speichern.  
   * Der WorkspaceManager ist verantwortlich für das Publizieren von WorkspaceEvents, um andere Systemteile über relevante Änderungen zu informieren.  
2. **workspaces::core als Fundament:**  
   * Stellt die Definition des Workspace-Structs und zugehöriger Typen (WindowIdentifier, WorkspaceLayoutType) sowie der Event-Payload-Datenstrukturen bereit.  
   * Workspace-Instanzen werden vom WorkspaceManager gehalten und modifiziert (z.B. durch Aufruf von Workspace::rename()).  
3. **workspaces::assignment als Dienstleister für Zuweisungslogik:**  
   * Stellt zustandslose Funktionen bereit, die auf der vom WorkspaceManager übergebenen Sammlung von Workspace-Objekten operieren, um Fenster zuzuweisen, zu entfernen oder zu verschieben.  
   * Modifiziert die window\_ids-Mengen innerhalb der Workspace-Objekte.  
4. **workspaces::config als Persistenzabstraktion:**  
   * Definiert die Schnittstelle (WorkspaceConfigProvider) und die Datenstrukturen (WorkspaceSnapshot, WorkspaceSetSnapshot) für das Laden und Speichern der Workspace-Konfiguration.  
   * Konkrete Implementierungen (z.B. FilesystemConfigProvider) nutzen Dienste der Kernschicht (core::config) für den eigentlichen Dateizugriff.

Dieses Design fördert Modularität und Testbarkeit. Der WorkspaceManager kann beispielsweise mit gemockten WorkspaceConfigProvider- und EventPublisher-Implementierungen getestet werden.

### **6.2. Abhängigkeiten und Schnittstellen zu anderen Domänenkomponenten und Schichten**

Die domain::workspaces-Komponente interagiert mit und hat Abhängigkeiten zu folgenden anderen Teilen des Systems:

* **Kernschicht (Core Layer):**  
  * **core::config:** Wird von workspaces::config (konkret von FilesystemConfigProvider) genutzt, um auf das Dateisystem zuzugreifen und Konfigurationsdateien zu lesen/schreiben.  
  * **core::errors:** Basisfehlertypen (z.B. ValidationError, ConfigError aus core::config) können von den spezifischen Fehler-Enums der Workspace-Module (WorkspaceCoreError, WorkspaceConfigError) via \#\[from\] referenziert und gewrappt werden.  
  * **core::types:** Fundamentale Typen wie uuid::Uuid (für WorkspaceId) werden direkt genutzt. Andere Typen (z.B. chrono::DateTime) für Zeitstempel.  
  * **core::logging (implizit):** Alle Module der domain::workspaces-Komponente sollten das tracing-Framework der Kernschicht für Logging und Tracing verwenden, wie in Richtlinie 4.4 spezifiziert.  
* **Andere Domänenkomponenten (Domain Layer):**  
  * **domain::window\_management (Policy):**  
    * Diese Komponente definiert die übergeordneten Regeln für Fensterplatzierung und \-verhalten. Sie könnte auf WorkspaceEvents (z.B. ActiveWorkspaceChanged, WindowAddedToWorkspace, WorkspaceLayoutChanged) vom workspaces::manager lauschen, um ihre Layout-Algorithmen oder Fensteranordnungen anzupassen.  
    * Umgekehrt könnte domain::window\_management Regeln bereitstellen (z.B. "Anwendung X immer auf Workspace Y öffnen"), die der workspaces::manager oder workspaces::assignment bei der initialen Zuweisung eines neuen Fensters berücksichtigen muss. Dies könnte über eine direkte Abfrage oder eine Konfigurationsschnittstelle erfolgen.  
  * **domain::settings:**  
    * Globale Desktop-Einstellungen (z.B. "Standardanzahl der Workspaces beim ersten Start", "Verhalten beim Schließen des letzten Fensters auf einem Workspace") könnten das Initialisierungs- oder Betriebsverhalten des workspaces::manager beeinflussen. Der WorkspaceManager könnte diese Einstellungen beim Start abfragen.  
  * **domain::ai (indirekt):**  
    * KI-Funktionen könnten kontextabhängig von Workspaces agieren (z.B. "fasse die Fenster auf dem aktuellen Workspace zusammen"). In diesem Fall würde domain::ai Informationen über den aktiven Workspace und dessen Fenster vom workspaces::manager abfragen.  
* **Systemschicht (System Layer):**  
  * **Compositor (system::compositor):**  
    * Informiert den workspaces::manager (oder eine übergeordnete Fassade in der Systemschicht, die mit dem Manager kommuniziert), wenn neue Fenster (Wayland Surfaces) erstellt oder zerstört werden. Diese Information ist notwendig, damit der WorkspaceManager die Fenster den Workspaces zuordnen kann.  
    * Wird vom workspaces::manager (oft indirekt über domain::window\_management) angewiesen, welche Fenster auf dem aktuell aktiven Workspace sichtbar gemacht und welche verborgen werden sollen.  
    * Setzt Fokusregeln basierend auf dem aktiven Workspace und den Anweisungen aus der Domänenschicht um.  
  * **D-Bus-Schnittstellen (system::dbus):**  
    * Der WorkspaceManager könnte seine API (oder Teile davon) über D-Bus exponieren, um externen Werkzeugen oder Skripten die Steuerung von Workspaces zu ermöglichen.  
    * Umgekehrt könnte der WorkspaceManager auf D-Bus-Signale von Systemdiensten lauschen, falls diese für die Workspace-Logik relevant sind.  
* **Benutzeroberflächenschicht (User Interface Layer):**  
  * **Shell-UI (ui::shell), Pager, Fensterwechsler (ui::window\_manager\_frontend):**  
    * Nutzt die API des workspaces::manager intensiv, um die Liste der Workspaces abzurufen und darzustellen, den aktiven Workspace hervorzuheben, das Wechseln zwischen Workspaces zu ermöglichen und die Erstellung/Löschung/Umbenennung von Workspaces durch Benutzeraktionen anzustoßen.  
    * Reagiert auf WorkspaceEvents vom WorkspaceManager, um die Benutzeroberfläche dynamisch zu aktualisieren, wenn sich der Workspace-Zustand ändert (z.B. neuer Workspace erscheint im Pager, Fensterliste für aktiven Workspace wird aktualisiert).

### **6.3. Sequenzdiagramme für typische Anwendungsfälle**

Die folgenden Beschreibungen skizzieren die Interaktionen für typische Anwendungsfälle. In einer vollständigen grafischen Dokumentation würden hier UML-Sequenzdiagramme stehen.

1. **Erstellung eines neuen Workspace durch Benutzeraktion:**  
   * User interagiert mit der UI-Schicht (z.B. Klick auf "Neuer Workspace"-Button).  
   * UI-Schicht ruft WorkspaceManager::create\_workspace(name, persistent\_id) auf.  
   * WorkspaceManager validiert Eingaben, generiert ggf. Standardnamen.  
   * WorkspaceManager ruft Workspace::new(final\_name, persistent\_id) (aus workspaces::core) auf, um eine neue Workspace-Instanz zu erstellen.  
     * Workspace::new gibt Ok(new\_workspace) oder Err(WorkspaceCoreError) zurück.  
   * WorkspaceManager fügt new\_workspace seiner internen Sammlung hinzu.  
   * WorkspaceManager publiziert ein WorkspaceEvent::WorkspaceCreated über seinen EventPublisher.  
   * WorkspaceManager ruft self.save\_configuration() auf, was intern den WorkspaceConfigProvider::save\_workspace\_config() (aus workspaces::config) aufruft.  
     * WorkspaceConfigProvider serialisiert den Zustand und nutzt core::config::ConfigService zum Schreiben.  
   * WorkspaceManager gibt Ok(new\_workspace\_id) an die UI-Schicht zurück.  
   * UI-Schicht (als Subscriber des WorkspaceEvent::WorkspaceCreated) aktualisiert die Darstellung (z.B. fügt neuen Workspace-Tab hinzu).  
2. **Ein neues Fenster wird erstellt und dem aktiven Workspace zugewiesen:**  
   * Systemschicht (Compositor) erkennt ein neues Fenster (z.B. neues Wayland Surface) und generiert eine WindowIdentifier.  
   * Systemschicht benachrichtigt den WorkspaceManager (ggf. über eine Fassade oder einen System-Event) über das neue Fenster: handle\_new\_window(window\_id).  
   * WorkspaceManager::handle\_new\_window (oder eine ähnliche Methode) ruft intern WorkspaceManager::assign\_window\_to\_active\_workspace(\&window\_id) auf.  
   * WorkspaceManager::assign\_window\_to\_active\_workspace prüft, ob ein aktiver Workspace existiert.  
   * WorkspaceManager ruft workspaces::assignment::assign\_window\_to\_workspace(\&mut self.workspaces, active\_ws\_id, \&window\_id, self.ensure\_unique\_window\_assignment) auf.  
     * assignment::assign\_window\_to\_workspace modifiziert das Workspace-Objekt des aktiven Workspace (fügt window\_id zu dessen window\_ids-Set hinzu) und entfernt es ggf. von anderen Workspaces.  
     * Gibt Ok(()) oder Err(WindowAssignmentError) zurück.  
   * WorkspaceManager publiziert WorkspaceEvent::WindowAddedToWorkspace (und ggf. WindowRemovedFromWorkspace falls von einem anderen WS entfernt) über seinen EventPublisher.  
   * WorkspaceManager gibt Erfolg/Fehler an den Aufrufer (Systemschicht) zurück.  
   * UI-Schicht (als Subscriber) aktualisiert ggf. die Fensterliste für den aktiven Workspace.  
   * domain::window\_management (als Subscriber) könnte auf das Event reagieren, um das neue Fenster gemäß den Layout-Regeln des aktiven Workspace zu positionieren.  
3. **Laden der Workspace-Konfiguration beim Start des WorkspaceManager:**  
   * Eine übergeordnete Komponente (z.B. Desktop-Initialisierungsdienst) ruft WorkspaceManager::new(config\_provider, event\_publisher,...) auf.  
   * WorkspaceManager::new ruft config\_provider.load\_workspace\_config() (aus workspaces::config) auf.  
   * FilesystemConfigProvider::load\_workspace\_config (Implementierung von WorkspaceConfigProvider):  
     * Ruft core::config::ConfigService::read\_config\_file(...) auf, um Rohdaten zu laden.  
     * Deserialisiert die Rohdaten in ein WorkspaceSetSnapshot.  
     * Validiert den Snapshot (z.B. auf doppelte persistente IDs).  
     * Gibt Ok(snapshot) oder Err(WorkspaceConfigError) zurück.  
   * WorkspaceManager::new verarbeitet das Result:  
     * Bei Ok(snapshot): Erstellt Workspace-Instanzen aus den WorkspaceSnapshots, füllt self.workspaces und self.ordered\_workspace\_ids. Setzt self.active\_workspace\_id basierend auf snapshot.active\_workspace\_persistent\_id. Publiziere WorkspacesReloaded und ActiveWorkspaceChanged.  
     * Bei Err(WorkspaceConfigError::LoadError { source: CoreConfigError::NotFound,.. }) (oder ähnlicher Fehler, der "Datei nicht gefunden" anzeigt): Erstellt einen oder mehrere Standard-Workspaces, fügt sie hinzu, setzt einen als aktiv. Publiziere WorkspaceCreated und ActiveWorkspaceChanged.  
     * Bei anderen Err(config\_err): Gibt Err(WorkspaceManagerError::ConfigError(config\_err)) zurück.  
   * WorkspaceManager::new gibt Ok(self) oder Err(WorkspaceManagerError) an den Aufrufer zurück.

## **7\. Anhang: Referenzierte Richtlinien zur Fehlerbehandlung**

Dieser Anhang fasst die zentralen Prinzipien und Entscheidungen zur Fehlerbehandlung zusammen, die für die Implementierung der domain::workspaces-Komponente und darüber hinaus im gesamten Projekt gelten. Diese basieren auf Richtlinie 4.3 der Gesamtspezifikation und den Erkenntnissen aus der Analyse etablierter Rust-Fehlerbehandlungspraktiken.1

* **Verwendung von thiserror pro Modul:** Jedes Modul (z.B. workspaces::core, workspaces::assignment) definiert sein eigenes spezifisches Fehler-Enum unter Verwendung des thiserror-Crates. Dies reduziert Boilerplate und fördert klar definierte Fehlergrenzen zwischen Modulen.1  
* **Klare und kontextreiche Fehlernachrichten:** Jede Variante eines Fehler-Enums muss eine präzise, entwicklerorientierte Fehlermeldung über das \#\[error("...")\]-Attribut bereitstellen. Diese Nachricht sollte den Fehler eindeutig beschreiben.  
* **Fehlervarianten mit Datenanreicherung:** Wo immer es für die Fehlerdiagnose oder die programmatische Fehlerbehandlung durch den Aufrufer nützlich ist, sollen Fehlervarianten relevante Daten als Felder enthalten. Dies können ungültige Eingabewerte, Zustandsinformationen zum Zeitpunkt des Fehlers oder andere kontextrelevante Details sein. Dies hilft, das "Context Blurring"-Problem zu vermeiden, bei dem generische Fehler nicht genügend Informationen liefern.1  
* **Nutzung von \#\[from\] für Fehlerkonvertierung:** Das \#\[from\]-Attribut von thiserror soll verwendet werden, um Fehler aus abhängigen Modulen oder Bibliotheken einfach in den Fehlertyp des aktuellen Moduls zu konvertieren. Dies erleichtert die Fehlerpropagierung mit dem ?-Operator und stellt sicher, dass die std::error::Error::source()-Kette erhalten bleibt, sodass die ursprüngliche Fehlerursache zurückverfolgt werden kann.3  
* **Spezifische Varianten bei unzureichendem Kontext durch \#\[from\]:** Wenn ein via \#\[from\] gewrappter Fehler zu generisch ist und der spezifische Kontext der fehlgeschlagenen Operation im aktuellen Modul verloren ginge, soll eine spezifischere Fehlervariante im aktuellen Modul-Error-Enum erstellt werden. Diese spezifischere Variante sollte den ursprünglichen Fehler explizit über das \#\[source\]-Attribut einbetten und zusätzliche Felder für den Kontext der aktuellen Operation enthalten.  
* **Vermeidung von unwrap() und expect():** In Bibliotheks-, Kern- und Domänencode ist die Verwendung von unwrap() und expect() zur Fehlerbehandlung strikt zu vermeiden. Alle vorhersehbaren Fehler müssen über das Result\<T, E\>-Typsystem explizit behandelt und propagiert werden. Panics sind nur für nicht behebbare Fehler oder in Tests und Beispielen akzeptabel.1  
* **Semantik der Display-Implementierung:** Die durch \#\[error("...")\] generierte Display-Implementierung von Fehlern ist primär für Entwickler (Logging, Debugging) gedacht. Die Benutzeroberflächenschicht ist dafür verantwortlich, diese technischen Fehler – basierend auf der semantischen Bedeutung der jeweiligen Fehlervariante – in benutzerfreundliche und ggf. lokalisierte Nachrichten zu übersetzen.  
* **Umgang mit Fehlern aus externen Bibliotheken:** Fehler aus externen Bibliotheken (z.B. serde\_json::Error) sollten ebenfalls in die modul-spezifischen Fehler-Enums integriert werden, idealerweise unter Beibehaltung des Originalfehlers als source. Dies kann durch \#\[from\] oder durch eine Variante mit einem \#\[source\]-Feld geschehen. Die direkte Konvertierung des externen Fehlers in einen String sollte vermieden werden, wenn dadurch wertvolle Diagnoseinformationen verloren gehen.

Die konsequente Anwendung dieser Richtlinien ist entscheidend für die Entwicklung einer robusten, wartbaren und gut diagnostizierbaren Desktop-Umgebung. Sie stellt sicher, dass Fehler nicht verschleiert werden, sondern klar und mit ausreichend Kontext an die entsprechenden Stellen im System weitergeleitet werden können.

#### **Referenzen**

1. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
2. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)  
3. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)  
4. std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/index.html](https://doc.rust-lang.org/std/error/index.html)
# **B3 Domänenschicht: Detaillierte Spezifikation – Teil 3/4: Benutzerzentrierte Dienste und Globale Einstellungsverwaltung**

Dieser Abschnitt des Dokuments setzt die detaillierte Spezifikation der Domänenschicht fort und konzentriert sich auf zwei Entwicklungsmodule: domain::user\_centric\_services und domain::global\_settings\_and\_state\_management. Diese Module sind entscheidend für die Implementierung intelligenter Benutzerinteraktionen, die Verwaltung von Benachrichtigungen und die Konfiguration des Desktops.  
---

**Entwicklungsmodul C: domain::user\_centric\_services**  
Dieses Modul bündelt die Logik für Dienste, die direkt auf die Bedürfnisse und Interaktionen des Benutzers ausgerichtet sind. Es umfasst die Verwaltung von KI-Interaktionen, einschließlich des Einwilligungsmanagements, sowie ein umfassendes Benachrichtigungssystem.  
**1\. Modulübersicht und Verantwortlichkeiten (domain::user\_centric\_services)**

* **Zweck:** Das Modul domain::user\_centric\_services dient als zentrale Komponente für die Orchestrierung von Benutzerinteraktionen, die über Standard-Desktop-Funktionen hinausgehen. Es stellt die Domänenlogik für KI-gestützte Assistenzfunktionen und ein robustes System zur Verwaltung von Benachrichtigungen bereit.  
* **Kernaufgaben:**  
  * **KI-Interaktionsmanagement:**  
    * Verwaltung des Lebenszyklus von KI-Interaktionskontexten.  
    * Implementierung der Logik für das Einholen, Speichern und Überprüfen von Benutzereinwilligungen (AIConsent) für die Nutzung von KI-Modellen und den Zugriff auf spezifische Datenkategorien (AIDataCategory).  
    * Verwaltung von Profilen verfügbarer KI-Modelle (AIModelProfile).  
    * Bereitstellung einer Schnittstelle zur Initiierung von KI-Aktionen und zur Verarbeitung von deren Ergebnissen, unabhängig vom spezifischen KI-Modell oder dem MCP-Protokoll (welches in der Systemschicht implementiert wird).  
  * **Benachrichtigungsmanagement:**  
    * Entgegennahme, Verarbeitung und Speicherung von Benachrichtigungen (Notification).  
    * Verwaltung des Zustands von Benachrichtigungen (aktiv, gelesen, abgewiesen).  
    * Implementierung einer Benachrichtigungshistorie mit konfigurierbarer Größe.  
    * Unterstützung für verschiedene Dringlichkeitsstufen (NotificationUrgency) und Aktionen (NotificationAction).  
    * Bereitstellung einer "Bitte nicht stören" (DND) Funktionalität.  
    * Ermöglichung des Filterns und Sortierens von Benachrichtigungen.  
* **Abgrenzung:**  
  * Dieses Modul implementiert *nicht* die UI-Elemente zur Darstellung von KI-Interaktionen oder Benachrichtigungen (dies ist Aufgabe der User Interface Layer).  
  * Es implementiert *nicht* die direkte Kommunikation mit KI-Modellen oder Systemdiensten wie dem D-Bus Notification Daemon (dies ist Aufgabe der System Layer). Es definiert die Logik und den Zustand, die von diesen Schichten genutzt werden.  
  * Die Persistenz von Einwilligungen oder Modellprofilen wird an die Core Layer (z.B. core::config) delegiert.  
* **Zugehörige Komponenten aus der Gesamtübersicht:** domain::ai, domain::notifications.

**2\. Datenstrukturen und Typdefinitionen (Rust) für domain::user\_centric\_services**  
Die folgenden Datenstrukturen definieren die Kernentitäten und Wertobjekte des Moduls. Sie sind so konzipiert, dass sie die notwendigen Informationen für die KI-Interaktions- und Benachrichtigungslogik kapseln.

* **2.1. Entitäten und Wertobjekte:**  
  * **AIInteractionContext (Entität):** Repräsentiert eine spezifische Interaktion oder einen Dialog mit einer KI.  
    * Attribute:  
      * id: Uuid (öffentlich): Eindeutiger Identifikator für den Kontext.  
      * creation\_timestamp: DateTime\<Utc\> (öffentlich): Zeitpunkt der Erstellung.  
      * active\_model\_id: Option\<String\> (öffentlich): ID des aktuell für diesen Kontext relevanten KI-Modells.  
      * consent\_status: AIConsentStatus (öffentlich): Aktueller Einwilligungsstatus für diesen Kontext.  
      * associated\_data\_categories: Vec\<AIDataCategory\> (öffentlich): Kategorien von Daten, die für diese Interaktion relevant sein könnten.  
      * interaction\_history: Vec\<String\> (privat, modifizierbar über Methoden): Eine einfache Historie der Konversation (z.B. Benutzeranfragen, KI-Antworten).  
      * attachments: Vec\<AttachmentData\> (öffentlich): Angehängte Daten (z.B. Dateipfade, Text-Snippets).  
    * Invarianten: id ist unveränderlich nach Erstellung. creation\_timestamp ist unveränderlich.  
    * Methoden (konzeptionell):  
      * new(relevant\_categories: Vec\<AIDataCategory\>) \-\> Self: Erstellt einen neuen Kontext.  
      * update\_consent\_status(\&mut self, status: AIConsentStatus): Aktualisiert den Einwilligungsstatus.  
      * set\_active\_model(\&mut self, model\_id: String): Legt das aktive Modell fest.  
      * add\_history\_entry(\&mut self, entry: String): Fügt einen Eintrag zur Historie hinzu.  
      * add\_attachment(\&mut self, attachment: AttachmentData): Fügt einen Anhang hinzu.  
  * **AIConsent (Entität):** Repräsentiert die Einwilligung eines Benutzers für eine spezifische Kombination aus KI-Modell und Datenkategorien.  
    * Attribute:  
      * id: Uuid (öffentlich): Eindeutiger Identifikator für die Einwilligung.  
      * user\_id: String (öffentlich, vereinfacht): Identifikator des Benutzers.  
      * model\_id: String (öffentlich): ID des KI-Modells, für das die Einwilligung gilt.  
      * data\_categories: Vec\<AIDataCategory\> (öffentlich): Datenkategorien, für die die Einwilligung erteilt wurde.  
      * granted\_timestamp: DateTime\<Utc\> (öffentlich): Zeitpunkt der Erteilung.  
      * expiry\_timestamp: Option\<DateTime\<Utc\>\> (öffentlich): Optionaler Ablaufzeitpunkt der Einwilligung.  
      * is\_revoked: bool (öffentlich, initial false): Gibt an, ob die Einwilligung widerrufen wurde.  
    * Invarianten: id, user\_id, model\_id, granted\_timestamp sind nach Erstellung unveränderlich. data\_categories sollten nach Erteilung nicht ohne Weiteres modifizierbar sein (neue Einwilligung erforderlich).  
    * Methoden (konzeptionell):  
      * new(user\_id: String, model\_id: String, categories: Vec\<AIDataCategory\>, expiry: Option\<DateTime\<Utc\>\>) \-\> Self.  
      * revoke(\&mut self): Markiert die Einwilligung als widerrufen.  
  * **AIModelProfile (Entität):** Beschreibt ein verfügbares KI-Modell.  
    * Attribute:  
      * model\_id: String (öffentlich): Eindeutiger Identifikator des Modells.  
      * display\_name: String (öffentlich): Anzeigename des Modells.  
      * description: String (öffentlich): Kurze Beschreibung des Modells.  
      * provider: String (öffentlich): Anbieter des Modells (z.B. "Local", "OpenAI").  
      * required\_consent\_categories: Vec\<AIDataCategory\> (öffentlich): Datenkategorien, für die dieses Modell typischerweise eine Einwilligung benötigt.  
      * capabilities: Vec\<String\> (öffentlich): Liste der Fähigkeiten des Modells (z.B. "text\_generation", "summarization").  
    * Invarianten: model\_id ist eindeutig und unveränderlich.  
    * Methoden (konzeptionell):  
      * new(...) \-\> Self.  
      * requires\_consent\_for(\&self, categories: &) \-\> bool: Prüft, ob für die gegebenen Kategorien eine Einwilligung erforderlich ist.  
  * **Notification (Entität):** Repräsentiert eine einzelne Benachrichtigung.  
    * Attribute:  
      * id: Uuid (öffentlich): Eindeutiger Identifikator.  
      * application\_name: String (öffentlich): Name der Anwendung, die die Benachrichtigung gesendet hat.  
      * application\_icon: Option\<String\> (öffentlich): Optionaler Pfad oder Name des Icons der Anwendung.  
      * summary: String (öffentlich): Kurze Zusammenfassung der Benachrichtigung.  
      * body: Option\<String\> (öffentlich): Detaillierterer Text der Benachrichtigung.  
      * actions: Vec\<NotificationAction\> (öffentlich): Verfügbare Aktionen für die Benachrichtigung.  
      * urgency: NotificationUrgency (öffentlich): Dringlichkeitsstufe.  
      * timestamp: DateTime\<Utc\> (öffentlich): Zeitpunkt des Eintreffens.  
      * is\_read: bool (privat, initial false): Status, ob gelesen.  
      * is\_dismissed: bool (privat, initial false): Status, ob vom Benutzer aktiv geschlossen.  
      * transient: bool (öffentlich, default false): Ob die Benachrichtigung flüchtig ist und nicht in der Historie verbleiben soll.  
    * Invarianten: id, timestamp sind unveränderlich. summary darf nicht leer sein.  
    * Methoden (konzeptionell):  
      * new(app\_name: String, summary: String, urgency: NotificationUrgency) \-\> Self.  
      * mark\_as\_read(\&mut self).  
      * dismiss(\&mut self).  
      * add\_action(\&mut self, action: NotificationAction).  
  * **NotificationAction (Wertobjekt):** Definiert eine Aktion, die im Kontext einer Benachrichtigung ausgeführt werden kann.  
    * Attribute:  
      * key: String (öffentlich): Eindeutiger Schlüssel für die Aktion (z.B. "reply", "archive").  
      * label: String (öffentlich): Anzeigename der Aktion.  
      * action\_type: NotificationActionType (öffentlich): Typ der Aktion (z.B. Callback, Link).  
  * **AttachmentData (Wertobjekt):** Repräsentiert angehängte Daten an einen AIInteractionContext.  
    * Attribute:  
      * id: Uuid (öffentlich): Eindeutiger Identifikator des Anhangs.  
      * mime\_type: String (öffentlich): MIME-Typ der Daten (z.B. "text/plain", "image/png").  
      * source\_uri: Option\<String\> (öffentlich): URI zur Quelle der Daten (z.B. file:///path/to/file).  
      * content: Option\<Vec\<u8\>\> (öffentlich): Direkter Inhalt der Daten, falls klein.  
      * description: Option\<String\> (öffentlich): Optionale Beschreibung des Anhangs.  
* **2.2. Modulspezifische Enums, Konstanten und Konfigurationsstrukturen:**  
  * **Enums:**  
    * AIConsentStatus: Enum (Granted, Denied, PendingUserAction, NotRequired).  
    * AIDataCategory: Enum (UserProfile, ApplicationUsage, FileSystemRead, ClipboardAccess, LocationData, GenericText, GenericImage).  
    * NotificationUrgency: Enum (Low, Normal, Critical).  
    * NotificationActionType: Enum (Callback, OpenLink).  
    * NotificationFilterCriteria: Enum (Unread, Application(String), Urgency(NotificationUrgency)).  
    * NotificationSortOrder: Enum (TimestampAscending, TimestampDescending, Urgency).  
  * **Konstanten:**  
    * const DEFAULT\_NOTIFICATION\_TIMEOUT\_SECS: u64 \= 5;  
    * const MAX\_NOTIFICATION\_HISTORY: usize \= 100;  
    * const MAX\_AI\_INTERACTION\_HISTORY: usize \= 50;  
* **2.3. Definition aller deklarierten Eigenschaften (Properties):**  
  * Für AIInteractionLogicService (als Trait implementiert):  
    * Keine direkten öffentlichen Eigenschaften, Zustand wird intern in der implementierenden Struktur gehalten (z.B. active\_contexts: HashMap\<Uuid, AIInteractionContext\>, consents: Vec\<AIConsent\>, model\_profiles: Vec\<AIModelProfile\>).  
  * Für NotificationService (als Trait implementiert):  
    * Keine direkten öffentlichen Eigenschaften, Zustand wird intern gehalten (z.B. active\_notifications: Vec\<Notification\>, history: VecDeque\<Notification\>, dnd\_enabled: bool).  
* **Wichtige Tabelle: Entitäten und Wertobjekte für domain::user\_centric\_services**

| Entität/Wertobjekt | Wichtige Attribute (Typ) | Kurzbeschreibung | Methoden (Beispiele) | Invarianten (Beispiele) |
| :---- | :---- | :---- | :---- | :---- |
| AIInteractionContext | id: Uuid, consent\_status: AIConsentStatus, associated\_data\_categories: Vec\<AIDataCategory\>, attachments: Vec\<AttachmentData\> | Repräsentiert eine laufende KI-Interaktion. | update\_consent\_status(), add\_attachment() | id ist unveränderlich. |
| AIConsent | model\_id: String, data\_categories: Vec\<AIDataCategory\>, granted\_timestamp: DateTime\<Utc\>, is\_revoked: bool | Speichert die Benutzereinwilligung für KI-Modell und Daten. | revoke() | model\_id, granted\_timestamp sind unveränderlich. |
| AIModelProfile | model\_id: String, display\_name: String, required\_consent\_categories: Vec\<AIDataCategory\>, capabilities: Vec\<String\> | Beschreibt ein verfügbares KI-Modell und dessen Anforderungen. | requires\_consent\_for() | model\_id ist eindeutig. |
| Notification | id: Uuid, summary: String, body: Option\<String\>, urgency: NotificationUrgency, is\_read: bool, actions: Vec\<NotificationAction\> | Repräsentiert eine System- oder Anwendungsbenachrichtigung. | mark\_as\_read(), dismiss(), add\_action() | id, timestamp sind unveränderlich. summary nicht leer. |
| NotificationAction | key: String, label: String, action\_type: NotificationActionType | Definiert eine ausführbare Aktion innerhalb einer Benachrichtigung. | \- | key ist eindeutig im Kontext der Benachrichtigung. |
| AttachmentData | id: Uuid, mime\_type: String, source\_uri: Option\<String\>, content: Option\<Vec\<u8\>\> | Repräsentiert angehängte Daten an einen AIInteractionContext. | \- | id ist eindeutig. Entweder source\_uri oder content sollte vorhanden sein. |

Diese tabellarische Übersicht fasst die zentralen Datenstrukturen zusammen. Die genaue Ausgestaltung der Attribute und Methoden ist für die korrekte Implementierung der Geschäftslogik entscheidend. Beispielsweise stellt die AIModelProfile-Struktur sicher, dass die Anforderungen eines Modells bezüglich der Dateneinwilligung klar definiert sind, was eine Kernanforderung für die KI-Integration darstellt.  
**3\. Öffentliche API und Interne Schnittstellen (Rust) für domain::user\_centric\_services**  
Die öffentliche API dieses Moduls wird durch Traits definiert, die von konkreten Service-Implementierungen erfüllt werden.

* **3.1. Exakte Signaturen aller öffentlichen Funktionen/Methoden:**  
  * **AIInteractionLogicService Trait:**  
    Rust  
    use crate::core::types::Uuid; // Standard Uuid Typ aus der Kernschicht  
    use crate::core::errors::CoreError; // Fehler aus der Kernschicht  
    use super::types::{AIInteractionContext, AIConsent, AIModelProfile, AIDataCategory, AttachmentData};  
    use super::errors::AIInteractionError;  
    use async\_trait::async\_trait;

    \#\[async\_trait\]  
    pub trait AIInteractionLogicService: Send \+ Sync {  
        /// Initiates a new AI interaction context.  
        /// Returns the ID of the newly created context.  
        async fn initiate\_interaction(  
            \&mut self,  
            relevant\_categories: Vec\<AIDataCategory\>,  
            initial\_attachments: Option\<Vec\<AttachmentData\>\>  
        ) \-\> Result\<Uuid, AIInteractionError\>;

        /// Retrieves an existing AI interaction context.  
        async fn get\_interaction\_context(\&self, context\_id: Uuid) \-\> Result\<AIInteractionContext, AIInteractionError\>;

        /// Provides or updates consent for a given interaction context and model.  
        async fn provide\_consent(  
            \&mut self,  
            context\_id: Uuid,  
            model\_id: String,  
            granted\_categories: Vec\<AIDataCategory\>,  
            consent\_decision: bool // true for granted, false for denied  
        ) \-\> Result\<(), AIInteractionError\>;

        /// Retrieves the consent status for a specific model and data categories,  
        /// potentially within an interaction context.  
        async fn get\_consent\_for\_model(  
            \&self,  
            model\_id: \&str,  
            data\_categories: &,  
            context\_id: Option\<Uuid\>  
        ) \-\> Result\<super::types::AIConsentStatus, AIInteractionError\>;

        /// Adds an attachment to an existing interaction context.  
        async fn add\_attachment\_to\_context(  
            \&mut self,  
            context\_id: Uuid,  
            attachment: AttachmentData  
        ) \-\> Result\<(), AIInteractionError\>;

        /// Lists all available and configured AI model profiles.  
        async fn list\_available\_models(\&self) \-\> Result\<Vec\<AIModelProfile\>, AIInteractionError\>;

        /// Stores a user's consent decision persistently.  
        /// This might be called after \`provide\_consent\` if the consent is to be remembered globally.  
        async fn store\_consent(\&self, consent: AIConsent) \-\> Result\<(), AIInteractionError\>;

        /// Retrieves all stored consents for a given user (simplified).  
        async fn get\_all\_user\_consents(\&self, user\_id: \&str) \-\> Result\<Vec\<AIConsent\>, AIInteractionError\>;

        /// Loads AI model profiles, e.g., from a configuration managed by core::config.  
        async fn load\_model\_profiles(\&mut self) \-\> Result\<(), AIInteractionError\>;  
    }

  * **NotificationService Trait:**  
    Rust  
    use crate::core::types::Uuid;  
    use crate::core::errors::CoreError;  
    use super::types::{Notification, NotificationUrgency, NotificationFilterCriteria, NotificationSortOrder};  
    use super::errors::NotificationError;  
    use async\_trait::async\_trait;

    \#\[async\_trait\]  
    pub trait NotificationService: Send \+ Sync {  
        /// Posts a new notification to the system.  
        /// Returns the ID of the newly created notification.  
        async fn post\_notification(\&mut self, notification\_data: Notification) \-\> Result\<Uuid, NotificationError\>;

        /// Retrieves a specific notification by its ID.  
        async fn get\_notification(\&self, notification\_id: Uuid) \-\> Result\<Notification, NotificationError\>;

        /// Marks a notification as read.  
        async fn mark\_as\_read(\&mut self, notification\_id: Uuid) \-\> Result\<(), NotificationError\>;

        /// Dismisses a notification, removing it from active view but possibly keeping it in history.  
        async fn dismiss\_notification(\&mut self, notification\_id: Uuid) \-\> Result\<(), NotificationError\>;

        /// Retrieves a list of currently active (not dismissed, potentially unread) notifications.  
        /// Allows filtering and sorting.  
        async fn get\_active\_notifications(  
            \&self,  
            filter: Option\<NotificationFilterCriteria\>,  
            sort\_order: Option\<NotificationSortOrder\>  
        ) \-\> Result\<Vec\<Notification\>, NotificationError\>;

        /// Retrieves the notification history.  
        /// Allows filtering and sorting.  
        async fn get\_notification\_history(  
            \&self,  
            limit: Option\<usize\>,  
            filter: Option\<NotificationFilterCriteria\>,  
            sort\_order: Option\<NotificationSortOrder\>  
        ) \-\> Result\<Vec\<Notification\>, NotificationError\>;

        /// Clears all notifications from history.  
        async fn clear\_history(\&mut self) \-\> Result\<(), NotificationError\>;

        /// Sets the "Do Not Disturb" mode.  
        async fn set\_do\_not\_disturb(\&mut self, enabled: bool) \-\> Result\<(), NotificationError\>;

        /// Checks if "Do Not Disturb" mode is currently enabled.  
        async fn is\_do\_not\_disturb\_enabled(\&self) \-\> Result\<bool, NotificationError\>;

        /// Invokes a specific action associated with a notification.  
        async fn invoke\_action(\&mut self, notification\_id: Uuid, action\_key: \&str) \-\> Result\<(), NotificationError\>;  
    }

* **3.2. Vor- und Nachbedingungen, Beschreibung der Logik/Algorithmen:**  
  * AIInteractionLogicService::provide\_consent:  
    * Vorbedingung: context\_id muss einen existierenden AIInteractionContext referenzieren. model\_id muss einem bekannten AIModelProfile entsprechen.  
    * Logik:  
      1. Kontext und Modellprofil laden.  
      2. Prüfen, ob die granted\_categories eine Untermenge der vom Modell potenziell benötigten Kategorien sind.  
      3. Einen neuen AIConsent-Eintrag erstellen oder einen bestehenden aktualisieren.  
      4. Den consent\_status im AIInteractionContext entsprechend anpassen.  
      5. Falls consent\_decision true ist und die Einwilligung global gespeichert werden soll, store\_consent() aufrufen.  
      6. AIConsentUpdatedEvent auslösen.  
    * Nachbedingung: Der Einwilligungsstatus des Kontexts ist aktualisiert. Ein AIConsent-Objekt wurde potenziell erstellt/modifiziert. Ein Event wurde ausgelöst.  
  * NotificationService::post\_notification:  
    * Vorbedingung: notification\_data.summary darf nicht leer sein.  
    * Logik:  
      1. Validieren der notification\_data.  
      2. Der Notification eine neue Uuid und einen timestamp zuweisen.  
      3. Wenn DND-Modus aktiv ist und die NotificationUrgency nicht Critical ist, die Benachrichtigung ggf. unterdrücken oder nur zur Historie hinzufügen, ohne sie aktiv anzuzeigen.  
      4. Die Benachrichtigung zur Liste der active\_notifications hinzufügen.  
      5. Wenn die Benachrichtigung nicht transient ist, sie zur history hinzufügen (unter Beachtung von MAX\_NOTIFICATION\_HISTORY).  
      6. NotificationPostedEvent auslösen (ggf. mit Information, ob sie aufgrund von DND unterdrückt wurde).  
    * Nachbedingung: Die Benachrichtigung ist im System registriert und ein Event wurde ausgelöst.  
* **3.3. Modulspezifische Trait-Definitionen und relevante Implementierungen:**  
  * AIInteractionLogicService und NotificationService sind die primären Traits.  
  * Implementierende Strukturen (z.B. DefaultAIInteractionLogicService, DefaultNotificationService) werden den Zustand halten (z.B. in HashMaps oder Vecs) und die Logik implementieren. Diese Strukturen sind nicht Teil der öffentlichen API, sondern interne Implementierungsdetails des Moduls.  
* **3.4. Exakte Definition aller Methoden für Komponenten mit komplexem internen Zustand oder Lebenszyklus:**  
  * DefaultAIInteractionLogicService:  
    * Hält intern Zustände wie active\_contexts: HashMap\<Uuid, AIInteractionContext\>, consents: Vec\<AIConsent\> (oder eine persistentere Speicherung über core::config), model\_profiles: Vec\<AIModelProfile\>.  
    * Die Methode load\_model\_profiles wäre typischerweise beim Start des Service aufgerufen, um die Profile aus einer Konfigurationsquelle zu laden.  
    * Die Methode store\_consent würde mit der Kernschicht interagieren, um Einwilligungen persistent zu machen.  
  * DefaultNotificationService:  
    * Hält intern Zustände wie active\_notifications: Vec\<Notification\>, history: VecDeque\<Notification\> (eine VecDeque ist hier passend für eine FIFO-artige Historie mit Limit), dnd\_enabled: bool, subscribers: Vec\<Weak\<dyn NotificationEventSubscriber\>\> (für den Event-Mechanismus, falls nicht über einen globalen Event-Bus gelöst).  
    * Methoden wie post\_notification und dismiss\_notification modifizieren diese Listen und müssen die Logik für die Historienbegrenzung und DND-Modus berücksichtigen.

**4\. Event-Spezifikationen für domain::user\_centric\_services**  
Events signalisieren Zustandsänderungen oder wichtige Ereignisse innerhalb des Moduls, die für andere Teile des Systems relevant sein können.

* **Event: AIInteractionInitiatedEvent**  
  * Event-Typ (Rust-Typ): pub struct AIInteractionInitiatedEvent { pub context\_id: Uuid, pub relevant\_categories: Vec\<AIDataCategory\> }  
  * Payload-Struktur: Enthält die ID des neuen Kontexts und die initial relevanten Datenkategorien.  
  * Typische Publisher: AIInteractionLogicService Implementierung.  
  * Typische Subscriber: UI-Komponenten, die eine KI-Interaktionsoberfläche öffnen oder vorbereiten; Logging-Systeme.  
  * Auslösebedingungen: Ein neuer AIInteractionContext wurde erfolgreich erstellt via initiate\_interaction.  
* **Event: AIConsentUpdatedEvent**  
  * Event-Typ (Rust-Typ): pub struct AIConsentUpdatedEvent { pub context\_id: Option\<Uuid\>, pub model\_id: String, pub granted\_categories: Vec\<AIDataCategory\>, pub consent\_status: AIConsentStatus }  
  * Payload-Struktur: Enthält die Kontext-ID (falls zutreffend), Modell-ID, die betroffenen Datenkategorien und den neuen Einwilligungsstatus.  
  * Typische Publisher: AIInteractionLogicService Implementierung.  
  * Typische Subscriber: UI-Komponenten, die den Einwilligungsstatus anzeigen oder Aktionen basierend darauf freischalten/sperren; die Komponente, die die eigentliche KI-Anfrage durchführt.  
  * Auslösebedingungen: Eine Einwilligung wurde erteilt, verweigert oder widerrufen (provide\_consent, store\_consent mit Widerruf).  
* **Event: NotificationPostedEvent**  
  * Event-Typ (Rust-Typ): pub struct NotificationPostedEvent { pub notification: Notification, pub suppressed\_by\_dnd: bool }  
  * Payload-Struktur: Enthält die vollständige Notification-Datenstruktur und ein Flag, ob sie aufgrund des DND-Modus unterdrückt wurde.  
  * Typische Publisher: NotificationService Implementierung.  
  * Typische Subscriber: UI-Schicht (zur Anzeige der Benachrichtigung), Systemschicht (z.B. um einen Ton abzuspielen, falls nicht unterdrückt).  
  * Auslösebedingungen: Eine neue Benachrichtigung wurde erfolgreich via post\_notification verarbeitet.  
* **Event: NotificationDismissedEvent**  
  * Event-Typ (Rust-Typ): pub struct NotificationDismissedEvent { pub notification\_id: Uuid }  
  * Payload-Struktur: Enthält die ID der entfernten Benachrichtigung.  
  * Typische Publisher: NotificationService Implementierung.  
  * Typische Subscriber: UI-Schicht (um die Benachrichtigung aus der aktiven Ansicht zu entfernen).  
  * Auslösebedingungen: Eine Benachrichtigung wurde erfolgreich via dismiss\_notification geschlossen.  
* **Event: NotificationReadEvent**  
  * Event-Typ (Rust-Typ): pub struct NotificationReadEvent { pub notification\_id: Uuid }  
  * Payload-Struktur: Enthält die ID der als gelesen markierten Benachrichtigung.  
  * Typische Publisher: NotificationService Implementierung.  
  * Typische Subscriber: UI-Schicht (um den "gelesen"-Status zu aktualisieren).  
  * Auslösebedingungen: Eine Benachrichtigung wurde erfolgreich via mark\_as\_read als gelesen markiert.  
* **Event: DoNotDisturbModeChangedEvent**  
  * Event-Typ (Rust-Typ): pub struct DoNotDisturbModeChangedEvent { pub dnd\_enabled: bool }  
  * Payload-Struktur: Enthält den neuen Status des DND-Modus.  
  * Typische Publisher: NotificationService Implementierung.  
  * Typische Subscriber: UI-Schicht (um ein Icon anzuzeigen), NotificationService selbst (um zukünftige Benachrichtigungen entsprechend zu behandeln).  
  * Auslösebedingungen: Der DND-Modus wurde via set\_do\_not\_disturb geändert.  
* **Wichtige Tabelle: Event-Spezifikationen für domain::user\_centric\_services**

| Event-Name/Typ (Rust) | Payload-Struktur (Felder, Typen) | Typische Publisher | Typische Subscriber | Auslösebedingungen |
| :---- | :---- | :---- | :---- | :---- |
| AIInteractionInitiatedEvent | context\_id: Uuid, relevant\_categories: Vec\<AIDataCategory\> | AIInteractionLogicService | UI für KI-Interaktion, Logging | Neuer AIInteractionContext erstellt. |
| AIConsentUpdatedEvent | context\_id: Option\<Uuid\>, model\_id: String, granted\_categories: Vec\<AIDataCategory\>, consent\_status: AIConsentStatus | AIInteractionLogicService | UI für Einwilligungsstatus, KI-Anfragekomponente | Einwilligung geändert (erteilt, verweigert, widerrufen). |
| NotificationPostedEvent | notification: Notification, suppressed\_by\_dnd: bool | NotificationService | UI zur Benachrichtigungsanzeige, System-Sound-Service | Neue Benachrichtigung verarbeitet. |
| NotificationDismissedEvent | notification\_id: Uuid | NotificationService | UI zur Benachrichtigungsanzeige | Benachrichtigung geschlossen. |
| NotificationReadEvent | notification\_id: Uuid | NotificationService | UI zur Benachrichtigungsanzeige | Benachrichtigung als gelesen markiert. |
| DoNotDisturbModeChangedEvent | dnd\_enabled: bool | NotificationService | UI (DND-Statusanzeige), NotificationService | DND-Modus geändert. |

Diese Event-Definitionen sind fundamental, um eine lose Kopplung zwischen diesem Domänenmodul und anderen Teilen des Systems, insbesondere der UI-Schicht, zu erreichen. Die UI kann auf diese Events reagieren, um sich dynamisch an Zustandsänderungen anzupassen, ohne die Interna dieses Moduls kennen zu müssen.  
**5\. Fehlerbehandlung (Rust mit thiserror) für domain::user\_centric\_services**  
Gemäß den Entwicklungsrichtlinien (Abschnitt 4.3) wird thiserror zur Definition spezifischer Fehler-Enums pro Sub-Modul verwendet. Dies ermöglicht eine klare und kontextbezogene Fehlerbehandlung.1

* **Definition der modulspezifischen Error-Enums:**  
  * AIInteractionError  
  * NotificationError  
* **Detaillierte Varianten, Nutzung von \#\[error(...)\] und \#\[from\]:**  
  * **AIInteractionError:**  
    Rust  
    use thiserror::Error;  
    use crate::core::types::Uuid; // Standard Uuid Typ aus der Kernschicht

    \#  
    pub enum AIInteractionError {  
        \#  
        ContextNotFound(Uuid),

        \#  
        ConsentAlreadyProvided(Uuid), // Spezifischer Fall, wenn ein erneutes explizites provide\_consent für bereits erteilte Zustimmung erfolgt

        \#\[error("Consent required for model '{model\_id}' but not granted for data categories: {missing\_categories:?}")\]  
        ConsentRequired { model\_id: String, missing\_categories: Vec\<String\> }, // String für AIDataCategory hier vereinfacht

        \#\[error("No suitable AI model available or configured.")\]  
        NoModelAvailable,

        \#\[error("AI Model '{model\_id}' not found or not configured.")\]  
        ModelNotFound(String),

        \#\[error("Invalid attachment data provided: {0}")\]  
        InvalidAttachment(String), // z.B. ungültiger Pfad, nicht unterstützter MIME-Typ

        \#\[error("Failed to store or retrieve consent: {0}")\]  
        ConsentStorageError(String), // Generisch für Fehler beim Speichern/Laden von AIConsent

        \#\[error("Failed to load AI model profiles: {0}")\]  
        ModelProfileLoadError(String),

        \#\[error("An underlying core error occurred: {source}")\]  
        CoreError { \#\[from\] source: crate::core::errors::CoreError }, // Annahme: Es gibt einen CoreError in der Kernschicht

        \#\[error("An unexpected internal error occurred: {0}")\]  
        InternalError(String),  
    }

  * **NotificationError:**  
    Rust  
    use thiserror::Error;  
    use crate::core::types::Uuid;

    \#  
    pub enum NotificationError {  
        \#  
        NotFound(Uuid),

        \# // z.B. leerer Summary  
        InvalidData{ summary: String, details: String },

        \#\[error("Maximum notification history of {max\_history} reached. Cannot add new notification: {summary}")\]  
        HistoryFull { max\_history: usize, summary: String },

        \#  
        ActionNotFound { notification\_id: Uuid, action\_id: String },

        \#\[error("An underlying core error occurred: {source}")\]  
        CoreError { \#\[from\] source: crate::core::errors::CoreError },

        \#\[error("An unexpected internal error occurred: {0}")\]  
        InternalError(String),  
    }

* **Spezifikation der Verwendung:**  
  * Diese Fehler werden als Err-Variante in Result\<T, E\>-Typen der öffentlichen API-Methoden der jeweiligen Services zurückgegeben.2  
  * Die \#\[from\]-Direktive wird genutzt, um Fehler aus der Kernschicht (z.B. CoreError beim Speichern/Laden von Konfigurationen für Einwilligungen oder Modellprofile) transparent in AIInteractionError oder NotificationError umzuwandeln. Dies erleichtert die Fehlerweitergabe (?-Operator) und erhält gleichzeitig die Fehlerquelle über die source()-Methode des std::error::Error-Traits.3  
  * Die \#\[error("...")\]-Nachrichten sind prägnant formuliert, um den Fehlerzustand klar zu beschreiben, wie in den Rust API Guidelines und 3 empfohlen (kleingeschrieben, ohne abschließende Interpunktion).  
  * Die Definition spezifischer Fehler-Enums pro logischem Service (AIInteractionError, NotificationError) folgt der Projektrichtlinie (4.3) und der Empfehlung aus 1, um Klarheit in der Fehlerbehandlung zu schaffen und es dem aufrufenden Code zu ermöglichen, spezifisch auf Fehlerfälle zu reagieren.  
  * Ein wichtiger Aspekt, der bei der Verwendung von thiserror mit \#\[from\] zu beachten ist, wurde in 2 hervorgehoben: Wenn mehrere Operationen innerhalb eines Services potenziell denselben *Basistyp* eines Fehlers aus einer unteren Schicht (z.B. std::io::Error, gekapselt in CoreError) für *unterschiedliche logische Fehlerfälle* im aktuellen Service erzeugen könnten, kann die alleinige Verwendung von \#\[from\] für eine generische CoreError-Variante den spezifischen Kontext verwischen.  
    * Beispiel: Sowohl das Speichern einer AIConsent als auch das Laden von AIModelProfile könnten intern eine CoreError::IoError verursachen. Wenn AIInteractionError nur CoreError { \#\[from\] source: CoreError } hätte, wäre aus dem Fehlertyp allein nicht ersichtlich, welche der beiden Operationen fehlgeschlagen ist.  
    * **Lösung und Spezifikation:** Für solche Fälle werden spezifischere Fehlervarianten ohne \#\[from\] für CoreError definiert, die stattdessen die CoreError (oder die relevante Information daraus) als Feld halten. Die \#\[error("...")\]-Nachricht dieser spezifischen Variante muss dann den Kontext klarstellen.  
      * Im obigen AIInteractionError sind ConsentStorageError(String) und ModelProfileLoadError(String) Beispiele dafür. Sie würden manuell in der Service-Logik konstruiert, z.B. indem ein von core::config zurückgegebener CoreError abgefangen und in diese spezifischeren Varianten umgewandelt wird, wobei die String-Payload die Details des Fehlers enthält.  
      * Die generische AIInteractionError::CoreError { \#\[from\] source: CoreError } Variante dient dann als Catch-All für andere, nicht spezifisch behandelte CoreError-Fälle aus diesem Service. Dies stellt sicher, dass der semantische Kontext des Domänenfehlers erhalten bleibt, während die Fehlerquelle (source()) weiterhin zugänglich ist, was für Debugging und Fehleranalyse von großer Bedeutung ist.2  
* **Wichtige Tabelle: Fehler-Enums für domain::user\_centric\_services**

| Fehler-Enum | Variante | \#\[error(...)\] Nachricht (Beispiel) | Felder (Typen) | Beschreibung / Auslösekontext |
| :---- | :---- | :---- | :---- | :---- |
| AIInteractionError | ContextNotFound | "AI interaction context not found for ID: {0}" | Uuid | Eine angeforderte AIInteractionContext ID existiert nicht. |
|  | ConsentRequired | "Consent required for model '{model\_id}' but not granted for data categories: {missing\_categories:?}" | model\_id: String, missing\_categories: Vec\<String\> | Für die geplante Aktion/Modell fehlt die notwendige Einwilligung. |
|  | ModelNotFound | "AI Model '{0}' not found or not configured." | String | Ein spezifisches KI-Modell wurde nicht gefunden oder ist nicht konfiguriert. |
|  | ConsentStorageError | "Failed to store or retrieve consent: {0}" | String | Fehler beim persistenten Speichern oder Laden einer AIConsent. |
|  | ModelProfileLoadError | "Failed to load AI model profiles: {0}" | String | Fehler beim Laden der AIModelProfile Konfigurationen. |
|  | CoreError | "An underlying core error occurred: {source}" | \#\[from\] source: crate::core::errors::CoreError | Ein nicht spezifisch behandelter Fehler aus der Kernschicht ist aufgetreten und wurde weitergeleitet. |
| NotificationError | NotFound | "Notification not found for ID: {0}" | Uuid | Eine angeforderte Benachrichtigungs-ID existiert nicht. |
|  | InvalidData | "Invalid notification data: {summary} (Details: {details})" | summary: String, details: String | Die übergebenen Daten zur Erstellung einer Benachrichtigung sind ungültig (z.B. leerer Summary). |
|  | HistoryFull | "Maximum notification history of {max\_history} reached. Cannot add new notification: {summary}" | max\_history: usize, summary: String | Das konfigurierte Benachrichtigungslimit in der Historie wurde erreicht. |
|  | ActionNotFound | "Action '{action\_id}' not found for notification ID: {notification\_id}" | notification\_id: Uuid, action\_id: String | Eine angeforderte Aktion für eine Benachrichtigung existiert nicht. |
|  | CoreError | "An underlying core error occurred: {source}" | \#\[from\] source: crate::core::errors::CoreError | Ein nicht spezifisch behandelter Fehler aus der Kernschicht ist aufgetreten und wurde weitergeleitet. |

Diese strukturierte Fehlerbehandlung ist für die Entwicklung robuster Software unerlässlich. Sie ermöglicht nicht nur eine präzise Fehlerdiagnose während der Entwicklung, sondern auch die Implementierung einer differenzierten Fehlerbehandlung im aufrufenden Code, bis hin zur Anzeige benutzerfreundlicher Fehlermeldungen in der UI.  
**6\. Detaillierte Implementierungsschritte und Dateistruktur für domain::user\_centric\_services**

* **6.1. Vorgeschlagene Dateistruktur:**  
  src/domain/user\_centric\_services/  
  ├── mod.rs               // Deklariert Submodule, exportiert öffentliche Typen/Traits  
  ├── ai\_interaction\_service.rs // Implementierung von AIInteractionLogicService (z.B. DefaultAIInteractionLogicService)  
  ├── notification\_service.rs   // Implementierung von NotificationService (z.B. DefaultNotificationService)  
  ├── types.rs             // Gemeinsame Enums (AIConsentStatus, AIDataCategory etc.) und Wertobjekte, Entitätsdefinitionen  
  └── errors.rs            // Definition von AIInteractionError und NotificationError

* **6.2. Nummerierte, schrittweise Anleitung zur Implementierung:**  
  1. **errors.rs erstellen:** Definieren Sie die AIInteractionError und NotificationError Enums mithilfe von thiserror wie im vorherigen Abschnitt spezifiziert. Stellen Sie sicher, dass sie Debug, Clone, PartialEq, Eq (falls für Testzwecke oder spezifische Logik benötigt) implementieren.  
  2. **types.rs erstellen:**  
     * Definieren Sie alle modulspezifischen Enums: AIConsentStatus, AIDataCategory, NotificationUrgency, NotificationActionType, NotificationFilterCriteria, NotificationSortOrder.  
     * Definieren Sie die Wertobjekte: NotificationAction, AttachmentData.  
     * Definieren Sie die Entitätsstrukturen: AIInteractionContext, AIConsent, AIModelProfile, Notification. Implementieren Sie für diese Debug, Clone, PartialEq und ggf. Serialize/Deserialize (von serde), falls sie direkt persistiert oder über IPC-Grenzen gesendet werden sollen. Fügen Sie Konstruktor-Methoden (new()) und andere relevante Logik direkt zu diesen Strukturen hinzu.  
  3. **ai\_interaction\_service.rs Basis:**  
     * Definieren Sie den Trait AIInteractionLogicService (wie in Abschnitt 3.1).  
     * Erstellen Sie eine Struktur DefaultAIInteractionLogicService. Diese Struktur wird Felder für den internen Zustand enthalten, z.B. active\_contexts: std::collections::HashMap\<Uuid, AIInteractionContext\>, consents: Vec\<AIConsent\> (oder eine Abstraktion für die Persistenz), model\_profiles: Vec\<AIModelProfile\>. Sie benötigt möglicherweise eine Abhängigkeit zu einer Komponente der Kernschicht für Persistenz.  
     * Beginnen Sie mit der Implementierung von \#\[async\_trait\] impl AIInteractionLogicService for DefaultAIInteractionLogicService {... }.  
  4. **notification\_service.rs Basis:**  
     * Definieren Sie den Trait NotificationService (wie in Abschnitt 3.1).  
     * Erstellen Sie eine Struktur DefaultNotificationService. Diese Struktur wird Felder für den internen Zustand enthalten, z.B. active\_notifications: Vec\<Notification\>, history: std::collections::VecDeque\<Notification\>, dnd\_enabled: bool.  
     * Beginnen Sie mit der Implementierung von \#\[async\_trait\] impl NotificationService for DefaultNotificationService {... }.  
  5. **Implementierung der AIInteractionLogicService-Methoden in DefaultAIInteractionLogicService:**  
     * Implementieren Sie jede Methode des Traits schrittweise. Achten Sie auf die korrekte Fehlerbehandlung und Rückgabe der definierten AIInteractionError-Varianten.  
     * Für Methoden, die Persistenz erfordern (z.B. store\_consent, load\_model\_profiles), definieren Sie die Interaktion mit der (noch abstrakten) Kernschichtkomponente.  
     * Stellen Sie sicher, dass die entsprechenden Events (z.B. AIInteractionInitiatedEvent, AIConsentUpdatedEvent) an den dafür vorgesehenen Stellen ausgelöst werden. Der genaue Mechanismus zur Event-Veröffentlichung (z.B. ein globaler Event-Bus, direkte Callbacks) muss projektweit definiert sein; hier wird nur das logische Auslösen spezifiziert.  
  6. **Implementierung der NotificationService-Methoden in DefaultNotificationService:**  
     * Implementieren Sie jede Methode des Traits. Achten Sie auf die Logik für DND, Historienbegrenzung (MAX\_NOTIFICATION\_HISTORY), Filterung und Sortierung.  
     * Verwenden Sie NotificationError-Varianten für Fehlerfälle.  
     * Lösen Sie die spezifizierten Notification-Events aus.  
  7. **mod.rs erstellen:**  
     * Deklarieren Sie die Submodule: pub mod errors;, pub mod types;, pub mod ai\_interaction\_service;, pub mod notification\_service;.  
     * Exportieren Sie die öffentlichen Typen, Traits und Fehler-Enums, die von außerhalb dieses Moduls verwendet werden sollen:  
       Rust  
       pub use errors::{AIInteractionError, NotificationError};  
       pub use types::{  
           AIInteractionContext, AIConsent, AIModelProfile, Notification, NotificationAction, AttachmentData,  
           AIConsentStatus, AIDataCategory, NotificationUrgency, NotificationActionType,  
           NotificationFilterCriteria, NotificationSortOrder  
       };  
       pub use ai\_interaction\_service::AIInteractionLogicService;  
       pub use notification\_service::NotificationService;

       // Optional: Konkrete Service-Typen exportieren, wenn sie direkt instanziiert werden sollen  
       // pub use ai\_interaction\_service::DefaultAIInteractionLogicService;  
       // pub use notification\_service::DefaultNotificationService;

  8. **Unit-Tests:** Schreiben Sie parallel zur Implementierung jeder Methode und jeder komplexen Logikeinheit Unit-Tests in den jeweiligen Service-Dateien (z.B. in einem \#\[cfg(test)\] mod tests {... } Block).

**7\. Interaktionen und Abhängigkeiten (domain::user\_centric\_services)**

* **Nutzung von Funktionalitäten der Kernschicht:**  
  * core::types: Verwendung von Uuid für eindeutige Identifikatoren und chrono::DateTime\<Utc\> für Zeitstempel.  
  * core::errors: Die CoreError-Typen der Kernschicht werden über \#\[from\] in die modulspezifischen Fehler AIInteractionError und NotificationError überführt, um Fehlerursachen aus der Kernschicht weiterzuleiten.  
  * core::config: Für das Laden von AIModelProfile-Konfigurationen und das persistente Speichern/Laden von AIConsent-Daten. Die Services in diesem Domänenmodul delegieren die eigentlichen Lese-/Schreiboperationen an die Kernschicht.  
  * core::logging: Das tracing-Framework wird innerhalb der Service-Implementierungen für strukturiertes Logging verwendet, um den Ablauf und mögliche Fehler nachvollziehen zu können.  
* **Schnittstellen zu System- und UI-Schicht:**  
  * Die definierten Traits AIInteractionLogicService und NotificationService stellen die primären Schnittstellen für höhere Schichten dar.  
  * Die **Systemschicht** wird diese Services nutzen:  
    * Der MCP-Client (in system::mcp) wird mit dem AIInteractionLogicService interagieren, um Einwilligungen zu prüfen und Interaktionskontexte zu verwalten.  
    * D-Bus Handler (in system::dbus), die z.B. den org.freedesktop.Notifications-Standard implementieren, werden den NotificationService verwenden, um Benachrichtigungen zu empfangen und Aktionen weiterzuleiten.  
  * Die **Benutzeroberflächenschicht (UI Layer)** wird ebenfalls mit diesen Services interagieren:  
    * UI-Komponenten für KI-Interaktionen (z.B. eine Befehlspalette oder ein Chat-Fenster) rufen Methoden des AIInteractionLogicService auf.  
    * Das ui::control\_center könnte Einstellungen für KI-Modelle oder Einwilligungen über den AIInteractionLogicService verwalten.  
    * Die Benachrichtigungsanzeige (ui::notifications) abonniert Events wie NotificationPostedEvent und ruft Methoden wie get\_active\_notifications oder mark\_as\_read des NotificationService auf.  
  * Events, die in diesem Domänenmodul ausgelöst werden (z.B. NotificationPostedEvent, AIConsentUpdatedEvent), werden primär von der UI-Schicht abonniert, um die Benutzeroberfläche entsprechend zu aktualisieren.  
* **Interaktionen mit anderen Modulen der Domänenschicht:**  
  * domain::global\_settings\_and\_state\_management: Globale Einstellungen, die das Verhalten der KI oder der Benachrichtigungen beeinflussen (z.B. Standard-KI-Modell, globale Einwilligungs-Standardeinstellungen, Standard-DND-Verhalten, maximale Historienlänge für Benachrichtigungen), könnten aus dem GlobalSettingsService gelesen werden. Änderungen an diesen Einstellungen könnten wiederum das Verhalten der Services in diesem Modul beeinflussen.  
  * domain::workspaces: Der AIInteractionContext könnte Informationen über den aktuellen Workspace (z.B. aktive Anwendung, Fenstertitel) enthalten, um den KI-Modellen besseren Kontext zu liefern. Diese Informationen würden vom AIInteractionLogicService aus dem domain::workspaces Modul bezogen.

**8\. Testaspekte für Unit-Tests (domain::user\_centric\_services)**  
Umfassende Unit-Tests sind entscheidend, um die Korrektheit der komplexen Logik in diesem Modul sicherzustellen.

* **Identifikation testkritischer Logik:**  
  * **AIInteractionLogicService:**  
    * Korrekte Erstellung, Aktualisierung und Abruf von AIInteractionContext.  
    * Logik der Einwilligungsprüfung (get\_consent\_for\_model), insbesondere die korrekte Auswertung von required\_consent\_categories der AIModelProfile gegen angefragte und erteilte AIDataCategory.  
    * Korrekte Erstellung und Speicherung (Mock) von AIConsent-Objekten.  
    * Laden und Filtern von AIModelProfile.  
    * Fehlerbehandlung für alle definierten AIInteractionError-Fälle.  
    * Korrekte Auslösung von Events.  
  * **NotificationService:**  
    * Korrekte Erstellung von Notification-Objekten und Zuweisung von IDs/Timestamps.  
    * Verwaltung der active\_notifications-Liste und der history-Deque, insbesondere die Einhaltung von MAX\_NOTIFICATION\_HISTORY.  
    * Logik des DND-Modus (Unterdrückung von Benachrichtigungen, Ausnahmen für Critical).  
    * Filter- und Sortierlogik für get\_active\_notifications und get\_notification\_history.  
    * Zustandsübergänge von Benachrichtigungen (is\_read, is\_dismissed).  
    * Korrekte Auslösung von Events.  
    * Fehlerbehandlung für alle definierten NotificationError-Fälle.  
* **Beispiele für Testfälle:**  
  * **AIInteractionLogicService Tests:**  
    * test\_initiate\_interaction\_creates\_context\_with\_unique\_id\_and\_fires\_event  
    * test\_provide\_consent\_granted\_updates\_context\_status\_and\_stores\_consent\_fires\_event  
    * test\_provide\_consent\_denied\_updates\_context\_status\_fires\_event  
    * test\_get\_consent\_for\_model\_no\_consent\_needed\_returns\_not\_required  
    * test\_get\_consent\_for\_model\_consent\_pending\_returns\_pending  
    * test\_get\_consent\_for\_model\_consent\_granted\_returns\_granted  
    * test\_get\_consent\_for\_model\_missing\_categories\_returns\_pending\_or\_error  
    * test\_list\_available\_models\_returns\_correctly\_loaded\_profiles  
    * test\_add\_attachment\_to\_context\_succeeds  
    * test\_get\_interaction\_context\_not\_found\_returns\_error  
    * test\_load\_model\_profiles\_error\_from\_core\_propagates\_as\_model\_profile\_load\_error  
  * **NotificationService Tests:**  
    * test\_post\_notification\_adds\_to\_active\_and\_history\_fires\_event  
    * test\_post\_notification\_when\_history\_full\_evicts\_oldest  
    * test\_post\_notification\_transient\_not\_added\_to\_history  
    * test\_post\_notification\_dnd\_active\_normal\_urgency\_suppressed\_fires\_event\_with\_suppressed\_flag  
    * test\_post\_notification\_dnd\_active\_critical\_urgency\_not\_suppressed  
    * test\_dismiss\_notification\_removes\_from\_active\_sets\_flag\_fires\_event  
    * test\_mark\_as\_read\_sets\_flag\_fires\_event  
    * test\_get\_active\_notifications\_filters\_unread\_correctly  
    * test\_get\_notification\_history\_sorted\_by\_timestamp\_descending  
    * test\_clear\_history\_empties\_history\_list  
    * test\_set\_do\_not\_disturb\_updates\_state\_and\_fires\_event  
    * test\_invoke\_action\_unknown\_notification\_id\_returns\_not\_found\_error  
    * test\_invoke\_action\_unknown\_action\_key\_returns\_action\_not\_found\_error  
* **Mocking:**  
  * Für Tests, die von der Kernschicht abhängen (z.B. core::config für das Laden/Speichern von AIConsent oder AIModelProfile), müssen Mocks dieser Kernschichtkomponenten erstellt werden. Dies kann durch Definition von Traits in der Kernschicht geschehen, die dann im Test durch Mock-Implementierungen ersetzt werden (z.B. mit dem mockall-Crate).  
  * Der Event-Mechanismus sollte ebenfalls mockbar sein, um zu überprüfen, ob Events korrekt ausgelöst werden.

---

**Entwicklungsmodul D: domain::global\_settings\_and\_state\_management**  
Dieses Modul ist für die Repräsentation, die Logik zur Verwaltung und die Konsistenz des globalen Zustands und der Einstellungen der Desktop-Umgebung zuständig, die nicht spezifisch einem anderen Domänenmodul zugeordnet sind oder von mehreren Modulen gemeinsam genutzt werden. Es fungiert als zentrale Anlaufstelle innerhalb der Domänenschicht für den Zugriff auf Konfigurationen und deren Modifikation.  
**1\. Modulübersicht und Verantwortlichkeiten (domain::global\_settings\_and\_state\_management)**

* **Zweck:** Bereitstellung einer kohärenten, typsicheren und validierten Abstraktion über die vielfältigen globalen Einstellungen und Zustände der Desktop-Umgebung. Dieses Modul definiert die "Quelle der Wahrheit" für diese Einstellungen innerhalb der Domänenschicht und stellt sicher, dass Änderungen konsistent angewendet und kommuniziert werden.  
* **Kernaufgaben:**  
  * Definition einer oder mehrerer umfassender Datenstrukturen (z.B. GlobalDesktopSettings), die alle globalen Desktop-Einstellungen kategorisiert repräsentieren (z.B. Erscheinungsbild, Verhalten, Eingabeoptionen, Energieverwaltungsrichtlinien, Standardanwendungen).  
  * Bereitstellung von Logik zur Validierung von Einstellungsänderungen anhand vordefinierter Regeln (z.B. Wertebereiche, gültige Optionen).  
  * Verwaltung des Lebenszyklus dieser Einstellungen: Laden von Standardwerten, Initialisierung aus persistenten Speichern (Delegation an die Kernschicht) und Persistierung von Änderungen.  
  * Benachrichtigung anderer Systemteile (innerhalb der Domänenschicht sowie höhere Schichten) über erfolgte Einstellungsänderungen mittels eines Event-Mechanismus.  
  * Verwaltung von globalen, nicht-persistenten Zuständen, die für die Dauer einer Benutzersitzung relevant sind und nicht direkt durch Systemdienste wie logind abgedeckt werden (z.B. ein anwendungsdefinierter "Desktop gesperrt"-Zustand, falls komplexere Logik als reine Sitzungssperrung benötigt wird).  
* **Abgrenzung:**  
  * Dieses Modul implementiert **nicht** die grafische Benutzeroberfläche zur Darstellung oder Änderung der Einstellungen. Diese Aufgabe obliegt der Komponente ui::control\_center in der Benutzeroberflächenschicht.  
  * Es implementiert **nicht** die tatsächliche Speicherung und das Laden von Konfigurationsdateien vom Dateisystem. Diese Low-Level-Operationen werden an eine Komponente der Kernschicht (z.B. core::config) delegiert. Das domain::global\_settings\_and\_state\_management-Modul definiert *was* gespeichert wird, die Struktur der Daten und die Regeln für deren Gültigkeit.  
  * Es verwaltet **keine** anwendungsspezifischen Einstellungen einzelner Drittanwendungen. Der Fokus liegt auf den globalen Einstellungen der Desktop-Umgebung selbst.  
* **Zugehörige Komponenten aus der Gesamtübersicht:** domain::settings.

**2\. Datenstrukturen und Typdefinitionen (Rust) für domain::global\_settings\_and\_state\_management**  
Die Datenstrukturen sind darauf ausgelegt, eine breite Palette von Einstellungen hierarchisch und typsicher abzubilden. Alle Einstellungsstrukturen müssen serde::Serialize und serde::Deserialize implementieren, um die Interaktion mit der Persistenzschicht (core::config) und die Verarbeitung von Einstellungsänderungen über serde\_json::Value zu ermöglichen.

* **2.1. Entitäten und Wertobjekte (primär Konfigurationsstrukturen):**  
  * **GlobalDesktopSettings (Hauptstruktur):**  
    Rust  
    use serde::{Serialize, Deserialize};  
    // Annahme: Pfade zu untergeordneten Typen sind korrekt  
    // use super::types::{AppearanceSettings, WorkspaceSettings,...};

    \#  
    pub struct GlobalDesktopSettings {  
        \#\[serde(default)\]  
        pub appearance: AppearanceSettings,  
        \#\[serde(default)\]  
        pub workspace\_config: WorkspaceSettings, // Umbenannt von workspace\_settings zur Klarheit (Konfiguration vs. Laufzeit)  
        \#\[serde(default)\]  
        pub input\_behavior: InputBehaviorSettings,  
        \#\[serde(default)\]  
        pub power\_management\_policy: PowerManagementPolicySettings,  
        \#\[serde(default)\]  
        pub default\_applications: DefaultApplicationsSettings,  
        // Weitere Kategorien können hier hinzugefügt werden, z.B.:  
        // \#\[serde(default)\]  
        // pub accessibility: AccessibilitySettings,  
        // \#\[serde(default)\]  
        // pub privacy: PrivacySettings,  
    }

    Die Verwendung von \#\[serde(default)\] stellt sicher, dass beim Deserialisieren einer unvollständigen Konfiguration die Standardwerte für fehlende Felder verwendet werden, was die Robustheit gegenüber Konfigurationsänderungen über Versionen hinweg erhöht.  
  * **AppearanceSettings:**  
    * Attribute:  
      * active\_theme\_name: String (z.B. "Adwaita-dark", "Nordic")  
      * color\_scheme: ColorScheme (Enum: Light, Dark, AutoSystem)  
      * accent\_color\_token: String (CSS-Token-Name, z.B. "--accent-blue", "--accent-custom-hexFFA07A")  
      * font\_settings: FontSettings  
      * icon\_theme\_name: String (z.B. "Papirus", "Numix")  
      * cursor\_theme\_name: String (z.B. "Adwaita", "Bibata-Modern-Ice")  
      * enable\_animations: bool  
      * interface\_scaling\_factor: f64 (z.B. 1.0, 1.25, 2.0; Validierung: \> 0.0)  
    * Methoden (konzeptionell): validate() prüft die Gültigkeit der Werte (z.B. Skalierungsfaktor \> 0).  
  * **WorkspaceSettings (Domänenlogik für Einstellungen, nicht der Workspace-Manager selbst):**  
    * Attribute:  
      * dynamic\_workspaces: bool (Workspaces werden bei Bedarf erstellt/entfernt)  
      * default\_workspace\_count: u8 (Nur relevant, wenn dynamic\_workspaces false ist; Validierung: \> 0\)  
      * workspace\_switching\_behavior: WorkspaceSwitchingBehavior (Enum: WrapAround, StopAtEdges)  
      * show\_workspace\_indicator: bool (Ob ein Indikator (z.B. im Panel) angezeigt wird)  
  * **FontSettings:**  
    * Attribute:  
      * default\_font\_family: String (z.B. "Noto Sans", "Cantarell")  
      * default\_font\_size: u8 (in Punkten, z.B. 10, 11; Validierung: z.B. 6-72)  
      * monospace\_font\_family: String (z.B. "Fira Code", "DejaVu Sans Mono")  
      * document\_font\_family: String (z.B. "Liberation Serif")  
      * hinting: FontHinting (Enum: None, Slight, Medium, Full)  
      * antialiasing: FontAntialiasing (Enum: None, Grayscale, Rgba)  
  * **InputBehaviorSettings:**  
    * Attribute:  
      * mouse\_acceleration\_profile: MouseAccelerationProfile (Enum: Flat, Adaptive, Custom(f32))  
      * mouse\_sensitivity: f32 (Validierung: z.B. 0.1 \- 10.0)  
      * natural\_scrolling\_mouse: bool  
      * natural\_scrolling\_touchpad: bool  
      * tap\_to\_click\_touchpad: bool  
      * touchpad\_pointer\_speed: f32 (Validierung: z.B. 0.1 \- 10.0)  
      * keyboard\_repeat\_delay\_ms: u32 (Validierung: z.B. 100-2000)  
      * keyboard\_repeat\_rate\_cps: u32 (Zeichen pro Sekunde; Validierung: z.B. 10-100)  
  * **PowerManagementPolicySettings (High-Level Richtlinien, die systemnahe Implementierung erfolgt in der Systemschicht):**  
    * Attribute:  
      * screen\_blank\_timeout\_ac\_secs: u32 (0 für nie; Validierung: z.B. 0 oder \>= 60\)  
      * screen\_blank\_timeout\_battery\_secs: u32 (0 für nie; Validierung: z.B. 0 oder \>= 30\)  
      * suspend\_action\_on\_lid\_close\_ac: LidCloseAction (Enum: Suspend, Hibernate, Shutdown, DoNothing, LockScreen)  
      * suspend\_action\_on\_lid\_close\_battery: LidCloseAction  
      * automatic\_suspend\_delay\_ac\_secs: u32 (0 für nie)  
      * automatic\_suspend\_delay\_battery\_secs: u32 (0 für nie)  
      * show\_battery\_percentage: bool  
  * **DefaultApplicationsSettings:**  
    * Attribute:  
      * web\_browser\_desktop\_file: String (Name der.desktop-Datei, z.B. "firefox.desktop")  
      * email\_client\_desktop\_file: String (z.B. "thunderbird.desktop")  
      * terminal\_emulator\_desktop\_file: String (z.B. "org.gnome.Console.desktop")  
      * file\_manager\_desktop\_file: String (z.B. "org.gnome.Nautilus.desktop")  
      * music\_player\_desktop\_file: String  
      * video\_player\_desktop\_file: String  
      * image\_viewer\_desktop\_file: String  
      * text\_editor\_desktop\_file: String  
* **2.2. Modulspezifische Enums, Konstanten und Konfigurationsstrukturen:**  
  * **Enums (alle mit Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default):**  
    * ColorScheme: \#\[default\] Light, Dark, AutoSystem.  
    * FontHinting: None, Slight, \#\[default\] Medium, Full.  
    * FontAntialiasing: None, Grayscale, \#\[default\] Rgba.  
    * MouseAccelerationProfile: \#\[default\] Adaptive, Flat, Custom(SerdeF32) (Wrapper für f32 für Default).  
    * LidCloseAction: \#\[default\] Suspend, Hibernate, Shutdown, LockScreen, DoNothing.  
    * WorkspaceSwitchingBehavior: \#\[default\] WrapAround, StopAtEdges.  
    * **Hilfsstruktur für f32 Default in Enums (da f32 nicht Eq ist):**  
      Rust  
      \#  
      pub struct SerdeF32(pub f32);  
      impl Default for SerdeF32 { fn default() \-\> Self { SerdeF32(1.0) } } // Beispiel-Default

  * **SettingPath (Strukturierter Enum für typsicheren Zugriff):**  
    Rust  
    \#  
    pub enum SettingPath {  
        Appearance(AppearanceSettingPath),  
        WorkspaceConfig(WorkspaceSettingPath),  
        InputBehavior(InputBehaviorSettingPath),  
        PowerManagementPolicy(PowerManagementPolicySettingPath),  
        DefaultApplications(DefaultApplicationsSettingPath),  
        // Weitere Top-Level Kategorien  
    }

    \#  
    pub enum AppearanceSettingPath {  
        ActiveThemeName, ColorScheme, AccentColorToken,  
        FontSettings(FontSettingPath), // Verschachtelt  
        IconThemeName, CursorThemeName, EnableAnimations, InterfaceScalingFactor,  
    }

    \#  
    pub enum FontSettingPath { // Beispiel für weitere Verschachtelung  
        DefaultFontFamily, DefaultFontSize, MonospaceFontFamily, DocumentFontFamily, Hinting, Antialiasing,  
    }  
    // Ähnliche Enums für WorkspaceSettingPath, InputBehaviorSettingPath etc. definieren.  
    // Diese Struktur ermöglicht eine präzise Adressierung einzelner Einstellungen.  
    // Für die Implementierung von \`get\_setting\` und \`update\_setting\` ist eine  
    // Konvertierung von/zu String-basierten Pfaden (z.B. "appearance.font\_settings.default\_font\_size")  
    // oder eine direkte Verarbeitung dieser Enum-Pfade erforderlich.

    Die SettingPath-Struktur ist entscheidend für die update\_setting-Methode, da sie eine typsichere und explizite Weise bietet, auf spezifische Einstellungen zuzugreifen, anstatt fehleranfällige String-Pfade zu verwenden.  
* **2.3. Definition aller deklarierten Eigenschaften (Properties):**  
  * Für GlobalSettingsService (als Trait implementiert):  
    * current\_settings: GlobalDesktopSettings (logisch): Der aktuelle Satz aller globalen Einstellungen. Der Zugriff erfolgt über Methoden wie get\_current\_settings() oder get\_setting(\&SettingPath). Modifikationen erfolgen über update\_setting(...).  
* **Wichtige Tabelle: Ausgewählte globale Einstellungen und ihre Eigenschaften**

| Struktur/Kategorie | Attribut/Einstellung | Rust-Typ | Standardwert (Beispiel) | Beschreibung / Gültigkeitsbereich / Validierungsregeln (Beispiele) |
| :---- | :---- | :---- | :---- | :---- |
| AppearanceSettings | active\_theme\_name | String | "default\_light\_theme" | Name des aktuell aktiven GTK-Themes. Muss ein installierter Theme-Name sein. |
|  | color\_scheme | ColorScheme | AutoSystem | Bevorzugtes Farbschema (Hell, Dunkel, Systemeinstellung folgen). |
|  | accent\_color\_token | String | "--accent-blue" | CSS-Token-Name der Akzentfarbe (z.B. "--accent-color-1"). |
|  | enable\_animations | bool | true | Ob Desktop-Animationen (Fenster, Übergänge etc.) aktiviert sind. |
|  | interface\_scaling\_factor | f64 | 1.0 | Globaler Skalierungsfaktor für die UI. Validierung: 0.5 \<= x \<= 3.0. |
| FontSettings | default\_font\_family | String | "Cantarell" | Standard-Schriftart für UI-Elemente. Muss eine installierte Schriftart sein. |
|  | default\_font\_size | u8 | 11 | Standard-Schriftgröße in Punkten. Validierung: 6 \<= size \<= 72\. |
| InputBehaviorSettings | natural\_scrolling\_touchpad | bool | true | Ob natürliches Scrollen (Inhaltsbewegung mit Fingerbewegung) für Touchpads aktiviert ist. |
|  | tap\_to\_click\_touchpad | bool | true | Ob Tippen zum Klicken für Touchpads aktiviert ist. |
|  | keyboard\_repeat\_delay\_ms | u32 | 500 | Verzögerung in ms bis Tastenwiederholung einsetzt. Validierung: 100 \<= delay \<= 2000\. |
| PowerManagementPolicySettings | screen\_blank\_timeout\_ac\_secs | u32 | 600 (10 Min.) | Timeout in Sekunden bis Bildschirmabschaltung im Netzbetrieb. 0 für nie. Validierung: 0 oder 30 \<= secs \<= 7200\. |
|  | suspend\_action\_on\_lid\_close\_battery | LidCloseAction | Suspend | Aktion beim Schließen des Laptop-Deckels im Akkubetrieb. |
| DefaultApplicationsSettings | web\_browser\_desktop\_file | String | "firefox.desktop" | Name der.desktop-Datei des Standard-Webbrowsers. Muss eine gültige, installierte.desktop-Datei sein. |

Diese Tabelle hebt einige der wichtigsten konfigurierbaren Aspekte des Desktops hervor. Die Definition von Standardwerten und Validierungsregeln ist entscheidend für die Robustheit des Systems und eine gute Benutzererfahrung, da sie ungültige Konfigurationen verhindert.  
**3\. Öffentliche API und Interne Schnittstellen (Rust) für domain::global\_settings\_and\_state\_management**  
Die öffentliche API wird durch den GlobalSettingsService-Trait definiert.

* **3.1. Exakte Signaturen aller öffentlichen Funktionen/Methoden:**  
  * **GlobalSettingsService Trait:**  
    Rust  
    use crate::core::errors::CoreError;  
    use super::types::{GlobalDesktopSettings, SettingPath}; // SettingPath wie oben definiert  
    use super::errors::GlobalSettingsError;  
    use async\_trait::async\_trait;  
    use serde\_json::Value as JsonValue; // Alias für Klarheit

    // SubscriptionId für das Abbestellen von Änderungen  
    // pub type SubscriptionId \= Uuid; // Beispiel

    \#\[async\_trait\]  
    pub trait GlobalSettingsService: Send \+ Sync {  
        /// Lädt die Einstellungen aus der persistenten Speicherung (via Kernschicht).  
        /// Falls keine Konfiguration vorhanden ist oder Fehler auftreten, werden Standardwerte verwendet  
        /// und ggf. eine Fehlermeldung geloggt oder ein spezifischer Fehler zurückgegeben.  
        async fn load\_settings(\&mut self) \-\> Result\<(), GlobalSettingsError\>;

        /// Speichert die aktuellen Einstellungen persistent (via Kernschicht).  
        async fn save\_settings(\&self) \-\> Result\<(), GlobalSettingsError\>;

        /// Gibt eine (tiefe) Kopie der aktuellen \`GlobalDesktopSettings\` zurück.  
        fn get\_current\_settings(\&self) \-\> GlobalDesktopSettings;

        /// Aktualisiert eine spezifische Einstellung unter dem gegebenen \`SettingPath\`.  
        /// Der \`value\`-Parameter ist ein \`serde\_json::Value\`, um Flexibilität zu gewährleisten.  
        /// Interne Logik muss diesen Wert in den korrekten Rust-Typ der Zieleinstellung  
        /// deserialisieren und validieren.  
        async fn update\_setting(  
            \&mut self,  
            path: SettingPath,  
            value: JsonValue  
        ) \-\> Result\<(), GlobalSettingsError\>;

        /// Gibt den Wert einer spezifischen Einstellung unter dem gegebenen \`SettingPath\`  
        /// als \`serde\_json::Value\` zurück.  
        fn get\_setting(\&self, path: \&SettingPath) \-\> Result\<JsonValue, GlobalSettingsError\>;

        /// Setzt alle Einstellungen auf ihre definierten Standardwerte zurück.  
        /// Die Änderungen werden anschließend persistent gespeichert.  
        async fn reset\_to\_defaults(\&mut self) \-\> Result\<(), GlobalSettingsError\>;

        // Die Implementierung von \`subscribe\_to\_setting\_changes\` und \`unsubscribe\`  
        // ist komplex und hängt stark vom gewählten Event-Mechanismus des Projekts ab.  
        // Für eine erste Iteration könnte ein globales \`SettingChangedEvent\` ausreichen,  
        // das den Pfad und den neuen Wert enthält.  
        //  
        // async fn subscribe\_to\_setting\_changes(  
        //     \&self,  
        //     path\_filter: Option\<SettingPath\>, // None für alle Änderungen  
        //     // Der Callback erhält den Pfad und den neuen Wert  
        //     callback: Box\<dyn Fn(SettingPath, JsonValue) \+ Send \+ Sync \+ 'static\>  
        // ) \-\> Result\<SubscriptionId, GlobalSettingsError\>;  
        //  
        // async fn unsubscribe(\&self, id: SubscriptionId) \-\> Result\<(), GlobalSettingsError\>;  
    }

* **3.2. Vor- und Nachbedingungen, Beschreibung der Logik/Algorithmen:**  
  * GlobalSettingsService::update\_setting(path: SettingPath, value: JsonValue):  
    * Vorbedingung:  
      * path muss auf eine gültige, existierende Einstellung innerhalb der GlobalDesktopSettings-Struktur verweisen.  
      * value (JsonValue) muss in den Ziel-Rust-Typ der durch path adressierten Einstellung deserialisierbar sein.  
      * Der deserialisierte Wert muss alle anwendungsspezifischen Validierungsregeln für diese Einstellung erfüllen (z.B. Wertebereich, gültige Enum-Variante).  
    * Logik:  
      1. **Pfad-Navigation:** Navigiere innerhalb der intern gehaltenen GlobalDesktopSettings-Instanz zum durch path spezifizierten Feld. Dies erfordert eine Mapping-Logik vom SettingPath-Enum zu den tatsächlichen Struct-Feldern.  
      2. **Typ-Prüfung und Deserialisierung:** Ermittle den erwarteten Rust-Typ des Zielfeldes. Versuche, das JsonValue in diesen Typ zu deserialisieren (z.B. serde\_json::from\_value::\<TargetType\>(value)).  
         * Bei Fehlschlag: Rückgabe von GlobalSettingsError::InvalidValueType mit Details zum erwarteten und erhaltenen Typ.  
      3. **Validierung:** Führe spezifische Validierungsregeln für die Einstellung durch. Diese Regeln sind Teil der Domänenlogik (z.B. appearance.interface\_scaling\_factor muss zwischen 0.5 und 3.0 liegen).  
         * Bei Fehlschlag: Rückgabe von GlobalSettingsError::ValidationError mit einer beschreibenden Nachricht.  
      4. **Aktualisierung:** Wenn Deserialisierung und Validierung erfolgreich waren, aktualisiere den Wert des Zielfeldes in der internen GlobalDesktopSettings-Instanz.  
      5. **Event-Auslösung:** Löse ein SettingChangedEvent aus, das den path und das (ggf. serialisierte) new\_value enthält, um andere Systemteile zu informieren.  
      6. **Persistenz (optional, konfigurierbar):** Rufe intern save\_settings() auf, um die Änderung sofort persistent zu machen. Alternativ könnten Änderungen gesammelt und später oder auf explizite Anforderung gespeichert werden, um die I/O-Last zu reduzieren. Für eine Desktop-Umgebung ist eine zeitnahe Persistenz meist erwünscht.  
    * Nachbedingung:  
      * Entweder wurde die Einstellung erfolgreich aktualisiert, ein SettingChangedEvent wurde ausgelöst und die Änderung wurde (ggf.) persistiert.  
      * Oder es wurde ein GlobalSettingsError (z.B. PathNotFound, InvalidValueType, ValidationError) zurückgegeben, und der Zustand der Einstellungen bleibt unverändert.  
  * GlobalSettingsService::load\_settings():  
    * Vorbedingung: Keine spezifischen, außer dass der Service initialisiert ist.  
    * Logik:  
      1. Interagiere mit der Kernschicht-Komponente (z.B. core::config), um die GlobalDesktopSettings-Struktur aus einem persistenten Speicher (z.B. Konfigurationsdatei) zu laden.  
      2. Die Kernschicht-Komponente ist für die Deserialisierung der Daten verantwortlich.  
      3. **Fehlerbehandlung beim Laden:**  
         * Wenn die Konfigurationsdatei nicht existiert oder nicht lesbar ist: Verwende die Default::default()-Implementierung von GlobalDesktopSettings (oder eine explizite Methode zur Erzeugung von Standardwerten). Logge eine Warnung.  
         * Wenn die Konfigurationsdatei korrupt ist oder nicht deserialisiert werden kann: Verwende Standardwerte. Logge einen Fehler. GlobalSettingsError::PersistenceError könnte zurückgegeben werden, oder der Service initialisiert sich mit Defaults und loggt den Fehler. Für eine robuste Nutzererfahrung ist das Laden von Defaults oft besser als ein harter Fehler.  
         * Wenn die geladene Konfiguration veraltet ist (z.B. Felder fehlen): serde füllt dank \#\[serde(default)\] fehlende Felder mit ihren Standardwerten auf.  
      4. Speichere die geladenen (oder Standard-) Einstellungen in der internen Instanz von GlobalDesktopSettings.  
      5. Löse ein SettingsLoadedEvent mit den initialisierten Einstellungen aus.  
    * Nachbedingung: Die interne GlobalDesktopSettings-Instanz des Service ist mit den geladenen oder Standardeinstellungen initialisiert. Ein SettingsLoadedEvent wurde ausgelöst.  
* **3.3. Modulspezifische Trait-Definitionen und relevante Implementierungen:**  
  * Der GlobalSettingsService-Trait ist die zentrale öffentliche Schnittstelle.  
  * Alle Einstellungsstrukturen (GlobalDesktopSettings, AppearanceSettings, etc.) müssen std::fmt::Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize und Default implementieren.  
    * Serialize und Deserialize sind fundamental für die Interaktion mit core::config (Persistenz) und für die update\_setting/get\_setting-API, die serde\_json::Value verwendet.  
    * Default ist wichtig für die Erzeugung von Standardkonfigurationen und für \#\[serde(default)\].  
    * PartialEq ist nützlich für Tests und um festzustellen, ob sich ein Wert tatsächlich geändert hat.  
* **3.4. Exakte Definition aller Methoden für Komponenten mit komplexem internen Zustand oder Lebenszyklus:**  
  * Die Hauptkomponente mit komplexem Zustand ist die Implementierung von GlobalSettingsService (z.B. DefaultGlobalSettingsService). Diese Struktur hält die current\_settings: GlobalDesktopSettings als ihren primären Zustand.  
  * Die Komplexität in den Methoden update\_setting und get\_setting liegt in der robusten und korrekten Handhabung des SettingPath:  
    * **Pfad-Auflösung:** Eine effiziente Methode, um von einem SettingPath-Enum-Wert auf das entsprechende Feld in der verschachtelten GlobalDesktopSettings-Struktur zuzugreifen und dessen Typ zu kennen. Dies könnte über match-Anweisungen oder eine komplexere Makro-basierte Lösung erfolgen, um Boilerplate-Code zu reduzieren.  
    * **Dynamische Typkonvertierung:** Die Konvertierung zwischen serde\_json::Value und den stark typisierten Rust-Feldern erfordert sorgfältige Fehlerbehandlung bei der Deserialisierung.  
    * **Validierungslogik:** Die Implementierung der spezifischen Validierungsregeln für jede Einstellung.

**4\. Event-Spezifikationen für domain::global\_settings\_and\_state\_management**  
Events dienen der Benachrichtigung anderer Systemkomponenten über Änderungen an den globalen Einstellungen.

* **Event: SettingChangedEvent**  
  * Event-Typ (Rust-Typ): pub struct SettingChangedEvent { pub path: SettingPath, pub new\_value: JsonValue }  
  * Payload-Struktur: Enthält den SettingPath der geänderten Einstellung und deren neuen Wert als JsonValue. Die Verwendung von JsonValue hier bietet Flexibilität, da der Subscriber den Wert bei Bedarf in den spezifischen Typ deserialisieren kann.  
  * Typische Publisher: Die Implementierung von GlobalSettingsService (nach einem erfolgreichen Aufruf von update\_setting oder reset\_to\_defaults).  
  * Typische Subscriber:  
    * ui::control\_center: Um die Anzeige der Einstellungen in der UI zu aktualisieren.  
    * domain::theming\_engine: Um auf Änderungen in AppearanceSettings (z.B. active\_theme\_name, accent\_color\_token) zu reagieren und das Theme dynamisch neu zu laden/anzuwenden.  
    * system::compositor: Könnte auf Änderungen wie appearance.enable\_animations oder appearance.interface\_scaling\_factor reagieren.  
    * Andere Domänenmodule oder Systemdienste, deren Verhalten von globalen Einstellungen abhängt (z.B. system::input für Mausempfindlichkeit, system::outputs für Standard-Bildschirmhelligkeit basierend auf Energieeinstellungen).  
  * Auslösebedingungen: Eine einzelne Einstellung wurde erfolgreich geändert und validiert. Bei reset\_to\_defaults wird für jede geänderte Einstellung ein separates Event ausgelöst oder ein übergreifendes "Reset"-Event.  
* **Event: SettingsLoadedEvent**  
  * Event-Typ (Rust-Typ): pub struct SettingsLoadedEvent { pub settings: GlobalDesktopSettings }  
  * Payload-Struktur: Enthält eine Kopie der vollständig geladenen GlobalDesktopSettings.  
  * Typische Publisher: Die Implementierung von GlobalSettingsService (nach einem erfolgreichen Aufruf von load\_settings während der Initialisierung).  
  * Typische Subscriber: Initialisierungscode anderer Module, die auf die ersten geladenen Einstellungen warten, um sich zu konfigurieren. UI-Komponenten, um ihren initialen Zustand zu setzen.  
  * Auslösebedingungen: Die globalen Einstellungen wurden erfolgreich initial aus dem persistenten Speicher geladen oder mit Standardwerten initialisiert.  
* **Event: SettingsSavedEvent**  
  * Event-Typ (Rust-Typ): pub struct SettingsSavedEvent; (Kann leer sein, da der reine Akt des Speicherns signalisiert wird. Optional könnten Details wie der Zeitpunkt oder Erfolg/Misserfolg von Teiloperationen enthalten sein, falls relevant.)  
  * Payload-Struktur: In der Regel keine, dient als reines Signal.  
  * Typische Publisher: Die Implementierung von GlobalSettingsService (nach einem erfolgreichen Aufruf von save\_settings).  
  * Typische Subscriber: Logging-Systeme; UI-Komponenten, die dem Benutzer eine kurze Bestätigung anzeigen könnten (z.B. "Einstellungen gespeichert").  
  * Auslösebedingungen: Die aktuellen globalen Einstellungen wurden erfolgreich in den persistenten Speicher geschrieben.  
* **Wichtige Tabelle: Event-Spezifikationen für domain::global\_settings\_and\_state\_management**

| Event-Name/Typ (Rust) | Payload-Struktur (Felder, Typen) | Typische Publisher | Typische Subscriber | Auslösebedingungen |
| :---- | :---- | :---- | :---- | :---- |
| SettingChangedEvent | path: SettingPath, new\_value: JsonValue | GlobalSettingsService | ui::control\_center, domain::theming\_engine, system::compositor, andere Module, die von Einstellungen abhängen | Eine spezifische Einstellung wurde erfolgreich geändert und validiert. |
| SettingsLoadedEvent | settings: GlobalDesktopSettings | GlobalSettingsService | Initialisierungscode von Modulen, UI-Komponenten für initialen Zustand | Globale Einstellungen wurden beim Start erfolgreich geladen oder mit Standardwerten initialisiert. |
| SettingsSavedEvent | (Normalerweise keine, oder Details zum Speichervorgang) | GlobalSettingsService | Logging-Systeme, UI für Feedback | Aktuelle globale Einstellungen wurden erfolgreich persistent gespeichert. |

Diese Event-Struktur ist entscheidend für die Reaktionsfähigkeit und Konsistenz der Desktop-Umgebung. Sie ermöglicht es verschiedenen Teilen des Systems, auf Änderungen der globalen Konfiguration zu reagieren, ohne direkt an den GlobalSettingsService gekoppelt zu sein.  
**5\. Fehlerbehandlung (Rust mit thiserror) für domain::global\_settings\_and\_state\_management**  
Die Fehlerbehandlung folgt den etablierten Projektrichtlinien unter Verwendung von thiserror.

* **Definition des modulspezifischen Error-Enums:**  
  * GlobalSettingsError  
* **Detaillierte Varianten, Nutzung von \#\[error(...)\] und \#\[from\]:**  
  Rust  
  use thiserror::Error;  
  use crate::core::errors::CoreError; // Fehler aus der Kernschicht  
  use super::types::SettingPath; // Annahme: SettingPath implementiert Display oder wird hier formatiert  
  use serde\_json::Error as SerdeJsonError; // Für die Kapselung von serde\_json Fehlern

  // Wrapper für serde\_json::Error, um es Cloneable etc. zu machen, falls GlobalSettingsError das sein muss.  
  // Alternativ kann man auch nur die String-Repräsentation des Fehlers speichern.  
  \#  
  \#  
  pub struct WrappedSerdeJsonError(\#\[from\] SerdeJsonError);

  // Um Clone, PartialEq, Eq für WrappedSerdeJsonError zu ermöglichen, wenn benötigt:  
  // impl Clone for WrappedSerdeJsonError { fn clone(\&self) \-\> Self { WrappedSerdeJsonError(self.0.to\_string()) } } // Vereinfacht  
  // impl PartialEq for WrappedSerdeJsonError { fn eq(\&self, other: \&Self) \-\> bool { self.0.to\_string() \== other.0.to\_string() } }  
  // impl Eq for WrappedSerdeJsonError {}

  \# // Clone, PartialEq, Eq können hinzugefügt werden, wenn die Fehler verglichen werden müssen.  
                         // Dies erfordert, dass alle \#\[source\] Fehler dies ebenfalls unterstützen oder gewrapped werden.  
  pub enum GlobalSettingsError {  
      \#  
      PathNotFound { path\_description: String }, // String-Repräsentation des SettingPath

      \#\[error("Invalid value type provided for setting '{path\_description}'. Expected '{expected\_type}', but got value '{actual\_value\_preview}'.")\]  
      InvalidValueType {  
          path\_description: String,  
          expected\_type: String,  
          actual\_value\_preview: String, // Eine kurze Vorschau des fehlerhaften JSON-Wertes  
      },

      \#\[error("Validation failed for setting '{path\_description}': {message}")\]  
      ValidationError { path\_description: String, message: String },

      \#  
      SerializationError {  
          path\_description: String,  
          \#\[source\] source: WrappedSerdeJsonError,  
      },

      \#  
      DeserializationError {  
          path\_description: String,  
          \#\[source\] source: WrappedSerdeJsonError,  
      },

      // Spezifischer Fehler für Persistenzprobleme, der die CoreError kapselt  
      \#\[error("Persistence error ({operation}) for settings: {message}")\]  
      PersistenceError {  
          operation: String, // "load" oder "save"  
          message: String,  
          \#\[source\] source: Option\<CoreError\>, // CoreError ist hier optional, da der Fehler auch direkt hier entstehen kann  
      },

      // Generischer Fallback für andere CoreErrors, die nicht durch PersistenceError abgedeckt sind  
      \#\[error("An underlying core error occurred: {source}")\]  
      CoreError { \#\[from\] source: CoreError },

      \#\[error("An unexpected internal error occurred in settings management: {0}")\]  
      InternalError(String),  
  }

  // Implementierung, um aus einem serde\_json::Error und Kontext einen GlobalSettingsError zu machen  
  impl GlobalSettingsError {  
      pub fn from\_serde\_deserialize(err: SerdeJsonError, path: \&SettingPath) \-\> Self {  
          GlobalSettingsError::DeserializationError {  
              path\_description: format\!("{:?}", path), // Bessere Formatierung für SettingPath wäre hier gut  
              source: WrappedSerdeJsonError(err),  
          }  
      }  
      pub fn from\_serde\_serialize(err: SerdeJsonError, path: \&SettingPath) \-\> Self {  
          GlobalSettingsError::SerializationError {  
              path\_description: format\!("{:?}", path),  
              source: WrappedSerdeJsonError(err),  
          }  
      }  
  }

  Die WrappedSerdeJsonError-Struktur dient dazu, serde\_json::Error zu kapseln, da dieser Typ selbst nicht unbedingt alle Traits implementiert (wie Clone oder Eq), die für GlobalSettingsError gewünscht sein könnten. Die from\_serde\_deserialize und from\_serde\_serialize Hilfsmethoden erleichtern die Konvertierung.  
* **Spezifikation der Verwendung:**  
  * GlobalSettingsError wird als Err-Variante in den Result-Typen der Methoden des GlobalSettingsService zurückgegeben.  
  * \#\[from\] für CoreError wird für die generische CoreError-Variante verwendet, um nicht anderweitig behandelte Fehler von der Kernschicht (z.B. beim tatsächlichen Lesen/Schreiben von Dateien durch core::config) zu konvertieren.  
  * Die spezifische Variante PersistenceError wird für Fehler verwendet, die direkt beim Laden oder Speichern der Einstellungen auftreten und eine CoreError als Ursache haben können. Dies gibt mehr Kontext als ein generischer CoreError.  
  * SerializationError und DeserializationError kapseln Fehler von serde\_json, die bei der Konvertierung von/zu JsonValue oder beim Speichern/Laden auftreten können.  
  * Die Fehler-Enums und ihre Varianten sind so gestaltet, dass sie den Empfehlungen aus 2 und 1 folgen: spezifische Fehler pro Modul, klare \#\[error(...)\]-Nachrichten und die Möglichkeit des Fehler-Chainings mittels \#\[source\].  
  * Die Granularität der Fehlervarianten wie InvalidValueType und ValidationError ist besonders hervorzuheben. Sie sind nicht nur für das Logging und Debugging durch Entwickler von Bedeutung, sondern können auch dazu dienen, der Benutzeroberflächenschicht (ui::control\_center) präzise Informationen zu liefern, warum eine Einstellungsänderung fehlgeschlagen ist. Beispielsweise kann die UI die path\_description verwenden, um das fehlerhafte Eingabefeld hervorzuheben, und die message aus ValidationError direkt dem Benutzer anzeigen. Dies verbessert die Benutzererfahrung erheblich im Vergleich zu generischen Fehlermeldungen und ist ein direktes Ergebnis der Überlegung, Fehler so zu gestalten, dass sie die Perspektive des Benutzers berücksichtigen, wie in 2 angedeutet ("What happens from the user's perspective.").  
* **Wichtige Tabelle: Fehler-Enum GlobalSettingsError**

| Fehler-Enum | Variante | \#\[error(...)\] Nachricht (Beispiel) | Felder (Typen) | Beschreibung / Auslösekontext |
| :---- | :---- | :---- | :---- | :---- |
| GlobalSettingsError | PathNotFound | "Setting path not found: {path\_description}" | path\_description: String | Der angegebene SettingPath zu einer Einstellung existiert nicht in der GlobalDesktopSettings-Struktur. |
|  | InvalidValueType | "Invalid value type provided for setting '{path\_description}'. Expected '{expected\_type}', got '{actual\_value\_preview}'." | path\_description: String, expected\_type: String, actual\_value\_preview: String | Der für eine Einstellung übergebene JsonValue konnte nicht in den erwarteten Rust-Typ deserialisiert werden. |
|  | ValidationError | "Validation failed for setting '{path\_description}': {message}" | path\_description: String, message: String | Der Wert für eine Einstellung ist zwar vom korrekten Typ, aber ungültig gemäß den Domänenregeln (z.B. außerhalb des erlaubten Wertebereichs). |
|  | SerializationError | "Serialization error for setting '{path\_description}': {source}" | path\_description: String, source: WrappedSerdeJsonError | Fehler bei der Serialisierung eines Einstellungs-Wertes nach JsonValue (z.B. für die get\_setting-Methode oder Event-Payloads). |
|  | DeserializationError | "Deserialization error for setting '{path\_description}': {source}" | path\_description: String, source: WrappedSerdeJsonError | Fehler bei der Deserialisierung eines JsonValue in einen Rust-Typ (z.B. in update\_setting oder beim Laden aus der Kernschicht). |
|  | PersistenceError | "Persistence error ({operation}) for settings: {message}" | operation: String, message: String, source: Option\<CoreError\> | Ein Fehler ist beim Laden ("load") oder Speichern ("save") der Einstellungen durch die Kernschicht aufgetreten. |
|  | CoreError | "An underlying core error occurred: {source}" | \#\[from\] source: CoreError | Ein allgemeiner, nicht spezifisch durch PersistenceError abgedeckter Fehler aus der Kernschicht ist aufgetreten und wurde weitergeleitet. |

Diese detaillierte Fehlerklassifizierung ist für ein robustes Einstellungsmanagement unerlässlich. Sie ermöglicht es aufrufendem Code, differenziert auf Probleme zu reagieren und dem Benutzer kontextsensitive Rückmeldungen zu geben.  
**6\. Detaillierte Implementierungsschritte und Dateistruktur für domain::global\_settings\_and\_state\_management**

* **6.1. Vorgeschlagene Dateistruktur:**  
  src/domain/global\_settings\_management/ // Alternativ: src/domain/settings/  
  ├── mod.rs               // Deklariert Submodule, exportiert öffentliche Typen/Traits  
  ├── service.rs           // Implementierung des GlobalSettingsService (z.B. DefaultGlobalSettingsService)  
  ├── types.rs             // Definition von GlobalDesktopSettings und allen untergeordneten Einstellungs-Structs und \-Enums  
  ├── paths.rs             // Definition von SettingPath und ggf. Hilfsfunktionen zur Pfad-Konvertierung/Navigation  
  └── errors.rs            // Definition von GlobalSettingsError und WrappedSerdeJsonError

* **6.2. Nummerierte, schrittweise Anleitung zur Implementierung:**  
  1. **errors.rs erstellen:** Definieren Sie GlobalSettingsError und die Hilfsstruktur WrappedSerdeJsonError wie im vorherigen Abschnitt spezifiziert.  
  2. **types.rs erstellen:**  
     * Definieren Sie die Hauptstruktur GlobalDesktopSettings.  
     * Definieren Sie alle untergeordneten Einstellungs-Structs (AppearanceSettings, FontSettings, WorkspaceSettings, etc.).  
     * Definieren Sie alle zugehörigen Enums (ColorScheme, FontHinting, LidCloseAction, etc.).  
     * Implementieren Sie für alle diese Strukturen und Enums die notwendigen Traits: Debug, Clone, PartialEq, Serialize, Deserialize und Default. Achten Sie auf die korrekte Verwendung von \#\[serde(default)\] für Felder in Strukturen und \#\[default\] für Enum-Varianten.  
     * Implementieren Sie Default für GlobalDesktopSettings und alle ihre Felder, um einen vollständigen Satz von Standardeinstellungen zu definieren.  
  3. **paths.rs erstellen:**  
     * Definieren Sie die SettingPath-Enum-Hierarchie (z.B. SettingPath, AppearanceSettingPath, FontSettingPath, etc.) wie skizziert.  
     * Implementieren Sie Serialize und Deserialize für SettingPath, falls es über Events oder APIs in serialisierter Form verwendet wird.  
     * Optional: Entwickeln Sie Hilfsfunktionen oder Makros, die das Navigieren in einer GlobalDesktopSettings-Instanz basierend auf einem SettingPath erleichtern oder die Konvertierung zu/von einem String-basierten Pfad (z.B. "appearance.font\_settings.default\_font\_size") ermöglichen.  
  4. **service.rs Basis:**  
     * Definieren Sie den Trait GlobalSettingsService (wie in Abschnitt 3.1).  
     * Erstellen Sie eine Struktur DefaultGlobalSettingsService. Diese wird eine Instanz von GlobalDesktopSettings als internen Zustand halten: settings: GlobalDesktopSettings.  
     * Diese Struktur benötigt eine Abhängigkeit zu einer Komponente der Kernschicht (z.B. einem ConfigManager Trait), um Einstellungen zu laden und zu speichern. Diese Abhängigkeit sollte über den Konstruktor injiziert werden.  
     * Beginnen Sie mit der Implementierung von \#\[async\_trait\] impl GlobalSettingsService for DefaultGlobalSettingsService {... }.  
  5. **Implementierung der GlobalSettingsService-Methoden in DefaultGlobalSettingsService:**  
     * load\_settings: Implementieren Sie die Logik zum Laden der GlobalDesktopSettings von der Kernschicht-Abhängigkeit. Behandeln Sie Fehler beim Laden (Datei nicht vorhanden, korrupt) durch Rückgriff auf GlobalDesktopSettings::default(). Lösen Sie das SettingsLoadedEvent aus.  
     * save\_settings: Implementieren Sie die Logik zum Speichern der aktuellen internen settings über die Kernschicht-Abhängigkeit. Lösen Sie das SettingsSavedEvent aus.  
     * get\_current\_settings: Gibt einen Klon der internen settings-Instanz zurück.  
     * update\_setting: Dies ist die komplexeste Methode.  
       * Implementieren Sie die Pfad-Navigationslogik, um das spezifische Feld innerhalb von self.settings basierend auf dem SettingPath zu identifizieren.  
       * Deserialisieren Sie das JsonValue in den Zieltyp.  
       * Führen Sie die Validierung durch.  
       * Bei Erfolg: Aktualisieren Sie das Feld, lösen Sie das SettingChangedEvent aus und rufen Sie self.save\_settings().await auf.  
       * Geben Sie bei Fehlern die entsprechenden GlobalSettingsError-Varianten zurück.  
     * get\_setting: Implementieren Sie die Pfad-Navigation und serialisieren Sie den gefundenen Wert nach JsonValue.  
     * reset\_to\_defaults: Setzen Sie self.settings \= GlobalDesktopSettings::default();. Lösen Sie für jede (geänderte) Einstellung ein SettingChangedEvent aus (oder ein globales Reset-Event). Rufen Sie self.save\_settings().await auf.  
  6. **mod.rs erstellen:** Deklarieren Sie die Submodule (errors, types, paths, service) und exportieren Sie alle öffentlichen Typen, Traits und Fehler, die von anderen Teilen des Systems verwendet werden sollen.  
  7. **Unit-Tests:** Schreiben Sie umfassende Unit-Tests parallel zur Implementierung jeder Methode. Testen Sie insbesondere die Pfad-Navigation, (De-)Serialisierung, Validierungslogik und Fehlerfälle in update\_setting und get\_setting. Mocken Sie die Kernschicht-Abhängigkeit für Lade-/Speicheroperationen.

**7\. Interaktionen und Abhängigkeiten (domain::global\_settings\_and\_state\_management)**

* **Nutzung von Funktionalitäten der Kernschicht:**  
  * core::config (oder eine äquivalente Komponente/Trait): Dies ist die Hauptabhängigkeit für die Persistenz. Der GlobalSettingsService delegiert das tatsächliche Lesen von und Schreiben in Konfigurationsdateien (oder andere Speicherorte) an diese Kernschichtkomponente. Der Service stellt die Logik und die Datenstruktur (GlobalDesktopSettings) bereit, während core::config die I/O-Operationen und die (De-)Serialisierung von/zu einem bestimmten Dateiformat (z.B. TOML, JSON) übernimmt.  
  * core::errors: CoreError-Typen, die von core::config zurückgegeben werden (z.B. I/O-Fehler, Formatierungsfehler), werden in spezifischere GlobalSettingsError::PersistenceError oder die generische GlobalSettingsError::CoreError Variante umgewandelt.  
  * core::logging: Das tracing-Framework wird für internes Logging verwendet, z.B. um das Laden von Einstellungen, aufgetretene Fehler oder erfolgreiche Speicheroperationen zu protokollieren.  
* **Schnittstellen zu System- und UI-Schicht:**  
  * ui::control\_center: Dies ist der primäre Konsument des GlobalSettingsService in der UI-Schicht. Das Control Center wird:  
    * get\_current\_settings() oder multiple get\_setting() Aufrufe verwenden, um die aktuellen Werte für die Anzeige zu laden.  
    * update\_setting() aufrufen, wenn der Benutzer eine Einstellung ändert.  
    * Das SettingChangedEvent abonnieren, um die UI dynamisch zu aktualisieren, falls Einstellungen anderweitig (z.B. durch reset\_to\_defaults oder programmatisch) geändert werden.  
  * **Systemschicht-Komponenten:** Verschiedene Komponenten der Systemschicht können Einstellungen aus dem GlobalSettingsService lesen, um ihr Verhalten anzupassen:  
    * system::compositor: Könnte AppearanceSettings.enable\_animations, AppearanceSettings.interface\_scaling\_factor oder InputBehaviorSettings.mouse\_acceleration\_profile lesen.  
    * system::input: Könnte Einstellungen für Tastaturwiederholrate, Mausempfindlichkeit oder Touchpad-Verhalten (InputBehaviorSettings) anwenden.  
    * system::outputs (Display-Management): Könnte Standardwerte für Bildschirmhelligkeit oder Timeouts bis zum Blanking des Bildschirms aus PowerManagementPolicySettings beziehen.  
    * system::audio: Könnte eine globale Lautstärkeeinstellung oder Standardausgabegeräte hierüber beziehen, falls solche Einstellungen als global definiert werden.  
* **Interaktionen mit anderen Modulen der Domänenschicht:**  
  * domain::theming\_engine: Ein sehr enger Konsument. Liest alle relevanten AppearanceSettings (Theme-Name, Akzentfarbe, Schriftarten, Icons, Cursor) und muss auf SettingChangedEvent für diese Pfade reagieren, um das Desktop-Theme dynamisch neu zu generieren und anzuwenden.  
  * domain::workspace\_and\_window\_policy (oder domain::workspaces und domain::window\_management): Liest WorkspaceSettings (z.B. dynamische Workspaces) und relevante InputBehaviorSettings (z.B. Mausverhalten für Fensterinteraktionen).  
  * domain::user\_centric\_services: Könnte globale Standardeinstellungen für KI-Interaktionen (z.B. default\_ai\_model\_id, falls als globale Einstellung definiert) oder Benachrichtigungen (z.B. global\_do\_not\_disturb\_default\_state, max\_notification\_history\_override) aus dem GlobalSettingsService beziehen.

**8\. Testaspekte für Unit-Tests (domain::global\_settings\_and\_state\_management)**  
Die Testbarkeit dieses Moduls ist entscheidend für die Stabilität der gesamten Desktop-Umgebung.

* **Identifikation testkritischer Logik:**  
  * Die korrekte Deserialisierung von JsonValue in den spezifischen Rust-Typ der Zieleinstellung und die anschließende Validierung dieses Wertes in update\_setting. Dies umfasst die Behandlung von Typ-Mismatch und Wertebereichsverletzungen.  
  * Die korrekte Navigation zu verschachtelten Feldern innerhalb der GlobalDesktopSettings-Struktur mittels SettingPath in update\_setting und get\_setting.  
  * Die Fehlerbehandlung für ungültige Pfade (PathNotFound), falsche Wertetypen (InvalidValueType) und ungültige Werte (ValidationError).  
  * Die Logik zum Laden von Standardwerten (Default::default()) und das korrekte Mergen mit einer möglicherweise unvollständigen, aber gültigen Konfiguration aus dem persistenten Speicher (Sicherstellung, dass \#\[serde(default)\] wie erwartet funktioniert).  
  * Die korrekte Auslösung von SettingChangedEvent mit dem korrekten SettingPath und JsonValue als Payload nach einer erfolgreichen Aktualisierung.  
  * Die Interaktion mit der (gemockten) core::config-Schicht für Lade- und Speicheroperationen, einschließlich der korrekten Fehlerweitergabe.  
  * Die Funktionalität von reset\_to\_defaults.  
* **Beispiele für Testfälle:**  
  * test\_load\_settings\_new\_system\_uses\_defaults\_and\_fires\_loaded\_event  
  * test\_load\_settings\_existing\_config\_loads\_correctly\_and\_fires\_loaded\_event  
  * test\_load\_settings\_partial\_config\_fills\_missing\_with\_defaults  
  * test\_load\_settings\_corrupted\_config\_falls\_back\_to\_defaults\_logs\_error (benötigt Mock für core::config, der Fehler simuliert)  
  * test\_update\_setting\_valid\_value\_updates\_internal\_state\_fires\_changed\_event\_and\_saves  
  * test\_update\_setting\_valid\_value\_for\_nested\_path  
  * test\_update\_setting\_invalid\_json\_type\_returns\_invalid\_value\_type\_error (z.B. String für boolesches Feld)  
  * test\_update\_setting\_value\_violates\_validation\_rule\_returns\_validation\_error (z.B. Schriftgröße 200, wenn max 72\)  
  * test\_update\_setting\_nonexistent\_path\_returns\_path\_not\_found\_error  
  * test\_get\_setting\_existing\_path\_returns\_correct\_value\_as\_json  
  * test\_get\_setting\_nonexistent\_path\_returns\_path\_not\_found\_error  
  * test\_reset\_to\_defaults\_restores\_all\_settings\_fires\_changed\_events\_and\_saves  
  * Für jede Einstellungsstruktur (AppearanceSettings, etc.): Testen der (De-)Serialisierungslogik (serde) und der Default-Implementierung.  
  * Testen der SettingPath-Navigation: Sicherstellen, dass jeder definierte Pfad korrekt auf ein Feld zugreift.  
* **Mocking:**  
  * Eine Mock-Implementierung für die von core::config bereitgestellte Schnittstelle (z.B. ein trait ConfigPersistence) ist unerlässlich. Diese Mock-Implementierung muss es ermöglichen, erfolgreiche Lade-/Speicheroperationen sowie verschiedene Fehlerszenarien (Datei nicht gefunden, Lesefehler, Schreibfehler, korrupte Daten) zu simulieren. Crates wie mockall können hierfür verwendet werden.  
  * Der Event-Auslösemechanismus sollte ebenfalls mockbar sein, um zu verifizieren, dass Events korrekt und mit den richtigen Payloads gesendet werden.

---

**Zusammenfassende Betrachtungen zur Domänenschicht (für Teil 3/4)**  
Die in diesem Dokument detailliert spezifizierten Module domain::user\_centric\_services und domain::global\_settings\_and\_state\_management bilden zwei zentrale Säulen der Domänenschicht. Sie sind maßgeblich dafür verantwortlich, die Kernlogik für eine intelligente, personalisierte und anpassbare Benutzererfahrung bereitzustellen.  
Das Modul domain::user\_centric\_services kapselt die komplexe Logik für KI-gestützte Funktionen und das Benachrichtigungssystem. Die sorgfältige Definition von Entitäten wie AIInteractionContext und AIConsent, gepaart mit robusten Prozessen für das Einwilligungsmanagement, stellt sicher, dass KI-Funktionen verantwortungsvoll und unter Wahrung der Benutzerkontrolle integriert werden können. Das NotificationService bietet eine flexible und erweiterbare Grundlage für die Verwaltung aller System- und Anwendungsbenachrichtigungen.  
Das Modul domain::global\_settings\_and\_state\_management schafft die Voraussetzung für eine hochgradig konfigurierbare Desktop-Umgebung. Durch die zentrale, typsichere und validierte Verwaltung aller globalen Einstellungen in der GlobalDesktopSettings-Struktur und dem zugehörigen GlobalSettingsService wird Konsistenz über das gesamte System hinweg gewährleistet. Die Verwendung von serde für die (De-)Serialisierung und die klare Definition von SettingPath ermöglichen eine flexible und dennoch robuste Handhabung von Konfigurationsänderungen.  
Für beide Module ist die detaillierte Spezifikation der Fehlerbehandlung mittels thiserror von entscheidender Bedeutung. Die bewusste Entscheidung für spezifische Fehlervarianten und kontextreiche Fehlermeldungen, wie sie auch durch die Analyse der Referenzmaterialien 1 gestützt wird, erhöht nicht nur die Wartbarkeit und Debugfähigkeit des Codes, sondern ermöglicht es auch, dem Benutzer über die UI präzisere und hilfreichere Rückmeldungen bei Problemen zu geben. Die konsequente Auslösung von Events bei relevanten Zustandsänderungen ist fundamental für die Entkopplung der Module und die dynamische Reaktion der Benutzeroberfläche.  
Die hier vorgelegten Ultrafeinspezifikationen bieten eine solide Grundlage für die Implementierung dieser Domänenkomponenten. Die Entwickler können diese Pläne nutzen, um Module zu erstellen, die nicht nur funktional korrekt sind, sondern auch den hohen Anforderungen an Stabilität, Erweiterbarkeit und Benutzerfreundlichkeit der geplanten Desktop-Umgebung gerecht werden.

#### **Referenzen**

1. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 13, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)  
2. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
3. Error in std::error \- Rust, Zugriff am Mai 13, 2025, [https://doc.rust-lang.org/std/error/trait.Error.html](https://doc.rust-lang.org/std/error/trait.Error.html)
# **B4 Domänenschicht (Domain Layer) – Teil 4/4: Einstellungs- und Benachrichtigungs-Subsysteme**

Dieser Teil der Spezifikation widmet sich den verbleibenden Kernkomponenten der Domänenschicht: dem Subsystem für die Verwaltung von Einstellungen (domain::settings\_core und domain::settings\_persistence\_iface) sowie dem Subsystem für die Verarbeitung und Regelung von Benachrichtigungen (domain::notifications\_core und domain::notifications\_rules). Diese Module sind entscheidend für die Konfigurierbarkeit und das reaktive Verhalten der Desktop-Umgebung.

## **4.1. Entwicklungsmodul: Kernlogik für Einstellungen (domain::settings\_core)**

Dieses Modul bildet das Herzstück der Einstellungsverwaltung innerhalb der Domänenschicht. Es ist verantwortlich für die Definition, Validierung, Speicherung (über eine Abstraktionsschicht) und den Zugriff auf alle Konfigurationseinstellungen der Desktop-Umgebung.

### **4.1.1. Detaillierte Verantwortlichkeiten und Ziele**

* **Verantwortlichkeiten:**  
  * Definition der Struktur und Typen von Einstellungen (SettingKey, SettingValue, SettingMetadata, Setting).  
  * Bereitstellung einer zentralen Logik (SettingsCoreManager) zur Verwaltung dieser Einstellungen.  
  * Validierung von Einstellungswerten gegen definierte Metadaten (Typ, Bereich, erlaubte Werte).  
  * Koordination des Ladens und Speicherns von Einstellungen über eine abstrakte Persistenzschnittstelle (SettingsProvider).  
  * Benachrichtigung anderer Systemteile über Einstellungsänderungen mittels interner Events (SettingChangedEvent).  
* **Ziele:**  
  * Schaffung einer typsicheren und validierten Verwaltung von Einstellungen.  
  * Entkopplung der Einstellungslogik von der konkreten Speicherung und der Benutzeroberfläche.  
  * Ermöglichung einer reaktiven Anpassung des Systemverhaltens basierend auf Konfigurationsänderungen.  
  * Sicherstellung der Konsistenz und Integrität der Einstellungen.

### **4.1.2. Entitäten und Wertobjekte**

Die folgenden Datenstrukturen sind in domain/src/settings\_core/types.rs zu definieren. Sie müssen Debug, Clone und PartialEq implementieren. Für die Persistenz und den Datenaustausch ist zudem die Implementierung von serde::Serialize und serde::Deserialize für SettingValue und die darin enthaltenen Typen essenziell. Die uuid Crate wird für eindeutige IDs verwendet, wobei die Features v4 (zur Generierung) und serde (zur Serialisierung) aktiviert sein müssen.1 Für Zeitstempel wird chrono mit dem aktivierten serde-Feature eingesetzt.3

* **SettingKey (Newtype für String)**  
  * **Zweck:** Ein typsicherer Wrapper für den Schlüssel einer Einstellung (z.B. "appearance.theme.name", "notifications.do\_not\_disturb.enabled").  
  * **Warum wertvoll:** Erhöht die Typsicherheit und verhindert die versehentliche Verwendung beliebiger Strings als Einstellungsschlüssel. Fördert Klarheit im Code.  
  * **Implementierungsdetails:**  
    * Interner Typ: String.  
    * Sollte Display, Hash, Eq, PartialEq, Ord, PartialOrd, From\<String\>, AsRef\<str\> implementieren.  
    * Konstruktion z.B. über SettingKey::new("my.setting.key") oder From::from("my.setting.key").  
* **SettingValue (Enum)**  
  * **Zweck:** Ein Enum, das alle möglichen Typen von Einstellungswerten repräsentiert.  
  * **Warum wertvoll:** Ermöglicht eine flexible, aber dennoch typsichere Behandlung unterschiedlicher Einstellungsdatentypen an einer zentralen Stelle.  
  * **Varianten:**  
    * Boolean(bool)  
    * Integer(i64)  
    * Float(f64)  
    * String(String)  
    * Color(String): Hex-Farbcode (z.B. "\#RRGGBBAA").  
    * FilePath(String): Ein Pfad zu einer Datei oder einem Verzeichnis.  
    * List(Vec\<SettingValue\>): Eine geordnete Liste von SettingValue.  
    * Map(std::collections::HashMap\<String, SettingValue\>): Eine Schlüssel-Wert-Map.  
  * **Methoden (Beispiele):**  
    * pub fn as\_bool(\&self) \-\> Option\<bool\>  
    * pub fn as\_str(\&self) \-\> Option\<\&str\>  
    * Weitere as\_TYPE und try\_into\_TYPE Methoden für bequemen Zugriff und Konvertierung.  
* **SettingMetadata Struktur**  
  * **Zweck:** Enthält Metadaten zu einer Einstellung, wie Beschreibung, Standardwert, mögliche Werte (für Enums), Validierungsregeln.  
  * **Warum wertvoll:** Ermöglicht eine deklarative Definition von Einstellungen und deren Eigenschaften. Dies ist fundamental, um die Verwaltung, die automatische Generierung von Benutzeroberflächen für Einstellungen und die Validierung zu vereinfachen. Ohne Metadaten wäre jede Einstellungslogik ad-hoc und schwer zu warten.

| Attribut | Typ | Sichtbarkeit | Beschreibung |
| :---- | :---- | :---- | :---- |
| description | Option\<String\> | pub | Menschenlesbare Beschreibung der Einstellung. |
| default\_value | SettingValue | pub | Der Standardwert, der verwendet wird, wenn kein Wert gesetzt ist. |
| value\_type\_hint | String | pub | Hinweis auf den erwarteten SettingValue-Typ (z.B. "Boolean", "Integer"). |
| possible\_values | Option\<Vec\<SettingValue\>\> | pub | Für Enum-Typen: eine Liste der erlaubten Werte. |
| validation\_regex | Option\<String\> | pub | Für String-Typen: ein regulärer Ausdruck zur Validierung. |
| min\_value | Option\<SettingValue\> | pub | Für numerische Typen: der minimale erlaubte Wert. |
| max\_value | Option\<SettingValue\> | pub | Für numerische Typen: der maximale erlaubte Wert. |
| is\_sensitive | bool | pub | Gibt an, ob der Wert sensibel ist (z.B. Passwort, nicht loggen). Default: false. |
| requires\_restart | Option\<String\> | pub | Wenn Some(app\_id\_or\_service\_name), deutet an, dass eine Änderung einen Neustart der genannten Komponente erfordert. None bedeutet keinen Neustart. |

* **Setting Struktur (Entität)**  
  * **Zweck:** Repräsentiert eine einzelne, konkrete Einstellung mit ihrem aktuellen Wert und Metadaten.  
  * **Warum wertvoll:** Das zentrale Objekt, das eine Einstellung im System darstellt und deren Zustand und Verhalten kapselt.

| Attribut | Typ | Sichtbarkeit | Beschreibung | Invarianten |
| :---- | :---- | :---- | :---- | :---- |
| id | uuid::Uuid | pub | Eindeutige ID der Einstellung (intern verwendet). | Muss eindeutig sein. Generiert via Uuid::new\_v4(). |
| key | SettingKey | pub | Der eindeutige Schlüssel der Einstellung. | Muss eindeutig sein. |
| current\_value | SettingValue | pub(crate) | Der aktuell gesetzte Wert der Einstellung. | Muss den Validierungsregeln in metadata entsprechen, falls gesetzt. |
| metadata | SettingMetadata | pub | Metadaten, die diese Einstellung beschreiben. |  |
| last\_modified | chrono::DateTime\<Utc\> | pub(crate) | Zeitstempel der letzten Änderung. | Wird bei jeder erfolgreichen Wertänderung aktualisiert. |
| is\_dirty | bool | pub(crate) | true, wenn current\_value geändert wurde, aber noch nicht persistiert ist. |  |

\*   \*\*Methoden:\*\*  
    \*   \`pub fn new(key: SettingKey, metadata: SettingMetadata) \-\> Self\`: Erstellt eine neue Einstellung. Der \`current\_value\` wird initial auf \`metadata.default\_value\` gesetzt. \`id\` wird generiert. \`last\_modified\` wird auf \`Utc::now()\` gesetzt.  
    \*   \`pub fn value(\&self) \-\> \&SettingValue\`: Gibt eine Referenz auf den aktuellen Wert zurück.  
    \*   \`pub(crate) fn set\_value(\&mut self, new\_value: SettingValue, timestamp: chrono::DateTime\<Utc\>) \-\> Result\<(), SettingsCoreError\>\`: Setzt einen neuen Wert, nachdem dieser erfolgreich gegen \`self.metadata\` validiert wurde (interner Aufruf von \`validate\_value\`). Aktualisiert \`current\_value\` und \`last\_modified\`.  
    \*   \`pub fn validate\_value(value: \&SettingValue, metadata: \&SettingMetadata) \-\> Result\<(), SettingsCoreError\>\`: Statische Methode zur Validierung eines Wertes gegen die gegebenen Metadaten. Diese Methode ist separat, um auch externe Validierung zu ermöglichen, bevor \`set\_value\` aufgerufen wird.  
    \*   \`pub fn reset\_to\_default(\&mut self, timestamp: chrono::DateTime\<Utc\>)\`: Setzt den \`current\_value\` auf \`self.metadata.default\_value\` zurück und aktualisiert \`last\_modified\`.

### **4.1.3. Öffentliche API des Moduls (SettingsCoreManager)**

Der SettingsCoreManager, definiert in domain/src/settings\_core/mod.rs, ist die zentrale Schnittstelle zur Einstellungslogik. Er kapselt die Verwaltung der Setting-Objekte und die Interaktion mit dem Persistenz-Provider.  
Die Operationen zum Laden und Speichern von Einstellungen können I/O-intensiv sein. Um die Domänenschicht nicht zu blockieren, werden diese Methoden als async deklariert. Dies erfordert, dass der SettingsProvider ebenfalls asynchrone Methoden anbietet und als Arc\<dyn SettingsProvider \+ Send \+ Sync\> übergeben wird, um Thread-Sicherheit in asynchronen Kontexten zu gewährleisten.5  
Wenn Einstellungen geändert werden, müssen andere Teile der Domänenschicht (z.B. die NotificationRulesEngine oder das Theming-System) potenziell darüber informiert werden. Um eine lose Kopplung zu erreichen, sendet der SettingsCoreManager interne Events (SettingChangedEvent) über einen tokio::sync::broadcast::Sender.6 Interessierte Module können einen broadcast::Receiver abonnieren und auf diese Events reagieren, ohne dass der SettingsCoreManager explizite Kenntnis von ihnen haben muss. Dieser Mechanismus ist entscheidend für eine reaktive Architektur.

Rust

// domain/src/settings\_core/mod.rs  
use crate::settings\_persistence\_iface::{SettingsProvider, SettingsPersistenceError};  
use crate::settings\_core::types::{Setting, SettingKey, SettingValue, SettingMetadata};  
use crate::settings\_core::error::SettingsCoreError;  
use std::collections::HashMap;  
use std::sync::Arc;  
use tokio::sync::{RwLock, broadcast};  
use chrono::Utc;

\# // Clone ist wichtig für den broadcast::Sender  
pub struct SettingChangedEvent {  
    pub key: SettingKey,  
    pub new\_value: SettingValue,  
    pub old\_value: Option\<SettingValue\>,  
}

pub struct SettingsCoreManager {  
    settings: RwLock\<HashMap\<SettingKey, Setting\>\>,  
    provider: Arc\<dyn SettingsProvider \+ Send \+ Sync\>,  
    event\_sender: broadcast::Sender\<SettingChangedEvent\>,  
    registered\_metadata: RwLock\<HashMap\<SettingKey, SettingMetadata\>\>, // RwLock auch hier für dynamische Registrierung  
}

impl SettingsCoreManager {  
    pub fn new(  
        provider: Arc\<dyn SettingsProvider \+ Send \+ Sync\>,  
        initial\_metadata: Vec\<(SettingKey, SettingMetadata)\>,  
        event\_channel\_capacity: usize  
    ) \-\> Self {  
        let (event\_sender, \_) \= broadcast::channel(event\_channel\_capacity);  
        let mut metadata\_map \= HashMap::new();  
        for (key, meta) in initial\_metadata {  
            metadata\_map.insert(key, meta);  
        }

        SettingsCoreManager {  
            settings: RwLock::new(HashMap::new()),  
            provider,  
            event\_sender,  
            registered\_metadata: RwLock::new(metadata\_map),  
        }  
    }

    // Weitere Methoden folgen  
}

* **Tabelle: Methoden des SettingsCoreManager**

| Methode | Signatur | Kurzbeschreibung | Vorbedingungen | Nachbedingungen (Erfolg) | Nachbedingungen (Fehler) |
| :---- | :---- | :---- | :---- | :---- | :---- |
| new | pub fn new(provider: Arc\<dyn SettingsProvider \+ Send \+ Sync\>, initial\_metadata: Vec\<(SettingKey, SettingMetadata)\>, event\_channel\_capacity: usize) \-\> Self | Konstruktor. Initialisiert den Manager mit Provider, Metadaten und Event-Kanal-Kapazität. | provider ist valide. event\_channel\_capacity \> 0\. | SettingsCoreManager ist initialisiert. event\_sender ist erstellt. settings ist leer. registered\_metadata ist gefüllt. | \- |
| register\_setting\_metadata | pub async fn register\_setting\_metadata(\&self, key: SettingKey, metadata: SettingMetadata) \-\> Result\<(), SettingsCoreError\> | Registriert Metadaten für eine neue Einstellung zur Laufzeit. | key ist noch nicht registriert. | Metadaten für key sind in registered\_metadata gespeichert. | SettingsCoreError::SettingKeyAlreadyExists |
| load\_all\_settings | pub async fn load\_all\_settings(\&self) \-\> Result\<(), SettingsCoreError\> | Lädt alle Einstellungen, für die Metadaten registriert sind, vom SettingsProvider. | provider ist erreichbar. | Interne settings-Map ist mit geladenen Werten (oder Defaults aus Metadaten) gefüllt. | SettingsCoreError::PersistenceError, SettingsCoreError::ValidationError |
| get\_setting\_value | pub async fn get\_setting\_value(\&self, key: \&SettingKey) \-\> Result\<SettingValue, SettingsCoreError\> | Ruft den aktuellen Wert einer Einstellung ab. Lädt ggf. nach, falls nicht im Speicher. | key muss registriert sein. | SettingValue des Schlüssels wird zurückgegeben. | SettingsCoreError::SettingNotFound, SettingsCoreError::UnregisteredKey, SettingsCoreError::PersistenceError |
| set\_setting\_value | pub async fn set\_setting\_value(\&self, key: \&SettingKey, value: SettingValue) \-\> Result\<(), SettingsCoreError\> | Setzt den Wert einer Einstellung. Validiert und persistiert den Wert. Sendet ein Event. | key muss registriert sein. value muss valide sein gemäß Metadaten. | Wert ist intern gesetzt, persistiert via provider. SettingChangedEvent wird gesendet. last\_modified im Setting aktualisiert. | SettingsCoreError::SettingNotFound, SettingsCoreError::UnregisteredKey, SettingsCoreError::ValidationError, SettingsCoreError::PersistenceError |
| reset\_setting\_to\_default | pub async fn reset\_setting\_to\_default(\&self, key: \&SettingKey) \-\> Result\<(), SettingsCoreError\> | Setzt eine Einstellung auf ihren Standardwert (aus Metadaten) zurück. Persistiert und sendet Event. | key muss registriert sein. | Wert ist intern auf Default gesetzt, persistiert. SettingChangedEvent wird gesendet. last\_modified aktualisiert. | SettingsCoreError::SettingNotFound, SettingsCoreError::UnregisteredKey, SettingsCoreError::PersistenceError |
| get\_all\_settings\_with\_metadata | pub async fn get\_all\_settings\_with\_metadata(\&self) \-\> Result\<Vec\<Setting\>, SettingsCoreError\> | Gibt eine Liste aller aktuell verwalteten Einstellungen (inkl. ihrer Werte und Metadaten) zurück. | \- | Eine Vec\<Setting\> mit Klonen aller Einstellungen. | SettingsCoreError::PersistenceError (falls Nachladen nötig und fehlschlägt) |
| subscribe\_to\_changes | pub fn subscribe\_to\_changes(\&self) \-\> broadcast::Receiver\<SettingChangedEvent\> | Gibt einen Receiver für SettingChangedEvents zurück, um auf Einstellungsänderungen zu reagieren. | \- | Ein neuer broadcast::Receiver\<SettingChangedEvent\>. | \- |

### **4.1.4. Interne Events (SettingChangedEvent)**

Definiert in domain/src/settings\_core/mod.rs (siehe oben).

* **Zweck:** Entkoppelte Benachrichtigung anderer Domänenkomponenten über Einstellungsänderungen.  
* **Warum wertvoll:** Ermöglicht eine reaktive Architektur innerhalb der Domänenschicht. Module können auf Änderungen reagieren, ohne dass der SettingsCoreManager sie kennen muss. Dies reduziert die Kopplung und erhöht die Wartbarkeit und Erweiterbarkeit des Systems. Beispielsweise kann das Theming-Modul auf Änderungen der Akzentfarbe reagieren, ohne dass der SettingsCoreManager das Theming-Modul explizit aufrufen muss.  
* **Struktur SettingChangedEvent:**

| Feld | Typ | Beschreibung |
| :---- | :---- | :---- |
| key | SettingKey | Der Schlüssel der geänderten Einstellung. |
| new\_value | SettingValue | Der neue Wert der Einstellung. |
| old\_value | Option\<SettingValue\> | Der vorherige Wert der Einstellung (falls vorhanden oder nicht Standardwert). |

* **Typische Publisher:** SettingsCoreManager (nach erfolgreichem set\_setting\_value oder reset\_setting\_to\_default).  
* **Typische Subscriber (intern in Domänenschicht):** NotificationRulesEngine (um z.B. auf "Nicht stören"-Modus zu reagieren), ThemingEngine (um auf Theme- oder Akzentfarbänderungen zu reagieren), potenziell andere Domänenmodule, die einstellungsabhängige Logik haben.

### **4.1.5. Fehlerbehandlung (SettingsCoreError)**

Definiert in domain/src/settings\_core/error.rs unter Verwendung der thiserror-Crate, gemäß Richtlinie 4.3 der Gesamtspezifikation. Die Verwendung von thiserror für Bibliotheks-Code ist vorteilhaft, da sie spezifische, typisierte Fehler ermöglicht, die von Aufrufern explizit behandelt werden können, im Gegensatz zu generischen Fehlertypen wie anyhow::Error oder Box\<dyn std::error::Error\>.8 Die \#\[from\]-Annotation erleichtert die Konvertierung von Fehlern aus anderen Modulen (z.B. SettingsPersistenceError) in Varianten von SettingsCoreError.10

Rust

// domain/src/settings\_core/error.rs  
use thiserror::Error;  
use crate::settings\_core::types::SettingKey;  
use crate::settings\_persistence\_iface::SettingsPersistenceError;

\#  
pub enum SettingsCoreError {  
    \#  
    SettingNotFound { key: SettingKey },

    \#  
    SettingKeyAlreadyExists { key: SettingKey },

    \#\[error("Validation failed for setting '{key}': {message}")\]  
    ValidationError { key: SettingKey, message: String },

    \#\[error("Persistence operation failed for setting '{key\_str}': {source}")\]  
    PersistenceError {  
        key\_str: String, // String, da SettingKey nicht immer verfügbar oder relevant für globalen Fehler  
        \#\[source\]  
        source: SettingsPersistenceError,  
    },

    \#\[error("Attempted to operate on an unregistered setting key: '{key}'")\]  
    UnregisteredKey { key: SettingKey },

    \#\[error("An underlying I/O error occurred: {0}")\]  
    IoError(\#\[from\] std::io::Error), // Für den Fall, dass das Modul selbst I/O machen würde (selten)

    \#\[error("Event channel error while processing key '{key\_str}': {message}")\]  
    EventChannelError{ key\_str: String, message: String },  
}

// Konvertierung von SettingsPersistenceError zu SettingsCoreError  
// Dies ist nützlich, wenn ein Persistenzfehler auftritt, der nicht direkt einem Schlüssel zugeordnet ist.  
impl From\<SettingsPersistenceError\> for SettingsCoreError {  
    fn from(err: SettingsPersistenceError) \-\> Self {  
        SettingsCoreError::PersistenceError {  
            key\_str: err.get\_key().map\_or\_else(|| "global".to\_string(), |k| k.as\_str().to\_string()),  
            source: err,  
        }  
    }  
}

(Hinweis: SettingsPersistenceError müsste eine Methode get\_key() \-\> Option\<\&SettingKey\> haben, um dies sauber zu implementieren.)

* **Tabelle: SettingsCoreError Varianten**

| Variante | Beschreibung | Kontext/Ursache |
| :---- | :---- | :---- |
| SettingNotFound | Eine angeforderte Einstellung existiert nicht in der internen settings-Map. | get\_setting\_value, set\_setting\_value für einen Schlüssel, der zwar registriert, aber nicht geladen ist. |
| SettingKeyAlreadyExists | Versuch, Metadaten für einen bereits existierenden Schlüssel zu registrieren. | register\_setting\_metadata. |
| ValidationError | Ein neuer Wert für eine Einstellung entspricht nicht den Validierungsregeln. | set\_setting\_value, interne Validierung durch Setting::validate\_value. |
| PersistenceError | Fehler bei der Interaktion mit dem SettingsProvider. | Wrappt Fehler vom SettingsProvider (z.B. SettingsPersistenceError::StorageError). Verwendet \#\[source\]. |
| UnregisteredKey | Operation auf einem Schlüssel ohne registrierte Metadaten. | Wenn eine Operation Metadaten erfordert (z.B. set\_setting\_value), diese aber für den Schlüssel fehlen. |
| IoError | Generischer I/O-Fehler (eher selten direkt hier, mehr für SettingsProvider). | Beispiel für \#\[from\] std::io::Error. |
| EventChannelError | Fehler beim Senden eines SettingChangedEvent über den broadcast::Sender. | Wenn der broadcast::Sender::send() einen Fehler zurückgibt (z.B. keine aktiven Receiver und Puffer voll). |

### **4.1.6. Detaillierte Implementierungsschritte und Algorithmen**

1. **Initialisierung (SettingsCoreManager::new):**  
   * Speichere den übergebenen provider und die initial\_metadata (in RwLock\<HashMap\<...\>\>).  
   * Erstelle den broadcast::channel für SettingChangedEvent mit der spezifizierten Kapazität.  
   * Die settings-Map (RwLock\<HashMap\<SettingKey, Setting\>\>) bleibt initial leer. Einstellungen werden lazy oder durch load\_all\_settings geladen.  
2. **SettingsCoreManager::register\_setting\_metadata:**  
   * Erwirb Schreibsperre für registered\_metadata.  
   * Prüfe, ob key bereits existiert. Wenn ja, Err(SettingsCoreError::SettingKeyAlreadyExists).  
   * Füge (key, metadata) zu registered\_metadata hinzu. Ok(()).  
3. **SettingsCoreManager::load\_all\_settings:**  
   * Erwirb Lesesperre für registered\_metadata und Schreibsperre für settings.  
   * Iteriere über alle (key, metadata) in registered\_metadata.  
   * Für jeden key:  
     * Rufe self.provider.load\_setting(\&key).await auf.  
     * Bei Ok(Some(loaded\_value)):  
       * Validiere loaded\_value gegen metadata mittels Setting::validate\_value(\&loaded\_value, \&metadata). Bei Fehler: Err(SettingsCoreError::ValidationError).  
       * Erstelle ein Setting-Objekt: let setting \= Setting { id: uuid::Uuid::new\_v4(), key: key.clone(), current\_value: loaded\_value, metadata: metadata.clone(), last\_modified: Utc::now(), is\_dirty: false };  
       * Füge (key.clone(), setting) zur settings-Map hinzu.  
     * Bei Ok(None) (kein Wert persistiert):  
       * Verwende metadata.default\_value. Erstelle Setting-Objekt wie oben, aber mit metadata.default\_value.clone().  
       * Füge zur settings-Map hinzu.  
     * Bei Err(persistence\_error): Konvertiere zu SettingsCoreError::PersistenceError und gib Fehler zurück. Breche den Ladevorgang ab.  
   * Ok(()) bei Erfolg.  
4. **SettingsCoreManager::get\_setting\_value:**  
   * Erwirb Lesesperre für registered\_metadata. Prüfe, ob key registriert ist. Wenn nein, Err(SettingsCoreError::UnregisteredKey).  
   * Erwirb Lesesperre für settings.  
   * Wenn key in settings vorhanden ist, gib settings.get(key).unwrap().value().clone() zurück.  
   * Wenn key nicht in settings vorhanden (nicht geladen):  
     * Gib Lesesperre für settings frei.  
     * Rufe self.provider.load\_setting(key).await auf.  
     * Erwirb Schreibsperre für settings.  
     * Bei Ok(Some(loaded\_value)):  
       * Hole metadata aus registered\_metadata.  
       * Validiere loaded\_value. Bei Fehler: Err(SettingsCoreError::ValidationError).  
       * Erstelle Setting-Objekt, füge zu settings hinzu. Gib loaded\_value.clone() zurück.  
     * Bei Ok(None):  
       * Hole metadata aus registered\_metadata.  
       * Erstelle Setting-Objekt mit metadata.default\_value. Füge zu settings hinzu. Gib metadata.default\_value.clone() zurück.  
     * Bei Err(persistence\_error): Err(SettingsCoreError::from(persistence\_error)).  
   * Stelle sicher, dass Sperren korrekt freigegeben werden, besonders bei frühen Returns.  
5. **SettingsCoreManager::set\_setting\_value:**  
   * Erwirb Lesesperre für registered\_metadata. Hole metadata für key. Wenn nicht gefunden: Err(SettingsCoreError::UnregisteredKey).  
   * Validiere value gegen metadata mittels Setting::validate\_value(\&value, \&retrieved\_metadata). Bei Fehler: Err(SettingsCoreError::ValidationError).  
   * Erwirb Schreibsperre für settings.  
   * Hole das (mutable) Setting-Objekt für key. Wenn nicht gefunden (sollte nach get\_setting\_value-Logik oder load\_all\_settings existieren, aber zur Sicherheit prüfen oder entry() API verwenden): Err(SettingsCoreError::SettingNotFound).  
   * Speichere old\_value \= current\_setting.value().clone().  
   * Rufe current\_setting.set\_value(value.clone(), Utc::now()) auf (dies validiert intern nicht erneut, da bereits geschehen).  
   * Setze current\_setting.is\_dirty \= true.  
   * Rufe self.provider.save\_setting(key, \&value).await auf.  
     * Bei Err(persistence\_error):  
       * Setze current\_setting.set\_value(old\_value, Utc::now()) (Rollback der In-Memory-Änderung).  
       * Setze current\_setting.is\_dirty \= false.  
       * Err(SettingsCoreError::from(persistence\_error)).  
   * Setze current\_setting.is\_dirty \= false.  
   * Erstelle SettingChangedEvent { key: key.clone(), new\_value: value, old\_value: Some(old\_value) }.  
   * Sende das Event via self.event\_sender.send(). Bei Fehler (z.B. wenn keine Subscriber da sind und der Kanal voll ist, was bei broadcast selten zu einem harten Fehler führt, aber Err zurückgeben kann): Err(SettingsCoreError::EventChannelError).  
   * Ok(()).  
6. **Validierungslogik (Setting::validate\_value):**  
   * Prüfe Typkompatibilität von value mit metadata.value\_type\_hint (z.B. SettingValue::Integer mit "Integer").  
   * Wenn metadata.possible\_values Some(list) ist, prüfe, ob value in list enthalten ist.  
   * Wenn metadata.validation\_regex Some(regex\_str) ist und value ein SettingValue::String(s) ist, kompiliere Regex und prüfe s dagegen.  
   * Prüfe metadata.min\_value / metadata.max\_value für numerische Typen (Integer, Float).  
   * Bei Verletzung: Err(SettingsCoreError::ValidationError) mit passender Nachricht.

### **4.1.7. Überlegungen zur Nebenläufigkeit und Zustandssynchronisierung**

* Die internen Zustände settings und registered\_metadata werden mit tokio::sync::RwLock geschützt. Dies erlaubt parallele Lesezugriffe, während Schreibzugriffe exklusiv sind, was für typische Einstellungs-Workloads (viele Lesezugriffe, wenige Schreibzugriffe) performant ist.  
* Der SettingsProvider wird als Arc\<dyn SettingsProvider \+ Send \+ Sync\> gehalten. Send und Sync sind notwendig, da die async-Methoden des SettingsCoreManager potenziell auf verschiedenen Threads durch den Tokio-Executor ausgeführt werden können und der Provider über Thread-Grenzen hinweg sicher geteilt werden muss.5  
* Der broadcast::Sender für SettingChangedEvent ist Thread-sicher und für die Verwendung in asynchronen Kontexten konzipiert.6

## **4.2. Entwicklungsmodul: Persistenzabstraktion und Schema für Einstellungen (domain::settings\_persistence\_iface)**

Dieses Modul definiert die Schnittstelle, über die der SettingsCoreManager Einstellungen lädt und speichert, ohne die konkrete Implementierung der Persistenz zu kennen.

### **4.2.1. Detaillierte Verantwortlichkeiten und Ziele**

* **Verantwortlichkeiten:**  
  * Definition eines abstrakten Traits (SettingsProvider), der die Operationen zum Laden und Speichern von Einstellungen vorschreibt.  
  * Definition der Fehlertypen (SettingsPersistenceError), die bei Persistenzoperationen auftreten können.  
* **Ziele:**  
  * Vollständige Entkopplung der Domänenlogik (domain::settings\_core) von spezifischen Speichertechnologien (z.B. GSettings, Konfigurationsdateien im TOML/JSON-Format, Datenbank).  
  * Ermöglichung der Testbarkeit des SettingsCoreManager durch Mocking des SettingsProvider.  
  * Flexibilität bei der Auswahl oder dem Wechsel der Speichertechnologie, ohne dass Änderungen an der Domänenschicht erforderlich sind.

Die Verwendung eines Trait-Objekts (Arc\<dyn SettingsProvider \+ Send \+ Sync\>) ist hier entscheidend. Die Send \+ Sync-Bounds sind unerlässlich, da der Provider in async-Funktionen verwendet wird, die von einem Multi-Threaded-Executor wie Tokio ausgeführt werden können. Ohne diese Bounds könnte der Compiler die Thread-Sicherheit nicht garantieren.5

### **4.2.2. Trait-Definitionen (SettingsProvider)**

Definiert in domain/src/settings\_persistence\_iface/mod.rs. Die Verwendung von async\_trait ist notwendig, um async fn in Traits zu deklarieren, solange dies nicht nativ in stabilem Rust unterstützt wird.

Rust

// domain/src/settings\_persistence\_iface/mod.rs  
use async\_trait::async\_trait;  
use crate::settings\_core::types::{SettingKey, SettingValue};  
use crate::settings\_persistence\_iface::error::SettingsPersistenceError; // Eigener Fehlertyp

\#\[async\_trait\]  
pub trait SettingsProvider {  
    async fn load\_setting(\&self, key: \&SettingKey) \-\> Result\<Option\<SettingValue\>, SettingsPersistenceError\>;  
    async fn save\_setting(\&self, key: \&SettingKey, value: \&SettingValue) \-\> Result\<(), SettingsPersistenceError\>;  
    async fn load\_all\_settings(\&self) \-\> Result\<Vec\<(SettingKey, SettingValue)\>, SettingsPersistenceError\>;  
    async fn delete\_setting(\&self, key: \&SettingKey) \-\> Result\<(), SettingsPersistenceError\>;  
    async fn setting\_exists(\&self, key: \&SettingKey) \-\> Result\<bool, SettingsPersistenceError\>;  
}

* **Tabelle: Methoden des SettingsProvider Traits**

| Methode | Signatur | Kurzbeschreibung |
| :---- | :---- | :---- |
| load\_setting | async fn load\_setting(\&self, key: \&SettingKey) \-\> Result\<Option\<SettingValue\>, SettingsPersistenceError\> | Lädt den Wert für einen Schlüssel. Ok(None) wenn nicht vorhanden. |
| save\_setting | async fn save\_setting(\&self, key: \&SettingKey, value: \&SettingValue) \-\> Result\<(), SettingsPersistenceError\> | Speichert einen Wert für einen Schlüssel. Überschreibt, falls existent. |
| load\_all\_settings | async fn load\_all\_settings(\&self) \-\> Result\<Vec\<(SettingKey, SettingValue)\>, SettingsPersistenceError\> | Lädt alle Einstellungen, die dieser Provider verwaltet (z.B. unter einem Schema). |
| delete\_setting | async fn delete\_setting(\&self, key: \&SettingKey) \-\> Result\<(), SettingsPersistenceError\> | Löscht eine Einstellung aus dem persistenten Speicher. |
| setting\_exists | async fn setting\_exists(\&self, key: \&SettingKey) \-\> Result\<bool, SettingsPersistenceError\> | Prüft, ob eine Einstellung im persistenten Speicher existiert. |

### **4.2.3. Datenstrukturen für die Persistenzschnittstelle**

Die primären Datenstrukturen, die über diese Schnittstelle ausgetauscht werden, sind SettingKey und SettingValue aus dem Modul domain::settings\_core::types. Es wird implizit erwartet, dass Implementierungen des SettingsProvider-Traits mit serialisierbaren Formen von SettingValue arbeiten können. Daher müssen SettingValue und die darin enthaltenen Typen serde::Serialize und serde::Deserialize implementieren. Die konkrete Serialisierungslogik (z.B. zu JSON, GVariant für GSettings, etc.) ist Aufgabe der jeweiligen Provider-Implementierung in der Systemschicht, nicht der Domänenschicht.

### **4.2.4. Fehlerbehandlung (SettingsPersistenceError)**

Definiert in domain/src/settings\_persistence\_iface/error.rs unter Verwendung von thiserror. Diese Fehler sind spezifisch für Persistenzoperationen und werden vom SettingsCoreManager in SettingsCoreError::PersistenceError gewrappt.

Rust

// domain/src/settings\_persistence\_iface/error.rs  
use thiserror::Error;  
use crate::settings\_core::types::SettingKey;

\#  
pub enum SettingsPersistenceError {  
    \#  
    BackendUnavailable { message: String },

    \#\[error("Failed to access storage for key '{key}': {message}")\]  
    StorageAccessError { key: SettingKey, message: String },

    \#\[error("Failed to serialize setting '{key}': {message}")\]  
    SerializationError { key: SettingKey, message: String },

    \#\[error("Failed to deserialize setting '{key}': {message}")\]  
    DeserializationError { key: SettingKey, message: String },

    \#  
    SettingNotFoundInStorage { key: SettingKey }, // Eindeutiger als der allgemeine SettingNotFound

    \#\[error("An I/O error occurred while accessing storage for key '{key\_opt:?}': {source}")\]  
    IoError {  
        key\_opt: Option\<SettingKey\>,  
        \#\[source\]  
        source: std::io::Error,  
    },

    \#\[error("An unknown persistence error occurred for key '{key\_opt:?}': {message}")\]  
    UnknownError { key\_opt: Option\<SettingKey\>, message: String },  
}

impl SettingsPersistenceError {  
    /// Hilfsmethode, um den Schlüssel aus dem Fehler zu extrahieren, falls vorhanden.  
    pub fn get\_key(\&self) \-\> Option\<\&SettingKey\> {  
        match self {  
            SettingsPersistenceError::StorageAccessError { key,.. } \=\> Some(key),  
            SettingsPersistenceError::SerializationError { key,.. } \=\> Some(key),  
            SettingsPersistenceError::DeserializationError { key,.. } \=\> Some(key),  
            SettingsPersistenceError::SettingNotFoundInStorage { key,.. } \=\> Some(key),  
            SettingsPersistenceError::IoError { key\_opt,.. } \=\> key\_opt.as\_ref(),  
            SettingsPersistenceError::UnknownError { key\_opt,.. } \=\> key\_opt.as\_ref(),  
            \_ \=\> None,  
        }  
    }  
}

* **Tabelle: SettingsPersistenceError Varianten**

| Variante | Beschreibung |
| :---- | :---- |
| BackendUnavailable | Das Speichersystem (z.B. D-Bus Dienst, Datenbankverbindung) ist nicht erreichbar. |
| StorageAccessError | Allgemeiner Fehler beim Zugriff auf den Speicher für einen bestimmten Schlüssel. |
| SerializationError | Fehler beim Serialisieren eines SettingValue für die Speicherung. |
| DeserializationError | Fehler beim Deserialisieren eines Wertes aus dem Speicher in ein SettingValue. |
| SettingNotFoundInStorage | Spezifischer Fehler, wenn ein Schlüssel im Persistenzlayer nicht existiert. |
| IoError | Wrappt std::io::Error für dateibasierte Provider. Enthält optional den Schlüssel. |
| UnknownError | Ein anderer, nicht spezifisch klassifizierter Fehler. Enthält optional den Schlüssel. |

### **4.2.5. Detaillierte Implementierungsschritte für die Interaktion mit der Schnittstelle**

Die konkreten Implementierungen des SettingsProvider-Traits (z.B. GSettingsProvider, FileConfigProvider) befinden sich typischerweise in der Systemschicht oder einer dedizierten Infrastrukturschicht, da sie systemspezifische Details oder externe Bibliotheken involvieren.  
Der SettingsCoreManager interagiert wie folgt mit dem Provider:

1. Der SettingsCoreManager hält eine Instanz von Arc\<dyn SettingsProvider \+ Send \+ Sync\>.  
2. Bei Operationen wie set\_setting\_value ruft der SettingsCoreManager die entsprechende Methode des Providers auf, z.B. provider.save\_setting(\&key, \&value).await.  
3. Gibt die Provider-Methode Ok(...) zurück, fährt der SettingsCoreManager mit seiner Logik fort (internen Zustand aktualisieren, Event senden).  
4. Gibt die Provider-Methode Err(SettingsPersistenceError) zurück, konvertiert der SettingsCoreManager diesen Fehler in eine SettingsCoreError::PersistenceError-Variante (unter Beibehaltung des ursprünglichen Fehlers als source mittels \#\[from\] oder manueller Implementierung) und gibt diesen an seinen Aufrufer weiter. Der interne Zustand des SettingsCoreManager wird gegebenenfalls auf den Stand vor dem fehlgeschlagenen Persistenzversuch zurückgesetzt (Rollback).

Diese klare Trennung stellt sicher, dass die Domänenlogik agnostisch gegenüber der Persistenztechnologie bleibt und erleichtert das Testen erheblich, da der Provider durch einen Mock ersetzt werden kann.

## **4.3. Entwicklungsmodul: Kernlogik der Benachrichtigungsverwaltung (domain::notifications\_core)**

Dieses Modul ist für die zentrale Logik der Verwaltung von Desktop-Benachrichtigungen zuständig. Es definiert, was eine Benachrichtigung ist, wie sie verarbeitet, gespeichert und ihr Lebenszyklus verwaltet wird.

### **4.3.1. Detaillierte Verantwortlichkeiten und Ziele**

* **Verantwortlichkeiten:**  
  * Definition der Datenstruktur einer Benachrichtigung (Notification) und zugehöriger Typen (NotificationId, NotificationAction, NotificationUrgency).  
  * Verwaltung des Lebenszyklus von Benachrichtigungen: Erstellung, Anzeige (konzeptionell, die Darstellung erfolgt in der UI-Schicht), Aktualisierung, Schließen.  
  * Bereitstellung einer API (NotificationCoreManager) zum programmatischen Hinzufügen und Verwalten von Benachrichtigungen.  
  * Führung einer Liste aktiver Benachrichtigungen.  
  * Verwaltung einer Benachrichtigungshistorie mit konfigurierbarer Größe und Persistenzlogik (FIFO).  
  * Unterstützung für interaktive Benachrichtigungen durch NotificationAction.  
  * Implementierung von Logik zur Deduplizierung oder zum Ersetzen von Benachrichtigungen (z.B. basierend auf replaces\_id).  
  * Interaktion mit der NotificationRulesEngine (domain::notifications\_rules) zur Anwendung von Filter-, Priorisierungs- und Modifikationsregeln.  
  * Versenden interner Events (NotificationEvent) über Zustandsänderungen von Benachrichtigungen.  
* **Ziele:**  
  * Schaffung einer zentralen, konsistenten und robusten Logik für das gesamte Benachrichtigungssystem.  
  * Strikte Trennung der Benachrichtigungslogik von der UI-Darstellung und den Transportmechanismen (wie D-Bus). Die Domänenschicht definiert *was* eine Benachrichtigung ist und *wie* sie verwaltet wird, nicht wie sie konkret aussieht oder über welche Kanäle sie empfangen/gesendet wird.  
  * Ermöglichung eines flexiblen und durch Regeln steuerbaren Benachrichtigungsflusses.

### **4.3.2. Entitäten und Wertobjekte**

Alle Typen sind in domain/src/notifications\_core/types.rs zu definieren. Sie benötigen standardmäßig Debug, Clone, PartialEq. Für die Persistenz der Historie und die Verwendung in Events ist auch serde::Serialize und serde::Deserialize für die Hauptstrukturen (Notification, NotificationAction etc.) erforderlich. uuid::Uuid (mit Features v4, serde) 1 und chrono::DateTime\<Utc\> (mit Feature serde) 3 werden für IDs bzw. Zeitstempel verwendet.

* **NotificationId (Newtype für uuid::Uuid)**  
  * **Zweck:** Eine typsichere ID für Benachrichtigungen.  
  * **Warum wertvoll:** Verhindert Verwechslungen mit anderen Uuid-basierten IDs im System und macht die API expliziter.  
  * **Implementierungsdetails:**  
    * Interner Typ: uuid::Uuid.  
    * Sollte Display, Hash, Eq, PartialEq, Ord, PartialOrd, serde::Serialize, serde::Deserialize, Copy (da Uuid Copy ist) implementieren.  
    * Methoden: pub fn new() \-\> Self { Self(uuid::Uuid::new\_v4()) }, pub fn as\_uuid(\&self) \-\> \&uuid::Uuid { \&self.0 }, From\<uuid::Uuid\>, Into\<uuid\_Uuid\>.  
* **NotificationUrgency (Enum)**  
  * **Zweck:** Definiert die Dringlichkeitsstufe einer Benachrichtigung.  
  * **Warum wertvoll:** Standardisiert die Dringlichkeit und ermöglicht darauf basierende Logik in Regeln und UI (z.B. Sortierung, Hervorhebung, unterschiedliche Töne).

| Variante | Wert (intern, z.B. u8) | Beschreibung |
| :---- | :---- | :---- |
| Low | 0 | Niedrige Dringlichkeit (z.B. informative Updates). |
| Normal | 1 | Normale Dringlichkeit (Standard). |
| Critical | 2 | Hohe Dringlichkeit (z.B. Fehler, wichtige Alarme). |

\*   Sollte \`serde::Serialize\`, \`serde::Deserialize\`, \`Copy\` implementieren.

* **NotificationAction (Struktur, Wertobjekt)**  
  * **Zweck:** Repräsentiert eine Aktion, die der Benutzer im Kontext einer Benachrichtigung ausführen kann.  
  * **Warum wertvoll:** Ermöglicht interaktive Benachrichtigungen, die über reine Informationsanzeige hinausgehen.

| Attribut | Typ | Sichtbarkeit | Beschreibung |
| :---- | :---- | :---- | :---- |
| key | String | pub | Eindeutiger Schlüssel der Aktion innerhalb der Benachrichtigung (z.B. "reply", "archive"). |
| label | String | pub | Menschenlesbare Beschriftung für den Button/Menüeintrag (z.B. "Antworten"). |
| icon\_name | Option\<String\> | pub | Optionaler Name eines Icons für die Aktion (gemäß Freedesktop Icon Naming Spec). |

\*   Sollte \`serde::Serialize\`, \`serde::Deserialize\` implementieren.

* **Notification (Struktur, Entität)**  
  * **Zweck:** Das zentrale Objekt, das eine einzelne Benachrichtigung mit all ihren Attributen darstellt.  
  * **Warum wertvoll:** Kapselt alle Informationen einer Benachrichtigung und dient als Hauptdatentyp für die Benachrichtigungslogik.

| Attribut | Typ | Sichtbarkeit | Beschreibung | Invarianten |
| :---- | :---- | :---- | :---- | :---- |
| id | NotificationId | pub | Eindeutige ID der Benachrichtigung. | Muss eindeutig sein. Wird bei Erstellung generiert. |
| app\_name | String | pub | Name der Anwendung, die die Benachrichtigung gesendet hat (z.B. "Thunderbird", "System Update"). | Nicht leer. |
| app\_icon | Option\<String\> | pub | Pfad oder Name des Icons der Anwendung (gemäß Freedesktop Icon Naming Spec). |  |
| summary | String | pub | Kurze Zusammenfassung/Titel der Benachrichtigung. | Nicht leer. |
| body | Option\<String\> | pub | Ausführlicherer Text der Benachrichtigung. Kann Markup enthalten (abhängig von UI-Interpretation). |  |
| actions | Vec\<NotificationAction\> | pub | Liste von Aktionen, die mit der Benachrichtigung verbunden sind. | Schlüssel (key) jeder Aktion müssen innerhalb dieser Liste eindeutig sein. |
| hints | HashMap\<String, SettingValue\> | pub | Zusätzliche, anwendungsspezifische Daten oder UI-Hinweise (z.B. "image-path", "progress", "resident"). |  |
| urgency | NotificationUrgency | pub | Dringlichkeitsstufe. Default: Normal. |  |
| timestamp\_created | chrono::DateTime\<Utc\> | pub | Zeitstempel der Erstellung der Benachrichtigung *in der Domänenschicht*. | Wird bei Instanziierung gesetzt. |
| timestamp\_displayed | Option\<chrono::DateTime\<Utc\>\> | pub(crate) | Zeitstempel, wann die Benachrichtigung (potenziell) dem Benutzer angezeigt wurde (von NotificationCoreManager gesetzt). |  |
| expires\_at | Option\<chrono::DateTime\<Utc\>\> | pub | Zeitstempel, wann die Benachrichtigung automatisch geschlossen werden soll (None \= kein Timeout). |  |
| is\_persistent | bool | pub | true, wenn die Benachrichtigung nach dem Schließen in der Historie verbleiben soll. Default: false. |  |
| replaces\_id | Option\<NotificationId\> | pub | ID der Benachrichtigung, die durch diese ersetzt werden soll. |  |
| category | Option\<String\> | pub | Kategorie der Benachrichtigung (z.B. "email.new", "download.complete", "chat.incoming\_message"). Standardisierte Kategorien können für Regeln nützlich sein. |  |

\*   Sollte \`serde::Serialize\`, \`serde::Deserialize\` implementieren.

* **NotificationHistory (Struktur, Aggregatwurzel)**  
  * **Zweck:** Verwaltet die Sammlung der vergangenen (geschlossenen, persistenten) Benachrichtigungen.  
  * **Warum wertvoll:** Stellt die Logik für die Historie bereit, insbesondere die Begrenzung der Größe und den Zugriff.  
  * **Implementierungsdetails:**  
    * notifications: VecDeque\<Notification\>: Eine VecDeque ist geeignet, da sie effizientes Hinzufügen am einen Ende und Entfernen am anderen Ende (für die Größenbeschränkung) ermöglicht.  
    * max\_size: usize: Maximale Anzahl an Benachrichtigungen in der Historie.  
    * Methoden:  
      * pub fn new(max\_size: usize) \-\> Self  
      * pub fn add(\&mut self, notification: Notification): Fügt eine Benachrichtigung hinzu. Wenn max\_size überschritten wird, wird die älteste entfernt (pop\_front).  
      * pub fn get\_all(\&self) \-\> Vec\<Notification\>: Gibt eine Kopie aller historischen Benachrichtigungen zurück (neueste zuerst oder älteste zuerst, je nach Anforderung).  
      * pub fn get\_paged(\&self, limit: usize, offset: usize) \-\> Vec\<Notification\>: Gibt eine Seite der Historie zurück.  
      * pub fn clear(\&mut self): Leert die Historie.  
      * pub fn current\_size(\&self) \-\> usize.  
  * Sollte serde::Serialize, serde::Deserialize implementieren, um die gesamte Historie persistieren zu können (optional, aber nützlich).

### **4.3.3. Öffentliche API des Moduls (NotificationCoreManager)**

Definiert in domain/src/notifications\_core/mod.rs. Der NotificationCoreManager ist die Fassade für die Benachrichtigungslogik. Er verwaltet intern Listen für aktive Benachrichtigungen und eine Instanz von NotificationHistory. Er interagiert eng mit der NotificationRulesEngine.

Rust

// domain/src/notifications\_core/mod.rs  
use crate::notifications\_core::types::{Notification, NotificationId, NotificationAction, NotificationHistory, NotificationUrgency}; // NotificationUrgency für Defaults  
use crate::notifications\_core::error::NotificationCoreError;  
use crate::notifications\_core::events::{NotificationEvent, CloseReason};  
use crate::notifications\_rules::{NotificationRulesEngine, RuleProcessingResult}; // Abhängigkeit  
use std::collections::{HashMap, VecDeque};  
use std::sync::Arc;  
use tokio::sync::{RwLock, broadcast};  
use chrono::Utc;

pub struct NotificationCoreManager {  
    active\_notifications: RwLock\<HashMap\<NotificationId, Notification\>\>,  
    history: RwLock\<NotificationHistory\>,  
    rules\_engine: Arc\<NotificationRulesEngine\>,  
    event\_sender: broadcast::Sender\<NotificationEvent\>,  
    // next\_internal\_id: RwLock\<u32\>, // Für Freedesktop Notification Spec Server ID, falls benötigt  
}

impl NotificationCoreManager {  
    pub fn new(  
        rules\_engine: Arc\<NotificationRulesEngine\>,  
        history\_max\_size: usize,  
        event\_channel\_capacity: usize  
    ) \-\> Self {  
        let (event\_sender, \_) \= broadcast::channel(event\_channel\_capacity);  
        NotificationCoreManager {  
            active\_notifications: RwLock::new(HashMap::new()),  
            history: RwLock::new(NotificationHistory::new(history\_max\_size)),  
            rules\_engine,  
            event\_sender,  
        }  
    }

    // Weitere Methoden folgen  
}

* **Tabelle: Methoden des NotificationCoreManager**

| Methode | Signatur | Kurzbeschreibung |
| :---- | :---- | :---- |
| new | pub fn new(rules\_engine: Arc\<NotificationRulesEngine\>, history\_max\_size: usize, event\_channel\_capacity: usize) \-\> Self | Konstruktor. Initialisiert den Manager mit der Regel-Engine, maximaler Historiengröße und Event-Kanal-Kapazität. |
| add\_notification | pub async fn add\_notification(\&self, mut new\_notification: Notification) \-\> Result\<NotificationId, NotificationCoreError\> | Fügt eine neue Benachrichtigung hinzu. Wendet Regeln an, prüft auf Ersetzung. Sendet NotificationAdded oder NotificationSuppressedByRule Event. Gibt die ID der (ggf. modifizierten) Benachrichtigung zurück. |
| get\_active\_notification | pub async fn get\_active\_notification(\&self, id: \&NotificationId) \-\> Result\<Option\<Notification\>, NotificationCoreError\> | Ruft eine aktive Benachrichtigung anhand ihrer ID ab (als Klon). |
| get\_all\_active\_notifications | pub async fn get\_all\_active\_notifications(\&self) \-\> Result\<Vec\<Notification\>, NotificationCoreError\> | Ruft eine Liste aller derzeit aktiven Benachrichtigungen ab (als Klone). |
| close\_notification | pub async fn close\_notification(\&self, id: \&NotificationId, reason: CloseReason) \-\> Result\<(), NotificationCoreError\> | Schließt eine aktive Benachrichtigung. Verschiebt sie ggf. in die Historie (basierend auf is\_persistent und reason). Sendet NotificationClosed Event. |
| invoke\_action | pub async fn invoke\_action(\&self, notification\_id: \&NotificationId, action\_key: \&str) \-\> Result\<(), NotificationCoreError\> | Löst eine Aktion für eine Benachrichtigung aus. Sendet NotificationActionInvoked Event. Die eigentliche Ausführung der Aktion ist nicht Teil dieser Domänenlogik. |
| get\_history | pub async fn get\_history(\&self, limit: Option\<usize\>, offset: Option\<usize\>) \-\> Result\<Vec\<Notification\>, NotificationCoreError\> | Ruft Benachrichtigungen aus der Historie ab (paginiert). |
| clear\_history | pub async fn clear\_history(\&self) \-\> Result\<(), NotificationCoreError\> | Leert die Benachrichtigungshistorie. Sendet NotificationHistoryCleared Event. |
| clear\_app\_notifications | pub async fn clear\_app\_notifications(\&self, app\_name: \&str, reason: CloseReason) \-\> Result\<usize, NotificationCoreError\> | Schließt alle aktiven Benachrichtigungen einer bestimmten App. Gibt Anzahl geschlossener Benachrichtigungen zurück. |
| subscribe\_to\_events | pub fn subscribe\_to\_events(\&self) \-\> broadcast::Receiver\<NotificationEvent\> | Gibt einen Receiver für NotificationEvents zurück, um auf Benachrichtigungs-Events zu reagieren. |

### **4.3.4. Interne Events (NotificationEvent)**

Definiert in domain/src/notifications\_core/events.rs. Diese Events werden über tokio::sync::broadcast 6 verteilt, was eine entkoppelte Kommunikation innerhalb des Systems ermöglicht.

* **Zweck:** Andere Teile des Systems (primär die UI-Schicht über Adaptoren in der Systemschicht, aber auch andere Domänenmodule oder Logging-Dienste) über signifikante Änderungen im Benachrichtigungssystem zu informieren.  
* **Warum wertvoll:** Entkoppelte Kommunikation ist ein Schlüsselprinzip für modulare und wartbare Systeme. Die UI muss nicht direkt vom NotificationCoreManager aufgerufen werden; sie reagiert stattdessen auf Events.

Rust

// domain/src/notifications\_core/events.rs  
use crate::notifications\_core::types::{Notification, NotificationId};  
use chrono::{DateTime, Utc}; // Für Zeitstempel in Events

\# // Clone für Sender, PartialEq für Tests, Serde für ggf. externe Weiterleitung  
pub enum CloseReason {  
    DismissedByUser,  
    Expired,  
    Replaced,  
    AppClosed,      // App hat explizit CloseNotification gerufen  
    SystemShutdown,  
    AppScopeClear,  // Durch clear\_app\_notifications  
    Other(String),  
}

\# // Clone für Sender, Serde für ggf. externe Weiterleitung  
pub enum NotificationEvent {  
    NotificationAdded {  
        notification: Notification, // Die tatsächlich hinzugefügte (ggf. modifizierte) Notification  
        timestamp: DateTime\<Utc\>,  
    },  
    NotificationUpdated { // Falls Benachrichtigungen aktualisiert werden können (z.B. Fortschritt)  
        notification: Notification, // Die aktualisierte Notification  
        timestamp: DateTime\<Utc\>,  
    },  
    NotificationClosed {  
        notification\_id: NotificationId,  
        app\_name: String, // Nützlich für UI, um schnell zuordnen zu können  
        summary: String,  // Nützlich für UI  
        reason: CloseReason,  
        timestamp: DateTime\<Utc\>,  
    },  
    NotificationActionInvoked {  
        notification\_id: NotificationId,  
        action\_key: String,  
        timestamp: DateTime\<Utc\>,  
    },  
    NotificationHistoryCleared {  
        timestamp: DateTime\<Utc\>,  
    },  
    NotificationSuppressedByRule {  
        original\_summary: String, // Nur einige Infos, nicht die ganze Notification  
        app\_name: String,  
        rule\_id: String, // ID der verantwortlichen Regel  
        timestamp: DateTime\<Utc\>,  
    }  
}

* **Tabelle: NotificationEvent Varianten**

| Variante | Payload-Felder | Beschreibung |
| :---- | :---- | :---- |
| NotificationAdded | notification: Notification, timestamp | Eine neue Benachrichtigung wurde dem System hinzugefügt und ist (nach Regelprüfung) aktiv. |
| NotificationUpdated | notification: Notification, timestamp | Eine bestehende aktive Benachrichtigung wurde aktualisiert (z.B. Fortschrittsbalken). |
| NotificationClosed | notification\_id: NotificationId, app\_name, summary, reason: CloseReason, timestamp | Eine aktive Benachrichtigung wurde geschlossen. app\_name und summary für leichtere UI-Verarbeitung. |
| NotificationActionInvoked | notification\_id: NotificationId, action\_key: String, timestamp | Eine Aktion einer Benachrichtigung wurde ausgelöst. |
| NotificationHistoryCleared | timestamp | Die Benachrichtigungshistorie wurde geleert. |
| NotificationSuppressedByRule | original\_summary: String, app\_name: String, rule\_id: String, timestamp | Eine eingehende Benachrichtigung wurde aufgrund einer Regel unterdrückt und nicht aktiv angezeigt. |

* **Typische Publisher:** NotificationCoreManager.  
* **Typische Subscriber:** Die UI-Schicht (über einen Adapter in der Systemschicht, der D-Bus-Signale oder Wayland-Events generiert), Logging-Dienste, potenziell andere Domänenmodule, die auf Benachrichtigungsstatus reagieren müssen.

### **4.3.5. Fehlerbehandlung (NotificationCoreError)**

Definiert in domain/src/notifications\_core/error.rs mit thiserror.9

Rust

// domain/src/notifications\_core/error.rs  
use thiserror::Error;  
use crate::notifications\_core::types::NotificationId;  
use crate::notifications\_rules::error::NotificationRulesError;

\#  
pub enum NotificationCoreError {  
    \#  
    NotificationNotFound(NotificationId),

    \#\[error("Action '{action\_key}' not found for notification '{notification\_id}'.")\]  
    ActionNotFound {  
        notification\_id: NotificationId,  
        action\_key: String,  
    },

    \#\[error("Failed to apply notification rules: {source}")\]  
    RuleApplicationError {  
        \#\[from\] // Direkte Konvertierung von NotificationRulesError  
        source: NotificationRulesError  
    },

    \#\[error("Notification history is full (max size: {max\_size}). Cannot add notification '{summary}'.")\]  
    HistoryFull { max\_size: usize, summary: String },

    \#\[error("Invalid notification data: {message}")\]  
    InvalidNotificationData { message: String },

    \#\[error("Event channel error: {message}")\]  
    EventChannelError { message: String },

    \#  
    DuplicateNotificationId(NotificationId),

    \#  
    ReplacedNotificationNotFound(NotificationId),  
}

* **Tabelle: NotificationCoreError Varianten**

| Variante | Beschreibung |
| :---- | :---- |
| NotificationNotFound | Eine angeforderte Benachrichtigung (aktiv) wurde nicht gefunden. |
| ActionNotFound | Eine angeforderte Aktion für eine Benachrichtigung existiert nicht. |
| RuleApplicationError | Fehler bei der Anwendung von Regeln aus NotificationRulesEngine. Nutzt \#\[from\] für direkte Konvertierung. |
| HistoryFull | Die Benachrichtigungshistorie hat ihre maximale Kapazität erreicht und eine weitere kann nicht hinzugefügt werden. |
| InvalidNotificationData | Die Daten der hinzuzufügenden Benachrichtigung sind ungültig (z.B. fehlender summary). |
| EventChannelError | Fehler beim Senden eines NotificationEvent über den broadcast::Sender. |
| DuplicateNotificationId | Versuch, eine Benachrichtigung mit einer bereits existierenden ID zu den aktiven Benachrichtigungen hinzuzufügen. |
| ReplacedNotificationNotFound | Die in replaces\_id angegebene Benachrichtigung wurde nicht gefunden. |

### **4.3.6. Detaillierte Implementierungsschritte und Algorithmen**

1. **NotificationCoreManager::add\_notification:**  
   * Validiere new\_notification (z.B. app\_name, summary nicht leer, id muss gesetzt sein). Bei Fehler: Err(NotificationCoreError::InvalidNotificationData).  
   * Erwirb Schreibsperre für active\_notifications.  
   * Wenn new\_notification.id bereits in active\_notifications existiert: Err(NotificationCoreError::DuplicateNotificationId).  
   * **Regelanwendung:** Rufe self.rules\_engine.process\_notification(\&new\_notification).await auf.  
     * Bei Err(rules\_error): Err(NotificationCoreError::from(rules\_error)).  
     * Bei Ok(RuleProcessingResult::Suppress(rule\_id)):  
       * Sende NotificationSuppressedByRule Event.  
       * Die Benachrichtigung wird nicht aktiv. Ggf. zur Historie hinzufügen, falls die Regel dies impliziert oder new\_notification.is\_persistent ist (abhängig von Designentscheidung).  
       * Ok(new\_notification.id) zurückgeben (die ID der ursprünglichen, nun unterdrückten Benachrichtigung).  
     * Bei Ok(RuleProcessingResult::Allow(mut processed\_notification)):  
       * processed\_notification.timestamp\_displayed \= Some(Utc::now()).  
       * **Ersetzungslogik:** Wenn processed\_notification.replaces\_id ein Some(id\_to\_replace) ist:  
         * Versuche, die Benachrichtigung mit id\_to\_replace aus active\_notifications zu entfernen.  
         * Wenn erfolgreich entfernt, sende NotificationClosed Event für id\_to\_replace mit CloseReason::Replaced.  
         * Wenn nicht gefunden: Err(NotificationCoreError::ReplacedNotificationNotFound(id\_to\_replace)).  
       * Füge processed\_notification.clone() zu active\_notifications hinzu (mit ihrer eigenen id).  
       * Sende NotificationAdded { notification: processed\_notification.clone(),... } Event.  
       * Ok(processed\_notification.id).  
2. **NotificationCoreManager::close\_notification:**  
   * Erwirb Schreibsperren für active\_notifications und history.  
   * Entferne Benachrichtigung mit id aus active\_notifications. Wenn nicht gefunden: Err(NotificationCoreError::NotificationNotFound(id)).  
   * Sei closed\_notification die entfernte Benachrichtigung.  
   * Wenn closed\_notification.is\_persistent oder reason dies nahelegt (z.B. DismissedByUser, aber nicht Expired wenn nicht persistent):  
     * Rufe history.write().await.add(closed\_notification.clone()) auf. Handle HistoryFull Fehler, falls add diesen zurückgeben kann (oder logge es).  
   * Sende NotificationClosed { notification\_id: id, app\_name: closed\_notification.app\_name, summary: closed\_notification.summary, reason,... } Event.  
   * Ok(()).  
3. **NotificationHistory::add (interne Methode von NotificationHistory):**  
   * Wenn self.notifications.len() \>= self.max\_size und self.max\_size \> 0:  
     * self.notifications.pop\_front() (entferne die älteste).  
   * self.notifications.push\_back(notification).  
4. **NotificationCoreManager::invoke\_action:**  
   * Erwirb Lesesperre für active\_notifications.  
   * Hole Benachrichtigung mit notification\_id. Wenn nicht gefunden: Err(NotificationCoreError::NotificationNotFound).  
   * Prüfe, ob die Aktion mit action\_key in notification.actions existiert. Wenn nicht: Err(NotificationCoreError::ActionNotFound).  
   * Sende NotificationActionInvoked { notification\_id, action\_key: action\_key.to\_string(),... } Event.  
   * Ok(()). (Die Domänenschicht löst nur das Event aus; die tatsächliche Aktionsausführung erfolgt in höheren Schichten oder der Anwendung selbst).

### **4.3.7. Überlegungen zur Nebenläufigkeit und Zustandssynchronisierung**

* active\_notifications und history (bzw. dessen interne VecDeque) benötigen tokio::sync::RwLock für Thread-sicheren Lese- und Schreibzugriff, da mehrere Tasks (z.B. durch D-Bus-Aufrufe oder interne Timer) gleichzeitig auf Benachrichtigungen zugreifen könnten.  
* Die rules\_engine wird als Arc\<NotificationRulesEngine\> übergeben, da sie von mehreren Aufrufen (z.B. für jede neue Benachrichtigung) nebenläufig genutzt werden kann und ihr Zustand (die Regeln) ebenfalls Thread-sicher sein muss.  
* Der broadcast::Sender für NotificationEvent ist inhärent Thread-sicher.13

## **4.4. Entwicklungsmodul: Priorisierung und Regel-Engine für Benachrichtigungen (domain::notifications\_rules)**

Dieses Modul implementiert die Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf einem Satz von konfigurierbaren Regeln.

### **4.4.1. Detaillierte Verantwortlichkeiten und Ziele**

* **Verantwortlichkeiten:**  
  * Definition der Struktur von Benachrichtigungsregeln (NotificationRule), deren Bedingungen (RuleCondition) und Aktionen (RuleAction).  
  * Bereitstellung einer Engine (NotificationRulesEngine), die eingehende Benachrichtigungen anhand dieser Regeln bewertet.  
  * Ermöglichung von Modifikationen an Benachrichtigungen durch Regeln (z.B. Dringlichkeit ändern, Ton festlegen, Aktionen hinzufügen).  
  * Ermöglichung der Unterdrückung von Benachrichtigungen basierend auf Regelbedingungen.  
  * Interaktion mit domain::settings\_core (durch Empfang von SettingChangedEvents und Abfrage von Einstellungswerten), um kontextsensitive Regeln zu ermöglichen (z.B. "Nicht stören"-Modus, anwendungsspezifische Stummschaltungen).  
  * Laden und Verwalten von Regeldefinitionen. Diese können initial fest kodiert sein, sollten aber idealerweise aus einer externen Konfiguration (z.B. via SettingsProvider) geladen werden können, um Flexibilität zu gewährleisten.  
* **Ziele:**  
  * Schaffung einer flexiblen und erweiterbaren Logik zur dynamischen Anpassung des Benachrichtigungsverhaltens.  
  * Ermöglichung einer feingranularen Steuerung des Benachrichtigungsflusses durch den Benutzer (implizit über Systemeinstellungen) oder durch Systemadministratoren.  
  * Reduzierung von "Notification Fatigue" durch intelligente Filterung und Priorisierung.

Ein wichtiger Aspekt beim Design der Regel-Engine ist die Frage, ob Regeln fest im Code verankert oder datengetrieben (z.B. aus einer Konfigurationsdatei) sind. Ein datengetriebener Ansatz erhöht die Flexibilität und Wartbarkeit erheblich, da Regeln ohne Neukompilierung des Systems geändert oder hinzugefügt werden können. Dies erfordert, dass die Regelstrukturen (NotificationRule, RuleCondition, RuleAction) serde::Serialize und serde::Deserialize implementieren. Selbst wenn die erste Version mit fest kodierten Regeln startet, sollte das Design eine spätere Umstellung ermöglichen.

### **4.4.2. Entitäten und Wertobjekte**

Alle Typen sind in domain/src/notifications\_rules/types.rs zu definieren. Sie benötigen Debug, Clone, PartialEq und, für datengetriebene Regeln, serde::Serialize und serde::Deserialize.

* **RuleCondition (Enum, Wertobjekt)**  
  * **Zweck:** Definiert die Bedingungen, die erfüllt sein müssen, damit eine Regel ausgelöst wird.  
  * **Warum wertvoll:** Ermöglicht die flexible und kompositorische Definition von Kriterien für Regeln, von einfachen Vergleichen bis zu komplexen logischen Verknüpfungen.

| Variante | Assoziierte Daten | Beschreibung |
| :---- | :---- | :---- |
| AppNameIs | String | Der app\_name der Benachrichtigung entspricht exakt dem Wert (case-sensitive). |
| AppNameMatches | String (als Regex-Pattern zu interpretieren) | Der app\_name der Benachrichtigung entspricht dem regulären Ausdruck. |
| SummaryContains | String | Der summary der Benachrichtigung enthält den Text (case-insensitive). |
| SummaryMatches | String (Regex-Pattern) | Der summary der Benachrichtigung entspricht dem regulären Ausdruck. |
| BodyContains | String | Der body der Benachrichtigung (falls vorhanden) enthält den Text (case-insensitive). |
| UrgencyIs | NotificationUrgency | Die urgency der Benachrichtigung entspricht dem Wert. |
| CategoryIs | String | Die category der Benachrichtigung (falls vorhanden) entspricht exakt dem Wert. |
| HintExists | String (Schlüssel des Hints) | Ein bestimmter Schlüssel existiert in den hints der Benachrichtigung. |
| HintValueIs | (String (Hint-Schlüssel), SettingValue (erwarteter Wert)) | Ein bestimmter Hint-Schlüssel existiert und sein Wert entspricht dem SettingValue. |
| SettingIsTrue | SettingKey (Schlüssel zu einer Boolean-Einstellung) | Eine globale Systemeinstellung (aus SettingsCoreManager) ist auf true gesetzt. |
| SettingIsFalse | SettingKey (Schlüssel zu einer Boolean-Einstellung) | Eine globale Systemeinstellung ist auf false gesetzt. |
| SettingValueEquals | (SettingKey, SettingValue) | Eine globale Systemeinstellung hat exakt den spezifizierten Wert. |
| LogicalAnd | Vec\<RuleCondition\> | Alle Unterbedingungen in der Liste müssen wahr sein. |
| LogicalOr | Vec\<RuleCondition\> | Mindestens eine der Unterbedingungen in der Liste muss wahr sein. |
| LogicalNot | Box\<RuleCondition\> | Die umschlossene Unterbedingung muss falsch sein. |

* **RuleAction (Enum, Wertobjekt)**  
  * **Zweck:** Definiert die Aktionen, die ausgeführt werden, wenn die Bedingungen einer Regel erfüllt sind.  
  * **Warum wertvoll:** Beschreibt, wie eine Benachrichtigung als Reaktion auf eine Regel modifiziert oder behandelt wird.

| Variante | Assoziierte Daten | Beschreibung |
| :---- | :---- | :---- |
| SuppressNotification | \- | Unterdrückt die Benachrichtigung vollständig. Sie wird nicht aktiv und typischerweise auch nicht in der Historie gespeichert. |
| SetUrgency | NotificationUrgency | Ändert die urgency der Benachrichtigung auf den neuen Wert. |
| AddAction | NotificationAction | Fügt eine zusätzliche NotificationAction zur Liste der Aktionen der Benachrichtigung hinzu. |
| SetHint | (String (Hint-Schlüssel), SettingValue (Wert)) | Setzt oder überschreibt einen Wert in den hints der Benachrichtigung. |
| PlaySound | Option\<String\> (Sound-Datei/Name oder Event-Name) | Signalisiert, dass ein Ton abgespielt werden soll. None für einen Standard-Benachrichtigungston, Some(name) für einen spezifischen Ton. Die Implementierung des Abspielens erfolgt in der System- oder UI-Schicht. |
| MarkAsPersistent | bool | Setzt das is\_persistent-Flag der Benachrichtigung. |
| SetExpiration | Option\<i64\> (Millisekunden relativ zu jetzt) | Setzt oder ändert die Ablaufzeit der Benachrichtigung. None entfernt eine existierende Ablaufzeit. Ein positiver Wert gibt die Dauer in ms an. |
| LogMessage | (String (Level: "info", "warn", "debug"), String (Nachricht)) | Schreibt eine Nachricht ins System-Log (über das tracing-Framework). Nützlich für das Debugging von Regeln. |

* **NotificationRule (Struktur, Entität)**  
  * **Zweck:** Repräsentiert eine einzelne, vollständige Regel mit Bedingungen und Aktionen.  
  * **Warum wertvoll:** Die atomaren Bausteine der Regel-Engine. Eine Sammlung dieser Regeln definiert das Verhalten des Benachrichtigungssystems.

| Attribut | Typ | Sichtbarkeit | Beschreibung |
| :---- | :---- | :---- | :---- |
| id | String | pub | Eindeutige, menschenlesbare ID der Regel (z.B. "suppress-low-priority-chat", "urgentify-calendar-reminders"). |
| description | Option\<String\> | pub | Optionale, menschenlesbare Beschreibung des Zwecks der Regel. |
| conditions | RuleCondition | pub | Die Bedingung(en), die erfüllt sein müssen, damit die Regel angewendet wird. Oft eine LogicalAnd oder LogicalOr. |
| actions | Vec\<RuleAction\> | pub | Die Liste der Aktionen, die ausgeführt werden, wenn die conditions zutreffen. Die Reihenfolge kann relevant sein. |
| is\_enabled | bool | pub | Gibt an, ob die Regel aktiv ist und ausgewertet werden soll. Default: true. |
| priority | i32 | pub | Priorität der Regel. Regeln mit höherem Wert werden typischerweise früher ausgewertet. Default: 0\. |
| stop\_after | bool | pub | Wenn true und diese Regel zutrifft und Aktionen ausführt, werden keine weiteren (niedriger priorisierten) Regeln für diese Benachrichtigung mehr ausgewertet. Default: false. |

### **4.4.3. Öffentliche API des Moduls (NotificationRulesEngine)**

Definiert in domain/src/notifications\_rules/mod.rs.

Rust

// domain/src/notifications\_rules/mod.rs  
use crate::notifications\_core::types::{Notification, NotificationUrgency, SettingValue as NotificationSettingValue}; // SettingValue hier umbenannt zur Klarheit  
use crate::notifications\_rules::types::{NotificationRule, RuleCondition, RuleAction, NotificationAction as RuleNotificationAction};  
use crate::notifications\_rules::error::NotificationRulesError;  
use crate::settings\_core::{SettingsCoreManager, SettingChangedEvent, SettingKey, SettingValue};  
use std::sync::Arc;  
use tokio::sync::{RwLock, broadcast::Receiver as BroadcastReceiver}; // Receiver explizit benannt  
use tracing; // Für LogMessage Aktion

\#  
pub enum RuleProcessingResult {  
    Allow(Notification),  
    Suppress(String), // Enthält die ID der Regel, die zur Unterdrückung geführt hat  
}

pub struct NotificationRulesEngine {  
    rules: RwLock\<Vec\<NotificationRule\>\>,  
    settings\_manager: Arc\<SettingsCoreManager\>,  
    // settings\_update\_receiver: RwLock\<Option\<BroadcastReceiver\<SettingChangedEvent\>\>\>, // Für das Lauschen auf Einstellungsänderungen  
}

impl NotificationRulesEngine {  
    pub fn new(  
        settings\_manager: Arc\<SettingsCoreManager\>,  
        initial\_rules: Vec\<NotificationRule\>,  
        // mut settings\_event\_receiver: BroadcastReceiver\<SettingChangedEvent\> // Wird übergeben  
    ) \-\> Arc\<Self\> { // Gibt Arc\<Self\> zurück, um das Klonen für den Listener-Task zu erleichtern  
        let mut sorted\_rules \= initial\_rules;  
        sorted\_rules.sort\_by\_key(|r| \-r.priority); // Höchste Priorität zuerst

        let engine \= Arc::new(NotificationRulesEngine {  
            rules: RwLock::new(sorted\_rules),  
            settings\_manager,  
            // settings\_update\_receiver: RwLock::new(Some(settings\_event\_receiver)),  
        });

        // Hier könnte ein Task gestartet werden, der auf settings\_event\_receiver lauscht  
        // und self.handle\_setting\_changed aufruft.  
        // let engine\_clone \= Arc::clone(\&engine);  
        // tokio::spawn(async move {  
        //     if let Some(mut rx) \= engine\_clone.settings\_update\_receiver.write().await.take() {  
        //         while let Ok(event) \= rx.recv().await {  
        //             engine\_clone.handle\_setting\_changed(\&event).await;  
        //         }  
        //     }  
        // });

        engine  
    }

    pub async fn load\_rules(\&self, new\_rules: Vec\<NotificationRule\>) {  
        let mut rules\_guard \= self.rules.write().await;  
        \*rules\_guard \= new\_rules;  
        rules\_guard.sort\_by\_key(|r| \-r.priority); // Höchste Priorität zuerst  
        tracing::info\!("Notification rules reloaded. {} rules active.", rules\_guard.len());  
    }

    pub async fn process\_notification(  
        \&self,  
        notification: \&Notification,  
    ) \-\> Result\<RuleProcessingResult, NotificationRulesError\> {  
        let rules\_guard \= self.rules.read().await;  
        let mut current\_notification \= notification.clone();  
        let mut suppressed\_by\_rule\_id: Option\<String\> \= None;

        for rule in rules\_guard.iter().filter(|r| r.is\_enabled) {  
            if self.evaluate\_condition(\&rule.conditions, \&current\_notification, rule).await? {  
                tracing::debug\!("Rule '{}' matched for notification '{}'", rule.id, notification.summary);  
                for action in \&rule.actions {  
                    match self.apply\_action(action, \&mut current\_notification, rule).await? {  
                        RuleProcessingResult::Suppress(\_) \=\> {  
                            suppressed\_by\_rule\_id \= Some(rule.id.clone());  
                            break; // Aktion "Suppress" beendet Aktionsschleife für diese Regel  
                        }  
                        RuleProcessingResult::Allow(modified\_notification) \=\> {  
                            current\_notification \= modified\_notification;  
                        }  
                    }  
                }  
                if suppressed\_by\_rule\_id.is\_some() |  
| rule.stop\_after {  
                    break; // Regelverarbeitung für diese Benachrichtigung beenden  
                }  
            }  
        }

        if let Some(rule\_id) \= suppressed\_by\_rule\_id {  
            Ok(RuleProcessingResult::Suppress(rule\_id))  
        } else {  
            Ok(RuleProcessingResult::Allow(current\_notification))  
        }  
    }

    async fn evaluate\_condition(  
        \&self,  
        condition: \&RuleCondition,  
        notification: \&Notification,  
        rule: \&NotificationRule, // Für Kontext in Fehlermeldungen  
    ) \-\> Result\<bool, NotificationRulesError\> {  
        match condition {  
            RuleCondition::AppNameIs(name) \=\> Ok(\&notification.app\_name \== name),  
            RuleCondition::AppNameMatches(pattern) \=\> {  
                // Hier Regex-Implementierung, z.B. mit \`regex\` Crate  
                // Für dieses Beispiel: einfache Prüfung  
                match regex::Regex::new(pattern) {  
                    Ok(re) \=\> Ok(re.is\_match(\&notification.app\_name)),  
                    Err(e) \=\> Err(NotificationRulesError::ConditionEvaluationError{ rule\_id: Some(rule.id.clone()), message: format\!("Invalid regex pattern '{}': {}", pattern, e) })  
                }  
            }  
            RuleCondition::SummaryContains(text) \=\> Ok(notification.summary.to\_lowercase().contains(\&text.to\_lowercase())),  
            //... Implementierung für alle RuleCondition-Varianten...  
            RuleCondition::SettingIsTrue(key) \=\> {  
                match self.settings\_manager.get\_setting\_value(key).await {  
                    Ok(SettingValue::Boolean(b)) \=\> Ok(b),  
                    Ok(other\_type) \=\> {  
                        tracing::warn\!("Rule '{}' expected boolean for setting '{}', got {:?}", rule.id, key.as\_str(), other\_type);  
                        Ok(false) // Falscher Typ, als false bewerten  
                    }  
                    Err(SettingsCoreError::SettingNotFound{..}) | Err(SettingsCoreError::UnregisteredKey{..}) \=\> {  
                        tracing::debug\!("Rule '{}': Setting '{}' not found or unregistered, condition evaluates to false.", rule.id, key.as\_str());  
                        Ok(false) // Einstellung nicht gefunden, als false bewerten  
                    }  
                    Err(e) \=\> Err(NotificationRulesError::SettingsAccessError(e)) // Anderer Fehler beim Holen  
                }  
            }  
            RuleCondition::LogicalAnd(sub\_conditions) \=\> {  
                for sub\_cond in sub\_conditions {  
                    if\!self.evaluate\_condition(sub\_cond, notification, rule).await? {  
                        return Ok(false);  
                    }  
                }  
                Ok(true)  
            }  
            RuleCondition::LogicalOr(sub\_conditions) \=\> {  
                for sub\_cond in sub\_conditions {  
                    if self.evaluate\_condition(sub\_cond, notification, rule).await? {  
                        return Ok(true);  
                    }  
                }  
                Ok(false)  
            }  
            RuleCondition::LogicalNot(sub\_condition) \=\> {  
                Ok(\!self.evaluate\_condition(sub\_condition, notification, rule).await?)  
            }  
            // Standard-Fallback für nicht implementierte Bedingungen (sollte nicht passieren bei vollständiger Impl.)  
            \_ \=\> {  
                tracing::warn\!("Unimplemented condition met in rule '{}': {:?}", rule.id, condition);  
                Ok(false)  
            }  
        }  
    }

    async fn apply\_action(  
        \&self,  
        action: \&RuleAction,  
        notification: \&mut Notification,  
        rule: \&NotificationRule, // Für Kontext  
    ) \-\> Result\<RuleProcessingResult, NotificationRulesError\> {  
        tracing::debug\!("Applying action {:?} from rule '{}' to notification '{}'", action, rule.id, notification.summary);  
        match action {  
            RuleAction::SuppressNotification \=\> return Ok(RuleProcessingResult::Suppress(rule.id.clone())),  
            RuleAction::SetUrgency(new\_urgency) \=\> notification.urgency \= \*new\_urgency,  
            RuleAction::AddAction(new\_action) \=\> {  
                // Prüfen, ob Aktion mit gleichem Key schon existiert, um Duplikate zu vermeiden  
                if\!notification.actions.iter().any(|a| a.key \== new\_action.key) {  
                    notification.actions.push(new\_action.clone());  
                }  
            }  
            RuleAction::SetHint((key, value)) \=\> {  
                notification.hints.insert(key.clone(), value.clone().into\_setting\_value()); // Annahme: value ist hier ein Domänen-SettingValue  
            }  
            RuleAction::PlaySound(sound\_name\_opt) \=\> {  
                // Diese Aktion setzt typischerweise einen Hint, den die UI/Systemschicht interpretiert  
                let hint\_key \= "sound-name".to\_string();  
                if let Some(sound\_name) \= sound\_name\_opt {  
                    notification.hints.insert(hint\_key, NotificationSettingValue::String(sound\_name.clone()));  
                } else {  
                    // Signal für Standardton, z.B. spezieller Wert oder Entfernen des Hints  
                    notification.hints.remove(\&hint\_key);  
                }  
            }  
            RuleAction::MarkAsPersistent(is\_persistent) \=\> notification.is\_persistent \= \*is\_persistent,  
            RuleAction::SetExpiration(duration\_ms\_opt) \=\> {  
                if let Some(duration\_ms) \= duration\_ms\_opt {  
                    if \*duration\_ms \> 0 {  
                        notification.expires\_at \= Some(Utc::now() \+ chrono::Duration::milliseconds(\*duration\_ms));  
                    } else {  
                        notification.expires\_at \= None; // Negative oder Null-Dauer entfernt Expiration  
                    }  
                } else {  
                    notification.expires\_at \= None;  
                }  
            }  
            RuleAction::LogMessage((level, message)) \=\> {  
                let full\_message \= format\!(" {}", rule.id, message);  
                match level.as\_str() {  
                    "info" \=\> tracing::info\!("{}", full\_message),  
                    "warn" \=\> tracing::warn\!("{}", full\_message),  
                    "debug" \=\> tracing::debug\!("{}", full\_message),  
                    \_ \=\> tracing::trace\!("{}", full\_message), // Default zu trace  
                }  
            }  
        }  
        Ok(RuleProcessingResult::Allow(notification.clone()))  
    }

    // Diese Methode wird aufgerufen, wenn ein SettingChangedEvent empfangen wird.  
    // Sie könnte z.B. einen internen Cache für Settings aktualisieren, falls verwendet,  
    // oder Regeln neu bewerten, die von dieser Einstellung abhängen (komplexer).  
    // Für eine einfache Implementierung ohne Cache ist diese Methode ggf. leer  
    // oder löst nur einen Log-Eintrag aus.  
    pub async fn handle\_setting\_changed(\&self, event: \&SettingChangedEvent) {  
        tracing::debug\!("NotificationRulesEngine received SettingChangedEvent for key: {}", event.key.as\_str());  
        // Hier könnte Logik stehen, um z.B. interne Caches zu invalidieren,  
        // falls die Performance der direkten Abfrage des SettingsCoreManager ein Problem darstellt.  
        // Für die meisten Fälle sollte die direkte Abfrage bei Bedarf ausreichend sein.  
    }  
}

// Hilfskonvertierung für RuleAction::SetHint, falls SettingValue aus notifications\_rules::types  
// und settings\_core::types nicht identisch sind (sollten sie aber sein).  
// Hier wird angenommen, dass SettingValue aus settings\_core verwendet wird.  
trait IntoSettingValue {  
    fn into\_setting\_value(self) \-\> SettingValue;  
}  
impl IntoSettingValue for NotificationSettingValue { // Hier NotificationSettingValue ist Alias für settings\_core::SettingValue  
    fn into\_setting\_value(self) \-\> SettingValue {  
        self // Direkte Konvertierung, da Typen identisch sein sollten  
    }  
}

(Hinweis: Die regex-Crate müsste als Abhängigkeit hinzugefügt werden. Der Listener-Task für Einstellungsänderungen ist auskommentiert, da seine Implementierung von der genauen Architektur des Event-Handlings abhängt und den Rahmen sprengen könnte, aber das Prinzip ist wichtig.)

* **Tabelle: Methoden der NotificationRulesEngine**

| Methode | Signatur | Kurzbeschreibung |
| :---- | :---- | :---- |
| new | pub fn new(settings\_manager: Arc\<SettingsCoreManager\>, initial\_rules: Vec\<NotificationRule\>/\*, settings\_event\_receiver: BroadcastReceiver\<SettingChangedEvent\>\*/) \-\> Arc\<Self\> | Konstruktor. Lädt initiale Regeln, sortiert sie nach Priorität. Speichert Referenz auf SettingsCoreManager. Startet optional einen Task, um auf SettingChangedEvents zu lauschen. Gibt Arc\<Self\> zurück. |
| load\_rules | pub async fn load\_rules(\&self, new\_rules: Vec\<NotificationRule\>) | Lädt einen neuen Satz von Regeln, ersetzt die alten und sortiert sie neu nach Priorität. |
| process\_notification | pub async fn process\_notification(\&self, notification: \&Notification) \-\> Result\<RuleProcessingResult, NotificationRulesError\> | Verarbeitet eine eingehende Benachrichtigung anhand der geladenen, aktivierten Regeln. Gibt entweder eine (potenziell modifizierte) Benachrichtigung (Allow) oder ein Signal zur Unterdrückung (Suppress) mit der verantwortlichen Regel-ID zurück. |
| handle\_setting\_changed | pub async fn handle\_setting\_changed(\&self, event: \&SettingChangedEvent) | Wird (intern, z.B. durch einen dedizierten Task) aufgerufen, wenn sich eine für Regeln relevante Systemeinstellung ändert. Ermöglicht der Engine, ihren Zustand oder ihr Verhalten anzupassen (z.B. Cache-Invalidierung). |

Die Entscheidung, SettingValue aus settings\_core auch in den RuleCondition und RuleAction zu verwenden, vereinfacht die Typisierung und vermeidet unnötige Konvertierungen.

### **4.4.4. Fehlerbehandlung (NotificationRulesError)**

Definiert in domain/src/notifications\_rules/error.rs mit thiserror.

Rust

// domain/src/notifications\_rules/error.rs  
use thiserror::Error;  
use crate::settings\_core::error::SettingsCoreError; // Für Fehler beim Zugriff auf Settings

\#  
pub enum NotificationRulesError {  
    \#  
    InvalidRuleDefinition {  
        rule\_id: Option\<String\>,  
        message: String,  
    },

    \#\[error("Failed to evaluate condition for rule '{rule\_id:?}': {message}")\]  
    ConditionEvaluationError {  
        rule\_id: Option\<String\>,  
        message: String,  
    },

    \#\[error("Failed to apply action for rule '{rule\_id:?}': {message}")\]  
    ActionApplicationError {  
        rule\_id: Option\<String\>,  
        message: String,  
    },

    \#\[error("Error accessing settings for rule evaluation: {source}")\]  
    SettingsAccessError{  
        \#\[from\] // Direkte Konvertierung von SettingsCoreError  
        source: SettingsCoreError  
    },

    \# // Wird intern verwendet, falls Regeln auf andere verweisen  
    RuleNotFound(String),  
}

* **Tabelle: NotificationRulesError Varianten**

| Variante | Beschreibung |
| :---- | :---- |
| InvalidRuleDefinition | Eine geladene Regel ist ungültig (z.B. fehlerhaftes Regex-Pattern in AppNameMatches, widersprüchliche Bedingungen, unbekannte Aktionstypen). |
| ConditionEvaluationError | Ein Fehler trat während der Auswertung einer Bedingung auf (z.B. Regex-Kompilierungsfehler, interner Logikfehler). |
| ActionApplicationError | Ein Fehler trat während der Anwendung einer Aktion auf (z.B. ungültige Parameter für eine Aktion). |
| SettingsAccessError | Fehler beim Zugriff auf SettingsCoreManager für die Auswertung von Bedingungen, die auf Systemeinstellungen basieren. Nutzt \#\[from\]. |
| RuleNotFound | Eine referenzierte Regel-ID (z.B. in einer komplexen Regelstruktur) existiert nicht. |

### **4.4.5. Detaillierte Implementierungsschritte und Algorithmen**

1. **Initialisierung (NotificationRulesEngine::new):**  
   * Speichere den Arc\<SettingsCoreManager\>.  
   * Lade die initial\_rules.  
   * Sortiere die Regeln nach priority (absteigend, d.h. höhere numerische Werte zuerst) und dann ggf. nach id für deterministische Reihenfolge bei gleicher Priorität.  
   * **Abonnement von Einstellungsänderungen:** Es ist entscheidend, dass die Regel-Engine auf Änderungen von Systemeinstellungen reagieren kann, die in RuleConditions verwendet werden (z.B. "Nicht stören"-Modus).  
     * Der NotificationRulesEngine sollte beim Erstellen einen broadcast::Receiver\<SettingChangedEvent\> vom SettingsCoreManager erhalten (oder der SettingsCoreManager registriert die Engine als Listener).  
     * Ein dedizierter tokio::task sollte gestartet werden, der diesen Receiver konsumiert. Bei Empfang eines SettingChangedEvent ruft dieser Task engine.handle\_setting\_changed(\&event).await auf.  
     * handle\_setting\_changed kann dann z.B. einen internen Cache von oft benötigten Einstellungswerten invalidieren oder aktualisieren, um zu vermeiden, dass für jede Regelauswertung der SettingsCoreManager abgefragt werden muss (Performance-Optimierung, falls nötig). Für den Anfang kann es ausreichen, dass evaluate\_condition immer live den SettingsCoreManager abfragt.  
2. **NotificationRulesEngine::process\_notification:**  
   * Erwirb eine Lesesperre auf self.rules.  
   * Klone die eingehende notification, um Modifikationen zu ermöglichen (current\_notification).  
   * Iteriere durch die sortierten, aktivierten (rule.is\_enabled) Regeln.  
   * Für jede Regel:  
     * Evaluiere rule.conditions rekursiv mittels self.evaluate\_condition(\&rule.conditions, \&current\_notification, \&rule).await.  
     * Wenn die Bedingungen erfüllt sind (true):  
       * Iteriere durch rule.actions.  
       * Wende jede Aktion auf current\_notification an mittels self.apply\_action(action, \&mut current\_notification, \&rule).await.  
       * Wenn eine Aktion RuleProcessingResult::Suppress zurückgibt (z.B. RuleAction::SuppressNotification), speichere die rule.id und brich die Verarbeitung der Aktionen *dieser Regel* ab.  
       * Wenn RuleProcessingResult::Allow(modified\_notification) zurückgegeben wird, aktualisiere current\_notification \= modified\_notification.  
       * Wenn suppressed\_by\_rule\_id gesetzt wurde oder rule.stop\_after \== true ist, brich die Iteration über *weitere Regeln* ab.  
   * Wenn am Ende suppressed\_by\_rule\_id gesetzt ist, gib Ok(RuleProcessingResult::Suppress(rule\_id)) zurück.  
   * Andernfalls gib Ok(RuleProcessingResult::Allow(current\_notification)) zurück.  
3. **NotificationRulesEngine::evaluate\_condition (rekursiv):**  
   * Implementiere die Logik für jede RuleCondition-Variante:  
     * Einfache Vergleiche (AppNameIs, SummaryContains, UrgencyIs, etc.) sind direkte Vergleiche der Felder der notification.  
     * Regex-basierte Vergleiche (AppNameMatches, SummaryMatches) verwenden die regex-Crate. Fehler bei der Regex-Kompilierung (sollten idealerweise beim Laden der Regeln abgefangen werden) führen zu Err(NotificationRulesError::ConditionEvaluationError).  
     * HintExists, HintValueIs: Zugriff auf notification.hints.  
     * SettingIsTrue, SettingIsFalse, SettingValueEquals: Asynchroner Aufruf von self.settings\_manager.get\_setting\_value(\&key).await.  
       * Fehler wie SettingsCoreError::SettingNotFound oder UnregisteredKey sollten die Bedingung typischerweise als false bewerten lassen, anstatt einen harten Fehler in der Regel-Engine auszulösen, um die Robustheit zu erhöhen. Ein Log-Eintrag (Warnung oder Debug) ist hier angebracht. Andere SettingsCoreError (z.B. PersistenceError) sollten als Err(NotificationRulesError::SettingsAccessError) propagiert werden.  
     * LogicalAnd: Gibt true zurück, wenn alle Unterbedingungen true sind (Kurzschlussauswertung).  
     * LogicalOr: Gibt true zurück, wenn mindestens eine Unterbedingung true ist (Kurzschlussauswertung).  
     * LogicalNot: Negiert das Ergebnis der Unterbedingung.  
   * Alle Pfade müssen Result\<bool, NotificationRulesError\> zurückgeben.  
4. **NotificationRulesEngine::apply\_action:**  
   * Implementiere die Logik für jede RuleAction-Variante.  
   * Die meisten Aktionen modifizieren die übergebene \&mut Notification direkt (z.B. SetUrgency, AddAction, SetHint, MarkAsPersistent, SetExpiration).  
   * SuppressNotification gibt Ok(RuleProcessingResult::Suppress(...)) zurück.  
   * PlaySound könnte einen speziellen Hint setzen (z.B. sound-event: "message-new-instant"), den die UI-Schicht interpretiert.  
   * LogMessage verwendet das tracing-Makro (z.B. tracing::info\!).  
   * Alle Pfade geben Result\<RuleProcessingResult, NotificationRulesError\> zurück (meist Ok(RuleProcessingResult::Allow(notification.clone())) nach Modifikation).

### **4.4.6. Erweiterbarkeit und Konfiguration der Regeln**

* Um Regeln dynamisch (z.B. aus Konfigurationsdateien) laden zu können, müssen NotificationRule und alle eingebetteten Typen (RuleCondition, RuleAction) serde::Serialize und serde::Deserialize implementieren.  
* Die NotificationRulesEngine könnte eine Methode async fn load\_rules\_from\_provider(\&self, settings\_provider: Arc\<dyn SettingsProvider\>, config\_key: \&SettingKey) anbieten. Diese Methode würde:  
  1. Den settings\_provider verwenden, um eine serialisierte Regelmenge (z.B. als JSON-String oder eine Liste von serialisierten Regelobjekten) unter config\_key zu laden.  
  2. Die geladenen Daten deserialisieren in Vec\<NotificationRule\>.  
  3. Diese neuen Regeln über self.load\_rules(...) aktivieren.  
* Das Format der Serialisierung (z.B. JSON, YAML, TOML) muss sorgfältig entworfen werden, um sowohl menschenlesbar als auch maschinell verarbeitbar zu sein. Validierungsschemata (z.B. JSON Schema) können helfen, die Korrektheit der Regeldefinitionen sicherzustellen, bevor sie geladen werden.  
* Die Fehlerbehandlung beim Laden und Deserialisieren von Regeln muss robust sein (InvalidRuleDefinition).

Diese detaillierte Ausarbeitung der Einstellungs- und Benachrichtigungs-Subsysteme vervollständigt die Spezifikation der Domänenschicht und legt eine solide Grundlage für deren Implementierung. Die Betonung von klar definierten Schnittstellen, Typsicherheit, Fehlerbehandlung und Entkopplung durch Events und Abstraktionen ist entscheidend für die Entwicklung einer modernen, wartbaren und erweiterbaren Desktop-Umgebung.

#### **Referenzen**

1. uuid \- Rust, Zugriff am Mai 14, 2025, [https://messense.github.io/bosonnlp-rs/uuid/index.html](https://messense.github.io/bosonnlp-rs/uuid/index.html)  
2. Uuid in rocket::serde::uuid \- Rust, Zugriff am Mai 14, 2025, [https://api.rocket.rs/v0.5/rocket/serde/uuid/struct.Uuid](https://api.rocket.rs/v0.5/rocket/serde/uuid/struct.Uuid)  
3. chrono::serde \- Rust, Zugriff am Mai 14, 2025, [https://prisma.github.io/prisma-engines/doc/chrono/serde/index.html](https://prisma.github.io/prisma-engines/doc/chrono/serde/index.html)  
4. chrono \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/chrono](https://crates.io/crates/chrono)  
5. Arc in std::sync \- Rust Documentation, Zugriff am Mai 14, 2025, [https://doc.rust-lang.org/std/sync/struct.Arc.html](https://doc.rust-lang.org/std/sync/struct.Arc.html)  
6. Tokio: Channels \- oida.dev, Zugriff am Mai 14, 2025, [https://oida.dev/rust-tokio-guide/channels/](https://oida.dev/rust-tokio-guide/channels/)  
7. tokio::sync \- Rust, Zugriff am Mai 14, 2025, [https://docs.rs/tokio/latest/tokio/sync/index.html](https://docs.rs/tokio/latest/tokio/sync/index.html)  
8. Rust Error Handling: thiserror, anyhow, and When to Use Each | Momori Nakano, Zugriff am Mai 14, 2025, [https://momori.dev/posts/rust-error-handling-thiserror-anyhow/](https://momori.dev/posts/rust-error-handling-thiserror-anyhow/)  
9. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
10. Simplify Error Handling in Rust with thiserror Crate \- w3resource, Zugriff am Mai 14, 2025, [https://www.w3resource.com/rust-tutorial/simplify-error-handling-rust-thiserror-crate.php](https://www.w3resource.com/rust-tutorial/simplify-error-handling-rust-thiserror-crate.php)  
11. as\_dyn\_trait \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/as-dyn-trait](https://docs.rs/as-dyn-trait)  
12. Graceful Shutdown | Will Cygan, Zugriff am Mai 14, 2025, [https://www.wcygan.io/post/tokio-graceful-shutdown/](https://www.wcygan.io/post/tokio-graceful-shutdown/)  
13. tokio::sync \- Rust \- People @EECS, Zugriff am Mai 14, 2025, [https://people.eecs.berkeley.edu/\~pschafhalter/pub/erdos/doc/tokio/sync/](https://people.eecs.berkeley.edu/~pschafhalter/pub/erdos/doc/tokio/sync/)
# **Ultra-Feinspezifikation und Implementierungsplan: Systemschicht \- Teil 1/4**

## **I. Einleitung**

### **A. Zweck und Geltungsbereich dieses Dokuments (Teil 1/4 der Systemschicht)**

Dieses Dokument stellt den ersten von vier Teilen der Ultra-Feinspezifikation und des Implementierungsplans für die Systemschicht der neuartigen Linux-Desktop-Umgebung dar. Sein primäres Ziel ist es, Entwicklern eine erschöpfende und unzweideutige Anleitung für die direkte Implementierung der Kernkomponenten des Compositors und der Eingabeverarbeitung zu liefern. Der Detaillierungsgrad zielt darauf ab, jegliche Interpretationsspielräume während der Entwicklung auszuschließen; alle algorithmischen Entscheidungen, Datenstrukturen und API-Signaturen sind hierin vordefiniert.  
Der Geltungsbereich dieses ersten Teils ist strikt auf die Module system::compositor und system::input beschränkt, wie sie in der "Technischen Gesamtspezifikation und Entwicklungsrichtlinien" (im Folgenden als "Gesamtspezifikation" bezeichnet) definiert sind. Diese Module bilden das Fundament für die visuelle Darstellung und Benutzerinteraktion und sind somit grundlegend für alle nachfolgenden Komponenten der Systemschicht sowie für die darüberliegenden Schichten der Desktop-Umgebung.

### **B. Bezug zur "Technischen Gesamtspezifikation und Entwicklungsrichtlinien"**

Dieses Dokument ist eine direkte und detaillierte Erweiterung der Gesamtspezifikation. Es übersetzt die dort getroffenen übergeordneten Architekturentscheidungen, die Auswahl des Technologie-Stacks (Rust, Smithay, libinput usw.) und die Entwicklungsrichtlinien (Programmierstil, Fehlerbehandlung mittels thiserror, API-Designprinzipien, tracing für Logging) \[Gesamtspezifikation: Abschnitte II, III, IV\] in konkrete, implementierbare Spezifikationen. Insbesondere werden die in Abschnitt V.3 der Gesamtspezifikation skizzierten Komponenten der Systemschicht – hier der Compositor und die Eingabesubsysteme – detailliert ausgeführt.  
Die strikte Einhaltung der Gesamtspezifikation ist bindend. Sollten während der detaillierten Spezifikationsphase Konflikte oder Unklarheiten auftreten, die nicht durch dieses Dokument aufgelöst werden können, so sind die Prinzipien und Entscheidungen der Gesamtspezifikation maßgeblich. Dies unterstreicht die Notwendigkeit eines Prozesses zur Klärung solcher Fälle, um die Integrität der Gesamtarchitektur zu wahren. Die Qualität und Voraussicht der Gesamtspezifikation sind entscheidend für den Erfolg der Spezifikationen der einzelnen Schichten, da Lücken oder Inkonsistenzen in der Gesamtspezifikation sich in den detaillierten Implementierungsplänen potenzieren würden.

### **C. Überblick über die behandelten Module: system::compositor und system::input**

Dieser erste Teil der Systemspezifikation konzentriert sich auf zwei grundlegende Module:

1. **system::compositor**: Dieses Modul implementiert die Kernlogik des Wayland-Compositors unter Verwendung des Smithay-Toolkits. Zu seinen Verantwortlichkeiten gehören die Verwaltung von Wayland-Client-Verbindungen, der Lebenszyklus von Oberflächen (Erstellung, Mapping, Rendering, Zerstörung), die Pufferbehandlung (Shared Memory, SHM) und die Integration mit Shell-Protokollen, insbesondere xdg\_shell für modernes Desktop-Fenstermanagement. Es orchestriert das Rendering, delegiert jedoch die eigentlichen Zeichenbefehle an eine Renderer-Schnittstelle, die in späteren Teilen dieser Spezifikation detailliert wird.  
2. **system::input**: Dieses Modul ist für die gesamte Verarbeitung von Benutzereingaben zuständig, die von Geräten wie Tastaturen, Mäusen und Touchpads stammen. Es nutzt primär libinput für die Erfassung von Rohdaten-Ereignissen und die Eingabeabstraktionen von Smithay für das Seat- und Fokusmanagement.

Die Auswahl dieser beiden Module für den ersten Teil der Spezifikation ist strategisch, da sie das absolute Fundament für die Benutzerinteraktion und die visuelle Präsentation der Desktop-Umgebung bilden. Ohne einen funktionierenden Compositor und ein zuverlässiges Eingabesystem können keine übergeordneten Systemfunktionen oder Benutzeroberflächen realisiert werden. Fehler oder Ineffizienzen in diesen grundlegenden Modulen hätten kaskadierende negative Auswirkungen auf die gesamte Benutzererfahrung, einschließlich Leistung, Reaktionsfähigkeit und Stabilität. Daher müssen die von diesen Modulen für andere Schichten (Domänen- und UI-Schicht) bereitgestellten APIs von Anfang an außergewöhnlich stabil und wohldefiniert sein, da Änderungen hier zu einem späteren Zeitpunkt sehr kostspielig wären.  
Die enge Verzahnung dieser beiden Module ist offensichtlich: Vom system::input-Modul verarbeitete Eingabeereignisse bestimmen oft Fokusänderungen (verwaltet durch den SeatHandler), die wiederum beeinflussen, wie der system::compositor Ereignisse an Client-Oberflächen (WlSurface) weiterleitet. Das Verständnis des Compositors für Oberflächenlayout und \-zustand (verwaltet durch XdgShellHandler, CompositorHandler) ist für das Eingabesystem unerlässlich, um Ereignisziele korrekt zu identifizieren. Die DesktopState-Struktur, die den Gesamtzustand des Compositors kapselt, wird der zentrale Punkt sein, der all diese Smithay-Zustandsstrukturen hält und die notwendigen Handler implementiert.

#### **Tabelle: Dokumentkonventionen**

Zur Gewährleistung von Klarheit und Konsistenz in der Terminologie und den Referenzen in diesem und den nachfolgenden Teilen der Systemschichtspezifikation werden folgende Konventionen verwendet:

| Begriff/Konvention | Beschreibung | Beispiel |
| :---- | :---- | :---- |
| DesktopState | Die zentrale Compositor-Zustandsstruktur, die alle Smithay-Handler-Traits implementieren wird. | impl CompositorHandler for DesktopState |
| Gesamtspezifikation | Bezieht sich auf das Dokument "Technische Gesamtspezifikation und Entwicklungsrichtlinien". | Gemäß Gesamtspezifikation Abschnitt III. |
| WlFoo | Bezieht sich auf Wayland-Protokollobjekte (z.B. WlSurface, WlSeat). | fn commit(surface: \&WlSurface) |
| XdgFoo | Bezieht sich auf XDG-Shell-Protokollobjekte (z.B. XdgSurface, XdgToplevel). | let toplevel: ToplevelSurface \=... |
| Snippet-ID | Verweise auf Recherchematerial, z.B..1 | Smithay verwendet calloop.2 |
| system::foo::bar | Bezieht sich auf Module innerhalb der aktuellen Projektstruktur. | system::compositor::core |
| \# | Standardattribut für Fehlerdefinitionen gemäß Entwicklungsrichtlinien. | Siehe CompositorCoreError Definition. |
| tracing::{info, debug, error} | Standardmakros für Logging gemäß Entwicklungsrichtlinien. | tracing::info\!("Neue Oberfläche erstellt"); |

*Begründung für den Wert dieser Tabelle:* Diese Tabelle etabliert ein klares, gemeinsames Vokabular und Referenzierungssystem, das für ein Dokument dieser technischen Tiefe und für ein Projekt mit mehreren Entwicklern unerlässlich ist. Sie minimiert Mehrdeutigkeiten und stellt sicher, dass alle Beteiligten Verweise auf externe Dokumente, interne Komponenten und Wayland/Smithay-Entitäten verstehen.

## **II. Entwicklungsmodul: system::compositor (Smithay-basierter Wayland Compositor)**

### **A. Modulübersicht**

Dieses Modul implementiert die Kernlogik des Wayland-Compositors unter Verwendung des Smithay-Toolkits.1 Seine Hauptverantwortlichkeiten umfassen:

* Verwaltung von Wayland-Client-Verbindungen und deren Lebenszyklus.  
* Handhabung von Wayland-Protokollobjekten: wl\_display, wl\_compositor, wl\_subcompositor, wl\_shm, wl\_surface und XDG-Shell-Objekte (xdg\_wm\_base, xdg\_surface, xdg\_toplevel, xdg\_popup).  
* Integration mit der calloop-Ereignisschleife für die Ereignisverteilung.1  
* Koordination mit dem Rendering-Backend (hier werden Abstraktionen definiert, die konkrete Implementierung erfolgt in späteren Teilen).  
* Verwaltung von Oberflächenhierarchien, Rollen und Zuständen (z.B. Pufferanhänge, Schadensverfolgung).

Die Designphilosophie von Smithay, modular zu sein und kein einschränkendes Framework darzustellen 5, bedeutet, dass das system::compositor-Modul zwar Bausteine erhält, aber für deren korrekte Assemblierung und Verwaltung selbst verantwortlich ist. Dies schließt ein signifikantes Zustandsmanagement und Logik innerhalb der zentralen DesktopState-Struktur ein. Smithay fördert die Verwendung einer zentralen, mutierbaren Zustandsstruktur, die an Callbacks übergeben wird, um exzessive Nutzung von Rc\<RefCell\<T\>\> oder Arc\<Mutex\<T\>\> zu vermeiden.2 Verschiedene Smithay-Komponenten wie CompositorState, XdgShellState und ShmState sind so konzipiert, dass sie Teil der Hauptzustandsstruktur des Entwicklers werden. Handler-Traits (CompositorHandler, XdgShellHandler etc.) werden von dieser Hauptzustandsstruktur implementiert.6 Folglich wird DesktopState zu einer zentralen Drehscheibe für Wayland-Protokollinteraktionen. Während Smithay Low-Level-Protokolldetails handhabt, müssen die einzigartigen Richtlinien des Compositors (Fensterplatzierung, Fokusregeln jenseits des Basisprotokolls usw.) oft innerhalb der Handler-Trait-Methoden implementiert werden. Dies erfordert ein sorgfältiges Design von DesktopState, um seine Verantwortlichkeiten zu verwalten, ohne zu einem "God-Objekt" zu werden.  
Die Wahl von Smithay, das nativ in Rust geschrieben ist, passt perfekt zur primären Sprachwahl des Projekts (Rust) \[Gesamtspezifikation: Abschn. 3.1, 3.4\]. Dies minimiert die FFI-Komplexität im Kern des Compositors und nutzt die Sicherheitsgarantien von Rust. Die Verwendung eines Rust-nativen Toolkits für ein Rust-basiertes Projekt reduziert die Risiken und den Overhead, die mit der Sprachinteroperabilität (FFI) verbunden sind, wie z.B. unsichere C-Bindungen, Nichtübereinstimmungen bei der Speicherverwaltung und komplexe Build-System-Integration. Dies sollte zu einem robusteren und wartbareren Compositor-Kern führen als die direkte Integration von C-basierten Bibliotheken. Die Leistungscharakteristik des Compositors wird sowohl von der Effizienz von Smithay als auch von der Qualität des eigenen Rust-Codes innerhalb der Handler stark beeinflusst.

### **B. Submodul 1: Compositor-Kern (system::compositor::core)**

Dieses Submodul etabliert die grundlegenden Elemente für die Verwaltung von Wayland-Oberflächen und die Kernoperationen des Compositors.

#### **1\. Datei: compositor\_state.rs**

* **Zweck**: Definiert und verwaltet den primären Zustand für die Globals wl\_compositor und wl\_subcompositor und handhabt den Client-spezifischen Compositor-Zustand.  
* **Struktur: CompositorCoreError**  
  * Definiert Fehler, die spezifisch für Kernoperationen des Compositors sind.  
  * Verwendet thiserror gemäß den Entwicklungsrichtlinien.8  
  * **Tabelle: CompositorCoreError-Varianten**

| Variantenname | Felder | \#\[error("...")\] Nachricht (Beispiel) |
| :---- | :---- | :---- |
| GlobalCreationFailed | (String) | "Erstellung des globalen Objekts {0} fehlgeschlagen" |
| RoleError | (\#\[from\] SurfaceRoleError) | "Fehler bei der Oberflächenrolle: {0}" |
| ClientDataMissing | (wayland\_server::backend::ClientId) | "Client-Daten für Client-ID {0:?} nicht gefunden" |
| SurfaceDataMissing | (wayland\_server::protocol::wl\_surface::WlSurface) | "SurfaceData für WlSurface {0:?} nicht gefunden oder falscher Typ" |
| InvalidSurfaceState | (String) | "Ungültiger Oberflächenzustand: {0}" |

\*Begründung für den Wert dieser Tabelle:\* Klare, spezifische Fehlertypen sind entscheidend für die Fehlersuche und eine robuste Fehlerbehandlung und stehen im Einklang mit den Qualitätszielen des Projekts. \`thiserror\` vereinfacht deren Definition erheblich.

* **Struktur: DesktopState (Teilweise Definition \- Fokus auf Compositor-Aspekte)**  
  * Diese Struktur wird den zentralen Zustand für den gesamten Desktop kapseln. Hier konzentrieren wir uns auf Felder, die für den CompositorHandler relevant sind.  
  * Felder:  
    * compositor\_state: CompositorState (aus smithay::wayland::compositor) 6  
    * display\_handle: DisplayHandle (aus smithay::wayland::display::DisplayHandle, ermöglicht Interaktion mit der Wayland-Anzeige) 11  
    * loop\_handle: LoopHandle\<Self\> (aus calloop::LoopHandle\<Self\>, zur Interaktion mit der Ereignisschleife) 2  
    * (Weitere Zustände wie ShmState, XdgShellState, SeatState etc. werden in ihren jeweiligen Abschnitten detailliert.)  
  * Konstruktor:  
    Rust  
    // system/src/compositor/core/compositor\_state.rs  
    use smithay::wayland::compositor::{CompositorState, CompositorClientState, CompositorHandler};  
    use smithay::reexports::wayland\_server::{Client, DisplayHandle, protocol::wl\_surface::WlSurface};  
    use smithay::reexports::calloop::LoopHandle;  
    use std::sync::Arc;  
    use parking\_lot::Mutex; // Gemäß Vorgabe: Rust-Standard-Mutex oder crossbeam/parking\_lot  
                            // Hier parking\_lot für potenziell bessere Performance in umkämpften Szenarien.  
    use super::surface\_management::SurfaceData; // Pfad anpassen  
    use super::error::CompositorCoreError; // Pfad anpassen

    pub struct ClientCompositorData {  
        // Wird benötigt, um CompositorClientState pro Client zu speichern  
        pub compositor\_state: CompositorClientState,  
    }

    pub struct DesktopState {  
        pub display\_handle: DisplayHandle,  
        pub loop\_handle: LoopHandle\<Self\>,  
        pub compositor\_state: CompositorState,  
        // Weitere Zustände hier einfügen  
    }

    impl DesktopState {  
        pub fn new(display\_handle: DisplayHandle, loop\_handle: LoopHandle\<Self\>) \-\> Self {  
            let compositor\_state \= CompositorState::new::\<Self\>(\&display\_handle);  
            Self {  
                display\_handle,  
                loop\_handle,  
                compositor\_state,  
                // Initialisierung weiterer Zustände  
            }  
        }  
    }

* **Implementierung: CompositorHandler für DesktopState** 6  
  * Dieses Trait ist zentral dafür, wie Smithay Compositor-Ereignisse an unsere Anwendungslogik delegiert.  
  * Die Implementierung von ClientData (oft eine UserDataMap) in Smithay ist entscheidend für die Zuordnung beliebiger, typsicherer Daten zu Wayland-Client-Objekten.1 Wenn ein neuer Client eine Verbindung herstellt oder zum ersten Mal mit dem Compositor-Global interagiert, muss CompositorClientState korrekt initialisiert und in ClientData eingefügt werden. Die Bereinigung dieses Client-spezifischen Zustands wird implizit von Smithay gehandhabt, wenn ein Client die Verbindung trennt, da ClientData und dessen Inhalt dann verworfen werden.  
  * Methodenimplementierungen werden in der folgenden Tabelle detailliert.  
* **Tabelle: CompositorHandler-Methodenimplementierungsdetails für DesktopState**

| Methodenname | Signatur | Detaillierte Schritt-für-Schritt-Logik | Wichtige Smithay Funktionen/Daten | Fehlerbehandlung |
| :---- | :---- | :---- | :---- | :---- |
| compositor\_state | fn compositor\_state(\&mut self) \-\> \&mut CompositorState | 1\. \&mut self.compositor\_state zurückgeben. | self.compositor\_state | N/A |
| client\_compositor\_state | fn client\_compositor\_state\<'a\>(\&self, client: &'a Client) \-\> &'a CompositorClientState | 1\. tracing::debug\!(client\_id \=?client.id(), "Anfrage für ClientCompositorState"); 2\. match client.get\_data::\<Arc\<Mutex\<ClientCompositorData\>\>\>() (Annahme: ClientCompositorData wird in einem Arc\<Mutex\<\>\> in ClientData gespeichert). 3\. Wenn Some(data), let guard \= data.lock(); \&guard.compositor\_state zurückgeben (Achtung: Lebensdauer des Guards beachten; Smithay erwartet einen direkten Verweis. Ggf. Box::leak oder unsicheren Code vermeiden, indem CompositorClientState direkt in ClientData ist, falls Smithay dies unterstützt, oder die Datenstruktur anpassen). Smithay erwartet, dass dieser Zustand existiert. Wenn nicht, ist das ein schwerwiegender Fehler. 4\. Wenn None, tracing::error\!("ClientCompositorData nicht für Client {:?} gefunden.", client.id()); panic\!("ClientCompositorData nicht gefunden"); (oder CompositorCoreError::ClientDataMissing zurückgeben, falls die Trait-Signatur dies erlaubt, was sie hier nicht tut). | Client::get\_data(), UserDataMap, ClientCompositorData | CompositorCoreError::ClientDataMissing (intern geloggt, Panic, da Trait Rückgabe erzwingt). |
| commit | fn commit(\&mut self, surface: \&WlSurface) | 1\. tracing::debug\!(surface\_id \=?surface.id(), "Commit für Oberfläche empfangen"); 2\. Mittels \`smithay::wayland::compositor::with\_states(surface, | states | ...)aufSurfaceDatazugreifen, das mit der Oberfläche assoziiert ist. 3.let data\_map \= states.data\_map.get::\<Arc\<Mutex\<SurfaceData\>\>\>().ok\_or(CompositorCoreError::SurfaceDataMissing(surface.clone()))?;(Fehlerbehandlung anpassen). 4.let mut surface\_data \= data\_map.lock();5. Prüfen, ob ein neuer Puffer angehängt wurde (surface\_data.pending\_buffer.is\_some()). Ggf. Validierung des Puffertyps (SHM, DMABUF \- letzteres später). 6\. Schadensverfolgungsinformationen für die Oberfläche aktualisieren basierend aufstates.cached\_state.current::\<smithay::wayland::compositor::SurfaceAttributes\>().damage..6 7\. Wenn die Oberfläche eine Rolle hat (z.B. Toplevel, Popup, Cursor), rollenspezifische Commit-Logik auslösen (z.B. Fenstermanager benachrichtigen, Cursor aktualisieren). Dies beinhaltet die Prüfung vonsurface\_data.role\_data. 8\. Wenn die Oberfläche eine synchronisierte Subsurface ist, wird ihr Zustand möglicherweise nicht sofort angewendet.surface.is\_sync\_subsurface()prüfen.10 9\. Ggf. synchronisierte Kind-Subsurfaces mittelswith\_surface\_tree\_upwardoderwith\_surface\_tree\_downward\` iterieren, um deren ausstehende Zustände anzuwenden.10 10\. Oberfläche für Neuzeichnung/Rekompilierung durch die Rendering-Pipeline markieren. |
| new\_surface | fn new\_surface(\&mut self, surface: \&WlSurface) | 1\. tracing::info\!(surface\_id \=?surface.id(), "Neue WlSurface erstellt"); 2\. let client\_id \= surface.client().expect("Oberfläche muss einen Client haben").id(); 3\. SurfaceData für diese WlSurface initialisieren und mittels \`surface.data\_map().insert\_if\_missing\_threadsafe( | Arc::new(Mutex::new(SurfaceData::new(client\_id))));speichern. 4\. Zerstörungshook mittelssmithay::wayland::compositor::add\_destruction\_hook(surface, | data\_map |
| new\_subsurface | fn new\_subsurface(\&mut self, surface: \&WlSurface, parent: \&WlSurface) | 1\. tracing::info\!(surface\_id \=?surface.id(), parent\_id \=?parent.id(), "Neue WlSubsurface erstellt"); 2\. Der Handler new\_surface wird bereits für surface aufgerufen worden sein. 3\. SurfaceData von surface aktualisieren, um auf parent zu verlinken (z.B. surface\_data.parent \= Some(parent.downgrade())). 4\. SurfaceData von parent aktualisieren, um surface in einer Liste von Kindern hinzuzufügen (z.B. parent\_surface\_data.children.push(surface.downgrade())). 5\. Die Rolle "subsurface" wird typischerweise von Smithays Compositor-Modul verwaltet, wenn wl\_subcompositor.get\_subsurface gehandhabt wird.10 | WlSurface::data\_map(), SurfaceData, Object::downgrade() | Fehler beim Zugriff auf SurfaceData. |
| destroyed | fn destroyed(\&mut self, surface: \&WlSurface) | 1\. tracing::info\!(surface\_id \=?surface.id(), "WlSurface zerstört"); 2\. Die primäre Bereinigung von SurfaceData (und anderen Benutzerdaten) wird von Smithay gehandhabt, wenn das WlSurface-Objekt zerstört und seine UserDataMap verworfen wird. 3\. Alle externen Referenzen oder Zustände (z.B. in Fenstermanagementlisten), die starke Referenzen oder IDs zu dieser Oberfläche halten, müssen hier oder über Zerstörungshooks bereinigt werden. | UserDataMap::drop (implizit) | Sicherstellen, dass alle Referenzen auf die Oberfläche bereinigt werden, um Use-after-Free zu verhindern, falls nicht durch Weak-Zeiger oder Ähnliches verwaltet. |

\*Begründung für den Wert dieser Tabelle:\* Diese Tabelle ist entscheidend, da sie die abstrakten Anforderungen des \`CompositorHandler\`-Traits in konkrete Implementierungsschritte für Entwickler übersetzt und somit direkt die Anforderung der "Ultra-Feinspezifikation" erfüllt. Sie detailliert, \*wie\* mit Smithays \`CompositorState\` und \`SurfaceData\` zu interagieren ist.

* **Implementierung: GlobalDispatch\<WlCompositor, ()\> für DesktopState** 10  
  * fn bind(state: \&mut Self, handle: \&DisplayHandle, client: \&Client, resource: New\<WlCompositor\>, global\_data: &(), data\_init: \&mut DataInit\<'\_, Self\>): Wird aufgerufen, wenn ein Client an wl\_compositor bindet.  
    * **Schritt 1**: Protokollieren der Bind-Anfrage: tracing::info\!(client\_id \=?client.id(), resource\_id \=?resource.id(), "Client bindet an wl\_compositor");  
    * **Schritt 2**: Initialisieren der Client-spezifischen Compositor-Daten, falls noch nicht geschehen. client.get\_data::\<Arc\<Mutex\<ClientCompositorData\>\>\>() prüfen und ggf. client.insert\_user\_data(|| Arc::new(Mutex::new(ClientCompositorData { compositor\_state: CompositorClientState::new() })), | | {}); (Syntax für insert\_user\_data prüfen).  
    * **Schritt 3**: data\_init.init(resource, ()); (Das () ist der UserData-Typ für das WlCompositor-Global selbst, nicht für den Client).  
    * Die Erstellung des globalen wl\_compositor-Objekts wird von CompositorState::new() gehandhabt.10  
* **Implementierung: GlobalDispatch\<WlSubcompositor, ()\> für DesktopState** 10  
  * fn bind(state: \&mut Self, handle: \&DisplayHandle, client: \&Client, resource: New\<WlSubcompositor\>, global\_data: &(), data\_init: \&mut DataInit\<'\_, Self\>): Wird aufgerufen, wenn ein Client an wl\_subcompositor bindet.  
    * **Schritt 1**: Protokollieren: tracing::info\!(client\_id \=?client.id(), resource\_id \=?resource.id(), "Client bindet an wl\_subcompositor");  
    * **Schritt 2**: data\_init.init(resource, ());  
    * Smithays CompositorState handhabt auch das globale wl\_subcompositor-Objekt intern, wenn CompositorState::new() aufgerufen wird.10

#### **2\. Datei: surface\_management.rs**

* **Zweck**: Definiert SurfaceData und zugehörige Hilfsfunktionen für die Verwaltung von Wayland-Oberflächen.  
* **Struktur: SurfaceData**  
  * Diese Struktur wird in der UserDataMap jeder WlSurface gespeichert.1  
  * Felder:  
    * pub id: uuid::Uuid (Generiert bei Erstellung, für internes Tracking, benötigt uuid-Crate mit v4- und serde-Features 14).  
    * pub role: Option\<String\> (Speichert die via give\_role zugewiesene Rolle 10).  
    * pub client\_id: wayland\_server::backend::ClientId (ID des Clients, dem die Oberfläche gehört).  
    * pub current\_buffer: Option\<wl\_buffer::WlBuffer\> (Der aktuell angehängte und committete Puffer).  
    * pub pending\_buffer: Option\<wl\_buffer::WlBuffer\> (Puffer angehängt, aber noch nicht committet).  
    * pub texture\_id: Option\<Box\<dyn RenderableTexture\>\> (Handle zur gerenderten Textur; Typ abhängig von Renderer-Abstraktion, Box\<dyn...\> für dynamische Dispatch). Muss Send \+ Sync sein, wenn SurfaceData in Arc\<Mutex\<\>\> ist.  
    * pub last\_commit\_serial: smithay::utils::Serial (Serial des letzten Commits).  
    * pub damage\_regions\_buffer\_coords: Vec\<smithay::utils::Rectangle\<i32, smithay::utils::Buffer\>\> (Akkumulierter Schaden seit dem letzten Frame, in Pufferkoordinaten).  
    * pub opaque\_region: Option\<smithay::utils::Region\<smithay::utils::Logical\>\> (Wie vom Client gesetzt).  
    * pub input\_region: Option\<smithay::utils::Region\<smithay::utils::Logical\>\> (Wie vom Client gesetzt).  
    * pub user\_data\_ext: UserDataMap (Für weitere Erweiterbarkeit durch andere Module, z.B. XDG-Shell-Daten).  
    * pub parent: Option\<wayland\_server::Weak\<wl\_surface::WlSurface\>\>  
    * pub children: Vec\<wayland\_server::Weak\<wl\_surface::WlSurface\>\>  
    * pub pre\_commit\_hooks: Vec\<Box\<dyn FnMut(\&mut DesktopState, \&wl\_surface::WlSurface) \+ Send \+ Sync\>\>  
    * pub post\_commit\_hooks: Vec\<Box\<dyn FnMut(\&mut DesktopState, \&wl\_surface::WlSurface) \+ Send \+ Sync\>\>  
    * pub destruction\_hooks: Vec\<Box\<dyn FnOnce(\&mut DesktopState, \&wl\_surface::WlSurface) \+ Send \+ Sync\>\>  
  * Methoden:  
    * pub fn new(client\_id: wayland\_server::backend::ClientId) \-\> Self  
    * pub fn set\_role(\&mut self, role: \&str) \-\> Result\<(), SurfaceRoleError\> (Fehler, wenn Rolle bereits gesetzt).  
    * pub fn get\_role(\&self) \-\> Option\<\&String\>  
    * pub fn attach\_buffer(\&mut self, buffer: Option\<wl\_buffer::WlBuffer\>, serial: smithay::utils::Serial)  
    * pub fn commit\_buffer(\&mut self) (Verschiebt pending\_buffer zu current\_buffer, löscht pending\_buffer).  
    * pub fn add\_damage\_buffer\_coords(\&mut self, damage: smithay::utils::Rectangle\<i32, smithay::utils::Buffer\>)  
    * pub fn take\_damage\_buffer\_coords(\&mut self) \-\> Vec\<smithay::utils::Rectangle\<i32, smithay::utils::Buffer\>\>  
  * **Tabelle: SurfaceData-Felder**

| Feldname | Rust-Typ | Initialwert (Beispiel) | Mutabilität | Beschreibung | Invarianten |
| :---- | :---- | :---- | :---- | :---- | :---- |
| id | uuid::Uuid | Uuid::new\_v4() | immutable (nach Init) | Eindeutiger interner Identifikator. | Muss eindeutig sein. |
| role | Option\<String\> | None | mutable (einmalig setzbar) | Zugewiesene Rolle der Oberfläche (z.B. "toplevel"). | Kann nur einmal gesetzt werden. |
| client\_id | wayland\_server::backend::ClientId | Parameter des Konstruktors | immutable | ID des besitzenden Clients. | \- |
| current\_buffer | Option\<wl\_buffer::WlBuffer\> | None | mutable | Aktuell dargestellter Puffer. | \- |
| pending\_buffer | Option\<wl\_buffer::WlBuffer\> | None | mutable | Für den nächsten Commit angehängter Puffer. | \- |
| texture\_id | Option\<Box\<dyn RenderableTexture\>\> | None | mutable | Handle zur gerenderten Textur im Renderer. | Muss mit current\_buffer synchron sein. |
| last\_commit\_serial | smithay::utils::Serial | Serial::INITIAL | mutable | Serial des letzten erfolgreichen Commits. | \- |
| damage\_regions\_buffer\_coords | Vec\<Rectangle\<i32, Buffer\>\> | vec\! | mutable | Regionen des Puffers, die sich seit dem letzten Frame geändert haben. | Koordinaten relativ zum Puffer. |
| opaque\_region | Option\<Region\<Logical\>\> | None | mutable | Vom Client definierte undurchsichtige Region. | Koordinaten in logischen Einheiten. |
| input\_region | Option\<Region\<Logical\>\> | None | mutable | Vom Client definierte Eingaberegion. | Koordinaten in logischen Einheiten. |
| user\_data\_ext | UserDataMap | UserDataMap::new() | mutable | Zusätzliche benutzerspezifische Daten. | \- |
| parent | Option\<Weak\<WlSurface\>\> | None | mutable | Schwache Referenz auf die Elternoberfläche (für Subsurfaces). | \- |
| children | Vec\<Weak\<WlSurface\>\> | vec\! | mutable | Schwache Referenzen auf Kindoberflächen. | \- |
| pre\_commit\_hooks | Vec\<Box\<dyn FnMut(\&mut DesktopState, \&WlSurface) \+ Send \+ Sync\>\> | vec\! | mutable | Callbacks vor dem Commit. | \- |
| post\_commit\_hooks | Vec\<Box\<dyn FnMut(\&mut DesktopState, \&WlSurface) \+ Send \+ Sync\>\> | vec\! | mutable | Callbacks nach dem Commit. | \- |
| destruction\_hooks | Vec\<Box\<dyn FnOnce(\&mut DesktopState, \&WlSurface) \+ Send \+ Sync\>\> | vec\! | mutable | Callbacks bei Zerstörung. | \- |

\*Begründung für den Wert dieser Tabelle:\* Diese Tabelle bietet eine klare, strukturierte Definition aller Zustände, die mit einer Wayland-Oberfläche verbunden sind. Dies ist für Entwickler unerlässlich, um deren Lebenszyklus und Eigenschaften zu verstehen. Die Unterscheidung zwischen Puffer- und Logikkoordinaten sowie die explizite Auflistung von Hooks und Regionen sind für eine präzise Implementierung entscheidend.

* **Fehler-Enum: SurfaceRoleError** (in compositor\_state.rs oder einer gemeinsamen error.rs definiert)  
  * \#  
  * Varianten:  
    * \# RoleAlreadySet { existing\_role: String, new\_role: String }  
* **Funktionen:**  
  * pub fn get\_surface\_data(surface: \&WlSurface) \-\> Option\<Arc\<Mutex\<SurfaceData\>\>\>: Ruft SurfaceData über surface.data\_map().get::\<Arc\<Mutex\<SurfaceData\>\>\>().cloned() ab.  
  * pub fn with\_surface\_data\<F, R\>(surface: \&WlSurface, f: F) \-\> Result\<R, CompositorCoreError\> where F: FnOnce(\&mut SurfaceData) \-\> R: Kapselt das Locken und Entsperren des Mutex für SurfaceData.  
    Rust  
    // Beispielimplementierung  
    pub fn with\_surface\_data\<F, R\>(  
        surface: \&WlSurface,  
        callback: F,  
    ) \-\> Result\<R, CompositorCoreError\>  
    where  
        F: FnOnce(\&mut SurfaceData) \-\> R,  
    {  
        let data\_map\_guard \= surface  
           .data\_map()  
           .get::\<Arc\<Mutex\<SurfaceData\>\>\>()  
           .ok\_or\_else(|| CompositorCoreError::SurfaceDataMissing(surface.clone()))?  
           .clone(); // Klonen des Arc, um den Borrow von data\_map() freizugeben

        let mut surface\_data\_guard \= data\_map\_guard.lock();  
        Ok(callback(\&mut \*surface\_data\_guard))  
    }

  * pub fn give\_surface\_role(surface: \&WlSurface, role: &'static str) \-\> Result\<(), SurfaceRoleError\>: Verwendet intern smithay::wayland::compositor::give\_role(surface, role). 10  
  * pub fn get\_surface\_role(surface: \&WlSurface) \-\> Option\<String\>: Verwendet intern smithay::wayland::compositor::get\_role(surface).map(String::from). 10

#### **3\. Datei: global\_objects.rs**

* **Zweck**: Zentralisiert die Erstellung der Kern-Wayland-Globals, die vom system::compositor::core-Modul verwaltet werden.  
* **Funktion: pub fn create\_core\_compositor\_globals(display\_handle: \&DisplayHandle, state: \&mut DesktopState)**  
  * **Schritt 1**: Erstellen von CompositorState: let compositor\_state \= CompositorState::new::\<DesktopState\>(display\_handle);.10  
  * Speichern von compositor\_state in state.compositor\_state.  
  * Dies registriert intern die Globals wl\_compositor (Version 6\) und wl\_subcompositor (Version 1).10  
  * Protokollieren der Erstellung dieser Globals: tracing::info\!("wl\_compositor (v6) und wl\_subcompositor (v1) Globals erstellt.");

### **C. Submodul 2: SHM-Pufferbehandlung (system::compositor::shm)**

Dieses Submodul implementiert die Unterstützung für wl\_shm, wodurch Clients Shared-Memory-Puffer mit dem Compositor teilen können.

#### **1\. Datei: shm\_state.rs**

* **Zweck**: Verwaltet das wl\_shm-Global und handhabt die Erstellung und den Zugriff auf SHM-Puffer.  
* **Struktur: ShmError**  
  * \#  
  * Varianten:  
    * \# PoolCreationFailed(String)  
    * \# BufferCreationFailed(String)  
    * \# InvalidFormat(wl\_shm::Format)  
    * \# AccessError(\#\[from\] smithay::wayland::shm::BufferAccessError)  
  * **Tabelle: ShmError-Varianten**

| Variantenname | Felder | \#\[error("...")\] Nachricht |
| :---- | :---- | :---- |
| PoolCreationFailed | (String) | "Erstellung des SHM-Pools fehlgeschlagen: {0}" |
| BufferCreationFailed | (String) | "Erstellung des SHM-Puffers fehlgeschlagen: {0}" |
| InvalidFormat | (wl\_shm::Format) | "Ungültiges SHM-Format: {0:?}" |
| AccessError | (\#\[from\] smithay::wayland::shm::BufferAccessError) | "Fehler beim Zugriff auf SHM-Puffer: {0}" |

\*Begründung für den Wert dieser Tabelle:\* Spezifische Fehler für SHM-Operationen helfen bei der Diagnose von Client-Problemen oder internen Compositor-Problemen im Zusammenhang mit Shared Memory.

* **Struktur: DesktopState (Teilweise \- Fokus auf SHM-Aspekte)**  
  * Felder:  
    * shm\_state: ShmState (aus smithay::wayland::shm) 17  
    * shm\_global: GlobalId (um das Global am Leben zu erhalten)  
* **Implementierung: ShmHandler für DesktopState** 17  
  * fn shm\_state(\&self) \-\> \&ShmState: Gibt \&self.shm\_state zurück.  
* **Implementierung: BufferHandler für DesktopState** 17  
  * fn buffer\_destroyed(\&mut self, buffer: \&wl\_buffer::WlBuffer):  
    * **Schritt 1**: Protokollieren der Pufferzerstörung: tracing::debug\!(buffer\_id \=?buffer.id(), "SHM WlBuffer zerstört");  
    * **Schritt 2**: Das Rendering-Backend benachrichtigen, dass dieser Puffer nicht mehr gültig ist und alle zugehörigen GPU-Ressourcen freigegeben werden können. Dies erfordert eine Schnittstelle zum Renderer (Details später).  
    * **Schritt 3**: Wenn ein interner Zustand diesen Puffer direkt verfolgt (z.B. in einem Cache oder einer Liste aktiver Puffer für eine Oberfläche), entfernen Sie ihn. Dies geschieht oft durch Iterieren über alle SurfaceData-Instanzen und Setzen von current\_buffer/pending\_buffer auf None, wenn sie mit dem zerstörten Puffer übereinstimmen.  
  * Die Trait BufferHandler ist nicht spezifisch für SHM-Puffer, sondern gilt für alle wl\_buffer-Instanzen. Das bedeutet, dass die Logik in buffer\_destroyed robust genug sein muss, um Puffer aus verschiedenen Quellen (SHM, zukünftig DMABUF) zu handhaben. Wenn ein Client einen wl\_buffer erstellt (z.B. über wl\_shm\_pool.create\_buffer) und diesen an eine WlSurface anhängt und committet, könnte der CompositorHandler::commit diesen WlBuffer in SurfaceData speichern und seinen Inhalt möglicherweise auf die GPU hochladen, wodurch eine Textur-ID erhalten wird. Wenn der Client später den wl\_buffer freigibt, erkennt Smithay dies und ruft BufferHandler::buffer\_destroyed auf. Die Implementierung muss dann herausfinden, wo dieser WlBuffer verwendet wurde (z.B. in SurfaceData für eine beliebige Oberfläche) und zugehörige Ressourcen (wie die GPU-Textur) bereinigen. SurfaceData muss daher WlBuffer korrekt verfolgen, und die Renderer-Abstraktion muss eine Möglichkeit bieten, Texturen freizugeben, die mit einem WlBuffer oder seiner abgeleiteten Textur-ID verbunden sind.  
* **Implementierung: GlobalDispatch\<WlShm, ()\> für DesktopState** 13  
  * fn bind(state: \&mut Self, handle: \&DisplayHandle, client: \&Client, resource: New\<WlShm\>, global\_data: &(), data\_init: \&mut DataInit\<'\_, Self\>):  
    * **Schritt 1**: Protokollieren der wl\_shm-Bindung: tracing::info\!(client\_id \=?client.id(), resource\_id \=?resource.id(), "Client bindet an wl\_shm");  
    * **Schritt 2**: data\_init.init(resource, ());  
    * Smithays ShmState handhabt das Senden der format-Ereignisse beim Binden.16 Die unterstützten Formate werden bei der Initialisierung von ShmState festgelegt.  
* **Funktion: pub fn create\_shm\_global(display\_handle: \&DisplayHandle, state: \&mut DesktopState)**  
  * **Schritt 1**: Definieren der unterstützten SHM-Formate (zusätzlich zu den standardmäßigen ARGB8888, XRGB8888). Gemäß Gesamtspezifikation sind vorerst keine weiteren spezifischen Formate erforderlich. let additional\_formats: Vec\<wl\_shm::Format\> \= vec\!;  
  * **Schritt 2**: let shm\_state \= ShmState::new::\<DesktopState\>(display\_handle, additional\_formats.clone()); (Smithays ShmState::new erwartet \&DisplayHandle und Vec\<Format\>. Die Logger-Parameter sind in neueren Smithay-Versionen oft implizit durch tracing.).17  
  * **Schritt 3**: let shm\_global \= shm\_state.global().clone(); (Die global()-Methode gibt eine GlobalId zurück, die geklont werden kann, um das Global am Leben zu erhalten).  
  * Speichern von shm\_state und shm\_global in state.  
  * Protokollieren der Erstellung des SHM-Globals und der unterstützten Formate (einschließlich der Standardformate): tracing::info\!("wl\_shm Global erstellt. Unterstützte zusätzliche Formate: {:?}. Standardformate ARGB8888 und XRGB8888 sind immer verfügbar.", additional\_formats);

#### **2\. Datei: shm\_buffer\_access.rs**

* **Zweck**: Bietet sicheren Zugriff auf Inhalte von SHM-Puffern.  
* **Funktion: pub fn with\_shm\_buffer\_contents\<F, T, E\>(buffer: \&wl\_buffer::WlBuffer, callback: F) \-\> Result\<T, ShmError\>** wobei F: FnOnce(\*const u8, usize, \&smithay::wayland::shm::BufferData) \-\> Result\<T, E\>, E: Into\<ShmError\>. (Angepasst an Smithays with\_buffer\_contents, das möglicherweise einen anderen Fehlertyp oder eine andere Callback-Signatur hat). 17  
  * **Schritt 1**: Intern smithay::wayland::shm::with\_buffer\_contents(buffer, |ptr, len, data| {... }) verwenden.  
  * **Schritt 2**: Innerhalb des Smithay-Callbacks den bereitgestellten callback(ptr, len, data) aufrufen.  
  * **Schritt 3**: BufferAccessError von Smithay in ShmError::AccessError umwandeln oder den Fehler von callback mittels .map\_err(Into::into) propagieren.  
  * **Sicherheitshinweis**: Der ptr ist nur für die Dauer des Callbacks gültig. Auf die Daten darf außerhalb dieses Bereichs nicht zugegriffen werden. Diese Funktion kapselt die Unsicherheit der Zeiger-Dereferenzierung.  
* **Wertobjekt: ShmBufferView** (optional, falls direkter, langlebiger Zugriff benötigt wird, obwohl dies aus Sicherheitsgründen im Allgemeinen nicht empfohlen wird; Callback-basierter Zugriff ist vorzuziehen)  
  * pub id: uuid::Uuid  
  * pub data: Arc\<Vec\<u8\>\> (erfordert das Kopieren des Puffers, um die Lebensdauer zu verwalten).  
  * pub metadata: smithay::wayland::shm::BufferData (aus smithay::wayland::shm).  
  * Methoden: pub fn width(\&self) \-\> i32, pub fn height(\&self) \-\> i32, pub fn stride(\&self) \-\> i32, pub fn format(\&self) \-\> wl\_shm::Format.

### **D. Submodul 3: XDG-Shell-Integration (system::compositor::xdg\_shell)**

Dieses Submodul implementiert das xdg\_shell-Protokoll zur Verwaltung moderner Desktop-Fenster (Toplevels und Popups). Das xdg\_shell-Protokoll ist komplex und umfasst mehrere interagierende Objekte (xdg\_wm\_base, xdg\_surface, xdg\_toplevel, xdg\_popup, xdg\_positioner). Smithays XdgShellState und XdgShellHandler abstrahieren einen Großteil dieser Komplexität, aber die Handler-Methoden erfordern dennoch eine signifikante Logik.7 Das Protokoll beinhaltet eine Zustandsmaschine für Oberflächen (z.B. initiale Konfiguration, ack\_configure, nachfolgende Konfigurationen).19 Anfragen wie set\_title, set\_app\_id, set\_maximized, move, resize müssen verarbeitet werden und führen oft zu neuen configure-Ereignissen, die an den Client gesendet werden.19 Popups haben eine komplizierte Positionierungslogik basierend auf xdg\_positioner.7 Daher werden die XdgShellHandler-Methoden in DesktopState umfangreich sein. Sie müssen Oberflächenzustände korrekt verwalten, mit der Fensterverwaltungsrichtlinie der Domänenschicht interagieren (hier nicht detailliert, aber ein Schnittstellenpunkt) und korrekte Wayland-Ereignisse an Clients senden. Eine robuste Fehlerbehandlung und Zustandsvalidierung sind bei der Implementierung von xdg\_shell von größter Bedeutung, um Abstürze des Compositors oder fehlverhaltende Client-Fenster zu verhindern. Smithays Zustandsverfolgung (z.B. SurfaceCachedState, ToplevelSurfaceData) hilft dabei, aber die Logik muss sie korrekt verwenden.7

#### **1\. Datei: xdg\_shell\_state.rs**

* **Zweck**: Verwaltet das xdg\_wm\_base-Global und die zugehörigen XDG-Oberflächenzustände.  
* **Struktur: XdgShellError**  
  * \#  
  * Varianten:  
    * \# InvalidSurfaceRole  
    * \# WindowHandlingError(uuid::Uuid)  
    * \#\[error("Fehler bei der Popup-Positionierung.")\] PopupPositioningError  
    * \# InvalidAckConfigureSerial(smithay::utils::Serial)  
    * \# ToplevelNotFound(uuid::Uuid)  
    * \# PopupNotFound(uuid::Uuid)  
  * **Tabelle: XdgShellError-Varianten** (Analog zu vorherigen Fehlertabellen)  
* **Struktur: DesktopState (Teilweise \- Fokus auf XDG-Shell-Aspekte)**  
  * Felder:  
    * xdg\_shell\_state: XdgShellState (aus smithay::wayland::shell::xdg) 7  
    * xdg\_shell\_global: GlobalId  
    * toplevels: std::collections::HashMap\<WlSurface, Arc\<Mutex\<ManagedToplevel\>\>\> (oder eine andere geeignete Struktur zur Verwaltung von ManagedToplevel-Instanzen, indiziert durch WlSurface oder eine interne ID).  
    * popups: std::collections::HashMap\<WlSurface, Arc\<Mutex\<ManagedPopup\>\>\>  
* **Implementierung: XdgShellHandler für DesktopState** 7  
  * fn xdg\_shell\_state(\&mut self) \-\> \&mut XdgShellState: Gibt \&mut self.xdg\_shell\_state zurück.  
  * Die Implementierung der einzelnen XdgShellHandler-Methoden wird in xdg\_handlers.rs detailliert.  
* **Implementierung: GlobalDispatch\<XdgWmBase, GlobalId\> für DesktopState** 7  
  * fn bind(state: \&mut Self, handle: \&DisplayHandle, client: \&Client, resource: New\<XdgWmBase\>, global\_data: \&GlobalId, data\_init: \&mut DataInit\<'\_, Self\>):  
    * **Schritt 1**: Protokollieren der xdg\_wm\_base-Bindung: tracing::info\!(client\_id \=?client.id(), resource\_id \=?resource.id(), "Client bindet an xdg\_wm\_base");  
    * **Schritt 2**: let shell\_client\_user\_data \= state.xdg\_shell\_state.new\_client(client); (Smithay's new\_client gibt ShellClientUserData zurück, das für die Initialisierung des XdgWmBase-Ressourcen-Userdatas verwendet werden kann). 7  
    * **Schritt 3**: data\_init.init(resource, shell\_client\_user\_data); (Assoziieren der ShellClientUserData mit der xdg\_wm\_base-Ressource).  
    * Das XdgWmBase-Global selbst sendet ein ping-Ereignis, wenn der Client nicht rechtzeitig mit pong antwortet; Smithays XdgShellState handhabt dies.7  
* **Funktion: pub fn create\_xdg\_shell\_global(display\_handle: \&DisplayHandle, state: \&mut DesktopState)**  
  * **Schritt 1**: let xdg\_shell\_state \= XdgShellState::new::\<DesktopState\>(display\_handle);.7  
  * **Schritt 2**: let xdg\_shell\_global \= xdg\_shell\_state.global().clone(); (Die global()-Methode von XdgShellState gibt die GlobalId des xdg\_wm\_base-Globals zurück).  
  * Speichern von xdg\_shell\_state und xdg\_shell\_global in state.  
  * Protokollieren der Erstellung des XDG-Shell-Globals: tracing::info\!("xdg\_wm\_base Global erstellt.");

#### **2\. Datei: toplevel\_management.rs**

* **Zweck**: Definiert Datenstrukturen und Logik, die spezifisch für XDG-Toplevel-Fenster sind.  
* **Struktur: ManagedToplevel**  
  * Diese Struktur kapselt eine smithay::wayland::shell::xdg::ToplevelSurface und fügt anwendungsspezifische Zustände und Logik hinzu.  
  * Felder:  
    * pub id: uuid::Uuid (Eindeutiger interner Identifikator).  
    * pub surface\_handle: ToplevelSurface (Das Smithay-Handle zur XDG-Toplevel-Oberfläche).7  
    * pub wl\_surface: WlSurface (Die zugrundeliegende WlSurface).  
    * pub app\_id: Option\<String\>  
    * pub title: Option\<String\>  
    * pub current\_state: ToplevelWindowState (z.B. maximiert, Vollbild, aktiv, Größe).  
    * pub pending\_state: ToplevelWindowState (Für den nächsten Configure-Zyklus).  
    * pub window\_geometry: smithay::utils::Rectangle\<i32, smithay::utils::Logical\> (Aktuelle Fenstergeometrie).  
    * pub min\_size: Option\<smithay::utils::Size\<i32, smithay::utils::Logical\>\>  
    * pub max\_size: Option\<smithay::utils::Size\<i32, smithay::utils::Logical\>\>  
    * pub parent: Option\<wayland\_server::Weak\<WlSurface\>\> (Für transiente Fenster).  
    * pub client\_provides\_decorations: bool (Abgeleitet aus Interaktion mit xdg-decoration).  
    * pub last\_configure\_serial: Option\<smithay::utils::Serial\>  
    * pub acked\_configure\_serial: Option\<smithay::utils::Serial\>  
  * Methoden:  
    * pub fn new(surface\_handle: ToplevelSurface, wl\_surface: WlSurface) \-\> Self  
    * pub fn send\_configure(\&mut self): Bereitet einen xdg\_toplevel.configure und xdg\_surface.configure vor und sendet ihn basierend auf dem pending\_state. Aktualisiert last\_configure\_serial.  
    * pub fn ack\_configure(\&mut self, serial: smithay::utils::Serial): Verarbeitet ein ack\_configure vom Client.  
    * Methoden zum Setzen von Zuständen im pending\_state (z.B. set\_maximized\_pending(bool)).  
* **Struktur: ToplevelWindowState**  
  * Felder:  
    * pub size: Option\<smithay::utils::Size\<i32, smithay::utils::Logical\>\>  
    * pub maximized: bool  
    * pub fullscreen: bool  
    * pub resizing: bool  
    * pub activated: bool  
    * pub suspended: bool (z.B. wenn minimiert oder nicht sichtbar)  
    * pub decorations: smithay::wayland::shell::xdg::decoration::XdgToplevelDecorationMode (Standard: ClientSide)  
* **Struktur: ToplevelSurfaceUserData** (Wird in WlSurface::data\_map() gespeichert, um auf ManagedToplevel zu verlinken)  
  * pub managed\_toplevel\_id: uuid::Uuid  
* **Tabelle: ManagedToplevel-Felder** (Analog zu SurfaceData-Felder-Tabelle)  
* **Tabelle: ToplevelWindowState-Felder** (Analog zu SurfaceData-Felder-Tabelle)

#### **3\. Datei: popup\_management.rs**

* **Zweck**: Definiert Datenstrukturen und Logik, die spezifisch für XDG-Popup-Fenster sind.  
* **Struktur: ManagedPopup**  
  * Kapselt eine smithay::wayland::shell::xdg::PopupSurface.  
  * Felder:  
    * pub id: uuid::Uuid  
    * pub surface\_handle: PopupSurface 7  
    * pub wl\_surface: WlSurface  
    * pub parent\_wl\_surface: wayland\_server::Weak\<WlSurface\> (Eltern-WlSurface, nicht unbedingt ein Toplevel).  
    * pub positioner\_state: smithay::wayland::shell::xdg::PositionerState 7  
    * pub current\_geometry: smithay::utils::Rectangle\<i32, smithay::utils::Logical\> (Berechnet aus Positioner und Elterngröße).  
    * pub last\_configure\_serial: Option\<smithay::utils::Serial\>  
    * pub acked\_configure\_serial: Option\<smithay::utils::Serial\>  
  * Methoden:  
    * pub fn new(surface\_handle: PopupSurface, wl\_surface: WlSurface, parent\_wl\_surface: WlSurface, positioner: PositionerState) \-\> Self  
    * pub fn send\_configure(\&mut self): Sendet xdg\_popup.configure und xdg\_surface.configure.  
    * pub fn ack\_configure(\&mut self, serial: smithay::utils::Serial)  
    * pub fn calculate\_geometry(\&self) \-\> smithay::utils::Rectangle\<i32, smithay::utils::Logical\>: Berechnet die Popup-Geometrie basierend auf positioner\_state und der Geometrie der Elternoberfläche.  
* **Struktur: PopupSurfaceUserData** (Wird in WlSurface::data\_map() gespeichert)  
  * pub managed\_popup\_id: uuid::Uuid  
* **Tabelle: ManagedPopup-Felder** (Analog zu SurfaceData-Felder-Tabelle)

#### **4\. Datei: xdg\_handlers.rs**

* **Zweck**: Detaillierte Implementierung der XdgShellHandler-Methoden für DesktopState.  
* **Implementierung XdgShellHandler für DesktopState:**  
  * fn new\_toplevel(\&mut self, surface: ToplevelSurface) 7:  
    * **Schritt 1**: Protokollieren: tracing::info\!(surface \=?surface.wl\_surface().id(), "Neues XDG Toplevel erstellt.");  
    * **Schritt 2**: let wl\_surface \= surface.wl\_surface().clone();  
    * **Schritt 3**: Erstellen einer neuen ManagedToplevel-Instanz: let managed\_toplevel \= ManagedToplevel::new(surface, wl\_surface.clone());  
    * **Schritt 4**: Speichern der managed\_toplevel.id in ToplevelSurfaceUserData und Einfügen in wl\_surface.data\_map().  
    * **Schritt 5**: self.toplevels.insert(wl\_surface.clone(), Arc::new(Mutex::new(managed\_toplevel)));  
    * **Schritt 6**: Initiale Konfiguration senden. let mut guard \= self.toplevels.get(\&wl\_surface).unwrap().lock(); guard.send\_configure();  
  * fn new\_popup(\&mut self, surface: PopupSurface, positioner: PositionerState) 7:  
    * **Schritt 1**: Protokollieren.  
    * **Schritt 2**: let wl\_surface \= surface.wl\_surface().clone();  
    * **Schritt 3**: let parent\_wl\_surface \= surface.get\_parent\_surface().expect("Popup muss eine Elternoberfläche haben.");  
    * **Schritt 4**: Erstellen ManagedPopup: let managed\_popup \= ManagedPopup::new(surface, wl\_surface.clone(), parent\_wl\_surface, positioner);  
    * **Schritt 5**: PopupSurfaceUserData in wl\_surface.data\_map() speichern.  
    * **Schritt 6**: self.popups.insert(wl\_surface.clone(), Arc::new(Mutex::new(managed\_popup)));  
    * **Schritt 7**: Initiale Konfiguration senden. let mut guard \= self.popups.get(\&wl\_surface).unwrap().lock(); guard.send\_configure();  
  * fn map\_toplevel(\&mut self, surface: \&ToplevelSurface):  
    * **Schritt 1**: Protokollieren.  
    * **Schritt 2**: let wl\_surface \= surface.wl\_surface();  
    * **Schritt 3**: let managed\_toplevel\_arc \= self.toplevels.get(wl\_surface).ok\_or\_else(|| XdgShellError::WindowHandlingError(Default::default()))?;  
    * **Schritt 4**: let mut managed\_toplevel \= managed\_toplevel\_arc.lock();  
    * **Schritt 5**: Logik für das Mapping des Toplevels ausführen (z.B. Sichtbarkeit im Fenstermanager aktualisieren, initiale Position/Größe gemäß Richtlinien festlegen, falls nicht vom Client spezifiziert).  
    * **Schritt 6**: Ggf. send\_configure aufrufen, wenn sich der Zustand durch das Mapping ändert (z.B. Aktivierung).  
  * fn ack\_configure(\&mut self, surface: WlSurface, configure: smithay::wayland::shell::xdg::XdgSurfaceConfigure) 7:  
    * **Schritt 1**: Protokollieren: tracing::debug\!(surface \=?surface.id(), serial \=?configure.serial, "XDG Surface ack\_configure empfangen.");  
    * **Schritt 2**: Herausfinden, ob es sich um ein Toplevel oder Popup handelt, basierend auf get\_role(\&surface).  
    * **Schritt 3**: Entsprechendes ManagedToplevel oder ManagedPopup aus self.toplevels oder self.popups abrufen.  
    * **Schritt 4**: managed\_entity.lock().ack\_configure(configure.serial);  
    * **Schritt 5**: Wenn dies ein ack auf eine Größenänderung war, muss der Fenstermanager ggf. Layoutanpassungen vornehmen.  
  * fn toplevel\_request\_set\_title(\&mut self, surface: \&ToplevelSurface, title: String):  
    * **Schritt 1**: let wl\_surface \= surface.wl\_surface();  
    * **Schritt 2**: let managed\_toplevel\_arc \= self.toplevels.get(wl\_surface).ok\_or\_else(...)?;  
    * **Schritt 3**: let mut managed\_toplevel \= managed\_toplevel\_arc.lock();  
    * **Schritt 4**: managed\_toplevel.title \= Some(title);  
    * **Schritt 5**: UI-Schicht benachrichtigen (z.B. über Event-Bus), um Titelleisten zu aktualisieren.  
  * (Weitere Handler für set\_app\_id, set\_maximized, unset\_maximized, set\_fullscreen, unset\_fullscreen, set\_minimized, move, resize, show\_window\_menu, destroy\_toplevel, destroy\_popup, grab\_popup, reposition\_popup usw. müssen analog implementiert werden, wobei jeweils der Zustand des entsprechenden ManagedToplevel oder ManagedPopup aktualisiert und ggf. ein neuer configure-Zyklus ausgelöst oder mit dem Input-System interagiert wird.)  
  * **Tabelle: XdgShellHandler-Kernmethodenimplementierungsdetails** (Auszug)

| Methodenname | Protokoll-Anfrage/-Ereignis | Detaillierte Schritt-für-Schritt-Logik | Wichtige Smithay-Strukturen/-Funktionen | Interaktion mit Fenstermanagement-Richtlinie | Wayland-Ereignisse an Client gesendet |
| :---- | :---- | :---- | :---- | :---- | :---- |
| new\_toplevel | xdg\_wm\_base.get\_xdg\_surface, xdg\_surface.get\_toplevel | Siehe oben. | ToplevelSurface, WlSurface::data\_map(), ManagedToplevel::new(), send\_configure() | Initiale Platzierung/Größe könnte von Richtlinie beeinflusst werden. | xdg\_toplevel.configure, xdg\_surface.configure |
| ack\_configure | xdg\_surface.ack\_configure | Siehe oben. | XdgSurfaceConfigure, ManagedToplevel/Popup::ack\_configure() | Richtlinie könnte auf Zustandsänderung reagieren (z.B. nach Größenänderung). | Keine direkt, aber Voraussetzung für weitere configure. |
| toplevel\_request\_set\_maximized | xdg\_toplevel.set\_maximized | 1\. ManagedToplevel finden. 2\. pending\_state.maximized \= true;. 3\. pending\_state.size ggf. anpassen. 4\. send\_configure() aufrufen. | ToplevelSurface, ManagedToplevel, send\_configure() | Richtlinie entscheidet, ob Maximierung erlaubt ist und wie sie umgesetzt wird (z.B. Größe des Outputs). | xdg\_toplevel.configure (mit Maximierungsstatus und neuer Größe), xdg\_surface.configure. |
| move\_request | xdg\_toplevel.move | 1\. ManagedToplevel finden. 2\. Input-System benachrichtigen, einen interaktiven Move-Grab zu starten. 3\. Seat::start\_pointer\_grab mit speziellem Grab-Handler. | ToplevelSurface, WlSeat, Serial, Seat::start\_pointer\_grab | Richtlinie kann interaktiven Move beeinflussen (z.B. Snapping). | Keine direkt während des Moves, aber Fokus-Events. |

\*Begründung für den Wert dieser Tabelle:\* Dies ist das Kernstück der XDG-Shell-Funktionalität. Detaillierte Schritte stellen sicher, dass Entwickler die Protokolllogik korrekt implementieren, einschließlich Zustandsübergängen und Interaktionen mit anderen Systemteilen.

### **E. Submodul 4: Display und Ereignisschleife (system::compositor::display\_loop)**

Dieses Submodul ist verantwortlich für die Einrichtung des Wayland-Display-Kernobjekts und dessen Integration in die calloop-Ereignisschleife. Die calloop-Ereignisschleife ist zentral für die Architektur von Smithay. Alle Ereignisquellen (Wayland-Client-FDs, libinput-FDs, Timer, ggf. D-Bus-FDs) werden bei ihr registriert, und ihre Callbacks treiben die Logik des Compositors an.1 Das Display-Objekt von Smithay stellt einen Dateideskriptor bereit, den calloop auf Lesbarkeit überwachen kann.11 Wenn der Wayland-Display-FD lesbar wird, wird Display::dispatch\_clients aufgerufen, was wiederum die entsprechenden Dispatch-Trait-Implementierungen aufruft (oft an Handler wie CompositorHandler, XdgShellHandler delegiert).1 Dies bedeutet, dass der gesamte Compositor ereignisgesteuert und größtenteils single-threaded ist (innerhalb des Haupt-calloop-Dispatches). Asynchrone Operationen, die nicht zum calloop-Modell passen (z.B. könnten einige D-Bus-Bibliotheken tokio bevorzugen), müssten sorgfältig integriert werden, möglicherweise indem sie in einem separaten Thread ausgeführt werden und über Kanäle oder benutzerdefinierte Ereignisquellen mit calloop kommunizieren. Die Leistung der Ereignisschleife (Dispatch-Latenz, Callback-Ausführungszeit) ist entscheidend für die Reaktionsfähigkeit der Benutzeroberfläche. Langlaufende Operationen in Callbacks müssen vermieden werden.

#### **1\. Datei: display\_setup.rs**

* **Zweck**: Initialisiert das Wayland Display und DisplayHandle.  
* **Struktur: ClientData** (Assoziiert mit wayland\_server::Client)  
  * pub id: uuid::Uuid (Generiert mit Uuid::new\_v4()).  
  * pub client\_name: Option\<String\> (Kann über wl\_display.sync und wl\_callback.done gesetzt werden, falls der Client es bereitstellt, oder über andere Mittel).  
  * pub user\_data: UserDataMap (aus wayland\_server::backend::UserDataMap) zum Speichern von Client-spezifischen Zuständen wie ClientCompositorData, XdgShellClientData usw..1  
  * **Tabelle: ClientData-Felder** (Analog zu SurfaceData-Felder-Tabelle).  
* **Funktion (konzeptionell, da die Initialisierung Teil von DesktopState::new ist): fn init\_wayland\_display\_and\_loop() \-\> Result\<(Display\<DesktopState\>, EventLoop\<DesktopState\>), InitError\>**  
  * **Schritt 1**: let event\_loop: EventLoop\<DesktopState\> \= EventLoop::try\_new().map\_err(|e| InitError::EventLoopCreationFailed(e.to\_string()))?;.2  
  * **Schritt 2**: let display \= Display::\<DesktopState\>::new().map\_err(|e| InitError::WaylandDisplayCreationFailed(e.to\_string()))?;.11  
  * Der DisplayHandle und LoopHandle werden in DesktopState gespeichert.  
* **Fehler-Enum: InitError**  
  * \#  
  * Varianten:  
    * \#\[error("Erstellung der Wayland-Anzeige fehlgeschlagen: {0}")\] WaylandDisplayCreationFailed(String)  
    * \#\[error("Erstellung der Ereignisschleife fehlgeschlagen: {0}")\] EventLoopCreationFailed(String)

#### **2\. Datei: event\_loop\_integration.rs**

* **Zweck**: Integriert die Wayland-Anzeige in die calloop-Ereignisschleife.  
* **Funktion: pub fn register\_wayland\_source(loop\_handle: \&LoopHandle\<DesktopState\>, display\_handle: \&DisplayHandle, desktop\_state\_accessor: impl FnMut() \-\> Arc\<Mutex\<DesktopState\>\> \+ 'static) \-\> Result\<calloop::RegistrationToken, std::io::Error\>**  
  * Die Verwaltung des mutierbaren Zugriffs auf Display innerhalb des calloop-Callbacks, während DesktopState ebenfalls mutierbar ist, erfordert sorgfältige Überlegungen zu Ownership/Borrowing. Smithay-Beispiele strukturieren dies oft, indem Display und EventLoop als Top-Level-Variablen vorhanden sind und DesktopState mutierbar an dispatch und Callbacks übergeben wird. Wenn Display Teil von DesktopState ist, könnte dies eine temporäre Entnahme oder RefCell beinhalten, falls geteilt. Für diese Spezifikation wird angenommen, dass desktop\_state.wayland\_display zugänglich und mutierbar ist. Eine gängige Methode ist die Verwendung eines Arc\<Mutex\<DesktopState\>\>, das im Callback geklont und gelockt wird, um Zugriff auf den Zustand einschließlich des DisplayHandle zu erhalten, und dann display\_handle.dispatch\_clients() aufzurufen.  
  * **Schritt 1**: Dateideskriptor der Wayland-Anzeige abrufen: let fd \= display\_handle.get\_fd(); (Die genaue Methode zum Abrufen des FD kann von der wayland-backend-Version abhängen; display.backend().poll\_fd() ist eine gängige Methode, wenn man Zugriff auf das Display-Objekt hat, nicht nur den DisplayHandle. Für calloop wird ein AsFd-kompatibler Typ benötigt.)  
  * **Schritt 2**: Erstellen einer Generic\<FileDescriptor\>-Ereignisquelle für calloop. let source \= calloop::generic::Generic::from\_fd(fd, calloop::Interest::READ, calloop::Mode::Level);  
  * **Schritt 3**: Einfügen der Quelle in die Ereignisschleife:  
    Rust  
    loop\_handle.insert\_source(source, move |event, \_metadata, shared\_data: \&mut DesktopState| {  
        // shared\_data ist hier \&mut DesktopState  
        // Zugriff auf display\_handle erfolgt über shared\_data.display\_handle  
        match shared\_data.display\_handle.dispatch\_clients(shared\_data) {  
            Ok(dispatched\_count) \=\> {  
                if dispatched\_count \> 0 {  
                    if let Err(e) \= shared\_data.display\_handle.flush\_clients() {  
                        tracing::error\!("Fehler beim Flushen der Wayland-Clients: {}", e);  
                    }  
                }  
            },  
            Err(e) \=\> {  
                tracing::error\!("Fehler beim Dispatch der Wayland-Clients: {}", e);  
            }  
        }  
        Ok(calloop::PostAction::Continue)  
    })

  .2

  * **Schritt 4**: Regelmäßiger Aufruf von display\_handle.flush\_clients() in der Ereignisschleife (z.B. nachdem alle Ereignisquellen verarbeitet wurden oder auf einem Timer), um sicherzustellen, dass alle gepufferten Wayland-Nachrichten gesendet werden.11 Dies ist entscheidend für die Reaktionsfähigkeit.

### **F. Submodul 5: Renderer-Schnittstelle (system::compositor::renderer\_interface)**

Dieses Submodul definiert abstrakte Schnittstellen für Rendering-Operationen und entkoppelt so die Kernlogik des Compositors von spezifischen Rendering-Backends (DRM/GBM, Winit/EGL). Diese Abstraktion ist entscheidend für die Unterstützung mehrerer Rendering-Backends (z.B. für den Betrieb in einem verschachtelten Fenster während der Entwicklung vs. direkter Hardwarezugriff auf einem TTY) und für die Testbarkeit. Smithays Renderer-Trait und verwandte Konzepte (z.B. Frame, Texture, Import\*-Traits) bilden eine Grundlage für diese Abstraktion.23 Durch die Definition eigener, übergeordneter Traits hier kann die Schnittstelle auf die spezifischen Bedürfnisse der Rendering-Pipeline des Compositors zugeschnitten werden (z.B. Umgang mit Ebenen, Effekten, Cursorn). Die konkreten Implementierungen dieser Traits (in system::compositor::drm\_gbm\_renderer und system::compositor::winit\_renderer – Details in späteren Teilen) werden komplex und stark von den gewählten Grafik-APIs (EGL, OpenGL ES) abhängen. Die Schadensverfolgung (Damage Tracking) ist für effizientes Rendering unerlässlich und muss in diese Renderer-Schnittstellen integriert werden; der Renderer sollte nur beschädigte Bereiche von Oberflächen neu zeichnen.

#### **1\. Datei: abstraction.rs**

* **Zweck**: Definiert Traits für Rendering-Operationen.  
* **Trait: FrameRenderer**  
  * fn new(???) \-\> Result\<Self, RendererError\> (Parameter abhängig vom Backend: z.B. DRM-Gerät, EGL-Kontext).  
  * fn render\_frame\<'a, E: RenderElement\<'a\> \+ 'a\>(\&mut self, elements: impl IntoIterator\<Item \= &'a E\>, output\_geometry: smithay::utils::Rectangle\<i32, smithay::utils::Physical\>, output\_scale: f64) \-\> Result\<(), RendererError\>.  
  * fn present\_frame(\&mut self) \-\> Result\<(), RendererError\> (Handhabt Puffertausch/Page-Flipping).  
  * fn create\_texture\_from\_shm(\&mut self, buffer: \&wl\_buffer::WlBuffer) \-\> Result\<Box\<dyn RenderableTexture\>, RendererError\>.  
  * fn create\_texture\_from\_dmabuf(\&mut self, dmabuf\_attributes: \&smithay::backend::allocator::dmabuf::Dmabuf) \-\> Result\<Box\<dyn RenderableTexture\>, RendererError\> (DMABUF-Unterstützung für spätere Teile).  
  * fn screen\_size(\&self) \-\> smithay::utils::Size\<i32, smithay::utils::Physical\>.  
* **Trait: RenderableTexture** (pub trait RenderableTexture: Send \+ Sync \+ std::fmt::Debug)  
  * fn id(\&self) \-\> uuid::Uuid (Eindeutige ID für diese Texturressource).  
  * fn bind(\&self, slot: u32) \-\> Result\<(), RendererError\> (Für Shader-Nutzung).  
  * fn width\_px(\&self) \-\> u32.  
  * fn height\_px(\&self) \-\> u32.  
  * fn format(\&self) \-\> Option\<smithay::backend::renderer::utils::Format\>. (FourCC or similar)  
* **Enum: RenderElement\<'a\>** (Konzeptionell, Smithay hat smithay::backend::renderer::element::Element)  
  * Surface { surface\_id: uuid::Uuid, texture: Arc\<dyn RenderableTexture\>, geometry: smithay::utils::Rectangle\<i32, smithay::utils::Logical\>, damage\_surface\_coords: &'a }  
  * SolidColor { color: Color, geometry: smithay::utils::Rectangle\<i32, smithay::utils::Logical\> }  
  * Cursor { texture: Arc\<dyn RenderableTexture\>, position\_logical: smithay::utils::Point\<i32, smithay::utils::Logical\>, hotspot\_logical: smithay::utils::Point\<i32, smithay::utils::Logical\> }  
* **Struktur: Color**  
  * pub r: f32 (0.0 bis 1.0)  
  * pub g: f32 (0.0 bis 1.0)  
  * pub b: f32 (0.0 bis 1.0)  
  * pub a: f32 (0.0 bis 1.0)  
* **Fehler-Enum: RendererError**  
  * \#  
  * Varianten:  
    * \# ContextCreationFailed(String)  
    * \# ShaderCompilationFailed(String)  
    * \# TextureUploadFailed(String)  
    * \#\[error("Fehler beim Puffertausch/Present: {0}")\] BufferSwapFailed(String)  
    * \# InvalidBufferType(String)  
    * \# DrmError(String) (Platzhalter für spezifischere DRM-Fehler)  
    * \#\[error("EGL-Fehler: {0}")\] EglError(String) (Platzhalter für spezifischere EGL-Fehler)  
    * \# Generic(String)  
* **Tabelle: RendererError-Varianten** (Analog zu vorherigen Fehlertabellen)  
* **Tabelle: FrameRenderer-Trait-Methoden**

| Methodenname | Signatur | Beschreibung | Hauptverantwortlichkeiten |
| :---- | :---- | :---- | :---- |
| new | fn new(???) \-\> Result\<Self, RendererError\> | Konstruktor für den Renderer. Parameter sind backend-spezifisch. | Initialisierung des Rendering-Kontexts, Laden von Shadern, etc. |
| render\_frame | fn render\_frame\<'a, E: RenderElement\<'a\> \+ 'a\>(\&mut self, elements: impl IntoIterator\<Item \= &'a E\>, output\_geometry: Rectangle\<i32, Physical\>, output\_scale: f64) \-\> Result\<(), RendererError\> | Rendert einen einzelnen Frame, bestehend aus mehreren RenderElement-Instanzen. | Iterieren über Elemente, Setzen von Transformationsmatrizen, Ausführen von Zeichenbefehlen, Schadensoptimierung. |
| present\_frame | fn present\_frame(\&mut self) \-\> Result\<(), RendererError\> | Präsentiert den gerenderten Frame auf dem Bildschirm. | Puffertausch (z.B. eglSwapBuffers), Page-Flip bei DRM. |
| create\_texture\_from\_shm | fn create\_texture\_from\_shm(\&mut self, buffer: \&wl\_buffer::WlBuffer) \-\> Result\<Box\<dyn RenderableTexture\>, RendererError\> | Erstellt eine renderbare Textur aus einem SHM-Puffer. | Zugriff auf SHM-Daten, Hochladen auf GPU, Erstellung eines RenderableTexture-Objekts. |
| create\_texture\_from\_dmabuf | fn create\_texture\_from\_dmabuf(\&mut self, dmabuf: \&Dmabuf) \-\> Result\<Box\<dyn RenderableTexture\>, RendererError\> | Erstellt eine renderbare Textur aus einem DMABUF. | Importieren von DMABUF in den Grafikstack (EGL/OpenGL), Erstellung eines RenderableTexture-Objekts. |
| screen\_size | fn screen\_size(\&self) \-\> Size\<i32, Physical\> | Gibt die aktuelle Größe des Renderziels in physischen Pixeln zurück. | Abrufen der aktuellen Ausgabegröße. |

\*Begründung für den Wert dieser Tabelle:\* Diese Tabelle definiert den Vertrag für jedes Rendering-Backend und stellt sicher, dass der Kern-Compositor konsistent mit verschiedenen Renderern (z.B. DRM/GBM, Winit) interagieren kann.

* **Tabelle: RenderableTexture-Trait-Methoden**

| Methodenname | Signatur | Beschreibung |
| :---- | :---- | :---- |
| id | fn id(\&self) \-\> uuid::Uuid | Gibt eine eindeutige ID für die Texturressource zurück. |
| bind | fn bind(\&self, slot: u32) \-\> Result\<(), RendererError\> | Bindet die Textur an einen bestimmten Texturslot für die Verwendung in Shadern. |
| width\_px | fn width\_px(\&self) \-\> u32 | Gibt die Breite der Textur in Pixeln zurück. |
| height\_px | fn height\_px(\&self) \-\> u32 | Gibt die Höhe der Textur in Pixeln zurück. |
| format | fn format(\&self) \-\> Option\<smithay::backend::renderer::utils::Format\> | Gibt das Pixelformat der Textur zurück. |

\*Begründung für den Wert dieser Tabelle:\* Abstrahiert die Texturbehandlung, was für die Verwaltung von GPU-Ressourcen, die mit Client-Puffern verbunden sind, unerlässlich ist.

## **III. Entwicklungsmodul: system::input (Libinput-basierte Eingabeverarbeitung)**

### **A. Modulübersicht**

Dieses Modul ist für die gesamte Verarbeitung von Benutzereingaben zuständig. Es initialisiert und verwaltet Eingabegeräte mittels libinput, übersetzt rohe Eingabeereignisse in ein für den Compositor und Wayland-Clients verwendbares Format und handhabt das Seat-Management, den Eingabefokus sowie die Darstellung von Zeigern/Cursorn. Die Integration von libinput erfolgt über Smithays LibinputInputBackend, das libinput in die calloop-Ereignisschleife einbindet. Smithays SeatState und SeatHandler bieten übergeordnete Abstraktionen für das Seat- und Fokusmanagement.23  
Das Eingabesystem bildet einen kritischen Pfad für die Benutzerinteraktion. Latenz oder fehlerhafte Ereignisverarbeitung hier würden die Benutzererfahrung erheblich beeinträchtigen. Die Transformation von libinput-Ereignissen in Wayland-Ereignisse, einschließlich Koordinatentransformationen und Fokuslogik, muss präzise sein. libinput liefert Low-Level-Ereignisse 25, die vom Eingabe-Stack von Smithay (LibinputInputBackend, Seat, KeyboardHandle, PointerHandle) verarbeitet und Wayland-Konzepten zugeordnet werden.26 Der Fokus bestimmt, welcher Client Eingaben empfängt; eine fehlerhafte Fokuslogik führt dazu, dass Eingaben an das falsche Fenster gehen.26 Koordinatentransformationen sind erforderlich, wenn Oberflächen skaliert oder gedreht werden. Eine gründliche Prüfung der Eingabebehandlung über verschiedene Geräte, Layouts und Fokusszenarien hinweg ist unerlässlich. Das Design muss erweiterte Eingabefunktionen wie Gesten berücksichtigen (libinput unterstützt sie 27), was möglicherweise eine komplexere Ereignisinterpretation im SeatHandler oder dedizierte Gestenmodule erfordert.  
xkbcommon ist grundlegend für die korrekte Interpretation von Tastatureingaben (Keymaps, Layouts, Modifikatoren). Sein Zustand muss pro Tastaturgerät oder pro Seat verwaltet werden.30 Rohe Keycodes von libinput sind für Anwendungen nicht direkt verwendbar. xkbcommon übersetzt Keycodes basierend auf der aktiven Keymap und dem Modifikatorstatus in Keysyms (z.B. 'A', 'Enter', 'Shift\_L') und UTF-8-Zeichen.30 Die Methode KeyboardHandle::input von Smithay verwendet typischerweise xkbcommon::State::key\_get\_syms. Der Compositor muss die korrekte XKB-Keymap laden (oft aus der Systemkonfiguration oder den Benutzereinstellungen, anfänglich ggf. Standardwerte) und einen xkbcommon::State für jede Tastatur pflegen. Änderungen des Tastaturlayouts (z.B. Sprachwechsel) erfordern eine Aktualisierung des xkbcommon::State und eine Benachrichtigung der Clients (z.B. über wl\_keyboard.keymap und wl\_keyboard.modifiers).

### **B. Submodul 1: Seat-Management (system::input::seat\_manager)**

#### **1\. Datei: seat\_state.rs**

* **Zweck**: Definiert und verwaltet SeatState und SeatHandler für Eingabefokus und die Bekanntmachung von Fähigkeiten (Capabilities).  
* **Struktur: InputError**  
  * \#  
  * Varianten:  
    * \# SeatCreationFailed(String)  
    * \# CapabilityAdditionFailed { seat\_name: String, capability: String, source: Box\<dyn std::error::Error \+ Send \+ Sync\> }  
    * \# XkbConfigError(String) (Sollte spezifischer sein, z.B. KeymapCompilationFailed)  
    * \#\[error("Libinput-Fehler: {0}")\] LibinputError(String)  
    * \# SeatNotFound(String)  
    * \# KeyboardHandleNotFound(String)  
    * \# PointerHandleNotFound(String)  
    * \# TouchHandleNotFound(String)  
  * **Tabelle: InputError-Varianten** (Analog zu vorherigen Fehlertabellen)  
* **Struktur: DesktopState (Teilweise \- Fokus auf Seat-Aspekte)**  
  * Felder:  
    * seat\_state: SeatState\<Self\> (aus smithay::input::SeatState) 26  
    * seats: std::collections::HashMap\<String, Seat\<Self\>\> (Speichert aktive Seats, indiziert nach Namen, z.B. "seat0")  
    * active\_seat\_name: Option\<String\> (Name des aktuell primären Seats)  
    * keyboards: std::collections::HashMap\<String, keyboard::xkb\_config::XkbKeyboardData\> (XKB-Daten pro Tastatur, Schlüssel könnte Gerätename oder Seat-Name sein)  
* **Implementierung: SeatHandler für DesktopState** 26  
  * type KeyboardFocus \= WlSurface;  
  * type PointerFocus \= WlSurface;  
  * type TouchFocus \= WlSurface;  
  * fn seat\_state(\&mut self) \-\> \&mut SeatState\<Self\>: Gibt \&mut self.seat\_state zurück.  
  * fn focus\_changed(\&mut self, seat: \&Seat\<Self\>, focused: Option\<\&Self::KeyboardFocus\>): (Smithays focus\_changed ist generisch; hier wird angenommen, es wird für Tastaturfokus aufgerufen oder als allgemeine Benachrichtigung, dass sich *ein* Fokus geändert hat. Für Zeiger- und Touch-Fokus werden separate Logiken in den jeweiligen Event-Handlern oder durch PointerHandle::enter/leave benötigt.)  
    * **Schritt 1**: Protokollieren der Fokusänderung: tracing::debug\!(seat\_name \= %seat.name(), new\_focus \=?focused.map(|s| s.id()), "Tastaturfokus geändert.");  
    * **Schritt 2**: Tastatur-Handle abrufen: let keyboard \= seat.get\_keyboard().ok\_or\_else(|| InputError::KeyboardHandleNotFound(seat.name().to\_string()))?; (Fehlerbehandlung anpassen).  
    * **Schritt 3**: Alten Fokus ermitteln (z.B. aus self.keyboards.get\_mut(seat.name()).unwrap().focused\_surface).  
    * **Schritt 4**: Wenn focused Some(new\_surface\_ref) ist:  
      * Wenn sich der Fokus geändert hat, keyboard.leave() an die alte fokussierte Oberfläche senden.  
      * keyboard.enter(new\_surface\_ref, &, Serial::now(), seat.get\_keyboard\_modifiers\_state()); (Aktuelle gedrückte Tasten und Modifikatoren senden).  
      * self.keyboards.get\_mut(seat.name()).unwrap().focused\_surface \= Some(new\_surface\_ref.downgrade());  
      * Interne Fenstermanagement-Zustände aktualisieren.  
    * **Schritt 5**: Wenn focused None ist:  
      * keyboard.leave() an die alte fokussierte Oberfläche senden.  
      * self.keyboards.get\_mut(seat.name()).unwrap().focused\_surface \= None;  
      * Interne Fenstermanagement-Zustände löschen/aktualisieren.  
  * fn cursor\_image(\&mut self, seat: \&Seat\<Self\>, image: smithay::input::pointer::CursorImageStatus):  
    * **Schritt 1**: Protokollieren der Cursor-Bild-Anfrage: tracing::trace\!(seat\_name \= %seat.name(), image\_status \=?image, "Cursor-Bild-Anfrage.");  
    * **Schritt 2**: Basierend auf image:  
      * CursorImageStatus::Hidden: Cursor ausblenden. Renderer anweisen, ihn nicht zu zeichnen.  
      * CursorImageStatus::Surface(cursor\_surface): Ein Client hat einen benutzerdefinierten Cursor mittels wl\_pointer.set\_cursor gesetzt.  
        * SurfaceData für cursor\_surface abrufen.  
        * Prüfen, ob cursor\_surface die Rolle "cursor" hat (mittels get\_surface\_role(\&cursor\_surface) \== Some("cursor")). 10  
        * Wenn gültig, Puffer und Hotspot aus SurfaceData oder den SurfaceAttributes der cursor\_surface abrufen.  
        * Renderer anweisen, diese Oberfläche als Cursor zu zeichnen.  
      * CursorImageStatus::Named(name): Ein Client fordert einen thematisierten Cursor an (z.B. "left\_ptr").  
        * Eine Cursor-Theming-Bibliothek (z.B. wayland-cursor oder eine benutzerdefinierte Lösung) verwenden, um die passende Cursor-Textur basierend auf name und dem aktuellen Thema zu laden.  
        * Renderer anweisen, diesen thematisierten Cursor zu zeichnen.  
    * **Schritt 3**: Renderer mit der neuen Cursor-Textur/Sichtbarkeit und dem Hotspot aktualisieren.  
* **Tabelle: SeatHandler-Methodenimplementierungsdetails für DesktopState**

| Methodenname | Signatur | Detaillierte Schritt-für-Schritt-Logik | Wichtige Smithay-Strukturen/-Funktionen | Wayland-Ereignisse gesendet |
| :---- | :---- | :---- | :---- | :---- |
| seat\_state | fn seat\_state(\&mut self) \-\> \&mut SeatState\<Self\> | \&mut self.seat\_state zurückgeben. | SeatState | Keine |
| focus\_changed | fn focus\_changed(\&mut self, seat: \&Seat\<Self\>, focused: Option\<\&WlSurface\>) | Siehe oben. | Seat, WlSurface, KeyboardHandle::enter(), KeyboardHandle::leave() | wl\_keyboard.enter, wl\_keyboard.leave, wl\_keyboard.modifiers |
| cursor\_image | fn cursor\_image(\&mut self, seat: \&Seat\<Self\>, image: CursorImageStatus) | Siehe oben. | Seat, CursorImageStatus, WlSurface (für Cursor), Renderer-API | Keine direkt, aber beeinflusst Cursor-Darstellung. |

\*Begründung für den Wert dieser Tabelle:\* Definiert, wie der Compositor auf zentrale Seat-Ereignisse wie Fokusänderungen und Cursor-Aktualisierungen reagiert, was für die grundlegende Interaktivität unerlässlich ist.

* **Funktion: pub fn create\_seat(state: \&mut DesktopState, display\_handle: \&DisplayHandle, seat\_name: String) \-\> Result\<(), InputError\>**  
  * **Schritt 1**: let seat \= state.seat\_state.new\_wl\_seat(display\_handle, seat\_name.clone());.29  
  * **Schritt 2**: Hinzufügen von Fähigkeiten (normalerweise nachdem das libinput-Backend aktiv ist und Geräte bekannt sind):  
    * Tastatur:  
      * let xkb\_config \= keyboard::xkb\_config::XkbConfig { rules: None, model: None, layout: Some("us".into()), variant: None, options: None }; (Standardkonfiguration, anpassbar).  
      * let keyboard\_handle \= seat.add\_keyboard(xkb\_config, 200, 25).map\_err(|e| InputError::CapabilityAdditionFailed { seat\_name: seat\_name.clone(), capability: "keyboard".to\_string(), source: Box::new(e) })?;.26  
      * Erstellen und Speichern von XkbKeyboardData für diese Tastatur/diesen Seat in state.keyboards.  
    * Zeiger: let \_pointer\_handle \= seat.add\_pointer().map\_err(|e| InputError::CapabilityAdditionFailed { seat\_name: seat\_name.clone(), capability: "pointer".to\_string(), source: Box::new(e) })?;.26  
    * Touch: let \_touch\_handle \= seat.add\_touch().map\_err(|e| InputError::CapabilityAdditionFailed { seat\_name: seat\_name.clone(), capability: "touch".to\_string(), source: Box::new(e) })?;.26  
  * **Schritt 3**: Speichern des Seat-Objekts: state.seats.insert(seat\_name.clone(), seat);.  
  * **Schritt 4**: Wenn dies der erste/primäre Seat ist, state.active\_seat\_name \= Some(seat\_name);.  
  * Protokollieren der Seat-Erstellung und Fähigkeitserweiterung.  
  * Ok(()) zurückgeben.

### **C. Submodul 2: Libinput-Backend (system::input::libinput\_handler)**

#### **1\. Datei: backend\_config.rs**

* **Zweck**: Initialisiert und konfiguriert das LibinputInputBackend.  
* **Struktur: LibinputSessionInterface** (Wrapper für Session-Trait zur Bereitstellung von input::LibinputInterface) 25  
  * Felder: session\_signal: calloop::LoopSignal (oder ähnlicher Mechanismus, um Sitzungsänderungen an die Ereignisschleife zu signalisieren).  
  * Implementiert input::LibinputInterface zum Öffnen/Schließen eingeschränkter Geräte über ein Session-Objekt (z.B. smithay::backend::session::direct::DirectSession oder smithay::backend::session::logind::LogindSession – Details zum Sitzungsmanagement folgen in späteren Teilen, aber diese Schnittstelle wird jetzt benötigt).23  
* **Funktion: pub fn init\_libinput\_backend(event\_loop\_handle: \&LoopHandle\<DesktopState\>, session\_interface: LibinputSessionInterface) \-\> Result\<LibinputInputBackend, InputError\>**  
  * **Schritt 1**: Erstellen eines libinput::Libinput-Kontexts: let mut libinput\_context \= Libinput::new\_from\_path(session\_interface);.25 Die session\_interface wird von libinput zum Öffnen/Schließen von Gerätedateien verwendet.  
  * **Schritt 2**: Zuweisen eines Seats zum Kontext: libinput\_context.udev\_assign\_seat("seat0").map\_err(|e| InputError::LibinputError(format\!("Zuweisung zu udev seat0 fehlgeschlagen: {:?}", e)))?;.32  
  * **Schritt 3**: let libinput\_backend \= LibinputInputBackend::new(libinput\_context.into()); (Die into() Konvertierung ist möglicherweise nicht direkt, ggf. LibinputInputBackend::new(libinput\_context, logger\_oder\_tracing\_span))..25  
  * Rückgabe des libinput\_backend. Die Registrierung als Ereignisquelle erfolgt separat.

#### **2\. Datei: event\_dispatcher.rs**

* **Zweck**: Verarbeitet InputEvent\<LibinputInputBackend\> und leitet an spezifische Handler weiter.  
* **Funktion: pub fn process\_input\_event(desktop\_state: \&mut DesktopState, event: InputEvent\<LibinputInputBackend\>, seat\_name: \&str)** (Aufgerufen vom calloop-Callback)  
  * **Schritt 1**: Aktiven Seat abrufen: let seat \= desktop\_state.seats.get(seat\_name).ok\_or\_else(|| InputError::SeatNotFound(seat\_name.to\_string()))?; (Fehlerbehandlung anpassen).  
  * **Schritt 2**: match event {... } 27  
    * InputEvent::Keyboard { event }: keyboard::key\_event\_translator::handle\_keyboard\_key\_event(desktop\_state, seat, event, seat\_name);  
    * InputEvent::PointerMotion { event }: pointer::pointer\_event\_translator::handle\_pointer\_motion\_event(desktop\_state, seat, event);  
    * InputEvent::PointerMotionAbsolute { event }: pointer::pointer\_event\_translator::handle\_pointer\_motion\_absolute\_event(desktop\_state, seat, event);  
    * InputEvent::PointerButton { event }: pointer::pointer\_event\_translator::handle\_pointer\_button\_event(desktop\_state, seat, event);  
    * InputEvent::PointerAxis { event }: pointer::pointer\_event\_translator::handle\_pointer\_axis\_event(desktop\_state, seat, event);  
    * InputEvent::TouchDown { event }: touch::touch\_event\_translator::handle\_touch\_down\_event(desktop\_state, seat, event);  
    * InputEvent::TouchUp { event }: touch::touch\_event\_translator::handle\_touch\_up\_event(desktop\_state, seat, event);  
    * InputEvent::TouchMotion { event }: touch::touch\_event\_translator::handle\_touch\_motion\_event(desktop\_state, seat, event);  
    * InputEvent::TouchFrame { event }: touch::touch\_event\_translator::handle\_touch\_frame\_event(desktop\_state, seat);  
    * InputEvent::TouchCancel { event }: touch::touch\_event\_translator::handle\_touch\_cancel\_event(desktop\_state, seat);  
    * InputEvent::GesturePinchBegin/Update/End, InputEvent::GestureSwipeBegin/Update/End usw. 27: Anfänglich diese Ereignisse protokollieren: tracing::debug\!("Gestenereignis empfangen: {:?}", event);. Vollständige Gestenbehandlung ist komplex und könnte Teil einer späteren Spezifikationsphase sein.  
    * InputEvent::DeviceAdded { device }:  
      * Protokollieren der Gerätehinzufügung: tracing::info\!("Eingabegerät hinzugefügt: {} ({:?})", device.name(), device.id());  
      * Seat-Fähigkeiten aktualisieren, falls erforderlich (z.B. wenn eine Tastatur angeschlossen wurde und der Seat noch keine hatte). device.has\_capability(DeviceCapability::Keyboard) usw. prüfen.28  
    * InputEvent::DeviceRemoved { device }:  
      * Protokollieren der Geräteentfernung: tracing::info\!("Eingabegerät entfernt: {} ({:?})", device.name(), device.id());  
      * Seat-Fähigkeiten aktualisieren.  
    * Andere Ereignisse (ToolAxis, ToolTip, TabletPadButton usw.): Protokollieren. Vollständige Tablet-Unterstützung ist umfangreich.  
* **Tabelle: InputEvent-Variantenverarbeitung**

| InputEvent-Variante | Zugehörige Handler-Funktion in event\_dispatcher.rs | Kurze Logikbeschreibung |
| :---- | :---- | :---- |
| Keyboard { event } | keyboard::key\_event\_translator::handle\_keyboard\_key\_event | Übersetzt Keycode in Keysym/UTF-8, aktualisiert Modifikatoren, sendet an Client. |
| PointerMotion { event } | pointer::pointer\_event\_translator::handle\_pointer\_motion\_event | Aktualisiert Cursorposition, sendet Motion-Ereignis an fokussierte Oberfläche. |
| PointerMotionAbsolute { event } | pointer::pointer\_event\_translator::handle\_pointer\_motion\_absolute\_event | Wie PointerMotion, aber mit absoluten Koordinaten. |
| PointerButton { event } | pointer::pointer\_event\_translator::handle\_pointer\_button\_event | Sendet Button-Ereignis, löst ggf. Fokusänderung oder Fenstermanagement-Aktionen aus. |
| PointerAxis { event } | pointer::pointer\_event\_translator::handle\_pointer\_axis\_event | Sendet Scroll-Ereignis (vertikal/horizontal). |
| TouchDown { event } | touch::touch\_event\_translator::handle\_touch\_down\_event | Startet einen Touchpunkt, sendet Down-Ereignis an Oberfläche unter dem Punkt. |
| TouchUp { event } | touch::touch\_event\_translator::handle\_touch\_up\_event | Beendet einen Touchpunkt, sendet Up-Ereignis. |
| TouchMotion { event } | touch::touch\_event\_translator::handle\_touch\_motion\_event | Aktualisiert Position eines Touchpunkts, sendet Motion-Ereignis. |
| TouchFrame { event } | touch::touch\_event\_translator::handle\_touch\_frame\_event | Signalisiert Ende eines Satzes von Touch-Ereignissen. |
| TouchCancel { event } | touch::touch\_event\_translator::handle\_touch\_cancel\_event | Signalisiert Abbruch der Touch-Interaktion. |
| DeviceAdded { device } | Direkt in process\_input\_event | Protokolliert neues Gerät, aktualisiert ggf. Seat-Fähigkeiten. |
| DeviceRemoved { device } | Direkt in process\_input\_event | Protokolliert entferntes Gerät, aktualisiert ggf. Seat-Fähigkeiten. |
| Gesture\* | Direkt in process\_input\_event | Protokolliert Gestenereignisse für spätere Implementierung. |

\*Begründung für den Wert dieser Tabelle:\* Bietet eine klare Zuordnung von rohen Smithay-Eingabeereignissen zu den spezifischen Verarbeitungsfunktionen innerhalb des Eingabesystems.

### **D. Submodul 3: Tastaturverarbeitung (system::input::keyboard)**

#### **1\. Datei: xkb\_config.rs**

* **Zweck**: Verwaltet XKB-Keymap und \-Status für Tastaturen.  
* **Struktur: XkbKeyboardData**  
  * pub context: xkbcommon::xkb::Context  
  * pub keymap: xkbcommon::xkb::Keymap  
  * pub state: xkbcommon::xkb::State  
  * pub repeat\_timer: Option\<calloop::TimerHandle\> (Für Tastenwiederholung)  
  * pub repeat\_info: Option\<(u32, KeyState, std::time::Duration, std::time::Duration)\> (Keycode, Zustand, anfängliche Verzögerung, Wiederholungsintervall)  
  * focused\_surface\_on\_seat: Option\<wayland\_server::Weak\<WlSurface\>\> (Cache des aktuellen Fokus für diesen Seat/diese Tastatur)  
  * repeat\_key\_serial: Option\<Serial\> (Serial des Tastenereignisses, das die Wiederholung ausgelöst hat)  
* **Tabelle: XkbKeyboardData-Felder** (Analog zu SurfaceData-Felder-Tabelle)  
* **Funktion: pub fn new\_xkb\_keyboard\_data(config: \&smithay::input::keyboard::XkbConfig\<'\_\>) \-\> Result\<XkbKeyboardData, InputError\>**  
  * **Schritt 1**: let context \= xkbcommon::xkb::Context::new(xkbcommon::xkb::CONTEXT\_NO\_FLAGS);  
  * **Schritt 2**: Erstellen von xkbcommon::xkb::RuleNames aus config.rules, config.model, config.layout, config.variant (oder Standardwerte wie "evdev", "pc105", "us", "").  
  * **Schritt 3**: let keymap \= xkbcommon::xkb::Keymap::new\_from\_names(\&context, \&rules, xkbcommon::xkb::KEYMAP\_COMPILE\_NO\_FLAGS).map\_err(|\_| InputError::XkbConfigError("Keymap-Kompilierung fehlgeschlagen".to\_string()))?;.30  
  * **Schritt 4**: let state \= xkbcommon::xkb::State::new(\&keymap);.30  
  * Gibt XkbKeyboardData zurück.  
* **Funktion: pub fn update\_xkb\_state\_from\_modifiers(xkb\_state: \&mut xkbcommon::xkb::State, modifiers\_state: \&smithay::input::keyboard::ModifiersState) \-\> bool**  
  * Ruft xkb\_state.update\_mask(modifiers\_state.depressed, modifiers\_state.latched, modifiers\_state.locked, modifiers\_state.layout\_depressed, modifiers\_state.layout\_latched, modifiers\_state.layout\_locked) auf.30  
  * Gibt true zurück, wenn sich der Zustand geändert hat, andernfalls false.

#### **2\. Datei: key\_event\_translator.rs**

* **Zweck**: Übersetzt KeyboardKeyEvent in Keysyms/UTF-8 und leitet an den Client weiter.  
* **Funktion: pub fn handle\_keyboard\_key\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: KeyboardKeyEvent\<LibinputInputBackend\>, seat\_name: \&str)**  
  * **Schritt 1**: Tastatur-Handle abrufen: let keyboard\_handle \= seat.get\_keyboard().ok\_or\_else(|| { tracing::warn\!("Kein Keyboard-Handle für Seat {} bei Key-Event.", seat\_name); InputError::KeyboardHandleNotFound(seat\_name.to\_string()) })?;  
  * **Schritt 2**: XkbKeyboardData für diesen Seat/diese Tastatur abrufen: let xkb\_data \= desktop\_state.keyboards.get\_mut(seat\_name).ok\_or\_else(|| { tracing::warn\!("Keine XKB-Daten für Seat {} bei Key-Event.", seat\_name); InputError::XkbConfigError("XKB-Daten nicht gefunden".to\_string()) })?;  
  * **Schritt 3**: xkbcommon::State aktualisieren: let key\_direction \= match event.state() { KeyState::Pressed \=\> xkbcommon::xkb::KeyDirection::Down, KeyState::Released \=\> xkbcommon::xkb::KeyDirection::Up, }; xkb\_data.state.update\_key(event.key\_code(), key\_direction);.30  
  * **Schritt 4**: ModifiersState von xkb\_data.state abrufen: let smithay\_mods\_state \= smithay::input::keyboard::ModifiersState { depressed: xkb\_data.state.serialize\_mods(xkbcommon::xkb::STATE\_MODS\_DEPRESSED), latched: xkb\_data.state.serialize\_mods(xkbcommon::xkb::STATE\_MODS\_LATCHED), locked: xkb\_data.state.serialize\_mods(xkbcommon::xkb::STATE\_MODS\_LOCKED), layout\_effective: xkb\_data.state.serialize\_layout(xkbcommon::xkb::STATE\_LAYOUT\_EFFECTIVE),..Default::default() };  
  * **Schritt 5**: KeyboardHandle über Modifikatoränderungen informieren: keyboard\_handle.modifiers(\&smithay\_mods\_state, event.serial());  
  * **Schritt 6**: Wenn event.state() \== KeyState::Pressed:  
    * let keysym \= xkb\_data.state.key\_get\_one\_sym(event.key\_code());  
    * let utf8 \= xkb\_data.state.key\_get\_utf8(event.key\_code());  
    * Protokollieren von Keysym und UTF-8: tracing::trace\!(keycode \= event.key\_code(), keysym \=?keysym, utf8 \= %utf8, "Taste gedrückt");  
    * keyboard\_handle.input(event.key\_code(), KeyState::Pressed, Some(keysym), if utf8.is\_empty() { None } else { Some(utf8) }, event.time(), event.serial());  
    * Tastenwiederholung einrichten/abbrechen unter Verwendung von xkb\_data.repeat\_timer und calloop::Timer. Die Wiederholungsrate und \-verzögerung kommen von keyboard\_handle.repeat\_info().  
      * Wenn eine Taste gedrückt wird, die Wiederholung unterstützt:  
        * Vorhandenen repeat\_timer abbrechen.  
        * Neuen Timer mit anfänglicher Verzögerung starten. Callback des Timers sendet das Key-Event erneut und plant sich selbst mit dem Wiederholungsintervall neu, bis die Taste losgelassen wird oder der Fokus wechselt.  
        * xkb\_data.repeat\_info und xkb\_data.repeat\_key\_serial speichern.  
  * **Schritt 7**: Wenn event.state() \== KeyState::Released:  
    * keyboard\_handle.input(event.key\_code(), KeyState::Released, None, None, event.time(), event.serial());  
    * Tastenwiederholung abbrechen, falls diese Taste die Wiederholung ausgelöst hat. xkb\_data.repeat\_timer.take().map(|t| t.cancel()); xkb\_data.repeat\_info \= None;

#### **3\. Datei: focus\_handler\_keyboard.rs**

* **Zweck**: Verwaltet den Tastaturfokus für WlSurface.  
* **Funktion: pub fn set\_keyboard\_focus(desktop\_state: \&mut DesktopState, seat\_name: \&str, surface: Option\<\&WlSurface\>, serial: Serial)**  
  * **Schritt 1**: Seat und KeyboardHandle abrufen. let seat \= desktop\_state.seats.get(seat\_name).ok\_or\_else(...)?.clone(); (Klonen des Seat-Handles). let keyboard\_handle \= seat.get\_keyboard().ok\_or\_else(...)?.clone(); (Klonen des KeyboardHandle).  
  * **Schritt 2**: XkbKeyboardData für den Seat abrufen. let xkb\_data \= desktop\_state.keyboards.get\_mut(seat\_name).ok\_or\_else(...)?;  
  * **Schritt 3**: Alten Fokus ermitteln: let old\_focus\_weak \= xkb\_data.focused\_surface\_on\_seat.clone();  
  * **Schritt 4**: Wenn surface Some(new\_focus\_ref) ist:  
    * Wenn old\_focus\_weak.as\_ref().and\_then(|w| w.upgrade()).as\_ref()\!= Some(\&new\_focus\_ref), dann hat sich der Fokus geändert.  
      * Wenn alter Fokus existierte und noch gültig ist (old\_focus.upgrade()), keyboard\_handle.leave(old\_focus.upgrade().unwrap(), serial); senden.  
      * keyboard\_handle.enter(new\_focus\_ref, \&xkb\_data.state.keycodes\_pressed().collect::\<Vec\<\_\>\>(), serial, seat.get\_keyboard\_modifiers\_state()); (Aktuell gedrückte Tasten und Modifikatoren senden).  
      * xkb\_data.focused\_surface\_on\_seat \= Some(new\_focus\_ref.downgrade());  
  * **Schritt 5**: Wenn surface None ist:  
    * Wenn old\_focus\_weak.as\_ref().and\_then(|w| w.upgrade()).is\_some(), keyboard\_handle.leave(old\_focus\_weak.unwrap().upgrade().unwrap(), serial); senden.  
    * xkb\_data.focused\_surface\_on\_seat \= None;  
  * **Schritt 6**: keyboard\_handle.set\_focus(surface, serial);.31

### **E. Submodul 4: Zeigerverarbeitung (system::input::pointer)**

#### **1\. Datei: pointer\_event\_translator.rs**

* **Zweck**: Verarbeitet Zeigerereignisse und leitet sie weiter.  
* **Funktion: pub fn handle\_pointer\_motion\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: PointerMotionEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: PointerHandle abrufen: let pointer\_handle \= seat.get\_pointer().ok\_or\_else(...)?.clone();  
  * **Schritt 2**: Globale Cursorposition aktualisieren (z.B. in DesktopState speichern, wenn nicht von PointerHandle verwaltet). Die event.delta() oder event.delta\_unaccel() können verwendet werden, um die neue globale Position zu berechnen.  
  * **Schritt 3**: Neuen Zeigerfokus bestimmen basierend auf der neuen globalen Cursorposition. Dies erfordert eine Iteration über sichtbare Toplevel-Oberflächen und deren Eingaberegionen unter Berücksichtigung der Stapelreihenfolge. let (new\_focus\_surface, surface\_local\_coords) \= find\_surface\_at\_global\_coords(\&desktop\_state.toplevels, global\_cursor\_pos);  
  * **Schritt 4**: Fokus- und Enter/Leave-Ereignisse senden: update\_pointer\_focus\_and\_send\_motion(desktop\_state, seat, \&pointer\_handle, new\_focus\_surface, surface\_local\_coords, event.time(), event.serial());  
  * **Schritt 5**: Renderer-Cursorposition aktualisieren.  
* **Funktion: pub fn handle\_pointer\_motion\_absolute\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: PointerMotionAbsoluteEvent\<LibinputInputBackend\>)**  
  * Ähnlich wie handle\_pointer\_motion\_event, aber verwendet absolute Koordinaten. event.x\_transformed(output\_width), event.y\_transformed(output\_height) können verwendet werden, um globale Bildschirmkoordinaten zu erhalten.27 (Benötigt die Größe des Outputs, auf dem sich das Gerät befindet).  
* **Funktion: pub fn handle\_pointer\_button\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: PointerButtonEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: PointerHandle abrufen.  
  * **Schritt 2**: let wl\_button\_state \= match event.button\_state() { ButtonState::Pressed \=\> wl\_pointer::ButtonState::Pressed, ButtonState::Released \=\> wl\_pointer::ButtonState::Released, }; pointer\_handle.button(event.button(), wl\_button\_state, event.serial(), event.time());  
  * **Schritt 3**: Wenn Taste gedrückt (Pressed):  
    * Tastaturfokus gemäß Fenstermanagement-Richtlinie ändern (z.B. Click-to-Focus). focus\_handler\_keyboard::set\_keyboard\_focus(...) aufrufen mit der Oberfläche unter dem Cursor.  
    * Fenstermanagement-Interaktionen behandeln (z.B. Move/Resize starten, wenn auf Dekoration geklickt wird). Dies kann das Starten eines Grabs beinhalten (seat.start\_pointer\_grab(...)).  
* **Funktion: pub fn handle\_pointer\_axis\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: PointerAxisEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: PointerHandle abrufen.  
  * **Schritt 2**: Achsenquelle bestimmen: let source \= match event.axis\_source() { Some(libinput::event::pointer::AxisSource::Wheel) \=\> wl\_pointer::AxisSource::Wheel, Some(libinput::event::pointer::AxisSource::Finger) \=\> wl\_pointer::AxisSource::Finger, Some(libinput::event::pointer::AxisSource::Continuous) \=\> wl\_pointer::AxisSource::Continuous, \_ \=\> wl\_pointer::AxisSource::Wheel, // Fallback };  
  * **Schritt 3**: Diskrete Scroll-Schritte: let v\_discrete \= event.axis\_value\_discrete(PointerAxis::Vertical); let h\_discrete \= event.axis\_value\_discrete(PointerAxis::Horizontal);  
  * **Schritt 4**: Kontinuierlicher Scroll-Wert: let v\_continuous \= event.axis\_value(PointerAxis::Vertical); let h\_continuous \= event.axis\_value(PointerAxis::Horizontal);  
  * **Schritt 5**: Wenn vertikales Scrollen (v\_discrete.is\_some() | | v\_continuous\!= 0.0): pointer\_handle.axis(wl\_pointer::Axis::VerticalScroll, source, v\_discrete, v\_continuous, event.serial(), event.time());  
  * **Schritt 6**: Wenn horizontales Scrollen (h\_discrete.is\_some() | | h\_continuous\!= 0.0): pointer\_handle.axis(wl\_pointer::Axis::HorizontalScroll, source, h\_discrete, h\_continuous, event.serial(), event.time());

#### **2\. Datei: focus\_handler\_pointer.rs**

* **Zweck**: Verwaltet Zeigerfokus, Enter/Leave-Ereignisse.  
* **Funktion: pub fn update\_pointer\_focus\_and\_send\_motion(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, pointer\_handle: \&PointerHandle\<DesktopState\>, new\_focus\_surface: Option\<WlSurface\>, surface\_local\_coords: Point\<f64, Logical\>, time: u32, serial: Serial)**  
  * **Schritt 1**: Aktuellen Fokus vom pointer\_handle abrufen: let old\_focus\_surface \= pointer\_handle.current\_focus();  
  * **Schritt 2**: Wenn new\_focus\_surface\!= old\_focus\_surface.as\_ref():  
    * Wenn old\_focus\_surface existierte, pointer\_handle.leave(old\_focus\_surface.as\_ref().unwrap(), serial, time); senden.  
    * Wenn new\_focus\_surface existiert, pointer\_handle.enter(new\_focus\_surface.as\_ref().unwrap(), serial, time, surface\_local\_coords); senden.  
    * Internen Fokus des PointerHandle aktualisieren (Smithay macht dies oft implizit bei enter).  
  * **Schritt 3**: Wenn new\_focus\_surface existiert (auch wenn es dasselbe wie der alte Fokus ist), pointer\_handle.motion(new\_focus\_surface.as\_ref().unwrap(), time, serial, surface\_local\_coords); senden.

#### **3\. Datei: cursor\_updater.rs**

* **Zweck**: Behandelt die Logik von SeatHandler::cursor\_image.  
* Die Logik ist bereits oben in der Implementierung von SeatHandler::cursor\_image detailliert. Diese Datei würde Hilfsfunktionen enthalten, falls diese Logik zu komplex wird, z.B. für das Laden von Cursor-Themen.

### **F. Submodul 5: Touch-Verarbeitung (system::input::touch)**

#### **1\. Datei: touch\_event\_translator.rs**

* **Zweck**: Verarbeitet Touch-Ereignisse und leitet sie weiter.  
* **Funktion: pub fn handle\_touch\_down\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: TouchDownEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: TouchHandle abrufen: let touch\_handle \= seat.get\_touch().ok\_or\_else(...)?.clone();  
  * **Schritt 2**: Fokussierte Oberfläche für diesen Touchpunkt bestimmen. Dies kann die Oberfläche unter dem Touchpunkt sein. let (focused\_surface, surface\_local\_coords) \= find\_surface\_at\_global\_coords(\&desktop\_state.toplevels, event.position\_transformed(output\_size)); (Benötigt Output-Größe für Transformation).  
  * **Schritt 3**: Wenn eine Oberfläche anvisiert wird:  
    * touch\_handle.down(focused\_surface.as\_ref().unwrap(), event.serial(), event.time(), event.slot().unwrap(), surface\_local\_coords); (Smithay's slot() gibt Option\<TouchSlot\>).  
* **Funktion: pub fn handle\_touch\_up\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: TouchUpEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: TouchHandle abrufen.  
  * touch\_handle.up(event.serial(), event.time(), event.slot().unwrap());  
* **Funktion: pub fn handle\_touch\_motion\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>, event: TouchMotionEvent\<LibinputInputBackend\>)**  
  * **Schritt 1**: TouchHandle abrufen.  
  * **Schritt 2**: Oberfläche abrufen, die aktuell von diesem Touch-Slot (event.slot().unwrap()) anvisiert wird (muss im TouchHandle oder DesktopState pro Slot gespeichert werden).  
  * **Schritt 3**: Koordinaten transformieren.  
  * touch\_handle.motion(focused\_surface\_for\_slot.as\_ref().unwrap(), event.serial(), event.time(), event.slot().unwrap(), surface\_local\_coords\_for\_slot);  
* **Funktion: pub fn handle\_touch\_frame\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>)**  
  * TouchHandle abrufen.  
  * touch\_handle.frame();  
* **Funktion: pub fn handle\_touch\_cancel\_event(desktop\_state: \&mut DesktopState, seat: \&Seat\<DesktopState\>)**  
  * TouchHandle abrufen.  
  * touch\_handle.cancel();

#### **2\. Datei: focus\_handler\_touch.rs**

* **Zweck**: Verwaltet den Touch-Fokus.  
* Die Logik zur Bestimmung des Touch-Fokus ist ähnlich der des Zeigerfokus, aber pro Touchpunkt/Slot. TouchHandle selbst hat keine expliziten enter/leave-Methoden wie PointerHandle; der Fokus ist implizit in dem Oberflächenargument für down/motion. Der Zustand, welche Oberfläche von welchem Slot berührt wird, muss im DesktopState oder einer benutzerdefinierten Struktur, die mit dem TouchHandle assoziiert ist, verwaltet werden.

## **IV. Schlussfolgerungen**

Dieser erste Teil der Ultra-Feinspezifikation für die Systemschicht legt ein detailliertes Fundament für die Kernkomponenten des Wayland-Compositors und der Eingabeverarbeitung. Durch die systematische Zerlegung in Module und Submodule, die präzise Definition von Datenstrukturen, Schnittstellen und Fehlerfällen sowie die schrittweise Detaillierung der Implementierungslogik wird eine solide Basis für die nachfolgende Entwicklung geschaffen.  
Die enge Integration mit dem Smithay-Toolkit und dessen Designprinzipien, insbesondere das Handler-Trait-Muster und die zentrale Zustandsverwaltung in DesktopState, prägen die Struktur der Implementierung maßgeblich. Die Spezifikation berücksichtigt die Notwendigkeit einer klaren Abstraktion der Renderer-Schnittstelle und einer robusten Fehlerbehandlung mittels thiserror. Die detaillierte Ausarbeitung der XDG-Shell-Handler und der Input-Event-Übersetzer adressiert die Komplexität dieser Protokolle und Interaktionen.  
Die hier spezifizierten Module system::compositor und system::input sind grundlegend für jede weitere Funktionalität der Desktop-Umgebung. Ihre korrekte und performante Implementierung gemäß dieser Spezifikation ist entscheidend für die Stabilität, Reaktionsfähigkeit und das Gesamterlebnis des Systems. Die identifizierten Abhängigkeiten und Interaktionen zwischen diesen Modulen sowie die Notwendigkeit einer sorgfältigen Zustandsverwaltung wurden hervorgehoben, um potenziellen Herausforderungen proaktiv zu begegnen.  
Mit dieser Spezifikation sind Entwickler in der Lage, die Implementierung von Teil 1/4 der Systemschicht mit einem hohen Grad an Klarheit und Präzision zu beginnen. Die nachfolgenden Teile werden auf dieser Grundlage aufbauen und weitere systemnahe Dienste und Protokolle detaillieren.

#### **Referenzen**

1. smithay \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/](https://smithay.github.io/smithay/)  
2. Smithay/calloop: A callback-based Event Loop \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/Smithay/calloop](https://github.com/Smithay/calloop)  
3. calloop \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/calloop/](https://docs.rs/calloop/)  
4. smithay \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/smithay](https://docs.rs/smithay)  
5. View github: Smithay/smithay | OpenText Core SCA \- Debricked, Zugriff am Mai 14, 2025, [https://debricked.com/select/package/github-Smithay/smithay](https://debricked.com/select/package/github-Smithay/smithay)  
6. CompositorHandler in smithay::wayland::compositor \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/wayland/compositor/trait.CompositorHandler.html](https://smithay.github.io/smithay/smithay/wayland/compositor/trait.CompositorHandler.html)  
7. smithay::wayland::shell::xdg \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/wayland/shell/xdg/index.html](https://smithay.github.io/smithay/smithay/wayland/shell/xdg/index.html)  
8. Multiple error types \- Rust By Example, Zugriff am Mai 14, 2025, [https://doc.rust-lang.org/rust-by-example/error/multiple\_error\_types.html](https://doc.rust-lang.org/rust-by-example/error/multiple_error_types.html)  
9. Rust Error Handling: thiserror, anyhow, and When to Use Each | Momori Nakano, Zugriff am Mai 14, 2025, [https://momori.dev/posts/rust-error-handling-thiserror-anyhow/](https://momori.dev/posts/rust-error-handling-thiserror-anyhow/)  
10. smithay::wayland::compositor \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/wayland/compositor/index.html](https://smithay.github.io/smithay/smithay/wayland/compositor/index.html)  
11. Display in wayland\_server \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/wayland\_server/struct.Display.html](https://smithay.github.io/smithay/wayland_server/struct.Display.html)  
12. LoopHandle in calloop \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/calloop/latest/calloop/struct.LoopHandle.html](https://docs.rs/calloop/latest/calloop/struct.LoopHandle.html)  
13. GlobalDispatch in wayland\_server \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/wayland\_server/trait.GlobalDispatch.html](https://smithay.github.io/smithay/wayland_server/trait.GlobalDispatch.html)  
14. uuid \- Rust, Zugriff am Mai 14, 2025, [https://messense.github.io/bosonnlp-rs/uuid/index.html](https://messense.github.io/bosonnlp-rs/uuid/index.html)  
15. Uuid in rocket::serde::uuid \- Rust, Zugriff am Mai 14, 2025, [https://api.rocket.rs/v0.5/rocket/serde/uuid/struct.Uuid](https://api.rocket.rs/v0.5/rocket/serde/uuid/struct.Uuid)  
16. Appendix A. Wayland Protocol Specification, Zugriff am Mai 14, 2025, [https://wayland.freedesktop.org/docs/html/apa.html](https://wayland.freedesktop.org/docs/html/apa.html)  
17. smithay::wayland::shm \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/wayland/shm/index.html](https://smithay.github.io/smithay/smithay/wayland/shm/index.html)  
18. wayland\_client::protocol::wl\_shm \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/wayland-client/latest/wayland\_client/protocol/wl\_shm/index.html](https://docs.rs/wayland-client/latest/wayland_client/protocol/wl_shm/index.html)  
19. gdk/wayland/protocol/xdg-shell.xml · 3.13.5 · Zrythm / GTK · GitLab, Zugriff am Mai 14, 2025, [https://gitlab.zrythm.org/zrythm/gtk/-/blob/3.13.5/gdk/wayland/protocol/xdg-shell.xml](https://gitlab.zrythm.org/zrythm/gtk/-/blob/3.13.5/gdk/wayland/protocol/xdg-shell.xml)  
20. XdgToplevel in wayland\_protocols::xdg::shell::server::xdg\_toplevel, Zugriff am Mai 14, 2025, [https://smithay.github.io/wayland-rs/wayland\_protocols/xdg/shell/server/xdg\_toplevel/struct.XdgToplevel.html](https://smithay.github.io/wayland-rs/wayland_protocols/xdg/shell/server/xdg_toplevel/struct.XdgToplevel.html)  
21. ToplevelSurface in smithay::wayland::shell::xdg \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/wayland/shell/xdg/struct.ToplevelSurface.html](https://smithay.github.io/smithay/smithay/wayland/shell/xdg/struct.ToplevelSurface.html)  
22. Popup in smithay\_client\_toolkit::shell::xdg::popup \- Rust, Zugriff am Mai 14, 2025, [https://doc.servo.org/smithay\_client\_toolkit/shell/xdg/popup/struct.Popup.html](https://doc.servo.org/smithay_client_toolkit/shell/xdg/popup/struct.Popup.html)  
23. smithay::backend \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/backend/index.html](https://smithay.github.io/smithay/smithay/backend/index.html)  
24. smithay::backend::renderer::element \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/backend/renderer/element/index.html](https://smithay.github.io/smithay/smithay/backend/renderer/element/index.html)  
25. smithay::backend::libinput \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/backend/libinput/index.html](https://smithay.github.io/smithay/smithay/backend/libinput/index.html)  
26. smithay::input \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/input/index.html](https://smithay.github.io/smithay/smithay/input/index.html)  
27. LibinputInputBackend in smithay::backend::libinput \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/backend/libinput/struct.LibinputInputBackend.html](https://smithay.github.io/smithay/smithay/backend/libinput/struct.LibinputInputBackend.html)  
28. Device in input \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/input/struct.Device.html](https://smithay.github.io/smithay/input/struct.Device.html)  
29. smithay::wayland::seat \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/wayland/seat/index.html](https://smithay.github.io/smithay/smithay/wayland/seat/index.html)  
30. State in smithay::input::keyboard::xkb \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/input/keyboard/xkb/struct.State.html](https://smithay.github.io/smithay/smithay/input/keyboard/xkb/struct.State.html)  
31. smithay::wayland::seat \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/smithay/latest/smithay/wayland/seat/index.html](https://docs.rs/smithay/latest/smithay/wayland/seat/index.html)  
32. Seats — libinput 1.28.1 documentation \- Wayland, Zugriff am Mai 14, 2025, [https://wayland.freedesktop.org/libinput/doc/latest/seats.html](https://wayland.freedesktop.org/libinput/doc/latest/seats.html)

# **Implementierungsleitfaden Systemschicht: D-Bus-Interaktion und Output-Management (Teil 2/4)**

Dieser Teil des Implementierungsleitfadens für die Systemschicht befasst sich mit zwei zentralen Aspekten der neuen Linux-Desktop-Umgebung: der Interaktion mit systemweiten D-Bus-Diensten und der umfassenden Verwaltung von Anzeigeausgängen. Diese Komponenten sind entscheidend für die Integration der Desktop-Umgebung in das Basissystem und für die Bereitstellung einer kohärenten Benutzererfahrung über verschiedene Hardwarekonfigurationen hinweg.

## **A. Modul: system::dbus – Interaktion mit System-D-Bus-Diensten**

Das Modul system::dbus ist verantwortlich für die Kommunikation mit verschiedenen Standard-D-Bus-Diensten, die für den Betrieb einer Desktop-Umgebung unerlässlich sind. Hierzu zählen Dienste für Energieverwaltung (UPower), Sitzungsmanagement (systemd-logind), Netzwerkmanagement (NetworkManager), Geheimnisverwaltung (Freedesktop Secret Service) und Rechteverwaltung (PolicyKit). Die Implementierung erfolgt unter Verwendung der zbus-Bibliothek.1

### **1\. Submodul: system::dbus::error – Fehlerbehandlung für D-Bus-Operationen**

Dieses Submodul definiert die spezifischen Fehlertypen für alle D-Bus-Interaktionen innerhalb der Systemschicht. Gemäß den Entwicklungsrichtlinien wird hierfür das thiserror-Crate genutzt, um pro Modul ein dediziertes Error-Enum zu erstellen \[User Query IV.4.3\]. Dies ermöglicht eine präzise Fehlerbehandlung und klare Fehlermeldungen.

* **Datei**: system/dbus/error.rs  
* **Spezifikation**:  
  * Es wird ein öffentliches Enum DBusError definiert, das die Traits thiserror::Error und std::fmt::Debug implementiert. Die Verwendung von thiserror vereinfacht die Erstellung idiomatischer Fehler.2  
  * Die \#\[from\]-Direktive von thiserror wird verwendet, um Fehler aus der zbus-Bibliothek (insbesondere zbus::Error 4 und zbus::zvariant::Error) transparent in spezifische Varianten von DBusError zu konvertieren. Dies ist entscheidend, da zbus-Operationen wie Verbindungsaufbau, Methodenaufrufe oder Signalabonnements fehlschlagen können.1  
  * **Varianten der DBusError Enum**:  
    * \# ConnectionFailed { service\_name: Option\<String\>, bus: BusType, \#\[source\] source: zbus::Error } Fehler beim Aufbau einer D-Bus-Verbindung. BusType ist ein Enum (Session, System).  
    * \# MethodCallFailed { service: String, path: String, interface: String, method: String, \#\[source\] source: zbus::Error } Fehler beim Aufruf einer D-Bus-Methode.  
    * \# ProxyCreationFailed { service: String, interface: String, \#\[source\] source: zbus::Error } Fehler bei der Erstellung eines D-Bus-Proxys.  
    * \# SignalSubscriptionFailed { interface: String, signal\_name: String, \#\[source\] source: zbus::Error } Fehler beim Abonnieren eines D-Bus-Signals.  
    * \# InvalidResponse { service: String, method: String, details: String } Unerwartete oder ungültige Antwort von einem D-Bus-Dienst.  
    * \# DataDeserializationError { context: String, \#\[source\] source: zbus::zvariant::Error } Fehler bei der Deserialisierung von D-Bus-Daten.  
    * \# PropertyAccessFailed { service: String, interface: String, property: String, \#\[source\] source: zbus::Error } Fehler beim Zugriff auf eine D-Bus-Eigenschaft.  
    * \# NameTaken { name: String, \#\[source\] source: zbus::Error } Tritt auf, wenn versucht wird, einen D-Bus-Namen zu beanspruchen, der bereits belegt ist (relevant für das Anbieten eigener D-Bus-Dienste, hier primär für Clients).  
    * \#\[error("Operation timed out: {operation}")\] Timeout { operation: String } Zeitüberschreitung bei einer D-Bus-Operation.  
* **Implementierungsschritte**:  
  1. Definition des BusType Enums: pub enum BusType { Session, System }.  
  2. Definition des DBusError Enums mit den oben genannten Varianten und den \#\[error(...)\]-Attributen für menschenlesbare Fehlermeldungen.  
  3. Sicherstellung, dass alle öffentlichen Funktionen im system::dbus-Modul und seinen Submodulen Result\<T, DBusError\> zurückgeben, um eine konsistente Fehlerbehandlung zu gewährleisten.

### **2\. Submodul: system::dbus::connection – D-Bus Verbindungsmanagement**

Dieses Submodul stellt einen zentralen Manager für D-Bus-Verbindungen bereit, um die Wiederverwendung von Verbindungen zu ermöglichen und deren Aufbau zu optimieren.

* **Datei**: system/dbus/connection.rs  
* **Spezifikation**:  
  * **Struktur**: DBusConnectionManager  
    * Felder:  
      * session\_bus: tokio::sync::OnceCell\<Arc\<zbus::Connection\>\>  
      * system\_bus: tokio::sync::OnceCell\<Arc\<zbus::Connection\>\> Die Verwendung von tokio::sync::OnceCell ermöglicht eine verzögerte Initialisierung der D-Bus-Verbindungen. Eine Verbindung wird erst beim ersten tatsächlichen Bedarf aufgebaut. Anschließend wird die Arc\<zbus::Connection\> für die zukünftige Wiederverwendung gespeichert.5 Dies ist effizient, da nicht bei jedem Start des Desktops sofort alle potenziellen D-Bus-Verbindungen etabliert werden müssen, und Arc stellt sicher, dass die einmal aufgebaute Verbindung sicher zwischen verschiedenen asynchronen Tasks geteilt werden kann, die möglicherweise parallel auf denselben Bus zugreifen (z.B. UPower-Client und Logind-Client auf dem Systembus).  
  * **Methoden** für DBusConnectionManager:  
    * pub fn new() \-\> Self: Konstruktor, initialisiert die leeren OnceCells.  
    * pub async fn get\_session\_bus(\&self) \-\> Result\<Arc\<zbus::Connection\>, DBusError\>: Gibt eine Arc-gekapselte zbus::Connection zum Session-Bus zurück. Nutzt self.session\_bus.get\_or\_try\_init() in Kombination mit zbus::Connection::session().await.1 Fehler beim Verbindungsaufbau werden in DBusError::ConnectionFailed gemappt.  
    * pub async fn get\_system\_bus(\&self) \-\> Result\<Arc\<zbus::Connection\>, DBusError\>: Analog zu get\_session\_bus, jedoch für den System-Bus unter Verwendung von zbus::Connection::system().await.1  
* **Implementierungsschritte**:  
  1. Definiere die DBusConnectionManager-Struktur.  
  2. Implementiere die new()-Methode.  
  3. Implementiere get\_session\_bus():  
     Rust  
     pub async fn get\_session\_bus(\&self) \-\> Result\<Arc\<zbus::Connection\>, DBusError\> {  
         self.session\_bus  
            .get\_or\_try\_init(|| async {  
                 zbus::Connection::session()  
                    .await  
                    .map(Arc::new)  
                    .map\_err(|e| DBusError::ConnectionFailed {  
                         service\_name: None, // Generic session bus connection  
                         bus: BusType::Session,  
                         source: e,  
                     })  
             })  
            .await  
            .cloned() // Clone the Arc for the caller  
     }

  4. Implementiere get\_system\_bus() analog.

### **3\. Submodul: system::dbus::upower\_client – UPower D-Bus Client**

Dieser Client interagiert mit dem org.freedesktop.UPower-Dienst, um Informationen über den Energiezustand des Systems und angeschlossene Geräte zu erhalten.6

* **Dateien**: system/dbus/upower\_client.rs, system/dbus/upower\_types.rs  
* **Spezifikation (upower\_types.rs)**:  
  * pub enum PowerDeviceType { Unknown \= 0, LinePower \= 1, Battery \= 2, Ups \= 3, Monitor \= 4, Mouse \= 5, Keyboard \= 6, Pda \= 7, Phone \= 8, /\* Display \= 9 (aus UPower.Device, nicht standardisiert in udev?) \*/ } (Werte basierend auf UPowerDeviceType in der UPower-Dokumentation).  
  * pub enum PowerState { Unknown \= 0, Charging \= 1, Discharging \= 2, Empty \= 3, FullyCharged \= 4, PendingCharge \= 5, PendingDischarge \= 6 }.8  
  * pub enum PowerWarningLevel { Unknown \= 0, None \= 1, Discharging \= 2, Low \= 3, Critical \= 4, Action \= 5 }.  
  * pub struct PowerDeviceDetails { pub object\_path: zbus::zvariant::OwnedObjectPath, pub vendor: String, pub model: String, pub serial: String, pub native\_path: String, pub device\_type: PowerDeviceType, pub state: PowerState, pub percentage: f64, pub temperature: f64, pub voltage: f64, pub energy: f64, pub energy\_empty: f64, pub energy\_full: f64, pub energy\_full\_design: f64, pub energy\_rate: f64, pub time\_to\_empty: i64, pub time\_to\_full: i64, pub is\_rechargeable: bool, pub is\_present: bool, pub warning\_level: PowerWarningLevel, pub icon\_name: String, pub capacity: f64, pub technology: String }.7  
    * Felder werden aus den Properties des org.freedesktop.UPower.Device-Interfaces abgeleitet.  
  * pub struct UPowerProperties { pub on\_battery: bool, pub lid\_is\_closed: bool, pub lid\_is\_present: bool, pub daemon\_version: String }.7  
  * Implementiere TryFrom\<u32\> für PowerDeviceType, PowerState, PowerWarningLevel zur Konvertierung von D-Bus-Werten.  
* **Spezifikation (upower\_client.rs)**:  
  * **Proxy-Definitionen** (mittels \#\[zbus::proxy(...)\] 1):  
    * UPowerManagerProxy (Name angepasst zur Klarheit) für org.freedesktop.UPower auf /org/freedesktop/UPower.  
      * Methoden:  
        * \# async fn enumerate\_devices(\&self) \-\> zbus::Result\<Vec\<zbus::zvariant::OwnedObjectPath\>\>; 7  
        * \# async fn get\_display\_device(\&self) \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath\>\>; 7  
        * \#\[zbus(name \= "GetCriticalAction")\] async fn get\_critical\_action(\&self) \-\> zbus::Result\<String\>\>; 7  
      * Properties (als Methoden im Proxy generiert):  
        * \#\[zbus(property)\] async fn on\_battery(\&self) \-\> zbus::Result\<bool\>; 7  
        * \#\[zbus(property)\] async fn lid\_is\_closed(\&self) \-\> zbus::Result\<bool\>; 7  
        * \#\[zbus(property)\] async fn lid\_is\_present(\&self) \-\> zbus::Result\<bool\>; 7  
        * \#\[zbus(property)\] async fn daemon\_version(\&self) \-\> zbus::Result\<String\>; 7  
      * Signale (als Methoden im Proxy generiert, die einen SignalStream zurückgeben):  
        * \#\[zbus(signal)\] async fn device\_added(\&self, device\_path: zbus::zvariant::OwnedObjectPath) \-\> zbus::Result\<()\>; (Das Signal selbst hat Argumente, die receive\_ Methode wird diese liefern) 7  
        * \#\[zbus(signal)\] async fn device\_removed(\&self, device\_path: zbus::zvariant::OwnedObjectPath) \-\> zbus::Result\<()\>; 7  
        * (Das PropertiesChanged-Signal wird über zbus::Proxy::receive\_properties\_changed\_with\_args() oder ähnliche Methoden des generierten Proxys gehandhabt).  
    * UPowerDeviceProxy für org.freedesktop.UPower.Device (Pfad variabel, daher default\_path nicht im Makro).  
      * Properties (Beispiele):  
        * \#\[zbus(property)\] async fn type\_(\&self) \-\> zbus::Result\<u32\>; (Suffix \_ um Keyword-Kollision zu vermeiden)  
        * \#\[zbus(property)\] async fn state(\&self) \-\> zbus::Result\<u32\>;  
        * \#\[zbus(property)\] async fn percentage(\&self) \-\> zbus::Result\<f64\>;  
        * \#\[zbus(property)\] async fn time\_to\_empty(\&self) \-\> zbus::Result\<i64\>; 8  
        * \#\[zbus(property)\] async fn time\_to\_full(\&self) \-\> zbus::Result\<i64\>; 8  
        * \#\[zbus(property, name \= "IsPresent")\] async fn is\_present(\&self) \-\> zbus::Result\<bool\>;  
        * \#\[zbus(property, name \= "IconName")\] async fn icon\_name(\&self) \-\> zbus::Result\<String\>;  
        * (Weitere Properties analog definieren: Vendor, Model, Serial, NativePath, Temperature, Voltage, Energy, EnergyEmpty, EnergyFull, EnergyFullDesign, EnergyRate, IsRechargeable, WarningLevel, Capacity, Technology).  
  * **Struktur**: UPowerClient  
    * Felder: connection\_manager: Arc\<DBusConnectionManager\>, manager\_proxy\_path: Arc\<zbus::zvariant::ObjectPath\<'static\>\> (Cache für den Manager-Pfad).  
  * **Methoden** für UPowerClient:  
    * pub async fn new(conn\_manager: Arc\<DBusConnectionManager\>) \-\> Result\<Self, DBusError\>: Initialisiert den Client. Speichert den conn\_manager. Der manager\_proxy\_path wird auf /org/freedesktop/UPower gesetzt.  
    * async fn get\_manager\_proxy(\&self) \-\> Result\<UPowerManagerProxy\<'\_\>, DBusError\>: Private Hilfsmethode, um den UPowerManagerProxy zu erstellen. Holt die Systembus-Verbindung vom connection\_manager.  
    * async fn get\_device\_proxy\<'a\>(\&self, device\_path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<UPowerDeviceProxy\<'a\>, DBusError\>: Private Hilfsmethode, um einen UPowerDeviceProxy für einen gegebenen Pfad zu erstellen.  
    * pub async fn get\_properties(\&self) \-\> Result\<UPowerProperties, DBusError\>: Ruft die on\_battery, lid\_is\_closed, lid\_is\_present und daemon\_version Properties vom UPowerManagerProxy ab und fasst sie in UPowerProperties zusammen.  
    * pub async fn enumerate\_devices(\&self) \-\> Result\<Vec\<zbus::zvariant::OwnedObjectPath\>, DBusError\>: Ruft UPowerManagerProxy::enumerate\_devices() auf.  
    * pub async fn get\_display\_device\_path(\&self) \-\> Result\<zbus::zvariant::OwnedObjectPath, DBusError\>: Ruft UPowerManagerProxy::get\_display\_device() auf.  
    * pub async fn get\_device\_details(\&self, device\_path: \&zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<PowerDeviceDetails, DBusError\>: Erstellt einen UPowerDeviceProxy für den device\_path. Ruft alle relevanten Properties ab und konvertiert sie in die PowerDeviceDetails-Struktur. Nutzt try\_into() für Enums.  
    * pub async fn on\_battery(\&self) \-\> Result\<bool, DBusError\>: Ruft die on\_battery Property vom UPowerManagerProxy ab.  
    * pub async fn subscribe\_device\_added(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<zbus::zvariant::OwnedObjectPath, DBusError\>\>, DBusError\>: Erstellt einen UPowerManagerProxy, ruft receive\_device\_added().await? auf.1 Mappt die Signaldaten ((OwnedObjectPath,)) und Fehler.  
    * pub async fn subscribe\_device\_removed(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<zbus::zvariant::OwnedObjectPath, DBusError\>\>, DBusError\>: Analog zu subscribe\_device\_added.  
    * pub async fn subscribe\_upower\_properties\_changed(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<HashMap\<String, zbus::zvariant::OwnedValue\>, DBusError\>\>, DBusError\>: Verwendet UPowerManagerProxy::receive\_properties\_changed().await?.  
    * pub async fn subscribe\_device\_properties\_changed(\&self, device\_path: zbus::zvariant::OwnedObjectPath) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<(String, HashMap\<String, zbus::zvariant::OwnedValue\>, Vec\<String\>), DBusError\>\>, DBusError\>: Erstellt einen UPowerDeviceProxy für den Pfad und verwendet receive\_properties\_changed\_with\_args().await?. Die Argumente des Signals sind (String, HashMap\<String, Value\>, Vec\<String\>).  
* **Implementierungsschritte**:  
  1. Definition der Typen in upower\_types.rs inklusive TryFrom\<u32\> für Enums.  
  2. Generierung der Proxy-Traits in upower\_client.rs.  
  3. Implementierung der UPowerClient-Struktur und ihrer Methoden. Die Methoden sollten die Proxy-Aufrufe kapseln und Fehler in DBusError umwandeln.  
  4. Signal-Abonnementmethoden geben einen Stream zurück, den der Aufrufer verarbeiten kann. Die Verarbeitung der Signaldaten (z.B. Extrahieren des device\_path aus dem Signal-Message-Body) und Fehlerbehandlung muss sorgfältig erfolgen.  
* **Publisher/Subscriber**:  
  * Publisher: org.freedesktop.UPower D-Bus Dienst.  
  * Subscriber: UPowerClient (bzw. die Systemschicht, die diesen Client nutzt).  
* Die Notwendigkeit, Signal-Streams korrekt zu verwalten, um Ressourcenlecks oder Callbacks auf ungültige Zustände zu vermeiden, ist ein wichtiger Aspekt. Wenn ein UPowerClient nicht mehr benötigt wird oder die Verbindung abbricht, müssen die assoziierten Streams ebenfalls beendet werden. Dies kann durch tokio::select\! in Kombination mit einem Shutdown-Signal oder durch das Droppen des Streams geschehen.

### **4\. Submodul: system::dbus::logind\_client – Systemd-Logind D-Bus Client**

Dieser Client interagiert mit org.freedesktop.login1 für Sitzungsmanagement, Sperr-/Entsperr-Operationen und Benachrichtigungen über Systemzustandsänderungen wie Suspend/Resume.10

* **Dateien**: system/dbus/logind\_client.rs, system/dbus/logind\_types.rs  
* **Spezifikation (logind\_types.rs)**:  
  * pub struct SessionInfo { pub id: String, pub user\_id: u32, pub user\_name: String, pub seat\_id: String, pub object\_path: zbus::zvariant::OwnedObjectPath }.10  
  * pub struct UserInfo { pub id: u32, pub name: String, pub object\_path: zbus::zvariant::OwnedObjectPath }.  
  * pub enum SessionState { Active, Online, Closing, Gone, Unknown } (basierend auf typischen Logind-Zuständen).  
* **Spezifikation (logind\_client.rs)**:  
  * **Proxy-Definitionen**:  
    * LogindManagerProxy für org.freedesktop.login1.Manager auf /org/freedesktop/login1.  
      * Methoden:  
        * \# async fn get\_session(\&self, session\_id: \&str) \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath\>; 10  
        * \# async fn get\_session\_by\_pid(\&self, pid: u32) \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath\>; 11  
        * \#\[zbus(name \= "GetUser")\] async fn get\_user(\&self, uid: u32) \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath\>; 10  
        * \# async fn list\_sessions(\&self) \-\> zbus::Result\<Vec\<(String, u32, String, String, zbus::zvariant::OwnedObjectPath)\>\>; 10  
        * \# async fn lock\_session(\&self, session\_id: \&str) \-\> zbus::Result\<()\>; 10  
        * \# async fn unlock\_session(\&self, session\_id: \&str) \-\> zbus::Result\<()\>; 10  
        * \# async fn lock\_sessions(\&self) \-\> zbus::Result\<()\>; 10  
        * \# async fn unlock\_sessions(\&self) \-\> zbus::Result\<()\>; 10  
      * Signale:  
        * \#\[zbus(signal)\] async fn session\_new(\&self, session\_id: String, object\_path: zbus::zvariant::OwnedObjectPath) \-\> zbus::Result\<()\>; 12  
        * \#\[zbus(signal)\] async fn session\_removed(\&self, session\_id: String, object\_path: zbus::zvariant::OwnedObjectPath) \-\> zbus::Result\<()\>; 12  
        * \# async fn prepare\_for\_sleep(\&self, start\_or\_stop: bool) \-\> zbus::Result\<()\>; 10  
    * LogindSessionProxy für org.freedesktop.login1.Session (Pfad variabel).  
      * Methoden:  
        * \#\[zbus(name \= "Lock")\] async fn lock(\&self) \-\> zbus::Result\<()\>; 10  
        * \#\[zbus(name \= "Unlock")\] async fn unlock(\&self) \-\> zbus::Result\<()\>; 10  
        * \# async fn terminate(\&self) \-\> zbus::Result\<()\>; 10  
      * Properties (Beispiele): Id: String, User: (u32, zbus::zvariant::OwnedObjectPath), Name: String, Timestamp: u64, TimestampMonotonic: u64, VTNr: u32, Seat: (String, zbus::zvariant::OwnedObjectPath), TTY: String, Remote: bool, RemoteHost: String, Service: String, Scope: String, Leader: u32, Audit: u32, Type: String, Class: String, Active: bool, State: String, IdleHint: bool, IdleSinceHint: u64, IdleSinceHintMonotonic: u64.  
      * Signale:  
        * \#\[zbus(signal, name \= "Lock")\] async fn lock\_signal(\&self) \-\> zbus::Result\<()\>; 10  
        * \#\[zbus(signal, name \= "Unlock")\] async fn unlock\_signal(\&self) \-\> zbus::Result\<()\>; 10  
        * \#\[zbus(signal, name \= "PropertyChanged")\] async fn property\_changed\_signal(\&self, name: String, value: zbus::zvariant::OwnedValue) \-\> zbus::Result\<()\>; (Standard-Signal)  
    * LogindUserProxy für org.freedesktop.login1.User (Pfad variabel).  
      * Methoden:  
        * \# async fn terminate(\&self) \-\> zbus::Result\<()\>; 10  
      * Properties (Beispiele): UID: u32, GID: u32, Name: String, Timestamp: u64, TimestampMonotonic: u64, RuntimePath: String, Service: String, Slice: String, Display: (String, zbus::zvariant::OwnedObjectPath), State: String, Sessions: Vec\<(String, zbus::zvariant::OwnedObjectPath)\>, IdleHint: bool, IdleSinceHint: u64, IdleSinceHintMonotonic: u64, Linger: bool.  
  * **Struktur**: LogindClient  
    * Felder: connection\_manager: Arc\<DBusConnectionManager\>, manager\_proxy\_path: Arc\<zbus::zvariant::ObjectPath\<'static\>\>.  
  * **Methoden** für LogindClient:  
    * pub async fn new(conn\_manager: Arc\<DBusConnectionManager\>) \-\> Result\<Self, DBusError\>  
    * async fn get\_manager\_proxy(\&self) \-\> Result\<LogindManagerProxy\<'\_\>, DBusError\>  
    * async fn get\_session\_proxy\<'a\>(\&self, session\_path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<LogindSessionProxy\<'a\>, DBusError\>  
    * pub async fn list\_sessions(\&self) \-\> Result\<Vec\<SessionInfo\>, DBusError\>: Ruft LogindManagerProxy::list\_sessions() auf und konvertiert das Tupel-Array in Vec\<SessionInfo\>.  
    * pub async fn get\_session\_details(\&self, session\_path: \&zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<SessionInfo, DBusError\>: Ruft Properties vom LogindSessionProxy ab.  
    * pub async fn lock\_session(\&self, session\_id: \&str) \-\> Result\<(), DBusError\>  
    * pub async fn unlock\_session(\&self, session\_id: \&str) \-\> Result\<(), DBusError\>  
    * pub async fn lock\_all\_sessions(\&self) \-\> Result\<(), DBusError\>  
    * pub async fn unlock\_all\_sessions(\&self) \-\> Result\<(), DBusError\>  
    * pub async fn subscribe\_session\_new(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<SessionInfo, DBusError\>\>, DBusError\>: Abonniert SessionNew, konvertiert die Daten in SessionInfo.  
    * pub async fn subscribe\_session\_removed(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<(String, zbus::zvariant::OwnedObjectPath), DBusError\>\>, DBusError\>  
    * pub async fn subscribe\_prepare\_for\_sleep(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<bool, DBusError\>\>, DBusError\> Das PrepareForSleep-Signal ist von besonderer Bedeutung. Wenn start\_or\_stop true ist, kündigt dies einen bevorstehenden Suspend- oder Hibernate-Vorgang an.10 Die Desktop-Umgebung muss darauf reagieren, indem sie beispielsweise den Bildschirm sperrt, laufende Anwendungen benachrichtigt (falls ein entsprechendes Protokoll existiert) und kritische Zustände sichert. Bei false signalisiert es das Aufwachen des Systems, woraufhin der Desktop entsperrt und Dienste reaktiviert werden können.  
    * pub async fn subscribe\_session\_lock(\&self, session\_path: zbus::zvariant::OwnedObjectPath) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<(), DBusError\>\>, DBusError\>: Abonniert das Lock-Signal des spezifischen Session-Objekts.  
    * pub async fn subscribe\_session\_unlock(\&self, session\_path: zbus::zvariant::OwnedObjectPath) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<(), DBusError\>\>, DBusError\>: Abonniert das Unlock-Signal des spezifischen Session-Objekts.  
* **Implementierungsschritte**: Analog zu UPowerClient. Besondere Aufmerksamkeit gilt der korrekten Handhabung der PrepareForSleep-Signale und der Interaktion mit den Session-spezifischen Lock/Unlock-Signalen.  
* **Publisher/Subscriber**:  
  * Publisher: org.freedesktop.login1 D-Bus Dienst.  
  * Subscriber: LogindClient.

### **5\. Submodul: system::dbus::networkmanager\_client – NetworkManager D-Bus Client**

Dieser Client interagiert mit org.freedesktop.NetworkManager, um Netzwerkinformationen abzurufen und auf Zustandsänderungen zu reagieren. Diese Informationen sind sowohl für die UI-Darstellung als auch für KI-Funktionen (z.B. Online-Status-Prüfung) relevant.

* **Dateien**: system/dbus/networkmanager\_client.rs, system/dbus/networkmanager\_types.rs  
* **Spezifikation (networkmanager\_types.rs)**:  
  * pub enum NetworkManagerState { Unknown \= 0, Asleep \= 10, Disconnected \= 20, Disconnecting \= 30, Connecting \= 40, ConnectedLocal \= 50, ConnectedSite \= 60, ConnectedGlobal \= 70 } (Werte gemäß NMState aus der NetworkManager-Dokumentation).  
  * pub enum NetworkDeviceType { Unknown \= 0, Ethernet \= 1, Wifi \= 2, Wimax \= 5, Modem \= 6, Bluetooth \= 7, /\*... weitere Typen... \*/ } (Werte gemäß NMDeviceType).  
  * pub enum NetworkConnectivityState { Unknown \= 0, None \= 1, Portal \= 2, Limited \= 3, Full \= 4 } (Werte gemäß NMConnectivityState).  
  * pub struct NetworkDevice { pub object\_path: zbus::zvariant::OwnedObjectPath, pub interface: String, pub ip\_interface: String, pub driver: String, pub device\_type: NetworkDeviceType, pub state: u32, /\* NMDeviceState \*/ pub available\_connections: Vec\<zbus::zvariant::OwnedObjectPath\>, pub managed: bool, pub firmare\_missing: bool, pub plugged: bool, /\*... weitere Felder... \*/ }.  
  * pub struct ActiveConnection { pub object\_path: zbus::zvariant::OwnedObjectPath, pub connection\_object\_path: zbus::zvariant::OwnedObjectPath, pub specific\_object\_path: zbus::zvariant::OwnedObjectPath, pub id: String, pub uuid: String, pub conn\_type: String, pub devices: Vec\<zbus::zvariant::OwnedObjectPath\>, pub state: u32, /\* NMActiveConnectionState \*/ pub default: bool, pub default6: bool, pub vpn: bool, /\*... weitere Felder... \*/ }.  
  * pub struct NetworkManagerProperties { pub state: NetworkManagerState, pub connectivity: NetworkConnectivityState, pub wireless\_enabled: bool, pub wwan\_enabled: bool, pub active\_connections: Vec\<zbus::zvariant::OwnedObjectPath\>, /\*... \*/ }.  
* **Spezifikation (networkmanager\_client.rs)**:  
  * **Proxy-Definitionen**:  
    * NetworkManagerProxy für org.freedesktop.NetworkManager auf /org/freedesktop/NetworkManager.  
      * Methoden: GetDevices() \-\> zbus::Result\<Vec\<zbus::zvariant::OwnedObjectPath\>\>, GetActiveConnections() \-\> zbus::Result\<Vec\<zbus::zvariant::OwnedObjectPath\>\>, ActivateConnection(connection: \&zbus::zvariant::ObjectPath\<'\_\>, device: \&zbus::zvariant::ObjectPath\<'\_\>, specific\_object: \&zbus::zvariant::ObjectPath\<'\_\>) \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath\>.  
      * Properties: State: u32, Connectivity: u32, WirelessEnabled: bool, WwanEnabled: bool, ActiveConnections: Vec\<zbus::zvariant::OwnedObjectPath\>.  
      * Signale: StateChanged(state: u32), DeviceAdded(device\_path: zbus::zvariant::OwnedObjectPath), DeviceRemoved(device\_path: zbus::zvariant::OwnedObjectPath).  
    * NMDeviceProxy für org.freedesktop.NetworkManager.Device (Pfad variabel).  
      * Properties: Udi: String, Interface: String, IpInterface: String, Driver: String, DeviceType: u32, State: u32, Managed: bool, AvailableConnections: Vec\<zbus::zvariant::OwnedObjectPath\>, FirmwareMissing: bool, Plugged: bool.  
    * NMActiveConnectionProxy für org.freedesktop.NetworkManager.Connection.Active (Pfad variabel).  
      * Properties: Connection: zbus::zvariant::OwnedObjectPath, SpecificObject: zbus::zvariant::OwnedObjectPath, Id: String, Uuid: String, Type: String, Devices: Vec\<zbus::zvariant::OwnedObjectPath\>, State: u32, Default: bool, Default6: bool, Vpn: bool.  
  * **Struktur**: NetworkManagerClient  
    * Felder: connection\_manager: Arc\<DBusConnectionManager\>, manager\_proxy\_path: Arc\<zbus::zvariant::ObjectPath\<'static\>\>.  
  * **Methoden** für NetworkManagerClient:  
    * pub async fn new(conn\_manager: Arc\<DBusConnectionManager\>) \-\> Result\<Self, DBusError\>  
    * async fn get\_manager\_proxy(\&self) \-\> Result\<NetworkManagerProxy\<'\_\>, DBusError\>  
    * async fn get\_device\_proxy\<'a\>(\&self, device\_path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<NMDeviceProxy\<'a\>, DBusError\>  
    * async fn get\_active\_connection\_proxy\<'a\>(\&self, ac\_path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<NMActiveConnectionProxy\<'a\>, DBusError\>  
    * pub async fn get\_properties(\&self) \-\> Result\<NetworkManagerProperties, DBusError\>  
    * pub async fn get\_devices(\&self) \-\> Result\<Vec\<NetworkDevice\>, DBusError\>: Ruft Pfade über GetDevices ab, dann für jeden Pfad die Details über NMDeviceProxy.  
    * pub async fn get\_active\_connections(\&self) \-\> Result\<Vec\<ActiveConnection\>, DBusError\>: Ruft Pfade über GetActiveConnections ab, dann für jeden Pfad die Details über NMActiveConnectionProxy.  
    * pub async fn subscribe\_state\_changed(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<NetworkManagerState, DBusError\>\>, DBusError\>: Abonniert StateChanged, konvertiert u32 in NetworkManagerState.  
    * pub async fn subscribe\_device\_added(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<NetworkDevice, DBusError\>\>, DBusError\>: Abonniert DeviceAdded, ruft dann Details für den neuen Pfad ab.  
    * pub async fn subscribe\_device\_removed(\&self) \-\> Result\<impl futures\_core::Stream\<Item \= Result\<zbus::zvariant::OwnedObjectPath, DBusError\>\>, DBusError\>  
* **Implementierungsschritte**: Analog zu UPowerClient. Die Datenstrukturen müssen die komplexen Informationen von NetworkManager korrekt abbilden.  
* **Publisher/Subscriber**:  
  * Publisher: org.freedesktop.NetworkManager D-Bus Dienst.  
  * Subscriber: NetworkManagerClient.  
* Die reaktive Aktualisierung des Netzwerkstatus bei Signalempfang ist für eine responsive UI und zuverlässige KI-Funktionen von Bedeutung. Änderungen an der Liste der Geräte oder aktiven Verbindungen erfordern, dass der Client die entsprechenden Detailinformationen neu abruft, da die Signale oft nur die Objektpfade der geänderten Entitäten enthalten.

### **6\. Submodul: system::dbus::secrets\_client – Freedesktop Secret Service D-Bus Client**

Dieser Client interagiert mit dem org.freedesktop.secrets-Dienst zum sicheren Speichern und Abrufen von sensiblen Daten wie API-Schlüsseln für Cloud-LLMs.13

* **Dateien**: system/dbus/secrets\_client.rs, system/dbus/secrets\_types.rs  
* **Spezifikation (secrets\_types.rs)**:  
  * pub struct Secret { pub session: zbus::zvariant::OwnedObjectPath, pub parameters: Vec\<u8\>, pub value: Vec\<u8\>, pub content\_type: String }  
  * pub struct SecretItemInfo { pub object\_path: zbus::zvariant::OwnedObjectPath, pub label: String, pub attributes: HashMap\<String, String\>, pub created: u64, pub modified: u64, pub locked: bool }  
  * pub struct SecretCollectionInfo { pub object\_path: zbus::zvariant::OwnedObjectPath, pub label: String, pub created: u64, pub modified: u64, pub locked: bool }  
  * pub enum PromptCompletedResult { Dismissed, Continue(Option\<zbus::zvariant::OwnedValue\> )}  
* **Spezifikation (secrets\_client.rs)**:  
  * **Proxy-Definitionen**:  
    * SecretServiceProxy für org.freedesktop.Secret.Service auf /org/freedesktop/secrets.  
      * Methoden: OpenSession(algorithm: \&str, input: \&zbus::zvariant::Value\<'\_\>) \-\> zbus::Result\<(zbus::zvariant::OwnedValue, zbus::zvariant::OwnedObjectPath)\>, CreateCollection(properties: HashMap\<\&str, \&zbus::zvariant::Value\<'\_\>\>, alias: \&str) \-\> zbus::Result\<(zbus::zvariant::OwnedObjectPath, zbus::zvariant::OwnedObjectPath /\* prompt \*/)\>, SearchItems(attributes: HashMap\<\&str, \&str\>) \-\> zbus::Result\<(Vec\<zbus::zvariant::OwnedObjectPath\>, Vec\<zbus::zvariant::OwnedObjectPath\>) /\* unlocked, locked \*/\>, Unlock(objects: &\[\&zbus::zvariant::ObjectPath\<'\_\>\]) \-\> zbus::Result\<(Vec\<zbus::zvariant::OwnedObjectPath\>, zbus::zvariant::OwnedObjectPath /\* prompt \*/)\>, Lock(objects: &\[\&zbus::zvariant::ObjectPath\<'\_\>\]) \-\> zbus::Result\<(Vec\<zbus::zvariant::OwnedObjectPath\>, zbus::zvariant::OwnedObjectPath /\* prompt \*/)\>, GetSecrets(items: &\[\&zbus::zvariant::ObjectPath\<'\_\>\], session: \&zbus::zvariant::ObjectPath\<'\_\>) \-\> zbus::Result\<HashMap\<zbus::zvariant::OwnedObjectPath, Secret\>\>.  
      * Properties: Collections: Vec\<zbus::zvariant::OwnedObjectPath\>.  
      * Signale: CollectionCreated(collection\_path: zbus::zvariant::OwnedObjectPath), CollectionChanged(collection\_path: zbus::zvariant::OwnedObjectPath), CollectionDeleted(collection\_path: zbus::zvariant::OwnedObjectPath).  
    * SecretCollectionProxy für org.freedesktop.Secret.Collection (Pfad variabel).  
      * Methoden: CreateItem(properties: HashMap\<\&str, \&zbus::zvariant::Value\<'\_\>\>, secret: \&Secret, replace: bool) \-\> zbus::Result\<(zbus::zvariant::OwnedObjectPath /\* item \*/, zbus::zvariant::OwnedObjectPath /\* prompt \*/)\>, SearchItems(attributes: HashMap\<\&str, \&str\>) \-\> zbus::Result\<Vec\<zbus::zvariant::OwnedObjectPath\>\>, Delete() \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath /\* prompt \*/\>.  
      * Properties: Label: String, Created: u64, Modified: u64, Locked: bool, Items: Vec\<zbus::zvariant::OwnedObjectPath\>.  
    * SecretItemProxy für org.freedesktop.Secret.Item (Pfad variabel).  
      * Methoden: GetSecret(session: \&zbus::zvariant::ObjectPath\<'\_\>) \-\> zbus::Result\<Secret\>, SetSecret(secret: \&Secret) \-\> zbus::Result\<()\>, Delete() \-\> zbus::Result\<zbus::zvariant::OwnedObjectPath /\* prompt \*/\>.  
      * Properties: Label: String, Attributes: HashMap\<String, String\>, Created: u64, Modified: u64, Locked: bool.  
    * SecretPromptProxy für org.freedesktop.Secret.Prompt (Pfad variabel).  
      * Methoden: Prompt(window\_id: \&str) \-\> zbus::Result\<()\>  
      * Signale: Completed(dismissed: bool, result: zbus::zvariant::Value\<'static\>)  
  * **Struktur**: SecretsClient  
    * Felder: connection\_manager: Arc\<DBusConnectionManager\>, service\_proxy\_path: Arc\<zbus::zvariant::ObjectPath\<'static\>\>.  
  * **Methoden** für SecretsClient:  
    * pub async fn new(conn\_manager: Arc\<DBusConnectionManager\>) \-\> Result\<Self, DBusError\>  
    * async fn get\_service\_proxy(\&self) \-\> Result\<SecretServiceProxy\<'\_\>, DBusError\>  
    * async fn get\_collection\_proxy\<'a\>(\&self, path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<SecretCollectionProxy\<'a\>, DBusError\>  
    * async fn get\_item\_proxy\<'a\>(\&self, path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<SecretItemProxy\<'a\>, DBusError\>  
    * async fn get\_prompt\_proxy\<'a\>(\&self, path: &'a zbus::zvariant::ObjectPath\<'\_\>) \-\> Result\<SecretPromptProxy\<'a\>, DBusError\>  
    * pub async fn open\_session(\&self) \-\> Result\<zbus::zvariant::OwnedObjectPath /\* session\_path \*/, DBusError\>: Verwendet "plain" Algorithmus und leeren Input.  
    * pub async fn get\_default\_collection(\&self) \-\> Result\<zbus::zvariant::OwnedObjectPath, DBusError\>: Sucht nach der Collection mit Alias "default" oder erstellt sie.  
    * pub async fn store\_secret(\&self, collection\_path: \&zbus::zvariant::ObjectPath\<'\_\>, label: \&str, secret\_value: &\[u8\], attributes: HashMap\<String, String\>, session\_path: \&zbus::zvariant::ObjectPath\<'\_\>, window\_id\_provider: impl Fn() \-\> String \+ Send \+ Sync) \-\> Result\<zbus::zvariant::OwnedObjectPath, DBusError\>: Erstellt ein Secret-Struct, ruft CreateItem auf der Collection auf. Behandelt den zurückgegebenen Prompt-Pfad mit handle\_prompt\_if\_needed.  
    * pub async fn retrieve\_secret(\&self, item\_path: \&zbus::zvariant::ObjectPath\<'\_\>, session\_path: \&zbus::zvariant::ObjectPath\<'\_\>, window\_id\_provider: impl Fn() \-\> String \+ Send \+ Sync) \-\> Result\<Option\<Vec\<u8\>\>, DBusError\>: Ruft GetSecret auf dem Item auf. Falls das Item oder die Collection gesperrt ist, wird Unlock auf dem Service-Proxy versucht, was einen Prompt auslösen kann.  
    * pub async fn search\_items(\&self, attributes: HashMap\<String, String\>) \-\> Result\<Vec\<SecretItemInfo\>, DBusError\>: Ruft SearchItems auf dem Service-Proxy auf, dann für jeden gefundenen Pfad die Properties vom SecretItemProxy.  
    * async fn handle\_prompt\_if\_needed(\&self, prompt\_path: \&zbus::zvariant::ObjectPath\<'\_\>, window\_id\_provider: impl Fn() \-\> String \+ Send \+ Sync) \-\> Result\<PromptCompletedResult, DBusError\>: Diese Methode ist zentral für die Benutzerinteraktion. Wenn prompt\_path nicht "/" ist (was "kein Prompt nötig" bedeutet), wird ein SecretPromptProxy erstellt. Prompt(window\_id) wird aufgerufen, wobei window\_id von der UI-Schicht über window\_id\_provider dynamisch bereitgestellt wird. Anschließend wird auf das Completed-Signal des Prompts gewartet. Das Ergebnis des Signals (dismissed, result) wird in PromptCompletedResult umgewandelt. Die Notwendigkeit einer window\_id für Prompts erfordert eine enge Kopplung oder einen Callback-Mechanismus mit der UI-Schicht, da die Systemschicht selbst keine Fensterkonzepte oder \-IDs direkt verwaltet.  
* **Implementierungsschritte**: Definition der Typen, Generierung der Proxies. Besondere Sorgfalt ist beim Management von Sessions und der Handhabung von Prompts geboten. Der secret-service-rs Crate 13 kann als Referenz für die korrekte Implementierung der komplexen Abläufe dienen.  
* **Publisher/Subscriber**:  
  * Publisher: org.freedesktop.secrets D-Bus Dienst.  
  * Subscriber: SecretsClient.

### **7\. Submodul: system::dbus::policykit\_client – PolicyKit D-Bus Client**

Dieser Client interagiert mit org.freedesktop.PolicyKit1.Authority zur Überprüfung von Berechtigungen für privilegierte Aktionen \[User Query III.11\].

* **Dateien**: system/dbus/policykit\_client.rs, system/dbus/policykit\_types.rs  
* **Spezifikation (policykit\_types.rs)**:  
  * Bitflags-Struktur PolicyKitCheckAuthFlags:  
    * None \= 0  
    * AllowUserInteraction \= 1  
    * NoUserInteraction \= 2 (obwohl AllowUserInteraction \= false dasselbe bewirkt)  
    * AllowDowngrade \= 4  
    * RetainAuthorization \= 8  
  * pub struct PolicyKitSubject\<'a\> { pub kind: &'a str, pub details: HashMap\<&'a str, zbus::zvariant::Value\<'a\>\> } (z.B. kind \= "unix-process", details \= {"pid" \-\> Value::U32(self\_pid)}).  
  * pub struct PolicyKitAuthorizationResult { pub is\_authorized: bool, pub is\_challenge: bool, pub details: HashMap\<String, zbus::zvariant::OwnedValue\> }  
* **Spezifikation (policykit\_client.rs)**:  
  * **Proxy-Definition**:  
    * PolicyKitAuthorityProxy für org.freedesktop.PolicyKit1.Authority auf /org/freedesktop/PolicyKit1/Authority.  
      * Methoden: CheckAuthorization\<'a\>(subject: PolicyKitSubject\<'a\>, action\_id: \&str, details: HashMap\<\&str, \&str\>, flags: u32, cancellation\_id: \&str) \-\> zbus::Result\<PolicyKitAuthorizationResult\>.  
  * **Struktur**: PolicyKitClient  
    * Felder: connection\_manager: Arc\<DBusConnectionManager\>, authority\_proxy\_path: Arc\<zbus::zvariant::ObjectPath\<'static\>\>.  
  * **Methoden** für PolicyKitClient:  
    * pub async fn new(conn\_manager: Arc\<DBusConnectionManager\>) \-\> Result\<Self, DBusError\>  
    * async fn get\_authority\_proxy(\&self) \-\> Result\<PolicyKitAuthorityProxy\<'\_\>, DBusError\>  
    * pub async fn check\_authorization(\&self, subject\_pid: Option\<u32\>, action\_id: \&str, details: HashMap\<String, String\>, allow\_interaction: bool) \-\> Result\<PolicyKitAuthorizationResult, DBusError\>: Erstellt ein PolicyKitSubject. Wenn subject\_pid Some(pid) ist, wird kind \= "unix-process" und details \= {"pid": Value::U32(pid)} verwendet. Andernfalls wird der PID des aktuellen Prozesses verwendet. Setzt die flags basierend auf allow\_interaction. cancellation\_id kann leer sein. Ruft PolicyKitAuthorityProxy::CheckAuthorization auf. Die korrekte Definition des subject ist sicherheitskritisch. Es muss klar sein, im Kontext welcher Entität (der Desktop-Umgebung selbst oder einer anfragenden Anwendung) die Berechtigung geprüft wird.  
* **Implementierungsschritte**: Proxy-Generierung, Implementierung der Client-Methoden. Die subject-Erstellung muss sorgfältig implementiert werden.  
* **Publisher/Subscriber**:  
  * Publisher: org.freedesktop.PolicyKit1.Authority D-Bus Dienst.  
  * Subscriber: PolicyKitClient.

## **B. Modul: system::outputs – Verwaltung der Anzeigeausgänge (Display Output Management)**

Dieses Modul ist für die Erkennung, Konfiguration und Verwaltung von Anzeigeausgängen (Monitoren) zuständig. Es implementiert die serverseitige Logik für die relevanten Wayland-Protokolle (wl\_output, xdg-output-unstable-v1, wlr-output-management-unstable-v1, wlr-output-power-management-unstable-v1) unter Verwendung der Abstraktionen von Smithay.14 Die korrekte Handhabung von Monitorkonfigurationen, Auflösungen, Skalierung und Hotplugging ist entscheidend für eine gute Benutzererfahrung, insbesondere in Multi-Monitor-Umgebungen.

### **1\. Submodul: system::outputs::error – Fehlerbehandlung für Output-Operationen**

Definiert spezifische Fehlertypen für Operationen im Zusammenhang mit Anzeigeausgängen.

* **Datei**: system/outputs/error.rs  
* **Spezifikation**:  
  * Öffentliches Enum OutputError mit thiserror::Error und Debug.  
  * **Varianten**:  
    * \# DeviceAccessFailed { device: String, \#\[source\] source: std::io::Error } (Relevant bei direktem DRM-Zugriff, z.B. über smithay::backend::drm).  
    * \#\[error("Wayland protocol error for '{protocol}': {message}")\] ProtocolError { protocol: String, message: String } (Für Fehler bei der Implementierung von Wayland-Protokollen).  
    * \#\[error("Output configuration conflict: {details}")\] ConfigurationConflict { details: String } (Wenn eine angeforderte Konfiguration nicht angewendet werden kann).  
    * \#\[error("Failed to create Wayland resource '{resource}': {reason}")\] ResourceCreationFailed { resource: String, reason: String }.  
    * \# SmithayOutputError { \#\[source\] source: smithay::output::OutputError } (Falls Smithay spezifische Fehler für smithay::output::Output-Operationen definiert).  
    * \#\[error("Output '{name}' not found")\] OutputNotFound { name: String }.  
    * \#\[error("Mode not supported by output '{output\_name}'")\] ModeNotSupported { output\_name: String, mode\_details: String }.  
* **Implementierungsschritte**: Definition des Enums, \#\[error(...)\]-Attribute und From-Implementierungen für zugrundeliegende Fehler (z.B. std::io::Error).

### **2\. Submodul: system::outputs::output\_device – Kernrepräsentation eines Anzeigeausgangs**

Diese Struktur kapselt den Zustand und die Logik eines einzelnen physischen Anzeigeausgangs.

* **Datei**: system/outputs/output\_device.rs  
* **Spezifikation**:  
  * **Struktur**: OutputDevice  
    * Felder:  
      * name: String (Eindeutiger Name des Outputs, z.B. "DP-1", "HDMI-A-2").  
      * smithay\_output: smithay::output::Output 15: Die Kernabstraktion von Smithay für einen Output. Enthält physische Eigenschaften, aktuelle und bevorzugte Modi.  
      * wl\_output\_global: Option\<wayland\_server::backend::GlobalId\>: Die ID des wl\_output-Globals, das diesen physischen Output repräsentiert.  
      * xdg\_output\_global: Option\<wayland\_server::backend::GlobalId\>: Die ID des zxdg\_output\_v1-Globals.  
      * wlr\_head\_global: Option\<wayland\_server::backend::GlobalId\>: Die ID des zwlr\_output\_head\_v1-Globals (für wlr-output-management).  
      * wlr\_power\_global: Option\<wayland\_server::backend::GlobalId\>: Die ID des zwlr\_output\_power\_v1-Globals (für wlr-output-power-management).  
      * enabled: bool: Gibt an, ob der Output aktuell aktiviert ist.  
      * current\_dpms\_state: DpmsState: Enum für den DPMS-Zustand (On, Standby, Suspend, Off).  
      * pending\_config\_serial: Option\<u32\>: Das Serial einer laufenden wlr-output-management-Konfiguration.  
  * **Struktur**: OutputDevicePendingState (für wlr-output-management)  
    * Felder: mode: Option\<smithay::output::Mode\>, position: Option\<smithay::utils::Point\<i32, smithay::utils::Logical\>\>, transform: Option\<smithay::utils::Transform\>, scale: Option\<f64\>, enabled: Option\<bool\>, adaptive\_sync\_enabled: Option\<bool\>.  
  * **Enum**: DpmsState { On, Standby, Suspend, Off }  
  * **Methoden** für OutputDevice:  
    * pub fn new(name: String, physical\_properties: smithay::output::PhysicalProperties, preferred\_mode: Option\<smithay::output::Mode\>, possible\_modes: Vec\<smithay::output::Mode\>, display\_handle: \&wayland\_server::DisplayHandle, compositor\_state: \&mut YourCompositorState) \-\> Result\<Self, OutputError\>: Erstellt ein neues OutputDevice. Initialisiert self.smithay\_output \= smithay::output::Output::new(name.clone(), physical\_properties.clone());. Fügt die possible\_modes und preferred\_mode zum smithay\_output hinzu (add\_mode(), set\_preferred\_mode()). Setzt einen initialen Zustand (z.B. bevorzugter Modus, Position (0,0), normale Transformation, Skalierung 1.0) via self.apply\_state\_internal(...). Das Erstellen der Globals (wl\_output\_global, xdg\_output\_global, etc.) erfolgt typischerweise durch den OutputManager oder die jeweiligen Protokoll-Handler, nicht direkt im Konstruktor des OutputDevice, da dies den globalen Display-Zustand modifiziert.  
    * pub fn name(\&self) \-\> \&str  
    * pub fn smithay\_output(\&self) \-\> \&smithay::output::Output  
    * pub fn current\_mode(\&self) \-\> Option\<smithay::output::Mode\>: Gibt den aktuellen Modus aus smithay\_output.current\_mode() zurück.  
    * pub fn current\_transform(\&self) \-\> smithay::utils::Transform: Gibt die aktuelle Transformation aus smithay\_output.current\_transform() zurück.  
    * pub fn current\_scale(\&self) \-\> smithay::output::Scale: Gibt die aktuelle Skalierung aus smithay\_output.current\_scale() zurück.  
    * pub fn current\_position(\&self) \-\> smithay::utils::Point\<i32, smithay::utils::Logical\>: Gibt die aktuelle Position aus smithay\_output.current\_position() zurück.  
    * pub fn is\_enabled(\&self) \-\> bool  
    * pub fn apply\_state(\&mut self, mode: Option\<smithay::output::Mode\>, transform: Option\<smithay::utils::Transform\>, scale: Option\<smithay::output::Scale\>, position: Option\<smithay::utils::Point\<i32, smithay::utils::Logical\>\>, enabled: bool) \-\> Result\<(), OutputError\>: Interne Methode, die self.smithay\_output.change\_current\_state(mode, transform, scale, position) aufruft.15 Aktualisiert self.enabled. Wenn enabled false ist, wird None für mode an change\_current\_state übergeben. Smithay sendet die wl\_output und xdg\_output Events (geometry, mode, scale, done, logical\_position, logical\_size) automatisch.  
    * pub fn set\_dpms\_state(\&mut self, state: DpmsState) \-\> Result\<(), OutputError\>: Ändert den DPMS-Zustand des Outputs (z.B. über DRM). Aktualisiert self.current\_dpms\_state. Löst ggf. Events für wlr-output-power-management aus.  
    * pub fn supported\_modes(\&self) \-\> Vec\<smithay::output::Mode\>: Gibt self.smithay\_output.modes() zurück.  
    * pub fn physical\_properties(\&self) \-\> smithay::output::PhysicalProperties: Gibt self.smithay\_output.physical\_properties() zurück.  
    * pub fn add\_mode(\&mut self, mode: smithay::output::Mode): Fügt einen Modus zu self.smithay\_output hinzu.  
    * pub fn set\_preferred\_mode(\&mut self, mode: smithay::output::Mode): Setzt den bevorzugten Modus in self.smithay\_output.  
    * Methoden zum Setzen und Abrufen der Global-IDs (wl\_output\_global, xdg\_output\_global, etc.).  
    * pub fn destroy\_globals(\&mut self, display\_handle: \&wayland\_server::DisplayHandle): Entfernt alle zugehörigen Globals vom DisplayHandle.  
* **Implementierungsschritte**:  
  1. Definiere OutputDevice, OutputDevicePendingState und DpmsState.  
  2. Implementiere new(): Initialisiert smithay::output::Output korrekt.  
  3. Implementiere apply\_state(): Ruft smithay\_output.change\_current\_state() auf.  
  4. Implementiere set\_dpms\_state(): Interagiert mit der DRM-Schicht oder dem entsprechenden Backend, um den Energiezustand zu ändern.

### **3\. Submodul: system::outputs::manager – Zentrales Management der Anzeigeausgänge**

Der OutputManager verwaltet eine Liste aller bekannten OutputDevice-Instanzen und behandelt Hotplug-Events.

* **Datei**: system/outputs/manager.rs  
* **Spezifikation**:  
  * **Struktur**: OutputManager  
    * Felder: outputs: HashMap\<String, Arc\<Mutex\<OutputDevice\>\>\> (HashMap mit Output-Name als Schlüssel), udev\_event\_source\_token: Option\<calloop::RegistrationToken\> (falls udev verwendet wird). Die Verwendung von Arc\<Mutex\<OutputDevice\>\> ist hier geboten, da OutputDevice-Instanzen von verschiedenen Teilen des Systems (z.B. DRM-Event-Handler, Wayland-Dispatcher für wlr-output-management, D-Bus-Handler für Power-Events) potenziell nebenläufig modifiziert werden könnten. Arc ermöglicht das Teilen des Besitzes, und Mutex stellt den exklusiven Zugriff für Schreiboperationen sicher, um Datenkonsistenz zu gewährleisten.5  
  * **Enum**: HotplugEvent  
    * DeviceAdded { name: String, path: std::path::PathBuf, physical\_properties: smithay::output::PhysicalProperties, modes: Vec\<smithay::output::Mode\>, preferred\_mode: Option\<smithay::output::Mode\>, enabled: bool, is\_drm: bool, drm\_device\_fd: Option\<std::os::unix::io::OwnedFd\> /\* nur wenn is\_drm true \*/ }  
    * DeviceRemoved { name: String }  
  * **Methoden** für OutputManager:  
    * pub fn new() \-\> Self  
    * pub fn add\_output(\&mut self, output\_device: Arc\<Mutex\<OutputDevice\>\>): Fügt ein OutputDevice zur outputs-Map hinzu.  
    * pub fn remove\_output(\&mut self, name: \&str, display\_handle: \&wayland\_server::DisplayHandle) \-\> Option\<Arc\<Mutex\<OutputDevice\>\>\>: Entfernt ein OutputDevice anhand seines Namens, zerstört dessen Globals und gibt es zurück.  
    * pub fn find\_output\_by\_name(\&self, name: \&str) \-\> Option\<Arc\<Mutex\<OutputDevice\>\>\>  
    * pub fn all\_outputs(\&self) \-\> Vec\<Arc\<Mutex\<OutputDevice\>\>\>: Gibt eine geklonte Liste aller Arc\<Mutex\<OutputDevice\>\> zurück.  
    * pub fn handle\_hotplug\_event(\&mut self, event: HotplugEvent, display\_handle: \&wayland\_server::DisplayHandle, compositor\_state: \&mut YourCompositorState) \-\> Result\<(), OutputError\>: Verarbeitet Hotplug-Events. Bei DeviceAdded: 1\. Prüft, ob ein Output mit diesem Namen bereits existiert. 2\. Erstellt ein neues OutputDevice mit den übergebenen Eigenschaften. 3\. Ruft output\_device\_created\_notifications auf, um die notwendigen Globals zu erstellen und Handler zu informieren. 4\. Fügt das neue OutputDevice zur outputs-Map hinzu. Bei DeviceRemoved: 1\. Sucht das OutputDevice anhand des Namens. 2\. Ruft output\_device\_removed\_notifications auf, um Globals zu zerstören und Handler zu informieren. 3\. Entfernt das OutputDevice aus der outputs-Map. Die Hotplug-Logik ist stark abhängig vom verwendeten Backend. Bei einem DRM/udev-Backend kommen die Events vom UdevBackend 18, die dann in HotplugEvent übersetzt werden müssen.  
    * fn output\_device\_created\_notifications(\&self, output\_device: \&Arc\<Mutex\<OutputDevice\>\>, display\_handle: \&wayland\_server::DisplayHandle, compositor\_state: \&mut YourCompositorState): Private Hilfsmethode. Erstellt wl\_output, zxdg\_output\_v1 und zwlr\_output\_head\_v1 Globals für das neue Gerät. Benachrichtigt die WlrOutputManagementState und WlrOutputPowerManagementState über das neue Gerät.  
    * fn output\_device\_removed\_notifications(\&self, output\_device: \&Arc\<Mutex\<OutputDevice\>\>, display\_handle: \&wayland\_server::DisplayHandle, compositor\_state: \&mut YourCompositorState): Private Hilfsmethode. Zerstört die Globals des entfernten Geräts. Benachrichtigt die relevanten Handler.  
* **Implementierungsschritte**:  
  1. Definiere OutputManager und HotplugEvent.  
  2. Implementiere CRUD-Methoden für OutputDevice-Instanzen.  
  3. Implementiere handle\_hotplug\_event. Die genaue Quelle der HotplugEvents (z.B. Udev-Integration) muss hier berücksichtigt werden.  
  4. Implementiere die ...\_notifications-Hilfsmethoden, um die Erstellung/Zerstörung von Globals und die Benachrichtigung anderer Handler zu zentralisieren.

### **4\. Submodul: system::outputs::wl\_output\_handler – Implementierung des wl\_output Protokolls**

Die Logik für wl\_output wird durch Smithays Output-Typ und den OutputHandler-Trait gehandhabt.15

* **Datei**: Integration in den globalen Compositor-Zustand und system::outputs::manager.rs.  
* **Spezifikation**:  
  * **Smithay Integration**:  
    * Der globale Compositor-Zustand (YourCompositorState) implementiert smithay::wayland::output::OutputHandler.  
    * smithay::delegate\_output\!(YourCompositorState); muss im globalen Zustand deklariert werden.  
    * Beim Hinzufügen eines neuen physischen Outputs im OutputManager::handle\_hotplug\_event (oder einer ähnlichen Funktion) wird für das neue OutputDevice (welches ein smithay::output::Output enthält) die Methode output\_dev.smithay\_output().create\_global::\<YourCompositorState\>(display\_handle) aufgerufen.15 Die zurückgegebene GlobalId wird im OutputDevice::wl\_output\_global gespeichert.  
  * **Implementierung des OutputHandler-Traits für YourCompositorState**:  
    * fn output\_state(\&mut self) \-\> \&mut smithay::wayland::output::OutputManagerState: Gibt eine Referenz zum OutputManagerState des Compositors zurück. Dieser OutputManagerState wird typischerweise im globalen Zustand des Compositors gehalten und bei der Initialisierung mit OutputManagerState::new() oder OutputManagerState::new\_with\_xdg\_output() 15 erstellt.  
    * fn new\_output(\&mut self, \_output: \&smithay::reexports::wayland\_server::protocol::wl\_output::WlOutput, \_output\_data: \&smithay::wayland::output::OutputData): Diese Methode wird aufgerufen, wenn ein Client an ein wl\_output-Global bindet. Hier kann client-spezifischer Zustand initialisiert werden, falls nötig. OutputData enthält eine Referenz zum smithay::output::Output.  
    * fn output\_destroyed(\&mut self, \_output: \&smithay::reexports::wayland\_server::protocol::wl\_output::WlOutput, \_output\_data: \&smithay::wayland::output::OutputData): Wird aufgerufen, wenn ein wl\_output-Global zerstört wird.  
  * Smithay sendet geometry, mode, scale, done Events an wl\_output-Clients automatisch, wenn Output::change\_current\_state() auf dem entsprechenden smithay::output::Output aufgerufen wird.15  
* **Implementierungsschritte**:  
  1. Stelle sicher, dass der globale Compositor-Zustand (YourCompositorState) ein Feld für OutputManagerState hat und den OutputHandler-Trait implementiert.  
  2. Integriere den Aufruf von smithay\_output().create\_global() in die Logik, die neue OutputDevice-Instanzen erstellt (z.B. in OutputManager::output\_device\_created\_notifications).  
  3. Implementiere die Methoden des OutputHandler-Traits. Oftmals ist hier keine spezifische Logik notwendig, da Smithay vieles übernimmt.

### **5\. Submodul: system::outputs::wlr\_output\_management\_handler – Implementierung des wlr-output-management-unstable-v1 Protokolls**

Dieses Submodul implementiert die serverseitige Logik für das wlr-output-management-unstable-v1-Protokoll, das es Clients (wie kanshi 19) ermöglicht, Display-Konfigurationen abzufragen und zu ändern.20

* **Dateien**: system/outputs/wlr\_output\_management/mod.rs, system/outputs/wlr\_output\_management/manager\_handler.rs, system/outputs/wlr\_output\_management/head\_handler.rs, system/outputs/wlr\_output\_management/mode\_handler.rs, system/outputs/wlr\_output\_management/configuration\_handler.rs  
* **Protokoll-Objekte**: zwlr\_output\_manager\_v1, zwlr\_output\_head\_v1, zwlr\_output\_mode\_v1, zwlr\_output\_configuration\_v1, zwlr\_output\_configuration\_head\_v1.  
* **Spezifikation**:  
  * **Struktur**: WlrOutputManagementState (im globalen Compositor-Zustand)  
    * Felder:  
      * output\_manager: Arc\<Mutex\<OutputManager\>\> (Referenz zum globalen OutputManager).  
      * configurations: HashMap\<wayland\_server::backend::ObjectId, Arc\<Mutex\<OutputConfigurationRequest\>\>\> (speichert laufende Konfigurationsanfragen, Schlüssel ist die ID des zwlr\_output\_configuration\_v1-Objekts).  
      * global\_serial: std::sync::atomic::AtomicU32 (für die done-Events des Managers).  
  * **Struktur**: OutputConfigurationRequest  
    * Felder: serial: u32 (Serial, mit dem die Konfiguration erstellt wurde), client: wayland\_server::Client, pending\_changes: HashMap\<String /\* OutputDevice name \*/, HeadChangeRequest\>, config\_resource: wayland\_server::Resource\<ZwlrOutputConfigurationV1\>.  
  * **Struktur**: HeadChangeRequest  
    * Felder: mode: Option\<smithay::output::Mode\>, position: Option\<smithay::utils::Point\<i32, smithay::utils::Logical\>\>, transform: Option\<smithay::utils::Transform\>, scale: Option\<f64\>, enabled: Option\<bool\>, adaptive\_sync\_enabled: Option\<bool\>.  
  * **User Data Structs**:  
    * WlrOutputManagerGlobalData { output\_manager\_state: Weak\<Mutex\<WlrOutputManagementState\>\> } (für zwlr\_output\_manager\_v1 Global).  
    * WlrOutputHeadGlobalData { output\_device: Weak\<Mutex\<OutputDevice\>\>, output\_manager\_state: Weak\<Mutex\<WlrOutputManagementState\>\> } (für zwlr\_output\_head\_v1 Ressourcen).  
    * WlrOutputModeGlobalData { mode: smithay::output::Mode } (für zwlr\_output\_mode\_v1 Ressourcen).  
    * WlrOutputConfigurationUserData { id: wayland\_server::backend::ObjectId, output\_manager\_state: Weak\<Mutex\<WlrOutputManagementState\>\> } (für zwlr\_output\_configuration\_v1 Ressourcen).  
    * WlrOutputConfigurationHeadUserData { output\_device\_name: String, config\_request\_id: wayland\_server::backend::ObjectId, output\_manager\_state: Weak\<Mutex\<WlrOutputManagementState\>\> } (für zwlr\_output\_configuration\_head\_v1 Ressourcen).  
  * **Smithay Integration**: Der globale Compositor-Zustand (YourCompositorState) implementiert:  
    * GlobalDispatch\<ZwlrOutputManagerV1, WlrOutputManagerGlobalData\>  
    * Dispatch\<ZwlrOutputManagerV1, WlrOutputManagerGlobalData, YourCompositorState\>  
    * Dispatch\<ZwlrOutputHeadV1, WlrOutputHeadGlobalData, YourCompositorState\>  
    * Dispatch\<ZwlrOutputModeV1, WlrOutputModeGlobalData, YourCompositorState\>  
    * Dispatch\<ZwlrOutputConfigurationV1, WlrOutputConfigurationUserData, YourCompositorState\>  
    * Dispatch\<ZwlrOutputConfigurationHeadV1, WlrOutputConfigurationHeadUserData, YourCompositorState\>  
    * smithay::delegate\_dispatch\!(YourCompositorState:);  
  * **Initialisierung**:  
    * Ein WlrOutputManagementState wird im globalen Compositor-Zustand erstellt.  
    * Ein zwlr\_output\_manager\_v1-Global wird mit display\_handle.create\_global() registriert.  
  * **Anfragebehandlung für zwlr\_output\_manager\_v1 (manager\_handler.rs)**:  
    * bind: Sendet den aktuellen Zustand aller Outputs (Heads und deren Modi) an den Client über die head, mode, done, finished Events des Managers.20  
    * destroy: Standard.  
    * create\_configuration(config\_resource: ZwlrOutputConfigurationV1, serial: u32):  
      1. Erstellt ein neues OutputConfigurationRequest mit dem gegebenen serial und der Client-ID. Speichert es in WlrOutputManagementState::configurations.  
      2. Sendet den aktuellen Zustand aller OutputDevices (als zwlr\_output\_head\_v1-Events: name, description, physical\_size, enabled, current\_mode, position, transform, scale, make, model, serial\_number, adaptive\_sync) und deren unterstützte Modi (als zwlr\_output\_mode\_v1-Events: size, refresh, preferred) an das neue config\_resource.  
      3. Jeder Kopf und Modus erhält eine eigene Ressource (ZwlrOutputHeadV1, ZwlrOutputModeV1), die mit den entsprechenden Daten initialisiert wird.  
      4. Beendet die Sequenz mit zwlr\_output\_head\_v1.done() für jeden Kopf und zwlr\_output\_manager\_v1.done(current\_serial) für den Manager selbst. Der serial-Parameter ist hierbei zentral: Die gesendeten Kopf- und Modusinformationen müssen dem Zustand entsprechen, den der Client mit diesem serial erwartet.  
  * **Anfragebehandlung für zwlr\_output\_configuration\_head\_v1 (configuration\_handler.rs)**:  
    * destroy: Standard.  
    * enable(), disable(): Aktualisiert enabled im HeadChangeRequest des zugehörigen OutputConfigurationRequest.  
    * set\_mode(mode: \&ZwlrOutputModeV1): Speichert den Modus (aus WlrOutputModeGlobalData) im HeadChangeRequest.  
    * set\_custom\_mode(...), set\_position(...), set\_transform(...), set\_scale(...), set\_adaptive\_sync(...): Speichern die angeforderten Änderungen im HeadChangeRequest.  
  * **Anfragebehandlung für zwlr\_output\_configuration\_v1 (configuration\_handler.rs)**:  
    * destroy: Verwirft die Konfigurationsanfrage und entfernt sie aus WlrOutputManagementState::configurations.  
    * apply():  
      1. Überprüft, ob der serial der Konfiguration noch aktuell ist (d.h. ob sich der globale Output-Zustand seit Erstellung der Konfiguration geändert hat, z.B. durch Hotplug). Wenn nicht, sendet cancelled und zerstört die Konfiguration.  
      2. Versucht, alle pending\_changes im OutputConfigurationRequest auf die entsprechenden OutputDevice-Instanzen (via OutputManager) anzuwenden.  
      3. Wenn alle Änderungen erfolgreich sind: Sendet succeeded an den Client und zerstört die Konfiguration. Aktualisiert den globalen OutputManager-Serial und sendet done an alle zwlr\_output\_manager\_v1-Instanzen.  
      4. Wenn Fehler auftreten: Sendet failed an den Client, macht Änderungen rückgängig (falls möglich) und zerstört die Konfiguration.  
    * test(): Ähnlich wie apply(), aber ohne die Änderungen tatsächlich anzuwenden. Validiert die Konfiguration.  
  * **Event-Generierung**: Der OutputManager (oder eine dedizierte Komponente) muss bei Änderungen am Output-Zustand (Hotplug, Modusänderung durch andere Quellen) die head, mode, done, finished Events an alle gebundenen zwlr\_output\_manager\_v1-Instanzen senden und den globalen Serial erhöhen.  
* **Implementierungsschritte**:  
  1. Definiere die Zustands- und UserData-Strukturen.  
  2. Implementiere GlobalDispatch für ZwlrOutputManagerV1.  
  3. Implementiere Dispatch für alle relevanten Protokollobjekte.  
  4. Die apply/test-Logik muss sorgfältig implementiert werden, um Atomarität (oder zumindest Fehlererkennung und \-behandlung) und korrekte Serial-Handhabung sicherzustellen.  
  5. Die Benachrichtigung über Änderungen im globalen Output-Zustand an alle Manager-Instanzen ist entscheidend. Dies kann über einen Listener-Mechanismus oder Callbacks im OutputManager erfolgen.  
* **Tabelle: WLR-Output-Management Protokoll Interaktionen**

| Client Aktion | Server Reaktion (Requests an Client, Events an Client) | Betroffene Zustände (Server) |
| :---- | :---- | :---- |
| Bindet an zwlr\_output\_manager\_v1 | Für jeden Output: head (mit Name, Desc, etc.), mode (für jeden Modus), enabled, current\_mode, position, etc. done (pro Kopf). Dann done(serial) vom Manager. | WlrOutputManagementState (neuer Client registriert), global\_serial |
| create\_configuration(serial) | Erstellt zwlr\_output\_configuration\_v1. Sendet aktuellen Output-Zustand (Heads, Modi) an diese Konfigurationsinstanz. | WlrOutputManagementState::configurations (neue Anfrage hinzugefügt) |
| zwlr\_output\_configuration\_head\_v1.set\_X(...) | Keine direkten Events an Client. | OutputConfigurationRequest::pending\_changes aktualisiert. |
| zwlr\_output\_configuration\_v1.apply() | Wenn serial aktuell & Konfig gültig: succeeded. Dann head/mode/done Events vom Manager mit neuem globalen Serial. Wenn serial veraltet: cancelled. Wenn Konfig ungültig: failed. | OutputManager::outputs (Zustand der OutputDevices geändert), global\_serial erhöht. WlrOutputManagementState::configurations (Anfrage entfernt). |
| zwlr\_output\_configuration\_v1.test() | Wenn serial aktuell & Konfig gültig: succeeded. Wenn serial veraltet: cancelled. Wenn Konfig ungültig: failed. | WlrOutputManagementState::configurations (Anfrage entfernt). Keine Zustandsänderung an Outputs. |
| Hotplug (z.B. Monitor angeschlossen/abgezogen) | An alle zwlr\_output\_manager\_v1: head (für neuen Output) / finished (für entfernten Output), done(new\_serial). | OutputManager::outputs aktualisiert, global\_serial erhöht. Laufende Konfigurationen werden bei nächstem apply/test als cancelled markiert. |

Diese Tabelle verdeutlicht die komplexen Interaktionsflüsse und die Bedeutung der Serial-Nummern für die Zustandssynchronisation zwischen Client und Compositor.

### **6\. Submodul: system::outputs::wlr\_output\_power\_management\_handler – Implementierung des wlr-output-power-management-unstable-v1 Protokolls**

Dieses Submodul implementiert die serverseitige Logik für das wlr-output-power-management-unstable-v1-Protokoll, das es Clients erlaubt, den Energiezustand von Monitoren zu steuern (z.B. An/Aus).22

* **Dateien**: system/outputs/wlr\_output\_power\_management/mod.rs, system/outputs/wlr\_output\_power\_management/manager\_handler.rs, system/outputs/wlr\_output\_power\_management/power\_control\_handler.rs  
* **Protokoll-Objekte**: zwlr\_output\_power\_manager\_v1, zwlr\_output\_power\_v1.  
* **Spezifikation**:  
  * **Struktur**: WlrOutputPowerManagementState (im globalen Compositor-Zustand)  
    * Felder:  
      * output\_manager: Arc\<Mutex\<OutputManager\>\>  
      * active\_controllers: HashMap\<String /\* OutputDevice name \*/, wayland\_server::Resource\<ZwlrOutputPowerV1\>\>: Speichert den aktiven Controller pro Output-Namen.  
  * **User Data Structs**:  
    * WlrOutputPowerManagerGlobalData { output\_power\_manager\_state: Weak\<Mutex\<WlrOutputPowerManagementState\>\> }.  
    * WlrOutputPowerControlUserData { output\_device\_name: String, output\_power\_manager\_state: Weak\<Mutex\<WlrOutputPowerManagementState\>\> }.  
  * **Smithay Integration**: Der globale Compositor-Zustand (YourCompositorState) implementiert:  
    * GlobalDispatch\<ZwlrOutputPowerManagerV1, WlrOutputPowerManagerGlobalData\>  
    * Dispatch\<ZwlrOutputPowerManagerV1, WlrOutputPowerManagerGlobalData, YourCompositorState\>  
    * Dispatch\<ZwlrOutputPowerV1, WlrOutputPowerControlUserData, YourCompositorState\>  
    * smithay::delegate\_dispatch\!(YourCompositorState:);  
  * **Initialisierung**: Ein WlrOutputPowerManagementState wird im globalen Zustand erstellt. Ein zwlr\_output\_power\_manager\_v1-Global wird registriert.  
  * **Anfragebehandlung für zwlr\_output\_power\_manager\_v1 (manager\_handler.rs)**:  
    * bind: Standard.  
    * destroy: Standard.  
    * get\_output\_power(output\_power\_resource: ZwlrOutputPowerV1, output: \&WlOutput):  
      1. Ermittelt den Namen des OutputDevice, das zum WlOutput gehört (z.B. über UserData des WlOutput).  
      2. Prüft, ob bereits ein aktiver Controller für diesen Output-Namen in active\_controllers existiert.  
      3. Wenn ja: Sendet failed an output\_power\_resource und zerstört es. Es darf nur einen Controller pro Output geben.22  
      4. Wenn nein: Speichert output\_power\_resource in active\_controllers für den Output-Namen. Sendet den aktuellen DPMS-Zustand des OutputDevice als initiales mode-Event an output\_power\_resource.  
  * **Anfragebehandlung für zwlr\_output\_power\_v1 (power\_control\_handler.rs)**:  
    * destroy: Entfernt den Controller aus active\_controllers.  
    * set\_mode(mode: u32):  
      1. Ermittelt das zugehörige OutputDevice anhand des in WlrOutputPowerControlUserData gespeicherten Namens.  
      2. Konvertiert mode (0 für Off, 1 für On 22) in den entsprechenden DpmsState.  
      3. Ruft output\_device.lock().unwrap().set\_dpms\_state(new\_dpms\_state) auf.  
      4. Wenn erfolgreich, sendet mode(mode) an den Client.  
      5. Wenn der Output den Modus nicht unterstützt oder ein anderer Fehler auftritt, sendet failed.  
  * **Event-Generierung**:  
    * Wenn sich der DPMS-Zustand eines OutputDevice ändert (auch extern, z.B. durch Inaktivität), muss der WlrOutputPowerManagementState dies erkennen und das mode-Event an den ggf. existierenden aktiven Controller für diesen Output senden.  
    * Wenn ein OutputDevice entfernt wird, muss ein failed-Event an den zugehörigen Controller gesendet und dieser zerstört werden.  
* **Implementierungsschritte**:  
  1. Definiere die Zustands- und UserData-Strukturen.  
  2. Implementiere GlobalDispatch für ZwlrOutputPowerManagerV1.  
  3. Implementiere Dispatch für ZwlrOutputPowerManagerV1 und ZwlrOutputPowerV1.  
  4. Die set\_mode-Anfrage muss mit der tatsächlichen Hardware-Steuerung (z.B. DRM DPMS über das OutputDevice) interagieren.  
  5. Sicherstellen, dass Änderungen des Power-Modus das mode-Event auslösen und die Exklusivität der Controller gewahrt bleibt.

### **7\. Submodul: system::outputs::xdg\_output\_handler – Implementierung des xdg-output-unstable-v1 Protokolls**

Dieses Submodul implementiert die serverseitige Logik für das xdg-output-unstable-v1-Protokoll, das Clients detailliertere Informationen über die logische Geometrie von Outputs liefert.

* **Datei**: system/outputs/xdg\_output\_handler.rs (kann auch als Integration in wl\_output\_handler oder manager erfolgen).  
* **Protokoll-Objekte**: zxdg\_output\_manager\_v1, zxdg\_output\_v1.  
* **Spezifikation**:  
  * **Smithay Integration**:  
    * Der globale Compositor-Zustand (YourCompositorState) implementiert:  
      * GlobalDispatch\<ZxdgOutputManagerV1, XdgOutputManagerGlobalData\>  
      * Dispatch\<ZxdgOutputManagerV1, XdgOutputManagerGlobalData, YourCompositorState\>  
      * Dispatch\<ZxdgOutputV1, XdgOutputGlobalData, YourCompositorState\>  
      * smithay::delegate\_dispatch\!(YourCompositorState:);  
    * XdgOutputManagerGlobalData { output\_manager: Weak\<Mutex\<OutputManager\>\> }.  
    * XdgOutputGlobalData { output\_device: Weak\<Mutex\<OutputDevice\>\> }.  
    * Die Erstellung der zxdg\_output\_manager\_v1-Globals und zxdg\_output\_v1-Ressourcen kann über Smithay's OutputManagerState::new\_with\_xdg\_output() 15 erfolgen, das automatisch ein zxdg\_output\_v1-Global erstellt, wenn ein wl\_output-Global erstellt wird. Alternativ kann dies manuell im OutputManager::output\_device\_created\_notifications geschehen.  
  * **Initialisierung**: Ein zxdg\_output\_manager\_v1-Global wird registriert.  
  * **Anfragebehandlung für zxdg\_output\_manager\_v1**:  
    * bind: Standard.  
    * destroy: Standard.  
    * get\_xdg\_output(xdg\_output\_resource: ZxdgOutputV1, output: \&WlOutput):  
      1. Ermittelt das OutputDevice, das zum WlOutput gehört.  
      2. Initialisiert xdg\_output\_resource mit den aktuellen logischen Daten des OutputDevice (Position, Größe) und sendet logical\_position, logical\_size, name, description, gefolgt von done.  
  * **Anfragebehandlung für zxdg\_output\_v1**:  
    * destroy: Standard.  
  * **Event-Generierung**:  
    * Wenn sich die logische Position, Größe, der Name oder die Beschreibung eines OutputDevice ändern, müssen die entsprechenden Events (logical\_position, logical\_size, name, description) an alle gebundenen zxdg\_output\_v1-Instanzen gesendet werden, gefolgt von einem done-Event. Dies wird typischerweise von Smithay gehandhabt, wenn Output::change\_current\_state() aufgerufen wird.  
* **Implementierungsschritte**:  
  1. Definiere die UserData-Strukturen.  
  2. Implementiere GlobalDispatch für ZxdgOutputManagerV1.  
  3. Implementiere Dispatch für ZxdgOutputManagerV1 und ZxdgOutputV1.  
  4. Sicherstellen, dass Änderungen an den relevanten OutputDevice-Eigenschaften (Position, Größe, Name, Beschreibung) die korrekten Events auslösen. Smithay's Output-Struktur sollte dies bei korrekter Verwendung von change\_current\_state bereits gewährleisten.

## **III. Implementierungsleitfaden (Implementation Guide)**

A. Allgemeine Hinweise: Die Implementierung aller hier spezifizierten Module und Submodule muss streng den in der technischen Gesamtspezifikation definierten Entwicklungsrichtlinien folgen. Dies umfasst insbesondere:  
\* Coding Style & Formatierung: Verbindliche Nutzung von rustfmt mit Standardkonfiguration und Einhaltung der Rust API Guidelines \[User Query IV.4.1\].  
\* API-Design: Befolgung der Rust API Guidelines Checklist für konsistente und idiomatische Schnittstellen \[User Query IV.4.2\].  
\* Fehlerbehandlung: Konsequente Verwendung des thiserror-Crates zur Definition spezifischer Fehler-Enums pro Modul (DBusError, OutputError) \[User Query IV.4.3\].  
\* Logging & Tracing: Einsatz des tracing-Crate-Frameworks für strukturiertes, kontextbezogenes Logging und Tracing von Operationen \[User Query IV.4.4\].  
B. Detaillierte Schritte pro Sub-Modul: Die oben in den Spezifikationen genannten Implementierungsschritte für jedes Submodul sind als detaillierte Arbeitsanweisungen zu verstehen. Dies beinhaltet:  
\* Strukturen und Enums: Exakte Definition aller Felder mit Typen und Sichtbarkeitsmodifikatoren (pub, pub(crate), private).  
\* Methodenimplementierung: Vollständige Implementierung aller öffentlichen Methoden gemäß den Signaturen. Vor- und Nachbedingungen sind zu beachten. Interne Logik muss robust und fehlerresistent sein.  
\* D-Bus Clients: Die generierten zbus-Proxies sind die primäre Schnittstelle zu den D-Bus-Diensten. Die Client-Wrapper-Klassen (UPowerClient, LogindClient, etc.) müssen die Rohdaten der Proxies in die anwendungsfreundlichen Typen aus den \*\_types.rs-Dateien konvertieren und Fehlerbehandlung durchführen. Signal-Handler müssen asynchron implementiert werden und die empfangenen Daten korrekt parsen.  
\* Wayland Protocol Handler: Die Implementierung der Dispatch- und GlobalDispatch-Traits für die Output-Protokolle erfordert sorgfältiges Management des Zustands, der oft in UserData-Strukturen der Wayland-Ressourcen gespeichert wird. Das korrekte Senden von Events an die Clients als Reaktion auf Anfragen oder Zustandsänderungen ist entscheidend.  
\* Interaktion der Submodule:  
\* Der OutputManager ist die zentrale Verwaltungsinstanz für OutputDevice-Objekte.  
\* Die Wayland-Protokoll-Handler für Outputs (wl\_output\_handler, wlr\_output\_management\_handler, etc.) greifen auf den OutputManager und die darin enthaltenen OutputDevice-Instanzen zu, um Informationen abzufragen oder Konfigurationen anzuwenden.  
\* Beispielsweise wird der wlr\_output\_management\_handler bei einer apply()-Anfrage die gewünschten Änderungen an die entsprechenden OutputDevice-Instanzen im OutputManager weiterleiten. Diese wiederum nutzen ihr internes smithay::output::Output-Objekt, um die Änderungen wirksam zu machen, was dann die notwendigen wl\_output- und xdg\_output-Events auslöst.  
\* Änderungen durch Hotplug-Events, die vom OutputManager verarbeitet werden, müssen Benachrichtigungen an die wlr-output-management und wlr-output-power-management Handler auslösen, damit diese ihre Clients über die geänderte Output-Konfiguration informieren können (z.B. Senden von head und done Events).

## **IV. Anhang (Appendix)**

### **A. D-Bus Schnittstellenübersicht**

Die folgende Tabelle fasst die wichtigsten D-Bus-Dienste zusammen, mit denen die Systemschicht interagiert:  
**Tabelle: D-Bus Service Details**

| Dienstname | Objektpfad (Manager/Service) | Interface (Haupt) | Relevante Methoden/Signale/Properties (Beispiele) | Korrespondierendes system::dbus Submodul |
| :---- | :---- | :---- | :---- | :---- |
| UPower | /org/freedesktop/UPower | org.freedesktop.UPower | EnumerateDevices(), GetDisplayDevice(), OnBattery (Prop), DeviceAdded (Sig), DeviceRemoved (Sig). Für Devices (org.freedesktop.UPower.Device): Type, State, Percentage, TimeToEmpty, TimeToFull (Props).7 | upower\_client |
| systemd-logind | /org/freedesktop/login1 | org.freedesktop.login1.Manager | ListSessions(), LockSession(), UnlockSession(), PrepareForSleep (Sig), SessionNew (Sig), SessionRemoved (Sig). Für Sessions (org.freedesktop.login1.Session): Lock() (Sig), Unlock() (Sig), Active (Prop).10 | logind\_client |
| NetworkManager | /org/freedesktop/NetworkManager | org.freedesktop.NetworkManager | GetDevices(), GetActiveConnections(), State (Prop), Connectivity (Prop), StateChanged (Sig), DeviceAdded (Sig). Für Devices (org.freedesktop.NetworkManager.Device): DeviceType, State (Props). Für Active Connections (org.freedesktop.NetworkManager.Connection.Active): Type, State, Default (Props). | networkmanager\_client |
| Freedesktop Secret Service | /org/freedesktop/secrets | org.freedesktop.Secret.Service | OpenSession(), CreateCollection(), SearchItems(), Unlock(), GetSecrets(), CollectionCreated (Sig). Für Collections (org.freedesktop.Secret.Collection): CreateItem(), Label (Prop). Für Items (org.freedesktop.Secret.Item): GetSecret(), SetSecret(), Label (Prop). Für Prompts (org.freedesktop.Secret.Prompt): Prompt(), Completed (Sig).13 | secrets\_client |
| PolicyKit | /org/freedesktop/PolicyKit1/Authority | org.freedesktop.PolicyKit1.Authority | CheckAuthorization() \[User Query III.11\]. | policykit\_client |

Diese Übersicht dient als Referenz für die spezifischen D-Bus-Interaktionen und deren Implementierungsort innerhalb des system::dbus-Moduls. Sie erleichtert das Verständnis der Abhängigkeiten von externen Systemdiensten.

### **B. Wayland Output Protokollübersicht**

Die folgende Tabelle gibt einen Überblick über die im system::outputs-Modul implementierten Wayland-Protokolle und deren Handler:  
**Tabelle: Wayland Output Protocol Handler**

| Protokollname | Hauptinterface(s) (Server) | Verantwortlicher Handler (Trait/Struktur im Code) | Wichtige Requests (vom Client an Server) | Wichtige Events (vom Server an Client) | Korrespondierendes system::outputs Submodul |
| :---- | :---- | :---- | :---- | :---- | :---- |
| Wayland Core Output | wl\_output | YourCompositorState (implementiert smithay::wayland::output::OutputHandler) | release | geometry, mode, done, scale 15 | wl\_output\_handler (Integration) |
| XDG Output | zxdg\_output\_manager\_v1, zxdg\_output\_v1 | YourCompositorState (implementiert GlobalDispatch und Dispatch für XDG Output Interfaces) | destroy (manager/output), get\_xdg\_output (manager) | logical\_position, logical\_size, done, name, description (output) | xdg\_output\_handler |
| WLR Output Management | zwlr\_output\_manager\_v1, zwlr\_output\_head\_v1, zwlr\_output\_mode\_v1, zwlr\_output\_configuration\_v1, zwlr\_output\_configuration\_head\_v1 | WlrOutputManagementState, YourCompositorState (implementiert relevante Dispatch-Traits) | create\_configuration (manager), apply, test (configuration), enable\_head, set\_mode (config\_head) 20 | head, done (manager), name, mode, current\_mode (head), succeeded, failed, cancelled (configuration) 20 | wlr\_output\_management\_handler |
| WLR Output Power Management | zwlr\_output\_power\_manager\_v1, zwlr\_output\_power\_v1 | WlrOutputPowerManagementState, YourCompositorState (implementiert relevante Dispatch-Traits) | get\_output\_power (manager), set\_mode (power\_control) 22 | mode, failed (power\_control) 22 | wlr\_output\_power\_management\_handler |

Diese Tabelle dient als Referenz für die implementierten Wayland-Protokolle im Bereich der Output-Verwaltung und zeigt die jeweiligen Zuständigkeiten der Handler-Komponenten auf. Sie ist nützlich, um die Struktur und die Verantwortlichkeiten innerhalb des system::outputs-Moduls nachzuvollziehen.

#### **Referenzen**

1. Writing a client proxy \- zbus: D-Bus for Rust made easy \- GitHub Pages, Zugriff am Mai 14, 2025, [https://dbus2.github.io/zbus/client.html](https://dbus2.github.io/zbus/client.html)  
2. Zugriff am Januar 1, 1970, [https://smithay.github.io/smithay/smithay/wayland/shell/xdg/struct.XdgShellState.html\#method.get\_grab\_start\_edges](https://smithay.github.io/smithay/smithay/wayland/shell/xdg/struct.XdgShellState.html#method.get_grab_start_edges)  
3. Error Handling for Large Rust Projects \- Best Practice in GreptimeDB, Zugriff am Mai 13, 2025, [https://greptime.com/blogs/2024-05-07-error-rust](https://greptime.com/blogs/2024-05-07-error-rust)  
4. Error in zbus \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/enum.Error.html](https://docs.rs/zbus/latest/zbus/enum.Error.html)  
5. Arc in std::sync \- Rust Documentation, Zugriff am Mai 14, 2025, [https://doc.rust-lang.org/std/sync/struct.Arc.html](https://doc.rust-lang.org/std/sync/struct.Arc.html)  
6. doc/dbus/org.freedesktop.UPower.ref.xml · debian/0.9.23-1 \- GitLab, Zugriff am Mai 14, 2025, [https://source.puri.sm/Librem5/upower/-/blob/debian/0.9.23-1/doc/dbus/org.freedesktop.UPower.ref.xml?ref\_type=tags](https://source.puri.sm/Librem5/upower/-/blob/debian/0.9.23-1/doc/dbus/org.freedesktop.UPower.ref.xml?ref_type=tags)  
7. org.freedesktop.UPower: UPower Reference Manual, Zugriff am Mai 14, 2025, [https://upower.freedesktop.org/docs/UPower.html](https://upower.freedesktop.org/docs/UPower.html)  
8. D-Bus API Reference: UPower Reference Manual, Zugriff am Mai 14, 2025, [https://upower.freedesktop.org/docs/ref-dbus.html](https://upower.freedesktop.org/docs/ref-dbus.html)  
9. "Connection" Search \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/?search=Connection](https://docs.rs/zbus/latest/zbus/?search=Connection)  
10. org.freedesktop.login1, Zugriff am Mai 14, 2025, [https://www.freedesktop.org/software/systemd/man/org.freedesktop.login1.html](https://www.freedesktop.org/software/systemd/man/org.freedesktop.login1.html)  
11. org.freedesktop.login1 \- The D-Bus interface of systemd-logind \- Ubuntu Manpage, Zugriff am Mai 14, 2025, [https://manpages.ubuntu.com/manpages/plucky/man5/org.freedesktop.login1.5.html](https://manpages.ubuntu.com/manpages/plucky/man5/org.freedesktop.login1.5.html)  
12. org.freedesktop.login1, Zugriff am Mai 14, 2025, [https://www.freedesktop.org/software/systemd/man/org.freedesktop.login1.html\#Signals](https://www.freedesktop.org/software/systemd/man/org.freedesktop.login1.html#Signals)  
13. Zugriff am Januar 1, 1970, [https://smithay.github.io/smithay/smithay/wayland/shell/xdg/struct.XdgShellState.html\#method.get\_grab\_start\_button](https://smithay.github.io/smithay/smithay/wayland/shell/xdg/struct.XdgShellState.html#method.get_grab_start_button)  
14. smithay/ output.rs, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/src/smithay/output.rs.html](https://smithay.github.io/smithay/src/smithay/output.rs.html)  
15. smithay::wayland::output \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/wayland/output/index.html](https://smithay.github.io/smithay/smithay/wayland/output/index.html)  
16. Zugriff am Januar 1, 1970, [https://smithay.github.io/smithay/smithay/output/struct.Output.html](https://smithay.github.io/smithay/smithay/output/struct.Output.html)  
17. tokio::sync \- Rust \- People @EECS, Zugriff am Mai 14, 2025, [https://people.eecs.berkeley.edu/\~pschafhalter/pub/erdos/doc/tokio/sync/](https://people.eecs.berkeley.edu/~pschafhalter/pub/erdos/doc/tokio/sync/)  
18. smithay::backend::udev \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/backend/udev/index.html](https://smithay.github.io/smithay/smithay/backend/udev/index.html)  
19. support wlr-output-management-unstable-v1? · YaLTeR niri · Discussion \#172 \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/YaLTeR/niri/discussions/172](https://github.com/YaLTeR/niri/discussions/172)  
20. wlr output management protocol | Wayland Explorer, Zugriff am Mai 14, 2025, [https://wayland.app/protocols/wlr-output-management-unstable-v1](https://wayland.app/protocols/wlr-output-management-unstable-v1)  
21. rcalixte/awesome-wayland: A curated list of Wayland resources \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/rcalixte/awesome-wayland](https://github.com/rcalixte/awesome-wayland)  
22. wlr output power management protocol | Wayland Explorer, Zugriff am Mai 14, 2025, [https://wayland.app/protocols/wlr-output-power-management-unstable-v1](https://wayland.app/protocols/wlr-output-power-management-unstable-v1)  
23. wayland-rs/historical\_changelog.md at master \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/Smithay/wayland-rs/blob/master/historical\_changelog.md](https://github.com/Smithay/wayland-rs/blob/master/historical_changelog.md)  
24. File: wlr-output-power-management-unstable-v1.xml \- Debian Sources, Zugriff am Mai 14, 2025, [https://sources.debian.org/src/phosh/0.8.0-1/protocol/wlr-output-power-management-unstable-v1.xml/](https://sources.debian.org/src/phosh/0.8.0-1/protocol/wlr-output-power-management-unstable-v1.xml/)
# **Implementierungsleitfaden Systemschicht (Teil 3/4)**

## **I. Einleitung zu den Spezifikationen der Systemschicht (Teil 3/4)**

### **Überblick**

Die Systemschicht, wie in der technischen Gesamtspezifikation dargelegt, bildet das kritische Bindeglied zwischen der abstrakten Logik der Domänenschicht, der Präsentationslogik der Benutzeroberflächenschicht und den konkreten Funktionalitäten des zugrundeliegenden Linux-Betriebssystems sowie der Hardware. Ihre Hauptaufgabe besteht darin, die "Mechanik" der Desktop-Umgebung zu implementieren, indem sie übergeordnete Richtlinien und Benutzerinteraktionen in handfeste Systemaktionen übersetzt. Dieser Prozess erfordert eine präzise und robuste Interaktion mit einer Vielzahl externer Komponenten, darunter Wayland-Protokolle, die über Bibliotheken wie Smithay gehandhabt werden, D-Bus-Systemdienste wie UPower und Logind sowie potenziell direkte Hardware-Interaktionen, beispielsweise über das Direct Rendering Manager (DRM)-Subsystem.  
Die Stabilität und Reaktionsfähigkeit der gesamten Desktop-Umgebung hängt maßgeblich von der Zuverlässigkeit der Systemschicht ab. Da diese Schicht intensiv mit externen, oft asynchronen Systemen kommuniziert, können Unvorhersehbarkeiten wie Latenzen, Fehler oder unerwartete Zustandsänderungen auftreten. Eine unzureichend robuste Systemschicht, die beispielsweise bei einem langsamen D-Bus-Aufruf blockiert, bei einem unerwarteten Wayland-Ereignis in Panik gerät oder den Ausfall eines Dienstes nicht korrekt behandelt, würde die Stabilität der gesamten Desktop-Umgebung direkt gefährden. Daher muss das Design jedes Moduls der Systemschicht Resilienz als oberste Priorität behandeln. Dies bedeutet konkret den Einsatz asynchroner Operationen für alle potenziell blockierenden E/A-Vorgänge, insbesondere bei D-Bus-Aufrufen (unterstützt durch zbus) und der Wayland-Ereignisverarbeitung. Ein umfassendes, typisiertes Fehlermanagement pro Modul (mittels thiserror) ist unerlässlich, um höheren Schichten eine angemessene Reaktion auf Fehlerzustände zu ermöglichen. Dies schließt die Behandlung von D-Bus-Fehlern, Wayland-Protokollfehlern und internen Logikfehlern ein. Wo immer möglich, sollten Interaktionen mit externen Diensten Timeouts beinhalten, und Fallback-Mechanismen oder eine graceful degradation der Funktionalität müssen in Betracht gezogen werden, falls ein Dienst nicht verfügbar oder nicht reaktionsfähig ist. Eine sorgfältige Zustandssynchronisation ist ebenfalls von entscheidender Bedeutung, insbesondere wenn der Zustand von externen Komponenten abgeleitet wird oder diese beeinflusst. Mechanismen zur Erkennung und Behebung von Zustandsdiskrepanzen, wie z.B. die Verwendung von Serialnummern in Wayland-Protokollen, müssen akribisch implementiert werden.

### **Zweck dieses Dokuments**

Dieses Dokument, "Teil 3/4" der Spezifikationen für die Systemschicht, legt vier detaillierte, ultrafeingranulare Implementierungspläne für Schlüsselmodule dieser Schicht vor. Ziel ist es, den Entwicklern so präzise Vorgaben an die Hand zu geben, dass eine direkte Implementierung ohne weitere architektonische oder tiefgreifende Designentscheidungen möglich wird.

### **Beziehung zur Gesamtarchitektur**

Die hier spezifizierten Module – system::outputs::output\_manager, system::outputs::power\_manager, system::dbus::upower\_interface und system::dbus::logind\_interface – sind fundamental für die Verwaltung der Display-Hardware und die Integration mit essenziellen Systemdiensten. Sie bauen auf den in der Kernschicht definierten grundlegenden Datentypen und Dienstprogrammen auf und stellen notwendige Funktionalitäten und Ereignisse für die Domänen- und Benutzeroberflächenschicht bereit.

## **II. Ultra-Feinspezifikation: system::outputs::output\_manager (Wayland Output Konfiguration)**

### **A. Modulübersicht und Zweck**

* **Verantwortlichkeit:** Dieses Modul implementiert die serverseitige Logik für das Wayland-Protokoll wlr-output-management-unstable-v1. Seine primäre Funktion besteht darin, Wayland-Clients – typischerweise Display-Konfigurationswerkzeuge – zu ermöglichen, verfügbare Display-Ausgänge zu erkennen, deren Fähigkeiten abzufragen (Modi, unterstützte Auflösungen, Bildwiederholraten, physische Dimensionen, Skalierung, Transformation) und atomare Änderungen an ihrer Konfiguration anzufordern (z.B. Setzen eines neuen Modus, Positionierung, Aktivieren/Deaktivieren eines Ausgangs).  
* **Interaktion:** Es interagiert mit der internen Repräsentation von Display-Ausgängen des Compositors, die wahrscheinlich durch Smithays Output- und OutputManagerState-Strukturen verwaltet werden.1 Über dieses Protokoll angeforderte Änderungen werden in Operationen auf diesen internen Smithay-Objekten übersetzt, die wiederum mit dem DRM-Backend (Direct Rendering Manager) interagieren können, um Hardware-Änderungen zu bewirken.  
* **Schlüsselprotokollelemente:** zwlr\_output\_manager\_v1, zwlr\_output\_head\_v1, zwlr\_output\_mode\_v1, zwlr\_output\_configuration\_v1.  
* **Relevante Referenzmaterialien & Analyse:**  
  * 2 (Protokollübersicht): Liefert die XML-Definition und detailliert Anfragen wie create\_configuration, apply, test sowie Ereignisse wie head, done, succeeded, failed. Dies ist die primäre Quelle für die Struktur der Protokollnachrichten.  
  * 1 (Smithay Output, OutputManagerState, OutputHandler): Diese Smithay-Komponenten sind fundamental. Output repräsentiert ein physisches Display im Compositor. OutputManagerState hilft bei der Verwaltung von wl\_output-Globalen. Der OutputHandler (oder ein spezifischerer Handler für dieses Protokoll) wird implementiert, um Client-Anfragen zu verarbeiten. Dieses Modul wird im Wesentlichen eine Brücke zwischen dem wlr-output-management-Protokoll und diesen Smithay-Abstraktionen schlagen.  
  * 26 (Anvil DRM Output Management): Zeigt ein praktisches Beispiel, wie Smithays Output basierend auf DRM-Geräteinformationen erstellt und konfiguriert wird. Während dieses Modul die Wayland-Protokollseite behandelt, werden die zugrundeliegenden Mechanismen zur Anwendung von Änderungen denen im DRM-Backend von Anvil ähneln.  
  * 1 (Smithay OutputHandler und wlr-output-management): Bestärken die Verbindung zwischen Smithays Output-Handling und dem wlr-output-management-Protokoll.

### **B. Entwicklungs-Submodule & Dateien**

* **1\. system::outputs::output\_manager::manager\_global**  
  * Dateien: system/outputs/output\_manager/manager\_global.rs  
  * Verantwortlichkeiten: Verwaltet den Lebenszyklus des zwlr\_output\_manager\_v1-Globals. Behandelt Bindeanfragen von Clients für dieses Global. Leitet Client-Anfragen zur Erstellung neuer zwlr\_output\_configuration\_v1-Objekte weiter.  
* **2\. system::outputs::output\_manager::head\_handler**  
  * Dateien: system/outputs/output\_manager/head\_handler.rs  
  * Verantwortlichkeiten: Verwaltet zwlr\_output\_head\_v1-Objekte. Sendet name, description, physical\_size, mode, enabled, current\_mode, position, transform, scale, finished, make, model, serial\_number-Ereignisse an den Client, basierend auf dem Zustand des entsprechenden smithay::output::Output.  
* **3\. system::outputs::output\_manager::mode\_handler**  
  * Dateien: system/outputs/output\_manager/mode\_handler.rs  
  * Verantwortlichkeiten: Verwaltet zwlr\_output\_mode\_v1-Objekte. Sendet size, refresh, preferred, finished-Ereignisse basierend auf den für ein smithay::output::Output verfügbaren Modi.  
* **4\. system::outputs::output\_manager::configuration\_handler**  
  * Dateien: system/outputs/output\_manager/configuration\_handler.rs  
  * Verantwortlichkeiten: Verwaltet zwlr\_output\_configuration\_v1- und zwlr\_output\_configuration\_head\_v1-Objekte. Speichert vom Client angeforderte, ausstehende Änderungen. Implementiert die Logik für test- und apply-Anfragen, interagiert mit dem Kern-Output-Zustand des Compositors und potenziell dem DRM-Backend. Sendet succeeded-, failed- oder cancelled-Ereignisse.  
* **5\. system::outputs::output\_manager::types**  
  * Dateien: system/outputs/output\_manager/types.rs  
  * Verantwortlichkeiten: Definiert Rust-Strukturen und \-Enums, die Protokolltypen widerspiegeln oder internen Zustand für die Verwaltung von Konfigurationen repräsentieren (z.B. PendingHeadConfiguration, AppliedConfigurationAttempt).  
* **6\. system::outputs::output\_manager::errors**  
  * Dateien: system/outputs/output\_manager/errors.rs  
  * Verantwortlichkeiten: Definiert das OutputManagerError-Enum mittels thiserror für Fehler, die spezifisch für die Operationen dieses Moduls sind.

### **C. Schlüsseldatenstrukturen**

* OutputManagerModuleState:  
  * output\_manager\_global: Option\<GlobalId\> (Smithay-Global für zwlr\_output\_manager\_v1)  
  * active\_configurations: HashMap\<ObjectId, Arc\<Mutex\<PendingOutputConfiguration\>\>\> (Verfolgt aktive zwlr\_output\_configuration\_v1-Instanzen)  
  * compositor\_output\_serial: u32 (Wird inkrementiert, wenn sich das Output-Layout des Compositors ändert)  
* PendingOutputConfiguration: Repräsentiert eine vom Client angeforderte Konfiguration über zwlr\_output\_configuration\_v1.  
  * serial: u32 (Vom Client bei Erstellung bereitgestellte Serialnummer)  
  * head\_configs: HashMap\<WlOutput, HeadConfigChange\> (Mappt wl\_output auf gewünschte Änderungen)  
  * is\_applied\_or\_tested: bool  
* HeadConfigChange:  
  * target\_output\_name: String (Interner Name/ID des Output-Objekts des Compositors)  
  * enabled: Option\<bool\>  
  * mode: Option\<OutputModeRequest\> (Könnte spezifische Mode-ID oder benutzerdefinierte Modusparameter sein)  
  * position: Option\<Point\<i32, Logical\>\>  
  * transform: Option\<wl\_output::Transform\>  
  * scale: Option\<f64\>  
* OutputModeRequest: Enum für ExistingMode(ModeId) oder CustomMode { width: i32, height: i32, refresh: i32 }.

**Tabelle: OutputManager-Datenstrukturen**

| Struct/Enum Name | Felder (Name, Rust-Typ, nullable, Mutabilität) | Beschreibung | Korrespondierendes Wayland-Protokollelement/Konzept |
| :---- | :---- | :---- | :---- |
| OutputManagerModuleState | output\_manager\_global: Option\<GlobalId\> (intern, veränderlich) \<br\> active\_configurations: HashMap\<ObjectId, Arc\<Mutex\<PendingOutputConfiguration\>\>\> (intern, veränderlich) \<br\> compositor\_output\_serial: u32 (intern, veränderlich) | Hauptzustand des Moduls, verwaltet das Global und aktive Konfigurationen. | zwlr\_output\_manager\_v1 |
| PendingOutputConfiguration | serial: u32 (intern, unveränderlich nach Erstellung) \<br\> head\_configs: HashMap\<WlOutput, HeadConfigChange\> (intern, veränderlich durch Client-Requests) \<br\> is\_applied\_or\_tested: bool (intern, veränderlich) | Speichert eine vom Client initiierte, aber noch nicht angewendete oder getestete Konfiguration. | zwlr\_output\_configuration\_v1 |
| HeadConfigChange | target\_output\_name: String (intern) \<br\> enabled: Option\<bool\> (optional) \<br\> mode: Option\<OutputModeRequest\> (optional) \<br\> position: Option\<Point\<i32, Logical\>\> (optional) \<br\> transform: Option\<wl\_output::Transform\> (optional) \<br\> scale: Option\<f64\> (optional) | Repräsentiert die gewünschten Änderungen für einen einzelnen Output (head). | zwlr\_output\_configuration\_head\_v1-Anfragen |
| OutputModeRequest | ExistingMode(ModeId) \<br\> CustomMode { width: i32, height: i32, refresh: i32 } | Unterscheidet zwischen der Auswahl eines existierenden Modus oder der Definition eines benutzerdefinierten Modus. | zwlr\_output\_configuration\_head\_v1.set\_mode, zwlr\_output\_configuration\_head\_v1.set\_custom\_mode |

Diese Datenstrukturen sind fundamental, um den Zustand der von Clients initiierten Output-Konfigurationen zu verfolgen. Die OutputManagerModuleState dient als zentraler Punkt für die Verwaltung des globalen zwlr\_output\_manager\_v1 und der damit verbundenen Konfigurationsobjekte. Jede PendingOutputConfiguration kapselt die Gesamtheit der Änderungen, die ein Client für eine Gruppe von Outputs vornehmen möchte, bevor diese getestet oder angewendet werden. Die compositor\_output\_serial ist entscheidend für die Synchronisation des Client-Wissens mit dem tatsächlichen Zustand der Outputs im Compositor.

### **D. Protokollbehandlung: zwlr\_output\_manager\_v1 (Interface Version: 3 2)**

* **Smithay Handler:** Die Zustandsverwaltung und Anforderungsbehandlung für das zwlr\_output\_manager\_v1-Global wird durch Implementierung der Traits GlobalDispatch\<ZwlrOutputManagerV1, GlobalData, YourCompositorState\> und Dispatch\<ZwlrOutputManagerV1, UserData, YourCompositorState\> für die OutputManagerModuleState-Struktur realisiert. GlobalData könnte hier leer sein oder minimale globale Informationen enthalten, während UserData für gebundene Manager-Instanzen spezifisch sein kann, falls erforderlich (oftmals ist für Singleton-Manager-Globale keine komplexe UserData nötig).  
* **Globalerstellung:** Das zwlr\_output\_manager\_v1-Global wird einmalig beim Start des Compositors oder bei der Initialisierung dieses Moduls mittels DisplayHandle::create\_global erstellt und dem Wayland-Display hinzugefügt. Die zurückgegebene GlobalId wird in OutputManagerModuleState::output\_manager\_global gespeichert.  
* **Anfrage: create\_configuration(id: New\<ZwlrOutputConfigurationV1\>, serial: u32)**  
  * Rust Signatur:  
    Rust  
    fn create\_configuration(  
        \&mut self,  
        \_client: \&Client, // wayland\_server::Client  
        \_manager: \&ZwlrOutputManagerV1, // wayland\_protocols::wlr::output\_management::v1::server::zwlr\_output\_manager\_v1::ZwlrOutputManagerV1  
        new\_id: New\<ZwlrOutputConfigurationV1\>, // wayland\_server::New\<ZwlrOutputConfigurationV1\>  
        serial: u32,  
        data\_init: \&mut DataInit\<'\_, YourCompositorState\> // wayland\_server::DataInit  
    ) {... }  
    (Hinweis: Die genaue Signatur hängt von der Implementierung des Dispatch-Traits ab; Result\<(), BindError\> ist bei GlobalDispatch nicht direkt der Rückgabewert der bind-Methode, sondern die Initialisierung erfolgt innerhalb.)  
  * Implementierung:  
    1. Die vom Client bereitgestellte serial wird mit der aktuellen self.compositor\_output\_serial verglichen. Obwohl das Protokoll nicht explizit eine Ablehnung bei Serial-Mismatch hier vorschreibt, ist es ein Indikator dafür, dass der Client möglicherweise veraltete Informationen hat. Eine Warnung kann geloggt werden. Die eigentliche Konsequenz eines Serial-Mismatchs wird typischerweise beim apply oder test relevant, wo eine cancelled-Nachricht gesendet werden kann.2  
    2. Eine neue Instanz von PendingOutputConfiguration wird mit der clientseitigen serial erstellt.  
    3. Diese PendingOutputConfiguration wird in einem Arc\<Mutex\<...\>\> verpackt und in OutputManagerModuleState::active\_configurations gespeichert, wobei die ObjectId des neuen zwlr\_output\_configuration\_v1-Objekts als Schlüssel dient.  
    4. Die zwlr\_output\_configuration\_v1-Ressource wird für den Client initialisiert und mit dem Arc\<Mutex\<PendingOutputConfiguration\>\> als UserData versehen. data\_init.init(new\_id, user\_data\_arc\_clone);  
* **Anfrage: stop() (seit Version 3\)**  
  * Rust Signatur:  
    Rust  
    fn stop(  
        \&mut self,  
        \_client: \&Client,  
        \_manager: \&ZwlrOutputManagerV1  
    ) {... }

  * Implementierung:  
    1. Wenn der Client die entsprechende Berechtigung hat (üblicherweise jeder Client, der den Manager gebunden hat), wird das zwlr\_output\_manager\_v1-Global zerstört.  
    2. Dies bedeutet, dass self.output\_manager\_global.take().map(|id| display\_handle.remove\_global(id)); aufgerufen wird, sodass keine neuen Clients mehr binden können.  
    3. Bestehende zwlr\_output\_configuration\_v1-Objekte könnten gemäß Protokollspezifikation weiterhin gültig bleiben, bis sie explizit vom Client zerstört werden oder ihre Operationen mit succeeded, failed oder cancelled abschließen. Die finished-Nachricht auf dem Manager signalisiert Clients, dass der Manager nicht mehr verwendet werden kann.  
* **Vom Compositor gesendete Ereignisse (beim Binden oder bei Änderung des Output-Zustands):**  
  * head(output: WlOutput): Für jedes aktuell vom Compositor verwaltete smithay::output::Output. Das WlOutput-Objekt wird dem Client übergeben.  
  * done(serial: u32): Nach allen head-Ereignissen wird die aktuelle compositor\_output\_serial gesendet.  
  * finished(): Wenn das Manager-Global zerstört wird (z.B. durch stop() oder beim Herunterfahren des Compositors).

**Tabelle: zwlr\_output\_manager\_v1 Interface-Behandlung**

| Anfrage/Ereignis | Richtung | Smithay Handler Signatur (Beispiel) | Parameter (Name, Wayland-Typ, Rust-Typ) | Vorbedingungen | Nachbedingungen | Fehlerbedingungen | Beschreibung |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| create\_configuration | Client \-\> Server | fn create\_configuration(..., new\_id: New\<ZwlrOutputConfigurationV1\>, serial: u32,...) | id: new\_id (New\<ZwlrOutputConfigurationV1\>), serial: uint (u32) | Manager-Global existiert. | Neues ZwlrOutputConfigurationV1-Objekt erstellt und mit PendingOutputConfiguration assoziiert. | Protokollfehler bei ungültiger ID. | Erstellt ein neues Konfigurationsobjekt. |
| stop | Client \-\> Server | fn stop(...) | \- | Manager-Global existiert. | Manager-Global wird für neue Bindungen deaktiviert/zerstört. finished-Ereignis wird gesendet. | \- | Stoppt den Output-Manager. |
| head | Server \-\> Client | \- (Intern ausgelöst) | output: object (WlOutput) | Output existiert im Compositor. | Client erhält Referenz auf ein WlOutput-Objekt. | \- | Informiert Client über einen verfügbaren Output. |
| done | Server \-\> Client | \- (Intern ausgelöst) | serial: uint (u32) | Alle head-Ereignisse für aktuellen Zustand gesendet. | Client kennt aktuelle Output-Serialnummer des Compositors. | \- | Signalisiert Ende der Output-Auflistung. |
| finished | Server \-\> Client | \- (Intern ausgelöst) | \- | Manager-Global wird zerstört. | Client weiß, dass der Manager nicht mehr nutzbar ist. | \- | Manager wurde beendet. |

### **E. Protokollbehandlung: zwlr\_output\_configuration\_v1 (Interface Version: 3\)**

* **Smithay Handler:** impl Dispatch\<ZwlrOutputConfigurationV1, Arc\<Mutex\<PendingOutputConfiguration\>\>, YourCompositorState\> for OutputManagerModuleState. Die UserData für jede zwlr\_output\_configuration\_v1-Ressource ist ein Arc\<Mutex\<PendingOutputConfiguration\>\>, das den Zustand der vom Client angeforderten, aber noch nicht angewendeten Konfiguration enthält.  
* **Anfragen vom Client (modifizieren PendingOutputConfiguration):**  
  * destroy(): Entfernt die zugehörige PendingOutputConfiguration aus OutputManagerModuleState::active\_configurations. Die Ressource wird von Smithay automatisch bereinigt.  
  * enable\_head(head: \&WlOutput): Setzt enabled \= Some(true) in der HeadConfigChange für den gegebenen head in PendingOutputConfiguration.  
  * disable\_head(head: \&WlOutput): Setzt enabled \= Some(false).  
  * set\_mode(head: \&WlOutput, mode: \&ZwlrOutputModeV1): Aktualisiert mode \= Some(OutputModeRequest::ExistingMode(mode\_id)) in HeadConfigChange. Die mode\_id muss aus dem ZwlrOutputModeV1-Objekt extrahiert werden (z.B. über dessen UserData).  
  * set\_custom\_mode(head: \&WlOutput, width: i32, height: i32, refresh: i32): Aktualisiert mode \= Some(OutputModeRequest::CustomMode { width, height, refresh }).  
  * set\_position(head: \&WlOutput, x: i32, y: i32): Aktualisiert position \= Some(Point::from((x, y))).  
  * set\_transform(head: \&WlOutput, transform: wl\_output::Transform): Aktualisiert transform \= Some(transform).  
  * set\_scale(head: \&WlOutput, scale: u32): Aktualisiert scale \= Some(scale as f64 / 256.0). Die Skalierung wird als Festkommazahl (multipliziert mit 256\) über das Protokoll gesendet. Alle diese Anfragen dürfen nur aufgerufen werden, wenn die Konfiguration noch nicht mit test() oder apply() verarbeitet wurde (PendingOutputConfiguration::is\_applied\_or\_tested \== false). Andernfalls ist es ein Protokollfehler (already\_applied\_or\_tested).  
* **Anfrage: test()**  
  * Implementierung:  
    1. Sperre den Mutex der PendingOutputConfiguration.  
    2. Wenn is\_applied\_or\_tested \== true, sende Protokollfehler already\_applied\_or\_tested und gib zurück.  
    3. Iteriere über head\_configs. Für jede HeadConfigChange:  
       * Identifiziere das Ziel-smithay::output::Output-Objekt anhand von WlOutput (z.B. über dessen UserData, das den Namen/ID des Smithay-Outputs enthält).  
       * Validiere die angeforderte Konfiguration:  
         * Existiert der Output noch?  
         * Wenn enabled \== Some(true):  
           * Ist der angeforderte Modus (existierend oder benutzerdefiniert) vom Output unterstützt? (Prüfe gegen Output::modes()).  
           * Ist die Position im Rahmen der Compositor-Policy gültig (z.B. keine unmöglichen Überlappungen, falls der Compositor dies prüft)?  
           * Sind Skalierung und Transformation gültige Werte?  
    4. Wenn alle Prüfungen erfolgreich sind, sende das succeeded()-Ereignis auf dem zwlr\_output\_configuration\_v1-Objekt.  
    5. Andernfalls sende das failed()-Ereignis.  
    6. Setze is\_applied\_or\_tested \= true.  
* **Anfrage: apply()**  
  * Implementierung:  
    1. Sperre den Mutex der PendingOutputConfiguration.  
    2. Wenn is\_applied\_or\_tested \== true, sende Protokollfehler already\_applied\_or\_tested und gib zurück.  
    3. Vergleiche PendingOutputConfiguration::serial mit OutputManagerModuleState::compositor\_output\_serial. Wenn sie nicht übereinstimmen, bedeutet dies, dass sich der Output-Zustand des Compositors geändert hat, seit der Client diese Konfiguration erstellt hat. Sende das cancelled()-Ereignis und gib zurück.  
    4. Führe Validierungen ähnlich wie bei test() durch. Wenn ungültig, sende failed() und gib zurück.  
    5. Versuche, die Konfiguration auf die tatsächlichen smithay::output::Output-Objekte des Compositors anzuwenden. Dies kann das Batchen von Änderungen beinhalten, wenn das DRM-Backend atomares Modesetting unterstützt.  
       * Für jede HeadConfigChange im PendingOutputConfiguration:  
         * Rufe output.change\_current\_state(...) mit den neuen Eigenschaften auf. Diese Methode in smithay::output::Output ist dafür verantwortlich, die Änderungen an das Backend (z.B. DRM) weiterzuleiten.  
         * Sammle die Ergebnisse dieser Operationen.  
    6. Wenn alle Hardware-Änderungen erfolgreich waren (oder erfolgreich simuliert wurden, falls kein echtes Backend):  
       * Inkrementiere OutputManagerModuleState::compositor\_output\_serial.  
       * Sende das succeeded()-Ereignis auf dem zwlr\_output\_configuration\_v1-Objekt.  
       * Benachrichtige alle zwlr\_output\_manager\_v1-Clients über den neuen Zustand, indem neue head-Ereignisse und ein done-Ereignis mit der neuen compositor\_output\_serial gesendet werden. Dies stellt sicher, dass alle Clients über die erfolgreiche Konfigurationsänderung informiert werden.  
    7. Wenn eine Hardware-Änderung fehlschlägt:  
       * Versuche, alle bereits teilweise angewendeten Änderungen dieser Konfiguration zurückzusetzen (Best-Effort-Basis). Dies ist ein komplexer Teil und hängt stark von den Fähigkeiten des Backends ab.  
       * Sende das failed()-Ereignis.  
    8. Setze is\_applied\_or\_tested \= true.  
* **Ereignisse an den Client:** succeeded(), failed(), cancelled().

**Tabelle: zwlr\_output\_configuration\_v1 Interface-Behandlung**

| Anfrage/Ereignis | Richtung | Smithay Handler Signatur (Beispiel) | Parameter (Name, Wayland-Typ, Rust-Typ) | Vorbedingungen | Nachbedingungen | Fehlerbedingungen | Beschreibung |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| destroy | Client \-\> Server | fn destroyed(..., \_data: \&Arc\<Mutex\<PendingOutputConfiguration\>\>) | \- | Konfigurationsobjekt existiert. | Konfigurationsobjekt und zugehöriger Zustand werden bereinigt. | \- | Zerstört das Konfigurationsobjekt. |
| enable\_head | Client \-\> Server | fn request(..., request: zwlr\_output\_configuration\_v1::Request, data: \&Arc\<Mutex\<PendingOutputConfiguration\>\>...) | head: object (WlOutput) | is\_applied\_or\_tested \== false. head ist valides WlOutput. | PendingOutputConfiguration für head wird auf enabled \= Some(true) gesetzt. | already\_applied\_or\_tested. | Aktiviert einen Output in der pend. Konfiguration. |
| disable\_head | Client \-\> Server | (wie enable\_head) | head: object (WlOutput) | (wie enable\_head) | PendingOutputConfiguration für head wird auf enabled \= Some(false) gesetzt. | already\_applied\_or\_tested. | Deaktiviert einen Output in der pend. Konfiguration. |
| set\_mode | Client \-\> Server | (wie enable\_head) | head: object (WlOutput), mode: object (ZwlrOutputModeV1) | (wie enable\_head). mode ist valider Modus für head. | PendingOutputConfiguration für head wird auf neuen Modus gesetzt. | already\_applied\_or\_tested. | Setzt einen existierenden Modus. |
| set\_custom\_mode | Client \-\> Server | (wie enable\_head) | head: object (WlOutput), width: int32, height: int32, refresh: int32 | (wie enable\_head) | PendingOutputConfiguration für head wird auf benutzerdef. Modus gesetzt. | already\_applied\_or\_tested. | Setzt einen benutzerdefinierten Modus. |
| set\_position | Client \-\> Server | (wie enable\_head) | head: object (WlOutput), x: int32, y: int32 | (wie enable\_head) | PendingOutputConfiguration für head wird auf neue Position gesetzt. | already\_applied\_or\_tested. | Setzt die Position eines Outputs. |
| set\_transform | Client \-\> Server | (wie enable\_head) | head: object (WlOutput), transform: uint (wl\_output::Transform) | (wie enable\_head) | PendingOutputConfiguration für head wird auf neue Transformation gesetzt. | already\_applied\_or\_tested. | Setzt die Transformation. |
| set\_scale | Client \-\> Server | (wie enable\_head) | head: object (WlOutput), scale: uint (Fixed-point 24.8) | (wie enable\_head) | PendingOutputConfiguration für head wird auf neue Skalierung gesetzt. | already\_applied\_or\_tested. | Setzt die Skalierung. |
| test | Client \-\> Server | (wie enable\_head) | \- | is\_applied\_or\_tested \== false. | is\_applied\_or\_tested \= true. succeeded oder failed wird gesendet. | already\_applied\_or\_tested. | Testet die pend. Konfiguration. |
| apply | Client \-\> Server | (wie enable\_head) | \- | is\_applied\_or\_tested \== false. | is\_applied\_or\_tested \= true. Konfiguration wird angewendet. succeeded, failed oder cancelled wird gesendet. Output-Serial wird ggf. aktualisiert & an Clients propagiert. | already\_applied\_or\_tested. | Wendet die pend. Konfiguration an. |
| succeeded | Server \-\> Client | \- | \- | test oder apply war erfolgreich. | Client weiß, dass Konfiguration gültig/angewendet ist. | \- | Konfiguration erfolgreich. |
| failed | Server \-\> Client | \- | \- | test oder apply ist fehlgeschlagen. | Client weiß, dass Konfiguration ungültig/nicht angewendet wurde. | \- | Konfiguration fehlgeschlagen. |
| cancelled | Server \-\> Client | \- | \- | apply wurde abgebrochen (z.B. Serial-Mismatch). | Client weiß, dass Konfiguration veraltet ist. | \- | Konfiguration abgebrochen. |

### **F. Fehlerbehandlung**

* OutputManagerError Enum (definiert in system/outputs/output\_manager/errors.rs):  
  Rust  
  use thiserror::Error;  
  use smithay::utils::Point; // Assuming Logical is part of Point's definition path  
  use wayland\_server::protocol::wl\_output;

  \#  
  pub enum OutputManagerError {  
      \#\[error("Invalid WlOutput reference provided by client.")\]  
      InvalidWlOutput,

      \#  
      InvalidModeForOutput,

      \#\[error("Configuration object has already been applied or tested and cannot be modified further.")\]  
      AlreadyProcessed,

      \#  
      BackendError(String),

      \#\[error("Client serial {client\_serial} does not match compositor output serial {server\_serial}; configuration cancelled.")\]  
      SerialMismatch { client\_serial: u32, server\_serial: u32 },

      \#\[error("Attempted to configure a non-existent or no longer available output: {output\_name}")\]  
      UnknownOutput { output\_name: String },

      \#  
      InvalidMode {  
          output\_name: String,  
          width: i32,  
          height: i32,  
          refresh: i32,  
      },

      \#\[error("Configuration test failed: {reason}")\]  
      TestFailed { reason: String },

      \#\[error("Configuration application failed: {reason}")\]  
      ApplyFailed { reason: String },

      \#\[error("Configuration was cancelled due to a concurrent output state change.")\]  
      Cancelled,

      \#\[error("A generic protocol error occurred: {0}")\]  
      ProtocolError(String), // For generic protocol violations by the client  
  }

**Tabelle: OutputManagerError Varianten**

| Variantenname | Beschreibung | Typischer Auslöser | Empfohlene Client-Aktion |
| :---- | :---- | :---- | :---- |
| InvalidWlOutput | Eine ungültige WlOutput-Referenz wurde vom Client bereitgestellt. | Client sendet eine Anfrage mit einer WlOutput-Ressource, die dem Compositor nicht (mehr) bekannt ist. | Client sollte seine Output-Liste aktualisieren. Protokollfehler. |
| InvalidModeForOutput | Der referenzierte ZwlrOutputModeV1 ist für den gegebenen WlOutput nicht gültig. | Client versucht, einen Modus zu setzen, der nicht zu den vom Output angebotenen Modi gehört. | Client sollte die Modi des Outputs erneut prüfen. Protokollfehler. |
| AlreadyProcessed | Das Konfigurationsobjekt wurde bereits angewendet oder getestet und kann nicht weiter modifiziert werden. | Client sendet eine Modifikationsanfrage (z.B. set\_mode) an ein zwlr\_output\_configuration\_v1-Objekt, nachdem bereits test() oder apply() darauf aufgerufen wurde. | Client muss ein neues Konfigurationsobjekt erstellen. Protokollfehler. |
| BackendError | Ein Fehler im DRM- oder Hardware-Backend während der Konfigurationsanwendung. | Fehler beim Aufruf von DRM ioctls oder anderen Backend-spezifischen Operationen. | Client kann versuchen, die Operation später erneut auszuführen oder eine einfachere Konfiguration wählen. Der Compositor sendet failed(). |
| SerialMismatch | Die Serialnummer des Clients stimmt nicht mit der des Compositors überein; Konfiguration abgebrochen. | Der Output-Zustand des Compositors hat sich geändert, seit der Client die Konfiguration erstellt hat. | Client muss seine Output-Informationen aktualisieren (auf head/done-Ereignisse warten) und eine neue Konfiguration erstellen. Der Compositor sendet cancelled(). |
| UnknownOutput | Versuch, einen nicht existierenden oder nicht mehr verfügbaren Output zu konfigurieren. | Client referenziert einen Output (z.B. per Name/ID intern), der nicht (mehr) existiert. | Client sollte seine Output-Liste aktualisieren. Der Compositor sendet failed() oder cancelled(). |
| InvalidMode | Ein ungültiger Modus (Dimensionen, Refresh-Rate) wurde für einen Output spezifiziert. | Client spezifiziert einen custom\_mode mit Werten, die vom Output oder Compositor nicht unterstützt werden. | Client sollte unterstützte Modi verwenden oder Parameter anpassen. Der Compositor sendet failed(). |
| TestFailed | Der Konfigurationstest ist fehlgeschlagen. | Die vorgeschlagene Konfiguration ist aus Sicht des Compositors ungültig (z.B. ungültige Modi, Überlappungen). | Client sollte die Konfiguration anpassen. Der Compositor sendet failed(). |
| ApplyFailed | Die Anwendung der Konfiguration ist fehlgeschlagen. | Die Konfiguration war zwar gültig, konnte aber aufgrund eines Backend-Fehlers oder eines Laufzeitproblems nicht angewendet werden. | Client kann es erneut versuchen oder eine andere Konfiguration wählen. Der Compositor sendet failed(). |
| Cancelled | Die Konfiguration wurde aufgrund einer gleichzeitigen Zustandsänderung des Outputs abgebrochen. | Typischerweise durch einen Serial-Mismatch bei apply() oder wenn sich der Output-Zustand während des apply-Vorgangs ändert. | Client muss seine Output-Informationen aktualisieren und eine neue Konfiguration erstellen. Der Compositor sendet cancelled(). |
| ProtocolError | Ein generischer Protokollfehler seitens des Clients. | Client sendet eine Anfrage, die gegen die Protokollregeln verstößt (z.B. falsche Argumente, falsche Reihenfolge). | Client-Fehler. Der Compositor kann die Client-Verbindung beenden. |

### **G. Detaillierte Implementierungsschritte (Zusammenfassung)**

1. **Global Setup:** OutputManagerModuleState initialisieren. Das zwlr\_output\_manager\_v1-Global erstellen und im Wayland-Display bekannt machen. GlobalDispatch für dieses Global implementieren, um Client-Bindungen zu handhaben.  
2. **Manager Request Handling:** Dispatch für ZwlrOutputManagerV1 implementieren.  
   * Bei create\_configuration: Eine neue PendingOutputConfiguration-Instanz (eingebettet in Arc\<Mutex\<...\>\>) erstellen, diese mit der neuen zwlr\_output\_configuration\_v1-Ressource als UserData assoziieren und in active\_configurations speichern. Die aktuelle compositor\_output\_serial in PendingOutputConfiguration speichern.  
   * Bei stop: Das Global aus dem Display entfernen.  
3. **Configuration Request Handling:** Dispatch für ZwlrOutputConfigurationV1 implementieren.  
   * Anfragen wie enable\_head, disable\_head, set\_mode, set\_custom\_mode, set\_position, set\_transform, set\_scale modifizieren den Zustand der assoziierten PendingOutputConfiguration. Vor jeder Modifikation prüfen, ob is\_applied\_or\_tested false ist; andernfalls einen Protokollfehler (already\_applied\_or\_tested) senden.  
4. **Test/Apply Logic:**  
   * Für test(): Die in PendingOutputConfiguration gespeicherten Änderungen validieren. Dies beinhaltet die Prüfung, ob die referenzierten Outputs und Modi existieren und gültig sind und ob die Gesamtkonfiguration plausibel ist (z.B. keine unmöglichen Überlappungen gemäß Compositor-Policy). Ergebnis mit succeeded() oder failed() an den Client senden. is\_applied\_or\_tested auf true setzen.  
   * Für apply(): Zuerst die PendingOutputConfiguration::serial mit der aktuellen compositor\_output\_serial vergleichen. Bei Abweichung cancelled() senden. Andernfalls Validierung wie bei test() durchführen. Wenn gültig, versuchen, die Änderungen auf die internen smithay::output::Output-Objekte anzuwenden (z.B. via output.change\_current\_state(...)). Bei Erfolg succeeded() senden, die compositor\_output\_serial inkrementieren und alle Manager-Clients über den neuen Zustand und die neue Serial informieren. Bei Fehlschlag (z.B. Backend-Fehler) versuchen, Änderungen zurückzurollen und failed() senden. is\_applied\_or\_tested auf true setzen.  
5. **Event Emission:**  
   * Wenn sich der Zustand eines smithay::output::Output ändert (z.B. durch Hotplug oder erfolgreiches apply), müssen alle gebundenen zwlr\_output\_manager\_v1-Clients aktualisierte head-Informationen und ein done-Ereignis mit der neuen compositor\_output\_serial erhalten.  
   * zwlr\_output\_configuration\_v1 sendet succeeded, failed oder cancelled als Antwort auf test oder apply.  
6. **State Synchronization:** Die compositor\_output\_serial ist der Schlüssel zur Konsistenzerhaltung. Sie wird bei jeder erfolgreichen Anwendung einer Konfiguration oder bei jeder vom Compositor initiierten Änderung des Output-Layouts (z.B. Hotplug) inkrementiert. Clients verwenden diese Serial, um sicherzustellen, dass ihre Konfigurationsanfragen auf dem aktuellen Stand basieren.

### **H. Interaktionen**

* **Compositor Core (AnvilState oder Äquivalent):** Stellt die Liste der smithay::output::Output-Objekte bereit, deren aktuellen Zustände (Modi, Positionen, etc.) und die aktuelle compositor\_output\_serial. Nimmt Anfragen zur Zustandsänderung von Outputs entgegen.  
* **DRM Backend (oder anderes Hardware-Backend):** Die apply()-Logik ruft letztendlich Funktionen des Backends auf, um physische Display-Eigenschaften zu ändern (z.B. via DRM ioctls für Modesetting, Positionierung über CRTC-Konfiguration).  
* **UI Layer (indirekt):** Display-Konfigurationswerkzeuge (z.B. ein Einstellungsdialog) sind die primären Clients dieses Protokolls. Sie nutzen es, um dem Benutzer die Kontrolle über die Display-Einstellungen zu ermöglichen.

### **I. Vertiefende Betrachtungen & Implikationen**

Die Implementierung des wlr-output-management-unstable-v1-Protokolls erfordert sorgfältige Beachtung der Atomarität von Konfigurationsänderungen und der Synchronisation des Client-Zustands mit dem Compositor.  
Die Semantik von test() und apply() 2 legt nahe, dass der Compositor in der Lage sein muss, einen vollständigen Satz von Output-Änderungen zu validieren, *bevor* er versucht, sie anzuwenden. Dies ist entscheidend, um zu verhindern, dass das System in einem inkonsistenten oder unbrauchbaren Display-Zustand verbleibt. Scheitert ein apply(), sollte idealerweise ein Rollback zum vorherigen Zustand erfolgen. Dies kann komplex sein, wenn das zugrundeliegende DRM-Backend nicht für alle relevanten Eigenschaften atomare Updates unterstützt oder wenn eine Sequenz von Änderungen erforderlich ist. Ein robuster Compositor muss hier entweder auf Backend-Fähigkeiten für atomare Commits zurückgreifen oder eine eigene Logik implementieren, um den aktuellen Hardware-Zustand zu lesen, Änderungen zu versuchen und bei Fehlschlägen einzelne Schritte zurückzunehmen – letzteres ist deutlich komplexer. Smithays DRM-Abstraktionen 3 zielen darauf ab, dies zu vereinfachen, aber die Atomaritätsanforderung des Protokolls stellt eine Herausforderung dar.  
Das Management von Serialnummern ist ein weiterer kritischer Aspekt. Das serial-Argument in create\_configuration und das done-Ereignis des Managers 2 ermöglichen es Clients zu erkennen, ob ihr Verständnis des Output-Layouts aktuell ist. Ändert sich das Output-Layout des Compositors (z.B. durch Hotplugging eines Monitors), nachdem ein Client ein done-Ereignis empfangen hat, aber bevor er create\_configuration aufruft, ermöglicht der Serialnummern-Mismatch dem Compositor, die Konfiguration effektiv abzubrechen (typischerweise durch Senden von cancelled bei apply()). Dies zwingt den Client, den Output-Zustand neu zu evaluieren, und verhindert Operationen auf einem veralteten Setup.  
Schließlich ist die zuverlässige Zuordnung von clientseitigen WlOutput-Ressourcen zu den internen smithay::output::Output-Instanzen des Compositors unerlässlich. Das Protokoll operiert mit WlOutput-Objekten. Der Compositor muss diese clientseitigen Ressourcen eindeutig seinen internen Repräsentationen der physischen Outputs zuordnen können, um Fähigkeiten abzufragen und Änderungen anzuwenden. Diese Zuordnung wird typischerweise etabliert, wenn das wl\_output-Global vom Client gebunden wird. Smithays UserData-Mechanismus oder interne Maps, die ObjectIds als Schlüssel verwenden, sind hierfür gängige Lösungen. Die Output-Struktur von Smithay selbst verwaltet die WlOutput-Globale für Clients.1

## **III. Ultra-Feinspezifikation: system::outputs::power\_manager (Wayland Output Power Management)**

### **A. Modulübersicht und Zweck**

* **Verantwortlichkeit:** Dieses Modul implementiert die serverseitige Logik für das Wayland-Protokoll wlr-output-power-management-unstable-v1. Es ermöglicht autorisierten Wayland-Clients, typischerweise übergeordneten Shell-Komponenten, den Energiezustand (z.B. An, Aus) einzelner Display-Ausgänge zu steuern.  
* **Interaktion:** Es interagiert mit den internen smithay::output::Output-Objekten des Compositors. Anfragen zur Änderung des Energiezustands werden in Operationen auf diesen Objekten übersetzt, die dann typischerweise mit dem DRM-Backend (z.B. mittels DPMS) interagieren, um die physische Hardware zu steuern.  
* **Schlüsselprotokollelemente:** zwlr\_output\_power\_manager\_v1, zwlr\_output\_power\_v1.  
* **Relevante Referenzmaterialien & Analyse:**  
  * 28 (Protokoll-XML), 5 (Protokollspezifikation): Dies sind die primären Quellen, die Anfragen, Ereignisse und Enums (on, off) definieren. 5 merkt an, dass Modusänderungen "sofort wirksam" sind.  
  * 29 (wayland-rs Changelog): Weist auf die Verfügbarkeit des Protokolls in wayland-protocols hin.  
  * 5 (wayland.app Übersicht): Allgemeine Beschreibung und Links.  
  * 30 (lib.rs Erwähnung): Zeigt, dass es sich um ein bekanntes Protokoll handelt. Die Analyse dieser Quellen ergibt, dass dieses Protokoll im Vergleich zum Output-Management-Protokoll einfacher ist und sich auf zwei Zustände (An/Aus) konzentriert. Die Herausforderung liegt in der korrekten Autorisierung von Anfragen (implizit, da für "spezielle Clients" gedacht) und der zuverlässigen Weitergabe von Zustandsänderungen an die zugrundeliegende Display-Hardware.

### **B. Entwicklungs-Submodule & Dateien**

* **1\. system::outputs::power\_manager::manager\_global**  
  * Dateien: system/outputs/power\_manager/manager\_global.rs  
  * Verantwortlichkeiten: Verwaltet das zwlr\_output\_power\_manager\_v1-Global, behandelt Client-Bindungen und leitet get\_output\_power-Anfragen weiter.  
* **2\. system::outputs::power\_manager::power\_control\_handler**  
  * Dateien: system/outputs/power\_manager/power\_control\_handler.rs  
  * Verantwortlichkeiten: Verwaltet zwlr\_output\_power\_v1-Instanzen. Behandelt set\_mode-Anfragen von Clients und sendet mode- oder failed-Ereignisse.  
* **3\. system::outputs::power\_manager::types**  
  * Dateien: system/outputs/power\_manager/types.rs  
  * Verantwortlichkeiten: Definiert Rust-Enums für zwlr\_output\_power\_v1::Mode (z.B. InternalPowerMode { On, Off }).  
* **4\. system::outputs::power\_manager::errors**  
  * Dateien: system/outputs/power\_manager/errors.rs  
  * Verantwortlichkeiten: Definiert OutputPowerError.

### **C. Schlüsseldatenstrukturen**

* OutputPowerManagerModuleState:  
  * power\_manager\_global: Option\<GlobalId\> (Smithay-Global für zwlr\_output\_power\_manager\_v1)  
  * active\_power\_controls: HashMap\<ObjectId, Arc\<Mutex\<OutputPowerControlState\>\>\> (Verfolgt aktive zwlr\_output\_power\_v1-Instanzen, Schlüssel ist die ObjectId der ZwlrOutputPowerV1-Ressource)  
* OutputPowerControlState: Repräsentiert den Zustand einer zwlr\_output\_power\_v1-Instanz.  
  * wl\_output\_resource: WlOutput (Die clientgebundene WlOutput-Ressource, für die diese Kontrolle gilt)  
  * compositor\_output\_name: String (Ein eindeutiger Bezeichner für das interne smithay::output::Output-Objekt, das diesem WlOutput entspricht)  
  * current\_mode: InternalPowerMode (Spiegelt den zuletzt erfolgreich gesetzten Modus wider)  
* InternalPowerMode (Rust Enum): On, Off.

**Tabelle: OutputPowerManager-Datenstrukturen**

| Struct/Enum Name | Felder (Name, Rust-Typ, nullable, Mutabilität) | Beschreibung | Korrespondierendes Wayland-Protokollelement/Konzept |
| :---- | :---- | :---- | :---- |
| OutputPowerManagerModuleState | power\_manager\_global: Option\<GlobalId\> (intern, veränderlich) \<br\> active\_power\_controls: HashMap\<ObjectId, Arc\<Mutex\<OutputPowerControlState\>\>\> (intern, veränderlich) | Hauptzustand des Moduls, verwaltet das Global und aktive Energiezustandskontrollen. | zwlr\_output\_power\_manager\_v1 |
| OutputPowerControlState | wl\_output\_resource: WlOutput (intern, unveränderlich nach Erstellung) \<br\> compositor\_output\_name: String (intern, unveränderlich nach Erstellung) \<br\> current\_mode: InternalPowerMode (intern, veränderlich) | Speichert den Zustand einer einzelnen Energiezustandskontrolle für einen bestimmten Output. | zwlr\_output\_power\_v1 |
| InternalPowerMode | On, Off | Rust-interne Repräsentation der Energiezustände. | zwlr\_output\_power\_v1::mode Enum (on, off) |

Diese Strukturen sind notwendig, um den Überblick über die globalen Dienste und die individuellen Steuerungsobjekte für jeden Output zu behalten. active\_power\_controls ermöglicht es, auf Anfragen zu einem spezifischen zwlr\_output\_power\_v1-Objekt zu reagieren und dessen Zustand (insbesondere den current\_mode) zu verwalten.

### **D. Protokollbehandlung: zwlr\_output\_power\_manager\_v1 (Interface Version: 1\)**

* **Smithay Handler:** Die Implementierung erfolgt über GlobalDispatch\<ZwlrOutputPowerManagerV1, GlobalData, YourCompositorState\> und Dispatch\<ZwlrOutputPowerManagerV1, UserData, YourCompositorState\> für OutputPowerManagerModuleState. GlobalData ist hier typischerweise leer. UserData für den Manager ist ebenfalls oft nicht komplex.  
* **Anfrage: get\_output\_power(id: New\<ZwlrOutputPowerV1\>, output: WlOutput)**  
  * Rust Signatur (innerhalb des Dispatch-Traits für den Manager):  
    Rust  
    fn request(  
        \&mut self,  
        client: \&Client,  
        manager: \&ZwlrOutputPowerManagerV1,  
        request: zwlr\_output\_power\_manager\_v1::Request,  
        data: \&Self::UserData, // UserData des Managers  
        dhandle: \&DisplayHandle,  
        data\_init: \&mut DataInit\<'\_, YourCompositorState\>,  
    ) {  
        if let zwlr\_output\_power\_manager\_v1::Request::GetOutputPower { id, output: wl\_output\_resource } \= request {  
            //... Implementierungslogik...  
        }  
    }

  * Implementierung:  
    1. Identifiziere das interne smithay::output::Output-Objekt, das der vom Client übergebenen wl\_output\_resource entspricht. Dies geschieht typischerweise durch Abrufen von UserData, das mit der wl\_output\_resource assoziiert ist und den Namen oder eine ID des smithay::output::Output enthält. Wenn kein entsprechender interner Output gefunden wird, sollte das neu erstellte ZwlrOutputPowerV1-Objekt später ein failed-Ereignis senden.  
    2. Prüfe, ob bereits ein anderer Client die Energiekontrolle für diesen spezifischen wl\_output\_resource besitzt. Das Protokoll 5 deutet an, dass nur ein Client exklusive Kontrolle haben sollte ("Another client already has exclusive power management mode control"). Wenn ein Konflikt besteht, sollte das neu erstellte ZwlrOutputPowerV1-Objekt dem neuen Client ein failed-Ereignis senden, sobald es initialisiert ist oder bei der ersten set\_mode-Anfrage.  
    3. Erstelle eine neue Instanz von OutputPowerControlState. Der compositor\_output\_name wird auf den Bezeichner des internen Smithay-Outputs gesetzt. Der current\_mode wird durch Abfrage des tatsächlichen Energiezustands des physischen Outputs (z.B. über DRM DPMS) initialisiert.  
    4. Assoziiere diesen OutputPowerControlState (eingepackt in Arc\<Mutex\<...\>\>) mit der neuen id (New\<ZwlrOutputPowerV1\>) über data\_init.init(id, Arc::new(Mutex::new(power\_control\_state)));.  
    5. Sende unmittelbar nach der Erstellung des ZwlrOutputPowerV1-Objekts das initiale mode-Ereignis an den Client, das den aktuellen Energiezustand des Outputs widerspiegelt.5  
* **Anfrage: destroy()**  
  * Implementierung: Zerstört das zwlr\_output\_power\_manager\_v1-Global. Bestehende ZwlrOutputPowerV1-Objekte bleiben gemäß Protokoll 5 gültig. Das Entfernen des Globals aus dem DisplayHandle verhindert, dass neue Clients binden.

**Tabelle: zwlr\_output\_power\_manager\_v1 Interface-Behandlung**

| Anfrage/Ereignis | Richtung | Smithay Handler Signatur (Beispiel) | Parameter (Name, Wayland-Typ, Rust-Typ) | Vorbedingungen | Nachbedingungen | Fehlerbedingungen | Beschreibung |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| get\_output\_power | Client \-\> Server | Dispatch::request (match auf Request::GetOutputPower) | id: new\_id (New\<ZwlrOutputPowerV1\>), output: object (WlOutput) | Manager-Global existiert. output ist ein gültiges WlOutput-Objekt. | Neues ZwlrOutputPowerV1-Objekt erstellt und mit OutputPowerControlState assoziiert. Initiales mode-Ereignis wird an das neue Objekt gesendet. | Protokollfehler bei ungültiger ID. Interner Fehler, wenn output nicht zugeordnet werden kann (führt zu failed auf dem neuen Objekt). | Erstellt ein Energiekontroll-Objekt für einen Output. |
| destroy | Client \-\> Server | Dispatch::request (match auf Request::Destroy) | \- | Manager-Global existiert. | Manager-Global wird für neue Bindungen deaktiviert/zerstört. | \- | Zerstört das Manager-Objekt. |

### **E. Protokollbehandlung: zwlr\_output\_power\_v1 (Interface Version: 1\)**

* **Smithay Handler:** impl Dispatch\<ZwlrOutputPowerV1, Arc\<Mutex\<OutputPowerControlState\>\>, YourCompositorState\> for OutputPowerManagerModuleState. Die UserData ist hier der Arc\<Mutex\<OutputPowerControlState\>\>, der bei get\_output\_power erstellt wurde.  
* **Anfrage vom Client: set\_mode(mode: zwlr\_output\_power\_v1::Mode)**  
  * Implementierung:  
    1. Sperre den Mutex des OutputPowerControlState, um exklusiven Zugriff zu erhalten.  
    2. Übersetze das mode-Enum des Protokolls (On oder Off) in einen internen Steuerungswert (z.B. einen DPMS-Zustand für das DRM-Backend).  
    3. Versuche, diesen Energiezustand auf den physischen Output anzuwenden. Dies geschieht durch einen Aufruf an das entsprechende Backend (z.B. DRM-Backend, um den DPMS-Status zu setzen). Der compositor\_output\_name im OutputPowerControlState wird verwendet, um den korrekten internen smithay::output::Output zu identifizieren.  
    4. Wenn die Backend-Operation erfolgreich war:  
       * Aktualisiere OutputPowerControlState::current\_mode mit dem neuen Zustand.  
       * Sende das mode(actual\_new\_mode)-Ereignis über die ZwlrOutputPowerV1-Ressource an den Client. Der actual\_new\_mode sollte dem angeforderten Modus entsprechen.  
    5. Wenn die Backend-Operation fehlschlägt (z.B. der Output unterstützt den Modus nicht, ein Fehler im Backend tritt auf):  
       * Sende das failed()-Ereignis über die ZwlrOutputPowerV1-Ressource an den Client.  
* **Anfrage vom Client: destroy()**  
  * Implementierung: Die Dispatch::destroyed-Methode wird von Smithay aufgerufen, wenn der Client die Ressource zerstört. Hier wird der OutputPowerControlState aus der active\_power\_controls-Map im OutputPowerManagerModuleState entfernt, um Ressourcen freizugeben und sicherzustellen, dass keine veralteten Kontrollen mehr existieren.  
* **Ereignisse an den Client:**  
  * mode(mode: zwlr\_output\_power\_v1::Mode): Gesendet bei erfolgreicher set\_mode-Anfrage oder bei der Erstellung des ZwlrOutputPowerV1-Objekts, um den initialen Zustand zu übermitteln.  
  * failed(): Gesendet, wenn set\_mode fehlschlägt, der referenzierte Output ungültig wird (z.B. abgesteckt) oder ein anderer Client bereits die exklusive Kontrolle hat.

**Tabelle: zwlr\_output\_power\_v1 Interface-Behandlung**

| Anfrage/Ereignis | Richtung | Smithay Handler Signatur (Beispiel) | Parameter (Name, Wayland-Typ, Rust-Typ) | Vorbedingungen | Nachbedingungen | Fehlerbedingungen | Beschreibung |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| set\_mode | Client \-\> Server | Dispatch::request (match auf Request::SetMode) | mode: uint (zwlr\_output\_power\_v1::Mode) | ZwlrOutputPowerV1-Objekt existiert und ist gültig. | Energiezustand des Outputs wird geändert. mode oder failed Ereignis wird gesendet. | Output unterstützt Modus nicht. Backend-Fehler. | Setzt den Energiezustand des Outputs. |
| destroy | Client \-\> Server | Dispatch::destroyed | \- | ZwlrOutputPowerV1-Objekt existiert. | Zugehöriger OutputPowerControlState wird bereinigt. | \- | Zerstört das Energiekontroll-Objekt. |
| mode | Server \-\> Client | \- (Intern ausgelöst durch set\_mode oder Initialisierung) | mode: uint (zwlr\_output\_power\_v1::Mode) | Erfolgreiche Modusänderung oder Initialisierung. | Client kennt den aktuellen Energiezustand. | \- | Meldet eine Änderung des Energiezustands. |
| failed | Server \-\> Client | \- (Intern ausgelöst bei Fehlern) | \- | set\_mode fehlgeschlagen, Output ungültig, oder Kontrollkonflikt. | Client weiß, dass das Objekt ungültig ist. | \- | Objekt ist nicht mehr gültig. |

### **F. Fehlerbehandlung**

* OutputPowerError Enum (definiert in system/outputs/power\_manager/errors.rs):  
  Rust  
  use thiserror::Error;

  \#  
  pub enum OutputPowerError {  
      \#\[error("Output {output\_name:?} does not support power management.")\]  
      OutputDoesNotSupportPowerManagement { output\_name: String },

      \#\[error("Failed to set power mode for output {output\_name:?} due to backend error: {reason}")\]  
      BackendSetModeFailed { output\_name: String, reason: String },

      \#\[error("Output {output\_name:?} is no longer available.")\]  
      OutputVanished { output\_name: String },

      \#\[error("Another client already has exclusive power management control for output {output\_name:?}.")\]  
      ExclusiveControlConflict { output\_name: String },

      \#\[error("Invalid WlOutput reference provided by client.")\]  
      InvalidWlOutput,

      \#\[error("A generic protocol error occurred: {0}")\]  
      ProtocolError(String),  
  }

**Tabelle: OutputPowerError Varianten**

| Variantenname | Beschreibung | Typischer Auslöser | Empfohlene Client-Aktion (via failed Event) |
| :---- | :---- | :---- | :---- |
| OutputDoesNotSupportPowerManagement | Der angegebene Output unterstützt keine Energieverwaltung. | set\_mode für einen Output, der dies nicht kann. | Client sollte das ZwlrOutputPowerV1-Objekt zerstören. |
| BackendSetModeFailed | Das Setzen des Energiemodus im Backend ist fehlgeschlagen. | DRM/Hardware-Fehler während des DPMS-Aufrufs. | Client kann es später erneut versuchen oder den Fehler protokollieren; Objekt zerstören. |
| OutputVanished | Der Output, auf den sich das Kontrollobjekt bezieht, ist nicht mehr verfügbar. | Monitor wurde abgesteckt. | Client sollte das ZwlrOutputPowerV1-Objekt zerstören. |
| ExclusiveControlConflict | Ein anderer Client hat bereits die exklusive Kontrolle über die Energieverwaltung dieses Outputs. | get\_output\_power wird für einen bereits kontrollierten Output von einem anderen Client aufgerufen. | Client sollte das ZwlrOutputPowerV1-Objekt zerstören. |
| InvalidWlOutput | Eine ungültige WlOutput-Referenz wurde vom Client bereitgestellt. | Client sendet eine WlOutput-Ressource, die dem Compositor nicht bekannt ist, an get\_output\_power. | Client sollte seine Output-Liste aktualisieren. Protokollfehler. |
| ProtocolError | Ein generischer Protokollfehler seitens des Clients. | Client sendet eine Anfrage, die gegen die Protokollregeln verstößt. | Client-Fehler. Der Compositor kann die Client-Verbindung beenden. |

### **G. Detaillierte Implementierungsschritte (Zusammenfassung)**

1. **Global Setup:** OutputPowerManagerModuleState initialisieren. Das zwlr\_output\_power\_manager\_v1-Global erstellen und im Wayland-Display bekannt machen. GlobalDispatch für dieses Global implementieren.  
2. **Manager Request Handling:** Dispatch für ZwlrOutputPowerManagerV1 implementieren.  
   * Bei get\_output\_power: Internes smithay::output::Output-Objekt identifizieren. Prüfen auf exklusive Kontrolle. OutputPowerControlState erstellen (den aktuellen Energiezustand vom Backend abfragen und speichern). Das neue ZwlrOutputPowerV1-Objekt mit diesem Zustand als UserData initialisieren. Initiales mode-Ereignis an den Client senden.  
3. **Power Control Request Handling:** Dispatch für ZwlrOutputPowerV1 implementieren.  
   * Bei set\_mode: Den angeforderten Modus an das Backend (DRM DPMS) weiterleiten. Bei Erfolg den internen Zustand aktualisieren und mode-Ereignis senden. Bei Fehlschlag failed-Ereignis senden.  
4. **Output Disappearance:** Wenn ein physischer Output entfernt wird (z.B. durch Hot-Unplugging, das vom DRM-Modul erkannt wird), müssen alle zugehörigen ZwlrOutputPowerV1-Objekte ein failed-Ereignis erhalten. Der OutputPowerControlState für diesen Output sollte dann aus active\_power\_controls entfernt werden.  
5. **Compositor-Initiated Power Changes:** Wenn der Compositor selbst den Energiezustand eines Outputs ändert (z.B. durch eine Idle-Policy), muss er den current\_mode im entsprechenden OutputPowerControlState aktualisieren und ein mode-Ereignis an den gebundenen Client senden.

### **H. Interaktionen**

* **Compositor Core (AnvilState oder Äquivalent):** Stellt Zugriff auf smithay::output::Output-Instanzen und deren Zuordnung zu WlOutput-Ressourcen bereit. Benachrichtigt dieses Modul möglicherweise über das Verschwinden von Outputs.  
* **DRM Backend:** Wird aufgerufen, um DPMS-Zustände (Display Power Management Signaling) oder äquivalente hardwarenahe Energiesparfunktionen zu setzen (z.B. DRM\_MODE\_DPMS\_ON, DRM\_MODE\_DPMS\_OFF).  
* **Domain Layer:** Kann Energiesparrichtlinien auslösen (z.B. Bildschirm nach Inaktivität ausschalten), indem es entweder direkt D-Bus-Dienste aufruft, die dann dieses Protokoll verwenden könnten (wenn die Shell ein Client ist), oder indem es eine interne API des System-Layers aufruft, die letztendlich dieses Modul zur Steuerung der Output-Energie verwendet.

### **I. Vertiefende Betrachtungen & Implikationen**

Die Implementierung des wlr-output-power-management-unstable-v1-Protokolls ist im Vergleich zum Output-Konfigurationsprotokoll geradliniger, birgt aber eigene spezifische Herausforderungen in Bezug auf Exklusivität und Synchronisation mit dem tatsächlichen Hardwarezustand.  
Die Protokollbeschreibung 5 legt nahe, dass Änderungen des Energiemodus "sofort wirksam" sind. Dies impliziert eine direkte Interaktion mit der Hardware ohne eine vorgelagerte Testphase, wie sie bei wlr-output-management existiert. Für den Compositor bedeutet dies, dass bei einer set\_mode-Anfrage unmittelbar versucht werden muss, den Hardwarezustand zu ändern. Die Komplexität der Zustandsverwaltung reduziert sich dadurch, da keine komplexen pendelnden Zustände für eine Testphase vorgehalten werden müssen. Die Rückmeldung an den Client ist binär: Entweder die Aktion war erfolgreich (signalisiert durch ein mode-Ereignis mit dem neuen Zustand) oder sie schlug fehl (signalisiert durch ein failed-Ereignis).  
Das failed-Ereignis 5 dient als umfassender Fehlermechanismus. Es wird nicht nur bei direkten Fehlschlägen von set\_mode verwendet, sondern auch, wenn der zugrundeliegende Output ungültig wird (z.B. durch Abstecken des Monitors) oder wenn ein anderer Client bereits die exklusive Kontrolle über den Energiezustand des Outputs hat. Dies erfordert vom Compositor eine proaktive Überwachung des Zustands der physischen Outputs. Bei Änderungen, wie dem Entfernen eines Outputs, muss der Compositor alle assoziierten zwlr\_output\_power\_v1-Objekte identifizieren und ihnen ein failed-Ereignis senden. Dies stellt sicher, dass Clients darüber informiert werden, dass ihre Kontrollobjekte nicht mehr gültig sind und zerstört werden sollten.  
Ein weiterer wichtiger Aspekt ist die Möglichkeit, dass der Compositor selbst den Energiezustand eines Outputs ändert, unabhängig von Client-Anfragen über dieses Protokoll (z.B. aufgrund einer systemweiten Idle-Richtlinie). Das Protokoll 5 spezifiziert, dass das mode-Ereignis auch gesendet wird, wenn "der Compositor entscheidet, den Modus eines Outputs zu ändern". Wenn also die interne Logik des Compositors einen Bildschirm ausschaltet, muss dies im OutputPowerControlState des betroffenen Outputs reflektiert und ein entsprechendes mode-Ereignis an alle gebundenen zwlr\_output\_power\_v1-Clients gesendet werden. Dies gewährleistet, dass Clients stets über den aktuellen Energiezustand des Outputs informiert sind, auch wenn die Änderung nicht durch sie initiiert wurde.

## **IV. Ultra-Feinspezifikation: system::dbus::upower\_interface (UPower D-Bus Client)**

### **A. Modulübersicht und Zweck**

* **Verantwortlichkeit:** Dieses Modul stellt eine Schnittstelle zum org.freedesktop.UPower-D-Bus-Dienst bereit. Es ist dafür zuständig, den Systemstromstatus zu überwachen, einschließlich Batteriestand, Netzteilverbindung und den Zustand des Laptopdeckels (geöffnet/geschlossen).  
* **Informationsbereitstellung:** Die gesammelten Informationen werden anderen Teilen der Desktop-Umgebung zur Verfügung gestellt. Beispielsweise kann die Benutzeroberflächenschicht diese Daten für Batterieanzeigen oder Warnungen bei niedrigem Akkustand nutzen, während die Domänenschicht sie für die Implementierung von Energiesparrichtlinien verwenden kann.  
* **Relevante Referenzmaterialien & Analyse:**  
  * 31 (UPower D-Bus ref.xml), 6 (UPower Interface-Details), 32 (UPower Methoden/Signale), 32 (UPower D-Bus API Referenz): Diese Dokumente beschreiben die D-Bus-Schnittstelle von UPower, einschließlich der relevanten Objekte, Methoden (EnumerateDevices, GetDisplayDevice), Signale (DeviceAdded, DeviceRemoved, PropertiesChanged) und Eigenschaften (OnBattery, LidIsClosed, Percentage, State, TimeToEmpty, TimeToFull).  
  * 11 (PropertiesChanged-Signal), 33 (DeviceAdded-Signal), 34 (DeviceRemoved-Signal): Spezifische Details zu wichtigen Signalen.  
  * zbus-Snippets 8: Diese demonstrieren die allgemeine Verwendung der zbus-Bibliothek für die D-Bus-Kommunikation, einschließlich Proxy-Generierung, Methodenaufrufe und Signalbehandlung, was direkt auf die Implementierung dieses Moduls anwendbar ist. Die Analyse dieser Quellen zeigt, dass dieses Modul zbus verwenden wird, um Proxys für die Interfaces org.freedesktop.UPower und org.freedesktop.UPower.Device zu generieren. Es muss eine Verbindung zum System-Bus herstellen, Geräte auflisten, das "Display-Gerät" abrufen und Signale wie PropertiesChanged auf relevanten Geräteobjekten sowie DeviceAdded/DeviceRemoved auf dem Manager-Objekt abonnieren.

### **B. Entwicklungs-Submodule & Dateien**

* **1\. system::dbus::upower\_interface::client**  
  * Dateien: system/dbus/upower\_interface/client.rs  
  * Verantwortlichkeiten: Verwaltet die D-Bus-Verbindung, Proxy-Objekte, Methodenaufrufe und die Behandlung von Signalen. Enthält die Hauptlogik des UPower-Clients.  
* **2\. system::dbus::upower\_interface::types**  
  * Dateien: system/dbus/upower\_interface/types.rs  
  * Verantwortlichkeiten: Definiert Rust-Strukturen und Enums, die UPower-Daten abbilden (z.B. PowerDeviceDetails, PowerDeviceState, PowerSupplyType, UPowerManagerProperties). Diese Strukturen dienen der internen Repräsentation der von D-Bus erhaltenen Daten.  
* **3\. system::dbus::upower\_interface::errors**  
  * Dateien: system/dbus/upower\_interface/errors.rs  
  * Verantwortlichkeiten: Definiert das UPowerError-Enum für spezifische Fehler dieses Moduls.

### **C. Schlüsseldatenstrukturen**

* UPowerClient: Hauptstruktur des Moduls, die den Zustand des UPower-Clients verwaltet.  
  * connection: zbus::Connection (Die aktive D-Bus-Verbindung)  
  * manager\_proxy: Arc\<UPowerManagerProxy\> (Proxy für org.freedesktop.UPower)  
  * devices: Arc\<Mutex\<HashMap\<ObjectPath\<'static\>, PowerDeviceDetails\>\>\> (Speichert Details zu allen bekannten Energiegeräten, geschützt durch einen Mutex für thread-sicheren Zugriff)  
  * display\_device\_path: Arc\<Mutex\<Option\<ObjectPath\<'static\>\>\>\> (Pfad zum "Display Device")  
  * manager\_properties: Arc\<Mutex\<UPowerManagerProperties\>\> (Aktuelle Eigenschaften des UPower-Managers wie OnBattery, LidIsClosed, LidIsPresent)  
  * internal\_event\_sender: tokio::sync::broadcast::Sender\<UPowerEvent\> (Sender für interne Ereignisse)  
* UPowerManagerProperties: Speichert die Eigenschaften des org.freedesktop.UPower-Managers.  
  * daemon\_version: String  
  * on\_battery: bool  
  * lid\_is\_closed: bool  
  * lid\_is\_present: bool  
* PowerDeviceDetails (Rust-Struktur zur Abbildung von org.freedesktop.UPower.Device-Eigenschaften):  
  * object\_path: ObjectPath\<'static\>  
  * vendor: String  
  * model: String  
  * kind: PowerSupplyType (Rust Enum, das uint32 UPowerDeviceLevel abbildet: Unknown, None, LinePower, Battery, Ups, Monitor, Mouse, Keyboard, Pda, Phone, GamingInput, BluetoothGeneric, Tablet, Camera, PortableAudioPlayer, Toy, Computer, Wireless, Last)  
  * percentage: f64  
  * state: PowerDeviceState (Rust Enum, das uint32 UPowerDeviceState abbildet: Unknown, Charging, Discharging, Empty, FullyCharged, PendingCharge, PendingDischarge)  
  * time\_to\_empty: Option\<std::time::Duration\>  
  * time\_to\_full: Option\<std::time::Duration\>  
  * icon\_name: String  
  * is\_rechargeable: bool  
  * capacity: f64 (in Prozent, normalisierte Kapazität)  
  * technology: PowerDeviceTechnology (Rust Enum: Unknown, LithiumIon, LithiumPolymer, LithiumIronPhosphate, LeadAcid, NickelCadmium, NickelMetalHydride)  
  * temperature: Option\<f64\> (in Grad Celsius)  
  * serial: String  
* UPowerEvent (internes Event-Enum):  
  * DeviceAdded { path: ObjectPath\<'static\>, details: PowerDeviceDetails }  
  * DeviceRemoved { path: ObjectPath\<'static\> }  
  * DeviceUpdated { path: ObjectPath\<'static\>, details: PowerDeviceDetails }  
  * ManagerPropertiesChanged { properties: UPowerManagerProperties }

**Tabelle: UPower Interface-Datenstrukturen**

| Struct/Enum Name | Felder (Name, Rust-Typ, nullable, Mutabilität) | Beschreibung | Korrespondierendes D-Bus-Element/Konzept |
| :---- | :---- | :---- | :---- |
| UPowerClient | connection: zbus::Connection \<br\> manager\_proxy: Arc\<UPowerManagerProxy\> \<br\> devices: Arc\<Mutex\<HashMap\<ObjectPath\<'static\>, PowerDeviceDetails\>\>\> \<br\> display\_device\_path: Arc\<Mutex\<Option\<ObjectPath\<'static\>\>\>\> \<br\> manager\_properties: Arc\<Mutex\<UPowerManagerProperties\>\> \<br\> internal\_event\_sender: tokio::sync::broadcast::Sender\<UPowerEvent\> | Hauptclientstruktur, verwaltet Verbindung, Proxys und aggregierten Zustand. | Gesamte Interaktion mit UPower |
| UPowerManagerProperties | daemon\_version: String \<br\> on\_battery: bool \<br\> lid\_is\_closed: bool \<br\> lid\_is\_present: bool | Speichert die Eigenschaften des UPower-Managers. | Eigenschaften von org.freedesktop.UPower |
| PowerDeviceDetails | object\_path: ObjectPath\<'static\> \<br\> vendor: String \<br\> model: String \<br\> kind: PowerSupplyType \<br\> percentage: f64 \<br\> state: PowerDeviceState \<br\> time\_to\_empty: Option\<Duration\> \<br\> time\_to\_full: Option\<Duration\> \<br\> icon\_name: String \<br\> is\_rechargeable: bool \<br\> capacity: f64 \<br\> technology: PowerDeviceTechnology \<br\> temperature: Option\<f64\> \<br\> serial: String | Detaillierte Informationen über ein einzelnes Energiegerät. | Eigenschaften von org.freedesktop.UPower.Device |
| PowerSupplyType (Enum) | Varianten wie LinePower, Battery, etc. | Typ des Energieversorgungsgeräts. | Type Eigenschaft von org.freedesktop.UPower.Device (eine uint32) |
| PowerDeviceState (Enum) | Varianten wie Charging, Discharging, etc. | Aktueller Lade-/Entladezustand des Geräts. | State Eigenschaft von org.freedesktop.UPower.Device (eine uint32) |
| PowerDeviceTechnology (Enum) | Varianten wie LithiumIon, etc. | Technologie des Energiegeräts. | Technology Eigenschaft von org.freedesktop.UPower.Device (eine uint32) |
| UPowerEvent (Enum) | DeviceAdded, DeviceRemoved, DeviceUpdated, ManagerPropertiesChanged | Interne Ereignisse zur Signalisierung von Zustandsänderungen. | D-Bus Signale von UPower |

Die sorgfältige Definition dieser Rust-Strukturen und Enums ist entscheidend, um die über D-Bus empfangenen Daten typsicher und ergonomisch in der Rust-Umgebung zu verarbeiten. Die Verwendung von Arc\<Mutex\<...\>\> für gemeinsam genutzte Zustände wie devices und manager\_properties ist notwendig, um thread-sicheren Zugriff aus asynchronen Signal-Handlern zu gewährleisten. Der tokio::sync::broadcast::Sender ermöglicht es, interne Zustandsänderungen an andere Teile des Systems zu propagieren.

### **D. D-Bus Interface Proxys (Generiert durch zbus::proxy)**

* UPowerManagerProxy für org.freedesktop.UPower auf /org/freedesktop/UPower.  
  * Methoden:  
    * async fn enumerate\_devices(\&self) \-\> zbus::Result\<Vec\<ObjectPath\<'static\>\>\>; 6  
    * async fn get\_display\_device(\&self) \-\> zbus::Result\<ObjectPath\<'static\>\>; 6  
    * async fn get\_critical\_action(\&self) \-\> zbus::Result\<String\>; 6  
  * Eigenschaften (mittels \#\[zbus(property)\] auf Getter-Methoden):  
    * async fn daemon\_version(\&self) \-\> zbus::Result\<String\>; 6  
    * async fn on\_battery(\&self) \-\> zbus::Result\<bool\>; 6  
    * async fn lid\_is\_closed(\&self) \-\> zbus::Result\<bool\>; 6  
    * async fn lid\_is\_present(\&self) \-\> zbus::Result\<bool\>; 6  
  * Signale (mittels \#\[zbus(signal)\] auf Handler-Methoden im Trait, die dann Streams zurückgeben):  
    * async fn receive\_device\_added(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, ObjectPath\<'static\>\>\>; (für DeviceAdded(o object\_path)) 6  
    * async fn receive\_device\_removed(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, ObjectPath\<'static\>\>\>; (für DeviceRemoved(o object\_path)) 6  
    * 6  
* UPowerDeviceProxy für org.freedesktop.UPower.Device auf gerätespezifischen Pfaden.  
  * Eigenschaften (Beispiele, alle als async fn name(\&self) \-\> zbus::Result\<Type\>;):  
    * vendor (String)  
    * model (String)  
    * type\_ (u32) \-\> wird zu PowerSupplyType gemappt  
    * percentage (f64)  
    * state (u32) \-\> wird zu PowerDeviceState gemappt  
    * time\_to\_empty (i64) \-\> wird zu Option\<Duration\> gemappt  
    * time\_to\_full (i64) \-\> wird zu Option\<Duration\> gemappt  
    * icon\_name (String)  
    * is\_rechargeable (bool)  
    * capacity (f64)  
    * technology (u32) \-\> wird zu PowerDeviceTechnology gemappt  
    * temperature (f64) (kann nicht vorhanden sein, daher Option\<f64\>)  
    * serial (String)  
  * Signal:  
    * async fn receive\_properties\_changed(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, PropertiesChangedArgs\>\>;  
      * PropertiesChangedArgs struct:  
        Rust  
        \#  
        pub struct PropertiesChangedArgs {  
            pub interface\_name: String,  
            pub changed\_properties: std::collections::HashMap\<String, zbus::zvariant::OwnedValue\>,  
            pub invalidated\_properties: Vec\<String\>,  
        }  
        7

**Tabelle: UPower D-Bus Proxys und Member**

| Proxy Name | D-Bus Interface | Schlüsselelemente (Methoden/Eigenschaften/Signale) | Rust Signatur (Beispiel) | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| UPowerManagerProxy | org.freedesktop.UPower | EnumerateDevices (Methode) | async fn enumerate\_devices(\&self) \-\> zbus::Result\<Vec\<ObjectPath\<'static\>\>\> | Listet alle bekannten Energiegeräte auf. |
|  |  | GetDisplayDevice (Methode) | async fn get\_display\_device(\&self) \-\> zbus::Result\<ObjectPath\<'static\>\> | Gibt den Pfad des primären Anzeigegeräts zurück. |
|  |  | OnBattery (Eigenschaft) | \#\[zbus(property)\] async fn on\_battery(\&self) \-\> zbus::Result\<bool\> | Gibt an, ob das System im Akkubetrieb läuft. |
|  |  | LidIsClosed (Eigenschaft) | \#\[zbus(property)\] async fn lid\_is\_closed(\&self) \-\> zbus::Result\<bool\> | Gibt an, ob der Laptopdeckel geschlossen ist. |
|  |  | DeviceAdded (Signal) | \#\[zbus(signal)\] async fn device\_added(\&self, device\_path: ObjectPath\<'static\>) \-\> zbus::Result\<()\>; (Stream-Methode: receive\_device\_added) | Wird gesendet, wenn ein neues Energiegerät hinzugefügt wird. |
|  |  | DeviceRemoved (Signal) | \#\[zbus(signal)\] async fn device\_removed(\&self, device\_path: ObjectPath\<'static\>) \-\> zbus::Result\<()\>; (Stream-Methode: receive\_device\_removed) | Wird gesendet, wenn ein Energiegerät entfernt wird. |
| UPowerDeviceProxy | org.freedesktop.UPower.Device | Percentage (Eigenschaft) | \#\[zbus(property)\] async fn percentage(\&self) \-\> zbus::Result\<f64\> | Aktueller Ladestand in Prozent. |
|  |  | State (Eigenschaft) | \#\[zbus(property)\] async fn state(\&self) \-\> zbus::Result\<u32\> | Aktueller Zustand des Geräts (Laden, Entladen, etc.). |
|  |  | TimeToEmpty (Eigenschaft) | \#\[zbus(property)\] async fn time\_to\_empty(\&self) \-\> zbus::Result\<i64\> | Geschätzte verbleibende Zeit bis leer (Sekunden). |
|  |  | PropertiesChanged (Signal) | \#\[zbus(signal)\] async fn properties\_changed(\&self, interface\_name: String, changed\_properties: HashMap\<String, zvariant::OwnedValue\>, invalidated\_properties: Vec\<String\>) \-\> zbus::Result\<()\>; (Stream-Methode: receive\_properties\_changed) | Wird gesendet, wenn sich Eigenschaften des Geräts ändern. |

Diese Tabellenstruktur verdeutlicht die direkte Abbildung zwischen den D-Bus-Spezifikationen und der Rust-Proxy-Implementierung, was für Entwickler, die diese Schnittstelle nutzen oder erweitern müssen, von großem Wert ist. Die Verwendung des \#\[zbus(proxy)\]-Makros 9 automatisiert die Generierung des Boilerplate-Codes für diese Proxys erheblich.

### **E. Fehlerbehandlung**

* UPowerError Enum (definiert in system/dbus/upower\_interface/errors.rs):  
  Rust  
  use thiserror::Error;  
  use zbus::zvariant::ObjectPath;

  \#  
  pub enum UPowerError {  
      \#  
      Connection(\#\[from\] zbus::Error),

      \#  
      ServiceUnavailable,

      \#  
      MethodCall { method: String, error: zbus::Error },

      \#\[error("Invalid data received from UPower service: {context}")\]  
      InvalidData { context: String },

      \#\[error("UPower device not found at path: {path}")\]  
      DeviceNotFound { path: String }, // Früher: path: ObjectPath\<'static\> \- String ist einfacher für Display

      \#  
      SignalSubscriptionFailed { signal\_name: String, error: zbus::Error },

      \#\[error("Internal error during UPower client operation: {0}")\]  
      Internal(String),  
  }

**Tabelle: UPowerError Varianten**

| Variantenname | Beschreibung | Typischer Auslöser |
| :---- | :---- | :---- |
| Connection | Fehler beim Herstellen der D-Bus-Verbindung oder allgemeiner D-Bus-Fehler. | zbus::Connection::system().await schlägt fehl; zugrundeliegende D-Bus-Fehler von zbus. |
| ServiceUnavailable | Der UPower-Dienst (org.freedesktop.UPower) ist auf dem System-Bus nicht erreichbar. | UPower-Daemon läuft nicht oder ist nicht korrekt registriert. |
| MethodCall | Fehler beim Aufrufen einer D-Bus-Methode auf einem UPower-Interface. | Methode existiert nicht, falsche Parameter, Dienst antwortet mit Fehler. |
| InvalidData | Ungültige oder unerwartete Daten vom UPower-Dienst empfangen. | Unerwartete Variant-Typen, Enum-Werte außerhalb des definierten Bereichs. |
| DeviceNotFound | Ein spezifisches UPower-Gerät konnte unter dem erwarteten Pfad nicht gefunden werden. | GetDisplayDevice gibt einen Pfad zurück, der nicht mehr gültig ist; veraltete Gerätepfade. |
| SignalSubscriptionFailed | Fehler beim Abonnieren eines D-Bus-Signals von UPower. | Probleme mit Match-Regeln, Dienst unterstützt Signal nicht wie erwartet. |
| Internal | Ein interner Fehler im UPower-Client-Modul. | Logische Fehler in der Client-Implementierung. |

### **F. Detaillierte Implementierungsschritte**

1. **Proxy-Definitionen:** Definiere die Rust-Traits UPowerManagerProxy und UPowerDeviceProxy mit dem \#\[zbus::proxy\]-Attribut, die die Methoden, Eigenschaften und Signale der entsprechenden D-Bus-Interfaces (org.freedesktop.UPower und org.freedesktop.UPower.Device) abbilden.9  
2. **UPowerClient::connect\_and\_initialize() asynchrone Funktion:**  
   * Stelle eine Verbindung zum D-Bus System-Bus her: let connection \= zbus::Connection::system().await.map\_err(UPowerError::Connection)?;  
   * Erstelle den UPowerManagerProxy: let manager\_proxy \= Arc::new(UPowerManagerProxy::new(\&connection).await.map\_err(|e| UPowerError::MethodCall { method: "UPowerManagerProxy::new".to\_string(), error: e })?);  
   * Initialisiere devices: Arc\<Mutex\<HashMap\<ObjectPath\<'static\>, PowerDeviceDetails\>\>\> als leer.  
   * Initialisiere manager\_properties: Arc\<Mutex\<UPowerManagerProperties\>\> durch Abrufen aller Manager-Eigenschaften (daemon\_version, on\_battery, lid\_is\_closed, lid\_is\_present) über den manager\_proxy.  
   * Rufe manager\_proxy.enumerate\_devices().await auf. Für jeden zurückgegebenen ObjectPath:  
     * Erstelle einen UPowerDeviceProxy für diesen Pfad: let device\_proxy \= UPowerDeviceProxy::builder(\&connection).path(path.clone())?.build().await?;  
     * Rufe alle relevanten Eigenschaften dieses device\_proxy ab (z.B. percentage(), state(), kind(), time\_to\_empty(), time\_to\_full(), icon\_name(), vendor(), model(), etc.).  
     * Konvertiere die Rohdaten (z.B. u32 für state und kind) in die entsprechenden Rust-Enums (PowerDeviceState, PowerSupplyType). Konvertiere i64 Sekunden in Option\<Duration\>.  
     * Erstelle eine PowerDeviceDetails-Instanz und füge sie zur devices-HashMap hinzu.  
   * Rufe manager\_proxy.get\_display\_device().await auf und speichere den Pfad in display\_device\_path.  
   * Erstelle den tokio::sync::broadcast::channel für UPowerEvent.  
   * Gib eine UPowerClient-Instanz mit der Verbindung, den Proxys, dem initialen Zustand und dem Sender des Broadcast-Kanals zurück.  
3. **Signalbehandlung (in separaten tokio::spawn-Tasks oder integriert in einen Haupt-Event-Loop-Dispatcher):**  
   * **Manager-Signale:**  
     * Abonniere manager\_proxy.receive\_device\_added().await?. In der Schleife:  
       * Wenn ein DeviceAdded(path)-Signal empfangen wird: Erstelle einen neuen UPowerDeviceProxy für path, rufe alle seine Eigenschaften ab, erstelle PowerDeviceDetails, füge es zu devices (unter Mutex-Sperre) hinzu und sende ein UPowerEvent::DeviceAdded über den Broadcast-Kanal.  
     * Abonniere manager\_proxy.receive\_device\_removed().await?. In der Schleife:  
       * Wenn ein DeviceRemoved(path)-Signal empfangen wird: Entferne den Eintrag aus devices (unter Mutex-Sperre) und sende ein UPowerEvent::DeviceRemoved über den Broadcast-Kanal.  
     * Abonniere manager\_proxy.receive\_properties\_changed().await? (für Eigenschaften des Manager-Objekts selbst, wie OnBattery, LidIsClosed). In der Schleife:  
       * Aktualisiere die Felder in manager\_properties (unter Mutex-Sperre) basierend auf den changed\_properties im Signal.  
       * Sende ein UPowerEvent::ManagerPropertiesChanged über den Broadcast-Kanal.  
   * **Device-Signale (für jedes Gerät in devices):**  
     * Beim Hinzufügen eines Geräts (oder bei der Initialisierung), abonniere dessen device\_proxy.receive\_properties\_changed().await?. In der Schleife für jedes Gerät:  
       * Wenn ein PropertiesChanged-Signal für dieses Gerät empfangen wird:  
         * Extrahiere changed\_properties und invalidated\_properties aus den Signal-Argumenten.  
         * Aktualisiere die entsprechenden Felder in der PowerDeviceDetails-Instanz für dieses Gerät in der devices-HashMap (unter Mutex-Sperre). Achte auf die korrekte Deserialisierung der zbus::zvariant::OwnedValue.  
         * Sende ein UPowerEvent::DeviceUpdated mit dem Pfad und den aktualisierten Details über den Broadcast-Kanal.  
4. **Öffentliche Methoden auf UPowerClient:**  
   * fn is\_on\_battery(\&self) \-\> bool: Gibt den Wert aus self.manager\_properties zurück.  
   * fn is\_lid\_closed(\&self) \-\> bool: Gibt den Wert aus self.manager\_properties zurück.  
   * fn get\_all\_devices(\&self) \-\> Vec\<PowerDeviceDetails\>: Gibt eine Kopie der Werte aus self.devices zurück.  
   * fn get\_display\_device\_details(\&self) \-\> Option\<PowerDeviceDetails\>: Gibt die Details für das Gerät unter self.display\_device\_path zurück.  
   * fn subscribe\_events(\&self) \-\> tokio::sync::broadcast::Receiver\<UPowerEvent\>: Gibt einen neuen Empfänger für den internen Event-Kanal zurück.

### **G. Interaktionen**

* **Core Layer:** Stellt die async-Laufzeitumgebung (z.B. tokio) bereit, die für zbus und die asynchrone Signalbehandlung benötigt wird.  
* **Domain Layer:** Abonniert die von UPowerClient über den internen Event-Bus (Broadcast-Kanal) gesendeten UPowerEvent-Ereignisse. Nutzt diese Informationen, um Energiesparrichtlinien zu implementieren (z.B. Bildschirm dimmen bei niedrigem Akkustand, System in den Ruhezustand versetzen bei kritischem Akkustand, Aktionen bei geschlossenem Deckel).  
* **UI Layer:** Abonniert ebenfalls die UPowerEvent-Ereignisse. Verwendet die Informationen, um Energiestatusanzeigen (Batterie-Icon, verbleibende Zeit, Ladestatus), Warnungen und ggf. Einstellungsoptionen für Energieverwaltung darzustellen.  
* **Event Bus:** Der UPowerClient fungiert als Herausgeber von UPowerEvent-Ereignissen (DeviceAdded, DeviceRemoved, DeviceUpdated, ManagerPropertiesChanged) auf einem internen, systemweiten Event-Bus (hier implementiert mit tokio::sync::broadcast).

### **H. Vertiefende Betrachtungen & Implikationen**

Die Implementierung eines robusten UPower-Clients erfordert eine sorgfältige Handhabung von asynchronen Signalen und die korrekte Interpretation der feingranularen Eigenschaftsänderungen.  
UPower's PropertiesChanged-Signal 7 liefert detaillierte Informationen darüber, welche Eigenschaften sich geändert haben und welche ungültig geworden sind. Anstatt bei jedem Signal alle Eigenschaften eines Geräts neu abzufragen, sollte der Client die changed\_properties (ein Dictionary von Eigenschaftsnamen zu neuen Werten) und invalidated\_properties (eine Liste von Eigenschaftsnamen, deren Werte nicht mehr gültig sind) auswerten. Dies erfordert eine effiziente Aktualisierung der lokalen PowerDeviceDetails-Struktur, indem nur die betroffenen Felder modifiziert werden. Eine sorgfältige Zuordnung zwischen den D-Bus-Eigenschaftsnamen (Strings) und den Feldern der Rust-Struktur sowie eine robuste Deserialisierung der zbus::zvariant::Value-Typen sind hierbei unerlässlich. Dieser Ansatz minimiert die D-Bus-Kommunikation und verbessert die Reaktionsfähigkeit.  
Das Konzept des "Display Device" 6 unter /org/freedesktop/UPower/devices/DisplayDevice ist eine wichtige Abstraktion, die UPower für Desktop-Umgebungen bereitstellt. Es handelt sich um ein zusammengesetztes Gerät, das den Gesamtstatus der Energieversorgung repräsentiert, der typischerweise in der Benutzeroberfläche angezeigt wird. Obwohl dieses Gerät einen bequemen Zugriff auf aggregierte Informationen bietet, ist es für ein vollständiges Bild der Energieversorgung – insbesondere in Systemen mit mehreren Batterien oder komplexen Energiekonfigurationen – notwendig, dass der Client alle Geräte über EnumerateDevices erfasst und deren Zustand individuell überwacht. Die UI-Schicht wird wahrscheinlich primär das "Display Device" für ihre Hauptanzeige nutzen, aber die Systemschicht sollte über diesen Client Zugriff auf die Details aller einzelnen Geräte ermöglichen.  
Die asynchrone Natur der D-Bus-Signalbehandlung erfordert besondere Aufmerksamkeit bei der Verwaltung des gemeinsamen Zustands. Da Signale wie DeviceAdded oder PropertiesChanged für verschiedene Geräte potenziell gleichzeitig eintreffen und verarbeitet werden könnten (abhängig von der Konfiguration des async-Executors), muss der Zugriff auf gemeinsam genutzte Datenstrukturen wie die Liste der Geräte (devices in UPowerClient) synchronisiert werden. Die Verwendung von Arc\<Mutex\<...\>\> ist hier ein gängiges Muster in Rust, um Datenkorruption oder inkonsistente Lesezugriffe zu verhindern. Die internen Ereignisse, die dieses Modul über den Broadcast-Kanal aussendet, sollten entweder unveränderliche Momentaufnahmen der Daten transportieren, oder die Abonnenten dieser Ereignisse müssen ebenfalls für eine korrekte Synchronisation sorgen, falls sie auf gemeinsam genutzte Zustände zugreifen, die durch diese Ereignisse modifiziert werden könnten.

## **V. Ultra-Feinspezifikation: system::dbus::logind\_interface (Logind D-Bus Client)**

### **A. Modulübersicht und Zweck**

* **Verantwortlichkeit:** Dieses Modul interagiert mit den D-Bus-Diensten org.freedesktop.login1.Manager und org.freedesktop.login1.Session. Es überwacht Benutzersitzungen, den Status von "Seats" (logische Gruppierungen von Eingabe-/Ausgabegeräten) und Systemereignisse wie das Vorbereiten des Ruhezustands (PrepareForSleep) und das Aufwachen.  
* **Funktionen:** Es ermöglicht der Desktop-Umgebung, auf das Sperren/Entsperren von Sitzungen, Benutzerwechsel und das Vorbereiten des Systems auf den Ruhezustand zu reagieren. Es kann auch Aktionen wie das Anfordern einer Sitzungssperre initiieren.  
* **Relevante Referenzmaterialien & Analyse:**  
  * 12 (logind man page Übersicht), 13 (logind Manager Methoden), 13 (logind Manager Methoden/Signale): Geben einen Überblick über die org.freedesktop.login1.Manager-Schnittstelle, einschließlich Methoden wie GetSession, ListSessions, LockSession, UnlockSession, Inhibit und Signale wie SessionNew, SessionRemoved, PrepareForSleep.  
  * 14 (SessionNew/SessionRemoved Signale), 15 (PrepareForSleep Signal), 16 (Lock/Unlock Signale auf Session-Objekt): Spezifische Details zu wichtigen Signalen. Die Analyse dieser Quellen zeigt, dass dieses Modul zbus für die Interaktion mit logind nutzen wird. Zentrale Aspekte sind das Verfolgen der aktiven Sitzung, das Reagieren auf das PrepareForSleep-Signal zur Durchführung notwendiger Aktionen vor dem Suspend (und das zuverlässige Freigeben von Inhibit-Locks) sowie das Reagieren auf Lock/Unlock-Signale zur Steuerung des Sitzungszustands (z.B. Aktivierung des Sperrbildschirms).

### **B. Entwicklungs-Submodule & Dateien**

* **1\. system::dbus::logind\_interface::client**  
  * Dateien: system/dbus/logind\_interface/client.rs  
  * Verantwortlichkeiten: Hauptlogik des Logind-Clients, D-Bus-Verwaltung, Proxy-Interaktionen, Signalbehandlung.  
* **2\. system::dbus::logind\_interface::types**  
  * Dateien: system/dbus/logind\_interface/types.rs  
  * Verantwortlichkeiten: Definition von Rust-Strukturen und \-Enums zur Abbildung von Logind-Daten (z.B. SessionInfo, ActiveSessionState, SleepPreparationState).  
* **3\. system::dbus::logind\_interface::errors**  
  * Dateien: system/dbus/logind\_interface/errors.rs  
  * Verantwortlichkeiten: Definition des LogindError-Enums.

### **C. Schlüsseldatenstrukturen**

* LogindClient: Hauptstruktur des Moduls.  
  * connection: zbus::Connection  
  * manager\_proxy: Arc\<LogindManagerProxy\> (Proxy für org.freedesktop.login1.Manager)  
  * active\_session\_id: Arc\<Mutex\<Option\<String\>\>\> (ID der aktuellen aktiven Sitzung)  
  * active\_session\_path: Arc\<Mutex\<Option\<ObjectPath\<'static\>\>\>\>  
  * active\_session\_proxy: Arc\<Mutex\<Option\<LogindSessionProxy\>\>\> (Proxy für die aktive org.freedesktop.login1.Session)  
  * sleep\_inhibitor\_lock: Arc\<Mutex\<Option\<zbus::zvariant::OwnedFd\>\>\> (File Descriptor für den Sleep-Inhibitor-Lock)  
  * internal\_event\_sender: tokio::sync::broadcast::Sender\<LogindEvent\>  
* SessionInfo: Repräsentiert Informationen über eine Benutzersitzung.  
  * id: String  
  * user\_id: u32  
  * user\_name: String  
  * seat\_id: String  
  * object\_path: ObjectPath\<'static\>  
  * is\_active: bool  
  * is\_locked\_hint: bool (Basierend auf der LockedHint-Eigenschaft der Session)  
* LogindEvent (internes Event-Enum):  
  * PrepareForSleep { starting: bool }  
  * ActiveSessionLocked  
  * ActiveSessionUnlocked  
  * ActiveSessionChanged { new\_session\_id: Option\<String\> }  
  * SessionListChanged { sessions: Vec\<SessionInfo\> }

**Tabelle: Logind Interface-Datenstrukturen**

| Struct/Enum Name | Felder (Name, Rust-Typ, nullable, Mutabilität) | Beschreibung | Korrespondierendes D-Bus-Element/Konzept |
| :---- | :---- | :---- | :---- |
| LogindClient | connection: zbus::Connection \<br\> manager\_proxy: Arc\<LogindManagerProxy\> \<br\> active\_session\_id: Arc\<Mutex\<Option\<String\>\>\> \<br\> active\_session\_path: Arc\<Mutex\<Option\<ObjectPath\<'static\>\>\>\> \<br\> active\_session\_proxy: Arc\<Mutex\<Option\<LogindSessionProxy\>\>\> \<br\> sleep\_inhibitor\_lock: Arc\<Mutex\<Option\<zbus::zvariant::OwnedFd\>\>\> \<br\> internal\_event\_sender: tokio::sync::broadcast::Sender\<LogindEvent\> | Hauptclientstruktur, verwaltet Verbindung, Proxys, aktive Sitzungsinformationen und Inhibit-Locks. | Gesamte Interaktion mit Logind |
| SessionInfo | id: String \<br\> user\_id: u32 \<br\> user\_name: String \<br\> seat\_id: String \<br\> object\_path: ObjectPath\<'static\> \<br\> is\_active: bool \<br\> is\_locked\_hint: bool | Detaillierte Informationen über eine einzelne Benutzersitzung. | Struktur der Rückgabewerte von ListSessions und Eigenschaften von org.freedesktop.login1.Session |
| LogindEvent (Enum) | PrepareForSleep { starting: bool } \<br\> ActiveSessionLocked \<br\> ActiveSessionUnlocked \<br\> ActiveSessionChanged {... } \<br\> SessionListChanged {... } | Interne Ereignisse zur Signalisierung von Zustandsänderungen im Logind-Kontext. | D-Bus Signale von Logind (PrepareForSleep, Lock, Unlock auf Session-Objekt, SessionNew, SessionRemoved) |

Die LogindClient-Struktur kapselt die gesamte Logik für die Interaktion mit logind. Die active\_session\_id und der zugehörige Proxy sind zentral, da viele Aktionen sitzungsspezifisch sind. Der sleep\_inhibitor\_lock ist kritisch für die korrekte Handhabung von Suspend-Zyklen.

### **D. D-Bus Interface Proxys (Generiert durch zbus::proxy)**

* LogindManagerProxy für org.freedesktop.login1.Manager auf /org/freedesktop/login1.  
  * Methoden:  
    * async fn get\_session(\&self, session\_id: \&str) \-\> zbus::Result\<ObjectPath\<'static\>\>; 12  
    * async fn list\_sessions(\&self) \-\> zbus::Result\<Vec\<(String, u32, String, String, ObjectPath\<'static\>)\>\>; (session\_id, uid, user\_name, seat\_id, object\_path) 13  
    * async fn lock\_session(\&self, session\_id: \&str) \-\> zbus::Result\<()\>; 13  
    * async fn unlock\_session(\&self, session\_id: \&str) \-\> zbus::Result\<()\>; 13  
    * async fn inhibit(\&self, what: \&str, who: \&str, why: \&str, mode: \&str) \-\> zbus::Result\<zbus::zvariant::OwnedFd\>; (z.B. what: "sleep:shutdown:idle", who: "Desktop Environment", why: "Saving state", mode: "delay") 13  
  * Signale:  
    * async fn receive\_session\_new(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, SessionNewArgs\>\>; (struct SessionNewArgs { session\_id: String, object\_path: ObjectPath\<'static\> }) 14  
    * async fn receive\_session\_removed(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, SessionRemovedArgs\>\>; (struct SessionRemovedArgs { session\_id: String, object\_path: ObjectPath\<'static\> }) 14  
    * async fn receive\_prepare\_for\_sleep(\&self) \-\> zbus::Result\<zbus::SignalStream\<'\_, bool\>\>; (start: bool) 15  
* LogindSessionProxy für org.freedesktop.login1.Session auf sitzungsspezifischen Pfaden.  
  * Eigenschaften:  
    * \#\[zbus(property)\] async fn active(\&self) \-\> zbus::Result\<bool\>;  
    * \#\[zbus(property)\] async fn locked\_hint(\&self) \-\> zbus::Result\<bool\>;  
    * \#\[zbus(property)\] async fn id(\&self) \-\> zbus::Result\<String\>;  
    * \#\[zbus(property)\] async fn user(\&self) \-\> zbus::Result\<(u32, ObjectPath\<'static\>)\>; (uid, user\_path)  
    * \#\[zbus(property)\] async fn seat(\&self) \-\> zbus::Result\<(String, ObjectPath\<'static\>)\>; (seat\_id, seat\_path)  
  * Signale (die der Session-Manager der DE abhört, nicht unbedingt dieser Client direkt, aber relevant für das Verständnis):  
    * Lock() 16  
    * Unlock() 16

**Tabelle: Logind D-Bus Proxys und Member**

| Proxy Name | D-Bus Interface | Schlüsselelemente (Methoden/Eigenschaften/Signale) | Rust Signatur (Beispiel) | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| LogindManagerProxy | org.freedesktop.login1.Manager | ListSessions (Methode) | async fn list\_sessions(\&self) \-\> zbus::Result\<Vec\<(String, u32, String, String, ObjectPath\<'static\>)\>\> | Listet alle aktuellen Benutzersitzungen auf. |
|  |  | LockSession (Methode) | async fn lock\_session(\&self, session\_id: \&str) \-\> zbus::Result\<()\> | Fordert das Sperren einer bestimmten Sitzung an. |
|  |  | Inhibit (Methode) | async fn inhibit(\&self, what: \&str, who: \&str, why: \&str, mode: \&str) \-\> zbus::Result\<zbus::zvariant::OwnedFd\> | Nimmt einen Inhibit-Lock, um Systemaktionen (z.B. Suspend) zu verzögern. |
|  |  | SessionNew (Signal) | \#\[zbus(signal)\] async fn session\_new(\&self, session\_id: String, object\_path: ObjectPath\<'static\>) \-\> zbus::Result\<()\>; | Wird gesendet, wenn eine neue Sitzung erstellt wird. |
|  |  | PrepareForSleep (Signal) | \#\[zbus(signal)\] async fn prepare\_for\_sleep(\&self, start: bool) \-\> zbus::Result\<()\>; | Wird gesendet, bevor das System in den Ruhezustand geht oder nachdem es aufwacht. |
| LogindSessionProxy | org.freedesktop.login1.Session | Active (Eigenschaft) | \#\[zbus(property)\] async fn active(\&self) \-\> zbus::Result\<bool\>; | Gibt an, ob die Sitzung aktiv ist. |
|  |  | LockedHint (Eigenschaft) | \#\[zbus(property)\] async fn locked\_hint(\&self) \-\> zbus::Result\<bool\>; | Gibt an, ob die Sitzung als gesperrt markiert ist. |
|  |  | Lock (Signal) | \#\[zbus(signal)\] async fn lock(\&self) \-\> zbus::Result\<()\>; | Signalisiert, dass die Sitzung gesperrt werden soll (wird vom Session-Manager empfangen). |

### **E. Fehlerbehandlung**

* LogindError Enum (definiert in system/dbus/logind\_interface/errors.rs):  
  Rust  
  use thiserror::Error;  
  use zbus::zvariant::OwnedObjectPath; // Korrigiert von ObjectPath zu OwnedObjectPath für SignalArgs

  \#  
  pub enum LogindError {  
      \#  
      Connection(\#\[from\] zbus::Error),

      \#  
      ServiceUnavailable,

      \#  
      MethodCall { method: String, error: zbus::Error },

      \#  
      SessionNotFound { session\_id: String },

      \#\[error("Failed to take inhibitor lock from logind: {reason}")\]  
      InhibitFailed { reason: String },

      \#\[error("No active session found for this desktop environment.")\]  
      NoActiveSession,

      \#  
      SignalSubscriptionFailed { signal\_name: String, error: zbus::Error },

      \#\[error("Internal error during logind client operation: {0}")\]  
      Internal(String),  
  }

**Tabelle: LogindError Varianten**

| Variantenname | Beschreibung | Typischer Auslöser |
| :---- | :---- | :---- |
| Connection | Fehler beim Herstellen der D-Bus-Verbindung oder allgemeiner D-Bus-Fehler. | zbus::Connection::system().await schlägt fehl. |
| ServiceUnavailable | Der Logind-Dienst ist auf dem System-Bus nicht erreichbar. | systemd-logind läuft nicht oder ist nicht korrekt registriert. |
| MethodCall | Fehler beim Aufrufen einer D-Bus-Methode auf einem Logind-Interface. | Methode existiert nicht, falsche Parameter, Dienst antwortet mit Fehler. |
| SessionNotFound | Eine Sitzung mit der angegebenen ID konnte nicht gefunden werden. | LockSession mit einer ungültigen ID aufgerufen. |
| InhibitFailed | Fehler beim Anfordern eines Inhibit-Locks von Logind. | Logind verweigert den Lock (z.B. keine Berechtigung, ungültige Parameter). |
| NoActiveSession | Es konnte keine aktive Sitzung für die laufende Desktop-Umgebung identifiziert werden. | Fehler bei der Logik zur Erkennung der aktiven Sitzung. |
| SignalSubscriptionFailed | Fehler beim Abonnieren eines D-Bus-Signals von Logind. | Probleme mit Match-Regeln. |
| Internal | Ein interner Fehler im Logind-Client-Modul. | Logische Fehler in der Client-Implementierung. |

### **F. Detaillierte Implementierungsschritte**

1. **Proxy-Definitionen:** Definiere die Rust-Traits LogindManagerProxy und LogindSessionProxy mit dem \#\[zbus::proxy\]-Attribut für die D-Bus-Interfaces org.freedesktop.login1.Manager und org.freedesktop.login1.Session.  
2. **LogindClient::connect\_and\_initialize() asynchrone Funktion:**  
   * Stelle Verbindung zum D-Bus System-Bus her und erstelle LogindManagerProxy.  
   * Identifiziere die aktive Sitzung:  
     * Rufe manager\_proxy.list\_sessions().await auf.  
     * Iteriere durch die Liste der Sessions. Für jede Session, erstelle temporär einen LogindSessionProxy für deren ObjectPath.  
     * Rufe die active().await-Eigenschaft auf diesem Session-Proxy ab.  
     * Die erste Session mit active \== true (und idealerweise passendem seat\_id, falls bekannt) wird als die aktive Sitzung betrachtet. Speichere deren session\_id, object\_path und den LogindSessionProxy in den Arc\<Mutex\<...\>\>-Feldern von LogindClient.  
     * Wenn keine aktive Sitzung gefunden wird, gib LogindError::NoActiveSession zurück.  
   * Erstelle den tokio::sync::broadcast::channel für LogindEvent.  
   * Gib eine LogindClient-Instanz zurück.  
3. **Signalbehandlung (in separaten tokio::spawn-Tasks):**  
   * **PrepareForSleep-Signal:**  
     * Abonniere manager\_proxy.receive\_prepare\_for\_sleep().await?.  
     * In der Signal-Schleife:  
       * Wenn start \== true (System bereitet sich auf Suspend vor):  
         * Versuche, einen Inhibit-Lock zu nehmen: let fd \= manager\_proxy.inhibit("sleep", "MyDesktopEnvironment", "Preparing for sleep", "delay").await.map\_err(|e| LogindError::InhibitFailed { reason: e.to\_string() })?;  
         * Speichere den OwnedFd (File Descriptor) in sleep\_inhibitor\_lock (unter Mutex-Sperre).  
         * Sende LogindEvent::PrepareForSleep { starting: true } über den Broadcast-Kanal.  
         * (Die Domänen-/UI-Schicht muss auf dieses Event reagieren und ihre Vorbereitungen treffen. Nach Abschluss oder Timeout muss ein Mechanismus existieren, um den Inhibit-Lock freizugeben.)  
       * Wenn start \== false (System wacht auf):  
         * Gib den Inhibit-Lock frei, falls einer gehalten wird: if let Some(fd) \= self.sleep\_inhibitor\_lock.lock().await.take() { drop(fd); } (Das drop auf OwnedFd schließt den FD und gibt den Lock frei).  
         * Sende LogindEvent::PrepareForSleep { starting: false } über den Broadcast-Kanal.  
   * **SessionNew / SessionRemoved-Signale:**  
     * Abonniere manager\_proxy.receive\_session\_new().await? und manager\_proxy.receive\_session\_removed().await?.  
     * Bei Empfang: Aktualisiere die interne Liste der bekannten Sitzungen (falls eine solche geführt wird, ansonsten primär für die ActiveSessionChanged-Logik relevant). Prüfe, ob sich die aktive Sitzung geändert hat. Wenn ja, aktualisiere active\_session\_id, active\_session\_path, active\_session\_proxy und sende LogindEvent::ActiveSessionChanged. Sende auch LogindEvent::SessionListChanged.  
   * **Lock / Unlock-Signale der aktiven Session (optional, falls die DE nicht selbst der Session-Manager ist, der diese direkt verarbeitet):**  
     * Wenn ein active\_session\_proxy vorhanden ist, abonniere dessen receive\_lock\_signal().await? und receive\_unlock\_signal().await? (falls diese Signale vom LogindSessionProxy so generiert werden; alternativ PropertiesChanged für LockedHint überwachen).  
     * Bei Lock-Signal: Sende LogindEvent::ActiveSessionLocked.  
     * Bei Unlock-Signal: Sende LogindEvent::ActiveSessionUnlocked.  
     * Bei PropertiesChanged auf LockedHint der aktiven Session: Entsprechend ActiveSessionLocked/Unlocked senden.  
4. **Öffentliche Methoden auf LogindClient:**  
   * async fn request\_lock\_active\_session(\&self) \-\> Result\<(), LogindError\>:  
     * Rufe die active\_session\_id ab (unter Mutex-Sperre).  
     * Wenn vorhanden, rufe self.manager\_proxy.lock\_session(\&session\_id).await.  
   * async fn request\_unlock\_active\_session(\&self) \-\> Result\<(), LogindError\>:  
     * Analog zu request\_lock\_active\_session mit unlock\_session.  
   * fn subscribe\_events(\&self) \-\> tokio::sync::broadcast::Receiver\<LogindEvent\>: Gibt einen neuen Empfänger für den internen Event-Kanal zurück.  
   * fn release\_sleep\_inhibitor(\&self): Methode, die von anderen Teilen des Systems aufgerufen werden kann, um den Sleep-Inhibitor explizit freizugeben, nachdem die Vorbereitungen für den Suspend abgeschlossen sind.

### **G. Interaktionen**

* **Core Layer:** Stellt die async-Laufzeitumgebung und FD-Handling-Fähigkeiten bereit (für den Inhibit-Lock).  
* **Domain Layer:** Empfängt LogindEvent::PrepareForSleep, um Zustände zu speichern oder laufende Operationen zu pausieren. Reagiert auf ActiveSessionLocked/Unlocked für Policy-Anpassungen (z.B. Deaktivierung bestimmter Hintergrunddienste).  
* **UI Layer:** Empfängt ActiveSessionLocked/Unlocked, um den Sperrbildschirm anzuzeigen/auszublenden oder andere UI-Anpassungen vorzunehmen. Kann request\_lock\_active\_session aufrufen.  
* **Event Bus:** Der LogindClient gibt LogindEvent-Ereignisse (PrepareForSleep, ActiveSessionLocked, ActiveSessionUnlocked, ActiveSessionChanged, SessionListChanged) auf einem internen Event-Bus aus.

### **H. Vertiefende Betrachtungen & Implikationen**

Die korrekte Handhabung von Inhibit-Locks im Kontext des PrepareForSleep-Signals ist für die Systemstabilität von entscheidender Bedeutung. Wenn die Desktop-Umgebung einen solchen Lock nimmt, um sich auf den Suspend-Vorgang vorzubereiten (z.B. durch Speichern von Zuständen, sicheres Beenden von Anwendungen, Dimmen des Bildschirms), muss dieser Lock unbedingt wieder freigegeben werden, sobald diese Vorbereitungen abgeschlossen sind oder ein definierter Timeout erreicht ist. Ein nicht freigegebener Inhibit-Lock kann den Suspend- oder Shutdown-Vorgang des gesamten Systems blockieren.13 Die Implementierung muss daher sicherstellen, dass der durch manager\_proxy.inhibit(...) erhaltene File Deskriptor zuverlässig geschlossen wird, auch im Fehlerfall oder bei einem unerwarteten Beenden der Desktop-Komponente. Dies erfordert eine robuste Fehlerbehandlung und möglicherweise den Einsatz von RAII-Mustern (Resource Acquisition Is Initialization), um sicherzustellen, dass der OwnedFd beim Verlassen des Gültigkeitsbereichs automatisch geschlossen wird.  
Die Unterscheidung zwischen dem *Anfordern* einer Sitzungssperre und dem tatsächlichen *gesperrten Zustand* der Sitzung ist ebenfalls wichtig. logind selbst sperrt den Bildschirm nicht direkt. Die Methode LockSession auf dem Manager-Objekt bewirkt, dass logind ein Lock-Signal an das entsprechende Session-Objekt sendet.13 Der Session-Manager, der typischerweise Teil der Desktop-Umgebung ist (oft in der UI-Schicht angesiedelt), lauscht auf dieses Lock-Signal auf seinem *eigenen* Session-D-Bus-Objekt. Nach Empfang dieses Signals ist der Session-Manager dafür verantwortlich, den Sperrbildschirm zu aktivieren. Sobald der Sperrbildschirm aktiv ist, sollte der Session-Manager logind darüber informieren, indem er die Eigenschaft LockedHint des Session-Objekts auf true setzt. Dieses Modul (system::dbus::logind\_interface) kann primär dafür zuständig sein, Sperr- und Entsperranforderungen über die Manager-Methoden zu initiieren und das PrepareForSleep-Signal zu überwachen. Die eigentliche UI des Sperrbildschirms und das Setzen von LockedHint wären Aufgaben der UI-Schicht, obwohl dieses Modul Änderungen der LockedHint-Eigenschaft der aktiven Sitzung überwachen könnte, um ein vollständiges Bild des Sitzungszustands zu erhalten.  
Die zuverlässige Identifizierung und Verfolgung der "aktiven" Sitzung ist eine weitere Herausforderung. Ein System kann mehrere Benutzersitzungen gleichzeitig haben (z.B. durch Fast User Switching oder Remote-Logins). Die Desktop-Umgebung läuft jedoch typischerweise innerhalb einer einzigen "aktiven" grafischen Sitzung. Viele logind-Operationen sind sitzungsspezifisch und erfordern eine Session-ID. Das logind\_interface-Modul muss daher zuverlässig die Session-ID ermitteln, die zur aktuell laufenden Desktop-Umgebung gehört. Dies kann durch Aufrufen von ListSessions und Überprüfen der Active-Eigenschaft jedes Session-Objekts geschehen.12 Alternativ, wenn die Desktop-Umgebung ihre eigene Session-ID kennt (z.B. aus Umgebungsvariablen, die von pam\_systemd gesetzt wurden), kann sie diese direkt verwenden. Das Modul muss auch Änderungen der aktiven Sitzung behandeln können, falls Funktionen wie Benutzerwechsel unterstützt werden sollen.

## **VI. Schlussfolgerung für Systemschicht (Teil 3/4)**

Die in diesem Teil spezifizierten Module – system::outputs::output\_manager, system::outputs::power\_manager, system::dbus::upower\_interface und system::dbus::logind\_interface – bilden wesentliche Komponenten der Systemschicht. Sie ermöglichen eine detaillierte Steuerung und Überwachung der Display-Hardware sowie die Integration mit grundlegenden Systemdiensten für Energieverwaltung und Sitzungsmanagement.  
Die dargelegten Ultra-Feinspezifikationen folgen dem Prinzip höchster Präzision und Detailgenauigkeit. Sie definieren exakte Schnittstellen, Datenstrukturen, Methoden-Signaturen, Fehlerbehandlungspfade und Interaktionsmuster. Ziel war es, einen direkten Implementierungsleitfaden für Entwickler bereitzustellen, der die Notwendigkeit eigener architektonischer oder logischer Entwurfsentscheidungen minimiert und eine konsistente und robuste Implementierung sicherstellt. Die sorgfältige Beachtung der Atomarität bei Konfigurationsänderungen, die Synchronisation von Zuständen mit externen Diensten und die robuste Fehlerbehandlung sind wiederkehrende Themen, die für die Stabilität der gesamten Desktop-Umgebung von entscheidender Bedeutung sind.  
Der nächste und letzte Teil der Systemschichtspezifikationen (Teil 4/4) wird sich mit weiteren kritischen Aspekten befassen, darunter die XWayland-Integration, die Implementierung von XDG Desktop Portals und die Audio-Management-Schnittstelle, um die Funktionalität der Systemschicht zu vervollständigen.

#### **Referenzen**

1. smithay::wayland::output \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/wayland/output/index.html](https://smithay.github.io/smithay/smithay/wayland/output/index.html)  
2. wlr output management protocol | Wayland Explorer, Zugriff am Mai 14, 2025, [https://wayland.app/protocols/wlr-output-management-unstable-v1](https://wayland.app/protocols/wlr-output-management-unstable-v1)  
3. smithay::backend::drm \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/backend/drm/index.html](https://smithay.github.io/smithay/smithay/backend/drm/index.html)  
4. Zugriff am Januar 1, 1970, [https://smithay.github.io/smithay/smithay/output/struct.Output.html](https://smithay.github.io/smithay/smithay/output/struct.Output.html)  
5. wlr output power management protocol | Wayland Explorer, Zugriff am Mai 14, 2025, [https://wayland.app/protocols/wlr-output-power-management-unstable-v1](https://wayland.app/protocols/wlr-output-power-management-unstable-v1)  
6. org.freedesktop.UPower: UPower Reference Manual, Zugriff am Mai 14, 2025, [https://upower.freedesktop.org/docs/UPower.html](https://upower.freedesktop.org/docs/UPower.html)  
7. D-BUS Protocol | Desktop Notifications Specification, Zugriff am Mai 14, 2025, [https://specifications.freedesktop.org/notification-spec/1.2/protocol.html](https://specifications.freedesktop.org/notification-spec/1.2/protocol.html)  
8. zbus \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/](https://docs.rs/zbus/latest/zbus/)  
9. Writing a client proxy \- zbus: D-Bus for Rust made easy \- GitHub Pages, Zugriff am Mai 14, 2025, [https://dbus2.github.io/zbus/client.html](https://dbus2.github.io/zbus/client.html)  
10. proxy in zbus \- Rust \- openrr.github.io, Zugriff am Mai 14, 2025, [https://openrr.github.io/openrr/zbus/attr.proxy.html](https://openrr.github.io/openrr/zbus/attr.proxy.html)  
11. Zugriff am Januar 1, 1970, [https://upower.freedesktop.org/docs/UPower.Device.html\#UPower.Device.PropertiesChanged](https://upower.freedesktop.org/docs/UPower.Device.html#UPower.Device.PropertiesChanged)  
12. org.freedesktop.login1 \- The D-Bus interface of systemd-logind \- Ubuntu Manpage, Zugriff am Mai 14, 2025, [https://manpages.ubuntu.com/manpages/plucky/man5/org.freedesktop.login1.5.html](https://manpages.ubuntu.com/manpages/plucky/man5/org.freedesktop.login1.5.html)  
13. org.freedesktop.login1, Zugriff am Mai 14, 2025, [https://www.freedesktop.org/software/systemd/man/org.freedesktop.login1.html](https://www.freedesktop.org/software/systemd/man/org.freedesktop.login1.html)  
14. org.freedesktop.login1, Zugriff am Mai 14, 2025, [https://www.freedesktop.org/software/systemd/man/org.freedesktop.login1.html\#Signals](https://www.freedesktop.org/software/systemd/man/org.freedesktop.login1.html#Signals)  
15. Zugriff am Januar 1, 1970, [https://www.freedesktop.org/software/systemd/man/org.freedesktop.login1.Manager.html\#Signals](https://www.freedesktop.org/software/systemd/man/org.freedesktop.login1.Manager.html#Signals)  
16. egui\_backend \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/egui\_backend](https://docs.rs/egui_backend)  
17. Error in zbus \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/enum.Error.html](https://docs.rs/zbus/latest/zbus/enum.Error.html)  
18. "Connection" Search \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/?search=Connection](https://docs.rs/zbus/latest/zbus/?search=Connection)  
19. Zbus create proxy builder without destination \- Stack Overflow, Zugriff am Mai 14, 2025, [https://stackoverflow.com/questions/78174269/zbus-create-proxy-builder-without-destination](https://stackoverflow.com/questions/78174269/zbus-create-proxy-builder-without-destination)  
20. zbus\_xmlgen \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/zbus\_xmlgen](https://crates.io/crates/zbus_xmlgen)  
21. zbus::fdo \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/fdo/index.html](https://docs.rs/zbus/latest/zbus/fdo/index.html)  
22. Introduction \- zbus: D-Bus for Rust made easy, Zugriff am Mai 14, 2025, [https://dbus2.github.io/zbus/](https://dbus2.github.io/zbus/)  
23. zbus \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/zbus/5.6.0](https://crates.io/crates/zbus/5.6.0)  
24. How to set interface dynamically using zbus \- The Rust Programming Language Forum, Zugriff am Mai 14, 2025, [https://users.rust-lang.org/t/how-to-set-interface-dynamically-using-zbus/108691](https://users.rust-lang.org/t/how-to-set-interface-dynamically-using-zbus/108691)  
25. Zugriff am Januar 1, 1970, [https://docs.rs/zbus/latest/zbus/attr.proxy.html](https://docs.rs/zbus/latest/zbus/attr.proxy.html)  
26. smithay/anvil/src/udev.rs at master \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/Smithay/smithay/blob/master/anvil/src/udev.rs](https://github.com/Smithay/smithay/blob/master/anvil/src/udev.rs)  
27. support wlr-output-management-unstable-v1? · YaLTeR niri · Discussion \#172 \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/YaLTeR/niri/discussions/172](https://github.com/YaLTeR/niri/discussions/172)  
28. File: wlr-output-power-management-unstable-v1.xml \- Debian Sources, Zugriff am Mai 14, 2025, [https://sources.debian.org/src/phosh/0.8.0-1/protocol/wlr-output-power-management-unstable-v1.xml/](https://sources.debian.org/src/phosh/0.8.0-1/protocol/wlr-output-power-management-unstable-v1.xml/)  
29. wayland-rs/historical\_changelog.md at master \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/Smithay/wayland-rs/blob/master/historical\_changelog.md](https://github.com/Smithay/wayland-rs/blob/master/historical_changelog.md)  
30. GUI — list of Rust libraries/crates // Lib.rs, Zugriff am Mai 14, 2025, [https://lib.rs/gui](https://lib.rs/gui)  
31. doc/dbus/org.freedesktop.UPower.ref.xml · debian/0.9.23-1 \- GitLab, Zugriff am Mai 14, 2025, [https://source.puri.sm/Librem5/upower/-/blob/debian/0.9.23-1/doc/dbus/org.freedesktop.UPower.ref.xml?ref\_type=tags](https://source.puri.sm/Librem5/upower/-/blob/debian/0.9.23-1/doc/dbus/org.freedesktop.UPower.ref.xml?ref_type=tags)  
32. D-Bus API Reference: UPower Reference Manual, Zugriff am Mai 14, 2025, [https://upower.freedesktop.org/docs/ref-dbus.html](https://upower.freedesktop.org/docs/ref-dbus.html)  
33. Zugriff am Januar 1, 1970, [https://upower.freedesktop.org/docs/UPower.Device.html\#UPower.Device.DeviceAdded](https://upower.freedesktop.org/docs/UPower.Device.html#UPower.Device.DeviceAdded)  
34. Zugriff am Januar 1, 1970, [https://upower.freedesktop.org/docs/UPower.Device.html\#UPower.Device.DeviceRemoved](https://upower.freedesktop.org/docs/UPower.Device.html#UPower.Device.DeviceRemoved)
# **Technische Gesamtspezifikation und Entwicklungsrichtlinien: Systemschicht Teil 4/4**

Dieses Dokument ist die Fortsetzung der detaillierten Spezifikation der Systemschicht und behandelt die Module system::audio, system::mcp und system::portals.

## **5\. system::audio \- PipeWire Client-Integration**

Das Modul system::audio ist die maßgebliche Komponente für alle audiobezogenen Operationen innerhalb der Desktop-Umgebung. Es nutzt das PipeWire Multimedia-Framework, um Audiogeräte (Sinks und Quellen), Lautstärke- und Stummschaltungszustände sowohl für Geräte als auch für Anwendungsströme zu verwalten und auf audiobezogene Systemereignisse zu reagieren. Dieses Modul agiert als PipeWire-Client und abstrahiert die Komplexität der PipeWire C-API durch die pipewire-rs Rust-Bindings.  
Die zentrale Designphilosophie dieses Moduls ist die Zentralisierung der gesamten PipeWire-Interaktionslogik, um eine saubere, übergeordnete API für andere Teile der Desktop-Umgebung bereitzustellen. Es basiert auf einer ereignisgesteuerten Architektur, die asynchron auf PipeWire-Ereignisse (Geräteänderungen, Stream-Status, Lautstärkeaktualisierungen) lauscht und diese in interne Systemereignisse übersetzt, die von der UI- und Domänenschicht konsumiert werden können. Eine robuste Fehlerbehandlung wird durch die Verwendung von thiserror für spezifische AudioError-Typen gewährleistet, die klar zwischen PipeWire-spezifischen Problemen und internen Logikfehlern unterscheiden.  
Die Architektur von PipeWire 1 dreht sich um eine MainLoop, einen Context, einen Core und eine Registry. Client-Anwendungen entdecken und interagieren mit entfernten Objekten (Nodes, Devices, Streams) über Proxys, die von der Registry bezogen werden. Die Ereignisbehandlung ist callback-basiert. Die Desktop-Umgebung muss sich dynamisch an Änderungen in der Audiolandschaft anpassen, beispielsweise beim Anschließen eines USB-Headsets oder wenn eine Anwendung die Audiowiedergabe startet oder stoppt. Dies erfordert eine kontinuierliche Überwachung des PipeWire-Status. Das Registry-Objekt sendet global- und global\_remove-Ereignisse für Objekte, die erscheinen oder verschwinden.4 Einzelne Objekte (Proxys für Nodes, Devices) senden Ereignisse für Eigenschaftsänderungen, z.B. param\_changed für Lautstärke/Stummschaltung eines Nodes.15 Die pipewire-rs Bibliothek stellt idiomatische Rust-Wrapper für diese Konzepte bereit.1 Beispiele wie 9 demonstrieren die Initialisierung der Main Loop, des Context, des Core, der Registry und das Hinzufügen von Listenern. Daraus folgt, dass system::audio seine eigene PipeWire MainLoop verwalten muss. Diese Schleife wird wahrscheinlich in einem dedizierten Thread ausgeführt, um ein Blockieren der Hauptereignisschleife der Desktop-Umgebung (z.B. Calloop) zu vermeiden. Asynchrone Kommunikationskanäle (wie tokio::sync::mpsc und tokio::sync::broadcast) werden verwendet, um Befehle und Ereignisse zwischen dem PipeWire-Thread und dem Rest des Systems zu überbrücken. Dies steht im Einklang mit den Multithreading-Richtlinien von pipewire-rs.1  
Die Lautstärkeregelung in PipeWire kann nuanciert sein und entweder Props auf einem Node (oft für Software-/Stream-Lautstärken) oder Route-Parameter auf einem Device (für Hardware-/Master-Lautstärken) betreffen. Benutzer erwarten, sowohl die Master-Ausgabelautstärke als auch die Lautstärke pro Anwendung steuern zu können. Kommandozeilenwerkzeuge wie pw-cli und wpctl demonstrieren das Setzen von channelVolumes über Props auf einem Node 26 oder über Route-Parameter auf einem Device.26 Die Parameter SPA\_PARAM\_Props und SPA\_PARAM\_Route sind zentrale PipeWire-Parameter (SPA \- Simple Plugin API). Die Methode Node::set\_param von pipewire-rs wird verwendet, was die Konstruktion von SpaPod-Objekten für diese Parameter erfordert.15 Das Modul system::audio muss daher zwischen der Steuerung der Master-Lautstärke des Geräts und der Lautstärke des Anwendungsstroms unterscheiden und die entsprechenden PipeWire-Objekte und \-Parameter verwenden. Lautstärkewerte erfordern oft eine kubische Skalierung für eine lineare Benutzerwahrnehmung.  
**Modulstruktur und Dateien:**

* system/audio/mod.rs: Öffentliche API des Audio-Moduls, Definition der AudioError Enum.  
* system/audio/client.rs: Kernstruktur PipeWireClient, verwaltet PipeWire-Verbindung, Hauptschleife, Ereignis-/Befehlskanäle.  
* system/audio/manager.rs: Handhabt die Erkennung, Verfolgung und Eigenschaftsaktualisierungen von AudioDevice- und StreamInfo-Objekten über Registry- und Proxy-Ereignisse.  
* system/audio/control.rs: Implementiert Logik für Lautstärke-/Stummschaltungsbefehle, Konstruktion von SpaPods und Aufruf von set\_param.  
* system/audio/types.rs: Definiert AudioDevice, StreamInfo, AudioEvent, AudioCommand, AudioDeviceType, Volume, etc.  
* system/audio/spa\_pod\_utils.rs: Hilfsfunktionen zur Konstruktion komplexer SpaPod-Objekte für Lautstärke, Stummschaltung und potenziell andere Parameter.  
* system/audio/error.rs: Fehlerbehandlung für das Audio-Modul.

### **5.3.1. Submodul: system::audio::client \- PipeWire Verbindungs- und Ereignisschleifenmanagement**

* **Datei:** system/audio/client.rs  
* **Zweck:** Dieses Submodul ist verantwortlich für die Verwaltung der Low-Level-Verbindung zu PipeWire. Es startet und unterhält die PipeWire-Haupt-Ereignisschleife in einem dedizierten Thread und dient als Brücke für die Weiterleitung von Befehlen an das PipeWire-System und die Verteilung von PipeWire-Ereignissen an andere Teile des Audio-Moduls.

#### **5.3.1.1. Strukuren**

* pub struct PipeWireClient:  
  * core: std::sync::Arc\<pipewire::Core\>: Ein Proxy zum PipeWire-Core, der die Hauptverbindung zum PipeWire-Daemon darstellt. Wird als Arc gehalten, um sicher zwischen Threads geteilt zu werden.  
  * mainloop\_thread\_handle: Option\<std::thread::JoinHandle\<()\>\>: Ein Handle für den dedizierten OS-Thread, in dem die PipeWire-Hauptereignisschleife läuft. Wird beim Beenden des Clients zum sauberen Herunterfahren des Threads verwendet.  
  * command\_sender: tokio::sync::mpsc::Sender\<AudioCommand\>: Ein asynchroner Sender zum Übermitteln von AudioCommands von anderen Teilen des Systems (z.B. UI-Interaktionen) an den PipeWire-Loop-Thread.  
  * internal\_event\_sender: tokio::sync::mpsc::Sender\<InternalAudioEvent\>: Ein interner Sender, der von Worker-Tasks innerhalb dieses Moduls (z.B. Registry-Listener) verwendet wird, um rohe PipeWire-Ereignisse an den Hauptverarbeitungslogik-Task im PipeWire-Thread zu senden.  
  * Initialwerte: core und registry werden während der Initialisierung gesetzt. mainloop\_thread\_handle ist anfangs None und wird nach dem Starten des Threads gesetzt. Die Sender werden beim Erstellen der Kanäle initialisiert.  
  * Invarianten: core und registry müssen immer gültig sein, solange der mainloop\_thread\_handle Some ist.  
* struct PipeWireLoopData: Diese Struktur kapselt alle Daten, die innerhalb des dedizierten PipeWire-Loop-Threads benötigt werden.  
  * core: std::sync::Arc\<pipewire::Core\>: Geteilter Zugriff auf den PipeWire Core.  
  * registry: std::sync::Arc\<pipewire::Registry\>: Geteilter Zugriff auf die PipeWire Registry.  
  * audio\_event\_broadcaster: tokio::sync::broadcast::Sender\<AudioEvent\>: Ein Sender zum Verteilen von aufbereiteten AudioEvents an alle interessierten Listener im System (z.B. UI-Komponenten).  
  * command\_receiver: tokio::sync::mpsc::Receiver\<AudioCommand\>: Empfängt Befehle, die an das Audio-System gesendet werden.  
  * internal\_event\_receiver: tokio::sync::mpsc::Receiver\<InternalAudioEvent\>: Empfängt interne Ereignisse von PipeWire-Callbacks.  
  * active\_devices: std::collections::HashMap\<u32, MonitoredDevice\>: Eine Map zur Verfolgung der aktuell aktiven Audiogeräte (Nodes oder Devices), ihrer Proxys, Eigenschaften und Listener-Hooks. Der Key ist die PipeWire Global ID.  
  * active\_streams: std::collections::HashMap\<u32, MonitoredStream\>: Eine Map zur Verfolgung aktiver Audio-Streams (Nodes mit Anwendungsbezug). Der Key ist die PipeWire Global ID.  
  * default\_sink\_id: Option\<u32\>: Die ID des aktuellen Standard-Audioausgabegeräts.  
  * default\_source\_id: Option\<u32\>: Die ID des aktuellen Standard-Audioeingabegeräts.  
  * pipewire\_mainloop: pipewire::MainLoop: Die PipeWire-Hauptereignisschleife.  
  * pipewire\_context: pipewire::Context: Der PipeWire-Kontext.  
  * metadata\_proxy: Option\<std::sync::Arc\<pipewire::metadata::Metadata\>\>: Proxy zum PipeWire Metadaten-Objekt, um Standardgeräte zu setzen/lesen.  
  * metadata\_listener\_hook: Option\<pipewire::spa::SpaHook\>: Listener für Änderungen am Metadaten-Objekt.  
* struct MonitoredDevice: Repräsentiert ein überwachtes Audiogerät.  
  * proxy: std::sync::Arc\<dyn pipewire::proxy::ProxyT \+ Send \+ Sync\>: Ein generischer Proxy, der entweder ein pw::node::Node oder pw::device::Device sein kann, abhängig davon, wie die Lautstärke/Stummschaltung gesteuert wird (Props vs. Route).  
  * proxy\_id: u32: Die ID des Proxy-Objekts.  
  * global\_id: u32: Die globale ID des PipeWire-Objekts.  
  * properties: pipewire::spa::SpaDict: Die zuletzt bekannten Eigenschaften des Geräts.  
  * param\_listener\_hook: Option\<pipewire::spa::SpaHook\>: Hook für den param\_changed Listener des Node/Device-Proxys.  
  * info: AudioDevice: Die zwischengespeicherte, aufbereitete AudioDevice-Struktur für die externe API.  
* struct MonitoredStream: Repräsentiert einen überwachten Audio-Stream.  
  * proxy: std::sync::Arc\<pipewire::node::Node\>: Proxy zum Stream-Node.  
  * proxy\_id: u32: Die ID des Proxy-Objekts.  
  * global\_id: u32: Die globale ID des PipeWire-Objekts.  
  * properties: pipewire::spa::SpaDict: Die zuletzt bekannten Eigenschaften des Streams.  
  * param\_listener\_hook: Option\<pipewire::spa::SpaHook\>: Hook für den param\_changed Listener des Node-Proxys.  
  * info: StreamInfo: Die zwischengespeicherte, aufbereitete StreamInfo-Struktur.  
* enum InternalAudioEvent: Interne Ereignisse zur Kommunikation innerhalb des Audio-Moduls.  
  * PwGlobalAdded(pipewire::registry::GlobalObject\<pipewire::spa::SpaDict\>)  
  * PwGlobalRemoved(u32)  
  * PwNodeParamChanged { node\_id: u32, param\_id: u32, pod: Option\<pipewire::spa::Pod\> }  
  * PwDeviceParamChanged { device\_id: u32, param\_id: u32, pod: Option\<pipewire::spa::Pod\> }  
  * PwMetadataPropsChanged { metadata\_id: u32, props: pipewire::spa::SpaDict }

#### **5.3.1.2. Methoden für PipeWireClient**

* pub async fn new(audio\_event\_broadcaster: tokio::sync::broadcast::Sender\<AudioEvent\>) \-\> Result\<Self, AudioError\>:  
  * **Vorbedingungen:** Keine.  
  * **Schritte:**  
    1. pipewire::init() aufrufen, um die PipeWire-Bibliothek zu initialisieren.4 Falls dies fehlschlägt, AudioError::PipeWireInitFailed zurückgeben.  
    2. Zwei tokio::sync::mpsc::channel erstellen:  
       * command\_channel für AudioCommand (Kapazität z.B. 32).  
       * internal\_event\_channel für InternalAudioEvent (Kapazität z.B. 64).  
    3. Die Sender (command\_sender, internal\_event\_sender) und Empfänger (command\_receiver, internal\_event\_receiver) aus den Kanälen extrahieren.  
    4. Einen tokio::sync::oneshot::channel erstellen (init\_signal\_tx, init\_signal\_rx) zur Signalisierung der erfolgreichen Initialisierung des PipeWire-Threads.  
    5. Einen neuen OS-Thread mit std::thread::spawn starten. Dieser Thread führt die Funktion run\_pipewire\_loop aus. Der audio\_event\_broadcaster, command\_receiver, internal\_event\_receiver, internal\_event\_sender\_clone (für Callbacks) und init\_signal\_tx werden in den Thread verschoben.  
       * **Thread-Logik (run\_pipewire\_loop Funktion):**  
         1. let mainloop \= MainLoop::new(None).map\_err(AudioError::MainLoopCreationFailed)?;.4  
         2. let context \= Context::new(\&mainloop).map\_err(AudioError::ContextCreationFailed)?;.4  
         3. let core \= Arc::new(context.connect(None).map\_err(AudioError::CoreConnectionFailed)?);.4  
         4. let registry \= Arc::new(core.get\_registry().map\_err(AudioError::RegistryCreationFailed)?);.4  
         5. Die erfolgreiche Initialisierung von core und registry über init\_signal\_tx.send(Ok((core.clone(), registry.clone()))) signalisieren.  
         6. Eine PipeWireLoopData-Instanz erstellen, die core, registry, den übergebenen audio\_event\_broadcaster, command\_receiver und internal\_event\_receiver enthält.  
         7. Einen Listener auf der registry mit add\_listener\_local() registrieren.4  
            * Im global-Callback: Ein InternalAudioEvent::PwGlobalAdded(global\_object) an den internal\_event\_sender\_clone senden. global\_object ist hier das Argument des Callbacks.  
            * Im global\_remove-Callback: Ein InternalAudioEvent::PwGlobalRemoved(id) an den internal\_event\_sender\_clone senden. id ist das Argument des Callbacks.  
         8. Eine Timer-Quelle zur mainloop hinzufügen (mainloop.loop\_().add\_timer(...)), die periodisch (z.B. alle 10ms) eine Funktion aufruft. Diese Funktion (process\_external\_messages) versucht, Nachrichten von command\_receiver und internal\_event\_receiver mit try\_recv() zu empfangen und verarbeitet diese.  
            * Die Integration von Tokio MPSC-Kanälen mit der blockierenden mainloop.run() erfordert einen Mechanismus, um die Schleife periodisch zu unterbrechen oder die MPSC-Empfänger nicht-blockierend abzufragen. Ein Timer ist ein gängiger Ansatz hierfür.1  
         9. mainloop.run() aufrufen. Diese Funktion blockiert den Thread und verarbeitet PipeWire-Ereignisse und Timer-Callbacks.  
    6. Auf das Ergebnis von init\_signal\_rx.await warten. Bei Erfolg die core und registry Arcs aus dem Ergebnis entnehmen. Bei Fehler AudioError::PipeWireThreadPanicked oder den empfangenen Fehler zurückgeben.  
    7. Den mainloop\_thread\_handle, die erhaltenen core und registry Arcs und den command\_sender in der PipeWireClient-Instanz speichern.  
    8. Ok(Self) zurückgeben.  
  * **Nachbedingungen:** Ein PipeWireClient ist initialisiert und der PipeWire-Loop-Thread läuft.  
  * **Fehlerfälle:** AudioError::PipeWireInitFailed, AudioError::MainLoopCreationFailed, AudioError::ContextCreationFailed, AudioError::CoreConnectionFailed, AudioError::RegistryCreationFailed, AudioError::PipeWireThreadPanicked.  
* pub fn get\_command\_sender(\&self) \-\> tokio::sync::mpsc::Sender\<AudioCommand\>:  
  * **Vorbedingungen:** Der PipeWireClient wurde erfolgreich initialisiert.  
  * **Schritte:** Gibt ein Klon des command\_sender zurück.  
  * **Nachbedingungen:** Keine Zustandsänderung.  
  * **Fehlerfälle:** Keine.

#### **5.3.1.3. Private statische Funktion run\_pipewire\_loop**

* fn run\_pipewire\_loop(audio\_event\_broadcaster: tokio::sync::broadcast::Sender\<AudioEvent\>, mut command\_receiver: tokio::sync::mpsc::Receiver\<AudioCommand\>, mut internal\_event\_receiver: tokio::sync::mpsc::Receiver\<InternalAudioEvent\>, internal\_event\_sender\_clone: tokio::sync::mpsc::Sender\<InternalAudioEvent\>, init\_signal\_tx: tokio::sync::oneshot::Sender\<Result\<(std::sync::Arc\<pipewire::Core\>, std::sync::Arc\<pipewire::Registry\>), AudioError\>\>):  
  * **Logik:** Wie oben unter PipeWireClient::new beschrieben (Schritt 5.1 bis 5.9).  
  * Die Funktion process\_external\_messages(loop\_data: \&mut PipeWireLoopData) wird vom Timer aufgerufen:  
    * **Befehlsverarbeitung (von loop\_data.command\_receiver.try\_recv()):**  
      * AudioCommand::SetDeviceVolume { device\_id, volume, curve }: Ruft system::audio::control::set\_device\_volume(\&loop\_data, device\_id, volume, curve) auf.  
      * AudioCommand::SetDeviceMute { device\_id, mute }: Ruft system::audio::control::set\_device\_mute(\&loop\_data, device\_id, mute) auf.  
      * AudioCommand::SetStreamVolume { stream\_id, volume, curve }: Ruft system::audio::control::set\_node\_volume(\&loop\_data, stream\_id, volume, curve) auf (da Streams als Nodes repräsentiert werden).  
      * AudioCommand::SetStreamMute { stream\_id, mute }: Ruft system::audio::control::set\_node\_mute(\&loop\_data, stream\_id, mute) auf.  
      * AudioCommand::SetDefaultDevice { device\_type, device\_id }: Ruft system::audio::control::set\_default\_device(\&loop\_data, device\_type, device\_id) auf.  
      * AudioCommand::RequestDeviceList: Sendet den aktuellen Stand von loop\_data.active\_devices über den audio\_event\_broadcaster als AudioEvent::DeviceListUpdated.  
      * AudioCommand::RequestStreamList: Sendet den aktuellen Stand von loop\_data.active\_streams über den audio\_event\_broadcaster als AudioEvent::StreamListUpdated.  
    * **Interne Ereignisverarbeitung (von loop\_data.internal\_event\_receiver.try\_recv()):**  
      * InternalAudioEvent::PwGlobalAdded(global): Ruft system::audio::manager::handle\_pipewire\_global\_added(\&mut loop\_data, global, \&internal\_event\_sender\_clone).  
      * InternalAudioEvent::PwGlobalRemoved(id): Ruft system::audio::manager::handle\_pipewire\_global\_removed(\&mut loop\_data, id).  
      * InternalAudioEvent::PwNodeParamChanged { node\_id, param\_id, pod }: Ruft system::audio::manager::handle\_node\_param\_changed(\&mut loop\_data, node\_id, param\_id, pod).  
      * InternalAudioEvent::PwDeviceParamChanged { device\_id, param\_id, pod }: Ruft system::audio::manager::handle\_device\_param\_changed(\&mut loop\_data, device\_id, param\_id, pod).  
      * InternalAudioEvent::PwMetadataPropsChanged { metadata\_id, props}: Ruft system::audio::manager::handle\_metadata\_props\_changed(\&mut loop\_data, metadata\_id, props).

### **5.3.2. Submodul: system::audio::manager \- Geräte- und Stream-Zustandsmanagement**

* **Datei:** system/audio/manager.rs  
* **Zweck:** Dieses Submodul enthält die Logik zur Verarbeitung von PipeWire-Registry-Ereignissen, zur Verwaltung der AudioDevice- und StreamInfo-Strukturen und zur Handhabung von Eigenschafts-/Parameteränderungen dieser Objekte. Es interagiert eng mit dem PipeWireClient, um auf Low-Level-Ereignisse zu reagieren und den Zustand der Audio-Entitäten im System zu aktualisieren.

#### **5.3.2.1. Funktionen (aufgerufen von PipeWireClient's Loop)**

* pub(super) fn handle\_pipewire\_global\_added(loop\_data: \&mut PipeWireLoopData, global: pipewire::registry::GlobalObject\<pipewire::spa::SpaDict\>, internal\_event\_sender: \&tokio::sync::mpsc::Sender\<InternalAudioEvent\>) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** loop\_data ist initialisiert. global ist ein neu entdecktes PipeWire-Global-Objekt.  
  * **Schritte:**  
    1. Loggt das neue globale Objekt: tracing::info\!("PipeWire Global Added: id={}, type={:?}, version={}, props={:?}", global.id, global.type\_, global.version, global.props.as\_ref().map\_or\_else(|| "None", |p| format\!("{:?}", p)));  
    2. Abhängig von global.type\_:  
       * ObjectType::Node:  
         1. Eigenschaften aus global.props extrahieren (falls vorhanden): media.class, node.name, node.description, application.process.id, application.name, audio.format, audio.channels, object.serial.  
         2. Bestimmen, ob es sich um ein Gerät (Sink/Source) oder einen Anwendungsstream handelt:  
            * **Gerät (Sink/Source Node):** Typischerweise media.class ist "Audio/Sink" oder "Audio/Source" und application.name ist nicht gesetzt oder verweist auf einen Systemdienst.  
              * Proxy binden: let node\_proxy \= Arc::new(loop\_data.registry.bind::\<pipewire::node::Node\>(\&global.into\_proxy\_properties(None)?)?);.8 Die into\_proxy\_properties Methode wird hier verwendet, um die bereits vorhandenen Properties direkt zu nutzen.  
              * Die global.id ist die ID des globalen Objekts, node\_proxy.id() ist die ID des gebundenen Proxys.  
              * Anfängliche Parameter abrufen (insbesondere SPA\_PARAM\_Props für Lautstärke/Mute): node\_proxy.enum\_params\_sync(pipewire::spa::param::ParamType::Props.as\_raw(), None, None, None) aufrufen. Den ersten zurückgegebenen SpaPod parsen, um channelVolumes und mute zu extrahieren (siehe spa\_pod\_utils).  
              * Eine AudioDevice-Instanz erstellen und mit den extrahierten und abgerufenen Informationen füllen. is\_default wird gesetzt, wenn global.id mit loop\_data.default\_sink\_id oder loop\_data.default\_source\_id übereinstimmt.  
              * Einen param\_changed-Listener auf dem node\_proxy registrieren:  
                Rust  
                let internal\_sender\_clone \= internal\_event\_sender.clone();  
                let proxy\_id \= node\_proxy.id(); // ID des gebundenen Proxys  
                let listener\_hook \= node\_proxy.add\_listener\_local()  
                   .param(move |\_id, \_seq, param\_id, \_index, \_next, pod| {  
                        let \_ \= internal\_sender\_clone.try\_send(InternalAudioEvent::PwNodeParamChanged {  
                            node\_id: proxy\_id, // Wichtig: ID des Proxys, nicht die globale ID  
                            param\_id,  
                            pod: pod.cloned(), // Klonen, da Pod nur als Referenz übergeben wird  
                        });  
                    })  
                   .register();

              * MonitoredDevice erstellen und in loop\_data.active\_devices mit global.id als Schlüssel einfügen. Die listener\_hook muss in MonitoredDevice gespeichert werden, um sie später entfernen zu können.  
              * AudioEvent::DeviceAdded(new\_device\_info) über loop\_data.audio\_event\_broadcaster senden.  
            * **Anwendungsstream:** Typischerweise ist application.name gesetzt.  
              * Proxy binden: let node\_proxy \= Arc::new(loop\_data.registry.bind::\<pipewire::node::Node\>(\&global.into\_proxy\_properties(None)?)?);  
              * Anfängliche Parameter (Lautstärke/Mute) wie bei Geräten abrufen.  
              * StreamInfo-Instanz erstellen.  
              * param\_changed-Listener auf node\_proxy registrieren (analog zu Geräten, sendet InternalAudioEvent::PwNodeParamChanged).  
              * MonitoredStream erstellen und in loop\_data.active\_streams mit global.id als Schlüssel einfügen.  
              * AudioEvent::StreamAdded(new\_stream\_info) über loop\_data.audio\_event\_broadcaster senden.  
       * ObjectType::Device:  
         1. Eigenschaften extrahieren: device.api, device.nick, device.description, media.class.  
         2. Wenn media.class "Audio/Sink" oder "Audio/Source" ist und dies ein "echtes" Hardware-Gerät darstellt (oft über device.api wie "alsa" identifizierbar), könnte dies für Master-Lautstärkeregelung über SPA\_PARAM\_Route relevant sein.  
            * Proxy binden: let device\_proxy \= Arc::new(loop\_data.registry.bind::\<pipewire::device::Device\>(\&global.into\_proxy\_properties(None)?)?);  
            * Anfängliche SPA\_PARAM\_Route-Parameter abrufen: device\_proxy.enum\_params\_sync(pipewire::spa::param::ParamType::Route.as\_raw(), None, None, None). Parsen, um aktive Route und deren Lautstärke/Mute zu finden.  
            * Eine AudioDevice-Instanz erstellen.  
            * Einen param\_changed-Listener auf dem device\_proxy registrieren, der InternalAudioEvent::PwDeviceParamChanged sendet.  
            * MonitoredDevice erstellen und in loop\_data.active\_devices einfügen.  
            * AudioEvent::DeviceAdded senden.  
       * ObjectType::Metadata:  
         1. Eigenschaften extrahieren: metadata.name.  
         2. Wenn metadata.name \== "default" ist:  
            * Proxy binden: let metadata\_proxy \= Arc::new(loop\_data.registry.bind::\<pipewire::metadata::Metadata\>(\&global.into\_proxy\_properties(None)?)?);  
            * loop\_data.metadata\_proxy \= Some(metadata\_proxy.clone());  
            * Die props-Eigenschaft des Metadatenobjekts enthält die Standardgeräte-IDs (z.B. default.audio.sink, default.audio.source).10 Diese parsen und loop\_data.default\_sink\_id/default\_source\_id aktualisieren.  
            * Einen props-Listener auf dem metadata\_proxy registrieren:  
              Rust  
              let internal\_sender\_clone \= internal\_event\_sender.clone();  
              let proxy\_id \= metadata\_proxy.id();  
              let listener\_hook \= metadata\_proxy.add\_listener\_local()  
                 .props(move |\_id, props| {  
                      let \_ \= internal\_sender\_clone.try\_send(InternalAudioEvent::PwMetadataPropsChanged {  
                          metadata\_id: proxy\_id,  
                          props: props.cloned(),  
                      });  
                  })  
                 .register();  
              loop\_data.metadata\_listener\_hook \= Some(listener\_hook);

            * AudioEvent::DefaultSinkChanged / DefaultSourceChanged senden, falls sich die IDs geändert haben.  
  * **Nachbedingungen:** Relevante Proxys sind gebunden, Listener registriert, und der Zustand in loop\_data ist aktualisiert. Entsprechende AudioEvents wurden gesendet.  
  * **Fehlerfälle:** AudioError::ProxyBindFailed, AudioError::ParameterEnumerationFailed.  
* pub(super) fn handle\_pipewire\_global\_removed(loop\_data: \&mut PipeWireLoopData, id: u32) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** id ist die globale ID eines entfernten PipeWire-Objekts.  
  * **Schritte:**  
    1. Loggt die Entfernung: tracing::info\!("PipeWire Global Removed: id={}", id);  
    2. Wenn id in loop\_data.active\_devices vorhanden ist:  
       * MonitoredDevice entfernen. Der param\_listener\_hook wird automatisch durch das Droppen des SpaHook-Objekts (oder durch explizites remove() auf dem Listener) entfernt, wenn der Proxy gedroppt wird. Der Proxy selbst wird gedroppt, wenn der Arc keine Referenzen mehr hat.  
       * AudioEvent::DeviceRemoved(id) über loop\_data.audio\_event\_broadcaster senden.  
    3. Wenn id in loop\_data.active\_streams vorhanden ist:  
       * MonitoredStream entfernen. Listener-Hook wird ebenfalls entfernt.  
       * AudioEvent::StreamRemoved(id) über loop\_data.audio\_event\_broadcaster senden.  
    4. Wenn die ID des loop\_data.metadata\_proxy (falls vorhanden) mit id übereinstimmt:  
       * loop\_data.metadata\_proxy \= None;  
       * loop\_data.metadata\_listener\_hook \= None; (wird gedroppt)  
  * **Nachbedingungen:** Das Objekt ist aus dem internen Zustand entfernt, Listener sind deregistriert. AudioEvent wurde gesendet.  
  * **Fehlerfälle:** Keine spezifischen Fehler erwartet, außer Logging-Fehler.  
* pub(super) fn handle\_node\_param\_changed(loop\_data: \&mut PipeWireLoopData, node\_id: u32, param\_id: u32, pod: Option\<pipewire::spa::Pod\>) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** node\_id ist die Proxy-ID eines Nodes. param\_id gibt den Typ des geänderten Parameters an. pod enthält die neuen Parameterdaten.  
  * **Schritte:**  
    1. Loggt die Parameteränderung: tracing::debug\!("Node Param Changed: node\_id={}, param\_id={}, pod\_is\_some={}", node\_id, param\_id, pod.is\_some());  
    2. Suchen des MonitoredDevice oder MonitoredStream in loop\_data.active\_devices oder loop\_data.active\_streams, dessen proxy.id() mit node\_id übereinstimmt.  
    3. Wenn gefunden und param\_id \== pipewire::spa::param::ParamType::Props.as\_raw():  
       * Wenn pod Some ist, die neuen Lautstärke- (channelVolumes) und Mute- (mute) Werte aus dem SpaPod parsen (siehe spa\_pod\_utils).  
       * Die info (entweder AudioDevice oder StreamInfo) im MonitoredDevice/MonitoredStream aktualisieren.  
       * Das entsprechende AudioEvent (DeviceVolumeChanged, DeviceMuteChanged, StreamVolumeChanged, StreamMuteChanged) über loop\_data.audio\_event\_broadcaster senden.  
  * **Nachbedingungen:** Der interne Zustand des Geräts/Streams ist aktualisiert und ein AudioEvent wurde gesendet.  
  * **Fehlerfälle:** AudioError::SpaPodParseFailed.  
* pub(super) fn handle\_device\_param\_changed(loop\_data: \&mut PipeWireLoopData, device\_id: u32, param\_id: u32, pod: Option\<pipewire::spa::Pod\>) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** device\_id ist die Proxy-ID eines Devices.  
  * **Schritte:**  
    1. Loggt die Parameteränderung.  
    2. Suchen des MonitoredDevice in loop\_data.active\_devices, dessen proxy.id() mit device\_id übereinstimmt.  
    3. Wenn gefunden und param\_id \== pipewire::spa::param::ParamType::Route.as\_raw():  
       * Wenn pod Some ist, die neuen Routenparameter parsen, um Lautstärke/Mute der aktiven Route zu extrahieren.  
       * Die info (AudioDevice) im MonitoredDevice aktualisieren.  
       * AudioEvent::DeviceVolumeChanged / DeviceMuteChanged senden.  
  * **Nachbedingungen:** Der interne Zustand des Geräts ist aktualisiert.  
  * **Fehlerfälle:** AudioError::SpaPodParseFailed.  
* pub(super) fn handle\_metadata\_props\_changed(loop\_data: \&mut PipeWireLoopData, metadata\_id: u32, props: pipewire::spa::SpaDict) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** metadata\_id ist die Proxy-ID des Metadaten-Objekts. props sind die geänderten Eigenschaften.  
  * **Schritte:**  
    1. Loggt die Änderung.  
    2. Überprüfen, ob loop\_data.metadata\_proxy existiert und seine ID mit metadata\_id übereinstimmt.  
    3. Die neuen Standard-Sink/Source-IDs aus props extrahieren (z.B. props.get("default.audio.sink").and\_then(|s| s.parse().ok())).  
    4. Wenn sich loop\_data.default\_sink\_id geändert hat:  
       * Altes Standardgerät (falls vorhanden) in active\_devices suchen und is\_default \= false setzen. AudioEvent::DeviceUpdated senden.  
       * Neues Standardgerät in active\_devices suchen und is\_default \= true setzen. AudioEvent::DeviceUpdated senden.  
       * loop\_data.default\_sink\_id aktualisieren.  
       * AudioEvent::DefaultSinkChanged(new\_id) senden.  
    5. Analog für default\_source\_id.  
  * **Nachbedingungen:** Standardgeräte-IDs und is\_default-Flags sind aktualisiert. AudioEvents wurden gesendet.  
  * **Fehlerfälle:** Keine spezifischen Fehler erwartet.

### **5.3.3. Submodul: system::audio::control \- Lautstärke-, Stummschaltungs- und Gerätesteuerung**

* **Datei:** system/audio/control.rs  
* **Zweck:** Implementiert die Logik zum Senden von Steuerbefehlen an PipeWire-Objekte, insbesondere zum Setzen von Lautstärke und Stummschaltung sowie zur Auswahl von Standardgeräten.

#### **5.3.3.1. Funktionen (aufgerufen von PipeWireClient's Loop bei AudioCommand Verarbeitung)**

* pub(super) fn set\_node\_volume(loop\_data: \&PipeWireLoopData, node\_id: u32, volume: Volume, curve: VolumeCurve) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** node\_id ist eine gültige Proxy-ID eines MonitoredDevice (als Node) oder MonitoredStream in loop\_data.  
  * **Schritte:**  
    1. Sucht den MonitoredDevice oder MonitoredStream anhand der node\_id (Proxy-ID).  
    2. Wenn nicht gefunden, AudioError::DeviceOrStreamNotFound(node\_id) zurückgeben.  
    3. Den pipewire::node::Node-Proxy extrahieren.  
    4. Die volume.channel\_volumes (Array von f32) entsprechend der VolumeCurve (z.B. Linear, Cubic) anpassen. Für Cubic wäre das vadj​=v3.  
    5. Einen SpaPod für SPA\_PARAM\_Props erstellen, der channelVolumes enthält (siehe spa\_pod\_utils::build\_volume\_props\_pod).  
    6. node\_proxy.set\_param(pipewire::spa::param::ParamType::Props.as\_raw(), 0, \&pod) aufrufen.27  
    7. Bei Fehler AudioError::PipeWireCommandFailed zurückgeben.  
  * **Nachbedingungen:** Der Lautstärkebefehl wurde an den PipeWire-Node gesendet.  
  * **Fehlerfälle:** AudioError::DeviceOrStreamNotFound, AudioError::SpaPodBuildFailed, AudioError::PipeWireCommandFailed.  
* pub(super) fn set\_node\_mute(loop\_data: \&PipeWireLoopData, node\_id: u32, mute: bool) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** node\_id ist eine gültige Proxy-ID.  
  * **Schritte:**  
    1. Sucht den MonitoredDevice oder MonitoredStream.  
    2. Den pipewire::node::Node-Proxy extrahieren.  
    3. Einen SpaPod für SPA\_PARAM\_Props erstellen, der mute enthält (siehe spa\_pod\_utils::build\_mute\_props\_pod).  
    4. node\_proxy.set\_param(pipewire::spa::param::ParamType::Props.as\_raw(), 0, \&pod) aufrufen.  
  * **Nachbedingungen:** Der Stummschaltungsbefehl wurde gesendet.  
  * **Fehlerfälle:** AudioError::DeviceOrStreamNotFound, AudioError::SpaPodBuildFailed, AudioError::PipeWireCommandFailed.  
* pub(super) fn set\_device\_volume(loop\_data: \&PipeWireLoopData, device\_id: u32, volume: Volume, curve: VolumeCurve) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** device\_id ist eine gültige Proxy-ID eines MonitoredDevice, dessen Proxy ein pipewire::device::Device ist.  
  * **Schritte:**  
    1. Sucht den MonitoredDevice anhand der device\_id.  
    2. Den pipewire::device::Device-Proxy extrahieren.  
    3. Die volume.channel\_volumes entsprechend der VolumeCurve anpassen.  
    4. Die aktuelle aktive Route für das Gerät ermitteln (ggf. durch enum\_params\_sync für SPA\_PARAM\_Route und Auswahl der Route mit dem höchsten priority oder dem passenden index).  
    5. Einen SpaPod für SPA\_PARAM\_Route erstellen, der die index, device (oft 0 für die Route selbst) und die neuen props (mit channelVolumes) enthält (siehe spa\_pod\_utils::build\_route\_volume\_pod). 26  
    6. device\_proxy.set\_param(pipewire::spa::param::ParamType::Route.as\_raw(), 0, \&pod) aufrufen.  
  * **Nachbedingungen:** Der Lautstärkebefehl für die Geräteroute wurde gesendet.  
  * **Fehlerfälle:** AudioError::DeviceOrStreamNotFound, AudioError::SpaPodBuildFailed, AudioError::PipeWireCommandFailed, AudioError::NoActiveRouteFound.  
* pub(super) fn set\_device\_mute(loop\_data: \&PipeWireLoopData, device\_id: u32, mute: bool) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** device\_id ist eine gültige Proxy-ID eines MonitoredDevice (Device-Proxy).  
  * **Schritte:**  
    1. Sucht den MonitoredDevice.  
    2. Den pipewire::device::Device-Proxy extrahieren.  
    3. Aktive Route ermitteln.  
    4. Einen SpaPod für SPA\_PARAM\_Route erstellen, der die props (mit mute) enthält (siehe spa\_pod\_utils::build\_route\_mute\_pod).  
    5. device\_proxy.set\_param(pipewire::spa::param::ParamType::Route.as\_raw(), 0, \&pod) aufrufen.  
  * **Nachbedingungen:** Der Stummschaltungsbefehl für die Geräteroute wurde gesendet.  
  * **Fehlerfälle:** AudioError::DeviceOrStreamNotFound, AudioError::SpaPodBuildFailed, AudioError::PipeWireCommandFailed, AudioError::NoActiveRouteFound.  
* pub(super) fn set\_default\_device(loop\_data: \&mut PipeWireLoopData, device\_type: AudioDeviceType, global\_id: u32) \-\> Result\<(), AudioError\>:  
  * **Vorbedingungen:** loop\_data.metadata\_proxy ist Some. global\_id ist die globale ID des Geräts, das zum Standard werden soll.  
  * **Schritte:**  
    1. Wenn loop\_data.metadata\_proxy None ist, AudioError::MetadataProxyNotAvailable zurückgeben.  
    2. Den pipewire::metadata::Metadata-Proxy extrahieren.  
    3. Den Eigenschaftsnamen basierend auf device\_type bestimmen:  
       * AudioDeviceType::Sink \=\> "default.audio.sink"  
       * AudioDeviceType::Source \=\> "default.audio.source"  
    4. Den Wert als String der global\_id vorbereiten.  
    5. metadata\_proxy.set\_property(property\_name, "Spa:String:JSON", \&global\_id\_string) aufrufen. Die Typangabe "Spa:String:JSON" könnte auch einfach "string" sein, je nachdem was PipeWire erwartet.  
       * **Anmerkung:** Die genaue Methode zum Setzen von Metadaten-Eigenschaften muss anhand der pipewire-rs API für Metadata überprüft werden. Es könnte sein, dass ein SpaDict mit den zu setzenden Properties übergeben werden muss.  
    6. Bei Erfolg wird der PwMetadataPropsChanged-Event ausgelöst und von handle\_metadata\_props\_changed verarbeitet, was den internen Zustand und die is\_default-Flags aktualisiert.  
  * **Nachbedingungen:** Der Befehl zum Ändern des Standardgeräts wurde an PipeWire gesendet.  
  * **Fehlerfälle:** AudioError::MetadataProxyNotAvailable, AudioError::PipeWireCommandFailed.

### **5.3.4. Submodul: system::audio::types \- Kerndatenstrukturen für Audio**

* **Datei:** system/audio/types.rs  
* **Zweck:** Definiert die primären Datenstrukturen, die vom Audio-Modul verwendet und nach außen exponiert werden.

#### **5.3.4.1. Enums**

* \#  
  pub enum AudioError {... } (Definition im error.rs Modul, hier nur als Referenz)  
* \#  
  pub enum AudioDeviceType { Sink, Source, Unknown }  
  * **Zweck:** Repräsentiert den Typ eines Audiogeräts.  
  * **Ableitung:** Aus media.class Property von PipeWire-Objekten (z.B. "Audio/Sink", "Audio/Source").  
* \#  
  pub enum VolumeCurve { Linear, Cubic }  
  * **Zweck:** Definiert die Kurve, die bei der Lautstärkeanpassung verwendet wird. Cubic wird oft für eine natürlichere Wahrnehmung der Lautstärkeänderung verwendet.  
  * **Initialwert:** Typischerweise Cubic für UI-Interaktionen.  
* \#  
  pub enum AudioCommand {... } (siehe Tabelle 5.2)  
* \#  
  pub enum AudioEvent {... } (siehe Tabelle 5.3)

#### **5.3.4.2. Strukuren**

* \#  
  pub struct Volume { pub channel\_volumes: Vec\<f32\> }  
  * **Zweck:** Repräsentiert die Lautstärke für jeden Kanal eines Geräts oder Streams. Werte typischerweise zwischen 0.0 und 1.0 (oder höher, falls Übersteuerung erlaubt ist).  
  * **Invarianten:** channel\_volumes sollte nicht leer sein, wenn das Gerät aktiv ist. Alle Werte sollten ≥0.0.  
  * **Initialwert:** Abhängig vom Gerät; oft 1.0 für jeden Kanal.  
* \#  
  pub struct AudioDevice {... } (siehe Tabelle 5.1)  
* \#  
  pub struct StreamInfo {  
  * pub id: u32, // Globale PipeWire ID des Node-Objekts  
  * pub name: Option\<String\>, // Aus node.name oder application.name  
  * pub application\_name: Option\<String\>, // Aus application.name  
  * pub process\_id: Option\<u32\>, // Aus application.process.id  
  * pub volume: Volume,  
  * pub is\_muted: bool,  
  * pub media\_class: Option\<String\>, // z.B. "Stream/Output/Audio"  
  * pub node\_id\_pw: u32, // PipeWire interne Node ID (object.serial oder node.id) }  
  * **Zweck:** Repräsentiert einen aktiven Audio-Stream einer Anwendung.  
  * **Ableitung:** Aus den Eigenschaften eines PipeWire Node-Objekts.

#### **Tabelle 5.1: AudioDevice Strukturdefinition**

| Feldname | Rust-Typ | PipeWire Property / Quelle | Beschreibung | Initialwert (Beispiel) | Sichtbarkeit |
| :---- | :---- | :---- | :---- | :---- | :---- |
| id | u32 | global.id | Eindeutige globale ID des PipeWire-Objekts (Node oder Device). | \- | pub |
| proxy\_id | u32 | proxy.id() | ID des gebundenen Proxy-Objekts. | \- | pub(super) |
| name | Option\<String\> | node.nick, device.nick, node.name, device.name | Benutzerfreundlicher Name des Geräts. | None | pub |
| description | Option\<String\> | node.description, device.description | Detailliertere Beschreibung des Geräts. | None | pub |
| device\_type | AudioDeviceType | media.class (z.B. "Audio/Sink", "Audio/Source") | Typ des Audiogeräts (Sink oder Quelle). | Unknown | pub |
| volume | Volume | SPA\_PARAM\_Props (channelVolumes) oder SPA\_PARAM\_Route | Aktuelle Lautstärkeeinstellungen für jeden Kanal. | Volume { vols: vec\! } | pub |
| is\_muted | bool | SPA\_PARAM\_Props (mute) oder SPA\_PARAM\_Route | Gibt an, ob das Gerät stummgeschaltet ist. | false | pub |
| is\_default | bool | PipeWire:Interface:Metadata Objekt (default.audio.sink/source) | Gibt an, ob dies das Standardgerät seines Typs ist. | false | pub |
| ports | Option\<Vec\<PortInfo\>\> | SPA\_PARAM\_PortConfig / SPA\_PARAM\_EnumPortInfo | Informationen über die Ports des Geräts (optional, falls benötigt). | None | pub |
| properties\_spa | Option\<pipewire::spa::SpaDict\> | global.props / proxy.get\_properties() | Rohe PipeWire SPA-Eigenschaften (für Debugging oder erweiterte Infos). | None | pub(super) |
| is\_hardware\_device | bool | Abgeleitet aus device.api (z.B. "alsa", "bluez\_input") | Gibt an, ob es sich um ein physisches Hardwaregerät handelt. | false | pub |
| api\_name | Option\<String\> | device.api | Name der zugrundeliegenden API (z.B. "alsa", "v4l2", "libcamera"). | None | pub |

#### **Tabelle 5.2: AudioCommand Enum Varianten**

| Variante | Parameter | Beschreibung |
| :---- | :---- | :---- |
| SetDeviceVolume | device\_id: u32, volume: Volume, curve: VolumeCurve | Setzt die Lautstärke für ein bestimmtes Gerät. |
| SetDeviceMute | device\_id: u32, mute: bool | Schaltet ein bestimmtes Gerät stumm oder hebt die Stummschaltung auf. |
| SetStreamVolume | stream\_id: u32, volume: Volume, curve: VolumeCurve | Setzt die Lautstärke für einen bestimmten Anwendungsstream. |
| SetStreamMute | stream\_id: u32, mute: bool | Schaltet einen bestimmten Anwendungsstream stumm oder hebt die Stummschaltung auf. |
| SetDefaultDevice | device\_type: AudioDeviceType, device\_id: u32 | Setzt das Standardgerät für den angegebenen Typ (Sink/Source). |
| RequestDeviceList | \- | Fordert die aktuelle Liste aller bekannten Audiogeräte an. |
| RequestStreamList | \- | Fordert die aktuelle Liste aller bekannten Audio-Streams an. |

#### **Tabelle 5.3: AudioEvent Enum Varianten**

| Variante | Payload | Beschreibung |
| :---- | :---- | :---- |
| DeviceAdded | device: AudioDevice | Ein neues Audiogerät wurde dem System hinzugefügt. |
| DeviceRemoved | device\_id: u32 | Ein Audiogerät wurde vom System entfernt. |
| DeviceUpdated | device: AudioDevice | Eigenschaften eines Audiogeräts haben sich geändert (z.B. Name, Beschreibung). |
| DeviceVolumeChanged | device\_id: u32, new\_volume: Volume | Die Lautstärke eines Geräts hat sich geändert. |
| DeviceMuteChanged | device\_id: u32, is\_muted: bool | Der Stummschaltungsstatus eines Geräts hat sich geändert. |
| StreamAdded | stream: StreamInfo | Ein neuer Audio-Stream einer Anwendung wurde erkannt. |
| StreamRemoved | stream\_id: u32 | Ein Audio-Stream einer Anwendung wurde beendet. |
| StreamUpdated | stream: StreamInfo | Eigenschaften eines Streams haben sich geändert. |
| StreamVolumeChanged | stream\_id: u32, new\_volume: Volume | Die Lautstärke eines Anwendungsstreams hat sich geändert. |
| StreamMuteChanged | stream\_id: u32, is\_muted: bool | Der Stummschaltungsstatus eines Anwendungsstreams hat sich geändert. |
| DefaultSinkChanged | new\_device\_id: Option\<u32\> | Das Standard-Audioausgabegerät hat sich geändert. |
| DefaultSourceChanged | new\_device\_id: Option\<u32\> | Das Standard-Audioeingabegerät hat sich geändert. |
| AudioErrorOccurred | error: String | Ein Fehler im Audio-Subsystem ist aufgetreten. |
| DeviceListUpdated | devices: Vec\<AudioDevice\> | Antwort auf RequestDeviceList, enthält die aktuelle Geräteliste. |
| StreamListUpdated | streams: Vec\<StreamInfo\> | Antwort auf RequestStreamList, enthält die aktuelle Streamliste. |

### **5.3.5. Submodul: system::audio::spa\_pod\_utils \- SPA POD Konstruktionshilfsmittel**

* **Datei:** system/audio/spa\_pod\_utils.rs  
* **Zweck:** Enthält Hilfsfunktionen zur Erstellung von pipewire::spa::Pod (Simple Plugin API Plain Old Data) Objekten, die für das Setzen von Parametern wie Lautstärke und Stummschaltung über die PipeWire API benötigt werden.

#### **5.3.5.1. Funktionen**

* pub(super) fn build\_volume\_props\_pod(channel\_volumes: &\[f32\]) \-\> Result\<pipewire::spa::Pod, AudioError\>:  
  * **Vorbedingungen:** channel\_volumes enthält die gewünschten Lautstärkewerte pro Kanal (normalisiert, z.B. 0.0 bis 1.0).  
  * **Schritte:**  
    1. Erstellt einen pipewire::spa::pod::PodBuilder.  
    2. Beginnt ein Objekt (push\_object) vom Typ SPA\_TYPE\_OBJECT\_Props und ID SPA\_PARAM\_Props.  
    3. Fügt die Eigenschaft SPA\_PROP\_channelVolumes hinzu (prop(pipewire::spa::param::prop\_info::PropInfoType::channelVolumes.as\_raw(), 0)).  
    4. Fügt ein Array (push\_array) für die Float-Werte hinzu.  
    5. Iteriert über channel\_volumes und fügt jeden Wert als Float zum Array hinzu (float(vol)).  
    6. Schließt das Array (pop) und das Objekt (pop).  
    7. Gibt den erstellten Pod zurück.  
  * **Nachbedingungen:** Ein gültiger SpaPod für die Lautstärkeeinstellung ist erstellt.  
  * **Fehlerfälle:** AudioError::SpaPodBuildFailed, falls die Erstellung fehlschlägt.  
* pub(super) fn build\_mute\_props\_pod(mute: bool) \-\> Result\<pipewire::spa::Pod, AudioError\>:  
  * **Vorbedingungen:** mute enthält den gewünschten Stummschaltungsstatus.  
  * **Schritte:**  
    1. Erstellt einen pipewire::spa::pod::PodBuilder.  
    2. Beginnt ein Objekt (push\_object) vom Typ SPA\_TYPE\_OBJECT\_Props und ID SPA\_PARAM\_Props.  
    3. Fügt die Eigenschaft SPA\_PROP\_mute hinzu (prop(pipewire::spa::param::prop\_info::PropInfoType::mute.as\_raw(), 0)).  
    4. Fügt den booleschen Wert hinzu (boolean(mute)).  
    5. Schließt das Objekt (pop).  
    6. Gibt den erstellten Pod zurück.  
  * **Nachbedingungen:** Ein gültiger SpaPod für die Stummschaltung ist erstellt.  
  * **Fehlerfälle:** AudioError::SpaPodBuildFailed.  
* pub(super) fn build\_route\_volume\_pod(route\_index: u32, route\_device\_id: u32, channel\_volumes: &\[f32\]) \-\> Result\<pipewire::spa::Pod, AudioError\>:  
  * **Vorbedingungen:** route\_index und route\_device\_id identifizieren die Zielroute. channel\_volumes enthält die Lautstärkewerte.  
  * **Schritte:**  
    1. Erstellt einen pipewire::spa::pod::PodBuilder.  
    2. Beginnt ein Objekt (push\_object) vom Typ SPA\_TYPE\_OBJECT\_ParamRoute und ID SPA\_PARAM\_Route.  
    3. Fügt die Eigenschaft SPA\_PARAM\_ROUTE\_index mit route\_index hinzu (prop(...).int(route\_index)).  
    4. Fügt die Eigenschaft SPA\_PARAM\_ROUTE\_device mit route\_device\_id hinzu (prop(...).int(route\_device\_id)).  
    5. Fügt die Eigenschaft SPA\_PARAM\_ROUTE\_props hinzu.  
    6. Innerhalb von SPA\_PARAM\_ROUTE\_props ein weiteres Objekt (push\_object) vom Typ SPA\_TYPE\_OBJECT\_Props erstellen (ohne explizite ID, da es Teil der Route-Props ist).  
    7. Fügt SPA\_PROP\_channelVolumes und das Array der Float-Werte hinzu, wie in build\_volume\_props\_pod.  
    8. Schließt das innere Props-Objekt (pop) und das äußere Route-Objekt (pop).  
    9. Gibt den erstellten Pod zurück.  
  * **Nachbedingungen:** Ein SpaPod zum Setzen der Lautstärke einer spezifischen Route ist erstellt.  
  * **Fehlerfälle:** AudioError::SpaPodBuildFailed.  
* pub(super) fn build\_route\_mute\_pod(route\_index: u32, route\_device\_id: u32, mute: bool) \-\> Result\<pipewire::spa::Pod, AudioError\>:  
  * **Analoge Schritte** zu build\_route\_volume\_pod, aber für die SPA\_PROP\_mute-Eigenschaft innerhalb der SPA\_PARAM\_ROUTE\_props.  
* pub(super) fn parse\_props\_volume\_mute(pod: \&pipewire::spa::Pod) \-\> Result\<(Option\<Volume\>, Option\<bool\>), AudioError\>:  
  * **Vorbedingungen:** pod ist ein SpaPod, der vermutlich SPA\_PARAM\_Props repräsentiert.  
  * **Schritte:**  
    1. Iteriert durch die Eigenschaften des SpaPod-Objekts.  
    2. Sucht nach SPA\_PROP\_channelVolumes: Wenn gefunden, die Float-Werte aus dem Array extrahieren und in Volume verpacken.  
    3. Sucht nach SPA\_PROP\_mute: Wenn gefunden, den booleschen Wert extrahieren.  
    4. Gibt ein Tupel (Option\<Volume\>, Option\<bool\>) zurück.  
  * **Nachbedingungen:** Lautstärke und Mute-Status sind aus dem Pod extrahiert, falls vorhanden.  
  * **Fehlerfälle:** AudioError::SpaPodParseFailed, wenn die Struktur des Pods unerwartet ist.  
* pub(super) fn parse\_route\_props\_volume\_mute(pod: \&pipewire::spa::Pod) \-\> Result\<(Option\<Volume\>, Option\<bool\>), AudioError\>:  
  * **Vorbedingungen:** pod ist ein SpaPod, der SPA\_PARAM\_Route repräsentiert.  
  * **Schritte:**  
    1. Iteriert durch die Eigenschaften des SpaPod-Objekts (SPA\_TYPE\_OBJECT\_ParamRoute).  
    2. Sucht nach SPA\_PARAM\_ROUTE\_props.  
    3. Wenn gefunden, den inneren SpaPod (der SPA\_TYPE\_OBJECT\_Props sein sollte) mit parse\_props\_volume\_mute parsen.  
  * **Nachbedingungen:** Lautstärke und Mute-Status der Route sind extrahiert.  
  * **Fehlerfälle:** AudioError::SpaPodParseFailed.

### **5.3.6. Submodul: system::audio::error \- Fehlerbehandlung im Audio-Modul**

* **Datei:** system/audio/error.rs  
* **Zweck:** Definiert die spezifischen Fehlertypen für das system::audio-Modul unter Verwendung von thiserror.

#### **5.3.6.1. Enum AudioError**

* \# pub enum AudioError {  
  * \#\[error("PipeWire C API initialization failed.")\]  
    PipeWireInitFailed,  
  * \#\[error("Failed to create PipeWire MainLoop.")\]  
    MainLoopCreationFailed(\#\[source\] pipewire::Error),  
  * \#\[error("Failed to create PipeWire Context.")\]  
    ContextCreationFailed(\#\[source\] pipewire::Error),  
  * \#\[error("Failed to connect to PipeWire Core.")\]  
    CoreConnectionFailed(\#\[source\] pipewire::Error),  
  * \#  
    RegistryCreationFailed(\#\[source\] pipewire::Error),  
  * \#\[error("PipeWire thread panicked or failed to initialize.")\]  
    PipeWireThreadPanicked,  
  * \#\[error("Failed to bind to PipeWire proxy for global id {global\_id}: {source}")\]  
    ProxyBindFailed { global\_id: u32, \#\[source\] source: pipewire::Error },  
  * \#\[error("Failed to enumerate parameters for object id {object\_id}: {source}")\]  
    ParameterEnumerationFailed { object\_id: u32, \#\[source\] source: pipewire::Error },  
  * \#  
    SpaPodParseFailed { message: String },  
  * \#  
    SpaPodBuildFailed { message: String },  
  * \#\[error("PipeWire command failed for object {object\_id}: {source}")\]  
    PipeWireCommandFailed { object\_id: u32, \#\[source\] source: pipewire::Error },  
  * \#  
    DeviceOrStreamNotFound(u32),  
  * \#  
    NoActiveRouteFound(u32),  
  * \#\[error("PipeWire Metadata proxy is not available.")\]  
    MetadataProxyNotAvailable,  
  * \#  
    InternalChannelSendError(String),  
  * \#  
    InternalBroadcastSendError(String),  
    }  
  * **Begründung für thiserror**: thiserror wird verwendet, um Boilerplate-Code für die Implementierung von std::error::Error und std::fmt::Display zu reduzieren. Es ermöglicht klare, kontextbezogene Fehlermeldungen und die einfache Einbettung von Quellfehlern (\#\[from\] oder \#\[source\]). Dies ist entscheidend für die Diagnose von Problemen in einem komplexen Subsystem wie der Audioverwaltung.33 Die spezifischen Fehlervarianten ermöglichen es aufrufendem Code, differenziert auf Fehler zu reagieren.

## **6\. system::mcp \- Model Context Protocol Client**

Das Modul system::mcp implementiert einen Client für das Model Context Protocol (MCP). MCP ist ein offener Standard für die sichere und standardisierte Verbindung von KI-Modellen (LLMs) mit externen Werkzeugen, Datenquellen und Anwendungen, wie dieser Desktop-Umgebung.37 Dieses Modul ermöglicht es der Desktop-Umgebung, mit lokalen oder Cloud-basierten MCP-Servern zu kommunizieren, um KI-gestützte Funktionen bereitzustellen. Die Kommunikation erfolgt typischerweise über Stdio, wobei JSON-RPC-Nachrichten ausgetauscht werden.

* **Kernfunktionalität**:  
  * Senden von Anfragen an einen MCP-Server (z.B. tool\_run, resource\_list).  
  * Empfangen und Verarbeiten von Antworten und asynchronen Benachrichtigungen vom Server.  
  * Verwaltung des Verbindungsstatus zum MCP-Server.  
* **Verwendete Crates**: mcp\_client\_rs 37 oder mcpr 38 als Basis für die MCP-Client-Implementierung. Die Wahl fiel auf mcp\_client\_rs (von darinkishore) aufgrund seiner direkten Stdio-Transportunterstützung und klaren Client-API.  
* **Modulstruktur und Dateien**:  
  * system/mcp/mod.rs: Öffentliche API, McpError Enum.  
  * system/mcp/client.rs: McpClient-Struktur, Logik zum Senden von Anfragen und Empfangen von Antworten/Benachrichtigungen.  
  * system/mcp/transport.rs: Implementierung des Stdio-Transports, falls nicht vollständig vom Crate abgedeckt oder Anpassungen nötig sind.  
  * system/mcp/types.rs: Definitionen für MCP-Anfragen, \-Antworten und \-Benachrichtigungen, die für die Desktop-Umgebung relevant sind (ggf. Wrapper um Crate-Typen).  
  * system/mcp/error.rs: Fehlerbehandlung für das MCP-Modul.

### **5.4.1. Submodul: system::mcp::client \- MCP Client Kernlogik**

* **Datei:** system/mcp/client.rs  
* **Zweck:** Dieses Submodul enthält die Kernlogik für die Interaktion mit einem MCP-Server. Es ist verantwortlich für das Starten des MCP-Server-Prozesses (falls lokal), das Senden von Anfragen und das Verarbeiten von Antworten und serverseitigen Benachrichtigungen.

#### **5.4.1.1. Strukuren**

* pub struct McpClient:  
  * client\_handle: Option\<mcp\_client\_rs::client::Client\>: Die eigentliche Client-Instanz aus dem mcp\_client\_rs-Crate. Option, da die Verbindung fehlschlagen oder noch nicht etabliert sein kann.  
  * server\_process: Option\<tokio::process::Child\>: Handle für den Kindprozess des MCP-Servers, falls dieser lokal von der Desktop-Umgebung gestartet wird.  
  * command\_sender: tokio::sync::mpsc::Sender\<McpCommand\>: Sender für Befehle an den MCP-Verwaltungs-Task.  
  * notification\_broadcaster: tokio::sync::broadcast::Sender\<McpNotification\>: Sender zum Verteilen von MCP-Benachrichtigungen an interessierte Systemkomponenten.  
  * status\_broadcaster: tokio::sync::broadcast::Sender\<McpClientStatus\>: Sender zum Verteilen von Statusänderungen des MCP-Clients.  
  * request\_id\_counter: std::sync::Arc\<std::sync::atomic::AtomicU64\>: Atomarer Zähler zur Generierung eindeutiger Request-IDs für JSON-RPC.  
  * pending\_requests: std::sync::Arc\<tokio::sync::Mutex\<std::collections::HashMap\<String, tokio::sync::oneshot::Sender\<Result\<serde\_json::Value, McpError\>\>\>\>\>: Speichert oneshot::Sender für jede ausstehende Anfrage, um die Antwort an den ursprünglichen Aufrufer weiterzuleiten. Der Key ist die Request-ID.  
  * listen\_task\_handle: Option\<tokio::task::JoinHandle\<()\>\>: Handle für den Tokio-Task, der eingehende Nachrichten vom MCP-Server verarbeitet.  
* pub struct McpServerConfig:  
  * command: String: Der auszuführende Befehl zum Starten des MCP-Servers (z.B. "/usr/bin/my\_mcp\_server").  
  * args: Vec\<String\>: Argumente für den Server-Befehl.  
  * working\_directory: Option\<String\>: Arbeitsverzeichnis für den Serverprozess.

#### **5.4.1.2. Enums**

* pub enum McpClientStatus:  
  * Disconnected: Der Client ist nicht verbunden.  
  * Connecting: Der Client versucht, eine Verbindung herzustellen.  
  * Connected: Der Client ist verbunden und initialisiert.  
  * Error(String): Ein Fehler ist aufgetreten.  
* pub enum McpCommand:  
  * Initialize { params: mcp\_client\_rs::protocol::InitializeParams }  
  * ListResources { params: mcp\_client\_rs::protocol::ListResourcesParams, response\_tx: tokio::sync::oneshot::Sender\<Result\<mcp\_client\_rs::protocol::ListResourcesResult, McpError\>\> }  
  * ReadResource { params: mcp\_client\_rs::protocol::ReadResourceParams, response\_tx: tokio::sync::oneshot::Sender\<Result\<mcp\_client\_rs::protocol::ReadResourceResult, McpError\>\> }  
  * CallTool { params: mcp\_client\_rs::protocol::CallToolParams, response\_tx: tokio::sync::oneshot::Sender\<Result\<mcp\_client\_rs::protocol::CallToolResult, McpError\>\> }  
  * Shutdown  
  * SubscribeToNotifications { subscriber: tokio::sync::broadcast::Sender\<McpNotification\> } (Beispiel für eine spezifischere Benachrichtigungsbehandlung)

#### **5.4.1.3. Methoden für McpClient**

* pub async fn new(server\_config: McpServerConfig, notification\_broadcaster: tokio::sync::broadcast::Sender\<McpNotification\>, status\_broadcaster: tokio::sync::broadcast::Sender\<McpClientStatus\>) \-\> Result\<Self, McpError\>:  
  * **Vorbedingungen:** server\_config ist gültig.  
  * **Schritte:**  
    1. Erstellt einen tokio::sync::mpsc::channel für McpCommand.  
    2. Initialisiert request\_id\_counter und pending\_requests.  
    3. Startet den MCP-Serverprozess gemäß server\_config mit tokio::process::Command. Stdin, Stdout und Stderr des Kindprozesses müssen für die Kommunikation verfügbar gemacht werden (Pipes). 37  
       * let mut command \= tokio::process::Command::new(\&server\_config.command);  
       * command.args(\&server\_config.args).stdin(std::process::Stdio::piped()).stdout(std::process::Stdio::piped()).stderr(std::process::Stdio::piped());  
       * if let Some(wd) \= \&server\_config.working\_directory { command.current\_dir(wd); }  
       * let child \= command.spawn().map\_err(|e| McpError::ServerSpawnFailed(e.to\_string()))?;  
    4. Nimmt stdin und stdout des Kindprozesses.  
    5. Erstellt einen mcp\_client\_rs::transport::stdio::StdioTransport mit den Pipes des Kindprozesses. 37  
    6. Erstellt eine mcp\_client\_rs::client::Client-Instanz mit dem Transport.  
    7. Speichert client\_handle und server\_process.  
    8. Startet den listen\_task (siehe unten) mit tokio::spawn.  
    9. Sendet McpClientStatus::Connecting über status\_broadcaster.  
    10. Sendet einen Initialize-Befehl an den command\_sender, um die MCP-Sitzung zu initialisieren. Wartet auf die Antwort.  
    11. Bei Erfolg: Sendet McpClientStatus::Connected über status\_broadcaster.  
    12. Bei Fehler: Sendet McpClientStatus::Error und gibt Fehler zurück.  
  * **Nachbedingungen:** MCP-Client ist initialisiert und verbunden, oder ein Fehler wird zurückgegeben. Der listen\_task läuft.  
  * **Fehlerfälle:** McpError::ServerSpawnFailed, McpError::TransportError, McpError::InitializationFailed.  
* async fn listen\_task(mut client\_transport\_rx: mcp\_client\_rs::transport::stdio::StdioTransportReceiver, /\*... \*/):  
  * **Logik:** Diese asynchrone Funktion läuft in einem eigenen Tokio-Task.  
  * Sie lauscht kontinuierlich auf eingehende Nachrichten vom StdioTransportReceiver (der rx-Teil des StdioTransport).  
  * Jede empfangene Nachricht (eine JSON-Zeichenkette) wird deserialisiert:  
    * Wenn es eine Antwort auf eine Anfrage ist (enthält id):  
      1. Sucht den passenden oneshot::Sender in pending\_requests anhand der id.  
      2. Sendet das Ergebnis (erfolgreiche Antwort oder Fehlerobjekt aus der Nachricht) über den oneshot::Sender.  
      3. Entfernt den Eintrag aus pending\_requests.  
    * Wenn es eine Benachrichtigung ist (enthält method, aber keine id):  
      1. Konvertiert die Benachrichtigung in eine McpNotification.  
      2. Sendet die McpNotification über den notification\_broadcaster.  
    * Wenn es eine Fehlermeldung ist, die nicht zu einer bestimmten Anfrage gehört (selten, aber möglich):  
      1. Loggt den Fehler.  
      2. Sendet ggf. McpClientStatus::Error.  
  * Behandelt Lese-/Deserialisierungsfehler und den Fall, dass der Server die Verbindung schließt (EOF auf Stdio). In solchen Fällen wird McpClientStatus::Disconnected oder McpClientStatus::Error gesendet und der Task beendet sich.  
  * Die mcp\_client\_rs Bibliothek könnte bereits einen Mechanismus zum Empfangen und Verarbeiten von Nachrichten bereitstellen (z.B. einen Stream von Nachrichten oder Callbacks). Diese Funktion würde diesen Mechanismus nutzen. 37  
* async fn send\_request\_generic\<P, R\>(\&self, method: \&str, params: P) \-\> Result\<R, McpError\>  
  where P: serde::Serialize \+ Send, R: serde::de::DeserializeOwned \+ Send:  
  * **Vorbedingungen:** Client ist verbunden.  
  * **Schritte:**  
    1. Wenn client\_handle None ist, McpError::NotConnected zurückgeben.  
    2. Generiert eine eindeutige request\_id (z.B. mit self.request\_id\_counter.fetch\_add(1, std::sync::atomic::Ordering::Relaxed).to\_string()).  
    3. Erstellt einen tokio::sync::oneshot::channel für die Antwort.  
    4. Speichert den response\_tx in pending\_requests mit der request\_id als Schlüssel.  
    5. Erstellt die JSON-RPC-Anfrage-Struktur (z.B. mcp\_client\_rs::protocol::Request).  
    6. Serialisiert die Anfrage zu einem JSON-String.  
    7. Sendet den JSON-String über den writer-Teil des StdioTransport des client\_handle. Dies wird von mcp\_client\_rs intern gehandhabt, z.B. durch eine Methode wie client.send\_request(req\_obj).await.  
    8. Wartet auf die Antwort über response\_rx.await.  
    9. Gibt das Ergebnis zurück.  
  * **Nachbedingungen:** Anfrage wurde gesendet und auf Antwort gewartet.  
  * **Fehlerfälle:** McpError::NotConnected, McpError::SerializationFailed, McpError::TransportError, McpError::RequestTimeout (falls implementiert), McpError::ServerReturnedError.  
* pub async fn list\_resources(\&self, params: mcp\_client\_rs::protocol::ListResourcesParams) \-\> Result\<mcp\_client\_rs::protocol::ListResourcesResult, McpError\>:  
  * Ruft self.send\_request\_generic("resource/list", params).await auf.  
* pub async fn read\_resource(\&self, params: mcp\_client\_rs::protocol::ReadResourceParams) \-\> Result\<mcp\_client\_rs::protocol::ReadResourceResult, McpError\>:  
  * Ruft self.send\_request\_generic("resource/read", params).await auf.  
* pub async fn call\_tool(\&self, params: mcp\_client\_rs::protocol::CallToolParams) \-\> Result\<mcp\_client\_rs::protocol::CallToolResult, McpError\>:  
  * Ruft self.send\_request\_generic("tool/run", params).await auf. 37  
* pub async fn shutdown(\&mut self) \-\> Result\<(), McpError\>:  
  * **Vorbedingungen:** Keine.  
  * **Schritte:**  
    1. Wenn client\_handle Some ist, eine shutdown-Anfrage an den Server senden (falls vom MCP-Protokoll spezifiziert und von mcp\_client\_rs unterstützt).  
    2. Den listen\_task abbrechen (self.listen\_task\_handle.as\_ref().map(|h| h.abort())).  
    3. Wenn server\_process Some ist, dem Kindprozess ein SIGTERM senden und auf sein Beenden warten (child.kill().await, child.wait().await).  
    4. self.client\_handle \= None; self.server\_process \= None;  
    5. Sendet McpClientStatus::Disconnected über status\_broadcaster.  
  * **Nachbedingungen:** Client ist heruntergefahren, Serverprozess (falls lokal) ist beendet.  
  * **Fehlerfälle:** McpError::TransportError.  
* pub fn get\_command\_sender(\&self) \-\> tokio::sync::mpsc::Sender\<McpCommand\>:  
  * Gibt einen Klon des command\_sender zurück.

### **5.4.2. Submodul: system::mcp::transport \- MCP Kommunikationstransport**

* **Datei:** system/mcp/transport.rs  
* **Zweck:** Dieses Submodul ist primär eine Abstraktionsebene, falls die verwendete mcp\_client\_rs-Bibliothek keine direkte oder anpassbare Stdio-Transportimplementierung bietet, die unseren Anforderungen genügt (z.B. spezifische Fehlerbehandlung, Logging-Integration). In den meisten Fällen wird die Transportlogik direkt vom mcp\_client\_rs::transport::stdio::StdioTransport gehandhabt.  
  * Die mcp\_client\_rs Bibliothek 37 und mcpr 38 bieten bereits Stdio-Transportmechanismen. Diese werden direkt in system::mcp::client verwendet.  
  * Dieses Modul würde nur dann eigene Implementierungen enthalten, wenn eine tiefgreifende Anpassung des Transports notwendig wäre, was aktuell nicht der Fall ist.

### **5.4.3. Submodul: system::mcp::types \- MCP Nachrichtenstrukturen und Datentypen**

* **Datei:** system/mcp/types.rs  
* **Zweck:** Definiert Rust-Strukturen, die MCP-Anfragen, \-Antworten und \-Benachrichtigungen entsprechen, sowie alle relevanten Datentypen. Diese können direkte Wrapper um die Typen aus mcp\_client\_rs::protocol und mcp\_client\_rs::types sein oder bei Bedarf eigene, anwendungsspezifische Abstraktionen darstellen.

#### **5.4.3.1. Strukuren und Enums (Beispiele, basierend auf mcp\_client\_rs und MCP-Spezifikation)**

Die meisten dieser Typen werden direkt aus dem mcp\_client\_rs::protocol und mcp\_client\_rs::types Modul re-exportiert oder als dünne Wrapper verwendet.

* pub use mcp\_client\_rs::protocol::{InitializeParams, InitializeResult, ErrorResponse, Notification, Request, Response, ListResourcesParams, ListResourcesResult, ReadResourceParams, ReadResourceResult, CallToolParams, CallToolResult, Resource, Tool}; 37  
* pub use mcp\_client\_rs::types::{Content, Document, ErrorCode, ErrorData, Message, MessageId, NotificationMessage, RequestMessage, ResponseMessage, Version}; 37  
* \#  
  pub struct McpNotification {  
  * pub method: String,  
  * pub params: Option\<serde\_json::Value\>, }  
  * **Zweck:** Eine generische Struktur für vom Server empfangene Benachrichtigungen.  
  * **Ableitung:** Aus mcp\_client\_rs::protocol::Notification.

### **5.4.4. Submodul: system::mcp::error \- MCP Client Fehlerbehandlung**

* **Datei:** system/mcp/error.rs  
* **Zweck:** Definiert die spezifischen Fehlertypen für das system::mcp-Modul.

#### **5.4.4.1. Enum McpError**

* \# pub enum McpError {  
  * \#\[error("Failed to spawn MCP server process: {0}")\]  
    ServerSpawnFailed(String),  
  * \#  
    TransportError(\#\[from\] mcp\_client\_rs::Error), // Direkte Konvertierung von Fehlern des mcp\_client\_rs Crates  
  * \#\[error("MCP client is not connected or initialized.")\]  
    NotConnected,  
  * \#\[error("Failed to initialize MCP session with server: {0}")\]  
    InitializationFailed(String), // Kann Details vom Server-Error enthalten  
  * \#\[error("Failed to serialize request: {0}")\]  
    SerializationFailed(\#\[from\] serde\_json::Error),  
  * \#  
    RequestTimeout,  
  * \#\[error("MCP server returned an error: {code} \- {message}")\]  
    ServerReturnedError { code: i64, message: String, data: Option\<serde\_json::Value\> }, // Basierend auf JSON-RPC Fehlerobjekt  
  * \#  
    UnexpectedResponse { request\_id: String },  
  * \#  
    ResponseChannelDropped { request\_id: String },  
  * \#\[error("Failed to send command to MCP client task: {0}")\]  
    CommandSendError(String),  
    }  
  * Die Felder in ServerReturnedError entsprechen typischen JSON-RPC-Fehlerobjekten.  
  * \#\[from\] wird verwendet, um Fehler von serde\_json und mcp\_client\_rs::Error direkt in McpError umzuwandeln, was die Fehlerbehandlung vereinfacht.33

## **7\. system::portals \- XDG Desktop Portals Backend**

Das Modul system::portals implementiert die Backend-Logik für ausgewählte XDG Desktop Portals.60 Diese Portale ermöglichen es sandboxed Anwendungen (wie Flatpaks, aber auch nativen Anwendungen), sicher auf Ressourcen außerhalb ihrer Sandbox zuzugreifen, z.B. für Dateiauswahldialoge oder Screenshots. Dieses Modul agiert als D-Bus-Dienst, der die Portal-Schnittstellen implementiert und Anfragen von Client-Anwendungen bearbeitet.

* **Kernfunktionalität**:  
  * Implementierung der D-Bus-Schnittstellen für org.freedesktop.portal.FileChooser und org.freedesktop.portal.Screenshot.  
  * Interaktion mit der UI-Schicht zur Anzeige von Dialogen (z.B. Dateiauswahl).  
  * Interaktion mit dem Compositor (Systemschicht) für Aktionen wie Screenshots.  
* **Verwendete Crates**: zbus für die D-Bus-Implementierung 83, ashpd (Rust-Bindings für XDG Desktop Portals, falls für Backend-Implementierung nützlich, ansonsten direkte D-Bus-Implementierung). Die Entscheidung fällt auf eine direkte Implementierung mit zbus, um volle Kontrolle zu behalten und keine unnötigen Abstraktionen einzuführen, da wir das Backend selbst bereitstellen.  
* **Modulstruktur und Dateien**:  
  * system/portals/mod.rs: Öffentliche API, PortalsError Enum, Startpunkt für den D-Bus-Dienst.  
  * system/portals/file\_chooser.rs: Implementierung des org.freedesktop.portal.FileChooser-Interfaces.  
  * system/portals/screenshot.rs: Implementierung des org.freedesktop.portal.Screenshot-Interfaces.  
  * system/portals/common.rs: Gemeinsame Hilfsfunktionen, D-Bus-Setup, Request-Handling-Logik.  
  * system/portals/error.rs: Fehlerbehandlung für das Portals-Modul.

### **5.5.1. Submodul: system::portals::file\_chooser \- FileChooser Portal Backend**

* **Datei:** system/portals/file\_chooser.rs  
* **Zweck:** Implementiert die D-Bus-Schnittstelle org.freedesktop.portal.FileChooser. Dieses Portal ermöglicht Anwendungen das Öffnen und Speichern von Dateien über einen systemeigenen Dialog, der vom Desktop-Environment bereitgestellt wird.

#### **5.5.1.1. Struktur FileChooserPortal**

* pub struct FileChooserPortal {  
  * connection: std::sync::Arc\<zbus::Connection\>,  
  * // Referenz auf UI-Service oder Kommunikationskanal zur UI-Schicht,  
  * // um Dateiauswahldialoge anzuzeigen.  
  * // z.B. ui\_event\_sender: tokio::sync::mpsc::Sender\<UiPortalCommand\> }  
  * **Initialwerte:** connection wird bei der Instanziierung übergeben. UI-Kommunikationskanäle werden ebenfalls initialisiert.  
  * **Invarianten:** connection muss eine gültige D-Bus-Verbindung sein.

#### **5.5.1.2. D-Bus Interface Implementierung (\#\[zbus::interface\])**

* **Interface-Name:** org.freedesktop.portal.FileChooser  
* **Objektpfad:** (Wird vom system::portals::common oder main.rs beim Starten des Dienstes festgelegt, typischerweise /org/freedesktop/portal/desktop)  
* **Methoden:**  
  * async fn OpenFile(\&self, parent\_window: String, title: String, options: std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>) \-\> zbus::fdo::Result\<(u32, std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>)\>  
    * **Spezifikation:** 66  
    * **Parameter parent\_window (s):** Kennung des Anwendungsfensters (oft leer, "x11:XID" oder "wayland:HANDLE"). Wird derzeit nicht streng validiert, aber für zukünftige Modalitätslogik gespeichert.  
    * **Parameter title (s):** Titel für den Dialog.  
    * **Parameter options (a{sv}):**  
      * handle\_token (s): Eindeutiges Token für die Anfrage.  
      * accept\_label (s): Optionaler Text für den "Öffnen"-Button.  
      * modal (b): Ob der Dialog modal sein soll (Standard: true).  
      * multiple (b): Ob Mehrfachauswahl erlaubt ist (Standard: false).  
      * directory (b): Ob Ordner statt Dateien ausgewählt werden sollen (Standard: false).  
      * filters (a(sa(us))): Liste von Dateifiltern. Jeder Filter: (String Name, Array\<Tuple\<u32 Typ, String Muster/MIME\>\>)  
      * current\_filter ((sa(us))): Standardmäßig ausgewählter Filter.  
      * choices (a(ssa(ss)s)): Zusätzliche Auswahlmöglichkeiten (Comboboxen/Checkboxen).  
      * current\_folder (ay): Vorgeschlagener Startordner (als Byte-Array, NUL-terminiert).  
    * **Rückgabe:** handle (o) \- Ein Objektpfad für das Request-Objekt. Die eigentlichen Ergebnisse (URIs) werden asynchron über das Response-Signal des Request-Objekts gesendet.  
      * Die Implementierung hier gibt ein Tupel (u32 response\_code, a{sv} results) direkt zurück, wie es in vielen Portal-Implementierungen üblich ist, wenn kein separates Request-Objekt für einfache Fälle erstellt wird. response\_code \= 0 für Erfolg.  
      * results enthält uris (as) und choices (a(ss)).  
    * **Implementierungsschritte:**  
      1. Generiert eine eindeutige request\_handle (z.B. basierend auf handle\_token oder UUID).  
      2. Extrahiert Optionen wie multiple, directory, filters aus options.  
      3. Sendet einen Befehl an die UI-Schicht, um einen Dateiauswahldialog mit den gegebenen Parametern anzuzeigen. Dies erfordert einen Mechanismus (z.B. einen MPSC-Kanal), um mit der UI-Schicht zu kommunizieren und das Ergebnis (ausgewählte URIs) zurückzuerhalten.  
      4. Wartet asynchron auf die Antwort von der UI-Schicht.  
      5. Wenn die UI einen oder mehrere Datei-URIs zurückgibt:  
         * Erstellt ein results Dictionary: {"uris": zbus::zvariant::Value::from(vec\!\["file:///path/to/file1",...\])}.  
         * Gibt Ok((0, results\_dict)) zurück.  
      6. Wenn der Benutzer abbricht oder ein Fehler auftritt:  
         * Gibt Ok((1, HashMap::new())) für Abbruch durch Benutzer oder einen entsprechenden Fehlercode für andere Fehler zurück.  
         * Alternativ einen D-Bus-Fehler werfen: Err(zbus::fdo::Error::Failed("Dialog cancelled by user".into())).  
  * async fn SaveFile(\&self, parent\_window: String, title: String, options: std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>) \-\> zbus::fdo::Result\<(u32, std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>)\>  
    * **Spezifikation:** 66  
    * **Parameter options (a{sv}):** Zusätzlich zu den OpenFile-Optionen:  
      * current\_name (s): Vorgeschlagener Dateiname.  
      * current\_file (ay): Pfad zur aktuell zu speichernden Datei (falls "Speichern unter" für eine vorhandene Datei).  
    * **Implementierungsschritte:** Ähnlich wie OpenFile, aber die UI zeigt einen "Speichern"-Dialog an. Die UI gibt einen einzelnen URI zurück.  
  * async fn SaveFiles(\&self, parent\_window: String, title: String, options: std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>) \-\> zbus::fdo::Result\<(u32, std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>)\>  
    * **Spezifikation:** 66  
    * **Parameter options (a{sv}):** Zusätzlich zu den OpenFile-Optionen (außer multiple, directory):  
      * files (aay): Array von Byte-Arrays, die die zu speichernden Dateinamen repräsentieren.  
    * **Implementierungsschritte:**  
      1. Die UI wird angewiesen, einen Ordnerauswahldialog anzuzeigen.  
      2. Nach Auswahl eines Ordners durch den Benutzer konstruiert dieses Backend die vollständigen URIs, indem die in options\["files"\] übergebenen Dateinamen an den ausgewählten Ordnerpfad angehängt werden.  
      3. Gibt die Liste der resultierenden URIs zurück.  
* **Signale:** Das FileChooser-Interface selbst definiert keine Signale. Antworten werden über das Response-Signal des Request-Objekts gesendet, das durch den handle-Ausgabeparameter der Methoden referenziert wird. Für eine vereinfachte Implementierung ohne explizite Request-Objekte werden die Ergebnisse direkt zurückgegeben.

### **5.5.2. Submodul: system::portals::screenshot \- Screenshot Portal Backend**

* **Datei:** system/portals/screenshot.rs  
* **Zweck:** Implementiert die D-Bus-Schnittstelle org.freedesktop.portal.Screenshot. Dieses Portal ermöglicht Anwendungen das Erstellen von Screenshots und das Auswählen von Bildschirmfarben.

#### **5.5.2.1. Struktur ScreenshotPortal**

* pub struct ScreenshotPortal {  
  * connection: std::sync::Arc\<zbus::Connection\>,  
  * // Referenz/Kanal zum Compositor (Systemschicht), um Screenshot-Aktionen auszulösen  
  * // z.B. compositor\_command\_sender: tokio::sync::mpsc::Sender\<CompositorScreenshotCommand\> }  
  * **Initialwerte:** connection wird bei der Instanziierung übergeben. Compositor-Kommunikationskanäle werden ebenfalls initialisiert.  
  * **Invarianten:** connection muss eine gültige D-Bus-Verbindung sein.

#### **5.5.2.2. D-Bus Interface Implementierung (\#\[zbus::interface\])**

* **Interface-Name:** org.freedesktop.portal.Screenshot  
* **Objektpfad:** (Wird vom system::portals::common oder main.rs beim Starten des Dienstes festgelegt, typischerweise /org/freedesktop/portal/desktop)  
* **Methoden:**  
  * async fn Screenshot(\&self, parent\_window: String, options: std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>) \-\> zbus::fdo::Result\<(u32, std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>)\>  
    * **Spezifikation:** 67  
    * **Parameter options (a{sv}):**  
      * handle\_token (s): Eindeutiges Token für die Anfrage.  
      * modal (b): Ob der Dialog modal sein soll (Standard: true).  
      * interactive (b): Ob der Benutzer Optionen zur Auswahl des Bereichs etc. erhalten soll (Standard: false). **Seit Version 2 des Protokolls.**  
    * **Rückgabe:** handle (o) \- Objektpfad für das Request-Objekt. Hier vereinfacht zu direkter Rückgabe.  
    * **Implementierungsschritte:**  
      1. Extrahiert interactive aus options.  
      2. Sendet einen Befehl an den Compositor (Systemschicht), einen Screenshot zu erstellen.  
         * Wenn interactive true ist, sollte der Compositor dem Benutzer erlauben, einen Bereich auszuwählen oder ein Fenster etc.  
         * Wenn interactive false ist, wird ein Screenshot des gesamten Bildschirms (oder des primären Bildschirms) erstellt.  
      3. Der Compositor speichert den Screenshot temporär (z.B. in $XDG\_RUNTIME\_DIR/screenshots) und gibt den Dateipfad zurück.  
      4. Konvertiert den Dateipfad in einen file:// URI.  
      5. Erstellt ein results Dictionary: {"uri": zbus::zvariant::Value::from(screenshot\_uri)}.  
      6. Gibt Ok((0, results\_dict)) zurück.  
      7. Bei Fehlern (Compositor-Fehler, Speicherfehler): Ok((error\_code,...)) oder Err(zbus::fdo::Error).  
  * async fn PickColor(\&self, parent\_window: String, options: std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>) \-\> zbus::fdo::Result\<(u32, std::collections::HashMap\<String, zbus::zvariant::Value\<'static\>\>)\>  
    * **Spezifikation:** 67  
    * **Parameter options (a{sv}):**  
      * handle\_token (s): Eindeutiges Token.  
    * **Implementierungsschritte:**  
      1. Sendet einen Befehl an den Compositor, den Farbauswahlmodus zu starten (z.B. Anzeige einer Lupe unter dem Cursor).  
      2. Der Compositor meldet die ausgewählte Farbe (RGB-Werte, typischerweise als Tupel von f64 im Bereich ) zurück.  
      3. Erstellt ein results Dictionary: {"color": zbus::zvariant::Value::from((r, g, b))}.  
      4. Gibt Ok((0, results\_dict)) zurück.  
* **Properties (Version Property):**  
  * \#\[zbus(property(emits\_changed\_signal \= "const"))\] async fn version(\&self) \-\> u32 { 2 } // Oder die höchste unterstützte Version  
    * **Spezifikation:** 77  
    * Gibt die implementierte Version des Screenshot-Portals zurück.

### **5.5.3. Submodul: system::portals::common \- Gemeinsame Portal-Hilfsmittel & D-Bus Handhabung**

* **Datei:** system/portals/common.rs  
* **Zweck:** Enthält Code, der von mehreren Portal-Implementierungen gemeinsam genutzt wird, wie z.B. das Starten des D-Bus-Dienstes, die Registrierung von Objekten und Schnittstellen sowie Hilfsfunktionen für die Interaktion mit der UI- oder Systemschicht.

#### **5.5.3.1. Funktionen**

* pub async fn run\_portal\_service(ui\_command\_sender: tokio::sync::mpsc::Sender\<UiPortalCommand\>, compositor\_command\_sender: tokio::sync::mpsc::Sender\<CompositorScreenshotCommand\>) \-\> Result\<(), PortalsError\>:  
  * **Vorbedingungen:** Keine.  
  * **Schritte:**  
    1. Erstellt eine neue D-Bus-Verbindung zum Session-Bus: let connection \= zbus::ConnectionBuilder::session()?.build().await?;.83  
    2. Registriert den Dienstnamen org.freedesktop.portal.Desktop: connection.request\_name("org.freedesktop.portal.Desktop").await?;  
    3. Erstellt Instanzen der Portal-Implementierungen:  
       * let file\_chooser\_portal \= Arc::new(FileChooserPortal { connection: connection.clone(), /\* ui\_event\_sender \*/ });  
       * let screenshot\_portal \= Arc::new(ScreenshotPortal { connection: connection.clone(), /\* compositor\_command\_sender \*/ });  
    4. Registriert die Portal-Objekte und ihre Schnittstellen beim ObjectServer der Verbindung:  
       * connection.object\_server().at("/org/freedesktop/portal/desktop", file\_chooser\_portal).await?;  
       * connection.object\_server().at("/org/freedesktop/portal/desktop", screenshot\_portal).await?;  
         * **Hinweis:** zbus erlaubt das Hinzufügen mehrerer Interfaces zum selben Pfad, wenn die Interfaces unterschiedliche Namen haben. Wenn FileChooserPortal und ScreenshotPortal als separate Rust-Strukturen implementiert sind, die jeweils ein Interface bereitstellen, müssen sie entweder auf unterschiedlichen Pfaden registriert werden (was nicht der XDG-Spezifikation entspricht) oder eine einzelne Struktur muss alle Portal-Interfaces implementieren, die unter /org/freedesktop/portal/desktop angeboten werden.  
         * **Korrekter Ansatz:** Eine einzelne Struktur DesktopPortal erstellen, die alle Portal-Interfaces (FileChooser, Screenshot, etc.) als Traits implementiert oder Instanzen der spezifischen Portal-Handler hält und die Aufrufe an diese delegiert.

    Rust  
           // In system::portals::common.rs oder mod.rs  
           pub struct DesktopPortal {  
               file\_chooser: Arc\<FileChooserPortal\>,  
               screenshot: Arc\<ScreenshotPortal\>,  
               //... andere Portale  
           }

           \#\[zbus::interface(name \= "org.freedesktop.portal.FileChooser")\]  
           impl DesktopPortal {  
               async fn OpenFile(...) { self.file\_chooser.OpenFile(...).await }  
               //...  
           }

           \#  
           impl DesktopPortal {  
               async fn Screenshot(...) { self.screenshot.Screenshot(...).await }  
               //...  
           }  
           // In run\_portal\_service:  
           // let desktop\_portal\_impl \= Arc::new(DesktopPortal { file\_chooser, screenshot });  
           // connection.object\_server().at("/org/freedesktop/portal/desktop", desktop\_portal\_impl).await?;

    5. Die Funktion tritt in eine Schleife ein oder verwendet std::future::pending().await, um den Dienst am Laufen zu halten und auf D-Bus-Anfragen zu warten.  
  * **Nachbedingungen:** Der D-Bus-Dienst für die Portale läuft und ist bereit, Anfragen zu bearbeiten.  
  * **Fehlerfälle:** PortalsError::DBusConnectionFailed, PortalsError::DBusNameAcquisitionFailed, PortalsError::DBusInterfaceRegistrationFailed.  
* fn generate\_request\_handle(token\_prefix: \&str) \-\> String:  
  * Erzeugt einen eindeutigen Handle-String für Portal-Anfragen, typischerweise unter Verwendung eines Präfixes und einer UUID oder eines Zeitstempels. Beispiel: format\!("/org/freedesktop/portal/desktop/request/{}/{}", token\_prefix, uuid::Uuid::new\_v4().to\_string().replace('-', "")).

#### **5.5.3.2. Hilfsstrukturen (Beispiel)**

* pub enum UiPortalCommand {  
  * ShowOpenFile { request\_id: String, parent\_window: String, title: String, options: OpenFileOptions, response\_tx: tokio::sync::oneshot::Sender\<Result\<Vec\<String\>, PortalUiError\>\> },  
  * ShowSaveFile { request\_id: String, parent\_window: String, title: String, options: SaveFileOptions, response\_tx: tokio::sync::oneshot::Sender\<Result\<String, PortalUiError\>\> },  
  * //... weitere Befehle }  
* pub struct OpenFileOptions { /\* Felder entsprechend den D-Bus Optionen \*/ }  
* pub struct SaveFileOptions { /\* Felder entsprechend den D-Bus Optionen \*/ }  
* pub enum PortalUiError { CancelledByUser, InternalError(String) }  
* pub enum CompositorScreenshotCommand {  
  * TakeScreenshot { request\_id: String, interactive: bool, response\_tx: tokio::sync::oneshot::Sender\<Result\<String, CompositorError\>\> }, // String ist der URI  
  * PickColor { request\_id: String, response\_tx: tokio::sync::oneshot::Sender\<Result\<(f64, f64, f64), CompositorError\>\> }, }

### **5.5.4. Submodul: system::portals::error \- Fehlerbehandlung im Portals-Modul**

* **Datei:** system/portals/error.rs  
* **Zweck:** Definiert die spezifischen Fehlertypen für das system::portals-Modul.

#### **5.5.4.1. Enum PortalsError**

* \# pub enum PortalsError {  
  * \#  
    DBusConnectionFailed(\#\[from\] zbus::Error),  
  * \#  
    DBusNameAcquisitionFailed { service\_name: String, \#\[source\] source: zbus::Error },  
  * \#  
    DBusInterfaceRegistrationFailed { interface\_name: String, object\_path: String, \#\[source\] source: zbus::Error },  
  * \#\[error("Failed to send command to UI layer: {0}")\]  
    UiCommandSendError(String),  
  * \#\[error("Failed to send command to Compositor layer: {0}")\]  
    CompositorCommandSendError(String),  
  * \#\[error("UI interaction failed or was cancelled: {0}")\]  
    UiInteractionFailed(String),  
  * \#\[error("Compositor interaction failed: {0}")\]  
    CompositorInteractionFailed(String),  
  * \#\[error("Invalid options provided for portal request: {0}")\]  
    InvalidOptions(String),  
    }  
  * Die Verwendung von \#\[from\] für zbus::Error ermöglicht eine einfache Konvertierung von zbus-Fehlern.104

---

**Schlussfolgerung Systemschicht Teil 4/4**  
Mit der Spezifikation der Module system::audio, system::mcp und system::portals ist die detaillierte Ausarbeitung der Systemschicht abgeschlossen. Diese Module stellen kritische Schnittstellen zum Audiosystem, zur KI-Integration und zu Desktop-übergreifenden Diensten bereit. Die Implementierung gemäß dieser Ultra-Feinspezifikation wird eine robuste und gut integrierte Systemschicht gewährleisten, die als solide Grundlage für die darüberliegende Benutzeroberflächenschicht dient. Die konsequente Nutzung von Rust, PipeWire, D-Bus und etablierten Freedesktop-Standards sichert Modernität, Leistung und Kompatibilität. Die detaillierte Definition von Datenstrukturen, Methoden, Fehlerbehandlung und Interaktionsprotokollen minimiert Ambiguitäten und ermöglicht eine effiziente Implementierung.

#### **Referenzen**

1. PipeWire — multimedia in Rust // Lib.rs, Zugriff am Mai 14, 2025, [https://lib.rs/crates/pipewire](https://lib.rs/crates/pipewire)  
2. PipeWire: PipeWire, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/](https://docs.pipewire.org/)  
3. PipeWire API, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/page\_api.html](https://docs.pipewire.org/page_api.html)  
4. Crate pipewire \- Rust \- FreeDesktop.org, Zugriff am Mai 14, 2025, [https://pipewire.pages.freedesktop.org/pipewire-rs/pipewire/](https://pipewire.pages.freedesktop.org/pipewire-rs/pipewire/)  
5. Tutorial \- Part 2: Enumerating Objects \- PipeWire, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/1.4/page\_tutorial2.html](https://docs.pipewire.org/1.4/page_tutorial2.html)  
6. pw\_registry\_events Struct Reference \- PipeWire, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/structpw\_\_registry\_\_events.html](https://docs.pipewire.org/structpw__registry__events.html)  
7. Streams \- PipeWire, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/page\_streams.html](https://docs.pipewire.org/page_streams.html)  
8. Sending Messages to a Pipewire Node \- Frank's Reich, Zugriff am Mai 14, 2025, [https://franks-reich.net/posts/sending\_messages\_to\_pipewire/](https://franks-reich.net/posts/sending_messages_to_pipewire/)  
9. pipewire/Rust: How to list all Audio/Source nodes and those properties by using pipewire-rs, Zugriff am Mai 14, 2025, [https://stackoverflow.com/questions/74793488/pipewire-rust-how-to-list-all-audio-source-nodes-and-those-properties-by-using](https://stackoverflow.com/questions/74793488/pipewire-rust-how-to-list-all-audio-source-nodes-and-those-properties-by-using)  
10. getting default audio/video input and ouput devices with rust and pipewire-rs, Zugriff am Mai 14, 2025, [https://stackoverflow.com/questions/77379792/getting-default-audio-video-input-and-ouput-devices-with-rust-and-pipewire-rs](https://stackoverflow.com/questions/77379792/getting-default-audio-video-input-and-ouput-devices-with-rust-and-pipewire-rs)  
11. Native Protocol \- PipeWire, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/page\_native\_protocol.html](https://docs.pipewire.org/page_native_protocol.html)  
12. pipewire 0.8.0 \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/pipewire/latest/pipewire/](https://docs.rs/pipewire/latest/pipewire/)  
13. Zugriff am Januar 1, 1970, [https://pipewire.pages.freedesktop.org/pipewire-rs/pipewire/registry/struct.Registry.html](https://pipewire.pages.freedesktop.org/pipewire-rs/pipewire/registry/struct.Registry.html)  
14. Zugriff am Januar 1, 1970, [https://pipewire.pages.freedesktop.org/pipewire-rs/pipewire/struct.MainLoop.html](https://pipewire.pages.freedesktop.org/pipewire-rs/pipewire/struct.MainLoop.html)  
15. Zugriff am Januar 1, 1970, [https://docs.rs/pipewire/latest/pipewire/type.Node.html](https://docs.rs/pipewire/latest/pipewire/type.Node.html)  
16. Zugriff am Januar 1, 1970, [https://docs.rs/pipewire/latest/pipewire/struct.Proxy.html](https://docs.rs/pipewire/latest/pipewire/struct.Proxy.html)  
17. Zugriff am Januar 1, 1970, [https://github.com/pipewire-rs/pipewire-rs/tree/master/examples](https://github.com/pipewire-rs/pipewire-rs/tree/master/examples)  
18. Zugriff am Januar 1, 1970, [https://docs.rs/pipewire/latest/pipewire/registry/struct.Registry.html](https://docs.rs/pipewire/latest/pipewire/registry/struct.Registry.html)  
19. Zugriff am Januar 1, 1970, [https://docs.rs/pipewire/latest/pipewire/node/struct.Node.html](https://docs.rs/pipewire/latest/pipewire/node/struct.Node.html)  
20. Zugriff am Januar 1, 1970, [https://github.com/pipewire-rs/pipewire-rs/blob/master/examples/audio-capture.rs](https://github.com/pipewire-rs/pipewire-rs/blob/master/examples/audio-capture.rs)  
21. Zugriff am Januar 1, 1970, [https://github.com/pipewire-rs/pipewire-rs/blob/master/src/node.rs](https://github.com/pipewire-rs/pipewire-rs/blob/master/src/node.rs)  
22. Zugriff am Januar 1, 1970, [https://github.com/pipewire-rs/pipewire-rs/blob/master/examples/dump-objects.rs](https://github.com/pipewire-rs/pipewire-rs/blob/master/examples/dump-objects.rs)  
23. Zugriff am Januar 1, 1970, [https://github.com/pipewire-rs/pipewire-rs/blob/master/pipewire/src/node.rs](https://github.com/pipewire-rs/pipewire-rs/blob/master/pipewire/src/node.rs)  
24. How to Capture Audio Using Pipewire and Rust \- Eloy Coto, Zugriff am Mai 14, 2025, [https://acalustra.com/playing-with-pipewire-audio-streams-and-rust.html](https://acalustra.com/playing-with-pipewire-audio-streams-and-rust.html)  
25. \[ANN\] wiremix: A TUI audio mixer for PipeWire written in Rust \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/rust/comments/1kbyv7s/ann\_wiremix\_a\_tui\_audio\_mixer\_for\_pipewire/](https://www.reddit.com/r/rust/comments/1kbyv7s/ann_wiremix_a_tui_audio_mixer_for_pipewire/)  
26. PipeWire volume-change with pw-cli doesn't notify other programs \- Stack Overflow, Zugriff am Mai 14, 2025, [https://stackoverflow.com/questions/77953845/pipewire-volume-change-with-pw-cli-doesnt-notify-other-programs](https://stackoverflow.com/questions/77953845/pipewire-volume-change-with-pw-cli-doesnt-notify-other-programs)  
27. Node \- PipeWire, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/1.4/group\_\_spa\_\_node.html](https://docs.pipewire.org/1.4/group__spa__node.html)  
28. pipewire-props, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/page\_man\_pipewire-props\_7.html](https://docs.pipewire.org/page_man_pipewire-props_7.html)  
29. \[SOLVED\] Low volume using Pipewire / Multimedia and Games / Arch Linux Forums, Zugriff am Mai 14, 2025, [https://bbs.archlinux.org/viewtopic.php?id=287573](https://bbs.archlinux.org/viewtopic.php?id=287573)  
30. spa/examples/example-control.c \- PipeWire, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/spa\_2examples\_2example-control\_8c-example.html](https://docs.pipewire.org/spa_2examples_2example-control_8c-example.html)  
31. spa/param/route.h Source File \- PipeWire, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/devel/route\_8h\_source.html](https://docs.pipewire.org/devel/route_8h_source.html)  
32. spa/param/audio/raw.h File Reference \- PipeWire, Zugriff am Mai 14, 2025, [https://docs.pipewire.org/1.4/audio\_2raw\_8h.html](https://docs.pipewire.org/1.4/audio_2raw_8h.html)  
33. Multiple error types \- Rust By Example, Zugriff am Mai 14, 2025, [https://doc.rust-lang.org/rust-by-example/error/multiple\_error\_types.html](https://doc.rust-lang.org/rust-by-example/error/multiple_error_types.html)  
34. Error handling \- good/best practices : r/rust \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/rust/comments/1bb7dco/error\_handling\_goodbest\_practices/](https://www.reddit.com/r/rust/comments/1bb7dco/error_handling_goodbest_practices/)  
35. Simplify Error Handling in Rust with thiserror Crate \- w3resource, Zugriff am Mai 14, 2025, [https://www.w3resource.com/rust-tutorial/simplify-error-handling-rust-thiserror-crate.php](https://www.w3resource.com/rust-tutorial/simplify-error-handling-rust-thiserror-crate.php)  
36. smithay/anvil/README.md at master \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/Smithay/smithay/blob/master/anvil/README.md](https://github.com/Smithay/smithay/blob/master/anvil/README.md)  
37. mcp\_client\_rs \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/mcp\_client\_rs](https://docs.rs/mcp_client_rs)  
38. conikeec/mcpr: Model Context Protocol (MCP) implementation in Rust \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/conikeec/mcpr](https://github.com/conikeec/mcpr)  
39. mcp\_client\_rs \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/mcp\_client\_rs](https://crates.io/crates/mcp_client_rs)  
40. mcpr \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/mcpr](https://docs.rs/mcpr)  
41. 0xKoda/mcp-rust-docs: An MCP to retrieve rust crate documentation for LLM's \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/0xKoda/mcp-rust-docs](https://github.com/0xKoda/mcp-rust-docs)  
42. MCP Notify Server – A Model Context Protocol service that sends desktop notifications and alert sounds when AI agent tasks are completed, integrating with various LLM clients like Claude Desktop and Cursor. \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/mcp/comments/1jd6j7x/mcp\_notify\_server\_a\_model\_context\_protocol/](https://www.reddit.com/r/mcp/comments/1jd6j7x/mcp_notify_server_a_model_context_protocol/)  
43. An MCP server for the github notifications API for the OSS maintainer, Zugriff am Mai 14, 2025, [https://github.com/mcollina/mcp-github-notifications](https://github.com/mcollina/mcp-github-notifications)  
44. Notifications \- Laravel 11.x \- The PHP Framework For Web Artisans, Zugriff am Mai 14, 2025, [https://laravel.com/docs/11.x/notifications](https://laravel.com/docs/11.x/notifications)  
45. React Native Android Notification Listener \- Listen for status bar notifications from all applications \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/leandrosimoes/react-native-android-notification-listener](https://github.com/leandrosimoes/react-native-android-notification-listener)  
46. Building a Server-Sent Events (SSE) MCP Server with FastAPI \- Ragie, Zugriff am Mai 14, 2025, [https://www.ragie.ai/blog/building-a-server-sent-events-sse-mcp-server-with-fastapi](https://www.ragie.ai/blog/building-a-server-sent-events-sse-mcp-server-with-fastapi)  
47. How would I create an asynchronous notification system using RESTful web services?, Zugriff am Mai 14, 2025, [https://stackoverflow.com/questions/1093900/how-would-i-create-an-asynchronous-notification-system-using-restful-web-service](https://stackoverflow.com/questions/1093900/how-would-i-create-an-asynchronous-notification-system-using-restful-web-service)  
48. mcp\_client\_rs \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/mcp\_client\_rs/0.1.1](https://crates.io/crates/mcp_client_rs/0.1.1)  
49. mcp\_client\_rs \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/mcp\_client\_rs/0.1.4](https://crates.io/crates/mcp_client_rs/0.1.4)  
50. darinkishore/mcp\_client\_rust \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/darinkishore/mcp\_client\_rust](https://github.com/darinkishore/mcp_client_rust)  
51. README.md \- Model Context Protocol (MCP) Rust SDK \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/darinkishore/mcp\_client\_rust/blob/main/README.md](https://github.com/darinkishore/mcp_client_rust/blob/main/README.md)  
52. mcp\_client\_rs \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/mcp\_client\_rs/latest/mcp\_client\_rs/](https://docs.rs/mcp_client_rs/latest/mcp_client_rs/)  
53. Zugriff am Januar 1, 1970, [https://docs.rs/mcp\_client\_rs/latest/mcp\_client\_rs/client/struct.Client.html](https://docs.rs/mcp_client_rs/latest/mcp_client_rs/client/struct.Client.html)  
54. Zugriff am Januar 1, 1970, [https://github.com/darinkishore/mcp\_client\_rust/tree/main/examples](https://github.com/darinkishore/mcp_client_rust/tree/main/examples)  
55. Zugriff am Januar 1, 1970, [https://github.com/darinkishore/mcp\_client\_rust/blob/main/src/client.rs](https://github.com/darinkishore/mcp_client_rust/blob/main/src/client.rs)  
56. Zugriff am Januar 1, 1970, [https://github.com/darinkishore/mcp\_client\_rust/blob/main/src/transport/stdio.rs](https://github.com/darinkishore/mcp_client_rust/blob/main/src/transport/stdio.rs)  
57. Zugriff am Januar 1, 1970, [https://raw.githubusercontent.com/darinkishore/mcp\_client\_rust/main/src/client.rs](https://raw.githubusercontent.com/darinkishore/mcp_client_rust/main/src/client.rs)  
58. Zugriff am Januar 1, 1970, [https://raw.githubusercontent.com/darinkishore/mcp\_client\_rust/main/src/transport/stdio.rs](https://raw.githubusercontent.com/darinkishore/mcp_client_rust/main/src/transport/stdio.rs)  
59. EventStream in rocket::response::stream \- Rust, Zugriff am Mai 14, 2025, [https://api.rocket.rs/v0.5/rocket/response/stream/struct.EventStream](https://api.rocket.rs/v0.5/rocket/response/stream/struct.EventStream)  
60. xdg-portal \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/xdg-portal](https://crates.io/crates/xdg-portal)  
61. We have made a xdg-desktop-portal which supports the remote of xdg-desktop-portal : r/swaywm \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/swaywm/comments/1kjabld/we\_have\_made\_a\_xdgdesktopportal\_which\_supports/](https://www.reddit.com/r/swaywm/comments/1kjabld/we_have_made_a_xdgdesktopportal_which_supports/)  
62. git: bf9c9f5197f2 \- main \- x11/xdg-desktop-portal-luminous: update to 0.1.10, Zugriff am Mai 14, 2025, [https://lists.freebsd.org/archives/dev-commits-ports-all/2025-May/159001.html](https://lists.freebsd.org/archives/dev-commits-ports-all/2025-May/159001.html)  
63. Can't run cosmic-screenshot in 24.04 · Issue \#75 \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/pop-os/cosmic-screenshot/issues/75](https://github.com/pop-os/cosmic-screenshot/issues/75)  
64. How to take a screenshot with QtDBus via org.freedesktop.portal? \- Stack Overflow, Zugriff am Mai 14, 2025, [https://stackoverflow.com/questions/74213740/how-to-take-a-screenshot-with-qtdbus-via-org-freedesktop-portal](https://stackoverflow.com/questions/74213740/how-to-take-a-screenshot-with-qtdbus-via-org-freedesktop-portal)  
65. xdg-desktop-portal-1.20.0 \- Linux From Scratch\!, Zugriff am Mai 14, 2025, [https://www.linuxfromscratch.org/blfs/view/12.3/x/xdg-desktop-portal.html](https://www.linuxfromscratch.org/blfs/view/12.3/x/xdg-desktop-portal.html)  
66. File Chooser \- XDG Desktop Portal documentation \- Flatpak, Zugriff am Mai 14, 2025, [https://flatpak.github.io/xdg-desktop-portal/docs/doc-org.freedesktop.portal.FileChooser.html](https://flatpak.github.io/xdg-desktop-portal/docs/doc-org.freedesktop.portal.FileChooser.html)  
67. Backend D-Bus Interfaces \- XDG Desktop Portal documentation \- Flatpak, Zugriff am Mai 14, 2025, [https://flatpak.github.io/xdg-desktop-portal/docs/impl-dbus-interfaces.html](https://flatpak.github.io/xdg-desktop-portal/docs/impl-dbus-interfaces.html)  
68. XDG Desktop Portal \- Flatpak, Zugriff am Mai 14, 2025, [https://flatpak.github.io/xdg-desktop-portal/](https://flatpak.github.io/xdg-desktop-portal/)  
69. node-web-audio-api \- NPM, Zugriff am Mai 14, 2025, [https://www.npmjs.com/package/node-web-audio-api](https://www.npmjs.com/package/node-web-audio-api)  
70. XDG Desktop Portal \- ArchWiki, Zugriff am Mai 14, 2025, [https://wiki.archlinux.org/title/XDG\_Desktop\_Portal](https://wiki.archlinux.org/title/XDG_Desktop_Portal)  
71. Interacting with System Services using DBus Dart \- Aadarsha Dhakal, Zugriff am Mai 14, 2025, [https://blog.aadarshadhakal.com.np/interacting-with-system-services-using-dbus-dart](https://blog.aadarshadhakal.com.np/interacting-with-system-services-using-dbus-dart)  
72. Taking screenshots with Java under Wayland \- adangel.org, Zugriff am Mai 14, 2025, [https://adangel.org/2022/02/06/java-screenshot/](https://adangel.org/2022/02/06/java-screenshot/)  
73. xdg-desktop-portal/NEWS.md at main \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/flatpak/xdg-desktop-portal/blob/main/NEWS.md](https://github.com/flatpak/xdg-desktop-portal/blob/main/NEWS.md)  
74. Add API to know whether a certain portal is really available · Issue \#686 · flatpak/xdg-desktop-portal \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/flatpak/xdg-desktop-portal/issues/686](https://github.com/flatpak/xdg-desktop-portal/issues/686)  
75. Bug List \- freedesktop.org Bugzilla, Zugriff am Mai 14, 2025, [https://bugs.freedesktop.org/buglist.cgi?limit=0\&query\_format=advanced\&resolution=FIXED\&order=assigned\_to%2Cshort\_desc%2Cchangeddate%2Cproduct%20DESC%2Ccomponent%2Cresolution%20DESC%2Cbug\_id%20DESC\&query\_based\_on=](https://bugs.freedesktop.org/buglist.cgi?limit=0&query_format=advanced&resolution=FIXED&order=assigned_to,short_desc,changeddate,product+DESC,component,resolution+DESC,bug_id+DESC&query_based_on)  
76. Attachment 145572 Details for Bug 111848 – package log output \- freedesktop.org Bugzilla, Zugriff am Mai 14, 2025, [https://bugs.freedesktop.org/attachment.cgi?id=145572\&action=edit](https://bugs.freedesktop.org/attachment.cgi?id=145572&action=edit)  
77. Screenshot \- XDG Desktop Portal documentation \- Flatpak, Zugriff am Mai 14, 2025, [https://flatpak.github.io/xdg-desktop-portal/docs/doc-org.freedesktop.portal.Screenshot.html](https://flatpak.github.io/xdg-desktop-portal/docs/doc-org.freedesktop.portal.Screenshot.html)  
78. xdg-desktop-portal/data/org.freedesktop.portal.Screenshot.xml at main \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/flatpak/xdg-desktop-portal/blob/master/data/org.freedesktop.portal.Screenshot.xml](https://github.com/flatpak/xdg-desktop-portal/blob/master/data/org.freedesktop.portal.Screenshot.xml)  
79. D-Bus Specification, Zugriff am Mai 14, 2025, [https://dbus.freedesktop.org/doc/dbus-specification.html](https://dbus.freedesktop.org/doc/dbus-specification.html)  
80. waycrate/xdg-desktop-portal-luminous: A xdg-desktop ... \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/waycrate/xdg-desktop-portal-luminous](https://github.com/waycrate/xdg-desktop-portal-luminous)  
81. Zugriff am Januar 1, 1970, [https://github.com/flatpak/xdg-desktop-portal/tree/main/src](https://github.com/flatpak/xdg-desktop-portal/tree/main/src)  
82. Zugriff am Januar 1, 1970, [https://flatpak.github.io/xdg-desktop-portal/portal-docs.html](https://flatpak.github.io/xdg-desktop-portal/portal-docs.html)  
83. zbus \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/](https://docs.rs/zbus/latest/zbus/)  
84. How to set interface dynamically using zbus \- The Rust Programming Language Forum, Zugriff am Mai 14, 2025, [https://users.rust-lang.org/t/how-to-set-interface-dynamically-using-zbus/108691](https://users.rust-lang.org/t/how-to-set-interface-dynamically-using-zbus/108691)  
85. zbus \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/zbus/5.6.0](https://crates.io/crates/zbus/5.6.0)  
86. Writing a client proxy \- zbus: D-Bus for Rust made easy \- GitHub Pages, Zugriff am Mai 14, 2025, [https://dbus2.github.io/zbus/client.html](https://dbus2.github.io/zbus/client.html)  
87. proxy in zbus \- Rust \- openrr.github.io, Zugriff am Mai 14, 2025, [https://openrr.github.io/openrr/zbus/attr.proxy.html](https://openrr.github.io/openrr/zbus/attr.proxy.html)  
88. Event in winit::event \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/winit-gtk/latest/winit/event/enum.Event.html](https://docs.rs/winit-gtk/latest/winit/event/enum.Event.html)  
89. Smithay/calloop-wayland-source \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/Smithay/calloop-wayland-source](https://github.com/Smithay/calloop-wayland-source)  
90. wayland\_client \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/wayland-client/](https://docs.rs/wayland-client/)  
91. smithay::desktop \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/smithay/smithay/desktop/index.html](https://smithay.github.io/smithay/smithay/desktop/index.html)  
92. "Connection" Search \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/?search=Connection](https://docs.rs/zbus/latest/zbus/?search=Connection)  
93. Introduction \- zbus: D-Bus for Rust made easy, Zugriff am Mai 14, 2025, [https://dbus2.github.io/zbus/](https://dbus2.github.io/zbus/)  
94. zbus \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/zbus/3.15.2](https://crates.io/crates/zbus/3.15.2)  
95. zbus \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/zbus](https://crates.io/crates/zbus)  
96. Writing a service interface \- zbus: D-Bus for Rust made easy, Zugriff am Mai 14, 2025, [https://dbus2.github.io/zbus/server.html](https://dbus2.github.io/zbus/server.html)  
97. Some D-Bus concepts \- zbus: D-Bus for Rust made easy, Zugriff am Mai 14, 2025, [https://dbus2.github.io/zbus/concepts.html](https://dbus2.github.io/zbus/concepts.html)  
98. zbus \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/zbus/2.0.0](https://crates.io/crates/zbus/2.0.0)  
99. Builder in zbus::connection \- Rust \- openrr.github.io, Zugriff am Mai 14, 2025, [https://openrr.github.io/openrr/zbus/connection/struct.Builder.html](https://openrr.github.io/openrr/zbus/connection/struct.Builder.html)  
100. Zugriff am Januar 1, 1970, [https://docs.rs/zbus/latest/zbus/struct.ObjectServer.html](https://docs.rs/zbus/latest/zbus/struct.ObjectServer.html)  
101. Zugriff am Januar 1, 1970, [https://docs.rs/zbus/latest/zbus/server/struct.ObjectServer.html](https://docs.rs/zbus/latest/zbus/server/struct.ObjectServer.html)  
102. Zugriff am Januar 1, 1970, [https://dbus2.github.io/zbus/async\_server.html](https://dbus2.github.io/zbus/async_server.html)  
103. Zugriff am Januar 1, 1970, [https://github.com/dbus2/zbus/blob/main/examples/object\_server.rs](https://github.com/dbus2/zbus/blob/main/examples/object_server.rs)  
104. Error in zbus \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/enum.Error.html](https://docs.rs/zbus/latest/zbus/enum.Error.html)
# **NovaDE UI-Schicht: Implementierungsleitfaden – Teil 1: ui::shell::PanelWidget und AppMenuButton**

## **1\. Einleitung**

### **1.1. Zweck des Dokuments**

Dieses Dokument dient als detaillierter Implementierungsleitfaden für ausgewählte Module der UI-Schicht der Nova Desktop Environment (NovaDE). Es spezifiziert die Architektur, das Design, die Datenstrukturen, Schnittstellen und Implementierungsdetails auf einer ultrafeinen Ebene, sodass Entwicklerteams diese Spezifikationen direkt für die Codierung verwenden können, ohne grundlegende Designentscheidungen treffen oder Kernlogiken selbst entwerfen zu müssen. Dieses erste Teildokument fokussiert sich auf die Kernkomponente ui::shell::PanelWidget und dessen Submodul ui::shell::panel\_widget::AppMenuButton.

### **1.2. Zielgruppe**

Dieses Dokument richtet sich an Softwareentwickler und \-architekten, die an der Implementierung der NovaDE UI-Schicht beteiligt sind. Es wird ein Verständnis von Rust, GTK4 und den gtk4-rs Bindings sowie grundlegenden Konzepten der Softwarearchitektur und des UI-Designs vorausgesetzt.

### **1.3. Umfang (Teil 1: ui::shell::PanelWidget und AppMenuButton)**

Dieser erste Teil des Implementierungsleitfadens für die UI-Schicht behandelt die folgenden Module:

* **ui::shell::PanelWidget**: Die Haupt-Panel-Komponente der Desktop-Shell, verantwortlich für die Aufnahme und Anordnung verschiedener Panel-Module.  
* **ui::shell::panel\_widget::AppMenuButton**: Ein spezifisches Panel-Modul innerhalb des PanelWidget, das das globale Anwendungsmenü der aktiven Applikation anzeigt.

Nachfolgende Teildokumente werden weitere Module der UI-Schicht detaillieren.

### **1.4. Technologie-Stack (Verbindlich)**

Die Implementierung der UI-Schicht erfolgt unter strikter Verwendung des folgenden Technologie-Stacks:

* **GUI-Toolkit**: GTK4 1  
* **Rust-Bindings**: gtk4-rs 1  
* **Programmiersprache**: Rust 4  
* **Asynchrone Operationen**: Integration mit Rusts async/await über glib::MainContext::spawn\_local 7  
* **Theming**: Anwendung von CSS-Stilen über gtk::CssProvider, generiert durch domain::theming 9  
* **D-Bus-Kommunikation**: zbus Crate für Interaktionen mit Systemdiensten und anderen Anwendungen 12

### **1.5. Allgemeine UI/UX-Prinzipien (Wiederholung)**

Die Entwicklung der UI-Schicht orientiert sich an den folgenden übergeordneten UI/UX-Prinzipien, die eine visionstreue Umsetzung gewährleisten:

* **Konsistenz**: Einheitliches Erscheinungsbild und Verhalten über alle UI-Komponenten hinweg.  
* **Feedback**: Klares visuelles (und ggf. haptisches) Feedback auf Benutzeraktionen.  
* **Effizienz**: Minimierung der notwendigen Schritte zur Erledigung häufiger Aufgaben.  
* **Zugänglichkeit (Accessibility)**: Einhaltung der a11y-Standards (ATK/AT-SPI).23  
* **Performance**: Flüssige Animationen, schnelle Reaktionszeiten und geringer Ressourcenverbrauch.24  
* **Anpassbarkeit**: Ermöglichung benutzerdefinierter Konfigurationen von Layouts, Widgets und Verhalten.

## **2\. Modul: ui::shell::PanelWidget (Haupt-Panel-Implementierung)**

### **2.1.1. Übersicht und Verantwortlichkeiten**

Das PanelWidget ist die zentrale Komponente der ui::shell, die als primäre(s) Kontroll- und Systemleiste(n) der NovaDE dient. Es ist verantwortlich für:

* Die Bereitstellung einer oder mehrerer horizontaler Leisten am Bildschirmrand (oben oder unten, konfigurierbar).  
* Die Aufnahme, Anordnung und Verwaltung verschiedener, modularer Panel-Elemente (Submodule wie AppMenuButton, ClockDateTimeWidget, etc.).  
* Die Implementierung grundlegender Panel-Eigenschaften wie Höhe, Transparenz und eines visuellen "Leuchtakzent"-Effekts.  
* Die Interaktion mit dem gtk4-layer-shell-Protokoll, um sich korrekt in Wayland-Compositors zu integrieren, die dieses Protokoll unterstützen (z.B. wlroots-basierte wie Sway, Mir, KDE Plasma).26  
* Das dynamische Laden und Anwenden von Theming-Informationen, insbesondere für den "Leuchtakzent" und Hintergrundstile.

### **2.1.2. Visuelles Design und Theming**

* **Positionierung**: Konfigurierbar am oberen oder unteren Bildschirmrand.  
* **Höhe**: Konfigurierbare Höhe, z.B. zwischen 24px und 128px.  
* **Transparenz**: Optionale Transparenz des Panel-Hintergrunds. Dies wird durch Setzen der Opazität des Hauptfensters und/oder durch Verwendung von RGBA-Farben im CSS und im benutzerdefinierten Zeichencode erreicht. Für Wayland-Compositors, die transparente Oberflächen unterstützen, muss das zugrundeliegende GdkSurface entsprechend konfiguriert werden. Die gtk4-layer-shell kann hierbei relevant sein, um sicherzustellen, dass der Compositor die Transparenz korrekt handhabt.26  
* **"Leuchtakzent"-Effekt**: Ein subtiler Leuchteffekt entlang einer Kante des Panels (z.B. die dem Bildschirmzentrum zugewandte Kante), dessen Farbe und Intensität durch das Theming-System (domain::theming) gesteuert wird. Die Implementierung erfolgt entweder durch CSS (box-shadow mit entsprechenden Offsets und Blur-Radien 36) oder durch benutzerdefiniertes Zeichnen mit Cairo auf einem gtk::DrawingArea.37  
* **CSS-Styling**:  
  * **CSS-Knoten**: Das PanelWidget selbst (als GtkApplicationWindow) hat den CSS-Knoten window. Wenn es einen internen Hauptcontainer (z.B. GtkBox) verwendet, hat dieser den Knoten box.42 Spezifische CSS-Klassen werden zugewiesen, um das Styling zu erleichtern.  
  * **CSS-Klassen**:  
    * .nova-panel: Allgemeine Klasse für das Panel.  
    * .panel-top, .panel-bottom: Je nach Positionierung.  
    * .transparent-panel: Wenn Transparenz aktiviert ist.  
  * Die Anwendung von CSS erfolgt über einen globalen gtk::CssProvider, der durch ui::theming\_gtk verwaltet wird.10 Das Panel reagiert auf ThemeChangedEvents, um dynamische Stiländerungen zu übernehmen.

### **2.1.3. Datenstrukturen, Eigenschaften und Zustand**

Das PanelWidget wird als benutzerdefiniertes GObject-Widget implementiert, das von gtk::ApplicationWindow erbt, um die Integration mit gtk4-layer-shell zu ermöglichen.27

* GObject-Definition (PanelWidget):  
  Die Definition erfolgt in zwei Hauptdateien: mod.rs für die öffentliche API und imp.rs für die private GObject-Implementierung.  
  *Auszug aus src/ui/shell/panel\_widget/mod.rs (vereinfacht):*  
  Rust  
  use gtk::glib;  
  use gtk::subclass::prelude::\*;  
  use std::cell::{Cell, RefCell};

  mod imp;

  glib::wrapper\! {  
      pub struct PanelWidget(ObjectSubclass\<imp::PanelWidget\>)  
          @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,  
          @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;  
  }

  impl PanelWidget {  
      pub fn new(app: \&gtk::Application) \-\> Self {  
          glib::Object::builder::\<Self\>()  
             .property("application", app)  
             .build()  
      }

      // Öffentliche Methoden hier definieren, z.B.:  
      pub fn add\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>, position: imp::ModulePosition, order: i32) {  
          self.imp().add\_module(module, position, order);  
      }

      pub fn remove\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>) {  
          self.imp().remove\_module(module);  
      }  
  }

  *Auszug aus src/ui/shell/panel\_widget/imp.rs (vereinfacht):*  
  Rust  
  use gtk::glib;  
  use gtk::subclass::prelude::\*;  
  use gtk::{CompositeTemplate, Align};  
  use std::cell::{Cell, RefCell};  
  use std::collections::HashMap;  
  use once\_cell::sync::Lazy; // \[123\]

  // Enum für PanelPosition  
  \#  
  \#  
  pub enum PanelPosition {  
      \#\[default\]  
      Top,  
      Bottom,  
  }

  \#  
  \#  
  pub enum ModulePosition {  
      Start,  
      Center,  
      End,  
  }

  static PANEL\_PROPERTIES: Lazy\<Vec\<glib::ParamSpec\>\> \= Lazy::new(|| {  
      vec\!  
  });

  // Hier könnten benutzerdefinierte Signale definiert werden, falls benötigt.  
  // static PANEL\_SIGNALS: Lazy\<HashMap\<String, glib::subclass::Signal\>\> \= Lazy::new(|| HashMap::new());

  \#  
  \#\[template(resource \= "/org/nova\_de/ui/shell/panel\_widget.ui")\] // Pfad zur UI-Datei  
  pub struct PanelWidget {  
      \#\[template\_child\]  
      pub(super) main\_box: TemplateChild\<gtk::Box\>,  
      \#\[template\_child\]  
      pub(super) start\_box: TemplateChild\<gtk::Box\>,  
      \#\[template\_child\]  
      pub(super) center\_box: TemplateChild\<gtk::Box\>,  
      \#\[template\_child\]  
      pub(super) end\_box: TemplateChild\<gtk::Box\>,

      // Für benutzerdefiniertes Zeichnen, falls CSS nicht ausreicht  
      drawing\_area: RefCell\<Option\<gtk::DrawingArea\>\>,

      \#\[property(get, set, explicit\_notify)\]  
      position: RefCell\<PanelPosition\>,  
      \#\[property(get, set, explicit\_notify)\]  
      panel\_height: Cell\<i32\>,  
      \#\[property(get, set, explicit\_notify)\]  
      transparency\_enabled: Cell\<bool\>,  
      \#\[property(get, set, explicit\_notify)\]  
      leuchtakzent\_color: RefCell\<Option\<gdk::RGBA\>\>,  
      \#\[property(get, set, explicit\_notify)\]  
      leuchtakzent\_intensity: Cell\<f64\>,

      // Interne Verwaltung der Module  
      modules\_start: RefCell\<Vec\<gtk::Widget\>\>,  
      modules\_center: RefCell\<Vec\<gtk::Widget\>\>,  
      modules\_end: RefCell\<Vec\<gtk::Widget\>\>,  
  }

  \#\[glib::object\_subclass\]  
  impl ObjectSubclass for PanelWidget {  
      const NAME: &'static str \= "NovaDEPanelWidget";  
      type Type \= super::PanelWidget;  
      type ParentType \= gtk::ApplicationWindow;

      fn class\_init(klass: \&mut Self::Class) {  
          klass.bind\_template();  
          klass.install\_properties(\&PANEL\_PROPERTIES);  
          // klass.install\_signals(\&PANEL\_SIGNALS, false); // Falls Signale vorhanden

          // CSS-Name für das Widget setzen, falls nicht über UI-Datei  
          klass.set\_css\_name("panelwidget");  
      }

      fn instance\_init(obj: \&glib::subclass::InitializingObject\<Self\>) {  
          obj.init\_template();  
      }  
  }

  impl ObjectImpl for PanelWidget {  
      fn constructed(\&self) {  
          self.parent\_constructed();  
          let obj \= self.obj();

          // Standardwerte setzen, falls nicht durch Properties initialisiert  
          if self.position.borrow().eq(\&PanelPosition::default()) {  
               self.position.replace(PanelPosition::Top);  
          }  
          if self.panel\_height.get() \== 0 { // GObject Int default ist 0  
              self.panel\_height.set(36); // Expliziter Standardwert  
          }  
           if self.leuchtakzent\_intensity.get() \== 0.0 { // GObject Double default ist 0.0  
              self.leuchtakzent\_intensity.set(0.5);  
          }

          // Layer Shell initialisieren  
          obj.setup\_layer\_shell();  
          obj.update\_layout(); // Erstes Layout anwenden

          // Eventuell DrawingArea initialisieren und verbinden  
          // let drawing\_area \= gtk::DrawingArea::new();  
          // drawing\_area.set\_content\_width(obj.width\_request()); // Beispiel  
          // drawing\_area.set\_content\_height(self.panel\_height.get());  
          // self.main\_box.prepend(\&drawing\_area); // Oder als Hintergrund  
          // self.drawing\_area.replace(Some(drawing\_area));  
          // self.obj().connect\_draw\_signal();  
      }

      fn properties() \-\> &'static {  
          PANEL\_PROPERTIES.as\_ref()  
      }

      fn set\_property(\&self, \_id: usize, value: \&glib::Value, pspec: \&glib::ParamSpec) {  
          match pspec.name() {  
              "position" \=\> {  
                  let position: PanelPosition \= value.get().expect("Value must be PanelPosition");  
                  self.position.replace(position);  
                  self.obj().setup\_layer\_shell(); // Layer Shell neu konfigurieren bei Positionsänderung  
                  self.obj().notify\_position();   
              }  
              "panel-height" \=\> {  
                  let height: i32 \= value.get().expect("Value must be i32");  
                  self.panel\_height.set(height);  
                  self.obj().set\_default\_height(height); // Fensterhöhe anpassen  
                  self.main\_box.set\_height\_request(height);  
                  // Ggf. DrawingArea Höhe anpassen  
                  // if let Some(da) \= self.drawing\_area.borrow().as\_ref() {  
                  //    da.set\_content\_height(height);  
                  // }  
                  self.obj().queue\_draw(); // Neuzeichnen anfordern  
                  self.obj().notify\_panel\_height();  
              }  
              "transparency-enabled" \=\> {  
                  let enabled: bool \= value.get().expect("Value must be bool");  
                  self.transparency\_enabled.set(enabled);  
                  self.obj().update\_transparency();  
                  self.obj().notify\_transparency\_enabled();  
              }  
              "leuchtakzent-color" \=\> {  
                  let color: Option\<gdk::RGBA\> \= value.get().expect("Value must be Option\<gdk::RGBA\>");  
                  self.leuchtakzent\_color.replace(color);  
                  self.obj().queue\_draw();  
                  self.obj().notify\_leuchtakzent\_color();  
              }  
              "leuchtakzent-intensity" \=\> {  
                  let intensity: f64 \= value.get().expect("Value must be f64");  
                  self.leuchtakzent\_intensity.set(intensity);  
                  self.obj().queue\_draw();  
                  self.obj().notify\_leuchtakzent\_intensity();  
              }  
              \_ \=\> unimplemented\!(),  
          }  
      }

      fn property(\&self, \_id: usize, pspec: \&glib::ParamSpec) \-\> glib::Value {  
          match pspec.name() {  
              "position" \=\> self.position.borrow().to\_value(),  
              "panel-height" \=\> self.panel\_height.get().to\_value(),  
              "transparency-enabled" \=\> self.transparency\_enabled.get().to\_value(),  
              "leuchtakzent-color" \=\> self.leuchtakzent\_color.borrow().to\_value(),  
              "leuchtakzent-intensity" \=\> self.leuchtakzent\_intensity.get().to\_value(),  
              \_ \=\> unimplemented\!(),  
          }  
      }  
  }  
  impl WidgetImpl for PanelWidget {  
      fn map(\&self) {  
          self.parent\_map();  
          // Sicherstellen, dass Layer Shell korrekt initialisiert ist, bevor das Fenster angezeigt wird  
          self.obj().setup\_layer\_shell();  
      }  
       fn size\_allocate(\&self, width: i32, height: i32, baseline: i32) {  
          self.parent\_size\_allocate(width, height, baseline);  
          // Ggf. Layout der internen Boxen hier anpassen oder DrawingArea Größe  
      }  
  }  
  impl WindowImpl for PanelWidget {  
      // Fenster-spezifische Implementierungen, z.B. Schließen-Verhalten  
  }  
  impl ApplicationWindowImpl for PanelWidget {}

  // Implementierung der öffentlichen und privaten Methoden für PanelWidget  
  impl super::PanelWidget {  
      fn setup\_layer\_shell(\&self) {  
          let imp \= self.imp();  
          gtk\_layer\_shell::init\_for\_window(self);  
          gtk\_layer\_shell::set\_layer(self, gtk\_layer\_shell::Layer::Top);  
          gtk\_layer\_shell::set\_keyboard\_mode(self, gtk\_layer\_shell::KeyboardMode::None); // Panels benötigen i.d.R. keinen direkten Fokus  
          gtk\_layer\_shell::auto\_exclusive\_zone\_enable(self); // Platz reservieren  
          gtk\_layer\_shell::set\_namespace(self, "NovaDEPanel");

          let position \= \*imp.position.borrow();  
          match position {  
              PanelPosition::Top \=\> {  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Top, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Left, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Right, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Bottom, false);  
              }  
              PanelPosition::Bottom \=\> {  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Bottom, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Left, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Right, true);  
                  gtk\_layer\_shell::set\_anchor(self, gtk\_layer\_shell::Edge::Top, false);  
              }  
          }  
          self.set\_default\_height(imp.panel\_height.get());  
          // Margins könnten hier auch gesetzt werden, falls gewünscht  
          // gtk\_layer\_shell::set\_margin(self, gtk\_layer\_shell::Edge::Top, 5);  
      }

      fn update\_layout(\&self) {  
          let imp \= self.imp();  
          // Entferne alle Kinder aus start\_box, center\_box, end\_box  
          while let Some(child) \= imp.start\_box.first\_child() {  
              imp.start\_box.remove(\&child);  
          }  
          while let Some(child) \= imp.center\_box.first\_child() {  
              imp.center\_box.remove(\&child);  
          }  
          while let Some(child) \= imp.end\_box.first\_child() {  
              imp.end\_box.remove(\&child);  
          }

          // Füge Module entsprechend ihrer Reihenfolge und Position hinzu  
          // Diese Logik muss verfeinert werden, um die \`order\` Eigenschaft zu berücksichtigen  
          for widget in imp.modules\_start.borrow().iter() {  
              imp.start\_box.append(widget);  
          }  
          for widget in imp.modules\_center.borrow().iter() {  
              imp.center\_box.append(widget);  
          }  
          for widget in imp.modules\_end.borrow().iter() {  
              imp.end\_box.append(widget);  
          }  
      }

      fn update\_transparency(\&self) {  
          let imp \= self.imp();  
          let visual \= if imp.transparency\_enabled.get() {  
              self.display().rgba\_visual()  
          } else {  
              None // Oder Standard-Visual  
          };  
          self.set\_visual(visual.as\_ref()); // Benötigt GdkDisplay

          // Für echte Transparenz unter Wayland muss der Compositor dies unterstützen  
          // und das Fenster muss ggf. mit einem Alpha-Kanal gezeichnet werden.  
          // CSS kann auch für Hintergrundtransparenz verwendet werden.  
          self.queue\_draw();  
      }

      // Beispiel für das Verbinden des Draw-Signals, falls benutzerdefiniertes Zeichnen  
      // fn connect\_draw\_signal(\&self) {  
      //     if let Some(da) \= self.imp().drawing\_area.borrow().as\_ref() {  
      //        da.set\_draw\_func(glib::clone\!(@weak self as panel \=\> move |\_, cr, width, height| {  
      //            panel.imp().draw\_background\_and\_accent(cr, width, height);  
      //        }));  
      //    } else { // Wenn das PanelWindow selbst zeichnet (komplexer wegen Layer Shell)  
      //        self.connect\_realize(|widget| { // Realize statt draw für Fensterhintergrund  
      //            widget.set\_decorated(false); // Wichtig für custom drawing  
      //            if widget.imp().transparency\_enabled.get() {  
      //                 if let Some(surface) \= widget.surface() {  
      //                    surface.set\_opaque\_region(None); // Versuch für Transparenz  
      //                 }  
      //            }  
      //        });  
      //        // Das direkte Zeichnen auf einem GtkApplicationWindow ist nicht trivial.  
      //        // Besser ist ein Kind-Widget (GtkDrawingArea) zu verwenden.  
      //    }  
      // }  
  }

  // Private Implementierungsmethoden  
  impl PanelWidget {  
      fn add\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>, position: ModulePosition, \_order: i32) {  
          // TODO: Ordnung berücksichtigen  
          match position {  
              ModulePosition::Start \=\> {  
                  self.imp().modules\_start.borrow\_mut().push(module.clone().upcast());  
                  self.imp().start\_box.append(module);  
              }  
              ModulePosition::Center \=\> {  
                  self.imp().modules\_center.borrow\_mut().push(module.clone().upcast());  
                  self.imp().center\_box.append(module);  
              }  
              ModulePosition::End \=\> {  
                  self.imp().modules\_end.borrow\_mut().push(module.clone().upcast());  
                  self.imp().end\_box.append(module);  
              }  
          }  
          // Signal 'module-layout-changed' emittieren  
      }

      fn remove\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>) {  
          let widget\_ptr \= module.as\_ref().to\_glib\_none().0;  
          if self.imp().modules\_start.borrow\_mut().retain(|m| m.to\_glib\_none().0\!= widget\_ptr).len() \< self.imp().modules\_start.borrow().len() {  
               self.imp().start\_box.remove(module);  
          } else if self.imp().modules\_center.borrow\_mut().retain(|m| m.to\_glib\_none().0\!= widget\_ptr).len() \< self.imp().modules\_center.borrow().len() {  
               self.imp().center\_box.remove(module);  
          } else if self.imp().modules\_end.borrow\_mut().retain(|m| m.to\_glib\_none().0\!= widget\_ptr).len() \< self.imp().modules\_end.borrow().len() {  
               self.imp().end\_box.remove(module);  
          }  
          // Signal 'module-layout-changed' emittieren  
      }  
  }

* Eigenschaften (Properties):  
  Die GObject-Eigenschaften ermöglichen die Konfiguration und Zustandsabfrage des PanelWidget. Sie werden über das glib::Properties-Makro und die install\_properties-Methode im ObjectSubclass-Trait deklariert.47  
  **Tabelle: PanelWidget Eigenschaften**

| Eigenschaftsname | Typ | Zugriff | Standardwert | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| position | PanelPosition | Lesen/Schreiben | Top | Bildschirmkante, an der das Panel verankert ist (Oben, Unten). |
| panel-height | i32 | Lesen/Schreiben | 36 | Höhe des Panels in Pixeln (Min: 24, Max: 128). |
| transparency-enabled | bool | Lesen/Schreiben | false | Gibt an, ob Transparenzeffekte für das Panel aktiv sind. |
| leuchtakzent-color | Option\<gdk::RGBA\> | Lesen/Schreiben | None | Farbe des Leuchtakzents. Wird typischerweise vom Theming-System aktualisiert. |
| leuchtakzent-intensity | f64 | Lesen/Schreiben | 0.5 | Intensität/Opazität des Leuchtakzents (Bereich: 0.0 bis 1.0). |

\*Bedeutung der Tabelle:\* Diese Tabelle bietet eine klare, strukturierte Definition der konfigurierbaren Aspekte des Panels. Sie ist essentiell für Entwickler, um die API des Widgets zu verstehen und es in Einstellungssysteme zu integrieren. Sie adressiert direkt die Anforderung der Anfrage nach der Definition von Eigenschaften mit exakten Typen und Initialwerten.

* **Interner Zustand:**  
  * modules\_start: RefCell\<Vec\<gtk::Widget\>\>: Speichert Referenzen auf die Panel-Module im Startbereich.  
  * modules\_center: RefCell\<Vec\<gtk::Widget\>\>: Speichert Referenzen auf die Panel-Module im Mittelbereich.  
  * modules\_end: RefCell\<Vec\<gtk::Widget\>\>: Speichert Referenzen auf die Panel-Module im Endbereich.  
  * Die Verwendung von RefCell ist notwendig für die innere Veränderlichkeit innerhalb des GObject-Systems, da GObject-Methoden typischerweise \&self erhalten.51

### **2.1.4. GTK-Widget-Implementierungsstrategie**

* **Basis-Widget**: Das PanelWidget erbt von gtk::ApplicationWindow.43 Diese Wahl ist entscheidend für die Integration mit gtk4-layer-shell, da dessen Funktionen wie init\_for\_window, set\_layer, set\_anchor und set\_margin auf einem gtk::Window operieren.26  
  * Die Initialisierung der Layer-Shell-Eigenschaften (gtk\_layer\_shell::init\_for\_window(self), etc.) muss erfolgen, bevor das Fenster zum ersten Mal realisiert (mapped) wird.29  
  * gtk\_layer\_shell::set\_layer(self.as\_ref(), gtk\_layer\_shell::Layer::Top) positioniert das Panel über normalen Anwendungsfenstern.  
  * gtk\_layer\_shell::set\_keyboard\_mode(self.as\_ref(), gtk\_layer\_shell::KeyboardMode::None) ist typisch für Panels, da sie selten direkten Tastaturfokus benötigen; dieser wird von den einzelnen Modulen gehandhabt.  
  * gtk\_layer\_shell::auto\_exclusive\_zone\_enable(self.as\_ref()) sorgt dafür, dass das Panel Platz auf dem Bildschirm reserviert und andere Fenster nicht verdeckt.  
* **Internes Layout**:  
  * Das PanelWidget verwendet eine panel\_widget.ui-Datei (Composite Template 55) oder definiert sein internes Layout programmatisch.  
  * Eine Haupt-gtk::Box (main\_box) mit horizontaler Orientierung dient als primärer Container.  
  * Innerhalb dieser main\_box befinden sich drei weitere gtk::Box-Widgets: start\_box, center\_box, und end\_box.42 Diese dienen zur Aufnahme der jeweiligen Panel-Module. start\_box und end\_box haben eine feste Größe basierend auf ihrem Inhalt, während center\_box den verbleibenden Raum einnimmt und sich horizontal ausdehnt (hexpand \= true).  
  * Alternativ kann gtk::CenterBox verwendet werden, wenn die UI-Definition dies unterstützt und die Anforderungen an die Ausrichtung der Kindelemente erfüllt.63  
* **Benutzerdefiniertes Zeichnen für "Leuchtakzent" und Hintergrund**:  
  * Falls CSS (box-shadow 36) für den "Leuchtakzent" oder komplexe Hintergründe nicht ausreicht oder die gewünschte Performance nicht liefert, wird ein gtk::DrawingArea eingesetzt.34  
  * Diese DrawingArea würde als unterste Ebene im PanelWidget platziert, oder das PanelWidget (als ApplicationWindow) muss seine Hintergrundzeichnung sorgfältig handhaben. Dies kann erreicht werden, indem das Fenster selbst transparent gemacht wird (widget.set\_visual(Some(\&display.rgba\_visual())) 34) und auf einer Kind-DrawingArea gezeichnet wird.  
  * Das draw-Signal der DrawingArea wird mit cairo-rs verwendet, um den Akzent und den Hintergrund zu zeichnen. Die Transparenz wird durch cairo::Context::set\_source\_rgba und die opacity-Eigenschaft von GtkWidget gesteuert.68

### **2.1.5. Methoden und Funktionssignaturen**

Die Methoden des PanelWidget definieren seine öffentliche API und interne Logik.

* **Öffentliche API (Auszug)**:  
  * pub fn add\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>, position: ModulePosition, order: i32) noexcept;  
    * Fügt ein gtk::Widget-basiertes Modul dem Panel hinzu.  
    * position: Enum (Start, Center, End), das den Bereich im Panel angibt.  
    * order: Ein i32-Wert, der die Reihenfolge innerhalb des Bereichs bestimmt (niedrigere Werte zuerst).  
  * pub fn remove\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>) noexcept;  
    * Entfernt ein zuvor hinzugefügtes Modul aus dem Panel.  
* **Interne Methoden (Auszug)**:  
  * fn setup\_layer\_shell(\&self) noexcept;  
    * Initialisiert und konfiguriert die gtk4-layer-shell-Eigenschaften basierend auf den aktuellen Panel-Einstellungen (Position, Höhe).  
  * fn update\_layout(\&self) noexcept;  
    * Ordnet die Module innerhalb der start\_box, center\_box und end\_box neu an, basierend auf ihrer order-Eigenschaft und aktuellen Konfiguration.  
  * fn draw\_background\_and\_accent(\&self, cr: \&cairo::Context, width: i32, height: i32) noexcept;  
    * Wird von der draw-Signal-Callback-Funktion der DrawingArea aufgerufen, um den benutzerdefinierten Hintergrund und den Leuchtakzent zu zeichnen. Verwendet leuchtakzent-color und leuchtakzent-intensity.  
  * fn update\_transparency(\&self) noexcept;  
    * Passt die Visuals des Fensters an, um Transparenz zu (de-)aktivieren.

**Tabelle: PanelWidget Methoden (Auswahl)**

| Signatur | Beschreibung | const | noexcept |
| :---- | :---- | :---- | :---- |
| pub fn new(app: \&gtk::Application) \-\> Self | Konstruktor, erstellt eine neue Instanz des PanelWidget. | Nein | Nein |
| pub fn add\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>, position: ModulePosition, order: i32) | Fügt ein Widget-Modul einem bestimmten Bereich (Start, Center, End) des Panels hinzu, unter Berücksichtigung der order. | Nein | Ja |
| pub fn remove\_module(\&self, module: \&impl glib::IsA\<gtk::Widget\>) | Entfernt das angegebene Widget-Modul aus dem Panel. | Nein | Ja |
| fn setup\_layer\_shell(\&self) | Interne Methode zur Konfiguration der gtk4-layer-shell-Parameter (Anker, Layer, Exklusivzone etc.) basierend auf den Panel-Eigenschaften wie position und panel-height. | Nein | Ja |
| fn update\_layout(\&self) | Interne Methode, die das Layout der Module in den Start-, Mittel- und Endbereichen aktualisiert, z.B. nach Hinzufügen/Entfernen eines Moduls oder einer Konfigurationsänderung. | Nein | Ja |

\*Bedeutung der Tabelle:\* Diese Tabelle ist entscheidend für Entwickler, die das \`PanelWidget\` verwenden oder erweitern, da sie einen klaren API-Vertrag bereitstellt und die Kernfunktionalitäten dokumentiert. Sie erfüllt die Anforderung der Anfrage nach exakten Methodensignaturen.

### **2.1.6. Signale**

Signale ermöglichen die Kommunikation von Zustandsänderungen oder Ereignissen des PanelWidget.

* **Benutzerdefinierte Signale**:  
  * module-layout-changed:  
    * Parameter: Keine.  
    * Emission: Wird emittiert, nachdem Module hinzugefügt, entfernt oder neu angeordnet wurden.  
    * Zweck: Ermöglicht anderen UI-Komponenten oder Logikmodulen, auf Änderungen im Panel-Layout zu reagieren.  
* **Verbundene Signale**:  
  * Lauscht auf ThemeChangedEvent von domain::theming::ThemingEngine:  
    * Handler-Aktion: Aktualisiert die Eigenschaft leuchtakzent-color und andere themenabhängige visuelle Aspekte. Fordert ein Neuzeichnen des Panels an (self.queue\_draw()).  
  * Verbindet sich mit notify::gtk-theme-name und notify::gtk-application-prefer-dark-theme von gtk::Settings::default() 10:  
    * Handler-Aktion: Lädt bei Bedarf Panel-spezifisches CSS neu oder passt Stile an, um Änderungen im System-Theme oder Dark-Mode-Präferenzen Rechnung zu tragen.

**Tabelle: PanelWidget emittierte Signale**

| Signalname | Parameter | Beschreibung |
| :---- | :---- | :---- |
| module-layout-changed | Keine | Wird emittiert, wenn sich die Anordnung oder der Satz der Module im Panel ändert. |

\*\*Tabelle: \`PanelWidget\` verbundene Signale\*\*

| Quelle | Signal | Handler-Aktion |
| :---- | :---- | :---- |
| domain::theming::ThemingEngine | ThemeChangedEvent | Aktualisiert leuchtakzent-color, fordert Neuzeichnen an. |
| gtk::Settings::default() | notify::gtk-theme-name | Lädt bei Bedarf panel-spezifisches CSS neu oder passt Stile an. |
| gtk::Settings::default() | notify::gtk-application-prefer-dark-theme | Passt Stile für Dark Mode an, lädt ggf. spezifisches CSS. |

\*Bedeutung der Tabellen:\* Diese Tabellen verdeutlichen die ereignisgesteuerten Interaktionen des \`PanelWidget\`. Dies ist entscheidend für das Verständnis seines dynamischen Verhaltens und für das Debugging.

### **2.1.7. Ereignisbehandlung**

* Das PanelWidget behandelt primär interne Layout-Aktualisierungen, die durch Eigenschaftsänderungen oder das Hinzufügen/Entfernen von Modulen ausgelöst werden.  
* Mausereignisse (z.B. enter-notify-event, leave-notify-event für Tooltips auf dem Panel selbst, falls vorhanden) werden über gtk::EventControllerMotion gehandhabt.70 Das Panel selbst wird jedoch in der Regel keinen komplexen Mausinteraktionen ausgesetzt sein; diese werden von den einzelnen Modulen übernommen.  
* Tastaturereignisse werden nicht direkt vom PanelWidget verarbeitet. Der Tastaturfokus wird von den einzelnen, fokussierbaren Panel-Modulen verwaltet.

### **2.1.8. Interaktionen**

* **domain::global\_settings\_and\_state\_management**:  
  * Liest die Panel-Konfiguration (Position, Höhe, Transparenzoptionen, Liste und Reihenfolge der Module) beim Start.  
  * Beobachtet Änderungen an diesen Einstellungen (z.B. über gio::Settings 21 oder ein anwendungsspezifisches Event-System), um das Panel dynamisch zu aktualisieren. Änderungen an Eigenschaften wie position oder panel-height führen zu Aufrufen von setup\_layer\_shell und update\_layout.  
* **system::compositor**:  
  * Die Interaktion erfolgt indirekt über die gtk4-layer-shell-Bibliothek.26 Das PanelWidget deklariert sich als Layer Surface (z.B. Layer::Top), setzt Anker und Margins, um seine Position und Größe relativ zum Output zu definieren.  
* **domain::theming::ThemingEngine**:  
  * Abonniert das ThemeChangedEvent, um Design-Tokens (insbesondere für leuchtakzent-color und Hintergrund) zu erhalten und anzuwenden. Dies löst ein Neuzeichnen des Panels aus.

### **2.1.9. Ausnahmebehandlung**

Zur robusten Fehlerbehandlung wird ein spezifischer Fehlertyp für das PanelWidget definiert.

* **enum PanelWidgetError** (definiert mit thiserror 72):  
  * LayerShellInitializationFailed(String): Wird zurückgegeben oder geloggt, wenn die Initialisierung mit gtk4-layer-shell fehlschlägt (z.B. wenn der Compositor das Protokoll nicht unterstützt).  
  * SettingsReadError(String): Wenn die Panel-Konfiguration nicht gelesen werden kann.  
  * InvalidModulePosition(String): Wenn versucht wird, ein Modul an einer ungültigen Position hinzuzufügen.  
* Fehler werden über das tracing-Crate geloggt 73, um Diagnose und Debugging zu erleichtern. Kritische Fehler, die die Funktionalität des Panels verhindern (z.B. LayerShellInitializationFailed), können dazu führen, dass das Panel nicht angezeigt wird, mit einer entsprechenden Log-Meldung.

### **2.1.10. Auflösung "Untersuchungsbedarf"**

* **Best Practices für gtk4-layer-shell-Integration**:  
  * Die Initialisierung der Layer-Shell-Eigenschaften (gtk\_layer\_shell::init\_for\_window, set\_layer, set\_anchor, set\_margin, auto\_exclusive\_zone\_enable) muss erfolgen, *bevor* das Panel-Fenster zum ersten Mal realisiert/gemappt wird. Dies geschieht typischerweise im constructed-Handler oder kurz vor dem ersten present()-Aufruf.26  
  * Der Tastaturinteraktivitätsmodus sollte sorgfältig gewählt werden. Für ein typisches Panel ist gtk\_layer\_shell::KeyboardMode::None oft angemessen, da die Panel-Module selbst den Fokus handhaben. KeyboardMode::OnDemand könnte relevant sein, wenn das Panel selbst oder bestimmte nicht-interaktive Bereiche des Panels temporär Fokus benötigen könnten.29  
  * Ein eindeutiger Namespace (z.B. "novade-panel") sollte mittels gtk\_layer\_shell::set\_namespace gesetzt werden. Dies hilft dem Compositor, verschiedene Layer-Shell-Clients zu identifizieren.29  
  * Für Multi-Monitor-Setups: Das Panel kann über gtk\_layer\_shell::set\_monitor einem spezifischen Monitor zugewiesen werden. Um Panels auf allen Monitoren darzustellen, müsste für jeden Monitor eine eigene PanelWidget-Instanz erstellt und konfiguriert werden. Die Liste der Monitore ist über gdk::Display::monitors() zugänglich.74 Änderungen in der Monitorkonfiguration (An-/Abstecken) können über Signale von gdk::Display (monitor-added, monitor-removed) überwacht werden.  
* **Implementierung des konfigurierbaren "Leuchtakzents" mit Cairo/GSK**:  
  * Das PanelWidget (oder eine dedizierte Kind-gtk::DrawingArea, die unter den Modul-Containern liegt) verbindet sich mit dem draw-Signal.  
  * Im Draw-Handler (fn draw\_background\_and\_accent):  
    1. Die aktuellen Werte der Eigenschaften leuchtakzent-color (ein gdk::RGBA) und leuchtakzent-intensity (ein f64 zwischen 0.0 und 1.0) werden abgerufen.  
    2. Der cairo::Context (cr) wird verwendet.  
    3. **Hintergrund zeichnen**: Zuerst wird der Panel-Hintergrund gezeichnet. Wenn Transparenz (transparency-enabled) aktiv ist, wird cr.set\_source\_rgba() mit einem Alpha-Wert \< 1.0 verwendet. Ansonsten eine deckende Farbe gemäß Theme. Abgerundete Ecken, falls spezifiziert, werden hier berücksichtigt (z.B. mit arc\_to und line\_to Pfaden).  
    4. **Leuchtakzent-Pfad definieren**: Ein Pfad wird für den Leuchteffekt erstellt. Dies könnte eine Linie oder ein schmales Rechteck entlang der Kante des Panels sein, die dem Bildschirmzentrum zugewandt ist. Die Position hängt von der position-Eigenschaft des Panels ab (oben oder unten).  
    5. **Leuchtakzent zeichnen**:  
       * **Farbe und Intensität**: cr.set\_source\_rgba() wird mit der leuchtakzent-color und einer durch leuchtakzent-intensity modulierten Alpha-Komponente aufgerufen.  
       * **Weicher Effekt**: Um einen weichen "Glow"-Effekt zu erzielen, können verschiedene Cairo-Techniken verwendet werden:  
         * **Gradienten**: Ein cairo::LinearGradient kann erstellt werden, der von der Akzentfarbe zu einer transparenten Version derselben Farbe oder zur Hintergrundfarbe übergeht. Der Gradient wird so ausgerichtet, dass er senkrecht zur Panelkante verläuft und nach außen hin ausblendet.41  
         * **Mehrfaches Zeichnen mit Unschärfe (simuliert)**: Da Cairo keine direkte Gausssche Unschärfe für Pfade bietet, kann ein ähnlicher Effekt durch mehrfaches Zeichnen des Akzentpfades mit leicht variierenden Offsets, Größen und abnehmender Deckkraft erzielt werden. Dies ist rechenintensiv und sollte mit Bedacht eingesetzt werden.  
         * **Schatten-API (falls anwendbar)**: Obwohl Cairo keine direkte box-shadow-Entsprechung für Pfade hat, könnte man einen Schatten simulieren, indem man eine versetzte, gefärbte und leicht transparente Version des Panelrands zeichnet und darüber den eigentlichen Panelinhalt.  
       * Die gezeichneten Elemente müssen die panel-height und die Gesamtbreite des Panels berücksichtigen.  
    6. Die GSK-Rendering-Pipeline von GTK4 wird diese Cairo-Operationen effizient auf die GPU übertragen.64 Es ist wichtig, queue\_draw() nur dann aufzurufen, wenn sich visuelle Aspekte tatsächlich ändern, um unnötiges Neuzeichnen zu vermeiden.  
  * Die Transparenz des Panel-Fensters selbst wird über gtk\_widget\_set\_opacity() 68 und die korrekte Konfiguration des GDK-Visuals für RGBA-Unterstützung gehandhabt, falls der Compositor dies erfordert und unterstützt.34

### **2.1.11. Dateistruktur**

Die Implementierung des PanelWidget wird in folgendem Verzeichnisbaum organisiert:

src/  
└── ui/  
    └── shell/  
        └── panel\_widget/  
            ├── mod.rs              // Öffentliche API, GObject Wrapper (PanelWidget struct)  
            ├── imp.rs              // Private GObject Implementierung (Subclass-Logik)  
            ├── panel\_widget.ui     // (Optional) XML-Definition für Composite Template  
            └── error.rs            // (Optional) Definition von PanelWidgetError

* mod.rs: Enthält die glib::wrapper\! Makrodefinition und öffentliche Methoden, die an die imp-Struktur delegieren.  
* imp.rs: Beinhaltet die \# Struktur, die \#\[glib::object\_subclass\] Implementierung und die Implementierungen für ObjectImpl, WidgetImpl, WindowImpl, und ApplicationWindowImpl. Hier werden Eigenschaften und Signale definiert und die Kernlogik des Widgets implementiert.  
* panel\_widget.ui: Falls Composite Templates für das interne Layout des Panels (z.B. die Anordnung von start\_box, center\_box, end\_box) verwendet werden, wird die XML-Struktur hier definiert.56  
* error.rs: Definiert PanelWidgetError unter Verwendung von thiserror.

Diese Struktur fördert die Modularität und Trennung von öffentlicher Schnittstelle und Implementierungsdetails, wie es in der gtk-rs Community üblich ist.5

### ---

**2.2. Sub-Modul: ui::shell::panel\_widget::AppMenuButton**

#### **2.2.1. Übersicht und Verantwortlichkeiten**

Das AppMenuButton ist ein spezialisiertes Panel-Modul, das als gtk::MenuButton (oder eine benutzerdefinierte Ableitung davon) implementiert wird. Seine Hauptverantwortung ist die Darstellung des globalen Anwendungsmenüs der aktuell fokussierten Applikation. Hierzu muss es:

1. Den app\_id (oder eine äquivalente Kennung) des aktiven Fensters ermitteln.  
2. Basierend auf dem app\_id das gio::MenuModel der aktiven Anwendung über D-Bus abrufen.  
3. Das abgerufene Menümodell in einem gtk::PopoverMenu darstellen, das beim Klick auf den Button erscheint.  
4. Das Aussehen des Buttons dynamisch an die aktive Anwendung anpassen (z.B. Icon und/oder Name anzeigen).

Die Komplexität dieser Komponente ergibt sich aus der Notwendigkeit, mit externen Systemkomponenten (Wayland Compositor für Fensterinformationen, D-Bus für Menüdaten) zu interagieren und auf Änderungen des Fensterfokus zu reagieren.

#### **2.2.2. Visuelles Design und Theming**

* **Anzeige**: Zeigt typischerweise das Icon der aktiven Anwendung. Falls kein Icon verfügbar ist oder keine Anwendung ein Menü bereitstellt, wird ein generisches "Anwendungsmenü"-Icon oder ein Platzhaltertext angezeigt.  
* **Beschriftung**: Kann optional den Namen der aktiven Anwendung neben dem Icon anzeigen, abhängig von der Konfiguration und dem verfügbaren Platz im Panel.  
* **Styling**:  
  * Als Instanz von gtk::MenuButton oder einer benutzerdefinierten, von gtk::Button abgeleiteten Klasse, die ein Popover öffnet. Es kann als ui::components::StyledButtonWidget implementiert werden, um ein konsistentes Erscheinungsbild mit anderen Buttons im Panel zu gewährleisten.  
  * **CSS-Knoten**: button (wenn von gtk::Button abgeleitet) oder menubutton (wenn von gtk::MenuButton).  
  * **CSS-Klassen**:  
    * .app-menu-button: Allgemeine Klasse für spezifisches Styling.  
    * .active-app: Wenn ein Anwendungsmenü erfolgreich geladen wurde.  
    * .no-app-menu: Wenn kein Menü für die aktive Anwendung verfügbar ist oder keine Anwendung fokussiert ist.  
* Der Tooltip des Buttons zeigt den Namen der aktiven Anwendung an, falls nicht bereits als Label sichtbar.76

#### **2.2.3. Datenstrukturen, Eigenschaften und Zustand**

Das AppMenuButton wird als GObject-Widget implementiert.

* **GObject-Definition (AppMenuButton)**:  
  *Auszug aus src/ui/shell/panel\_widget/app\_menu\_button/imp.rs (vereinfacht):*  
  Rust  
  use gtk::glib;  
  use gtk::subclass::prelude::\*;  
  use gtk::{gio, CompositeTemplate};  
  use std::cell::{Cell, RefCell};  
  use once\_cell::sync::Lazy;  
  use zbus::Connection; // \[12\]

  // Enum für den Status der Menüabfrage  
  \#  
  pub enum MenuFetchStatus {  
      \#\[default\]  
      Idle,  
      Loading,  
      Success,  
      Error(String), // Enthält Fehlermeldung  
  }

  static APP\_MENU\_BUTTON\_PROPERTIES: Lazy\<Vec\<glib::ParamSpec\>\> \= Lazy::new(|| {  
      vec\!  
  });

  \#  
  pub struct AppMenuButton {  
      // Eigenschaften  
      active\_app\_id: RefCell\<Option\<String\>\>,  
      active\_app\_name: RefCell\<Option\<String\>\>,  
      active\_app\_icon\_name: RefCell\<Option\<String\>\>,  
      has\_menu: Cell\<bool\>,  
      menu\_fetch\_status: RefCell\<MenuFetchStatus\>,

      // Interner Zustand  
      current\_menu\_model: RefCell\<Option\<gio::MenuModel\>\>,  
      dbus\_connection: RefCell\<Option\<Connection\>\>, // Zbus-Verbindung \[12\]

      // Referenz auf das GtkMenuButton-Widget selbst (oder das Popover, falls custom)  
      menu\_button\_widget: RefCell\<Option\<gtk::MenuButton\>\>, // Wird in constructed gesetzt  
  }

  \#\[glib::object\_subclass\]  
  impl ObjectSubclass for AppMenuButton {  
      const NAME: &'static str \= "NovaDEAppMenuButton";  
      type Type \= super::AppMenuButton;  
      type ParentType \= gtk::MenuButton; // Oder gtk::Button, wenn ein Popover manuell verwaltet wird

      fn new() \-\> Self {  
          Self {  
              active\_app\_id: RefCell::new(None),  
              active\_app\_name: RefCell::new(None),  
              active\_app\_icon\_name: RefCell::new(None),  
              has\_menu: Cell::new(false),  
              menu\_fetch\_status: RefCell::new(MenuFetchStatus::Idle),  
              current\_menu\_model: RefCell::new(None),  
              dbus\_connection: RefCell::new(None),  
              menu\_button\_widget: RefCell::new(None),  
          }  
      }

      fn class\_init(klass: \&mut Self::Class) {  
          klass.install\_properties(\&APP\_MENU\_BUTTON\_PROPERTIES);  
          // CSS-Name setzen  
          klass.set\_css\_name("appmenubutton");  
      }  
  }

  impl ObjectImpl for AppMenuButton {  
      fn constructed(\&self) {  
          self.parent\_constructed();  
          let obj \= self.obj();  
          // Speichere eine Referenz auf das Widget selbst für einfachen Zugriff  
          // self.menu\_button\_widget.replace(Some(obj.clone()));

          // Initialisiere D-Bus Verbindung und abonniere aktive Fensteränderungen  
          // Dies sollte idealerweise asynchron geschehen.  
          let widget \= obj.clone();  
          glib::MainContext::default().spawn\_local(async move {  
              match Connection::session().await { // \[12\]  
                  Ok(conn) \=\> {  
                      widget.imp().dbus\_connection.replace(Some(conn));  
                      // Hier Logik zum Abonnieren von Änderungen des aktiven Fensters einfügen  
                      // z.B. über einen internen Service, der Wayland-Events verarbeitet  
                      // widget.subscribe\_to\_active\_window\_changes();  
                  }  
                  Err(e) \=\> {  
                      tracing::error\!("Failed to connect to D-Bus for AppMenuButton: {}", e);  
                      widget.imp().menu\_fetch\_status.replace(MenuFetchStatus::Error(format\!("D-Bus connection failed: {}", e)));  
                      widget.update\_button\_appearance\_and\_state();  
                  }  
              }  
          });  
          obj.update\_button\_appearance\_and\_state(); // Initiales Aussehen  
      }

      fn properties() \-\> &'static {  
          APP\_MENU\_BUTTON\_PROPERTIES.as\_ref()  
      }

      fn property(\&self, \_id: usize, pspec: \&glib::ParamSpec) \-\> glib::Value {  
          match pspec.name() {  
              "active-app-name" \=\> self.active\_app\_name.borrow().to\_value(),  
              "active-app-icon-name" \=\> self.active\_app\_icon\_name.borrow().to\_value(),  
              "has-menu" \=\> self.has\_menu.get().to\_value(),  
              \_ \=\> unimplemented\!(),  
          }  
      }  
      // set\_property ist hier nicht nötig, da die Eigenschaften Read-only sind und intern gesetzt werden.  
  }  
  impl WidgetImpl for AppMenuButton {  
      fn map(\&self) {  
          self.parent\_map();  
          // Beim Sichtbarwerden ggf. aktuellen Status neu abfragen  
          self.obj().trigger\_menu\_update\_for\_current\_app();  
      }  
  }  
  impl ButtonImpl for AppMenuButton {} // Falls ParentType gtk::Button  
  impl MenuButtonImpl for AppMenuButton {} // Falls ParentType gtk::MenuButton

* **Eigenschaften (Properties)**:  
  **Tabelle: AppMenuButton Eigenschaften**

| Eigenschaftsname | Typ | Zugriff | Standardwert | Beschreibung |
| :---- | :---- | :---- | :---- | :---- |
| active-app-name | Option\<String\> | Nur Lesen | None | Name der Anwendung, deren Menü aktuell angezeigt wird oder angezielt ist. |
| active-app-icon-name | Option\<String\> | Nur Lesen | None | Icon-Name (für Theming) der Anwendung, deren Menü angezielt ist. |
| has-menu | bool | Nur Lesen | false | true, wenn ein Menü für die aktive Anwendung verfügbar und geladen ist. |

\*Bedeutung der Tabelle:\* Definiert den beobachtbaren Zustand des \`AppMenuButton\`, nützlich für Binding oder um auf Änderungen im Menü der aktiven Anwendung zu reagieren.

* **Interner Zustand**:  
  * active\_app\_id: RefCell\<Option\<String\>\>: Speichert die ID der aktuell fokussierten Anwendung.  
  * menu\_fetch\_status: RefCell\<MenuFetchStatus\>: Verfolgt den Zustand des Menüabrufs.  
  * current\_menu\_model: RefCell\<Option\<gio::MenuModel\>\>: Hält das aktuell geladene Menümodell.  
  * dbus\_connection: RefCell\<Option\<zbus::Connection\>\>: Die D-Bus-Verbindung für Abfragen.

#### **2.2.4. GTK-Widget-Implementierung**

* Das AppMenuButton erbt von gtk::MenuButton.77 Diese Klasse bietet bereits die Funktionalität, ein Popover beim Klick anzuzeigen.  
* Das Popover wird ein gtk::PopoverMenu sein.79  
* Die Eigenschaft menu-model des gtk::MenuButton (oder des internen gtk::PopoverMenu) wird dynamisch mit dem über D-Bus abgerufenen gio::MenuModel aktualisiert.  
  * gtk::MenuButton::set\_menu\_model(Some(menu\_model))  
  * Wenn kein Menü verfügbar ist, wird gtk::MenuButton::set\_menu\_model(None) gesetzt oder das Popover deaktiviert.

#### **2.2.5. Methoden und Funktionssignaturen**

* **Öffentliche Methoden (vom Panel oder einem Dienst für aktive Fenster aufgerufen)**:  
  * pub fn update\_active\_window\_info(\&self, app\_id: Option\<String\>, window\_title: Option\<String\>, icon\_name: Option\<String\>) noexcept;  
    * Wird aufgerufen, wenn sich das aktive Fenster *oder* dessen Metadaten ändern.  
    * Speichert app\_id, window\_title, icon\_name intern.  
    * Löst trigger\_menu\_update\_for\_current\_app aus.  
    * Aktualisiert sofort das Aussehen des Buttons (Icon/Label) basierend auf icon\_name und window\_title/app\_id.  
* **Interne Methoden**:  
  * fn trigger\_menu\_update\_for\_current\_app(\&self) noexcept;  
    * Prüft, ob active\_app\_id gesetzt ist.  
    * Wenn ja, startet die asynchrone fetch\_menu\_for\_app-Operation.  
    * Setzt menu\_fetch\_status auf Loading.  
    * Aktualisiert das Button-Aussehen (z.B. Ladeindikator).  
  * async fn fetch\_menu\_for\_app(dbus\_conn: Connection, app\_id: String) \-\> Result\<gio::MenuModel, AppMenuError\>;  
    * Diese Funktion ist async und wird mit glib::MainContext::spawn\_local ausgeführt.7  
    * Versucht, das gio::MenuModel für den gegebenen app\_id über D-Bus zu beziehen (siehe 2.2.8 Interaktionen).  
    * Gibt das gio::MenuModel oder einen AppMenuError zurück.  
  * fn handle\_menu\_fetch\_result(\&self, result: Result\<gio::MenuModel, AppMenuError\>) noexcept;  
    * Wird im glib::MainContext aufgerufen, nachdem fetch\_menu\_for\_app abgeschlossen ist.  
    * Aktualisiert current\_menu\_model, has\_menu, und menu\_fetch\_status.  
    * Ruft display\_menu und update\_button\_appearance\_and\_state auf.  
  * fn display\_menu(\&self) noexcept;  
    * Setzt das current\_menu\_model auf den gtk::MenuButton.  
  * fn update\_button\_appearance\_and\_state(\&self) noexcept;  
    * Aktualisiert Icon (z.B. gtk::Image::set\_from\_icon\_name 84) und Label des gtk::MenuButton basierend auf active\_app\_icon\_name, active\_app\_name und menu\_fetch\_status.  
    * Setzt den sensitive-Zustand des Buttons (z.B. deaktiviert, wenn kein Menü geladen werden kann oder Loading).  
    * Aktualisiert die GObject-Properties (active-app-name, active-app-icon-name, has-menu) und emittiert notify Signale.

**Tabelle: AppMenuButton Methoden (Auswahl)**

| Signatur | Beschreibung | async | noexcept |
| :---- | :---- | :---- | :---- |
| pub fn update\_active\_window\_info(\&self, app\_id: Option\<String\>, window\_title: Option\<String\>, icon\_name: Option\<String\>) | Aktualisiert die Informationen über das aktive Fenster und löst ggf. eine Menüaktualisierung aus. | Nein | Ja |
| fn trigger\_menu\_update\_for\_current\_app(\&self) | Startet den Prozess zum Abrufen und Anzeigen des Menüs für die aktuell zwischengespeicherte app\_id. | Nein | Ja |
| async fn fetch\_menu\_for\_app(dbus\_conn: Connection, app\_id: String) \-\> Result\<gio::MenuModel, AppMenuError\> | Ruft asynchron das GMenuModel für die gegebene app\_id über D-Bus ab. | Ja | Nein |
| fn handle\_menu\_fetch\_result(\&self, result: Result\<gio::MenuModel, AppMenuError\>) | Verarbeitet das Ergebnis von fetch\_menu\_for\_app, aktualisiert den internen Zustand und die UI. | Nein | Ja |

#### **2.2.6. Signale**

* **Benutzerdefinierte Signale**: Keine spezifischen benutzerdefinierten Signale für diese Komponente vorgesehen. Es erbt die Signale von gtk::MenuButton (z.B. clicked, activate).  
* **Verbundene Signale**:  
  * Intern: Lauscht auf ein Signal von einem übergeordneten Dienst (z.B. innerhalb von ui::shell), das Änderungen des aktiven Fensters (app\_id, Titel, Icon) meldet.

#### **2.2.7. Ereignisbehandlung**

* Die Hauptinteraktion ist der Klick auf den Button, der durch die gtk::MenuButton-Basisklasse gehandhabt wird und das Popover mit dem Menü anzeigt.  
* Interne Reaktionen auf die Ergebnisse der asynchronen D-Bus-Menüabfrage und auf Änderungen des aktiven Fensters sind entscheidend für die dynamische Aktualisierung.

#### **2.2.8. Interaktionen**

* **system::compositor (Fensterinformationen)**:  
  * Das AppMenuButton selbst interagiert nicht direkt mit dem Compositor. Es ist auf einen Dienst innerhalb der ui::shell angewiesen, der Informationen über das aktive Fenster bereitstellt. Dieser Dienst nutzt Wayland-Protokolle.  
  * **Wayland-Protokolle**:  
    * wlr-foreign-toplevel-management-unstable-v1: Dieses Protokoll ermöglicht es einem Client (dem NovaDE-Shell-Dienst), eine Liste von Toplevel-Fenstern zu erhalten und deren Zustände (inkl. app\_id, title, state) zu überwachen. Der Dienst würde das activated-Ereignis nutzen, um das aktuell fokussierte Fenster zu identifizieren.85  
    * ext-foreign-toplevel-list-v1: Ein alternatives oder ergänzendes Protokoll, das ebenfalls zur Auflistung von Toplevel-Fenstern dient.85  
  * Die Implementierung dieser Wayland-Client-Logik sollte zentral in einem ui::shell-Modul erfolgen (z.B. ui::shell::active\_window\_service) und nicht im AppMenuButton selbst, um Redundanz zu vermeiden und die Komplexität zu kapseln. Dieser Dienst würde dann ein internes Signal oder einen Event für das AppMenuButton bereitstellen.  
* **D-Bus (Menüabruf)**:  
  * Sobald der app\_id des aktiven Fensters bekannt ist, wird versucht, dessen Menümodell über D-Bus abzurufen.  
  * **Primärer Mechanismus (org.gtk.Menus)**:  
    * GTK4-Anwendungen, die GApplication verwenden, exportieren ihre Menüs (typischerweise GMenuModel für Anwendungsmenü und Menüleiste) oft über D-Bus unter ihrem eigenen Bus-Namen (welcher dem app\_id entspricht, z.B. org.gnome.TextEditor).  
    * Der Standard-Objektpfad für das Menü ist oft /org/gtk/menus/menubar oder ein ähnlicher, durch GApplication festgelegter Pfad.91  
    * Die Schnittstelle ist org.gtk.Menus.  
    * gio::DBusMenuModel::new(bus\_name, object\_path) kann verwendet werden, um ein GMenuModel direkt von einem D-Bus-Dienst zu erstellen, was die Details der Methodenaufrufe abstrahiert.21  
  * **Fallback-Mechanismus (com.canonical.AppMenu.Registrar)**:  
    * Ein älterer Mechanismus, der von Unity verwendet wurde. Anwendungen registrieren ihre Fenster-ID und den D-Bus-Pfad zu ihrem Menü bei diesem Dienst.15  
    * Dienstname: com.canonical.AppMenu.Registrar  
    * Objektpfad: /com/canonical/AppMenu/Registrar  
    * Schnittstelle: com.canonical.AppMenu.Registrar  
    * Methode: GetMenuForWindow(window\_id\_uint32). Dies ist problematisch in einer reinen Wayland-Umgebung, da X11-Fenster-IDs nicht direkt verfügbar oder relevant sind. Eine Wayland-kompatible Anwendung müsste ihren Menüpfad auf andere Weise bekannt geben.  
  * **D-Bus-Client-Implementierung**: Das zbus-Crate wird verwendet, um D-Bus-Proxies zu erstellen und Methoden aufzurufen.12  
    * Ein zbus::Proxy wird für den Zieldienst erstellt (entweder der app\_id oder com.canonical.AppMenu.Registrar).  
    * Die entsprechenden Methoden werden asynchron aufgerufen.  
    * Das Ergebnis (oft ein Pfad zu einem DBusMenu-Objekt) wird verwendet, um ein gio::MenuModel zu instanziieren, typischerweise mit gio::DBusMenuModel.

**Tabelle: AppMenuButton D-Bus Interaktionen**

| Interaktion | Zieldienst (Primär) | Objektpfad (Primär) | Schnittstelle (Primär) | Methode/Eigenschaft (Primär) | Zieldienst (Fallback) | Objektpfad (Fallback) | Schnittstelle (Fallback) | Methode (Fallback) |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| GMenuModel für aktive Anwendung abrufen | \[app\_id\_der\_aktiven\_Anwendung\] | /org/gtk/menus/menubar (oder Konvention) | org.gtk.Menus (oder org.freedesktop.DBus.Properties) | gio::DBusMenuModel::new(bus\_name, object\_path) (abstrahiert Methodenaufrufe) | com.canonical.AppMenu.Registrar | /com/canonical/AppMenu/Registrar | com.canonical.AppMenu.Registrar | GetMenuForWindow (XID-abhängig) oder App registriert Menüpfad |

\*Bedeutung der Tabelle:\* Verdeutlicht die komplexen D-Bus-Interaktionen, die für das Abrufen von Anwendungsmenüs erforderlich sind. Dies ist entscheidend für die Implementierung und das Debugging, insbesondere angesichts der verschiedenen Mechanismen, über die Menüs bereitgestellt werden können.

#### **2.2.9. Ausnahmebehandlung**

* **enum AppMenuError** (definiert mit thiserror 72):  
  * WaylandError(String): Fehler beim Abrufen von Informationen zum aktiven Fenster.  
  * DBusConnectionError(zbus::Error): Fehler bei der D-Bus-Kommunikation.  
  * MenuServiceUnavailable(String): Der D-Bus-Dienst für die Anwendung (z.B. app\_id oder AppMenu.Registrar) ist nicht erreichbar.  
  * MenuNotFound(String): Die Anwendung (app\_id) exportiert kein bekanntes Menü oder das Menü ist leer.  
  * MenuModelParseError(String): Fehler beim Parsen oder Interpretieren der Menüdaten.  
* Im Fehlerfall zeigt der AppMenuButton einen deaktivierten Zustand oder ein generisches Icon an. Fehlerdetails werden über tracing geloggt.73

#### **2.2.10. Auflösung "Untersuchungsbedarf"**

* **Zuverlässige Methode zur Ermittlung des aktiven Fensters/app\_id unter Wayland**:  
  * Die bevorzugte Methode ist die Verwendung des wlr-foreign-toplevel-management-unstable-v1-Protokolls.86 Ein zentraler Shell-Dienst (nicht der AppMenuButton selbst) agiert als Client dieses Protokolls.  
  * Der Dienst bindet sich an den globalen zwlr\_foreign\_toplevel\_manager\_v1.  
  * Für jedes gemeldete Toplevel (zwlr\_foreign\_toplevel\_handle\_v1) lauscht der Dienst auf die Ereignisse app\_id, title und state.  
  * Das state-Ereignis enthält Flags, darunter activated. Das Toplevel mit dem activated-Flag ist das aktuell fokussierte Fenster.  
  * Die smithay-client-toolkit 85 könnte Rust-Abstraktionen für dieses Protokoll bereitstellen. Falls nicht, ist die direkte Verwendung von wayland-client mit den wayland-protocols-Bindings (speziell wlr-protocols) notwendig.89  
  * Dieser zentrale Dienst stellt dann die Informationen über das aktive Fenster (insbesondere app\_id, title, icon\_name) dem AppMenuButton und anderen interessierten UI-Komponenten über ein internes Event-System oder Signale zur Verfügung.  
* **Ermittlung und Konsumierung von GMenuModel via D-Bus**:  
  * **Primärer Pfad (für GTK4-Anwendungen)**: Moderne GTK-Anwendungen, die GApplication verwenden, exportieren ihr Hauptmenü (GMenuModel) typischerweise über D-Bus auf ihrem eigenen, durch den app\_id bestimmten Bus-Namen. Der Objektpfad ist oft standardisiert, z.B. /org/gtk/menus/menubar oder ein anderer Pfad, den GApplication für diesen Zweck nutzt.91 Ein gio::DBusMenuModel wird dann mit diesem Bus-Namen und Objektpfad instanziiert, um das Menümodell zu erhalten.21  
  * **Fallback (StatusNotifierItem)**: Falls eine Anwendung ein StatusNotifierItem bereitstellt, kann dessen Menu-Eigenschaft einen D-Bus-Objektpfad zu einem Menü (oft im com.canonical.dbusmenu-Format) enthalten.102 Dies ist relevant, wenn die Anwendung primär über ein Tray-Icon interagiert.  
  * **Fallback (AppMenu Registrar)**: Der com.canonical.AppMenu.Registrar D-Bus-Dienst ist ein älterer Mechanismus.15 Seine Verwendung in einer reinen Wayland-Umgebung ist aufgrund der Abhängigkeit von X11-Fenster-IDs problematisch und sollte nur als letzte Option in Betracht gezogen werden, falls Anwendungen keine anderen Mechanismen anbieten.  
  * **Implementierungsentscheidung**: Die Strategie sollte sein, zuerst den primären Pfad (org.gtk.Menus auf dem app\_id-Bus) zu versuchen. Schlägt dies fehl und ist ein StatusNotifierItem für die App vorhanden, kann dessen Menüpfad versucht werden. Der AppMenuRegistrar wird aufgrund seiner X11-Lastigkeit tendenziell vermieden.  
  * Das AppMenuButton verwendet das erhaltene gio::MenuModel, um seinen internen gtk::PopoverMenu zu füllen.79

Die Implementierung des AppMenuButton erfordert eine sorgfältige Orchestrierung asynchroner Operationen für Wayland-Events und D-Bus-Aufrufe, um die UI reaktionsfähig zu halten (glib::MainContext::spawn\_local 7). Fehlerzustände (z.B. keine aktive Anwendung, keine Menüdaten, D-Bus-Fehler) müssen robust gehandhabt und dem Benutzer klar signalisiert werden (z.B. durch ein deaktiviertes oder generisches Icon).

#### **2.2.11. Dateistruktur**

src/  
└── ui/  
    └── shell/  
        └── panel\_widget/  
            └── app\_menu\_button/  
                ├── mod.rs          // Öffentliche API, GObject Wrapper (AppMenuButton struct)  
                ├── imp.rs          // Private GObject Implementierung  
                ├── dbus.rs         // Logik für D-Bus Interaktionen (Menüabruf)  
                └── error.rs        // Definition von AppMenuError

Diese Struktur kapselt die Komplexität des AppMenuButton und trennt die D-Bus-Logik klar ab.  
---

**(Hinweis: Die detaillierte Ausarbeitung weiterer Submodule des PanelWidget wie WorkspaceIndicatorWidget, ClockDateTimeWidget, SystemTrayEquivalentWidget etc. würde einem ähnlichen Detaillierungsgrad folgen und die spezifischen "Untersuchungsbedarfe" adressieren. Insbesondere das SystemTrayEquivalentWidget erfordert eine tiefgreifende Auseinandersetzung mit der StatusNotifierItem-Spezifikation und deren D-Bus-Implementierung mittels zbus, wie in der Gliederung angedeutet.102)**  
Die Implementierung eines SystemTrayEquivalentWidget ist ein komplexes Unterfangen, da Wayland selbst kein natives "System Tray"-Protokoll definiert. Die De-facto-Standardlösung ist die StatusNotifierItem (SNI) Spezifikation von Freedesktop.org, die auf D-Bus basiert.102  
Ein SystemTrayEquivalentWidget müsste folgende Kernkomponenten umfassen:

1. **StatusNotifierHost-Registrierung**: Das Panel (oder dieses Widget) muss sich als org.freedesktop.StatusNotifierHost auf dem Session-Bus registrieren. Dies signalisiert dem StatusNotifierWatcher, dass ein Host für Items vorhanden ist.106 Die Registrierung erfolgt typischerweise durch das Anfordern eines eindeutigen Bus-Namens (z.B. org.freedesktop.StatusNotifierHost-PID oder org.freedesktop.StatusNotifierHost-NovaDE).  
2. **Interaktion mit StatusNotifierWatcher**:  
   * Der StatusNotifierWatcher (org.freedesktop.StatusNotifierWatcher) ist der zentrale Dienst zur Verwaltung von SNIs.102  
   * Das Widget muss diesen Watcher auf dem D-Bus finden (Standardname org.freedesktop.StatusNotifierWatcher, Pfad /org/freedesktop/StatusNotifierWatcher).  
   * Es muss die Methode RegisterStatusNotifierHost am Watcher aufrufen, um sich selbst als Host zu registrieren.  
   * Es muss die Eigenschaft RegisteredStatusNotifierItems des Watchers abfragen, um eine initiale Liste aller bereits vorhandenen SNIs zu erhalten.  
   * Es muss die Signale StatusNotifierItemRegistered und StatusNotifierItemUnregistered des Watchers abonnieren, um dynamisch auf neue oder entfernte SNIs zu reagieren. zbus wird hierfür verwendet, um Signal-Handler einzurichten.109  
3. **Interaktion mit einzelnen StatusNotifierItems**:  
   * Für jeden von StatusNotifierWatcher gemeldeten Dienstnamen eines SNI (z.B. org.freedesktop.StatusNotifierItem-PID-ID) muss ein zbus::Proxy erstellt werden.17  
   * Über diesen Proxy werden die Eigenschaften des SNI ausgelesen: Category, Id, Title, Status, WindowId, IconName, IconPixmap, OverlayIconName, OverlayIconPixmap, AttentionIconName, AttentionIconPixmap, AttentionMovieName, ToolTip, ItemIsMenu, Menu.102  
   * Signale des SNI (z.B. NewIcon, NewStatus, NewToolTip, NewMenu) müssen abonniert werden, um auf Änderungen zu reagieren und die Darstellung des entsprechenden Indikator-Widgets im Panel zu aktualisieren.16  
4. **Darstellung der Indikatoren**:  
   * Für jedes aktive SNI wird ein kleines Widget im SystemTrayEquivalentWidget (das selbst eine gtk::Box oder ein ähnlicher Container ist) angezeigt.  
   * **Icon**: IconName wird verwendet, um ein themenbasiertes Icon über gtk::Image::from\_icon\_name zu laden.84 Falls IconPixmap bereitgestellt wird, müssen die Rohpixeldaten (oft ein Array von Tupeln (width, height, data)) in ein gdk\_pixbuf::Pixbuf konvertiert werden (z.B. mit Pixbuf::from\_mut\_slice oder PixbufLoader, falls die Daten gestreamt ankommen, was hier aber unwahrscheinlich ist) und dann in einem gtk::Image angezeigt werden.117  
   * **Tooltip**: Die ToolTip-Eigenschaft des SNI (eine Struktur mit Titel, Text, Icon) wird verwendet, um einen Tooltip für das Indikator-Widget mittels gtk::Widget::set\_tooltip\_markup oder gtk::Widget::set\_tooltip\_text zu setzen.76  
   * **Status**: Die Status-Eigenschaft (Passive, Active, NeedsAttention) kann verwendet werden, um das Aussehen des Indikators anzupassen (z.B. Hervorhebung bei NeedsAttention).  
5. **Interaktion mit den Indikatoren**:  
   * **Linksklick (Activate)**: Ein Klick auf das Indikator-Widget ruft die Activate(x, y)-Methode des SNI über D-Bus auf.103  
   * **Rechtsklick (ContextMenu)**: Ein Rechtsklick ruft die ContextMenu(x, y)-Methode des SNI auf. Wenn die ItemIsMenu-Eigenschaft true ist und die Menu-Eigenschaft einen gültigen D-Bus-Pfad zu einem com.canonical.dbusmenu-Objekt enthält, wird dieses Menü abgerufen (mittels gio::DBusMenuModel 96) und als gtk::PopoverMenu angezeigt.79  
   * **Scrollen**: Mausrad-Events über dem Indikator rufen die Scroll(delta, orientation)-Methode des SNI auf.  
6. **Asynchronität**: Alle D-Bus-Interaktionen (Methodenaufrufe, Signal-Handling) müssen asynchron mit glib::MainContext::spawn\_local erfolgen, um die UI nicht zu blockieren.7

Die "Alternativen unter Wayland" 104 beziehen sich darauf, dass Wayland selbst kein Tray-Protokoll spezifiziert. StatusNotifierItem ist die etablierte D-Bus-basierte Lösung. Einige Desktop-Umgebungen könnten eigene Protokolle haben, aber für eine breite Kompatibilität ist SNI der Standard. Die Herausforderung besteht darin, dass nicht alle Anwendungen SNI korrekt oder vollständig implementieren.

## ---

**3\. Übergreifende Belange – Initiale Spezifikationen**

Dieser Abschnitt definiert initiale Strategien für Aspekte, die mehrere UI-Module betreffen und eine konsistente Handhabung erfordern.

### **3.1. UI-Zustandsverwaltungsstrategie**

Die Verwaltung des UI-Zustands ist entscheidend für eine reaktive und wartbare Benutzeroberfläche. In NovaDE wird ein mehrschichtiger Ansatz verfolgt, der die Stärken von GObject mit Rust-Idiomen kombiniert:

* **GObject-Eigenschaften für Widget-Zustand**:  
  * Der primäre Mechanismus zur Verwaltung des Zustands einzelner Widgets sind GObject-Eigenschaften. Diese werden mit dem glib::Properties-Derive-Makro und klass.install\_properties() in der ObjectSubclass-Implementierung definiert.47  
  * Beispiel: Die panel-height-Eigenschaft des PanelWidget.  
  * Änderungen an diesen Eigenschaften lösen automatisch "notify::property-name"-Signale aus, auf die andere Teile der UI oder die interne Logik des Widgets reagieren können. Explizite Benachrichtigung kann mit self.obj().notify\_propertyName() erzwungen werden, falls die automatische Benachrichtigung nicht ausreicht oder benutzerdefinierte Logik vor der Benachrichtigung ausgeführt werden muss.  
* **Benutzerdefinierte GObject-Signale**:  
  * Für komplexere Zustandsänderungen oder Ereignisse, die nicht direkt durch eine einzelne Eigenschaftsänderung abgebildet werden, werden benutzerdefinierte GObject-Signale definiert.115  
  * Beispiel: Das module-layout-changed-Signal des PanelWidget.  
  * Signale werden in ObjectImpl::signals() definiert und können mit self.obj().emit\_by\_name::\<()\>("signal-name", &\[\&param1, \&param2\]) ausgelöst werden.  
* **Rc\<RefCell\<T\>\> für gemeinsam genutzten UI-Zustand**:  
  * Für UI-Zustände, die von mehreren Widgets gemeinsam genutzt werden und nicht in einer direkten GObject-Eltern-Kind-Beziehung stehen oder nicht sinnvoll als globale GSettings abgebildet werden können, wird das Rust-Idiom Rc\<RefCell\<T\>\> verwendet.51  
  * Rc ermöglicht das Teilen des Besitzes im Single-Threaded-Kontext des GTK-Mainloops.  
  * RefCell ermöglicht die innere Veränderlichkeit (mutable borrows zur Laufzeit geprüft).  
  * Dies ist nützlich für z.B. einen gemeinsam genutzten D-Bus-Verbindungsmanager, der von mehreren UI-Komponenten verwendet wird, oder für View-Modelle, die Daten für mehrere, lose gekoppelte Widgets halten.  
  * Vorsicht ist geboten, um Zyklen von Rc-Referenzen zu vermeiden, die zu Speicherlecks führen können. Weak\<RefCell\<T\>\> kann hier Abhilfe schaffen.  
* **Datenbindung (Property Binding)**:  
  * GObject-Eigenschaftsbindungen (GObject.bind\_property()) werden intensiv genutzt, um UI-Elemente direkt an Zustandseigenschaften zu koppeln. Dies reduziert manuellen Synchronisationscode und fördert eine deklarative UI-Logik.  
  * Beispiel: Die label-Eigenschaft eines gtk::Label könnte an eine String-Eigenschaft eines View-Modell-Objekts gebunden werden.  
* **Adaption von MVVM/MVC-Mustern**:  
  * Obwohl GTK nicht explizit für ein bestimmtes UI-Architekturmuster wie MVVM oder MVC ausgelegt ist, können deren Prinzipien adaptiert werden:  
    * **Model**: Repräsentiert die Anwendungsdaten und Geschäftslogik (primär in der domain-Schicht, aber auch UI-spezifische Zustandsmodelle).  
    * **View**: Die GTK-Widgets selbst.  
    * **ViewModel/Controller**: GObject-Instanzen, die UI-spezifische Logik und Zustand halten (ViewModel-Aspekt) und Benutzerinteraktionen verarbeiten (Controller-Aspekt). GObject-Eigenschaften des ViewModels werden an die View (Widgets) gebunden. Methoden im ViewModel/Controller reagieren auf UI-Events und interagieren mit dem Model.  
* **Kommunikation mit unteren Schichten**:  
  * Zustandsänderungen, die von der domain- oder system-Schicht ausgehen (z.B. durch Ereignisse oder Callbacks von asynchronen Operationen), werden in UI-Zustandsaktualisierungen übersetzt.  
  * Dies geschieht typischerweise innerhalb von Closures, die mit glib::MainContext::spawn\_local auf dem UI-Thread ausgeführt werden, um Thread-Sicherheit zu gewährleisten.7  
  * Beispiel: Ein NetworkStatusChangedEvent aus der system-Schicht könnte die icon-name-Eigenschaft eines NetworkIndicatorWidget aktualisieren.

Dieser Ansatz ermöglicht eine klare Trennung der Belange, nutzt die Stärken des GObject-Systems für Widget-spezifischen Zustand und bietet gleichzeitig flexible Rust-basierte Lösungen für komplexere oder gemeinsam genutzte UI-Zustände.

### **3.2. Fehlerbehandlungs-Framework für die UI-Schicht**

Eine konsistente und benutzerfreundliche Fehlerbehandlung ist unerlässlich.

* **Fehlerdefinition mit thiserror**:  
  * Für jedes Hauptmodul der UI-Schicht (z.B. ui::shell, ui::control\_center) und ggf. für komplexe Submodule (z.B. AppMenuButton) werden spezifische Error-Enums mit thiserror::Error definiert.72 Beispiel: PanelWidgetError, AppMenuError.  
  * Diese modul-spezifischen Fehler werden in einem übergeordneten UI-Fehler-Enum (z.B. NovaUiError) zusammengefasst, ebenfalls unter Verwendung von \#\[from\]-Attributen in thiserror für eine einfache Konvertierung.  
    Rust  
    // Beispiel: src/ui/error.rs  
    use thiserror::Error;

    \#  
    pub enum PanelWidgetError {  
        \#\[error("Layer shell initialization failed: {0}")\]  
        LayerShellInitializationFailed(String),  
        // Weitere Panel-spezifische Fehler  
    }

    \#  
    pub enum AppMenuError {  
        \#\[error("Failed to get active window info from Wayland: {0}")\]  
        WaylandError(String),  
        \#  
        DBusConnectionError(\#\[from\] zbus::Error),  
        \#\[error("Menu service for app '{0}' unavailable")\]  
        MenuServiceUnavailable(String),  
        \#\[error("Menu not found for app '{0}'")\]  
        MenuNotFound(String),  
    }

    \#  
    pub enum NovaUiError {  
        \#\[error("Panel widget error: {0}")\]  
        Panel(\#\[from\] PanelWidgetError),  
        \#\[error("AppMenu button error: {0}")\]  
        AppMenu(\#\[from\] AppMenuError),  
        \#  
        Theming(String), // Fehler von ui::theming\_gtk  
        \#\[error("I/O error: {0}")\]  
        Io(\#\[from\] std::io::Error),  
        // Weitere Fehlerkategorien  
    }

* **Fehlerdarstellung**:  
  * **Kritische Fehler**: Fehler, die die grundlegende Funktionalität einer Komponente oder der UI stark beeinträchtigen (z.B. D-Bus-Verbindung nicht möglich, Layer-Shell-Initialisierung fehlgeschlagen), werden dem Benutzer über ein gtk::AlertDialog mitgeteilt. Der Dialog sollte eine klare Fehlermeldung und ggf. Vorschläge zur Fehlerbehebung oder einen Hinweis auf Log-Dateien enthalten.  
  * **Nicht-kritische Fehler**: Weniger schwerwiegende Fehler (z.B. ein einzelnes Panel-Modul kann nicht geladen werden, eine Einstellung kann nicht gelesen werden) werden als NotificationPopupWidget (siehe ui::notifications\_frontend) oder durch eine Zustandsänderung im Widget selbst (z.B. ausgegrautes Icon, Fehlermeldung im Tooltip) angezeigt.  
  * Fehlermeldungen für den Benutzer werden internationalisiert (i18n).  
* **Fehlerpropagation**: Fehler aus unteren Schichten (domain, system) werden in entsprechende NovaUiError-Varianten umgewandelt und nach oben propagiert oder an der Stelle behandelt, an der sie für die UI relevant werden.

### **3.3. Logging-Strategie**

Strukturiertes Logging ist für Diagnose und Debugging unerlässlich.

* **Bibliothek**: Das tracing-Crate wird für alle Logging-Aufgaben in der UI-Schicht verwendet.73  
* **Log-Level**:  
  * trace\!: Sehr detaillierte Informationen für tiefgreifendes Debugging (z.B. einzelne D-Bus-Nachrichten, detaillierte Widget-Zustandsänderungen). Standardmäßig deaktiviert.  
  * debug\!: Informationen, die für das Debugging nützlich sind (z.B. Erstellung von Widgets, Aufruf wichtiger interner Methoden, empfangene Ereignisse).  
  * info\!: Allgemeine Informationen über den Betrieb (z.B. Modul geladen, Einstellung geändert).  
  * warn\!: Unerwartete, aber nicht unbedingt fehlerhafte Zustände (z.B. optionale Konfigurationsdatei nicht gefunden, Fallback-Verhalten aktiviert).  
  * error\!: Fehlerzustände, die die Funktionalität beeinträchtigen (z.B. D-Bus-Aufruf fehlgeschlagen, Widget konnte nicht erstellt werden). Details zum Fehlerobjekt werden mitgeloggt.  
* **Strukturierte Felder**: Log-Nachrichten sollen relevante Kontextinformationen als strukturierte Felder enthalten.  
  * Beispiel: tracing::debug\!(widget\_name \= %self.widget\_name(), event \=?event\_type, "Event received");  
* **Span-Nutzung**: tracing::span\! wird verwendet, um wichtige Operationen oder Lebenszyklen von Komponenten zu umfassen, insbesondere bei asynchronen Abläufen.  
* **Konfiguration**:  
  * Die Konfiguration des tracing-Subscribers (z.B. tracing\_subscriber::fmt für Konsolenausgabe oder tracing\_journald für systemd-journal-Integration) erfolgt im Hauptanwendungseinstiegspunkt (main.rs).  
  * Die Standard-Logstufe für Entwicklungs-Builds ist DEBUG, für Release-Builds INFO. Die Logstufe kann zur Laufzeit über Umgebungsvariablen (z.B. RUST\_LOG) angepasst werden.

### **3.4. Initiales Teststrategie-Framework**

Eine mehrschichtige Teststrategie stellt die Qualität und Korrektheit der UI-Schicht sicher.

* **Unit-Tests**:  
  * Fokus: Testen von isolierter Logik innerhalb von UI-Komponenten, die nicht direkt vom GTK-Rendering oder \-Eventloop abhängt (z.B. Hilfsfunktionen, Datenkonvertierungslogik, Zustandsmanagement-Helfer).  
  * Werkzeuge: Standard Rust \#\[test\], Mocking-Bibliotheken (z.B. mockall) für Abhängigkeiten zu unteren Schichten oder externen Diensten.  
* **Widget-Tests**:  
  * Fokus: Testen des Verhaltens und Zustands einzelner GTK-Widgets und benutzerdefinierter GObject-Komponenten.  
  * Werkzeuge:  
    * gtk::test Namespace: Bietet Funktionen zum Initialisieren von GTK in Testumgebungen.  
    * Programmatische Interaktion: Simulieren von Signalen (z.B. widget.emit\_by\_name::\<()\>("clicked", &)), Setzen und Abfragen von GObject-Eigenschaften.  
    * Inspektion: Überprüfung von Widget-Zuständen (z.B. label.text(), button.is\_sensitive()).  
    * GTK-Inspektionswerkzeuge und Accessibility-APIs (ATK) können programmatisch genutzt werden, um Widget-Zustände und \-Eigenschaften zu überprüfen.122 Die Evaluierung von Frameworks wie gtk4-rs-test-utils (falls existent und passend) oder ähnlichen Ansätzen ist Teil des Untersuchungsbedarfs.  
* **Accessibility-Tests**:  
  * Fokus: Sicherstellen, dass UI-Komponenten für assistive Technologien zugänglich sind.  
  * Werkzeuge: Überprüfung von ATK-Eigenschaften (Rolle, Name, Beschreibung, Zustand) der Widgets. Manuelle Tests mit Screenreadern (z.B. Orca) sind ebenfalls notwendig. gtk::Accessible.23  
* **Visuelle Regressionstests**: (Zur Evaluierung)  
  * Fokus: Erkennen von unbeabsichtigten visuellen Änderungen in der UI.  
  * Werkzeuge: Evaluierung von Werkzeugen für den visuellen Vergleich von UI-Zuständen (Screenshots). Dies ist oft aufwendig und wird initial möglicherweise zurückgestellt.  
* **Integrations-/End-to-End-Tests**: (Herausfordernd, für kritische Pfade)  
  * Fokus: Testen des Zusammenspiels mehrerer UI-Komponenten und deren Interaktion mit unteren Schichten.  
  * Werkzeuge: Simulation von Benutzerinteraktionen auf Wayland-Ebene (z.B. mit Tools wie ydotool oder spezialisierten Test-Frameworks, falls verfügbar und integrierbar). Überprüfung des Systemverhaltens. Dies ist sehr komplex und wird nur für kritische User Journeys in Betracht gezogen.

### **3.5. Richtlinien für Performance-Optimierung und Profiling**

Die Sicherstellung einer performanten UI ist ein Kernziel.

* **Profiling-Werkzeuge**:  
  * **Rust-spezifisch**: perf unter Linux, cargo flamegraph, tracing mit tracing-flame für CPU-Profiling. Speicher-Profiler wie heaptrack oder Valgrind (mit Massif) können zur Analyse des Speicherverbrauchs herangezogen werden.  
  * **GTK4-spezifisch**: Der GTK Inspector enthält einen Profiler, der Rendering-Zeiten und Widget-Updates visualisiert. GSK-spezifische Debug-Flags (GSK\_DEBUG) können Aufschluss über Rendering-Pfade geben.  
* **Optimierungsbereiche**:  
  * **Widget-Zeichnung**: Bei benutzerdefinierten Zeichnungen mit Cairo (GtkDrawingArea) darauf achten, nur die notwendigen Bereiche neu zu zeichnen (gtk\_widget\_queue\_draw\_area). Komplexität der Zeichenoperationen minimieren.  
  * **CSS-Anwendung**: CSS-Selektoren einfach halten. Komplexe Selektoren und Regeln können die Performance beeinträchtigen. Effiziente Aktualisierung von CSS bei Theme-Wechseln.10  
  * **Datenbindung**: Übermäßige Nutzung von GObject-Property-Bindings oder zu häufige Benachrichtigungen bei kleinen Änderungen können zu Performance-Engpässen führen. Änderungen ggf. bündeln.  
  * **Layout-Performance**: Vermeidung unnötig tiefer Widget-Hierarchien. Effiziente Nutzung von Layout-Managern wie GtkBox und GtkGrid.  
  * **Asynchrone Operationen**: Konsequente Nutzung von glib::MainContext::spawn\_local für alle potenziell blockierenden Operationen (Netzwerk, Datei-I/O, aufwändige Berechnungen in der Domänenschicht), um UI-Blockaden zu verhindern.7 Visuelles Feedback (Spinner, Fortschrittsbalken) für laufende Operationen bereitstellen.  
* **Allgemeine Rust-Optimierungen**: Zero-Cost-Abstraktionen nutzen, unnötige Allokationen vermeiden, effiziente Datenstrukturen wählen.24

Performance-Messungen und \-Optimierungen sollten ein integraler Bestandteil des Entwicklungsprozesses sein, nicht eine nachträgliche Maßnahme.

## **4\. Plan für nachfolgende UI-Layer-Module**

### **4.1. Priorisierung für nächste Module**

Nach der initialen Implementierung und Stabilisierung des PanelWidget und des AppMenuButton sowie der grundlegenden übergreifenden Frameworks (Theming, State Management, Error Handling, Logging) werden die UI-Module in folgender logischer Reihenfolge priorisiert:

1. **Weitere Kern-Panel-Module (ui::shell)**:  
   * WorkspaceIndicatorWidget: Essentiell für die Workspace-Navigation.  
   * ClockDateTimeWidget: Grundlegende Benutzerinformation.  
   * SystemTrayEquivalentWidget: Kritisch für die Integration von Drittanbieter-Anwendungen. Aufgrund seiner Komplexität (siehe oben) wird hierfür frühzeitig mit der Detailplanung und Prototyping begonnen.  
   * QuickSettingsButtonWidget und NotificationCenterButtonWidget: Wichtige Zugriffspunkte für Systemfunktionen.  
   * Weitere Indikatoren (NetworkIndicatorWidget, PowerIndicatorWidget, AudioIndicatorWidget).  
2. **Ausklappbare Panel-Inhalte (ui::shell)**:  
   * QuickSettingsPanelWidget: Wird vom QuickSettingsButtonWidget geöffnet.  
   * NotificationCenterPanelWidget: Wird vom NotificationCenterButtonWidget geöffnet und interagiert mit ui::notifications\_frontend.  
3. **Weitere Shell-Komponenten (ui::shell)**:  
   * SmartTabBarWidget  
   * WorkspaceSwitcherWidget  
   * QuickActionDockWidget  
4. **Systemeinstellungsanwendung (ui::control\_center)**:  
   * Dies ist eine größere, eigenständige Anwendung und wird parallel zu weniger kritischen Shell-Komponenten entwickelt, sobald die Kern-Shell-Interaktionen stabil sind.  
5. **Spezifische UI-Frontends und Widgets**:  
   * ui::notifications\_frontend (Popups)  
   * ui::widgets (Sidebar-Widgets)  
   * ui::window\_manager\_frontend  
   * ui::speed\_dial  
   * ui::command\_palette

Diese Priorisierung zielt darauf ab, schnell einen funktionalen Kern der Desktop-Shell zu etablieren und dann schrittweise weitere Funktionen und Anwendungen hinzuzufügen.

### **4.2. Identifizierte Abhängigkeiten und Parallelisierungsmöglichkeiten**

* **Abhängigkeiten**:  
  * Alle Panel-Module hängen von einem stabilen PanelWidget und dessen API ab.  
  * AppMenuButton und SystemTrayEquivalentWidget haben starke Abhängigkeiten von D-Bus-Interaktionen und Wayland-Protokollen (bzw. den Abstraktionsdiensten dafür).  
  * NetworkIndicatorWidget, PowerIndicatorWidget, AudioIndicatorWidget hängen von den entsprechenden D-Bus-Schnittstellen der system-Schicht ab.  
  * NotificationCenterPanelWidget hängt von domain::user\_centric\_services::NotificationService und ui::notifications\_frontend::NotificationPopupWidget ab.  
  * ui::control\_center Module hängen stark von domain::global\_settings\_and\_state\_management::GlobalSettingsService ab.  
* **Parallelisierung**:  
  * Sobald die API des PanelWidget definiert ist, können viele der darin enthaltenen Module (ClockDateTimeWidget, WorkspaceIndicatorWidget, einzelne Indikatoren) parallel entwickelt werden.  
  * Die Entwicklung des ui::control\_center kann weitgehend parallel zur Verfeinerung der ui::shell erfolgen, sobald die GlobalSettingsService-Schnittstelle stabil ist.  
  * Wiederverwendbare Komponenten in ui::components können frühzeitig parallel entwickelt und in anderen Modulen eingesetzt werden.  
  * Die Implementierung der D-Bus-Clients für verschiedene Systemdienste (NetworkManager, UPower, etc.) kann parallelisiert werden.

Eine enge Abstimmung zwischen den Teams, die an abhängigen Modulen arbeiten, ist entscheidend. Die Definition klarer Schnittstellen (GObject-Properties und \-Signale, Rust-Traits) für Module und Dienste erleichtert die parallele Entwicklung und spätere Integration.

#### **Referenzen**

1. gtk4-rs/README.md at main \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/gtk-rs/gtk4-rs/blob/main/README.md](https://github.com/gtk-rs/gtk4-rs/blob/main/README.md)  
2. GTK and Rust \- The GTK Project \- A free and open-source cross-platform widget toolkit, Zugriff am Mai 14, 2025, [https://www.gtk.org/docs/language-bindings/rust](https://www.gtk.org/docs/language-bindings/rust)  
3. gtk4 \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/gtk4](https://docs.rs/gtk4)  
4. Patterns \- The Rust Reference, Zugriff am Mai 14, 2025, [https://doc.rust-lang.org/stable/reference/patterns.html?highlight=Patterns](https://doc.rust-lang.org/stable/reference/patterns.html?highlight=Patterns)  
5. Rust: Project structure example step by step \- DEV Community, Zugriff am Mai 14, 2025, [https://dev.to/ghost/rust-project-structure-example-step-by-step-3ee](https://dev.to/ghost/rust-project-structure-example-step-by-step-3ee)  
6. How to structure files in rust projects? \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/rust/comments/6qbi91/how\_to\_structure\_files\_in\_rust\_projects/](https://www.reddit.com/r/rust/comments/6qbi91/how_to_structure_files_in_rust_projects/)  
7. MainContext in glib \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/glib/latest/glib/struct.MainContext.html](https://docs.rs/glib/latest/glib/struct.MainContext.html)  
8. MainContext in glib \- Rust \- gtk-rs, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.MainContext.html](https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.MainContext.html)  
9. How to force custom GTK4 theme to follow preferred theme? : r/gnome \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/gnome/comments/1kasp2c/how\_to\_force\_custom\_gtk4\_theme\_to\_follow/](https://www.reddit.com/r/gnome/comments/1kasp2c/how_to_force_custom_gtk4_theme_to_follow/)  
10. jbenner-radham/rust-gtk4-css-styling: How to style your ... \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/jbenner-radham/rust-gtk4-css-styling](https://github.com/jbenner-radham/rust-gtk4-css-styling)  
11. Gtk.CssProvider, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.CssProvider.html](https://docs.gtk.org/gtk4/class.CssProvider.html)  
12. zbus \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/](https://docs.rs/zbus/latest/zbus/)  
13. dbus2/zbus: Rust D-Bus crate. \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/dbus2/zbus](https://github.com/dbus2/zbus)  
14. zbus \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/zbus](https://crates.io/crates/zbus)  
15. zbus \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/zbus/3.15.2](https://crates.io/crates/zbus/3.15.2)  
16. Writing a service interface \- zbus: D-Bus for Rust made easy, Zugriff am Mai 14, 2025, [https://dbus2.github.io/zbus/service.html](https://dbus2.github.io/zbus/service.html)  
17. "dbus\_proxy" Search \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/?search=dbus\_proxy](https://docs.rs/zbus/latest/zbus/?search=dbus_proxy)  
18. proxy in zbus \- Rust \- openrr.github.io, Zugriff am Mai 14, 2025, [https://openrr.github.io/openrr/zbus/attr.proxy.html](https://openrr.github.io/openrr/zbus/attr.proxy.html)  
19. Introduction \- zbus: D-Bus for Rust made easy, Zugriff am Mai 14, 2025, [https://dbus2.github.io/zbus/](https://dbus2.github.io/zbus/)  
20. Fighting with zbus implementation \- help \- The Rust Programming Language Forum, Zugriff am Mai 14, 2025, [https://users.rust-lang.org/t/fighting-with-zbus-implementation/106696](https://users.rust-lang.org/t/fighting-with-zbus-implementation/106696)  
21. Gio – 2.0 \- GTK Documentation, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gio/index.html](https://docs.gtk.org/gio/index.html)  
22. Zugriff am Januar 1, 1970, [https://github.com/dbus2/zbus/tree/main/zbus/examples](https://github.com/dbus2/zbus/tree/main/zbus/examples)  
23. Gtk – 4.0: Accessibility, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/section-accessibility.html](https://docs.gtk.org/gtk4/section-accessibility.html)  
24. Ultimate Rust Performance Optimization Guide 2024: Basics to Advanced \- Rapid Innovation, Zugriff am Mai 14, 2025, [https://www.rapidinnovation.io/post/performance-optimization-techniques-in-rust](https://www.rapidinnovation.io/post/performance-optimization-techniques-in-rust)  
25. Ultimate Rust FPS Optimization Guide ✔️ \- YouTube, Zugriff am Mai 14, 2025, [https://m.youtube.com/watch?v=lQxeBhTgPEQ](https://m.youtube.com/watch?v=lQxeBhTgPEQ)  
26. wmww/gtk4-layer-shell: A library to create panels and other ... \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/wmww/gtk4-layer-shell](https://github.com/wmww/gtk4-layer-shell)  
27. gtk4-layer-shell \- crates.io: Rust Package Registry, Zugriff am Mai 14, 2025, [https://crates.io/crates/gtk4-layer-shell](https://crates.io/crates/gtk4-layer-shell)  
28. gtk4-layer-shell/examples/simple-example.c at main \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/wmww/gtk4-layer-shell/blob/main/examples/simple-example.c](https://github.com/wmww/gtk4-layer-shell/blob/main/examples/simple-example.c)  
29. LayerShell in gtk\_layer\_shell \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/gtk-layer-shell/latest/gtk\_layer\_shell/trait.LayerShell.html](https://docs.rs/gtk-layer-shell/latest/gtk_layer_shell/trait.LayerShell.html)  
30. drkrssll/chunks-rs: Simplifies the process of making GTK4 widgets for wayland compositors. \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/drkrssll/chunks-rs/](https://github.com/drkrssll/chunks-rs/)  
31. Zugriff am Januar 1, 1970, [https://github.com/pentamassiv/gtk4-layer-shell-gir/tree/main/gtk4-layer-shell/examples](https://github.com/pentamassiv/gtk4-layer-shell-gir/tree/main/gtk4-layer-shell/examples)  
32. Zugriff am Januar 1, 1970, [https://github.com/pentamassiv/gtk4-layer-shell-gir/tree/main/examples](https://github.com/pentamassiv/gtk4-layer-shell-gir/tree/main/examples)  
33. Zugriff am Januar 1, 1970, [https://docs.rs/gtk4-layer-shell/latest/gtk\_layer\_shell/trait.LayerShell.html](https://docs.rs/gtk4-layer-shell/latest/gtk_layer_shell/trait.LayerShell.html)  
34. DrawingArea in gtk4 \- Rust \- gtk-rs, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/0.8/docs/gtk4/struct.DrawingArea.html](https://gtk-rs.org/gtk4-rs/stable/0.8/docs/gtk4/struct.DrawingArea.html)  
35. gtk4/NEWS.pre-4.0 at layer-shell\_impish \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/pop-os/gtk4/blob/layer-shell\_impish/NEWS.pre-4.0](https://github.com/pop-os/gtk4/blob/layer-shell_impish/NEWS.pre-4.0)  
36. Gtk – 4.0: GTK CSS Properties, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/css-properties.html](https://docs.gtk.org/gtk4/css-properties.html)  
37. DrawingArea in gtk4 \- Rust \- gtk-rs, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/0.5/docs/gtk4/struct.DrawingArea.html](https://gtk-rs.org/gtk4-rs/stable/0.5/docs/gtk4/struct.DrawingArea.html)  
38. DrawingArea in gtk4 \- Rust \- gtk-rs, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.DrawingArea.html](https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.DrawingArea.html)  
39. How do I create a glow effect like this? I tried gaussian blur, but it doesn't really look like this : r/krita \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/krita/comments/1j7innz/how\_do\_i\_create\_a\_glow\_effect\_like\_this\_i\_tried/](https://www.reddit.com/r/krita/comments/1j7innz/how_do_i_create_a_glow_effect_like_this_i_tried/)  
40. Creating a highlight effect with the cairo library \- Stack Overflow, Zugriff am Mai 14, 2025, [https://stackoverflow.com/questions/9955964/creating-a-highlight-effect-with-the-cairo-library](https://stackoverflow.com/questions/9955964/creating-a-highlight-effect-with-the-cairo-library)  
41. Cooking with Cairo \- Cairo graphics library, Zugriff am Mai 14, 2025, [https://www.cairographics.org/cookbook/](https://www.cairographics.org/cookbook/)  
42. GtkBox, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.Box.html](https://docs.gtk.org/gtk4/class.Box.html)  
43. IsA for subclasses in GTK Rust \- Stack Overflow, Zugriff am Mai 14, 2025, [https://stackoverflow.com/questions/75623312/isa-for-subclasses-in-gtk-rust](https://stackoverflow.com/questions/75623312/isa-for-subclasses-in-gtk-rust)  
44. gtk4-rs/book/listings/actions/6/resources/window.ui at main \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/6/resources/window.ui](https://github.com/gtk-rs/gtk4-rs/blob/main/book/listings/actions/6/resources/window.ui)  
45. How to make gtk4-rs use native windows decorations? : r/rust \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/rust/comments/1jdm50v/how\_to\_make\_gtk4rs\_use\_native\_windows\_decorations/](https://www.reddit.com/r/rust/comments/1jdm50v/how_to_make_gtk4rs_use_native_windows_decorations/)  
46. Gtk.ApplicationWindow, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.ApplicationWindow.html](https://docs.gtk.org/gtk4/class.ApplicationWindow.html)  
47. Properties \- GUI development with Rust and GTK 4, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/latest/book/g\_object\_properties.html](https://gtk-rs.org/gtk4-rs/stable/latest/book/g_object_properties.html)  
48. Zugriff am Januar 1, 1970, [https://gtk-rs.org/gtk4-rs/stable/latest/book/gobject\_properties.html](https://gtk-rs.org/gtk4-rs/stable/latest/book/gobject_properties.html)  
49. GObject – 2.0 \- GTK Documentation, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gobject/index.html](https://docs.gtk.org/gobject/index.html)  
50. Zugriff am Januar 1, 1970, [https://gtk-rs.org/gtk4-rs/stable/latest/docs/glib/index.html](https://gtk-rs.org/gtk4-rs/stable/latest/docs/glib/index.html)  
51. Memory Management \- GUI development with Rust and GTK 4, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/latest/book/g\_object\_memory\_management.html](https://gtk-rs.org/gtk4-rs/stable/latest/book/g_object_memory_management.html)  
52. glib \- Rust \- gtk-rs, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/](https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/)  
53. Zugriff am Januar 1, 1970, [https://gtk-rs.org/gtk4-rs/stable/latest/book/gobject\_memory\_management.html](https://gtk-rs.org/gtk4-rs/stable/latest/book/gobject_memory_management.html)  
54. GLib – 2.0 \- GTK Documentation, Zugriff am Mai 14, 2025, [https://docs.gtk.org/glib/index.html](https://docs.gtk.org/glib/index.html)  
55. Counter App with GTK4 CompositeTemplate and Rust \- DEV Community, Zugriff am Mai 14, 2025, [https://dev.to/kashifsoofi/counter-app-with-gtk4-compositetemplate-and-rust-h0p](https://dev.to/kashifsoofi/counter-app-with-gtk4-compositetemplate-and-rust-h0p)  
56. Composite Templates \- GUI development with Rust and GTK 4, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/latest/book/composite\_templates.html](https://gtk-rs.org/gtk4-rs/stable/latest/book/composite_templates.html)  
57. Writing a Custom GTK widget with template UI files \- Stack Overflow, Zugriff am Mai 14, 2025, [https://stackoverflow.com/questions/77768792/writing-a-custom-gtk-widget-with-template-ui-files](https://stackoverflow.com/questions/77768792/writing-a-custom-gtk-widget-with-template-ui-files)  
58. Counter App with GTK4 CompositeTemplate and Rust \- Kashif Soofi, Zugriff am Mai 14, 2025, [https://kashifsoofi.github.io/gtk4/rust/gtk4-rust-counter-app-with-template/](https://kashifsoofi.github.io/gtk4/rust/gtk4-rust-counter-app-with-template/)  
59. Building a Simple To-Do App \- GUI development with Rust and GTK 4, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/latest/book/todo\_1.html](https://gtk-rs.org/gtk4-rs/stable/latest/book/todo_1.html)  
60. Introduction \- GUI development with Rust and GTK 4 \- gtk-rs, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/latest/book/introduction.html](https://gtk-rs.org/gtk4-rs/stable/latest/book/introduction.html)  
61. Gtk.Builder \- GTK Documentation, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.Builder.html](https://docs.gtk.org/gtk4/class.Builder.html)  
62. Box in gtk4 \- Rust \- gtk-rs, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Box.html](https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Box.html)  
63. Gtk.CenterBox, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.CenterBox.html](https://docs.gtk.org/gtk4/class.CenterBox.html)  
64. Zugriff am Januar 1, 1970, [https://docs.gtk.org/gtk4/section-drawing-model.html](https://docs.gtk.org/gtk4/section-drawing-model.html)  
65. Zugriff am Januar 1, 1970, [https://gtk-rs.org/gtk4-rs/stable/latest/docs/cairo/index.html](https://gtk-rs.org/gtk4-rs/stable/latest/docs/cairo/index.html)  
66. Pango – 1.0 \- GTK Documentation, Zugriff am Mai 14, 2025, [https://docs.gtk.org/Pango/index.html](https://docs.gtk.org/Pango/index.html)  
67. cairo-rs 0.20.7 \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/cairo-rs/latest/cairo/struct.ImageSurface.html](https://docs.rs/cairo-rs/latest/cairo/struct.ImageSurface.html)  
68. Gtk.Widget, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.Widget.html](https://docs.gtk.org/gtk4/class.Widget.html)  
69. Gtk.Settings, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.Settings.html](https://docs.gtk.org/gtk4/class.Settings.html)  
70. geting the coordinates of the user's mouse pointer in GTK4 in C \- Stack Overflow, Zugriff am Mai 14, 2025, [https://stackoverflow.com/questions/79016771/geting-the-coordinates-of-the-users-mouse-pointer-in-gtk4-in-c](https://stackoverflow.com/questions/79016771/geting-the-coordinates-of-the-users-mouse-pointer-in-gtk4-in-c)  
71. Gtk.EventControllerMotion, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.EventControllerMotion.html](https://docs.gtk.org/gtk4/class.EventControllerMotion.html)  
72. thiserror \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/thiserror/latest/thiserror/](https://docs.rs/thiserror/latest/thiserror/)  
73. tracing \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/tracing/latest/tracing/](https://docs.rs/tracing/latest/tracing/)  
74. Gdk.Display, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gdk4/class.Display.html](https://docs.gtk.org/gdk4/class.Display.html)  
75. Gdk.Monitor, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gdk4/class.Monitor.html](https://docs.gtk.org/gdk4/class.Monitor.html)  
76. Gtk.Widget:tooltip-text, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/property.Widget.tooltip-text.html](https://docs.gtk.org/gtk4/property.Widget.tooltip-text.html)  
77. Gtk.Button, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.Button.html](https://docs.gtk.org/gtk4/class.Button.html)  
78. Gtk.MenuButton, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.MenuButton.html](https://docs.gtk.org/gtk4/class.MenuButton.html)  
79. Gtk.PopoverMenu, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.PopoverMenu.html](https://docs.gtk.org/gtk4/class.PopoverMenu.html)  
80. PopoverMenu in gtk4 \- Rust \- gtk-rs, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.PopoverMenu.html](https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.PopoverMenu.html)  
81. API changes in GTK4: removal of GtkMenu : r/GTK \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/GTK/comments/xdfgjr/api\_changes\_in\_gtk4\_removal\_of\_gtkmenu/](https://www.reddit.com/r/GTK/comments/xdfgjr/api_changes_in_gtk4_removal_of_gtkmenu/)  
82. Zugriff am Januar 1, 1970, [https://docs.gtk.org/gtk4/method.PopoverMenu.new\_from\_model.html](https://docs.gtk.org/gtk4/method.PopoverMenu.new_from_model.html)  
83. Gtk.Popover, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.Popover.html](https://docs.gtk.org/gtk4/class.Popover.html)  
84. Gtk.Image \- GTK Documentation, Zugriff am Mai 14, 2025, [https://docs.gtk.org/gtk4/class.Image.html](https://docs.gtk.org/gtk4/class.Image.html)  
85. I want to create a window switcher for Linux. Is a Wayland client the correct approach?, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/linux/comments/1juzcto/i\_want\_to\_create\_a\_window\_switcher\_for\_linux\_is\_a/](https://www.reddit.com/r/linux/comments/1juzcto/i_want_to_create_a_window_switcher_for_linux_is_a/)  
86. wlr foreign toplevel management protocol \- Wayland Explorer, Zugriff am Mai 14, 2025, [https://wayland.app/protocols/wlr-foreign-toplevel-management-unstable-v1](https://wayland.app/protocols/wlr-foreign-toplevel-management-unstable-v1)  
87. Zugriff am Januar 1, 1970, [https://wayland.freedesktop.org/protocols/wlr-foreign-toplevel-management-unstable-v1.html](https://wayland.freedesktop.org/protocols/wlr-foreign-toplevel-management-unstable-v1.html)  
88. Zugriff am Januar 1, 1970, [https://docs.rs/smithay-client-toolkit/latest/smithay\_client\_toolkit/shell/foreign\_toplevel/index.html](https://docs.rs/smithay-client-toolkit/latest/smithay_client_toolkit/shell/foreign_toplevel/index.html)  
89. Zugriff am Januar 1, 1970, [https://docs.rs/wayland-protocols/latest/wayland\_protocols/wlr/unstable/foreign\_toplevel\_management/v1/client/index.html](https://docs.rs/wayland-protocols/latest/wayland_protocols/wlr/unstable/foreign_toplevel_management/v1/client/index.html)  
90. wayland\_protocols::ext::foreign\_toplevel\_list::v1::client::ext\_foreign\_toplevel\_list\_v1 \- Rust, Zugriff am Mai 14, 2025, [https://pop-os.github.io/libcosmic/wayland\_protocols/ext/foreign\_toplevel\_list/v1/client/ext\_foreign\_toplevel\_list\_v1/index.html](https://pop-os.github.io/libcosmic/wayland_protocols/ext/foreign_toplevel_list/v1/client/ext_foreign_toplevel_list_v1/index.html)  
91. Projects/GLib/GApplication/DBusAPI – GNOME Wiki Archive, Zugriff am Mai 14, 2025, [https://wiki.gnome.org/Projects/GLib/GApplication/DBusAPI](https://wiki.gnome.org/Projects/GLib/GApplication/DBusAPI)  
92. gtk/gtk/gtkapplication-dbus.c at main · GNOME/gtk \- GitHub, Zugriff am Mai 14, 2025, [https://github.com/GNOME/gtk/blob/master/gtk/gtkapplication-dbus.c](https://github.com/GNOME/gtk/blob/master/gtk/gtkapplication-dbus.c)  
93. D-Bus \- GNOME JavaScript, Zugriff am Mai 14, 2025, [https://gjs.guide/guides/gio/dbus.html](https://gjs.guide/guides/gio/dbus.html)  
94. Menus \- GNOME Developer Documentation, Zugriff am Mai 14, 2025, [https://developer.gnome.org/documentation/tutorials/menus.html](https://developer.gnome.org/documentation/tutorials/menus.html)  
95. Application menu / Actions \- GNOME Wiki, Zugriff am Mai 14, 2025, [https://wiki.gnome.org/ThreePointThree(2f)Features(2f)ApplicationMenu.html](https://wiki.gnome.org/ThreePointThree\(2f\)Features\(2f\)ApplicationMenu.html)  
96. Zugriff am Januar 1, 1970, [https://docs.gtk.org/gio/struct.DBusMenuModel.html](https://docs.gtk.org/gio/struct.DBusMenuModel.html)  
97. rust-zbus package : Ubuntu \- Launchpad, Zugriff am Mai 14, 2025, [https://launchpad.net/ubuntu/+source/rust-zbus](https://launchpad.net/ubuntu/+source/rust-zbus)  
98. Global Menu — helloSystem documentation, Zugriff am Mai 14, 2025, [https://hellosystem.github.io/docs/developer/menu.html](https://hellosystem.github.io/docs/developer/menu.html)  
99. Zugriff am Januar 1, 1970, [https://docs.rs/zbus/latest/zbus/struct.Proxy.html](https://docs.rs/zbus/latest/zbus/struct.Proxy.html)  
100. smithay\_client\_toolkit::foreign\_toplevel\_list \- Rust, Zugriff am Mai 14, 2025, [https://smithay.github.io/client-toolkit/smithay\_client\_toolkit/foreign\_toplevel\_list/index.html](https://smithay.github.io/client-toolkit/smithay_client_toolkit/foreign_toplevel_list/index.html)  
101. Zugriff am Januar 1, 1970, [https://github.com/smithay/smithay-client-toolkit/tree/master/examples](https://github.com/smithay/smithay-client-toolkit/tree/master/examples)  
102. StatusNotifierItem \- Freedesktop.org, Zugriff am Mai 14, 2025, [https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/](https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/)  
103. StatusNotifierItem \- Freedesktop.org, Zugriff am Mai 14, 2025, [https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierItem/](https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierItem/)  
104. Where are status icons in Gnome 40/GTK 4? \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/gnome/comments/u9tq1k/where\_are\_status\_icons\_in\_gnome\_40gtk\_4/](https://www.reddit.com/r/gnome/comments/u9tq1k/where_are_status_icons_in_gnome_40gtk_4/)  
105. Introduce support for GTK 4 · Issue \#22 · AyatanaIndicators/libayatana-appindicator-glib, Zugriff am Mai 14, 2025, [https://github.com/AyatanaIndicators/libayatana-appindicator-glib/issues/22](https://github.com/AyatanaIndicators/libayatana-appindicator-glib/issues/22)  
106. StatusNotifierHost \- Freedesktop.org, Zugriff am Mai 14, 2025, [https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierHost/](https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierHost/)  
107. StatusNotifierWatcher \- Freedesktop.org, Zugriff am Mai 14, 2025, [https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierWatcher/](https://www.freedesktop.org/wiki/Specifications/StatusNotifierItem/StatusNotifierWatcher/)  
108. Zugriff am Januar 1, 1970, [https://www.freedesktop.org/wiki/Specifications/StatusNotifierHost/](https://www.freedesktop.org/wiki/Specifications/StatusNotifierHost/)  
109. Writing a client proxy \- zbus: D-Bus for Rust made easy \- GitHub Pages, Zugriff am Mai 14, 2025, [https://dbus2.github.io/zbus/client.html](https://dbus2.github.io/zbus/client.html)  
110. NameOwnerChanged in zbus::fdo \- Rust \- openrr.github.io, Zugriff am Mai 14, 2025, [https://openrr.github.io/openrr/zbus/fdo/struct.NameOwnerChanged.html](https://openrr.github.io/openrr/zbus/fdo/struct.NameOwnerChanged.html)  
111. zbus::fdo \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/zbus/latest/zbus/fdo/index.html](https://docs.rs/zbus/latest/zbus/fdo/index.html)  
112. Zbus: catching signal with a destination \- help \- The Rust Programming Language Forum, Zugriff am Mai 14, 2025, [https://users.rust-lang.org/t/zbus-catching-signal-with-a-destination/125709](https://users.rust-lang.org/t/zbus-catching-signal-with-a-destination/125709)  
113. Zugriff am Januar 1, 1970, [https://docs.rs/zbus/latest/zbus/struct.Connection.html](https://docs.rs/zbus/latest/zbus/struct.Connection.html)  
114. Zugriff am Januar 1, 1970, [https://docs.rs/zbus/latest/zbus/fdo/struct.NameOwnerChangedArgs.html](https://docs.rs/zbus/latest/zbus/fdo/struct.NameOwnerChangedArgs.html)  
115. Signals \- GUI development with Rust and GTK 4, Zugriff am Mai 14, 2025, [https://gtk-rs.org/gtk4-rs/stable/latest/book/g\_object\_signals.html](https://gtk-rs.org/gtk4-rs/stable/latest/book/g_object_signals.html)  
116. icon-theme-spec \- Freedesktop.org, Zugriff am Mai 14, 2025, [https://www.freedesktop.org/wiki/Specifications/icon-theme-spec/](https://www.freedesktop.org/wiki/Specifications/icon-theme-spec/)  
117. Zugriff am Januar 1, 1970, [https://gtk-rs.org/gtk4-rs/stable/latest/docs/gdk\_pixbuf/index.html](https://gtk-rs.org/gtk4-rs/stable/latest/docs/gdk_pixbuf/index.html)  
118. Zugriff am Januar 1, 1970, [https://docs.rs/gdk-pixbuf/latest/gdk\_pixbuf/struct.PixbufLoader.html](https://docs.rs/gdk-pixbuf/latest/gdk_pixbuf/struct.PixbufLoader.html)  
119. dbusmenu\_glib \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/dbusmenu-glib](https://docs.rs/dbusmenu-glib)  
120. System Tray Icons in GTK4? \- Platform \- GNOME Discourse, Zugriff am Mai 14, 2025, [https://discourse.gnome.org/t/system-tray-icons-in-gtk4/22615](https://discourse.gnome.org/t/system-tray-icons-in-gtk4/22615)  
121. Correct way of state management for gtk-rs? : r/rust \- Reddit, Zugriff am Mai 14, 2025, [https://www.reddit.com/r/rust/comments/1czodm3/correct\_way\_of\_state\_management\_for\_gtkrs/](https://www.reddit.com/r/rust/comments/1czodm3/correct_way_of_state_management_for_gtkrs/)  
122. Gtk4 \- how to deploy complex event handlers \- help \- Rust Users Forum, Zugriff am Mai 14, 2025, [https://users.rust-lang.org/t/gtk4-how-to-deploy-complex-event-handlers/88170](https://users.rust-lang.org/t/gtk4-how-to-deploy-complex-event-handlers/88170)  
123. once\_cell \- Rust \- Docs.rs, Zugriff am Mai 14, 2025, [https://docs.rs/once\_cell/latest/once\_cell/](https://docs.rs/once_cell/latest/once_cell/)



**Grundidee des Model Context Protocol (MCP):**

Ein MCP würde es verschiedenen Komponenten des Desktops (Anwendungen, Desktop-Shell, Widgets, Assistenten) ermöglichen, Informationen über den aktuellen Benutzerkontext sicher und effizient auszutauschen. "Modell" könnte sich hier auf ein Datenmodell für den Kontext oder auf KI-Modelle beziehen, die diesen Kontext nutzen.

**Phase 1: Konzeptuelle Architektur und Hypothesenformulierung**

1. **Epistemologischer Rahmen & Prämissen:**
    
    - **Ziel:** Verbesserung der Benutzererfahrung durch proaktive, kontextsensitive Unterstützung und Reduzierung repetitiver Aufgaben.
    - **Prämisse 1:** Ein standardisiertes Kontextprotokoll ist notwendig für Interoperabilität.
    - **Prämisse 2:** Benutzer müssen die volle Kontrolle über die Freigabe ihres Kontexts haben (Datenschutz).
    - **Prämisse 3:** Die Integration muss ressourcenschonend sein.
2. **Kernkonzepte & Taxonomie:**
    
    - **Context Provider:** Anwendungen (Texteditor, Browser, Kalender), Systemdienste (Standort, Netzwerk), Desktop-Shell.
    - **Context Consumer:** Desktop-Assistenten, Suchfunktionen, Automatisierungstools, App-Switcher, Benachrichtigungssysteme.
    - **Context Broker:** Eine zentrale Instanz (wahrscheinlich über D-Bus), die Kontextinformationen sammelt, filtert und verteilt.
    - **Context Data Model:** Ein standardisiertes Format (z.B. JSON-LD, ActivityStreams-ähnlich) zur Beschreibung von Kontext-Entitäten (Dokument, Aufgabe, Ort, Person, Ereignis) und deren Beziehungen.
    - **Permission Management:** System zur Verwaltung von Zugriffsrechten auf Kontextdaten.
3. **Hypothesen:**
    
    - **H1 (Sinnhaftigkeit):** Durch MCP können Anwendungen dem Benutzer relevantere Informationen und Aktionen anbieten.
    - **H2 (Benutzerfreundlichkeit):** Eine klare und granulare Kontrolle über die Kontextfreigabe erhöht die Akzeptanz.
    - **H3 (Effizienz):** MCP reduziert die Notwendigkeit für den Benutzer, Informationen manuell zwischen Anwendungen zu kopieren/übertragen.
4. **Operationalisierbare Variablen:**
    
    - Zeitersparnis bei Standardaufgaben.
    - Anzahl der Klicks/Aktionen reduziert.
    - Benutzerzufriedenheit (Umfragen).
    - Adoptionsrate des Protokolls durch Anwendungen.

**Phase 2: Systematische Literaturanalyse und Wissenskartographie**

1. **Recherche existierender Ansätze:**
    - **D-Bus:** Als zugrundeliegende IPC-Mechanismus in Linux-Desktops.
    - **Freedesktop.org-Spezifikationen:** z.B. für Benachrichtigungen, Status-Icons, MIME-Typen.
    - **Nepomuk/Baloo (KDE):** Frühere Versuche semantischer Desktops und deren Herausforderungen (Performance, Komplexität).
    - **ActivityStreams:** Web-Standard zur Beschreibung sozialer Aktivitäten, potenziell adaptierbar.
    - **Telepathy:** Framework für Echtzeitkommunikation.
    - **Mobile OS-Ansätze:** Android Intents, iOS App Intents/Shortcuts für App-Interaktion und Kontext.
2. **Identifikation von Lücken:** Aktuell kein umfassendes, desktopweites, standardisiertes Protokoll für feingranularen Anwendungskontext.

**Phase 3: Datenakquisition und Multi-Methoden-Triangulation (Design-Phase)**

Entwurf des MCP:

1. **Protokoll-Spezifikation:**
    - **Transport:** D-Bus ist die naheliegendste Wahl. Definition von D-Bus-Interfaces, -Methoden und -Signalen.
    - **Datenformat:** Z.B. JSON-basiert mit einem klaren Schema. Überlegung zu Vokabularen (Schema.org könnte Inspiration bieten).
    - **Kernkontext-Typen:** "AktivesDokument", "AusgewählterText", "AktuelleAufgabe", "Standort", "BevorstehendesEreignis", "Kommunikationspartner".
2. **API-Design:**
    - Bibliotheken (z.B. in C/GLib, Qt, Python, Vala) für Anwendungsentwickler zur einfachen Integration.
    - APIs für das Publizieren von Kontext und das Abonnieren von Kontextänderungen.
3. **Permission-Modell:**
    - Integration in bestehende Systeme (z.B. Flatpak Portals, systemweite Datenschutzeinstellungen).
    - Granulare Kontrolle: Pro Anwendung, pro Kontext-Typ.
    - Transparenz: Der Benutzer muss sehen können, welche Anwendung welchen Kontext teilt und wer darauf zugreift.

**Integration in die Linux Desktopumgebung (Sinnvoll & Benutzerfreundlich):**

1. **Zentrale Konfigurationsschnittstelle:**
    
    - Ein Modul in den Systemeinstellungen (z.B. GNOME Control Center, KDE System Settings).
    - **Benutzerfreundlich:** Klare Auflistung aller Apps, die Kontext teilen oder nutzen können. Einfache Schalter zum Aktivieren/Deaktivieren pro App und pro Kontext-Typ.
    - **Sinnvoll:** Standardeinstellungen, die einen guten Kompromiss zwischen Nutzen und Datenschutz bieten (z.B. Kontext nur mit explizit vertrauenswürdigen Systemkomponenten teilen).
2. **Integration in die Desktop-Shell (GNOME Shell, KDE Plasma, etc.):**
    
    - **Globale Suche:** Suchergebnisse basierend auf dem aktuellen Kontext priorisieren (z.B. suche "Bericht" – finde zuerst den Bericht, an dem ich gerade arbeite).
    - **Task-Switcher/Activity Overview:** Zusätzliche Kontextinformationen zu laufenden Anwendungen anzeigen.
    - **Benachrichtigungssystem:** Intelligentere Benachrichtigungen, die den aktuellen Fokus berücksichtigen (z.B. stumm schalten, wenn in Präsentation).
    - **Sinnvoll:** Macht die Shell proaktiver und informativer.
    - **Benutzerfreundlich:** Nahtlose Integration, keine zusätzliche Lernkurve.
3. **Integration in Kernanwendungen:**
    
    - **Dateimanager:** Kontextmenü-Optionen basierend auf dem globalen Kontext (z.B. "An E-Mail mit aktueller Aufgabe anhängen").
    - **Texteditor/IDE:** Code-Vervollständigung oder Dokumentationssuche basierend auf dem Projektkontext, der auch andere Tools umfasst.
    - **E-Mail-Client/Kalender:** Automatische Verknüpfung von E-Mails mit relevanten Dokumenten oder Kalendereinträgen basierend auf dem Kontext.
    - **Browser:** Vorschläge basierend auf dem Inhalt anderer aktiver Anwendungen.
    - **Sinnvoll:** Reduziert manuelle Schritte, fördert Workflows.
    - **Benutzerfreundlich:** Aktionen werden dort angeboten, wo sie gebraucht werden.
4. **Unterstützung für Desktop-Assistenten (Mycroft, Rhasspy, oder zukünftige):**
    
    - **Sinnvoll:** Ermöglicht Assistenten, wirklich "wissend" über die aktuelle Benutzeraktivität zu sein, ohne auf Screen-Scraping oder unsichere Methoden zurückgreifen zu müssen.
        - "Speichere dieses Dokument und sende einen Link an Max Mustermann bezüglich des Projekts Alpha."
        - "Erinnere mich an diese Webseite, wenn ich morgen an meinem Bericht arbeite."
    - **Benutzerfreundlich:** Natürlichsprachliche Interaktion wird mächtiger und relevanter.
5. **Entwicklerfreundlichkeit:**
    
    - **Sinnvoll:** Klare Dokumentation, Beispielimplementierungen, Test-Tools.
    - **Benutzerfreundlich (für Entwickler):** Einfach zu integrierende Bibliotheken, geringer Overhead. Anreize zur Adoption (z.B. Feature in Desktop-Umgebung hervorgehoben).
6. **Datenschutz und Sicherheit als Kernprinzip:**
    
    - **Sinnvoll & Benutzerfreundlich:**
        - **Transparenz:** Der Benutzer muss jederzeit sehen, welche Kontextdaten erfasst und von wem sie genutzt werden. Visuelle Indikatoren.
        - **Kontrolle:** Opt-in statt Opt-out für die meisten Kontextfreigaben. Möglichkeit, den Kontext-Verlauf zu löschen.
        - **Anonymisierung/Aggregation:** Wo möglich, Kontext aggregiert oder anonymisiert teilen.
        - **Sichere Speicherung:** Wenn Kontextdaten persistiert werden, dann verschlüsselt und lokal.
        - **Sandboxing:** Integration mit Flatpak/Snap-Portalen für sicheren Zugriff.

**Beispiele für sinnvolle und benutzerfreundliche Anwendungsfälle:**

- **Intelligente Zwischenablage:** Wenn Text aus einer E-Mail kopiert wird und in einen Task-Manager eingefügt wird, könnte das MCP den Betreff der E-Mail als potenziellen Task-Titel vorschlagen.
- **Automatisierte Workflows:** Beim Öffnen eines bestimmten Projektordners im Dateimanager könnte das MCP assoziierte Anwendungen (IDE, Terminal mit richtigem Pfad, Notizen-App mit Projektnotizen) vorschlagen oder automatisch starten.
- **Proaktive Hilfe:** Wenn der Benutzer in einer Anwendung auf einen Fehler stößt, könnte das MCP (mit Zustimmung) kontextrelevante Log-Dateien oder Hilfeseiten identifizieren.
- **Barrierefreiheit:** Assistive Technologien könnten den detaillierten Kontext nutzen, um Benutzern mit Einschränkungen eine reichhaltigere Interaktion zu ermöglichen.

**Herausforderungen:**

- **Standardisierung:** Einigung auf ein gemeinsames Protokoll und Datenmodell über verschiedene Desktop-Umgebungen und Toolkits hinweg. Freedesktop.org wäre die richtige Anlaufstelle.
- **Adoption:** Entwickler müssen den Mehrwert sehen, um das Protokoll in ihre Anwendungen zu integrieren.
- **Performance:** Der Kontextaustausch darf das System nicht verlangsamen.
- **Komplexität vs. Nutzen:** Das Protokoll muss mächtig genug sein, aber einfach genug für Entwickler und verständlich für Benutzer.
- **Sicherheitsrisiken:** Ein kompromittierter Context Broker könnte sensible Daten leaken.

**Fazit:**

Die Integration eines "Model Context Protocol" in eine Linux-Desktopumgebung erfordert einen durchdachten, standardisierten Ansatz mit starkem Fokus auf Benutzerkontrolle und Datenschutz. Über D-Bus als Transportmechanismus und eine klare API könnten Anwendungen und Systemdienste einen reichen, gemeinsamen Kontext aufbauen. Dies würde intelligentere, proaktivere und letztlich benutzerfreundlichere Desktop-Erfahrungen ermöglichen, indem Workflows vereinfacht, relevante Informationen zur richtigen Zeit bereitgestellt und die Effizienz gesteigert wird. Der Schlüssel zum Erfolg liegt in der offenen Zusammenarbeit, einer guten Entwicklererfahrung und dem unbedingten Schutz der Privatsphäre der Nutzer.
# Detaillierte Technische Spezifikation: KI-Integration (domain::ai)

## I. Einleitung

### A. Zweck und Geltungsbereich

Dieses Dokument spezifiziert die Implementierung des Moduls `domain::ai`, das für die Verwaltung der Interaktion der Desktop-Umgebung mit KI-Modellen verantwortlich ist.

Es legt den Schwerpunkt auf die sichere und kontrollierte Einbindung von KI-Funktionalitäten, insbesondere die Handhabung der Benutzereinwilligung bezüglich des Zugriffs auf deren Daten.

### B. Modulverantwortlichkeiten

Das `domain::ai`-Modul übernimmt folgende Aufgaben:

- Verwaltung des Lebenszyklus von KI-Interaktionskontexten.
    
    - Bereitstellung von Strukturen und Logik zur Nachverfolgung einzelner KI-Sitzungen oder Anfragen.
- Implementierung der Logik für das Einholen, Speichern und Überprüfen von Benutzereinwilligungen (AIConsent) für die Nutzung von KI-Modellen und den Zugriff auf spezifische Datenkategorien (AIDataCategory).
    
    - Definition von Mechanismen, um zu bestimmen, welche Daten für eine bestimmte KI-Aktion erforderlich sind und ob der Benutzer die Verwendung dieser Daten erlaubt hat.
- Verwaltung von Profilen verfügbarer KI-Modelle (AIModelProfile).
    
    - Katalogisierung der Fähigkeiten und Anforderungen verschiedener KI-Modelle, um eine korrekte Einwilligungsverwaltung zu gewährleisten.
- Bereitstellung einer Schnittstelle zur Initiierung von KI-Aktionen und zur Verarbeitung von deren Ergebnissen, unabhängig vom spezifischen KI-Modell oder dem MCP-Protokoll (welches in der Systemschicht implementiert wird).
    
    - Abstraktion der Kommunikation mit den KI-Modellen, um die Kompatibilität zu erhöhen und den Aufwand für andere Module zu minimieren.

### C. Nicht-Zuständigkeiten

Dieses Modul ist nicht verantwortlich für:

- Die Implementierung der UI-Elemente zur Darstellung von KI-Interaktionen oder Einwilligungsabfragen (Aufgabe der Benutzeroberflächenschicht).
    
- Die direkte Kommunikation mit KI-Modellen oder externen Diensten (Aufgabe der Systemschicht, insbesondere des MCP-Clients).
    
- Die Persistenz von Einwilligungen oder Modellprofilen (Delegiert an die Core Layer, z.B. core::config).
    

## II. Datenstrukturen

### A. Kernentitäten

1. **AIInteractionContext**
    
    - Zweck: Repräsentiert eine spezifische Interaktion oder einen Dialog mit einer KI.
        
    - Attribute:
        - `id`: `Uuid` (öffentlich): Eindeutiger Identifikator für den Kontext.
            
        - `creation_timestamp`: `DateTime<Utc>` (öffentlich): Zeitpunkt der Erstellung.
            
        - `active_model_id`: `Option<String>` (öffentlich): ID des aktuell für diesen Kontext relevanten KI-Modells.
            
        - `consent_status`: `AIConsentStatus` (öffentlich): Aktueller Einwilligungsstatus für diesen Kontext.
            
        - `associated_data_categories`: `Vec<AIDataCategory>` (öffentlich): Kategorien von Daten, die für diese Interaktion relevant sein könnten.
            
        - `interaction_history`: `Vec<String>` (privat): Eine einfache Historie der Konversation (z.B. Benutzeranfragen, KI-Antworten).
            
        - `attachments`: `Vec<AttachmentData>` (öffentlich): Angehängte Daten (z.B. Dateipfade, Text-Snippets).
            
    - Invarianten:
        - `id` und `creation_timestamp` sind nach der Erstellung unveränderlich.
            
    - Methoden (konzeptionell):
        - `new(relevant_categories: Vec<AIDataCategory>, initial_attachments: Option<Vec<AttachmentData>>) -> Self`: Erstellt einen neuen Kontext.
        - `update_consent_status(&mut self, status: AIConsentStatus)`: Aktualisiert den Einwilligungsstatus.
            
        - `set_active_model(&mut self, model_id: String)`: Legt das aktive Modell fest.
        - `add_history_entry(&mut self, entry: String)`: Fügt einen Eintrag zur Historie hinzu.
            
        - `add_attachment(&mut self, attachment: AttachmentData)`: Fügt einen Anhang hinzu.
2. **AIConsent**
    
    - Zweck: Repräsentiert die Einwilligung eines Benutzers für eine spezifische Kombination aus KI-Modell und Datenkategorien.
        
    - Attributes:
        - `id`: `Uuid` (öffentlich): Eindeutiger Identifikator für die Einwilligung.
            
        - `user_id`: `String` (öffentlich): Identifikator des Benutzers.
            
        - `model_id`: `String` (öffentlich): ID des KI-Modells, für das die Einwilligung gilt.
            
        - `data_categories`: `Vec<AIDataCategory>` (öffentlich): Datenkategorien, für die die Einwilligung erteilt wurde.
            
        - `granted_timestamp`: `DateTime<Utc>` (öffentlich): Zeitpunkt der Erteilung.
            
        - `expiry_timestamp`: `Option<DateTime<Utc>>` (öffentlich): Optionaler Ablaufzeitpunkt der Einwilligung.
            
        - `is_revoked`: `bool` (öffentlich, initial false): Gibt an, ob die Einwilligung widerrufen wurde.
            
    - Invarianten:
        - `id`, `user_id`, `model_id`, und `granted_timestamp` sind nach der Erstellung unveränderlich.
            
        - `data_categories` sollten nach der Erteilung nicht ohne expliziten Benutzerwunsch modifizierbar sein (neue Einwilligung erforderlich).
            
    - Methoden (konzeptionell):
        - `new(user_id: String, model_id: String, categories: Vec<AIDataCategory>, expiry: Option<DateTime<Utc>>) -> Self`: Erstellt eine neue Einwilligung.
        - `revoke(&mut self)`: Markiert die Einwilligung als widerrufen.
            
3. **AIModelProfile**
    
    - Zweck: Beschreibt ein verfügbares KI-Modell.
        
    - Attribute:
        - `model_id`: `String` (öffentlich): Eindeutiger Identifikator des Modells.
            
        - `display_name`: `String` (öffentlich): Anzeigename des Modells.
            
        - `description`: `String` (öffentlich): Kurze Beschreibung des Modells.
            
        - `provider`: `String` (öffentlich): Anbieter des Modells (z.B. "Local", "CloudProvider").
            
        - `required_consent_categories`: `Vec<AIDataCategory>` (öffentlich): Datenkategorien, für die dieses Modell typischerweise eine Einwilligung benötigt.
            
        - `capabilities`: `Vec<String>` (öffentlich): Liste der Fähigkeiten des Modells (z.B. "text_generation", "image_recognition").
            
    - Invarianten:
        - `model_id` ist eindeutig und unveränderlich.
            
    - Methoden (konzeptionell):
        - `new(...) -> Self`: Erstellt ein neues Modellprofil.
        - `requires_consent_for(&self, categories: &Vec<AIDataCategory>) -> bool`: Prüft, ob für die gegebenen Kategorien eine Einwilligung erforderlich ist.
            
4. **Notification**
    
    - Zweck: Repräsentiert eine einzelne Benachrichtigung.
        
    - Attribute:
        - `id`: `Uuid` (öffentlich): Eindeutiger Identifikator.
            
        - `application_name`: `String` (öffentlich): Name der Anwendung, die die Benachrichtigung gesendet hat.
            
        - `application_icon`: `Option<String>` (öffentlich): Optionaler Pfad oder Name des Icons der Anwendung.
            
        - `summary`: `String` (öffentlich): Kurze Zusammenfassung der Benachrichtigung.
            
        - `body`: `Option<String>` (öffentlich): Detaillierterer Text der Benachrichtigung.
            
        - `actions`: `Vec<NotificationAction>` (öffentlich): Verfügbare Aktionen für die Benachrichtigung.
            
        - `urgency`: `NotificationUrgency` (öffentlich): Dringlichkeitsstufe.
            
        - `timestamp`: `DateTime<Utc>` (öffentlich): Zeitpunkt des Eintreffens.
            
        - `is_read`: `bool` (privat, initial false): Status, ob gelesen.
            
        - `is_dismissed`: `bool` (privat, initial false): Status, ob vom Benutzer aktiv geschlossen.
            
        - `transient`: `bool` (öffentlich, default false): Ob die Benachrichtigung flüchtig ist und nicht in der Historie verbleiben soll.
            
    - Invarianten:
        - `id` und `timestamp` sind unveränderlich.
            
        - `summary` darf nicht leer sein.
            
    - Methoden (konzeptionell):
        - `new(app_name: String, summary: String, urgency: NotificationUrgency) -> Self`: Erstellt eine neue Benachrichtigung.
            
        - `mark_as_read(&mut self)`: Setzt den Lesestatus.
        - `dismiss(&mut self)`: Setzt den Entlassen-Status.
        - `add_action(&mut self, action: NotificationAction)`: Fügt eine Aktion hinzu.
            
5. **NotificationAction**
    
    - Zweck: Definiert eine Aktion, die im Kontext einer Benachrichtigung ausgeführt werden kann.
        
    - Attribute:
        - `key`: `String` (öffentlich): Eindeutiger Schlüssel für die Aktion (z.B. "reply", "archive").
            
        - `label`: `String` (öffentlich): Anzeigename der Aktion.
            
        - `action_type`: `NotificationActionType` (öffentlich): Typ der Aktion (z.B. Callback, Link).
            
6. **AttachmentData**
    
    - Zweck: Repräsentiert angehängte Daten an einen AIInteractionContext.
        
    - Attribute:
        - `id`: `Uuid` (öffentlich): Eindeutiger Identifikator des Anhangs.
            
        - `mime_type`: `String` (öffentlich): MIME-Typ der Daten (z.B. "text/plain", "image/png").
            
        - `source_uri`: `Option<String>` (öffentlich): URI zur Quelle der Daten (z.B. file:///path/to/file).
            
        - `content`: `Option<Vec<u8>>` (öffentlich): Direkter Inhalt der Daten, falls klein.
            
        - `description`: `Option<String>` (öffentlich): Optionale Beschreibung des Anhangs.
            

### B. Modulspezifische Enums

1. **AIConsentStatus**: Enum
    
    - Varianten: `Granted`, `Denied`, `PendingUserAction`, `NotRequired`.
        
2. **AIDataCategory**: Enum
    
    - Varianten: `UserProfile`, `ApplicationUsage`, `FileSystemRead`, `ClipboardAccess`, `LocationData`, `GenericText`, `GenericImage`.
        
3. **NotificationUrgency**: Enum
    
    - Varianten: `Low`, `Normal`, `Critical`.
        
4. **NotificationActionType**: Enum
    
    - Varianten: `Callback`, `OpenLink`.
        
5. **NotificationFilterCriteria**: Enum
    
    - Varianten: `Unread`, `Application(String)`, `Urgency(NotificationUrgency)`.
        
6. **NotificationSortOrder**: Enum
    
    - Varianten: `TimestampAscending`, `TimestampDescending`, `Urgency`.
        

### C. Modulspezifische Konstanten

- `const DEFAULT_NOTIFICATION_TIMEOUT_SECS: u64 = 5;`
    
- `const MAX_NOTIFICATION_HISTORY: usize = 100;`
    
- `const MAX_AI_INTERACTION_HISTORY: usize = 50;`
    

## III. Modulspezifische Funktionen

### A. Traits

1. **AIInteractionLogicService**
    
    Rust
    
    ```
    use crate::core::types::Uuid;
    use crate::core::errors::CoreError;
    use super::types::{AIInteractionContext, AIConsent, AIModelProfile, AIDataCategory, AttachmentData};
    use super::errors::AIInteractionError;
    use async_trait::async_trait;
    
    #[async_trait]
    pub trait AIInteractionLogicService: Send + Sync {
        /// Initiates a new AI interaction context.
        /// Returns the ID of the newly created context.
        async fn initiate_interaction(
            &mut self,
            relevant_categories: Vec<AIDataCategory>,
            initial_attachments: Option<Vec<AttachmentData>>
        ) -> Result<Uuid, AIInteractionError>;
    
        /// Retrieves an existing AI interaction context.
        async fn get_interaction_context(&self, context_id: Uuid) -> Result<AIInteractionContext, AIInteractionError>;
    
        /// Provides or updates consent for a given interaction context and model.
        async fn provide_consent(
            &mut self,
            context_id: Uuid,
            model_id: String,
            granted_categories: Vec<AIDataCategory>,
            consent_decision: bool // true for granted, false for denied
        ) -> Result<(), AIInteractionError>;
    
        /// Retrieves the consent status for a specific model and data categories,
        /// potentially within an interaction context.
        async fn get_consent_for_model(
            &self,
            model_id: &str,
            data_categories: &Vec<AIDataCategory>,
            context_id: Option<Uuid>
        ) -> Result<AIConsentStatus, AIInteractionError>;
    
        /// Adds an attachment to an existing interaction context.
        async fn add_attachment_to_context(
            &mut self,
            context_id: Uuid,
            attachment: AttachmentData
        ) -> Result<(), AIInteractionError>;
    
        /// Lists all available and configured AI model profiles.
        async fn list_available_models(&self) -> Result<Vec<AIModelProfile>, AIInteractionError>;
    
        /// Stores a user's consent decision persistently.
        /// This might be called after `provide_consent` if the consent is to be remembered globally.
        async fn store_consent(&self, consent: AIConsent) -> Result<(), AIInteractionError>;
    
        /// Retrieves all stored consents for a given user (simplified).
        async fn get_all_user_consents(&self, user_id: &str) -> Result<Vec<AIConsent>, AIInteractionError>;
    
        /// Loads AI model profiles, e.g., from a configuration managed by core::config.
        async fn load_model_profiles(&mut self) -> Result<(), AIInteractionError>;
    }
    ```
    
2. **NotificationService**
    
    Rust
    
    ```
    use crate::core::types::Uuid;
    use crate::core::errors::CoreError;
    use super::types::{Notification, NotificationUrgency, NotificationFilterCriteria, NotificationSortOrder};
    use super::errors::NotificationError;
    use async_trait::async_trait;
    
    #[async_trait]
    pub trait NotificationService: Send + Sync {
        /// Posts a new notification to the system.
        /// Returns the ID of the newly created notification.
        async fn post_notification(&mut self, notification_data: Notification) -> Result<Uuid, NotificationError>;
    
        /// Retrieves a specific notification by its ID.
        async fn get_notification(&self, notification_id: Uuid) -> Result<Notification, NotificationError>;
    
        /// Marks a notification as read.
        async fn mark_as_read(&mut self, notification_id: Uuid) -> Result<(), NotificationError>;
    
        /// Dismisses a notification, removing it from active view but possibly keeping it in history.
        async fn dismiss_notification(&mut self, notification_id: Uuid) -> Result<(), NotificationError>;
    
        /// Retrieves a list of currently active (not dismissed, potentially unread) notifications.
        /// Allows filtering and sorting.
        async fn get_active_notifications(
            &self,
            filter: Option<NotificationFilterCriteria>,
            sort_order: Option<NotificationSortOrder>
        ) -> Result<Vec<Notification>, NotificationError>;
    
        /// Retrieves the notification history.
        /// Allows filtering and sorting.
        async fn get_notification_history(
            &self,
            limit: Option<usize>,
            filter: Option<NotificationFilterCriteria>,
            sort_order: Option<NotificationSortOrder>
        ) -> Result<Vec<Notification>, NotificationError>;
    
        /// Clears all notifications from history.
        async fn clear_history(&mut self) -> Result<(), NotificationError>;
    
        /// Sets the "Do Not Disturb" mode.
        async fn set_do_not_disturb(&mut self, enabled: bool) -> Result<(), NotificationError>;
    
        /// Checks if "Do Not Disturb" mode is currently enabled.
        async fn is_do_not_disturb_enabled(&self) -> Result<bool, NotificationError>;
    
        /// Invokes a specific action associated with a notification.
        async fn invoke_action(&mut self, notification_id: Uuid, action_key: &str) -> Result<(), NotificationError>;
    }
    ```
    

### B. Methodenlogik

1. **AIInteractionLogicService::provide_consent**
    
    - Vorbedingung:
        - `context_id` muss einen existierenden AIInteractionContext referenzieren.
            
        - `model_id` muss einem bekannten AIModelProfile entsprechen.
            
    - Logik:
        1. Kontext und Modellprofil laden.
        2. Prüfen, ob die `granted_categories` eine Untermenge der vom Modell potenziell benötigten Kategorien sind.
            
        3. Einen neuen `AIConsent`-Eintrag erstellen oder einen bestehenden aktualisieren.
        4. Den `consent_status` im `AIInteractionContext` entsprechend anpassen.
            
        5. Falls `consent_decision` true ist und die Einwilligung global gespeichert werden soll, `store_consent()` aufrufen.
        6. `AIConsentUpdatedEvent` auslösen.
    - Nachbedingung:
        - Der Einwilligungsstatus des Kontexts ist aktualisiert.
        - Ein `AIConsent`-Objekt wurde potenziell erstellt/modifiziert.
        - Ein Event wurde ausgelöst.
            
2. **NotificationService::post_notification**
    
    - Vorbedingung:
        - `notification_data.summary` darf nicht leer sein.
            
    - Logik:
        1. Validieren der `notification_data`.
        2. Der `Notification` eine neue Uuid und einen `timestamp` zuweisen.
            
        3. Wenn DND-Modus aktiv ist und die `NotificationUrgency` nicht Critical ist, die Benachrichtigung ggf. unterdrücken oder nur zur Historie hinzufügen, ohne sie aktiv anzuzeigen.
            
        4. Die Benachrichtigung zur Liste der `active_notifications` hinzufügen.
        5. Wenn die Benachrichtigung nicht transient ist, sie zur `history` hinzufügen (unter Beachtung von `MAX_NOTIFICATION_HISTORY`).
        6. `NotificationPostedEvent` auslösen (ggf. mit Information, ob sie aufgrund von DND unterdrückt wurde).
    - Nachbedingung:
        - Die Benachrichtigung ist im System registriert und ein Event wurde ausgelöst.
            

## IV. Fehlerbehandlung

### A. AIInteractionError

Rust

```
use thiserror::Error;
use crate::core::types::Uuid;

pub enum AIInteractionError {
    ContextNotFound(Uuid),
    ConsentAlreadyProvided(Uuid),
    #[error("Consent required for model '{model_id}' but not granted for data categories: {missing_categories:?}")]
    ConsentRequired { model_id: String, missing_categories: Vec<String> },
    NoModelAvailable,
    ModelNotFound(String),
    InvalidAttachment(String),
    ConsentStorageError(String),
    ModelProfileLoadError(String),
    CoreError { #[from] source: crate::core::errors::CoreError },
    InternalError(String),
}
```

### B. NotificationError

Rust

```
use thiserror::Error;
use crate::core::types::Uuid;

pub enum NotificationError {
    NotFound(Uuid),
    InvalidData{ summary: String, details: String },
    #[error("Maximum notification history of {max_history} reached. Cannot add new notification: {summary}")]
    HistoryFull { max_history: usize, summary: String },
    ActionNotFound { notification_id: Uuid, action_id: String },
    CoreError { #[from] source: crate::core::errors::CoreError },
    InternalError(String),
}
```

## V. Ereignisse

### A. AIInteractionInitiatedEvent

- Payload-Struktur:
    
    Rust
    
    ```
    pub struct AIInteractionInitiatedEvent {
        pub context_id: Uuid,
        pub relevant_categories: Vec<AIDataCategory>
    }
    ```
    
- Typische Publisher: AIInteractionLogicService Implementierung.
    
- Typische Subscriber: UI-Komponenten, die eine KI-Interaktionsoberfläche öffnen oder vorbereiten; Logging-Systeme.
    
- Auslösebedingungen: Ein neuer AIInteractionContext wurde erfolgreich erstellt via initiate_interaction.
    

### B. AIConsentUpdatedEvent

- Payload-Struktur:
    
    Rust
    
    ```
    pub struct AIConsentUpdatedEvent {
        pub context_id: Option<Uuid>,
        pub model_id: String,
        pub granted_categories: Vec<AIDataCategory>,
        pub consent_status: AIConsentStatus
    }
    ```
    
- Typische Publisher: AIInteractionLogicService Implementierung.
    
- Typische Subscriber: UI-Komponenten, die den Einwilligungsstatus anzeigen oder Aktionen basierend darauf freischalten/sperren; die Komponente, die die eigentliche KI-Anfrage durchführt.
    
- Auslösebedingungen: Eine Einwilligung wurde erteilt, verweigert oder widerrufen (provide_consent, store_consent mit Widerruf).
    

### C. NotificationPostedEvent

- Payload-Struktur:
    
    Rust
    
    ```
    pub struct NotificationPostedEvent {
        pub notification: Notification,
        pub suppressed_by_dnd: bool
    }
    ```
    
- Typische Publisher: NotificationService Implementierung.
    
- Typische Subscriber: UI-Schicht (zur Anzeige der Benachrichtigung), System-Schicht (z.B. um einen Ton abzuspielen, falls nicht unterdrückt).
    
- Auslösebedingungen: Eine neue Benachrichtigung wurde erfolgreich via post_notification verarbeitet.
    

### D. NotificationDismissedEvent

- Payload-Struktur:
    
    Rust
    
    ```
    pub struct NotificationDismissedEvent {
        pub notification_id: Uuid
    }
    ```
    
- Typische Publisher: NotificationService Implementierung.
    
- Typische Subscriber: UI-Schicht (um die Benachrichtigung aus der aktiven Ansicht zu entfernen).
    
- Auslösebedingungen: Eine Benachrichtigung wurde erfolgreich via dismiss_notification geschlossen.
    

### E. NotificationReadEvent

- Payload-Struktur:
    
    Rust
    
    ```
    pub struct NotificationReadEvent {
        pub notification_id: Uuid
    }
    ```
    
- Typische Publisher: NotificationService Implementierung.
    
- Typische Subscriber: UI-Schicht (um den "gelesen"-Status zu aktualisieren).
    
- Auslösebedingungen: Eine Benachrichtigung wurde erfolgreich via mark_as_read als gelesen markiert.
    

### F. DoNotDisturbModeChangedEvent

- Payload-Struktur:
    
    Rust
    
    ```
    pub struct DoNotDisturbModeChangedEvent {
        pub dnd_enabled: bool
    }
    ```
    
- Typische Publisher: NotificationService Implementierung.
    
- Typische Subscriber: UI (DND-Statusanzeige), NotificationService (um Benachrichtigungen zu unterdrücken).
    
- Auslösebedingungen: Der DND-Modus wurde via set_do_not_disturb geändert.
    

## VI. Implementierungsrichtlinien

### A. Modulstruktur

```
src/domain/user_centric_services/
├── mod.rs                      // Deklariert Submodule, exportiert öffentliche Typen/Traits
├── ai_interaction_service.rs  // Implementierung von AIInteractionLogicService
├── notification_service.rs    // Implementierung von NotificationService
├── types.rs                    // Gemeinsame Enums und Structs
└── errors.rs                   // Definition der Fehler-Enums
```

### B. Implementierungsschritte

1. **errors.rs erstellen**: Definiere die AIInteractionError und NotificationError Enums mithilfe von `thiserror`. Stelle sicher, dass sie `Debug`, `Clone`, `PartialEq`, und `Eq` (falls benötigt) implementieren.
2. **types.rs erstellen**: Definiere alle modulspezifischen Enums (AIConsentStatus, AIDataCategory, etc.) und Structs (AIInteractionContext, AIConsent, etc.). Implementiere für diese Strukturen die notwendigen Traits: `Debug`, `Clone`, `PartialEq`, und `Serialize`/`Deserialize` (wo benötigt).
3. **ai_interaction_service.rs Basis**:
    - Definiere den Trait `AIInteractionLogicService`.
    - Erstelle eine Struktur `DefaultAIInteractionLogicService`. Diese Struktur wird Felder für den internen Zustand enthalten.
    - Beginne mit der Implementierung von `#[async_trait] impl AIInteractionLogicService for DefaultAIInteractionLogicService`.
4. **notification_service.rs Basis**:
    - Definiere den Trait `NotificationService`.
    - Erstelle eine Struktur `DefaultNotificationService`. Diese Struktur wird Felder für den internen Zustand enthalten.
    - Beginne mit der Implementierung von `#[async_trait] impl NotificationService for DefaultNotificationService`.
5. **Implementierung der AIInteractionLogicService-Methoden**: Implementiere jede Methode des Traits schrittweise. Achte auf korrekte Fehlerbehandlung und Rückgabe der definierten `AIInteractionError`-Varianten. Implementiere die Interaktion mit der Kernschicht (z.B. für Persistenz). Löse die entsprechenden Events aus.
6. **Implementierung der NotificationService-Methoden**: Implementiere jede Methode des Traits. Implementiere die Logik für DND, Historienbegrenzung, Filterung und Sortierung. Verwende `NotificationError`-Varianten für Fehlerfälle. Löse die spezifizierten Notification-Events aus.
7. **mod.rs erstellen**: Deklariere die Submodule und exportiere alle öffentlichen Typen, Traits, und Fehler-Enums, die von außerhalb dieses Moduls verwendet werden sollen.
8. **Unit-Tests**: Schreibe Unit-Tests parallel zur Implementierung jeder Methode und jeder komplexen Logikeinheit. Mocke dabei gegebenenfalls Abhängigkeiten zur Kernschicht.
# Executive Summary

Purpose and Scope: Dieses Dokument liefert eine Ultra-Feinspezifikation für sämtliche Schnittstellen und Implementierungen des Model Context Protocol (MCP) innerhalb des NovaDE-Projekts. Es dient als definitive technische Referenz für Entwickler und Architekten, die an der Integration von MCP beteiligt sind. Die Spezifikation zielt darauf ab, eine klare, präzise und unzweideutige Grundlage für die Entwicklung zu schaffen, die eine direkte Umsetzung ermöglicht.


MCP in NovaDE: Die strategische Entscheidung zur Adaption von MCP im NovaDE-Projekt basiert auf der Erwartung signifikanter Vorteile. Dazu zählen die standardisierte Integration von KI-Modellen, eine verbesserte kontextuelle Wahrnehmung für KI-Agenten und der modulare Zugriff auf die domänenspezifischen Funktionalitäten von NovaDE.1 MCP positioniert NovaDE so, dass es von einem wachsenden Ökosystem an KI-Werkzeugen und -Modellen profitieren kann, indem eine standardisierte Interaktionsebene bereitgestellt wird.1 Diese Ausrichtung deutet auf eine zukunftsorientierte Architektur hin, die auf Interoperabilität und Erweiterbarkeit abzielt. Da MCP als universeller Standard gilt und von führenden KI-Akteuren adaptiert wird 1, kann NovaDE durch dessen Nutzung einfacher mit diversen KI-Modellen integriert werden und von gemeinschaftlich entwickelten MCP-Servern oder -Clients profitieren.


Key Deliverables: Diese Spezifikation umfasst detaillierte MCP-Nachrichtenformate, NovaDE-spezifische Schnittstellendefinitionen (Ressourcen, Werkzeuge, Aufforderungen, Benachrichtigungen), Integrationsstrategien mit der (aktuell separaten) "Domänenschicht-Spezifikation", Implementierungsrichtlinien, Sicherheitsüberlegungen, Fehlerbehandlung und Versionierung.


Critical Dependencies: Es wird explizit auf die Abhängigkeit von der "Domänenschicht-Spezifikation" für die konkrete Abbildung von Domänenfunktionalitäten auf MCP-Konstrukte hingewiesen. Dieses Dokument stellt den Rahmen für solche Abbildungen bereit. Der Erfolg der MCP-Integration hängt maßgeblich von einer wohldefinierten "Domänenschicht-Spezifikation" ab; ohne diese bleiben die MCP-Schnittstellen abstrakt.


Intended Audience: Dieses Dokument richtet sich an technische Leiter, Softwarearchitekten und Senior-Entwickler des NovaDE-Projekts.

2. Model Context Protocol (MCP) Grundlagen für NovaDE

2.1. MCP Protokollübersicht

Definition und Ziele: Das Model Context Protocol (MCP) ist ein offener Standard, der entwickelt wurde, um die Art und Weise zu standardisieren, wie KI-Modelle, insbesondere Large Language Models (LLMs), mit externen Werkzeugen, Systemen und Datenquellen integriert werden und Daten austauschen.1 Es fungiert als universelle Schnittstelle für den Kontexaustausch zwischen KI-Assistenten und Software-Umgebungen, indem es modellagnostische Mechanismen zum Lesen von Dateien, Ausführen von Funktionen und Handhaben kontextueller Anfragen bereitstellt.1 Das primäre Ziel von MCP ist es, die Herausforderung isolierter Informationssilos und proprietärer Legacy-Systeme zu adressieren, die die Fähigkeiten selbst hochentwickelter KI-Modelle einschränken.1
Kernkonzepte:

Client-Host-Server-Architektur: MCP basiert auf einem Client-Host-Server-Muster.2

MCP Clients: Sind Protokoll-Clients, die typischerweise in KI-Anwendungen oder Agenten eingebettet sind und eine Eins-zu-Eins-Verbindung zu MCP-Servern herstellen. Sie sind für die Aushandlung von Fähigkeiten und die Orchestrierung von Nachrichten zwischen sich und dem Server zuständig.2
MCP Hosts: Agieren als Container oder Koordinatoren für eine oder mehrere Client-Instanzen. Sie verwalten den Lebenszyklus und die Sicherheitsrichtlinien (z.B. Berechtigungen, Benutzerautorisierung, Durchsetzung von Einwilligungsanforderungen) und überwachen, wie die KI-Integration innerhalb jedes Clients erfolgt, indem sie Kontext sammeln und zusammenführen.2 Ein Beispiel hierfür ist die Claude Desktop App.1
MCP Server: Sind Programme, die Datenquellen, APIs oder andere Dienstprogramme (wie CRM-Systeme, Git-Repositories oder Dateisysteme) umschließen und deren Fähigkeiten über die standardisierte MCP-Schnittstelle bereitstellen. Sie müssen Sicherheitsbeschränkungen und Benutzerberechtigungen, die vom Host durchgesetzt werden, einhalten.2


Ressourcen (Resources): Stellen Dateneinheiten dar, die von MCP-Servern exponiert werden. Sie können beliebige Entitäten sein – Dateien, API-Antworten, Datenbankabfragen, Systeminformationen etc..5 Sie sind vergleichbar mit GET-Endpunkten in einer Web-API und dienen dazu, Informationen in den Kontext des LLMs zu laden.6
Werkzeuge (Tools): Repräsentieren Funktionalitäten, die von MCP-Servern bereitgestellt werden und von LLMs aufgerufen werden können, um Aktionen auszuführen oder Berechnungen durchzuführen.3 Im Gegensatz zu Ressourcen wird von Werkzeugen erwartet, dass sie Seiteneffekte haben können. Sie sind vergleichbar mit POST-Endpunkten in einer REST-API.6
Aufforderungen (Prompts): Definieren wiederverwendbare Interaktionsmuster oder Vorlagen für LLM-Interaktionen, die Systemanweisungen, erforderliche Argumente, eingebettete Ressourcen und verschiedene Inhaltstypen umfassen können.5
Benachrichtigungen (Notifications): Sind asynchrone Nachrichten, die von einem MCP-Server an einen MCP-Client gesendet werden, typischerweise um über Zustandsänderungen oder Ereignisse zu informieren, ohne dass eine direkte vorherige Anfrage vom Client erfolgte.5


JSON-RPC Basis: MCP basiert auf JSON-RPC 2.0.2 Dies impliziert ein etabliertes Nachrichtenformat für Anfragen (Requests), Antworten (Responses) und Benachrichtigungen (Notifications), was die Implementierung und Interoperabilität erleichtert.



2.2. MCP-Architektur im NovaDE-Projekt

Identifizierung von MCP-Komponenten:

MCP Hosts in NovaDE: Es ist zu definieren, welche Komponenten des NovaDE-Projekts als MCP Hosts agieren werden. Dies könnte beispielsweise ein zentraler KI-Agenten-Orchestrator sein, der die Interaktionen zwischen verschiedenen KI-Modellen und den NovaDE MCP-Servern koordiniert und Sicherheitsrichtlinien durchsetzt, wie in 2 beschrieben.
MCP Server in NovaDE: Module oder Subsysteme von NovaDE, die spezifische Domänenfunktionalitäten oder Datenzugriffe bereitstellen, werden als MCP-Server implementiert. Diese Server exponieren dann über MCP definierte Ressourcen und Werkzeuge.
MCP Clients in NovaDE: Potenzielle MCP-Clients können interne KI-Agenten des NovaDE-Projekts sein oder auch externe KI-Modelle, die mit den Funktionalitäten von NovaDE interagieren sollen.


Transportmechanismen:

Stdio (Standard Input/Output): Dieser Mechanismus eignet sich für die lokale Interprozesskommunikation zwischen eng gekoppelten Komponenten innerhalb von NovaDE.3 Rust SDKs wie mcp_client_rs 7 und mcpr 10 unterstützen Stdio. Für Szenarien, in denen ein NovaDE-Host einen lokalen MCP-Server als Subprozess startet, ist Stdio eine einfache und effiziente Wahl.
HTTP/SSE (Server-Sent Events): Für die Kommunikation mit entfernten MCP-Servern oder wenn Echtzeit-Updates vom Server zum Client erforderlich sind (z.B. Benachrichtigungen über Änderungen in der Domänenschicht), ist HTTP mit SSE der empfohlene Transportmechanismus.3 Das mcpr Rust SDK 10 bietet explizite Unterstützung für SSE, einschließlich Mock-Implementierungen für Tests. Auch mcp-go unterstützt SSE.6 Die Fähigkeit, Server-Push-Benachrichtigungen zu empfangen, ist für viele KI-Anwendungen entscheidend, was SSE favorisiert.
Rationale für die Wahl: Die Auswahl des Transportmechanismus pro Komponente in NovaDE sollte auf den spezifischen Anforderungen basieren. Für eng integrierte lokale Prozesse, die keine unidirektionalen Echtzeit-Updates vom Server benötigen, kann Stdio ausreichend sein. Für alle Szenarien, die Server-Push-Benachrichtigungen oder die Anbindung externer/entfernter MCP-Server erfordern, sollte HTTP/SSE verwendet werden. Die "Domänenschicht-Spezifikation" muss analysiert werden, um festzustellen, welche Funktionalitäten asynchrone Updates erfordern, was die Wahl des Transports und potenziell des MCP-Server-SDKs für diese Teile leitet.


Datenflussdiagramme:

Diagramm 2.2.1: Allgemeiner MCP-Datenfluss in NovaDE (Illustriert einen NovaDE MCP Host, der mit einem internen NovaDE MCP Server und einem externen KI-Modell (Client) kommuniziert.)
Diagramm 2.2.2: Datenfluss für Werkzeugaufruf über Stdio
Diagramm 2.2.3: Datenfluss für Ressourcenabruf und Benachrichtigung über SSE



Die Unterscheidung zwischen Client, Host und Server im MCP-Modell 2 erfordert eine sorgfältige Zuweisung dieser Rollen innerhalb der NovaDE-Architektur. Der Host als Koordinator und Durchsetzer von Sicherheitsrichtlinien ist eine zentrale Komponente, insbesondere wenn mehrere KI-Agenten oder Clients mit verschiedenen NovaDE MCP-Servern interagieren. Das Design dieser Host-Komponente(n) wird entscheidend für die Sicherheit und Verwaltbarkeit des Gesamtsystems sein.

3. Standard-MCP-Nachrichtenspezifikationen für NovaDEDieser Abschnitt definiert die präzisen JSON-RPC 2.0 Strukturen für alle Standard-MCP-Nachrichten, angepasst mit NovaDE-spezifischen Überlegungen, wie beispielsweise gemeinsamen Metadatenfeldern. Die hier definierten Strukturen basieren auf den allgemeinen MCP-Konzepten 3 und werden durch spezifische Felder für den NovaDE-Kontext erweitert.

3.1. Initialize Request und ResponseDie Initialize-Nachricht dient dem Aufbau einer Verbindung und dem Aushandeln von Protokollversionen und Fähigkeiten zwischen Client und Server.3

InitializeParams: Parameter für den Initialize-Request.

Tabelle 3.1: InitializeParams Schema




FeldnameJSON-TypBeschreibungConstraintsprotocolVersionstringDie vom Client vorgeschlagene MCP-Protokollversion (z.B. "2025-03-26").ErforderlichclientNamestringOptionaler, menschenlesbarer Name der Client-Anwendung/Komponente.OptionalclientVersionstringOptionale Version der Client-Anwendung/Komponente.OptionalsupportedFeaturesarray of stringOptionale Liste von NovaDE-spezifischen MCP-Features, die der Client unterstützt.Optional*   **`InitializeResult`**: Ergebnis eines erfolgreichen Initialize-Requests.
    *   **Tabelle 3.2**: `InitializeResult` Schema
FeldnameJSON-TypBeschreibungConstraintsprotocolVersionstringDie vom Server gewählte und unterstützte MCP-Protokollversion.ErforderlichserverNamestringOptionaler, menschenlesbarer Name der Server-Anwendung/Komponente.OptionalserverVersionstringOptionale Version der Server-Anwendung/Komponente.OptionalsupportedFeaturesarray of stringOptionale Liste von NovaDE-spezifischen MCP-Features, die der Server unterstützt.Optionaltoolsarray of ToolDefinitionOptionale initiale Liste der vom Server bereitgestellten Werkzeuge.Optional, siehe Tabelle 3.8 für ToolDefinitionresourcesarray of ResourceDefinitionOptionale initiale Liste der vom Server bereitgestellten Ressourcen.Optional, Struktur analog zu Resource (Tabelle 3.5) aber ggf. ohne content    *Referenzen*: Die `mcp_client_rs` Bibliothek nutzt eine `spawn_and_initialize` Methode [9], und `mcpr` bietet eine `client.initialize()` Funktion [10], was die fundamentale Rolle dieser Nachricht unterstreicht.


3.2. ListResources Request und ResponseDiese Nachricht ermöglicht es einem Client, die vom Server verfügbaren Ressourcen abzufragen.3

ListResourcesParams: Parameter für den ListResources-Request.

Tabelle 3.3: ListResourcesParams Schema




FeldnameJSON-TypBeschreibungConstraintsfilterobjectOptionale, NovaDE-spezifische Kriterien zur Filterung der Ressourcen (z.B. nach Typ, Domänenentität).OptionalpageTokenstringOptionales Token zur Paginierung, um die nächste Seite der Ergebnisse abzurufen.Optional*   **`ListResourcesResult`**: Ergebnis eines erfolgreichen ListResources-Requests.
    *   **Tabelle 3.4**: `ListResourcesResult` Schema
FeldnameJSON-TypBeschreibungConstraintsresourcesarray of ResourceListe der Resource-Objekte, die den Filterkriterien entsprechen.Erforderlich, siehe Tabelle 3.5 für ResourcenextPageTokenstringOptionales Token, um die nächste Seite der Ergebnisse abzurufen, falls vorhanden.Optional*   **`Resource` Objektstruktur**: Definiert die Struktur einer einzelnen Ressource.
    *   **Tabelle 3.5**: `Resource` Objekt Schema
FeldnameJSON-TypBeschreibungConstraintsDomänenschicht-Mapping (Beispiel)uristringEindeutiger Resource Identifier (URI).ErforderlichDomainObject.IDnamestringMenschenlesbarer Name der Ressource.ErforderlichDomainObject.DisplayNamedescriptionstringOptionale, detaillierte Beschreibung der Ressource.OptionalDomainObject.DescriptionschemaobjectOptionales JSON-Schema, das die Datenstruktur des Ressourceninhalts beschreibt.Optional-novaDE_domain_typestringOptionaler Typbezeichner, der auf einen Typ in der "Domänenschicht-Spezifikation" verweist.OptionalName des DomänentypscontentTypestringOptionaler MIME-Typ oder NovaDE-spezifischer Inhaltstyp.OptionalDomainObject.MimeTypecanReadbooleanGibt an, ob die Ressource gelesen werden kann.Optional-canWritebooleanGibt an, ob die Ressource geschrieben werden kann (falls zutreffend).Optional-    *Referenzen*: Die `list_resources()` Methode in `mcp_client_rs` [9] und das allgemeine Konzept von Ressourcen in MCP [6] sind hier relevant.


3.3. CallTool Request und ResponseDiese Nachricht ermöglicht es einem Client, ein vom Server bereitgestelltes Werkzeug auszuführen.3

CallToolParams: Parameter für den CallTool-Request.

Tabelle 3.6: CallToolParams Schema




FeldnameJSON-TypBeschreibungConstraintstoolNamestringName des aufzurufenden Werkzeugs.ErforderlichargumentsobjectJSON-Objekt, das die Argumente für das Werkzeug enthält.ErforderlichprogressTokenstringOptionales Token zur Verfolgung des Fortschritts langlaufender Werkzeuge.Optional*   **`CallToolResult`**: Ergebnis eines erfolgreichen CallTool-Requests.
    *   **Tabelle 3.7**: `CallToolResult` Schema
FeldnameJSON-TypBeschreibungConstraintsresultanyOptionale Ausgabe der Werkzeugausführung. Die Struktur hängt vom Werkzeug ab.OptionalisErrorbooleanOptional. Gibt an, ob der Werkzeugaufruf zu einem anwendungsspezifischen Fehler geführt hat (Standard: false).Optional, Default falseerrorobjectOptionale, werkzeugspezifische Fehlerdetails, falls isError true ist.Optional*   **`ToolDefinition` Objektstruktur**: Definiert die Struktur eines Werkzeugs (verwendet in `InitializeResult` und potenziell in einer `ListTools`-Antwort).
    *   **Tabelle 3.8**: `ToolDefinition` Objekt Schema
FeldnameJSON-TypBeschreibungConstraintsDomänenschicht-Mapping (Beispiel)namestringEindeutiger Name des Werkzeugs.ErforderlichDomainFunction.NamedescriptionstringOptionale, menschenlesbare Beschreibung des Werkzeugs.OptionalDomainFunction.DocparametersSchemaobjectJSON-Schema, das die Eingabeparameter (arguments) des Werkzeugs beschreibt.Erforderlich-resultSchemaobjectOptionales JSON-Schema, das die erfolgreiche Ausgabe (result) des Werkzeugs beschreibt.Optional-novaDE_domain_functionstringOptionaler Bezeichner, der auf eine Funktion/Fähigkeit in der "Domänenschicht-Spezifikation" verweist.OptionalName der Domänenfunktion    *Referenzen*: Die `call_tool()` Methode in `mcp_client_rs` [9] und das Werkzeugkonzept in MCP [3, 6] sind hier relevant.


3.4. ReadResource Request und ResponseErmöglicht das Lesen des Inhalts einer spezifischen Ressource.

ReadResourceParams: Parameter für den ReadResource-Request.

Tabelle 3.9: ReadResourceParams Schema




FeldnameJSON-TypBeschreibungConstraintsuristringURI der zu lesenden Ressource.Erforderlich*   **`ReadResourceResult`**: Ergebnis eines erfolgreichen ReadResource-Requests.
    *   **Tabelle 3.10**: `ReadResourceResult` Schema
FeldnameJSON-TypBeschreibungConstraintscontentanyDer Inhalt der Ressource, konform zu ihrem Schema (falls definiert).ErforderlichcontentTypestringOptionaler MIME-Typ oder NovaDE-spezifischer Inhaltstyp der Ressource.Optional    *Referenzen*: Die `read_resource()` Methode in `mcp_client_rs`.[9]


3.5. Notification MessageAsynchrone Nachricht vom Server an den Client.5

Notification Struktur:

Tabelle 3.11: Generische Notification Struktur




FeldnameJSON-TypBeschreibungConstraintsjsonrpcstringMuss "2.0" sein.ErforderlichmethodstringName der Benachrichtigungsmethode (z.B. novaDE/resourceUpdated, novaDE/statusChanged).ErforderlichparamsobjectOptionales JSON-Objekt mit den Parametern der Benachrichtigung. Das Schema hängt von method ab.Optional    *Referenzen*: Die Notwendigkeit der Handhabung von Server-Push-Benachrichtigungen wird durch die SSE-Unterstützung in `mcpr` [10, 11, 12] und die Erwähnung in MCP-Konzepten [5] deutlich.


3.6. Response Message (Erfolg)Standard-JSON-RPC-Erfolgsantwort.

Response Struktur:

jsonrpc (string, required): "2.0".
id (string | number | null, required): Muss mit der ID der ursprünglichen Anfrage übereinstimmen.
result (any, required): Das Ergebnis der Anfrage, dessen Struktur vom jeweiligen Request-Typ abhängt (z.B. InitializeResult, ListResourcesResult).





3.7. ErrorResponse Message (Protokollfehler)Standard-JSON-RPC-Fehlerantwort.5

ErrorResponse Struktur:

Tabelle 3.12: Generische ErrorResponse Struktur




FeldnameJSON-TypBeschreibungConstraintsjsonrpcstringMuss "2.0" sein.Erforderlichidstring \number \nullerrorobjectEin Objekt, das den Fehler beschreibt.Erforderlicherror.codeintegerNumerischer Fehlercode.Erforderlicherror.messagestringMenschenlesbare Fehlerbeschreibung.Erforderlicherror.dataanyOptionale, zusätzliche Fehlerdetails.OptionalDie Standard-MCP-Nachrichten bilden ein robustes Fundament. Für NovaDE wird die Hauptaufgabe darin bestehen, spezifische Schemata für `Resource`-Inhalte, `ToolDefinition.parametersSchema`, `ToolDefinition.resultSchema` und `Notification.params` zu definieren, die auf der Domänenschicht des Projekts basieren. Die Verwendung von Rust-SDKs wie `mcp_client_rs` [7, 8, 9] unterstreicht die Bedeutung typsicherer Methoden für Kernanfragen, was wiederum voraussetzt, dass Serverantworten strikt den definierten Schemata entsprechen, um eine erfolgreiche Deserialisierung zu gewährleisten. Dies macht eine rigorose Schemavalidierung sowohl auf Client- als auch auf Serverseite unerlässlich für eine robuste Kommunikation.
4. NovaDE Domänenschicht-IntegrationsstrategieDie erfolgreiche Integration des Model Context Protocol (MCP) in das NovaDE-Projekt hängt entscheidend von einer klaren Strategie zur Abbildung der NovaDE-Domänenschicht auf MCP-Schnittstellen ab. Dieser Abschnitt legt die Methodik und Prinzipien für diese Abbildung fest und diskutiert, wie domänenspezifische Technologien, insbesondere im Kontext eines Desktop-Environments, über MCP zugänglich gemacht werden können. Da die detaillierte "Domänenschicht-Spezifikation" für NovaDE zum Zeitpunkt der Erstellung dieses Dokuments nicht vorliegt, dient dieser Abschnitt als Rahmenwerk und illustriert die Integrationsansätze beispielhaft.

4.1. Methodik zur Abbildung

Prinzipien: Der Prozess der Abbildung der "Domänenschicht-Spezifikation" auf MCP-Konstrukte erfordert eine systematische Analyse. Zunächst müssen die Kernentitäten, -funktionalitäten und -ereignisse der Domänenschicht identifiziert werden. Diese werden dann den entsprechenden MCP-Konzepten – Ressourcen (Resources), Werkzeuge (Tools) und Benachrichtigungen (Notifications) – zugeordnet. Es ist essenziell, dass diese Abbildung die Semantik der Domänenschicht korrekt widerspiegelt und gleichzeitig eine für KI-Agenten verständliche und nutzbare Schnittstelle schafft.
Granularität: Die Wahl der Granularität für MCP-Schnittstellen ist eine wichtige Designentscheidung. Es muss abgewogen werden, ob ein MCP-Server viele feingranulare Werkzeuge und Ressourcen exponiert, die spezifische, kleine Aufgaben abbilden, oder ob weniger, dafür aber grobgranularere Schnittstellen angeboten werden, die komplexere Operationen kapseln. Die optimale Granularität hängt von der Natur der NovaDE-Domänenschicht und den erwarteten Anwendungsfällen der interagierenden KI-Modelle ab. Feingranulare Schnittstellen bieten mehr Flexibilität, können aber zu komplexeren Interaktionsmustern führen, während grobgranulare Schnittstellen die Komplexität für den Client reduzieren, aber möglicherweise weniger flexibel sind.
Abstraktion vs. Direkte Abbildung: MCP ist als universeller Adapter konzipiert 3, was darauf hindeutet, dass es oft als eine Abstraktionsebene über darunterliegenden Systemen dient. Es muss entschieden werden, ob die MCP-Schnittstellen eine direkte Eins-zu-Eins-Abbildung von Funktionen der Domänenschicht darstellen oder ob sie eine höhere Abstraktionsebene bieten, die möglicherweise mehrere Domänenfunktionen zu einem kohärenten MCP-Werkzeug oder einer Ressource zusammenfasst. Eine Abstraktion kann die Komplexität für KI-Agenten reduzieren und die Schnittstelle stabiler gegenüber Änderungen in der Domänenschicht machen. Die Domänenschicht-Spezifikation ist hier der entscheidende Faktor.



4.2. Datenmodellierung für MCP-Schnittstellen

Namenskonventionen: Es müssen klare und konsistente Namenskonventionen für MCP-Ressourcen und -Werkzeuge definiert werden, die sich idealerweise an den Bezeichnern der entsprechenden Entitäten und Funktionen in der NovaDE-Domänenschicht orientieren. Dies fördert die Verständlichkeit und Wartbarkeit.
JSON-Schema-Richtlinien: Für die Inhalte von Ressourcen sowie für die Parameter und Ergebnisse von Werkzeugen müssen JSON-Schemata erstellt werden. Es sind Richtlinien für die Erstellung dieser Schemata festzulegen, um Konsistenz über alle NovaDE-MCP-Schnittstellen hinweg zu gewährleisten. Dies beinhaltet die Verwendung standardisierter Datentypen, Formatierungen und Validierungsregeln.
Datentransformation: Es ist zu analysieren, ob und welche Datentransformationen zwischen den Datenformaten der Domänenschicht und den MCP-Nachrichten-Payloads erforderlich sind. Diese Transformationen müssen klar definiert und implementiert werden, um eine korrekte Datenübertragung sicherzustellen.



4.3. Potenzielle Integrationspunkte mit Desktop-Technologien (Beispielhaft)Dieser Unterabschnitt dient als Illustration, wie domänenspezifische Technologien, die typischerweise in einem Desktop-Environment wie NovaDE vorkommen könnten, über MCP integriert werden könnten. Die konkreten Integrationspunkte hängen vollständig von der tatsächlichen "Domänenschicht-Spezifikation" von NovaDE ab.


D-Bus-Dienste: Viele Desktop-Umgebungen nutzen D-Bus für die Interprozesskommunikation und den Zugriff auf Systemdienste. Wenn die Domänenschicht von NovaDE Interaktionen mit solchen Diensten vorsieht, könnten MCP-Schnittstellen als Abstraktion dienen:

MCP-Werkzeuge (Tools) könnten D-Bus-Methodenaufrufe kapseln. Beispielsweise könnte ein Werkzeug novade/notifications/sendDesktopNotification die Methode Notify des org.freedesktop.Notifications D-Bus-Dienstes aufrufen.13 Ähnlich könnten Werkzeuge für die Interaktion mit org.freedesktop.secrets (z.B. zum Speichern oder Abrufen von Passwörtern 15), org.freedesktop.login1 (z.B. zum Sperren der Sitzung oder Abfragen von Benutzerinformationen 17) oder org.freedesktop.UPower (z.B. zum Abfragen des Batteriestatus 21) definiert werden.
MCP-Ressourcen (Resources) könnten abfragbare D-Bus-Eigenschaften oder den Zustand von D-Bus-Objekten repräsentieren. Beispielsweise könnte eine Ressource novade://power/status die Eigenschaften des org.freedesktop.UPower.Device exponieren.
MCP-Benachrichtigungen (Notifications) könnten D-Bus-Signale an MCP-Clients weiterleiten. Ein SessionLock-Signal von org.freedesktop.login1 könnte eine MCP-Benachrichtigung auslösen.
Zur Implementierung solcher MCP-Server in Rust, die mit D-Bus interagieren, ist die zbus-Bibliothek ein geeignetes Werkzeug.26



Wayland-Protokolle: Wenn NovaDE ein Wayland-Compositor ist oder tiefgreifend mit Wayland-basierten Funktionen der Domänenschicht interagiert, könnten MCP-Schnittstellen diese komplexen Protokolle abstrahieren:

MCP-Werkzeuge (Tools) könnten Aktionen wie Fensterverwaltung (Fokus setzen, Schließen, Größenänderung basierend auf xdg-shell 42), das Erstellen von Screenshots (möglicherweise über xdg-desktop-portal oder direktere Wayland-Protokolle wie wlr-screencopy-v1 falls NovaDE ein wlroots-basierter Compositor ist), oder die Synthese von Eingabeereignissen bereitstellen. Die Integration mit wlr-layer-shell 43 für Oberflächen wie Panels oder Hintergrundbilder könnte ebenfalls über MCP-Werkzeuge gesteuert werden.
MCP-Ressourcen (Resources) könnten den Zustand von Fenstern, Ausgabegeräten (Monitoren) oder Eingabegeräten repräsentieren.
Die Smithay-Bibliothek ist ein Rust-Framework, das Bausteine für Wayland-Compositoren bereitstellt und Handler für viele Wayland-Protokolle enthält.



PipeWire: Wenn die Domänenschicht von NovaDE Multimedia-Aspekte umfasst, könnten MCP-Werkzeuge PipeWire-Knoten (Sinks, Sources, Filter) für Lautstärke, Routing usw. steuern.44 MCP-Ressourcen könnten PipeWire-Objekteigenschaften darstellen. Die pipewire-rs-Bibliothek 47 bietet Rust-Bindings für PipeWire. Beispiele zeigen, wie Knoten aufgelistet 59 und Parameter wie Lautstärke gesetzt werden können.47


XDG Desktop Portals: Wenn NovaDE-Anwendungen sandboxed sind oder benutzervermittelten Zugriff auf Ressourcen (Dateien, Screenshots) benötigen, können MCP-Werkzeuge Aufrufe an XDG Desktop Portals kapseln.87 Die Schnittstellen org.freedesktop.portal.FileChooser 98 und org.freedesktop.portal.Screenshot 91 sind wohldefiniert. Rust-Crates wie xdg-portal 105 oder direkte zbus-Aufrufe können hierfür verwendet werden.


Die "Domänenschicht-Spezifikation" ist der kritischste Input für die Definition konkreter MCP-Schnittstellen. Die obigen Beispiele sind potenzielle Integrationspunkte, falls NovaDE ein Desktop-Environment ist. Die tatsächliche Domäne wird die Spezifika diktieren. Diese Spezifikation muss daher flexibel bleiben. Die Abstraktion komplexer Protokolle über einfachere MCP-Schnittstellen kann die Hürde für KI-Agenten zur Interaktion mit NovaDE signifikant senken, da Wayland 43 und D-Bus 15 komplexe APIs haben, während MCP eine standardisierte und potenziell einfachere Schnittstelle für KI anstrebt.1 Das Design der MCP-Schnittstellen sollte sich daher auf Anwendungsfälle konzentrieren, die für die KI-Interaktion relevant sind, und nicht notwendigerweise jede Nuance der zugrundeliegenden Domänenschicht-APIs exponieren.

5. NovaDE-spezifische MCP-SchnittstellendefinitionenDieser Abschnitt dient als Katalog der MCP-Server-Schnittstellen, die spezifisch für das NovaDE-Projekt entwickelt werden. Jede hier definierte Schnittstellengruppe repräsentiert eine logische Sammlung von Funktionalitäten innerhalb von NovaDE. Der Inhalt dieses Abschnitts ist als Vorlage zu verstehen und muss basierend auf der detaillierten "Domänenschicht-Spezifikation" des NovaDE-Projekts konkretisiert werden. Die Struktur orientiert sich an den Kernkonzepten von MCP (Ressourcen, Werkzeuge, Aufforderungen, Benachrichtigungen) 5, um sicherzustellen, dass alle NovaDE-spezifischen Erweiterungen auf dem Standard-MCP-Framework aufbauen.(Vorlagenstruktur - zu füllen basierend auf der Domänenschicht-Spezifikation)
5.1. Interface-Gruppe: de.nova.projekt.Kernfunktionalitaeten

Übersicht: Diese Schnittstellengruppe umfasst grundlegende Funktionalitäten des NovaDE-Kerns, die für KI-Agenten relevant sind, wie z.B. Systeminformationen oder grundlegende Konfigurationsaspekte.
Tabelle 5.1.1: MCP-Schnittstellen in Gruppe Kernfunktionalitaeten


Schnittstellen-ID (Interface ID)ZweckServer-Komponente (NovaDE-Modul)de.nova.mcp.core.systemInfoBereitstellung von SysteminformationenNovaDE.Core.SystemMonitorde.nova.mcp.core.userPreferencesZugriff auf BenutzereinstellungenNovaDE.Core.SettingsManager*   **5.1.1 Schnittstelle: `de.nova.mcp.core.systemInfo`**
    *   **Version**: `1.0.0`
    *   **Beschreibung**: Stellt Informationen über das NovaDE-System und die zugrundeliegende Hardware/Software-Umgebung bereit.
    *   **Abhängigkeiten**: Abschnitt X.Y der "Domänenschicht-Spezifikation" (Systeminformationen).
    *   **5.1.1.1 Ressourcen (Resources)**
        *   **Name**: `SystemStatus`
        *   **URI-Struktur**: `novade://core/system/status`
        *   **Tabelle 5.1.1.1.A**: Ressourcenschema für `SystemStatus`
FeldnameJSON-TypBeschreibungConstraintsDomänenschicht-EntitätosVersionstringVersion des BetriebssystemsErforderlichSystem.OS.VersionnovaDEVersionstringVersion von NovaDEErforderlichNovaDE.VersioncpuUsagenumberAktuelle CPU-Auslastung (Prozent)OptionalSystem.CPU.CurrentLoadmemoryUsageobjectInformationen zur SpeichernutzungOptionalSystem.Memory.StatsmemoryUsage.totalintegerGesamtspeicher in MBOptionalSystem.Memory.TotalmemoryUsage.availableintegerVerfügbarer Speicher in MBOptionalSystem.Memory.Available        *   **Unterstützte Operationen**: `ReadResource`.
        *   **Zugriffssteuerung**: Nur authentifizierte Systemagenten.

    *   **5.1.1.2 Werkzeuge (Tools)**: Keine für diese spezifische Schnittstelle definiert.
    *   **5.1.1.3 Aufforderungen (Prompts)**: Keine für diese spezifische Schnittstelle definiert.
    *   **5.1.1.4 Benachrichtigungen (Notifications)**
        *   **Name**: `systemLoadWarning`
        *   **Auslösebedingungen**: Wird gesendet, wenn die CPU-Auslastung für einen bestimmten Zeitraum einen Schwellenwert überschreitet.
        *   **Tabelle 5.1.1.4.A**: Payload-Schema für `systemLoadWarning`
FeldnameJSON-TypBeschreibungDomänenschicht-EreignisdatenlevelstringWarnstufe (HIGH, CRITICAL)SystemAlert.LevelcpuUsagenumberAktuelle CPU-Auslastung zum Zeitpunkt des AlarmsSystemAlert.CPULoad
5.2. Interface-Gruppe: de.nova.projekt.DesktopIntegration (Beispiel für D-Bus/Wayland)

Übersicht: Diese Schnittstellengruppe demonstriert, wie Desktop-spezifische Funktionalitäten, die typischerweise über D-Bus oder Wayland-Protokolle bereitgestellt werden, über MCP abstrahiert werden können.
Tabelle 5.2.1: MCP-Schnittstellen in Gruppe DesktopIntegration


Schnittstellen-ID (Interface ID)ZweckServer-Komponente (NovaDE-Modul)de.nova.mcp.desktop.notificationsSenden und Verwalten von Desktop-BenachrichtigungenNovaDE.NotificationServiceWrapperde.nova.mcp.desktop.secretsSicherer Speicher für GeheimnisseNovaDE.SecretsAgentde.nova.mcp.desktop.powerAbfragen und Steuern von EnergieoptionenNovaDE.PowerManagerWrapperde.nova.mcp.desktop.sessionVerwalten von BenutzersitzungenNovaDE.SessionManagerWrapperde.nova.mcp.desktop.fileChooserÖffnen von DateiauswahldialogenNovaDE.FileChooserPortalWrapperde.nova.mcp.desktop.screenshotErstellen von BildschirmfotosNovaDE.ScreenshotPortalWrapper*   **5.2.1 Schnittstelle: `de.nova.mcp.desktop.notifications`**
    *   **Version**: `1.0.0`
    *   **Beschreibung**: Ermöglicht das Senden von Desktop-Benachrichtigungen und das Abfragen von Server-Fähigkeiten, basierend auf `org.freedesktop.Notifications`.
    *   **Abhängigkeiten**: `org.freedesktop.Notifications` D-Bus Spezifikation.[13, 14]
    *   **5.2.1.1 Ressourcen (Resources)**: Keine direkt, Status wird über Werkzeuge/Benachrichtigungen gehandhabt.
    *   **5.2.1.2 Werkzeuge (Tools)**
        *   **Name**: `sendNotification`
        *   **Beschreibung**: Sendet eine Desktop-Benachrichtigung.
        *   **Tabelle 5.2.1.2.A**: Eingabeparameter für `sendNotification` (abgeleitet von `org.freedesktop.Notifications.Notify` [14])
ParameternameJSON-TypBeschreibungErforderlichDomänenschicht-Parameter (D-Bus)appNamestringName der Anwendung, die die Benachrichtigung sendet.Neinapp_name (STRING)replacesIdintegerID einer zu ersetzenden Benachrichtigung (0 für neu).Neinreplaces_id (UINT32)appIconstringPfad oder Name des Anwendungsicons.Neinapp_icon (STRING)summarystringZusammenfassung der Benachrichtigung.Jasummary (STRING)bodystringDetaillierter Text der Benachrichtigung.Neinbody (STRING)actionsarray of stringListe von Aktions-IDs und deren Beschriftungen (alternierend).Neinactions (as)hintsobjectZusätzliche Hinweise für den Server (z.B. Dringlichkeit).Neinhints (a{sv})expireTimeoutintegerTimeout in Millisekunden (-1 für Server-Default).Neinexpire_timeout (INT32)        *   **Tabelle 5.2.1.2.B**: Ausgabeparameter für `sendNotification`
ParameternameJSON-TypBeschreibungDomänenschicht-Rückgabe (D-Bus)notificationIdintegerEindeutige ID der Benachrichtigung.id (UINT32)        *   **Name**: `getNotificationCapabilities`
        *   **Beschreibung**: Frägt die Fähigkeiten des Benachrichtigungsservers ab.
        *   **Tabelle 5.2.1.2.C**: Ausgabeparameter für `getNotificationCapabilities` (abgeleitet von `org.freedesktop.Notifications.GetCapabilities` [14])
ParameternameJSON-TypBeschreibungDomänenschicht-Rückgabe (D-Bus)capabilitiesarray of stringListe der unterstützten Server-Fähigkeiten.capabilities (as)    *   **5.2.1.3 Benachrichtigungen (Notifications)**
        *   **Name**: `notificationClosed` (entspricht `org.freedesktop.Notifications.NotificationClosed` [14])
        *   **Tabelle 5.2.1.3.A**: Payload-Schema für `notificationClosed`
FeldnameJSON-TypBeschreibungDomänenschicht-Ereignisdaten (D-Bus)idintegerID der geschlossenen Benachrichtigung.id (UINT32)reasonintegerGrund für das Schließen (1=expired, 2=dismissed, 3=closed by call).reason (UINT32)*   *(Weitere Schnittstellen wie `de.nova.mcp.desktop.secrets`, `de.nova.mcp.desktop.power` etc. würden analog unter Verwendung der relevanten D-Bus Spezifikationen [15, 17, 21] und XDG Portal Spezifikationen [98, 100] detailliert werden.)*
Die explizite Abbildung auf Entitäten, Funktionen und Ereignisse der "Domänenschicht" in den Tabellen ist entscheidend, um die Nachvollziehbarkeit zu gewährleisten und zu verdeutlichen, wie die MCP-Schnittstellen mit dem zugrundeliegenden NovaDE-System zusammenhängen. Dies ist eine direkte Anforderung der Nutzeranfrage. Die Konsistenz zwischen dieser MCP-Spezifikation und der "Domänenschicht-Spezifikation" muss während der gesamten Entwicklung von NovaDE aufrechterhalten werden. Dieser Abschnitt wird der umfangreichste und detaillierteste sein und erfordert eine sorgfältige Definition von Schemata und Verhaltensweisen für jedes domänenspezifische MCP-Element, sobald die Domänenschicht-Spezifikation verfügbar ist.6. Implementierungsaspekte für NovaDEDieser Abschnitt behandelt empfohlene Technologien und Muster für die Implementierung von MCP-Clients und -Servern im NovaDE-Projekt, mit besonderem Fokus auf die Handhabung von Asynchronität und Verbindungsmanagement.

6.1. Empfohlene SDKs und BibliothekenDie Wahl der SDKs und Bibliotheken hängt von der jeweiligen Komponente und deren Anforderungen ab, insbesondere bezüglich des Transportmechanismus.

Rust:

Server-Implementierung: Für MCP-Server, die Server-Sent Events (SSE) für Benachrichtigungen nutzen müssen, wird das mcpr Crate empfohlen.10 Es bietet High-Level-Abstraktionen für Server, Werkzeuge und unterstützt verschiedene Transportmechanismen, einschließlich Stdio und SSE. Die Fähigkeit, Server-Push-Benachrichtigungen zu senden, ist für viele KI-Anwendungen kritisch, was mcpr favorisiert.
Client-Implementierung:

Das mcpr Crate 10 ist ebenfalls eine gute Wahl für Rust-basierte MCP-Clients, insbesondere wenn SSE-basierte Benachrichtigungen empfangen werden müssen. Es bietet eine konsistente API für Client- und Server-Entwicklung.
Das mcp_client_rs Crate von Darin Kishore 7 (basierend auf einer früheren Version von Derek-X-Wang/mcp-rust-sdk 109) ist eine weitere Option, primär für Stdio-basierte Kommunikation. Die Dokumentation ist jedoch weniger explizit bezüglich der Handhabung von asynchronen Server-Push-Benachrichtigungen über Stdio 9, was für reaktive Agenten ein Nachteil sein könnte. Die Unterstützung für WebSocket-Transport mit Wiederverbindungshandhabung ist zwar erwähnt, aber als "Coming Soon" markiert.109




Go: Für Komponenten des NovaDE-Projekts, die in Go implementiert werden, stellt mcp-go 6 eine valide Option dar. Dieses SDK unterstützt ebenfalls Stdio und bietet Abstraktionen für Server, Werkzeuge und Ressourcen.
Andere Sprachen: Da MCP auf JSON-RPC 2.0 basiert, können Clients und Server prinzipiell in jeder Sprache implementiert werden, die JSON-Verarbeitung und den gewählten Transportmechanismus (Stdio oder HTTP/SSE) unterstützt.



6.2. Handhabung von asynchronen Server-Sent NotificationsAsynchrone Benachrichtigungen vom Server zum Client sind ein Kernmerkmal von MCP, um KI-Agenten über Zustandsänderungen oder Ereignisse in der Domänenschicht zu informieren.3

Client-seitig:

Clients, die auf Server-Push-Benachrichtigungen reagieren müssen, sollten den SSE-Transportmechanismus verwenden. Das mcpr Crate in Rust bietet hierfür geeignete Abstraktionen, um einen SSE-Stream zu abonnieren und die eingehenden Nachrichten zu verarbeiten.10 Dies beinhaltet das Parsen der JSON-RPC-Benachrichtigungen und das Weiterleiten der params-Nutzlast an die zuständige Anwendungslogik.
Beispiele für MCP-Server, die Benachrichtigungen verwenden, wie der MCP Notify Server 122 oder die in mcp-go beschriebene Fähigkeit, Benachrichtigungen an spezifische Clients zu senden 6, unterstreichen die Wichtigkeit dieses Musters.
Für Stdio-Transporte ist die Handhabung von Server-Push-Benachrichtigungen komplexer, da Stdio primär für Request-Response-Interaktionen ausgelegt ist. mcp_client_rs müsste hierfür einen dedizierten Lesethread oder eine asynchrone Lese-Schleife implementieren, die kontinuierlich stdout des Servers auf neue Nachrichten überwacht und diese dann als Benachrichtigungen interpretiert.118 Die Dokumentation von mcp_client_rs ist hierzu nicht explizit.


Server-seitig:

NovaDE MCP-Server, die Benachrichtigungen senden müssen, sollten bei Verwendung von SSE die etablierten Mechanismen des gewählten Frameworks (z.B. mcpr in Rust oder FastAPI mit SSE-Support in Python 12) nutzen, um Nachrichten an alle oder ausgewählte verbundene Clients zu pushen.
Bei Stdio-Transport müssen Benachrichtigungen als reguläre JSON-RPC-Nachrichten auf stdout geschrieben werden, wobei der Client für das korrekte Parsen und Unterscheiden von regulären Antworten zuständig ist.





6.3. Behandlung von Verbindungsstatus-EreignissenEine robuste Behandlung von Verbindungsstatus ist essentiell für die Zuverlässigkeit.

Client-seitig:

Clients müssen Mechanismen zur Erkennung von Verbindungsabbrüchen implementieren. Dies kann durch Timeouts bei Requests, Fehler beim Lesen/Schreiben auf den Transportkanal oder spezifische Fehlermeldungen des Transport-SDKs geschehen.
Strategien für automatische Wiederverbindungsversuche sollten implementiert werden, idealerweise mit exponentiellem Backoff, um Server nicht zu überlasten.
Der mcpr-Client erwähnt die Handhabung von Prozessbeendigung und Pipe-Verbindungsproblemen bei Stdio.10 Die (geplante) WebSocket-Unterstützung in mcp_client_rs erwähnt "built-in reconnection handling".109
Allgemeine Prinzipien zur Fehlerbehebung bei Netzwerkverbindungen, wie in 123 für Azure Event Grid beschrieben (Port-Blockaden, Firewall-Regeln), können auch hier relevant sein, insbesondere bei HTTP/SSE.


Server-seitig:

MCP-Server sollten Client-Verbindungen aktiv verwalten, einschließlich Logging von Verbindungsaufbau und -abbau.
Bei Stdio-basierten Servern endet der Serverprozess typischerweise, wenn der Client die Verbindung trennt.10 Für langlebige Sitzungen muss dies bedacht werden.





6.4. Zustandsbehaftetes Sitzungsmanagement (Session Management)Einige Interaktionen mit KI-Modellen erfordern möglicherweise einen Zustand, der über mehrere MCP-Requests hinweg erhalten bleibt.

Server-seitig: Wenn NovaDE-Schnittstellen zustandsbehaftete Interaktionen erfordern, müssen MCP-Server Mechanismen zum Sitzungsmanagement implementieren. Das mcp-go SDK erwähnt explizit die Unterstützung für die Verwaltung separater Zustände für jeden verbundenen Client, das Verfolgen von Client-Sitzungen und die Möglichkeit, per-session Werkzeuganpassungen vorzunehmen.6
Dies könnte die Generierung und Verwaltung von Sitzungs-IDs beinhalten, die vom Client bei nachfolgenden Anfragen mitgesendet werden, oder die Nutzung inhärenter Sitzungsmerkmale des gewählten Transports (z.B. langlebige SSE-Verbindungen).
Die Notwendigkeit und Komplexität des Sitzungsmanagements hängt stark von den spezifischen Anwendungsfällen ab, die durch die "Domänenschicht-Spezifikation" definiert werden.


Die Wahl des SDKs und die Implementierung von Benachrichtigungs- und Verbindungsmanagement sind kritisch. Für NovaDE-Komponenten, die auf Server-Push-Benachrichtigungen angewiesen sind oder eine robustere Handhabung von Remote-Verbindungen benötigen, scheint mcpr aufgrund seiner expliziten SSE-Unterstützung die passendere Wahl in Rust zu sein. Die Client-Implementierungen in NovaDE müssen eine widerstandsfähige Logik für die Verarbeitung von Benachrichtigungsströmen und die Behandlung von Verbindungsfehlern enthalten, um die Stabilität und Reaktionsfähigkeit der KI-Agenten zu gewährleisten.7. Sicherheitsmodell für NovaDE MCP-SchnittstellenDie Sicherheit der MCP-Schnittstellen ist von größter Bedeutung, da sie potenziell Zugriff auf sensible Daten und kritische Funktionalitäten des NovaDE-Projekts ermöglichen. Das Sicherheitsmodell muss Authentifizierung, Autorisierung, Datensicherheit und Benutzereinwilligung umfassen. MCP selbst legt Wert auf Sicherheit 2, aber die konkrete Ausgestaltung obliegt dem NovaDE-Projekt.

7.1. Authentifizierung und Autorisierung

Client-Authentifizierung: Es müssen Mechanismen definiert werden, wie sich MCP-Clients gegenüber NovaDE-MCP-Servern authentifizieren.

Für Stdio-basierte Kommunikation ist die Authentifizierung oft implizit durch die Prozessgrenzen und Benutzerkontexte des Betriebssystems gegeben. Zusätzliche anwendungsspezifische Token können jedoch für eine feinere Kontrolle verwendet werden.
Für HTTP/SSE-basierte Kommunikation sind explizite Authentifizierungsmechanismen erforderlich. Optionen umfassen:

Token-basierte Authentifizierung (z.B. API-Keys, JWTs), die im HTTP-Header übertragen werden.
OAuth 2.0, falls externe Clients oder Benutzer im Namen von Benutzern agieren. MCP unterstützt prinzipiell OAuth.3
Es ist zu beachten, dass die MCP-Spezifikation zum Zeitpunkt einiger Referenzdokumente möglicherweise keinen standardisierten Authentifizierungsmechanismus für SSE-Server definierte.12 Daher muss NovaDE hier ggf. eine eigene Lösung implementieren oder auf Netzwerkebene absichern (z.B. über VPN, IP-Whitelisting oder einen Reverse-Proxy, der die Authentifizierung übernimmt).




Server-Authentifizierung: Clients müssen die Identität der NovaDE-MCP-Server überprüfen können, insbesondere bei HTTP/SSE-Kommunikation. Dies geschieht typischerweise durch TLS-Zertifikate, deren Validierung clientseitig erfolgen muss.
Autorisierungsrichtlinien: Nach erfolgreicher Authentifizierung muss die Autorisierung erfolgen. Es muss klar definiert werden, welche authentifizierten Clients (oder Benutzer, in deren Namen sie handeln) auf welche MCP-Server, Ressourcen und Werkzeuge zugreifen dürfen.

Dies erfordert eine Integration mit einem bestehenden oder neu zu definierenden Identitäts- und Zugriffsmanagementsystem (IAM) für NovaDE.
Das MCP Host-Konzept ist hier zentral: Der Host-Prozess ist für die Verwaltung von Sicherheitsrichtlinien und Benutzerautorisierung zuständig.2 Dies impliziert, dass der NovaDE MCP Host eine kritische Rolle bei der Durchsetzung von Zugriffsrechten spielt.
Wenn MCP-Server privilegierte Operationen im System ausführen (z.B. bei Integration mit Desktop-Technologien), könnte PolicyKit 108 für die Autorisierungsprüfungen auf Systemebene herangezogen werden. Der MCP-Server würde dann als Mechanismus im Sinne von PolicyKit agieren.





7.2. Berechtigungsmodell für Ressourcen und Werkzeuge

Es ist ein granulares Berechtigungsmodell zu definieren, das spezifische Aktionen auf MCP-Ressourcen (z.B. read, write, list) und die Ausführung von MCP-Werkzeugen (execute) abdeckt.
Diese Berechtigungen sollten an Rollen oder individuelle Client-Identitäten gebunden sein und vom MCP-Server bzw. dem MCP-Host bei jeder Anfrage überprüft werden.
Die Definition dieser Berechtigungen muss eng mit der "Domänenschicht-Spezifikation" und den dort definierten Zugriffsregeln verknüpft sein.



7.3. Datensicherheit

Verschlüsselung bei der Übertragung (Encryption in Transit): Für HTTP/SSE-basierte MCP-Kommunikation ist die Verwendung von TLS (HTTPS/WSS) zwingend erforderlich, um die Vertraulichkeit und Integrität der übertragenen Daten zu gewährleisten.
Verschlüsselung im Ruhezustand (Encryption at Rest): Falls NovaDE-MCP-Server Daten persistent speichern (z.B. Konfigurationen, zwischengespeicherte Ressourcendaten), müssen diese Daten im Ruhezustand verschlüsselt werden, um unbefugten Zugriff zu verhindern. Die Wahl der Verschlüsselungsmethoden sollte aktuellen Sicherheitsstandards entsprechen.
Geheimnisverwaltung (Secret Management): MCP-Server benötigen möglicherweise Geheimnisse (API-Schlüssel, Datenbank-Passwörter, Zugriffstoken für die Domänenschicht). Diese Geheimnisse müssen sicher gespeichert und verwaltet werden.

Die Nutzung der Freedesktop Secrets API über D-Bus (Schnittstelle org.freedesktop.Secrets 15) ist eine Option für NovaDE-MCP-Server, um solche Geheimnisse sicher im Benutzerkontext oder Systemkontext zu speichern und abzurufen. Dies ist besonders relevant, wenn Server im Auftrag des Benutzers auf geschützte Domänenressourcen zugreifen.





7.4. Benutzereinwilligung (User Consent)

Für Operationen, die auf sensible Benutzerdaten zugreifen oder signifikante Aktionen im Namen des Benutzers ausführen (z.B. das Ändern von Systemeinstellungen, Senden von Nachrichten), müssen Mechanismen zur Einholung der expliziten Zustimmung des Benutzers implementiert werden.
Der MCP Host-Prozess spielt auch hier eine Rolle bei der Durchsetzung von Einwilligungsanforderungen.2
Die Gestaltung der Einwilligungsdialoge muss transparent und verständlich sein, damit der Benutzer eine informierte Entscheidung treffen kann. XDG Desktop Portals 87 bieten Standardmechanismen für benutzervermittelte Zugriffsanfragen, die als Inspiration dienen oder direkt genutzt werden könnten, falls MCP-Werkzeuge solche Portale kapseln.


Die Sicherheitsarchitektur von NovaDE muss einen oder mehrere MCP Hosts definieren, die als Gatekeeper fungieren und die oben genannten Sicherheitsfunktionen koordinieren und durchsetzen. Ohne klar definierte Hosts könnten Sicherheitsrichtlinien inkonsistent angewendet werden.8. FehlerbehandlungsspezifikationEine konsistente und informative Fehlerbehandlung ist entscheidend für die Robustheit, Wartbarkeit und Benutzerfreundlichkeit der MCP-Schnittstellen im NovaDE-Projekt. Diese Spezifikation definiert Standardfehlercodes und Richtlinien für die Fehlerbehandlung.

8.1. Standard-MCP-Fehlercodes für NovaDEZusätzlich zu den Standard-JSON-RPC-2.0-Fehlercodes (Parse Error: -32700, Invalid Request: -32600, Method not found: -32601, Invalid params: -32602, Internal error: -32603) definiert NovaDE einen Satz erweiterter Fehlercodes, um spezifischere Fehlersituationen innerhalb des MCP-Kontexts zu signalisieren. Diese Codes sollten von allen NovaDE-MCP-Servern konsistent verwendet werden. Die Struktur der Fehlerantwort folgt dem Standard-JSON-RPC-Error-Objekt.5

Tabelle 8.1: NovaDE MCP Fehlercodes


CodeName (Konstante)Nachricht (Template)HTTP-Status (für SSE)Beschreibung-32000DOMAIN_SPECIFIC_ERROR"Domänenspezifischer Fehler: {details}"500Ein Fehler ist in der NovaDE-Domänenschicht aufgetreten. {details} kann spezifische Informationen enthalten.-32001RESOURCE_NOT_FOUND"Ressource '{uri}' nicht gefunden."404Die angeforderte MCP-Ressource existiert nicht oder ist nicht zugänglich.-32002TOOL_EXECUTION_FAILED"Ausführung des Werkzeugs '{toolName}' fehlgeschlagen."500Ein unerwarteter Fehler während der Ausführung eines MCP-Werkzeugs.-32003INVALID_TOOL_PARAMETERS"Ungültige Parameter für Werkzeug '{toolName}'."400Die für ein MCP-Werkzeug bereitgestellten Parameter sind ungültig oder unvollständig.-32004PERMISSION_DENIED"Zugriff für Operation '{operation}' auf '{target}' verweigert."403Dem aufrufenden Client fehlen die notwendigen Berechtigungen für die angeforderte Operation.-32005SERVER_UNAVAILABLE"MCP-Server ist temporär nicht verfügbar."503Der angefragte MCP-Server ist derzeit nicht erreichbar oder überlastet.-32006AUTHENTICATION_FAILED"Authentifizierung fehlgeschlagen."401Die Authentifizierung des Clients ist fehlgeschlagen.-32007PROTOCOL_VERSION_MISMATCH"Inkompatible Protokollversion. Client: {clientVersion}, Server unterstützt: {serverVersions}"400Client und Server konnten sich nicht auf eine gemeinsame MCP-Protokollversion einigen.Die Verwendung von Rust-Bibliotheken wie `thiserror` [125, 126, 127] oder `snafu` [128] wird für die Implementierung strukturierter Fehler in den Rust-basierten MCP-Servern von NovaDE empfohlen. Diese Bibliotheken erleichtern die Definition von Fehler-Enums, die automatische Implementierung von `std::error::Error` und `Display`, sowie das Anhängen von Kontextinformationen.


8.2. Fehlerweiterleitung (Error Propagation)

MCP-Server müssen Fehler, die in der darunterliegenden Domänenschicht oder von abhängigen Diensten (z.B. D-Bus-Dienste, externe APIs) auftreten, abfangen und in standardisierte MCP-Fehlerantworten umwandeln. Dabei ist es wichtig, eine Balance zu finden: Einerseits soll genügend Kontext für die Fehlerdiagnose bereitgestellt werden, andererseits dürfen keine sensiblen internen Implementierungsdetails oder Sicherheitsinformationen an den Client durchsickern.
Die source-Kette von Fehlern, wie sie von std::error::Error und Crates wie thiserror unterstützt wird, kann intern zur Diagnose verwendet werden, aber die an den MCP-Client gesendete Fehlernachricht sollte sorgfältig formuliert sein. Die Diskussion in 128 über das Gruppieren mehrerer Fehlertypen und das Hinzufügen von Kontext ist hier relevant.



8.3. Client-seitige Fehlerbehandlung

MCP-Clients im NovaDE-Projekt müssen robust auf Fehlerantworten reagieren. Dies beinhaltet das Parsen des error-Objekts, die Interpretation des code und der message, und gegebenenfalls die Nutzung der data-Komponente.
Abhängig vom Fehlercode und der Natur des Fehlers können verschiedene Strategien angewendet werden:

Wiederholungsversuche (Retries): Bei temporären Fehlern (z.B. SERVER_UNAVAILABLE oder bestimmten Netzwerkfehlern) können Clients Wiederholungsversuche mit exponentiellem Backoff implementieren.
Benutzerbenachrichtigung: Bei Fehlern, die eine Benutzerinteraktion erfordern oder den Benutzer über ein Problem informieren müssen (z.B. PERMISSION_DENIED, AUTHENTICATION_FAILED), sollte eine klare und verständliche Meldung angezeigt werden.
Graceful Degradation: Wenn eine Funktionalität aufgrund eines Fehlers nicht verfügbar ist, sollte der Client versuchen, in einem eingeschränkten Modus weiterzuarbeiten oder alternative Pfade anzubieten.


Die mcp_client_rs 7 und mcpr 10 SDKs stellen Result-Typen für ihre Operationen bereit, die eine Fehlerbehandlung über das Err-Variant ermöglichen.

Die Unterscheidung zwischen Protokollfehlern (die eine JSON-RPC ErrorResponse auslösen) und anwendungsspezifischen Werkzeug-Fehlern ist wichtig. Wie in 116 (impliziert durch isError in CallToolResult bei einigen SDK-Interpretationen) angedeutet, kann ein Werkzeugaufruf protokollkonform erfolgreich sein, die interne Logik des Werkzeugs jedoch fehlschlagen. In solchen Fällen sollte die CallToolResult isError: true und ein anwendungsspezifisches error-Objekt im result-Feld enthalten, anstatt einen JSON-RPC-Protokollfehler auszulösen. Dies ermöglicht eine differenziertere Fehlerbehandlung auf Client-Seite. Diese Spezifikation muss klar definieren, wann welche Art von Fehler gemeldet wird.

9. Versionierung und ProtokollevolutionUm die langfristige Wartbarkeit und Kompatibilität der MCP-Schnittstellen im NovaDE-Projekt sicherzustellen, ist eine klare Strategie für Versionierung und Protokollevolution unerlässlich.

9.1. MCP-Versionsstrategie für NovaDE

Globale MCP-Version: Das NovaDE-Projekt wird sich an der offiziellen Versionierung des Model Context Protocol orientieren, wie sie von den Standardisierungsgremien (z.B. Anthropic und die Community) vorgegeben wird. Aktuell wird auf eine Version wie "2025-03-26" referenziert.5 Die Initialize-Nachricht dient dem Aushandeln dieser Basis-Protokollversion zwischen Client und Server.3
NovaDE-spezifische Schnittstellenversionierung: Jede in Abschnitt 5 definierte, NovaDE-spezifische MCP-Schnittstelle (z.B. de.nova.mcp.core.systemInfo) erhält eine eigene semantische Versionierung (z.B. 1.0.0). Diese Version wird im serverVersion-Feld der InitializeResult-Nachricht für den jeweiligen Server und idealerweise als Teil der Metadaten einer Ressource oder eines Werkzeugs kommuniziert.
Granularität der Versionierung: Einzelne Ressourcen oder Werkzeuge innerhalb einer Schnittstelle können bei Bedarf ebenfalls versioniert werden, falls sich ihre Schemata oder Verhalten unabhängig von der Gesamtschnittstelle ändern. Dies sollte jedoch zugunsten der Einfachheit vermieden werden, wenn möglich.



9.2. Umgang mit abwärtskompatiblen ÄnderungenAbwärtskompatible Änderungen sind solche, die bestehende Clients nicht brechen.

Beispiele:

Hinzufügen neuer, optionaler Felder zu Anfrage- oder Antwort-Payloads.
Hinzufügen neuer, optionaler Parameter zu Werkzeugen.
Hinzufügen neuer Werkzeuge oder Ressourcen zu einer bestehenden Schnittstelle.
Hinzufügen neuer Werte zu Enums (Clients sollten unbekannte Enum-Werte tolerant behandeln).


Vorgehen: Solche Änderungen führen zu einer Erhöhung der Minor- oder Patch-Version der betroffenen NovaDE-spezifischen Schnittstelle (z.B. von 1.0.0 auf 1.1.0 oder 1.0.1). Clients, die für eine ältere Minor-Version entwickelt wurden, sollten weiterhin mit Servern funktionieren, die eine neuere Minor-Version derselben Major-Version implementieren.



9.3. Umgang mit abwärtsinkompatiblen ÄnderungenAbwärtsinkompatible Änderungen sind solche, die bestehende Clients potenziell brechen können.

Beispiele:

Entfernen von Feldern aus Anfrage- oder Antwort-Payloads.
Umbenennen von Feldern oder Ändern ihres Datentyps.
Ändern erforderlicher Parameter für Werkzeuge.
Entfernen von Werkzeugen oder Ressourcen.
Grundlegende Änderung der Semantik einer Operation.


Vorgehen:

Solche Änderungen erfordern eine Erhöhung der Major-Version der betroffenen NovaDE-spezifischen Schnittstelle (z.B. von 1.1.0 auf 2.0.0).
Es wird dringend empfohlen, abwärtsinkompatible Änderungen so weit wie möglich zu vermeiden.
Wenn eine solche Änderung unumgänglich ist, sollte idealerweise für eine Übergangszeit sowohl die alte als auch die neue Version der Schnittstelle parallel angeboten werden (z.B. unter einem anderen Endpunkt oder mit einer expliziten Versionsauswahl im Initialize-Request).
Eine klare Kommunikation und Migrationspfade für Clients müssen bereitgestellt werden.



Die Initialize-Nachricht spielt eine Schlüsselrolle bei der Versionierung, da sie es Clients und Servern ermöglicht, ihre unterstützten Protokollversionen und optional auch spezifische Feature-Flags auszutauschen.3 NovaDE-Clients sollten darauf vorbereitet sein, dass Server möglicherweise nicht alle angefragten Features oder die exakt gleiche Schnittstellenversion unterstützen, und entsprechend reagieren (z.B. durch Deaktivieren bestimmter Funktionalitäten oder Melden einer Inkompatibilität).

10. SchlussfolgerungenDie Implementierung des Model Context Protocol (MCP) im NovaDE-Projekt stellt einen strategisch wichtigen Schritt dar, um die Integration von KI-Funktionalitäten auf einer standardisierten, flexiblen und zukunftssicheren Basis zu ermöglichen. Diese Ultra-Feinspezifikation legt den detaillierten Rahmen für die MCP-Schnittstellen, Nachrichtenformate, Integrationsstrategien mit der Domänenschicht sowie für Implementierungs-, Sicherheits- und Fehlerbehandlungsaspekte fest.Wesentliche Erkenntnisse und Implikationen sind:
Standardisierung als Fundament: MCP bietet eine universelle Sprache für die Kommunikation zwischen KI-Modellen und den vielfältigen Datenquellen und Werkzeugen des NovaDE-Projekts.1 Dies reduziert den Aufwand für proprietäre Integrationen und fördert die Interoperabilität.
Abhängigkeit von der Domänenschicht: Die konkrete Ausgestaltung der NovaDE-spezifischen MCP-Ressourcen, -Werkzeuge und -Benachrichtigungen ist untrennbar mit der noch zu detaillierenden "Domänenschicht-Spezifikation" verbunden. Diese Spezifikation muss als Grundlage für die in Abschnitt 5 vorgesehenen Definitionen dienen.
Architektonische Entscheidungen: Die Wahl der Transportmechanismen (Stdio vs. HTTP/SSE) und die klare Definition von MCP Host-, Server- und Client-Rollen innerhalb der NovaDE-Architektur sind entscheidend für Leistung, Skalierbarkeit und Sicherheit.2 Für reaktive Agenten und Server-Push-Benachrichtigungen ist SSE der empfohlene Weg.
Rust SDKs: Für die Implementierung in Rust bieten sich mcpr 10 und mcp_client_rs 7 an, wobei mcpr aufgrund seiner expliziten SSE-Unterstützung und moderneren Anmutung für komplexere Szenarien mit Benachrichtigungen tendenziell vorzuziehen ist.
Sicherheit als Priorität: Ein robustes Sicherheitsmodell, das Authentifizierung, Autorisierung, Datensicherheit und Benutzereinwilligung umfasst, ist unerlässlich. Die Integration mit bestehenden Systemmechanismen (z.B. PolicyKit, Freedesktop Secrets API) sollte geprüft werden, falls die Domänenschicht dies erfordert.2
Konsistente Fehlerbehandlung und Versionierung: Standardisierte Fehlercodes und eine klare Versionierungsstrategie sind für die Wartbarkeit und Weiterentwicklung des Systems unabdingbar.
Empfehlungen für das weitere Vorgehen:
Priorisierung der Domänenschicht-Spezifikation: Die Fertigstellung und Detaillierung der "Domänenschicht-Spezifikation" ist der nächste kritische Schritt, um die in diesem Dokument vorbereiteten MCP-Schnittstellendefinitionen (Abschnitt 5) mit Leben zu füllen.
Prototypische Implementierung: Es wird empfohlen, frühzeitig mit der prototypischen Implementierung ausgewählter MCP-Server und -Clients zu beginnen, basierend auf den hier spezifizierten Standards und unter Verwendung der evaluierten SDKs. Dies hilft, die Konzepte zu validieren und praktische Erfahrungen zu sammeln.
Iterative Verfeinerung: Diese Spezifikation sollte als lebendes Dokument betrachtet und parallel zur Entwicklung der Domänenschicht und der MCP-Komponenten iterativ verfeinert werden.
Fokus auf Sicherheit: Sicherheitsaspekte müssen von Beginn an in Design und Implementierung aller MCP-Komponenten berücksichtigt werden.
Entwickler-Schulung: Sicherstellen, dass alle beteiligten Entwickler ein tiefes Verständnis von MCP und dieser Spezifikation erlangen.
Durch die konsequente Anwendung dieser Spezifikation kann das NovaDE-Projekt eine leistungsfähige und flexible MCP-Infrastruktur aufbauen, die es ermöglicht, das volle Potenzial moderner KI-Modelle auszuschöpfen.11. Anhang

11.1. Glossar

MCP (Model Context Protocol): Ein offener Standard zur Verbindung von KI-Modellen mit externen Datenquellen und Werkzeugen.
JSON-RPC 2.0: Ein leichtgewichtiges Remote Procedure Call Protokoll, das als Basis für MCP dient.
Ressource (Resource): Eine Dateneinheit, die von einem MCP-Server bereitgestellt und von einem Client gelesen werden kann.
Werkzeug (Tool): Eine Funktion oder Operation, die von einem MCP-Server bereitgestellt und von einem Client aufgerufen werden kann, um Aktionen auszuführen.
Aufforderung (Prompt): Eine vordefinierte Vorlage für Interaktionen mit einem LLM, die Systemanweisungen und Argumente umfassen kann.
Benachrichtigung (Notification): Eine asynchrone Nachricht vom Server an den Client, die über Ereignisse oder Zustandsänderungen informiert.
Stdio (Standard Input/Output): Ein Transportmechanismus für MCP, der auf Standard-Datenströmen basiert, typischerweise für lokale Prozesskommunikation.
SSE (Server-Sent Events): Ein Transportmechanismus für MCP über HTTP, der es einem Server ermöglicht, kontinuierlich Daten an einen Client zu senden.
Domänenschicht: Die spezifische Anwendungslogik und Datenmodelle des NovaDE-Projekts.
NovaDE: Name des Projekts, für das diese MCP-Spezifikation erstellt wird.
Client (MCP): Eine Softwarekomponente (oft Teil eines KI-Agenten oder einer Anwendung), die mit einem MCP-Server interagiert, um Kontext zu erhalten oder Aktionen auszuführen.
Server (MCP): Eine Softwarekomponente, die Daten oder Funktionalitäten über das MCP-Protokoll bereitstellt.
Host (MCP): Eine Anwendung oder Umgebung, die MCP-Clients beherbergt und deren Interaktionen mit MCP-Servern koordiniert und absichert.
URI (Uniform Resource Identifier): Eine Zeichenfolge zur eindeutigen Identifizierung einer Ressource.



11.2. JSON Schema Beispiele (Referenz)(Dieser Abschnitt würde exemplarische JSON-Schemata für typische Ressourcen oder Werkzeugparameter enthalten, um die in den Tabellen beschriebenen Strukturen zu illustrieren. Aufgrund der fehlenden Domänenschicht-Spezifikation sind dies allgemeine Beispiele.)


Beispiel: Ressourcenschema für ein einfaches Dateiobjekt
JSON{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "NovaDEFileResource",
  "description": "Repräsentiert eine Datei im NovaDE-System.",
  "type": "object",
  "properties": {
    "uri": {
      "type": "string",
      "format": "uri",
      "description": "Eindeutiger URI der Datei."
    },
    "name": {
      "type": "string",
      "description": "Dateiname."
    },
    "size": {
      "type": "integer",
      "description": "Dateigröße in Bytes.",
      "minimum": 0
    },
    "mimeType": {
      "type": "string",
      "description": "MIME-Typ der Datei."
    },
    "lastModified": {
      "type": "string",
      "format": "date-time",
      "description": "Zeitpunkt der letzten Änderung (ISO 8601)."
    },
    "contentPreview": {
      "type": "string",
      "description": "Optionale Vorschau des Dateiinhalts (z.B. erste Zeilen einer Textdatei)."
    }
  },
  "required":
}



Beispiel: Parameterschema für ein Werkzeug createDocument
JSON{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "CreateDocumentToolParams",
  "description": "Parameter für das Werkzeug 'createDocument'.",
  "type": "object",
  "properties": {
    "parentFolderUri": {
      "type": "string",
      "format": "uri",
      "description": "URI des Ordners, in dem das Dokument erstellt werden soll."
    },
    "documentName": {
      "type": "string",
      "description": "Name des zu erstellenden Dokuments.",
      "minLength": 1
    },
    "initialContent": {
      "type": "string",
      "description": "Optionaler initialer Inhalt des Dokuments."
    },
    "templateId": {
      "type": "string",
      "description": "Optionale ID einer Vorlage, die für das neue Dokument verwendet werden soll."
    }
  },
  "required": [
    "parentFolderUri",
    "documentName"
  ]
}



Beispiel: Ergebnisschema für ein Werkzeug createDocument
JSON{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "CreateDocumentToolResult",
  "description": "Ergebnis des Werkzeugs 'createDocument'.",
  "type": "object",
  "properties": {
    "documentUri": {
      "type": "string",
      "format": "uri",
      "description": "URI des neu erstellten Dokuments."
    },
    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "Zeitpunkt der Erstellung (ISO 8601)."
    }
  },
  "required": [
    "documentUri",
    "timestamp"
  ]
}





# Ultra-Feinspezifikation der MCP-Schnittstellen und Implementierungen für das NovaDE-Projekt

## 1. Einleitung

### 1.1. Zweck des Dokuments

Dieses Dokument definiert die Ultra-Feinspezifikation aller Model Context Protocol (MCP) Schnittstellen und deren Implementierungen innerhalb des NovaDE-Projekts. Es dient als maßgebliche technische Referenz für die Entwicklung, Integration und Wartung von MCP-basierten Komponenten im NovaDE-Ökosystem. Die Spezifikation umfasst detaillierte Beschreibungen von Nachrichtenformaten, Datenstrukturen, Methoden, Ereignissen und Fehlerbehandlungsmechanismen. Ein besonderer Fokus liegt auf der Integration der Domänenschicht-Spezifikation des NovaDE-Projekts in die MCP-Schnittstellen.

### 1.2. Geltungsbereich

Diese Spezifikation bezieht sich auf sämtliche Aspekte des Model Context Protocol, wie es im Kontext des NovaDE-Projekts eingesetzt wird. Dies beinhaltet:

- Alle MCP-Schnittstellen, die im NovaDE-Projekt definiert oder genutzt werden.
- Die Interaktion dieser MCP-Schnittstellen mit anderen Systemkomponenten, einschließlich, aber nicht beschränkt auf D-Bus-Dienste, Wayland-Protokolle und PipeWire-Audio-Management.
- Implementierungsrichtlinien und -details, insbesondere unter Verwendung der Programmiersprache Rust und assoziierter Bibliotheken.
- Die nahtlose Einbindung der fachlichen Anforderungen und Datenmodelle aus der Domänenschicht-Spezifikation des NovaDE-Projekts.

### 1.3. Zielgruppe

Dieses Dokument richtet sich an folgende Personengruppen innerhalb des NovaDE-Projekts:

- Softwarearchitekten und -entwickler, die MCP-Schnittstellen und -Komponenten entwerfen, implementieren oder nutzen.
- Systemintegratoren, die für die Bereitstellung und Konfiguration von NovaDE-Systemen verantwortlich sind.
- Qualitätssicherungsingenieure, die MCP-Funktionalitäten testen.
- Technische Projektmanager, die die Entwicklung und Implementierung des NovaDE-Projekts überwachen.

### 1.4. Definitionen und Akronyme

- **MCP:** Model Context Protocol. Ein offener Standard zur Kommunikation zwischen KI-Modellen/Anwendungen und externen Werkzeugen oder Datenquellen.1
- **NovaDE-Projekt:** Das spezifische Projekt, für das diese MCP-Spezifikation erstellt wird. (Details zum Projekt selbst sind außerhalb des Geltungsbereichs der bereitgestellten Materialien).
- **Domänenschicht-Spezifikation:** Ein separates Dokument, das die fachlichen Entitäten, Geschäftsregeln und Datenmodelle des NovaDE-Projekts beschreibt. Diese Spezifikation wird als integraler Bestandteil der MCP-Schnittstellendefinitionen betrachtet.
- **API:** Application Programming Interface.
- **D-Bus:** Desktop Bus, ein System für Interprozesskommunikation (IPC).3
- **Wayland:** Ein Kommunikationsprotokoll zwischen einem Display-Server (Compositor) und seinen Clients.4
- **PipeWire:** Ein Multimedia-Framework für Audio- und Videoverarbeitung unter Linux.5
- **XDG Desktop Portals:** Ein Framework, das sandboxed Anwendungen den sicheren Zugriff auf Ressourcen außerhalb der Sandbox ermöglicht.6
- **JSON-RPC:** JavaScript Object Notation Remote Procedure Call. Ein leichtgewichtiges RPC-Protokoll.8
- **Stdio:** Standard Input/Output.
- **SSE:** Server-Sent Events. Eine Technologie, die es einem Server ermöglicht, Updates an einen Client über eine HTTP-Verbindung zu pushen.8
- **Smithay:** Eine Rust-Bibliothek zur Erstellung von Wayland-Compositoren.10
- **zbus:** Eine Rust-Bibliothek für die D-Bus-Kommunikation.12
- **pipewire-rs:** Rust-Bindungen für PipeWire.14
- **mcpr:** Eine Rust-Implementierung des Model Context Protocol.16
- **mcp_client_rs:** Eine weitere Rust-Client-SDK für MCP.17

### 1.5. Referenzierte Dokumente

- Model Context Protocol Specification (Version 2025-03-26 oder aktueller) 2
- Domänenschicht-Spezifikation des NovaDE-Projekts (externes Dokument)
- Freedesktop D-Bus Specification 3
- Wayland Protocol Specification 4
- PipeWire Documentation 5
- XDG Desktop Portal Documentation 6
- Spezifikationen der relevanten D-Bus-Schnittstellen (Secrets, PolicyKit, Portals, Login1, UPower, Notifications)
- Spezifikationen der relevanten Wayland-Protokolle und -Erweiterungen
- Dokumentation der verwendeten Rust-Bibliotheken (Smithay, zbus, pipewire-rs, mcpr, mcp_client_rs, tokio, serde, thiserror etc.)

## 2. Model Context Protocol (MCP) – Grundlagen

### 2.1. Überblick und Kernkonzepte

Das Model Context Protocol (MCP) ist ein offener Standard, der darauf abzielt, die Integration von Large Language Models (LLMs) mit externen Werkzeugen, Datenbanken und APIs zu standardisieren.1 Es fungiert als eine universelle Schnittstelle, die es KI-Modellen ermöglicht, dynamisch auf Kontextinformationen zuzugreifen und Aktionen in ihrer Umgebung auszuführen.9 MCP adressiert die Herausforderung der Informationssilos und proprietären Integrationen, indem es einen einheitlichen Rahmen für die KI-Tool-Kommunikation schafft.1

Die Kernprinzipien von MCP umfassen 2:

- **Standardisierte Schnittstelle:** Einheitliche Methoden für LLMs zum Zugriff auf Werkzeuge und Ressourcen.
- **Erweiterte Fähigkeiten:** Befähigung von LLMs zur Interaktion mit diversen Systemen.
- **Sicherheit und Kontrolle:** Strukturierte Zugriffsmuster mit integrierter Validierung und klaren Grenzen.
- **Modularität und Erweiterbarkeit:** Einfaches Hinzufügen neuer Fähigkeiten durch Server, ohne die Kernanwendung des LLMs modifizieren zu müssen.

MCP ist darauf ausgelegt, die Reproduzierbarkeit von KI-Interaktionen zu verbessern, indem der gesamte notwendige Kontext (Datensätze, Umgebungsspezifikationen, Hyperparameter) an einem Ort verwaltet wird.1

### 2.2. Architektur (Client-Host-Server-Modell)

MCP basiert auf einer Client-Host-Server-Architektur 8:

- **Host:** Eine LLM-Anwendung (z.B. Claude Desktop, IDEs), die Verbindungen initiiert und als Container oder Koordinator für mehrere Client-Instanzen fungiert. Der Host verwaltet den Lebenszyklus, Sicherheitsrichtlinien (Berechtigungen, Benutzerautorisierung) und die Integration des LLMs.1
- **Client:** Eine Protokoll-Client-Komponente innerhalb der Host-Anwendung, die eine 1:1-Verbindung zu einem MCP-Server herstellt. Der Client ist verantwortlich für die Aushandlung von Fähigkeiten und die Orchestrierung von Nachrichten zwischen sich und dem Server.1
- **Server:** Ein Dienst (oft ein leichtgewichtiger Prozess), der spezifische Kontexte, Werkzeuge und Prompts für den Client bereitstellt. Server können lokale Prozesse oder entfernte Dienste sein und kapseln den Zugriff auf Datenquellen, APIs oder andere Utilities.1

Diese Architektur ermöglicht eine klare Trennung der Verantwortlichkeiten und fördert die Entwicklung modularer und wiederverwendbarer MCP-Server.23 Die Kommunikation zwischen diesen Komponenten erfolgt über eine Transportschicht und eine Protokollschicht, die auf JSON-RPC aufbaut und zustandsbehaftete Sitzungen für den Kontextaustausch und das Sampling betont.1

### 2.3. Nachrichtenformate (JSON-RPC 2.0 Basis)

MCP verwendet JSON-RPC 2.0 als Grundlage für seine Nachrichtenformate.8 Dies gewährleistet eine strukturierte und standardisierte Kommunikation. Die Hauptnachrichtentypen sind 8:

- **Requests (Anfragen):** Vom Client oder Server gesendete Nachrichten, die eine Antwort erwarten. Sie enthalten typischerweise eine `method` (Methodenname) und optionale `params` (Parameter).
    - Beispiel: `{"jsonrpc": "2.0", "method": "tools/list", "id": 1}`
- **Responses (Antworten):** Erfolgreiche Antworten auf Requests. Sie enthalten ein `result`-Feld mit den Ergebnisdaten und die `id` des ursprünglichen Requests.
    - Beispiel: `{"jsonrpc": "2.0", "result": {"tools": [...]}, "id": 1}`
- **Error Responses (Fehlerantworten):** Antworten, die anzeigen, dass ein Request fehlgeschlagen ist. Sie enthalten ein `error`-Objekt mit `code`, `message` und optional `data`, sowie die `id` des ursprünglichen Requests.
    - Beispiel: `{"jsonrpc": "2.0", "error": {"code": -32601, "message": "Method not found"}, "id": 1}`
- **Notifications (Benachrichtigungen):** Einwegnachrichten, die keine Antwort erwarten. Sie enthalten eine `method` und optionale `params`, aber keine `id`.
    - Beispiel: `{"jsonrpc": "2.0", "method": "textDocument/didChange", "params": {...}}`

Die spezifischen Methoden und Parameter für MCP-Nachrichten wie `initialize`, `tools/list`, `resources/read`, `tools/call` werden im weiteren Verlauf dieses Dokuments detailliert [2 (angenommen)].

### 2.4. Transportmechanismen

MCP unterstützt verschiedene Transportmechanismen für die Kommunikation zwischen Host/Client und Server 8:

- **Stdio (Standard Input/Output):** Dieser Mechanismus wird für die Kommunikation mit lokalen Prozessen verwendet. Der MCP-Server läuft als separater Prozess, und die Kommunikation erfolgt über dessen Standard-Eingabe- und Ausgabe-Streams. Dies ist ideal für Kommandozeilenwerkzeuge und lokale Entwicklungsszenarien.16 Die Rust-Bibliothek `mcpr` bietet beispielsweise `StdioTransport` 16, und `mcp_client_rs` fokussiert sich ebenfalls auf diesen Transportweg für lokal gespawnte Server.18
- **HTTP mit SSE (Server-Sent Events):** Dieser Mechanismus wird für netzwerkbasierte Kommunikation verwendet, insbesondere wenn der Server remote ist oder Echtzeit-Updates vom Server an den Client erforderlich sind. SSE ermöglicht es dem Server, asynchron Nachrichten an den Client zu pushen, während Client-zu-Server-Nachrichten typischerweise über HTTP POST gesendet werden.8 Die `mcpr`-Bibliothek erwähnt SSE-Transportunterstützung.16

Die Wahl des Transportmechanismus hängt von den spezifischen Anforderungen der NovaDE-Komponente ab, insbesondere davon, ob der MCP-Server lokal oder remote betrieben wird.

### 2.5. Sicherheitsaspekte

Sicherheit und Datenschutz sind zentrale Aspekte des Model Context Protocol, da es potenziell den Zugriff auf sensible Daten und die Ausführung von Code ermöglicht.2 Die Spezifikation legt folgende Schlüsselprinzipien fest 2:

- **Benutzereinwilligung und -kontrolle:**
    - Benutzer müssen explizit allen Datenzugriffen und Operationen zustimmen und diese verstehen.
    - Benutzer müssen die Kontrolle darüber behalten, welche Daten geteilt und welche Aktionen ausgeführt werden.
    - Implementierungen sollten klare Benutzeroberflächen zur Überprüfung und Autorisierung von Aktivitäten bereitstellen.
- **Datenschutz:**
    - Hosts müssen die explizite Zustimmung des Benutzers einholen, bevor Benutzerdaten an Server weitergegeben werden.
    - Hosts dürfen Ressourcendaten nicht ohne Zustimmung des Benutzers an andere Stellen übertragen.
    - Benutzerdaten sollten durch geeignete Zugriffskontrollen geschützt werden.
- **Werkzeugsicherheit (Tool Safety):**
    - Werkzeuge repräsentieren die Ausführung von beliebigem Code und müssen mit entsprechender Vorsicht behandelt werden. Beschreibungen des Werkzeugverhaltens (z.B. Annotationen) sind als nicht vertrauenswürdig zu betrachten, es sei denn, sie stammen von einem vertrauenswürdigen Server.
    - Hosts müssen die explizite Zustimmung des Benutzers einholen, bevor ein Werkzeug aufgerufen wird.
    - Benutzer sollten verstehen, was jedes Werkzeug tut, bevor sie dessen Verwendung autorisieren.
- **LLM Sampling Controls:**
    - Benutzer müssen explizit allen LLM-Sampling-Anfragen zustimmen.
    - Benutzer sollten kontrollieren, ob Sampling überhaupt stattfindet, den tatsächlichen Prompt, der gesendet wird, und welche Ergebnisse der Server sehen kann.

Obwohl MCP diese Prinzipien nicht auf Protokollebene erzwingen kann, **SOLLTEN** Implementierer robuste Zustimmungs- und Autorisierungsflüsse entwickeln, Sicherheitsimplikationen klar dokumentieren, geeignete Zugriffskontrollen und Datenschutzmaßnahmen implementieren und bewährte Sicherheitspraktiken befolgen.2 Die Architektur mit MCP-Servern als Vermittler kann eine zusätzliche Sicherheitsebene bieten, indem der Zugriff auf Ressourcen kontrolliert und potenziell in einer Sandbox ausgeführt wird.19

## 3. MCP-Schnittstellen im NovaDE-Projekt – Allgemeine Spezifikation

### 3.1. Namenskonventionen und Versionierung

Für alle MCP-Schnittstellen, die im Rahmen des NovaDE-Projekts definiert werden, gelten folgende Namenskonventionen und Versionierungsrichtlinien:

- **Schnittstellennamen:** Schnittstellennamen folgen dem Muster `nova.<KomponentenName>.<Funktionsbereich>.<Version>`. Beispiel: `nova.workspace.fileAccess.v1`. Dies gewährleistet Eindeutigkeit und Klarheit über den Ursprung und Zweck der Schnittstelle.
- **Methodennamen:** Methodennamen verwenden camelCase, beginnend mit einem Kleinbuchstaben (z.B. `listResources`, `callTool`).
- **Parameternamen:** Parameternamen verwenden ebenfalls camelCase.
- **Versionierung:** Jede MCP-Schnittstelle wird explizit versioniert. Die Version wird als Teil des Schnittstellennamens geführt (z.B. `v1`, `v2`). Änderungen, die die Abwärtskompatibilität brechen, erfordern eine Erhöhung der Hauptversionsnummer. Abwärtskompatible Erweiterungen können zu einer Erhöhung einer Nebenversionsnummer führen, falls ein solches Schema zusätzlich eingeführt wird. Das NovaDE-Projekt hält sich an die im MCP-Standard definierte Protokollversion (z.B. `2025-03-26`).2 Die aktuell unterstützte MCP-Protokollversion ist im `mcp_client_rs` Crate als `LATEST_PROTOCOL_VERSION` und `SUPPORTED_PROTOCOL_VERSIONS` definiert.27

### 3.2. Standardnachrichtenflüsse

Die Kommunikation im NovaDE-Projekt über MCP folgt etablierten Nachrichtenflüssen, die auf dem JSON-RPC 2.0 Standard basieren.8

1. **Initialisierung (Connection Lifecycle):** 8
    - Der MCP-Client (innerhalb des NovaDE-Hosts) sendet eine `initialize`-Anfrage an den MCP-Server. Diese Anfrage enthält die vom Client unterstützte Protokollversion und dessen Fähigkeiten (Capabilities).
    - Der MCP-Server antwortet mit seiner Protokollversion und seinen Fähigkeiten.
    - Der Client bestätigt die erfolgreiche Initialisierung mit einer `initialized`-Notification.
    - Anschließend beginnt der reguläre Nachrichtenaustausch.
2. **Anfrage-Antwort (Request-Response):** 8
    - Der Client sendet eine Anfrage (z.B. `tools/list`, `resources/read`, `tools/call`) mit einer eindeutigen ID.
    - Der Server verarbeitet die Anfrage und sendet entweder eine Erfolgsantwort mit dem Ergebnis (`result`) und derselben ID oder eine Fehlerantwort (`error`) mit Fehlercode, Nachricht und derselben ID.
3. **Benachrichtigungen (Notifications):** 8
    - Client oder Server können einseitige Benachrichtigungen senden, die keine direkte Antwort erwarten. Diese haben keine ID. Ein Beispiel ist die `initialized`-Notification oder serverseitige Push-Events.
4. **Beendigung (Termination):** 8
    - Die Verbindung kann durch eine `shutdown`-Anfrage vom Client initiiert werden, gefolgt von einer `exit`-Notification. Alternativ kann die Verbindung durch Schließen des zugrundeliegenden Transportkanals beendet werden.

Die Rust-Bibliotheken `mcpr` und `mcp_client_rs` implementieren diese grundlegenden Nachrichtenflüsse.16 `mcp_client_rs` beispielsweise nutzt Tokio für asynchrone Operationen und stellt Methoden wie `initialize()`, `list_resources()`, `call_tool()` zur Verfügung, die diesen Flüssen folgen.18

### 3.3. Fehlerbehandlung und Fehlercodes

Eine robuste Fehlerbehandlung ist entscheidend für die Stabilität der MCP-Kommunikation im NovaDE-Projekt. MCP-Fehlerantworten folgen dem JSON-RPC 2.0 Standard 8 und enthalten ein `error`-Objekt mit den Feldern `code` (Integer), `message` (String) und optional `data` (beliebiger Typ).

**Standard-Fehlercodes (basierend auf JSON-RPC 2.0):**

- `-32700 Parse error`: Ungültiges JSON wurde empfangen.
- `-32600 Invalid Request`: Die JSON-Anfrage war nicht wohlgeformt.
- `-32601 Method not found`: Die angeforderte Methode existiert nicht oder ist nicht verfügbar.
- `-32602 Invalid params`: Ungültige Methodenparameter.
- `-32603 Internal error`: Interner JSON-RPC-Fehler.
- `-32000` bis `-32099 Server error`: Reserviert für implementierungsspezifische Serverfehler.

NovaDE-spezifische Fehlercodes:

Zusätzlich zu den Standard-JSON-RPC-Fehlercodes definiert das NovaDE-Projekt spezifische Fehlercodes im Bereich -32000 bis -32099 für anwendungsspezifische Fehler, die während der Verarbeitung von MCP-Anfragen auftreten können. Diese Fehlercodes werden pro Schnittstelle und Methode dokumentiert.

Fehlerbehandlung in Rust-Implementierungen:

In Rust-basierten MCP-Implementierungen für NovaDE wird die Verwendung von thiserror für Bibliotheksfehler und potenziell anyhow für Anwendungsfehler empfohlen, um eine klare und kontextreiche Fehlerbehandlung zu gewährleisten.29 Die mcp_client_rs Bibliothek stellt einen Error-Typ bereit, der verschiedene Fehlerquellen kapselt.27 Die Struktur ErrorResponse und das Enum ErrorCode [240 (angenommen)] sind Teil der Protokolldefinitionen zur strukturierten Fehlerkommunikation.

**Beispiel für eine Fehlerantwort:**

JSON

```
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32001,
    "message": "NovaDE Domain Error: Ressource nicht gefunden.",
    "data": {
      "resourceUri": "nova://domain/entity/123"
    }
  },
  "id": 123
}
```

### 3.4. Integration der Domänenschicht-Spezifikation

Die Domänenschicht-Spezifikation des NovaDE-Projekts ist ein zentrales Element, das die fachlichen Entitäten, Operationen und Geschäftsregeln definiert. Die MCP-Schnittstellen im NovaDE-Projekt müssen diese Domänenspezifikation nahtlos integrieren. Dies bedeutet:

- **Abbildung von Domänenentitäten:** Datenstrukturen innerhalb der MCP-Nachrichten (Parameter von Methoden, Rückgabewerte, Event-Payloads) müssen die Entitäten der Domänenschicht widerspiegeln oder direkt verwenden. Dies stellt sicher, dass die MCP-Kommunikation die fachlichen Anforderungen korrekt abbildet.
- **Domänenoperationen als MCP-Methoden:** Viele MCP-Methoden werden direkte Abbildungen von Operationen sein, die in der Domänenschicht definiert sind. Die Parameter und Rückgabewerte dieser MCP-Methoden korrespondieren mit den Ein- und Ausgaben der Domänenoperationen.
- **Validierung und Geschäftsregeln:** Bevor MCP-Anfragen an die Domänenschicht weitergeleitet oder Ergebnisse von der Domänenschicht über MCP zurückgegeben werden, müssen Validierungen und Geschäftsregeln der Domänenschicht angewendet werden. Dies kann sowohl im MCP-Server als auch in einer zwischengeschalteten Logikschicht geschehen.
- **Konsistente Terminologie:** Die in den MCP-Schnittstellen verwendete Terminologie (Namen von Methoden, Parametern, Datenfeldern) sollte mit der Terminologie der Domänenschicht-Spezifikation übereinstimmen, um Missverständnisse zu vermeiden und die Kohärenz im gesamten System zu fördern.

Die genauen Details der Integration hängen von den spezifischen Inhalten der Domänenschicht-Spezifikation ab. Jede detaillierte MCP-Schnittstellenspezifikation in Abschnitt 4 wird explizit auf die relevanten Teile der Domänenschicht-Spezifikation verweisen und die Abbildung erläutern.

## 4. Detaillierte MCP-Schnittstellenspezifikationen

Für das NovaDE-Projekt werden spezifische MCP-Schnittstellen definiert, um die Interaktion mit verschiedenen Modulen und Diensten zu ermöglichen. Jede Schnittstelle wird nach dem folgenden Schema spezifiziert. _Da die konkreten Schnittstellen für NovaDE nicht in den bereitgestellten Materialien definiert sind, dient der folgende Abschnitt als Vorlage und Beispielstruktur._

---

**Beispiel-Schnittstelle: `nova.dataAccess.document.v1`**

### 4.1. Beschreibung und Zweck

Die Schnittstelle `nova.dataAccess.document.v1` dient dem Zugriff auf und der Verwaltung von Dokumenten innerhalb des NovaDE-Projekts. Sie ermöglicht es MCP-Clients, Dokumente basierend auf Kriterien der Domänenschicht zu lesen, zu schreiben, zu aktualisieren und zu löschen. Diese Schnittstelle interagiert eng mit den Entitäten und Operationen, die in der "Domänenschicht-Spezifikation, Abschnitt X.Y (Dokumentenverwaltung)" definiert sind.

### 4.2. Methoden

#### 4.2.1. `readDocument`

- **Beschreibung:** Liest den Inhalt und die Metadaten eines spezifischen Dokuments.
- **Parameter:**
    - `uri` (String, erforderlich): Der eindeutige URI des Dokuments, konform zum NovaDE-URI-Schema (z.B. `nova://documents/internal/doc123`).
    - `options` (Object, optional): Zusätzliche Optionen für den Lesevorgang.
        - `version` (String, optional): Die spezifische Version des Dokuments, die gelesen werden soll. Falls nicht angegeben, wird die neueste Version gelesen.
- **Rückgabewerte:**
    - `document` (Object): Ein Objekt, das das gelesene Dokument repräsentiert. Die Struktur dieses Objekts ist in der Domänenschicht-Spezifikation definiert und könnte Felder wie `uri`, `mimeType`, `content` (String oder Binary), `metadata` (Object), `version` (String), `lastModified` (Timestamp) enthalten.
- **Mögliche Fehler:**
    - `-32001`: `DOCUMENT_NOT_FOUND` - Das angeforderte Dokument existiert nicht.
    - `-32002`: `ACCESS_DENIED` - Der Client hat keine Berechtigung, das Dokument zu lesen.
    - `-32003`: `VERSION_NOT_FOUND` - Die angeforderte Version des Dokuments existiert nicht.

#### 4.2.2. `writeDocument`

- **Beschreibung:** Schreibt ein neues Dokument oder aktualisiert ein bestehendes Dokument.
- **Parameter:**
    - `uri` (String, erforderlich): Der URI, unter dem das Dokument geschrieben werden soll. Bei Aktualisierung eines bestehenden Dokuments dessen URI.
    - `content` (String oder Binary, erforderlich): Der Inhalt des Dokuments. Der Typ (String oder Base64-kodiertes Binary) hängt vom `mimeType` ab.
    - `mimeType` (String, erforderlich): Der MIME-Typ des Dokuments (z.B. `text/plain`, `application/pdf`).
    - `metadata` (Object, optional): Domänenspezifische Metadaten für das Dokument.
    - `options` (Object, optional):
        - `overwrite` (Boolean, optional, default: `false`): Wenn `true` und ein Dokument unter dem URI existiert, wird es überschrieben. Andernfalls schlägt der Aufruf fehl, wenn das Dokument existiert.
- **Rückgabewerte:**
    - `newUri` (String): Der URI des geschriebenen oder aktualisierten Dokuments (kann sich bei Neuerstellung ändern, falls der Server URIs generiert).
    - `version` (String): Die Versionskennung des geschriebenen Dokuments.
- **Mögliche Fehler:**
    - `-32002`: `ACCESS_DENIED` - Keine Schreibberechtigung.
    - `-32004`: `DOCUMENT_EXISTS` - Dokument existiert bereits und `overwrite` ist `false`.
    - `-32005`: `INVALID_CONTENT` - Der bereitgestellte Inhalt ist für den `mimeType` ungültig.

_(Weitere Methoden wie `deleteDocument`, `listDocuments` würden hier analog spezifiziert werden.)_

### 4.3. Events/Notifications

#### 4.3.1. `documentChanged`

- **Beschreibung:** Wird vom Server gesendet, wenn ein Dokument, für das der Client möglicherweise Interesse bekundet hat (z.B. durch vorheriges Lesen), geändert wurde.
- **Parameter:**
    - `uri` (String): Der URI des geänderten Dokuments.
    - `changeType` (String): Art der Änderung (z.B. `UPDATED`, `DELETED`).
    - `newVersion` (String, optional): Die neue Versionskennung, falls `changeType` `UPDATED` ist.

### 4.4. Datenstrukturen

Die für diese Schnittstelle relevanten Datenstrukturen (z.B. die Struktur eines `Document`-Objekts, `Metadata`-Objekts) werden primär durch die Domänenschicht-Spezifikation des NovaDE-Projekts definiert. MCP-Nachrichten verwenden JSON-Repräsentationen dieser domänenspezifischen Strukturen.

**Beispiel `Document` (basierend auf einer hypothetischen Domänenspezifikation):**

JSON

```
{
  "uri": "nova://documents/internal/doc123",
  "mimeType": "text/plain",
  "content": "Dies ist der Inhalt des Dokuments.",
  "metadata": {
    "author": "NovaUser",
    "tags": ["wichtig", "projektA"],
    "customDomainField": "spezifischerWert"
  },
  "version": "v1.2.3",
  "lastModified": "2024-07-15T10:30:00Z"
}
```

### 4.5. Beispiele für Nachrichten

**Anfrage `readDocument`:**

JSON

```
{
  "jsonrpc": "2.0",
  "method": "nova.dataAccess.document.v1/readDocument",
  "params": {
    "uri": "nova://documents/internal/doc123"
  },
  "id": 1
}
```

**Antwort `readDocument` (Erfolg):**

JSON

```
{
  "jsonrpc": "2.0",
  "result": {
    "document": {
      "uri": "nova://documents/internal/doc123",
      "mimeType": "text/plain",
      "content": "Dies ist der Inhalt des Dokuments.",
      "metadata": {"author": "NovaUser"},
      "version": "v1.0.0",
      "lastModified": "2024-07-15T10:00:00Z"
    }
  },
  "id": 1
}
```

### 4.6. Interaktion mit der Domänenschicht

Die Methode `readDocument` ruft intern die Funktion `DomainLayer.getDocumentByUri(uri, options.version)` der Domänenschicht auf. Die zurückgegebenen Domänenobjekte werden gemäß den MCP-Datenstrukturen serialisiert. Die Methode `writeDocument` validiert die Eingaben anhand der Geschäftsregeln der Domänenschicht (z.B. `DomainLayer.validateDocumentContent(content, mimeType)`) und ruft dann `DomainLayer.saveDocument(documentData)` auf. Berechtigungsprüfungen erfolgen ebenfalls über dedizierte Domänenschicht-Services (z.B. `DomainLayer.Security.canReadDocument(userContext, uri)`).

---

_(Dieser beispielhafte Abschnitt würde für jede spezifische MCP-Schnittstelle im NovaDE-Projekt wiederholt werden.)_

## 5. Implementierung der MCP-Schnittstellen im NovaDE-Projekt

### 5.1. Verwendete Technologien

Die Kernimplementierung der MCP-Schnittstellen und der zugehörigen Logik im NovaDE-Projekt erfolgt in **Rust**. Dies schließt sowohl Client- als auch (potenzielle) Server-seitige Komponenten ein. Die Wahl von Rust begründet sich in dessen Stärken hinsichtlich Systemsicherheit, Performance und Nebenläufigkeit, welche für ein robustes Desktop Environment Projekt wie NovaDE essentiell sind.

Folgende Rust-Bibliotheken (Crates) sind für die MCP-Implementierung von zentraler Bedeutung:

- **MCP-Protokoll-Handling:**
    - `mcp_client_rs` (von darinkishore) [17 (angenommen), 241 (angenommen), 28 (angenommen), 243 (angenommen), 244 (angenommen), 243 (angenommen), 242 (angenommen), 245 (angenommen), 246 (angenommen), 246 (angenommen)] oder alternativ `mcpr` (von conikeec) 16 für die Client-seitige Implementierung. Die Entscheidung für eine spezifische Bibliothek hängt von den detaillierten Anforderungen und der Reife der jeweiligen Bibliothek zum Zeitpunkt der Implementierung ab. Beide bieten Mechanismen zur Serialisierung/Deserialisierung von MCP-Nachrichten und zur Verwaltung der Kommunikation.
- **Asynchrone Laufzeitumgebung:** `tokio` wird als primäre asynchrone Laufzeitumgebung für die nebenläufige Verarbeitung von MCP-Nachrichten und Interaktionen mit anderen Systemdiensten verwendet.25
- **Serialisierung/Deserialisierung:** `serde` und `serde_json` für die Umwandlung von Rust-Datenstrukturen in und aus dem JSON-Format, das von JSON-RPC verwendet wird.25
- **Fehlerbehandlung:** `thiserror` für die Definition von benutzerdefinierten Fehlertypen in Bibliotheks-Code und potenziell `anyhow` für eine vereinfachte Fehlerbehandlung in Anwendungscode.29
- **UUID-Generierung:** Das `uuid` Crate mit den Features `v4` und `serde` wird für die Erzeugung und Handhabung von eindeutigen Identifikatoren verwendet, die in MCP-Nachrichten oder domänenspezifischen Daten benötigt werden könnten.41
- **D-Bus-Kommunikation:** `zbus` für die Interaktion mit Systemdiensten über D-Bus.12
- **Wayland Compositing (falls NovaDE ein Compositor ist oder tief integriert):** `smithay` als Framework für Wayland-spezifische Interaktionen.10
- **PipeWire-Integration:** `pipewire-rs` für die Interaktion mit dem PipeWire Multimedia-Framework.14

### 5.2. MCP-Client-Implementierung (Rust)

Die MCP-Client-Komponenten im NovaDE-Projekt sind für die Kommunikation mit verschiedenen MCP-Servern zuständig, die Werkzeuge und Ressourcen bereitstellen.

#### 5.2.1. Initialisierung und Verbindungsaufbau

Die Initialisierung eines MCP-Clients beginnt mit der Konfiguration des Transports und der Erstellung einer Client-Instanz. Am Beispiel von `mcp_client_rs` (darinkishore):

- **Server-Spawning (für lokale Server via Stdio):** Die `ClientBuilder`-API ermöglicht das Starten eines lokalen MCP-Serverprozesses und die Verbindung zu dessen Stdio-Kanälen.17
    
    Rust
    
    ```
    // Beispielhafte Initialisierung (Pseudocode, da Servername und Argumente spezifisch für NovaDE sind)
    // use mcp_client_rs::client::ClientBuilder;
    // let client = ClientBuilder::new("nova-mcp-server-executable")
    //    .arg("--config-path")
    //    .arg("/etc/nova/mcp_server_config.json")
    //    .spawn_and_initialize().await?;
    ```
    
    Es ist wichtig zu beachten, dass `mcp_client_rs` (darinkishore) primär für lokal gespawnte Server konzipiert ist und keine direkte Unterstützung für Remote-Server plant.17 Für Remote-Verbindungen via HTTP/SSE müsste eine andere Bibliothek oder eine Erweiterung dieses Ansatzes in Betracht gezogen werden, wie sie z.B. in `mcpr` (conikeec) angedeutet ist.16
    
- **Verwendung eines existierenden Transports:** Alternativ kann ein Client mit einem bereits existierenden Transportobjekt initialisiert werden.14
    
    Rust
    
    ```
    // use std::sync::Arc;
    // use mcp_client_rs::client::Client;
    // use mcp_client_rs::transport::stdio::StdioTransport;
    // use tokio::io::{stdin, stdout};
    //
    // let transport = StdioTransport::with_streams(stdin(), stdout());
    // let client = Client::new(Arc::new(transport));
    ```
    
- **`initialize`-Nachricht:** Nach dem Aufbau der Transportverbindung sendet der Client eine `initialize`-Anfrage an den Server, um Protokollversionen und Fähigkeiten auszutauschen.8 Die `spawn_and_initialize()`-Methode von `mcp_client_rs` (darinkishore) handhabt dies implizit.17 Die `initialize()`-Methode auf der Client-Instanz von `mcpr` (conikeec) führt dies explizit durch.16
    

Die `InitializeParams` [240 (angenommen)] würden typischerweise die `protocolVersion` (z.B. "2025-03-26"), `clientName`, `clientVersion` und `supportedFeatures` enthalten. Die `InitializeResult` [240 (angenommen)] vom Server bestätigt die `protocolVersion` und listet die `serverCapabilities` und `serverInfo` auf.

#### 5.2.2. Senden von Requests

MCP-Clients im NovaDE-Projekt senden Anfragen an Server, um Ressourcen aufzulisten, Werkzeuge aufzurufen oder andere definierte Operationen auszuführen.

- **`ListResources`:**
    - Parameter: `ListResourcesParams` [240 (angenommen)] können Filterkriterien oder Paginierungsinformationen enthalten.
    - Antwort: `ListResourcesResult` [240 (angenommen)] enthält eine Liste von `Resource`-Objekten [240 (angenommen)], die jeweils URI, Name, Beschreibung und unterstützte Operationen definieren.
    - Beispielaufruf mit `mcp_client_rs`: `let resources = client.list_resources().await?;` 18
- **`CallTool`:**
    - Parameter: `CallToolParams` [240 (angenommen)] enthalten den `toolName` (String) und `arguments` (JSON-Objekt).
    - Antwort: `CallToolResult` [240 (angenommen)] enthält das Ergebnis der Werkzeugausführung, typischerweise als JSON-Objekt.
    - Beispielaufruf mit `mcp_client_rs`: `let tool_result = client.call_tool("domain.action.calculateSum", serde_json::json!({"op1": 10, "op2": 20})).await?;` 18
    - Die Definition von Werkzeugen (`ToolDefinition` [240 (angenommen)]) umfasst Name, Beschreibung und ein JSON-Schema für die Parameter.
- **`ReadResource`:** (und andere domänenspezifische Requests)
    - Parameter: Typischerweise ein URI und optionale Parameter.
    - Antwort: Der Inhalt oder Zustand der Ressource.
    - Beispielaufruf mit `mcp_client_rs`: `let read_result = client.read_resource("nova://domain/entity/123").await?;` 18

Alle diese Anfragen werden asynchron über den konfigurierten Transportmechanismus gesendet. Die `mcp_client_rs` Bibliothek nutzt Tokio für diese asynchronen Operationen.25

#### 5.2.3. Empfangen von Responses und Notifications

Der Empfang von Nachrichten ist ein kritischer Aspekt der MCP-Client-Implementierung.

- **Responses:** Antworten auf Client-Anfragen werden typischerweise über `async/await` Konstrukte direkt als Rückgabewerte der aufrufenden Methoden empfangen (z.B. `ListResourcesResult` von `list_resources().await?`).18 Die zugrundeliegende Transportlogik (z.B. in `StdioTransport` [242 (angenommen), 244 (angenommen), 242 (angenommen)]) liest die Rohdaten, parst sie als `McpMessage` [240 (angenommen)] und leitet sie an den entsprechenden wartenden Task weiter.
- **Notifications (Server Push Events):** Asynchrone Benachrichtigungen vom Server (z.B. `documentChanged` aus dem Beispiel in Abschnitt 4.3.1) erfordern einen dedizierten Mechanismus zum Empfang und zur Verarbeitung.
    - Die `mcpr` Bibliothek (conikeec) deutet auf Unterstützung für Server-Sent Events (SSE) hin, was einen Stream von Ereignissen impliziert, den der Client verarbeiten müsste.16
    - Die `mcp_client_rs` Bibliothek (darinkishore) ist primär auf Stdio ausgerichtet. Die Handhabung von Server-Push-Benachrichtigungen über Stdio würde erfordern, dass der `StdioTransport` kontinuierlich die Standardeingabe liest und eingehende Nachrichten (die keine direkten Antworten auf Anfragen sind) als `Notification` [240 (angenommen)] identifiziert und an einen Handler oder einen Ereignis-Stream weiterleitet. Die genaue Implementierung (z.B. ein dedizierter Empfangs-Loop oder ein Stream von `McpMessage`) ist in den bereitgestellten Snippets nicht vollständig ersichtlich [17 (fehlend), 246 (fehlend), 241 (fehlend), 243 (fehlend), 243 (fehlend), 245 (fehlend), 246 (fehlend), 246 (fehlend)]. Es ist davon auszugehen, dass eine `async_stream`-basierte Lösung oder ein `tokio::sync::broadcast` Kanal 36 verwendet wird, um diese Nachrichten an interessierte Teile der Anwendung zu verteilen.
    - Die `mcp_client_rs` Version 0.1.1 erwähnt "WebSocket Transport (Coming Soon)" mit "built-in reconnection handling", was auf zukünftige robustere Mechanismen für Server-Push und Verbindungsstatus hindeutet.25
- **Connection Status Events:** Die Überwachung des Verbindungsstatus (z.B. Verbindungsabbruch, Wiederverbindung) ist für robuste Anwendungen wichtig. Explizite Mechanismen hierfür sind in den Snippets zu `mcp_client_rs` (darinkishore) nicht detailliert, könnten aber Teil des `WebSocketTransport` sein 25 oder müssten auf der Transportebene (z.B. durch Überwachung der Stdio-Pipes) implementiert werden. Für SSE-Transporte könnten HTTP-Fehlercodes oder das Schließen des Event-Streams als Indikatoren dienen.26

#### 5.2.4. Fehlerbehandlung

Fehler können auf verschiedenen Ebenen auftreten: Transportfehler, JSON-RPC-Parsingfehler, oder anwendungsspezifische Fehler, die vom Server als `ErrorResponse` [240 (angenommen)] gesendet werden.

- Die `mcp_client_rs` Bibliothek verwendet `thiserror` zur Definition ihres `Error`-Typs, der verschiedene Fehlerquellen aggregiert.27
- Client-Code sollte `Result`-Typen sorgfältig behandeln, um auf Fehler angemessen reagieren zu können (z.B. Wiederholungsversuche, Benutzerbenachrichtigung, Logging).
- Spezifische `ErrorCode`-Werte [240 (angenommen)] in `ErrorResponse`-Nachrichten ermöglichen eine differenzierte Fehlerbehandlung basierend auf der Art des serverseitigen Fehlers.

#### 5.2.5. Transport Layer

- **StdioTransport:** Für die Kommunikation mit lokalen Serverprozessen. Implementierungen in `mcpr` 16 und `mcp_client_rs` [25 (angenommen), 244 (angenommen), 242 (angenommen)] lesen von `stdin` und schreiben nach `stdout` des Subprozesses. Die `StdioTransport` in `mcp_client_rs` verwendet typischerweise `tokio::io::AsyncRead` und `tokio::io::AsyncWrite` für die asynchrone Verarbeitung. Eingehende Nachrichten werden zeilenbasiert oder durch Längenpräfixe (gemäß JSON-RPC Framing) gelesen und dann als `McpMessage` deserialisiert.
- **SSETransport (Server-Sent Events):** Für webbasierte oder Remote-Server. `mcpr` erwähnt dessen Unterstützung.16 Dies involviert einen HTTP-Client, der eine Verbindung zu einem SSE-Endpunkt des Servers herstellt und einen kontinuierlichen Stream von Ereignissen empfängt.26

### 5.3. MCP-Server-Implementierung (Rust)

Obwohl der primäre Fokus des NovaDE-Projekts auf der Client-Seite liegen mag, könnten bestimmte Komponenten des Projekts auch als MCP-Server fungieren, um Fähigkeiten für andere Teile des Systems oder externe LLMs bereitzustellen.

- **Struktur:** Ein MCP-Server in Rust, beispielsweise unter Verwendung der `mcpr`-Bibliothek 16, würde eine `ServerConfig` definieren, die Name, Version und eine Liste der bereitgestellten `Tool`-Definitionen enthält. Jedes `Tool` spezifiziert seinen Namen, eine Beschreibung und ein JSON-Schema für seine Parameter.
- **Tool-Registrierung:** Für jedes definierte Werkzeug wird ein Handler registriert, der die Werkzeugparameter entgegennimmt, die Logik ausführt und ein Ergebnis (oder einen Fehler) zurückgibt.
    
    Rust
    
    ```
    // Beispielhafte Server-Konfiguration mit mcpr (conikeec)
    // use mcpr::{server::{Server, ServerConfig}, transport::stdio::StdioTransport, Tool, error::MCPError};
    // use serde_json::Value;
    //
    // let server_config = ServerConfig::new()
    //    .with_name("NovaDE.DomainService.v1")
    //    .with_version("1.0.0")
    //    .with_tool(Tool {
    //         name: "nova.domain.getEntityDetails".to_string(),
    //         description: Some("Ruft Details zu einer Domänenentität ab.".to_string()),
    //         parameters_schema: serde_json::json!({
    //             "type": "object",
    //             "properties": {
    //                 "entityUri": {"type": "string", "description": "URI der Entität"}
    //             },
    //             "required": ["entityUri"]
    //         }),
    //     });
    // let mut server: Server<StdioTransport> = Server::new(server_config);
    // server.register_tool_handler("nova.domain.getEntityDetails", |params: Value| {
    //     // Implementierung der Domänenlogik hier
    //     //...
    //     Ok(serde_json::json!({"status": "success", "data": { /*... */ }}))
    // })?;
    // let transport = StdioTransport::new();
    // server.start(transport)?;
    ```
    

Die Serverimplementierung ist verantwortlich für das Parsen eingehender Anfragen, das Weiterleiten an die entsprechenden Handler und das Senden von Antworten oder Benachrichtigungen über den gewählten Transportmechanismus.

### 5.4. Interaktion mit Systemdiensten und Protokollen

Die MCP-Schnittstellen im NovaDE-Projekt sind nicht isoliert, sondern interagieren intensiv mit bestehenden Systemdiensten und Protokollen. Diese Interaktionen sind entscheidend für den Zugriff auf Systemressourcen, die Verwaltung von Berechtigungen und die Integration in die Desktop-Umgebung. Die folgenden Abschnitte detaillieren diese Interaktionen.

## 6. Interaktion mit D-Bus-Diensten

Die Kommunikation mit systemweiten und benutzerspezifischen Diensten im NovaDE-Projekt erfolgt primär über D-Bus. Die Rust-Bibliothek `zbus` wird für diese Interaktionen verwendet.12

### 6.1. Allgemeine D-Bus-Integration mit `zbus`

`zbus` ermöglicht eine typsichere und asynchrone Kommunikation mit D-Bus-Diensten.

- **Proxy-Generierung:** Für die Interaktion mit D-Bus-Schnittstellen werden Proxys verwendet. Das `#[dbus_proxy]` (oder `#[proxy]`) Makro von `zbus` generiert Rust-Traits und Proxy-Strukturen aus D-Bus-Interface-Definitionen [12 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich)].
    
    Rust
    
    ```
    // use zbus::{dbus_proxy, Connection, Result};
    // #
    // trait ExampleProxy {
    //     async fn some_method(&self, param: &str) -> Result<String>;
    //     #[dbus_proxy(signal)]
    //     async fn some_signal(&self, value: u32) -> Result<()>;
    // }
    ```
    
- **Verbindungsaufbau:** Eine Verbindung zum Session- oder Systembus wird mit `zbus::Connection::session().await?` bzw. `zbus::Connection::system().await?` hergestellt.45
- **Methodenaufrufe:** Methoden auf D-Bus-Schnittstellen werden asynchron über die generierten Proxy-Methoden aufgerufen.45
- **Signalempfang:** Signale werden als asynchrone Streams (`futures_util::stream::StreamExt`) über die Proxy-Methoden `receive_<signal_name>()` empfangen.46 Die Argumente des Signals können aus der `zbus::Message` deserialisiert werden [46 (nicht zugänglich), 65 (nicht zugänglich)].
- **Fehlerbehandlung:** `zbus`-Operationen geben `zbus::Result` zurück. Fehler werden durch das `zbus::Error`-Enum repräsentiert, das verschiedene Fehlerquellen wie I/O-Fehler, ungültige Nachrichten oder Fehler vom D-Bus-Dienst selbst abdeckt.52
- **Server-Implementierung:** `zbus` ermöglicht auch die Implementierung von D-Bus-Diensten. Mittels `ConnectionBuilder::serve_at` können Interfaces auf bestimmten Objektpfaden bereitgestellt werden [13 (nicht zugänglich), 57 (nicht zugänglich), 12 (nicht zugänglich), 56 (nicht zugänglich), 57 (nicht zugänglich), 12 (nicht zugänglich), 60]. Das `ObjectServer`-API kann für komplexere Szenarien mit mehreren Objekten und Interfaces auf derselben Verbindung genutzt werden [48 (nicht zugänglich), 57 (nicht zugänglich), 12 (nicht zugänglich), 56 (nicht zugänglich), 57 (nicht zugänglich), 58 (nicht zugänglich), 60].

### 6.2. `org.freedesktop.secrets` – Sichere Speicherung von Geheimnissen

Das NovaDE-Projekt nutzt die `org.freedesktop.Secrets`-Schnittstelle für die sichere Speicherung und Verwaltung von sensiblen Daten wie Passwörtern oder API-Tokens, die von MCP-Komponenten benötigt werden.70

- **Schnittstellenspezifikation:** 70
    - **`org.freedesktop.Secrets.Service`:** Verwalter von Collections und Sessions.
        - Methoden: `OpenSession`, `CreateCollection`, `SearchCollections`, `RetrieveSecrets`, `LockService`, `DeleteCollection`.
        - Signale: `CollectionCreated`, `CollectionDeleted`.
        - Properties: `Collections` (RO), `DefaultCollection` (RW).
    - **`org.freedesktop.Secrets.Collection`:** Eine Sammlung von Items (Geheimnissen).
        - Methoden: `Delete`, `SearchItems`, `CreateItem`.
        - Signale: `CreatedItem`, `DeletedItem`.
        - Properties: `Items` (RO), `Private` (RO), `Label` (RW), `Locked` (RO), `Created` (RO), `Modified` (RO).
    - **`org.freedesktop.Secrets.Item`:** Ein einzelnes Geheimnis mit Attributen.
        - Methoden: `Delete`.
        - Signale: `changed`.
        - Properties: `Locked` (RO), `Attributes` (RW), `Label` (RW), `Secret` (RW), `Created` (RO), `Modified` (RO).
    - **`org.freedesktop.Secrets.Session`:** Repräsentiert eine Sitzung zwischen Client und Dienst.
        - Methoden: `Close`, `Negotiate`, `BeginAuthenticate`, `CompleteAuthenticate`.
        - Signale: `Authenticated`.
- **Datentyp `Secret`:** 70
    - `algorithm` (String): Algorithmus zur Kodierung des Geheimnisses (z.B. "PLAIN").
    - `parameters` (Array<Byte>): Algorithmus-spezifische Parameter.
    - `value` (Array<Byte>): Der möglicherweise kodierte Geheimniswert.
- **Fehlerdomäne:** `org.freedesktop.Secrets.Error.*` (z.B. `AlreadyExists`, `IsLocked`, `NotSupported`).70
- **Nutzung im NovaDE-Projekt für MCP:**
    - MCP-Server oder -Clients im NovaDE-Projekt, die Zugriff auf persistente, sichere Anmeldeinformationen oder Tokens benötigen, interagieren mit diesem Dienst.
    - Beispiel: Ein MCP-Server, der eine Verbindung zu einem externen API herstellt, könnte das API-Token sicher über `org.freedesktop.Secrets` speichern und abrufen.
    - Die `CreateCollection`-Methode wird verwendet, um spezifische Sammlungen für NovaDE-Komponenten anzulegen, potenziell mit `private = true`, um den Zugriff einzuschränken.
    - `SearchItems` mit spezifischen `Attributes` wird verwendet, um gezielt nach Geheimnissen zu suchen.
    - Die `Negotiate`-Methode kann für eine verschlüsselte Übertragung der Geheimnisse genutzt werden, falls erforderlich.

### 6.3. `org.freedesktop.PolicyKit1.Authority` – Berechtigungsprüfung

PolicyKit wird im NovaDE-Projekt eingesetzt, um granulare Berechtigungsprüfungen für Aktionen durchzuführen, die von MCP-Schnittstellen oder den dahinterliegenden Diensten ausgelöst werden.71

- **Schnittstellenspezifikation:** `org.freedesktop.PolicyKit1.Authority` am Pfad `/org/freedesktop/PolicyKit1/Authority`.71
    - **Methoden:**
        - `CheckAuthorization(IN Subject subject, IN String action_id, IN Dict<String,String> details, IN CheckAuthorizationFlags flags, IN String cancellation_id, OUT AuthorizationResult result)`: Prüft, ob ein Subjekt berechtigt ist, eine Aktion auszuführen. `details` können verwendet werden, um kontextspezifische Informationen für die Autorisierungsentscheidung oder die dem Benutzer angezeigte Nachricht bereitzustellen. `AllowUserInteraction` im `flags`-Parameter ermöglicht eine interaktive Authentifizierung.
        - `CancelCheckAuthorization(IN String cancellation_id)`: Bricht eine laufende Autorisierungsprüfung ab.
        - `EnumerateActions(IN String locale, OUT Array<ActionDescription> action_descriptions)`: Listet alle registrierten Aktionen auf.
        - `RegisterAuthenticationAgent(IN Subject subject, IN String locale, IN String object_path)`: Registriert einen Authentifizierungsagenten.
    - **Signale:**
        - `Changed()`: Wird emittiert, wenn sich Aktionen oder Autorisierungen ändern.
- **Wichtige Datenstrukturen:** 71
    - `Subject`: Beschreibt das handelnde Subjekt (z.B. `unix-process`, `unix-session`).
    - `ActionDescription`: Beschreibt eine registrierte Aktion (ID, Beschreibung, Nachricht, Standardberechtigungen).
    - `AuthorizationResult`: Ergebnis der Prüfung (`is_authorized`, `is_challenge`, `details`).
- **Nutzung im NovaDE-Projekt für MCP-Zugriffssteuerung:**
    - Bevor eine MCP-Methode eine potenziell privilegierte Operation ausführt (z.B. Systemkonfiguration ändern, auf geschützte Benutzerdaten zugreifen), muss der MCP-Server oder die aufgerufene NovaDE-Komponente `CheckAuthorization` aufrufen.
    - Die `action_id` entspricht einer vordefinierten Aktion im NovaDE-PolicyKit-Regelwerk (z.B. `org.novade.mcp.filesystem.writeFile`).
    - Die `details` können MCP-spezifische Parameter enthalten, die für die Entscheidung oder die Benutzerinteraktion relevant sind.
    - Das Ergebnis von `CheckAuthorization` bestimmt, ob die MCP-Operation fortgesetzt oder mit einem Berechtigungsfehler abgelehnt wird.

### 6.4. XDG Desktop Portals

XDG Desktop Portals bieten sandboxed Anwendungen (und auch nicht-sandboxed Anwendungen) einen standardisierten Weg, um mit der Desktop-Umgebung zu interagieren, z.B. für Dateiauswahl oder Screenshots.6 MCP-Schnittstellen im NovaDE-Projekt können diese Portale nutzen, um solche Interaktionen sicher und konsistent zu gestalten.

#### 6.4.1. `org.freedesktop.portal.FileChooser`

Wird verwendet, um dem Benutzer Dialoge zur Datei- oder Ordnerauswahl anzuzeigen.6

- **Methoden:** 73
    - `OpenFile(IN String parent_window, IN String title, IN Dict<String,Variant> options, OUT ObjectPath handle)`: Öffnet einen Dialog zur Auswahl einer oder mehrerer Dateien.
        - Optionen (`a{sv}`): `handle_token` (s), `accept_label` (s), `modal` (b), `multiple` (b), `directory` (b), `filters` (`a(sa(us))`), `current_filter` (`(sa(us))`), `choices` (`a(ssa(ss)s)`), `current_folder` (ay).
        - Antwort über `org.freedesktop.portal.Request::Response`: `uris` (as), `choices` (`a(ss)`), `current_filter` (`(sa(us))`).
    - `SaveFile(IN String parent_window, IN String title, IN Dict<String,Variant> options, OUT ObjectPath handle)`: Öffnet einen Dialog zum Speichern einer Datei.
        - Optionen (`a{sv}`): Ähnlich wie `OpenFile`, zusätzlich `current_name` (s), `current_file` (ay).
        - Antwort über `org.freedesktop.portal.Request::Response`: `uris` (as), `choices` (`a(ss)`), `current_filter` (`(sa(us))`).
    - `SaveFiles(IN String parent_window, IN String title, IN Dict<String,Variant> options, OUT ObjectPath handle)`: Öffnet einen Dialog zum Speichern mehrerer Dateien in einem Ordner.
        - Optionen (`a{sv}`): Ähnlich wie `SaveFile`, zusätzlich `files` (aay).
        - Antwort über `org.freedesktop.portal.Request::Response`: `uris` (as), `choices` (`a(ss)`).
- **Nutzung im NovaDE-Projekt:** MCP-Methoden, die Dateiinteraktionen erfordern (z.B. das Hochladen eines Dokuments durch den Benutzer, das Speichern von generierten Inhalten), rufen diese Portalmethoden auf. Die `parent_window`-Kennung muss korrekt übergeben werden. Die `options` werden basierend auf dem Kontext der MCP-Aktion befüllt (z.B. Dateifilter basierend auf erwarteten MIME-Typen der Domänenschicht).

#### 6.4.2. `org.freedesktop.portal.Screenshot`

Ermöglicht das Erstellen von Screenshots und das Auswählen von Pixelfarben.3

- **Methoden (Version 2):** 79
    - `Screenshot(IN String parent_window, IN Dict<String,Variant> options, OUT ObjectPath handle)`: Erstellt einen Screenshot.
        - Optionen (`a{sv}`): `handle_token` (s), `modal` (b, default: true), `interactive` (b, default: false, seit v2).
        - Antwort über `org.freedesktop.portal.Request::Response`: `uri` (s) des Screenshots.
    - `PickColor(IN String parent_window, IN Dict<String,Variant> options, OUT ObjectPath handle)`: Wählt die Farbe eines Pixels aus.
        - Optionen (`a{sv}`): `handle_token` (s).
        - Antwort über `org.freedesktop.portal.Request::Response`: `color` (`(ddd)`) als RGB-Werte .
- **Nutzung im NovaDE-Projekt:** MCP-Schnittstellen, die visuelle Informationen vom Desktop benötigen (z.B. ein Werkzeug zur Fehlerberichterstattung, das einen Screenshot anhängt, oder ein Design-Tool, das Farben vom Bildschirm aufnimmt), verwenden diese Portalmethoden.
- **Backend-Implementierung:** Für Wayland-basierte Desktops wie potenziell NovaDE ist eine Backend-Implementierung wie `xdg-desktop-portal-wlr` 6, `xdg-desktop-portal-gnome` 6, `xdg-desktop-portal-kde` 6 oder eine spezifische Implementierung wie `xdg-desktop-portal-luminous` (Rust-basiert, nutzt `libwayshot` und `zwlr_screencopy`) 83 erforderlich. `xdg-desktop-portal-luminous` ist ein Beispiel für eine Rust-basierte Implementierung, die `zbus` für D-Bus verwenden könnte und über das `zwlr_screencopy`-Protokoll mit wlroots-basierten Compositors interagiert.88

### 6.5. `org.freedesktop.login1` – Sitzungs- und Benutzerverwaltung

Der `systemd-logind`-Dienst stellt über D-Bus Informationen und Kontrollfunktionen für Benutzersitzungen, Benutzer und Seats bereit [90 (nicht zugänglich), 253 (nicht zugänglich), 254 (nicht zugänglich)]. MCP-Komponenten im NovaDE-Projekt können diese Schnittstelle nutzen, um kontextbezogene Informationen über den aktuellen Benutzer oder die Sitzung zu erhalten oder um sitzungsbezogene Aktionen auszulösen.

- **Manager-Interface (`org.freedesktop.login1.Manager` auf `/org/freedesktop/login1`):** 90
    - **Methoden:**
        - `GetSession(IN String session_id, OUT ObjectPath object_path)`
        - `GetUser(IN UInt32 uid, OUT ObjectPath object_path)`
        - `ListSessions(OUT Array<(String session_id, UInt32 user_id, String user_name, String seat_id, ObjectPath session_path)> sessions)`
        - `LockSession(IN String session_id)`
        - `UnlockSession(IN String session_id)`
    - **Signale:**
        - `SessionNew(String session_id, ObjectPath object_path)` 91
        - `SessionRemoved(String session_id, ObjectPath object_path)` 91
        - `PrepareForSleep(Boolean start)` 90
- **Session-Interface (`org.freedesktop.login1.Session` auf dem jeweiligen Session-Pfad):**
    - **Signale:**
        - `Lock()` [90 (nicht zugänglich)]
        - `Unlock()` [90 (nicht zugänglich)]
- **Nutzung im NovaDE-Projekt für MCP-Kontext:**
    - Abfrage der aktuellen Sitzungs-ID oder Benutzer-ID, um MCP-Aktionen zu personalisieren oder Berechtigungen feingranularer zu steuern.
    - Reaktion auf `PrepareForSleep`-Signale, um z.B. laufende MCP-Operationen zu pausieren oder Daten zu sichern.
    - Auslösen von `LockSession` durch eine MCP-Methode, um den Bildschirm zu sperren.

### 6.6. `org.freedesktop.UPower` – Energieverwaltung

UPower liefert Informationen über Energiequellen und deren Status.92 Dies kann für MCP-Komponenten relevant sein, die ihr Verhalten an den Energiestatus anpassen müssen.

- **UPower-Interface (`org.freedesktop.UPower` auf `/org/freedesktop/UPower`):** 93
    - **Methoden:**
        - `EnumerateDevices(OUT Array<ObjectPath> devices)`
        - `GetDisplayDevice(OUT ObjectPath device)`
        - `GetCriticalAction(OUT String action)`
    - **Signale:**
        - `DeviceAdded(ObjectPath device)` [93 (nicht zugänglich)]
        - `DeviceRemoved(ObjectPath device)` [93 (nicht zugänglich)]
        - `DeviceChanged(ObjectPath device)` (impliziert durch `PropertiesChanged` auf Device-Objekt)
    - **Properties:**
        - `DaemonVersion` (String, RO)
        - `OnBattery` (Boolean, RO)
        - `LidIsClosed` (Boolean, RO)
        - `LidIsPresent` (Boolean, RO)
- **Device-Interface (`org.freedesktop.UPower.Device` auf dem jeweiligen Gerätepfad):** 93
    - **Properties (Auswahl):**
        - `Type` (UInt32, z.B. Battery, UPS, LinePower)
        - `State` (UInt32, z.B. Charging, Discharging, FullyCharged)
        - `Percentage` (Double)
        - `TimeToEmpty` (Int64, Sekunden)
        - `TimeToFull` (Int64, Sekunden)
        - `IsPresent` (Boolean)
        - `IconName` (String)
        - `WarningLevel` (UInt32)
    - **Signale:**
        - `PropertiesChanged` (via `org.freedesktop.DBus.Properties`) [257 (nicht zugänglich)]
- **Nutzung im NovaDE-Projekt für MCP-Kontext:**
    - MCP-Werkzeuge könnten den Batteriestatus abfragen (`OnBattery`, `Percentage`, `TimeToEmpty`), um langlaufende Operationen zu vermeiden oder den Benutzer zu warnen.
    - Anpassung des Verhaltens von NovaDE-Komponenten basierend auf dem Energiestatus (z.B. Reduzierung der Hintergrundaktivität bei niedrigem Akkustand).

### 6.7. `org.freedesktop.Notifications` – Desktop-Benachrichtigungen

Diese Schnittstelle ermöglicht es Anwendungen, Desktop-Benachrichtigungen anzuzeigen.95 MCP-Komponenten im NovaDE-Projekt können dies nutzen, um Benutzer über wichtige Ereignisse, den Abschluss von Aufgaben oder Fehler zu informieren.

- **Schnittstellenspezifikation (`org.freedesktop.Notifications` auf `/org/freedesktop/Notifications`):** 96
    - **Methoden:**
        - `Notify(IN String app_name, IN UInt32 replaces_id, IN String app_icon, IN String summary, IN String body, IN Array<String> actions, IN Dict<String,Variant> hints, IN Int32 expire_timeout, OUT UInt32 notification_id)`
        - `CloseNotification(IN UInt32 id)`
        - `GetCapabilities(OUT Array<String> capabilities)`
        - `GetServerInformation(OUT String name, OUT String vendor, OUT String version, OUT String spec_version)`
    - **Signale:**
        - `NotificationClosed(UInt32 id, UInt32 reason)`
        - `ActionInvoked(UInt32 id, String action_key)`
- **Wichtige Parameter und Hinweise:**
    - `actions`: Liste von Aktions-IDs und deren lesbaren Bezeichnungen.
    - `hints`: Diktionär für zusätzliche Hinweise (z.B. `urgency`, `sound-file`, `image-data`).
    - `expire_timeout`: `-1` für Server-Default, `0` für niemals auslaufend.
- **Nutzung im NovaDE-Projekt durch MCP:**
    - Ein MCP-Tool, das eine langlaufende Aufgabe abschließt, kann `Notify` aufrufen, um den Benutzer zu informieren.
    - Fehler, die in MCP-Operationen auftreten und Benutzereingriffe erfordern, können als Benachrichtigungen signalisiert werden.
    - Aktionen in Benachrichtigungen (`actions`-Parameter) können mit spezifischen MCP-Folgeaktionen im NovaDE-Client verknüpft werden.

## 7. Interaktion mit Wayland (Smithay)

Falls das NovaDE-Projekt einen eigenen Wayland-Compositor beinhaltet oder tief mit einem solchen interagiert (z.B. für spezifische Desktop-Umgebungsfeatures), kommt das Smithay-Framework zum Einsatz.10 Smithay ist eine Rust-Bibliothek zum Erstellen von Wayland-Compositoren.

### 7.1. Smithay Architekturüberblick

Smithay bietet Bausteine für Wayland-Compositoren und ist modular aufgebaut.10

- **Display und EventLoop:** Das Herzstück ist der `Display`-Typ (aus `wayland-server`) und ein `calloop::EventLoop`.98 `DisplayHandle` wird für Interaktionen mit dem Wayland-Protokoll verwendet [214 (nicht zugänglich)]. Der `EventLoopHandle` von `calloop` dient zur Verwaltung von Event-Quellen.234
- **State Management:** Ein zentraler `State`-Typ (z.B. `AnvilState` im Smithay-Beispielcompositor Anvil) hält den Zustand des Compositors [258 (nicht zugänglich), 124 (nicht zugänglich), 124 (nicht zugänglich), 98 (nicht zugänglich), 261 (nicht zugänglich), 262 (nicht zugänglich), 170 (nicht zugänglich)]. `ClientData` (oder `UserDataMap` auf Ressourcen) wird verwendet, um client-spezifischen Zustand zu speichern [98 (nicht zugänglich)].
- **Handler und Delegation:** Für verschiedene Wayland-Protokolle und -Objekte implementiert der `State`-Typ spezifische Handler-Traits (z.B. `CompositorHandler`, `ShmHandler`, `OutputHandler`, `SeatHandler`, `DataDeviceHandler`, `XdgShellHandler`, etc.). Smithay verwendet `delegate_<protocol>!` Makros, um die Dispatch-Logik zu vereinfachen [98 (nicht zugänglich), 136 (nicht zugänglich), 201 (nicht zugänglich), 205 (nicht zugänglich), 200 (nicht zugänglich), 200 (nicht zugänglich), 145 (nicht zugänglich), 222 (nicht zugänglich), 222 (nicht zugänglich), 200 (nicht zugänglich)].

### 7.2. Wayland Core Protokolle und ihre Handhabung durch MCP

#### 7.2.1. `wl_compositor`, `wl_subcompositor`, `wl_surface`, `wl_buffer`

Diese sind grundlegend für jede Wayland-Anzeige.

- **`CompositorState` und `CompositorHandler`:** Smithay stellt `CompositorState` zur Verwaltung von `wl_surface`-Objekten und deren Hierarchien (Subsurfaces) bereit.235 Der `CompositorHandler` im NovaDE-State muss implementiert werden, um auf Surface-Commits und -Zerstörungen zu reagieren.134 `SurfaceData` [263 (nicht zugänglich)] und `CompositorClientState` [201 (nicht zugänglich)] speichern oberflächen- bzw. clientbezogene Zustände. `SurfaceAttributes` enthalten Informationen wie die zugewiesene Rolle [123 (nicht zugänglich)].
- **`wl_buffer`:** Repräsentiert den Inhalt einer Surface. `BufferHandler` [145 (nicht zugänglich)] wird implementiert, um auf die Zerstörung von Buffern zu reagieren.
- **MCP-Interaktion:** MCP-Komponenten könnten indirekt mit diesen Objekten interagieren, z.B. wenn eine MCP-gesteuerte Anwendung eine UI auf dem Desktop darstellt. Die Spezifikation von Fenstergeometrien oder das Anfordern von Neuzeichnungen könnte über MCP-Methoden erfolgen, die dann auf die entsprechenden `wl_surface`-Operationen abgebildet werden.

#### 7.2.2. `wl_shm` – Shared Memory Buffers

Ermöglicht Clients, Buffer über Shared Memory bereitzustellen.

- **`ShmState` und `ShmHandler`:** `ShmState` verwaltet den `wl_shm`-Global und die unterstützten Formate. Der `ShmHandler` im NovaDE-State stellt den Zugriff auf `ShmState` sicher.136
- **Buffer-Import und Rendering:** `with_buffer_contents` erlaubt den Zugriff auf SHM-Buffer-Daten.145 Renderer wie `GlesRenderer` können SHM-Buffer importieren (`import_shm_buffer`) und rendern.171 MCP-Aktionen, die die Anzeige von Inhalten erfordern, die von einem Client als SHM-Buffer bereitgestellt werden, nutzen diese Mechanismen.

#### 7.2.3. `wl_output` und `xdg-output` – Output Management

Verwaltung von Bildschirmausgaben.

- **`Output` und `OutputHandler`:** Ein `Output`-Objekt repräsentiert eine physische Anzeige. `Output::new()` erstellt ein Output-Objekt, `Output::create_global()` macht es für Clients sichtbar [137 (nicht zugänglich), 137]. `Output::change_current_state()` aktualisiert Modus, Transformation, Skalierung und Position. Der `OutputHandler` im NovaDE-State behandelt clientseitige Interaktionen.101
- **`OutputManagerState`:** Kann verwendet werden, um `xdg-output` zusätzlich zu `wl_output` zu verwalten [137 (nicht zugänglich)].
- **MCP-Interaktion:** MCP-Methoden könnten es ermöglichen, Informationen über verfügbare Ausgaben abzurufen oder anwendungsspezifische Fenster auf bestimmten Ausgaben zu positionieren, basierend auf den von diesen Modulen bereitgestellten Informationen.

#### 7.2.4. `wl_seat`, `wl_keyboard`, `wl_pointer`, `wl_touch` – Input Handling

Verwaltung von Eingabegeräten und Fokus.

- **`SeatState` und `SeatHandler`:** `SeatState` verwaltet einen oder mehrere `Seat`-Instanzen. Der `SeatHandler` im NovaDE-State definiert, wie auf Eingabeereignisse und Fokusänderungen reagiert wird.113
- **Fokus-Management:** `KeyboardFocus`, `PointerFocus`, `TouchFocus` werden typischerweise auf `WlSurface` gesetzt, um den Eingabefokus zu lenken.113
- **Input Grabs:** Mechanismen wie `PointerGrab` und `KeyboardGrab` ermöglichen es, Eingabeereignisse exklusiv für eine bestimmte Oberfläche oder Aktion abzufangen [187 (nicht zugänglich)].
- **MCP-Interaktion:** MCP-gesteuerte Aktionen könnten den Fokus anfordern oder auf Eingabeereignisse reagieren, die über diese Seat-Abstraktionen verarbeitet werden. Beispielsweise könnte ein MCP-Tool eine Texteingabe erfordern, was das Setzen des Tastaturfokus auf ein entsprechendes Eingabefeld des MCP-Clients zur Folge hätte.


---

# Ultra-Feinspezifikation der MCP-Schnittstellen und Implementierungen für das NovaDE-Projekt

## 1. Einleitung

### 1.1. Zweck des Dokuments

Dieses Dokument definiert die Ultra-Feinspezifikation aller Model Context Protocol (MCP) Schnittstellen und deren Implementierungen innerhalb des NovaDE-Projekts. Es dient als maßgebliche technische Referenz für die Entwicklung, Integration und Wartung von MCP-basierten Komponenten im NovaDE-Ökosystem. Die Spezifikation umfasst detaillierte Beschreibungen von Nachrichtenformaten, Datenstrukturen, Methoden, Ereignissen und Fehlerbehandlungsmechanismen. Ein besonderer Fokus liegt auf der Integration der Domänenschicht-Spezifikation des NovaDE-Projekts in die MCP-Schnittstellen.

### 1.2. Geltungsbereich

Diese Spezifikation bezieht sich auf sämtliche Aspekte des Model Context Protocol, wie es im Kontext des NovaDE-Projekts eingesetzt wird. Dies beinhaltet:

- Alle MCP-Schnittstellen, die im NovaDE-Projekt definiert oder genutzt werden.
- Die Interaktion dieser MCP-Schnittstellen mit anderen Systemkomponenten, einschließlich, aber nicht beschränkt auf D-Bus-Dienste, Wayland-Protokolle und PipeWire-Audio-Management.
- Implementierungsrichtlinien und -details, insbesondere unter Verwendung der Programmiersprache Rust und assoziierter Bibliotheken.
- Die nahtlose Einbindung der fachlichen Anforderungen und Datenmodelle aus der Domänenschicht-Spezifikation des NovaDE-Projekts.

### 1.3. Zielgruppe

Dieses Dokument richtet sich an folgende Personengruppen innerhalb des NovaDE-Projekts:

- Softwarearchitekten und -entwickler, die MCP-Schnittstellen und -Komponenten entwerfen, implementieren oder nutzen.
- Systemintegratoren, die für die Bereitstellung und Konfiguration von NovaDE-Systemen verantwortlich sind.
- Qualitätssicherungsingenieure, die MCP-Funktionalitäten testen.
- Technische Projektmanager, die die Entwicklung und Implementierung des NovaDE-Projekts überwachen.

### 1.4. Definitionen und Akronyme

- **MCP:** Model Context Protocol. Ein offener Standard zur Kommunikation zwischen KI-Modellen/Anwendungen und externen Werkzeugen oder Datenquellen.1
- **NovaDE-Projekt:** Das spezifische Projekt, für das diese MCP-Spezifikation erstellt wird. (Details zum Projekt selbst sind außerhalb des Geltungsbereichs der bereitgestellten Materialien).
- **Domänenschicht-Spezifikation:** Ein separates Dokument, das die fachlichen Entitäten, Geschäftsregeln und Datenmodelle des NovaDE-Projekts beschreibt. Diese Spezifikation wird als integraler Bestandteil der MCP-Schnittstellendefinitionen betrachtet.
- **API:** Application Programming Interface.
- **D-Bus:** Desktop Bus, ein System für Interprozesskommunikation (IPC).3
- **Wayland:** Ein Kommunikationsprotokoll zwischen einem Display-Server (Compositor) und seinen Clients.4
- **PipeWire:** Ein Multimedia-Framework für Audio- und Videoverarbeitung unter Linux.5
- **XDG Desktop Portals:** Ein Framework, das sandboxed Anwendungen den sicheren Zugriff auf Ressourcen außerhalb der Sandbox ermöglicht.6
- **JSON-RPC:** JavaScript Object Notation Remote Procedure Call. Ein leichtgewichtiges RPC-Protokoll.8
- **Stdio:** Standard Input/Output.
- **SSE:** Server-Sent Events. Eine Technologie, die es einem Server ermöglicht, Updates an einen Client über eine HTTP-Verbindung zu pushen.8
- **Smithay:** Eine Rust-Bibliothek zur Erstellung von Wayland-Compositoren.10
- **zbus:** Eine Rust-Bibliothek für die D-Bus-Kommunikation.12
- **pipewire-rs:** Rust-Bindungen für PipeWire.14
- **mcpr:** Eine Rust-Implementierung des Model Context Protocol.16
- **mcp_client_rs:** Eine weitere Rust-Client-SDK für MCP.17

### 1.5. Referenzierte Dokumente

- Model Context Protocol Specification (Version 2025-03-26 oder aktueller) 2
- Domänenschicht-Spezifikation des NovaDE-Projekts (externes Dokument)
- Freedesktop D-Bus Specification 3
- Wayland Protocol Specification 4
- PipeWire Documentation 5
- XDG Desktop Portal Documentation 6
- Spezifikationen der relevanten D-Bus-Schnittstellen (Secrets, PolicyKit, Portals, Login1, UPower, Notifications)
- Spezifikationen der relevanten Wayland-Protokolle und -Erweiterungen
- Dokumentation der verwendeten Rust-Bibliotheken (Smithay, zbus, pipewire-rs, mcpr, mcp_client_rs, tokio, serde, thiserror etc.)

## 2. Model Context Protocol (MCP) – Grundlagen

### 2.1. Überblick und Kernkonzepte

Das Model Context Protocol (MCP) ist ein offener Standard, der darauf abzielt, die Integration von Large Language Models (LLMs) mit externen Werkzeugen, Datenbanken und APIs zu standardisieren.1 Es fungiert als eine universelle Schnittstelle, die es KI-Modellen ermöglicht, dynamisch auf Kontextinformationen zuzugreifen und Aktionen in ihrer Umgebung auszuführen.9 MCP adressiert die Herausforderung der Informationssilos und proprietären Integrationen, indem es einen einheitlichen Rahmen für die KI-Tool-Kommunikation schafft.1

Die Kernprinzipien von MCP umfassen 2:

- **Standardisierte Schnittstelle:** Einheitliche Methoden für LLMs zum Zugriff auf Werkzeuge und Ressourcen.
- **Erweiterte Fähigkeiten:** Befähigung von LLMs zur Interaktion mit diversen Systemen.
- **Sicherheit und Kontrolle:** Strukturierte Zugriffsmuster mit integrierter Validierung und klaren Grenzen.
- **Modularität und Erweiterbarkeit:** Einfaches Hinzufügen neuer Fähigkeiten durch Server, ohne die Kernanwendung des LLMs modifizieren zu müssen.

MCP ist darauf ausgelegt, die Reproduzierbarkeit von KI-Interaktionen zu verbessern, indem der gesamte notwendige Kontext (Datensätze, Umgebungsspezifikationen, Hyperparameter) an einem Ort verwaltet wird.1

### 2.2. Architektur (Client-Host-Server-Modell)

MCP basiert auf einer Client-Host-Server-Architektur 8:

- **Host:** Eine LLM-Anwendung (z.B. Claude Desktop, IDEs), die Verbindungen initiiert und als Container oder Koordinator für mehrere Client-Instanzen fungiert. Der Host verwaltet den Lebenszyklus, Sicherheitsrichtlinien (Berechtigungen, Benutzerautorisierung) und die Integration des LLMs.1
- **Client:** Eine Protokoll-Client-Komponente innerhalb der Host-Anwendung, die eine 1:1-Verbindung zu einem MCP-Server herstellt. Der Client ist verantwortlich für die Aushandlung von Fähigkeiten und die Orchestrierung von Nachrichten zwischen sich und dem Server.1
- **Server:** Ein Dienst (oft ein leichtgewichtiger Prozess), der spezifische Kontexte, Werkzeuge und Prompts für den Client bereitstellt. Server können lokale Prozesse oder entfernte Dienste sein und kapseln den Zugriff auf Datenquellen, APIs oder andere Utilities.1

Diese Architektur ermöglicht eine klare Trennung der Verantwortlichkeiten und fördert die Entwicklung modularer und wiederverwendbarer MCP-Server.23 Die Kommunikation zwischen diesen Komponenten erfolgt über eine Transportschicht und eine Protokollschicht, die auf JSON-RPC aufbaut und zustandsbehaftete Sitzungen für den Kontextaustausch und das Sampling betont.1

### 2.3. Nachrichtenformate (JSON-RPC 2.0 Basis)

MCP verwendet JSON-RPC 2.0 als Grundlage für seine Nachrichtenformate.8 Dies gewährleistet eine strukturierte und standardisierte Kommunikation. Die Hauptnachrichtentypen sind 8:

- **Requests (Anfragen):** Vom Client oder Server gesendete Nachrichten, die eine Antwort erwarten. Sie enthalten typischerweise eine `method` (Methodenname) und optionale `params` (Parameter).
    - Beispiel: `{"jsonrpc": "2.0", "method": "tools/list", "id": 1}`
- **Responses (Antworten):** Erfolgreiche Antworten auf Requests. Sie enthalten ein `result`-Feld mit den Ergebnisdaten und die `id` des ursprünglichen Requests.
    - Beispiel: `{"jsonrpc": "2.0", "result": {"tools": [...]}, "id": 1}`
- **Error Responses (Fehlerantworten):** Antworten, die anzeigen, dass ein Request fehlgeschlagen ist. Sie enthalten ein `error`-Objekt mit `code`, `message` und optional `data`, sowie die `id` des ursprünglichen Requests.
    - Beispiel: `{"jsonrpc": "2.0", "error": {"code": -32601, "message": "Method not found"}, "id": 1}`
- **Notifications (Benachrichtigungen):** Einwegnachrichten, die keine Antwort erwarten. Sie enthalten eine `method` und optionale `params`, aber keine `id`.
    - Beispiel: `{"jsonrpc": "2.0", "method": "textDocument/didChange", "params": {...}}`

Die spezifischen Methoden und Parameter für MCP-Nachrichten wie `initialize`, `tools/list`, `resources/read`, `tools/call` werden im weiteren Verlauf dieses Dokuments detailliert [2 (angenommen)].

### 2.4. Transportmechanismen

MCP unterstützt verschiedene Transportmechanismen für die Kommunikation zwischen Host/Client und Server 8:

- **Stdio (Standard Input/Output):** Dieser Mechanismus wird für die Kommunikation mit lokalen Prozessen verwendet. Der MCP-Server läuft als separater Prozess, und die Kommunikation erfolgt über dessen Standard-Eingabe- und Ausgabe-Streams. Dies ist ideal für Kommandozeilenwerkzeuge und lokale Entwicklungsszenarien.16 Die Rust-Bibliothek `mcpr` bietet beispielsweise `StdioTransport` 16, und `mcp_client_rs` fokussiert sich ebenfalls auf diesen Transportweg für lokal gespawnte Server.18
- **HTTP mit SSE (Server-Sent Events):** Dieser Mechanismus wird für netzwerkbasierte Kommunikation verwendet, insbesondere wenn der Server remote ist oder Echtzeit-Updates vom Server an den Client erforderlich sind. SSE ermöglicht es dem Server, asynchron Nachrichten an den Client zu pushen, während Client-zu-Server-Nachrichten typischerweise über HTTP POST gesendet werden.8 Die `mcpr`-Bibliothek erwähnt SSE-Transportunterstützung.16

Die Wahl des Transportmechanismus hängt von den spezifischen Anforderungen der NovaDE-Komponente ab, insbesondere davon, ob der MCP-Server lokal oder remote betrieben wird.

### 2.5. Sicherheitsaspekte

Sicherheit und Datenschutz sind zentrale Aspekte des Model Context Protocol, da es potenziell den Zugriff auf sensible Daten und die Ausführung von Code ermöglicht.2 Die Spezifikation legt folgende Schlüsselprinzipien fest 2:

- **Benutzereinwilligung und -kontrolle:**
    - Benutzer müssen explizit allen Datenzugriffen und Operationen zustimmen und diese verstehen.
    - Benutzer müssen die Kontrolle darüber behalten, welche Daten geteilt und welche Aktionen ausgeführt werden.
    - Implementierungen sollten klare Benutzeroberflächen zur Überprüfung und Autorisierung von Aktivitäten bereitstellen.
- **Datenschutz:**
    - Hosts müssen die explizite Zustimmung des Benutzers einholen, bevor Benutzerdaten an Server weitergegeben werden.
    - Hosts dürfen Ressourcendaten nicht ohne Zustimmung des Benutzers an andere Stellen übertragen.
    - Benutzerdaten sollten durch geeignete Zugriffskontrollen geschützt werden.
- **Werkzeugsicherheit (Tool Safety):**
    - Werkzeuge repräsentieren die Ausführung von beliebigem Code und müssen mit entsprechender Vorsicht behandelt werden. Beschreibungen des Werkzeugverhaltens (z.B. Annotationen) sind als nicht vertrauenswürdig zu betrachten, es sei denn, sie stammen von einem vertrauenswürdigen Server.
    - Hosts müssen die explizite Zustimmung des Benutzers einholen, bevor ein Werkzeug aufgerufen wird.
    - Benutzer sollten verstehen, was jedes Werkzeug tut, bevor sie dessen Verwendung autorisieren.
- **LLM Sampling Controls:**
    - Benutzer müssen explizit allen LLM-Sampling-Anfragen zustimmen.
    - Benutzer sollten kontrollieren, ob Sampling überhaupt stattfindet, den tatsächlichen Prompt, der gesendet wird, und welche Ergebnisse der Server sehen kann.

Obwohl MCP diese Prinzipien nicht auf Protokollebene erzwingen kann, **SOLLTEN** Implementierer robuste Zustimmungs- und Autorisierungsflüsse entwickeln, Sicherheitsimplikationen klar dokumentieren, geeignete Zugriffskontrollen und Datenschutzmaßnahmen implementieren und bewährte Sicherheitspraktiken befolgen.2 Die Architektur mit MCP-Servern als Vermittler kann eine zusätzliche Sicherheitsebene bieten, indem der Zugriff auf Ressourcen kontrolliert und potenziell in einer Sandbox ausgeführt wird.19

## 3. MCP-Schnittstellen im NovaDE-Projekt – Allgemeine Spezifikation

### 3.1. Namenskonventionen und Versionierung

Für alle MCP-Schnittstellen, die im Rahmen des NovaDE-Projekts definiert werden, gelten folgende Namenskonventionen und Versionierungsrichtlinien:

- **Schnittstellennamen:** Schnittstellennamen folgen dem Muster `nova.<KomponentenName>.<Funktionsbereich>.<Version>`. Beispiel: `nova.workspace.fileAccess.v1`. Dies gewährleistet Eindeutigkeit und Klarheit über den Ursprung und Zweck der Schnittstelle.
- **Methodennamen:** Methodennamen verwenden camelCase, beginnend mit einem Kleinbuchstaben (z.B. `listResources`, `callTool`).
- **Parameternamen:** Parameternamen verwenden ebenfalls camelCase.
- **Versionierung:** Jede MCP-Schnittstelle wird explizit versioniert. Die Version wird als Teil des Schnittstellennamens geführt (z.B. `v1`, `v2`). Änderungen, die die Abwärtskompatibilität brechen, erfordern eine Erhöhung der Hauptversionsnummer. Abwärtskompatible Erweiterungen können zu einer Erhöhung einer Nebenversionsnummer führen, falls ein solches Schema zusätzlich eingeführt wird. Das NovaDE-Projekt hält sich an die im MCP-Standard definierte Protokollversion (z.B. `2025-03-26`).2 Die aktuell unterstützte MCP-Protokollversion ist im `mcp_client_rs` Crate als `LATEST_PROTOCOL_VERSION` und `SUPPORTED_PROTOCOL_VERSIONS` definiert.27

### 3.2. Standardnachrichtenflüsse

Die Kommunikation im NovaDE-Projekt über MCP folgt etablierten Nachrichtenflüssen, die auf dem JSON-RPC 2.0 Standard basieren.8

1. **Initialisierung (Connection Lifecycle):** 8
    - Der MCP-Client (innerhalb des NovaDE-Hosts) sendet eine `initialize`-Anfrage an den MCP-Server. Diese Anfrage enthält die vom Client unterstützte Protokollversion und dessen Fähigkeiten (Capabilities).
    - Der MCP-Server antwortet mit seiner Protokollversion und seinen Fähigkeiten.
    - Der Client bestätigt die erfolgreiche Initialisierung mit einer `initialized`-Notification.
    - Anschließend beginnt der reguläre Nachrichtenaustausch.
2. **Anfrage-Antwort (Request-Response):** 8
    - Der Client sendet eine Anfrage (z.B. `tools/list`, `resources/read`, `tools/call`) mit einer eindeutigen ID.
    - Der Server verarbeitet die Anfrage und sendet entweder eine Erfolgsantwort mit dem Ergebnis (`result`) und derselben ID oder eine Fehlerantwort (`error`) mit Fehlercode, Nachricht und derselben ID.
3. **Benachrichtigungen (Notifications):** 8
    - Client oder Server können einseitige Benachrichtigungen senden, die keine direkte Antwort erwarten. Diese haben keine ID. Ein Beispiel ist die `initialized`-Notification oder serverseitige Push-Events.
4. **Beendigung (Termination):** 8
    - Die Verbindung kann durch eine `shutdown`-Anfrage vom Client initiiert werden, gefolgt von einer `exit`-Notification. Alternativ kann die Verbindung durch Schließen des zugrundeliegenden Transportkanals beendet werden.

Die Rust-Bibliotheken `mcpr` und `mcp_client_rs` implementieren diese grundlegenden Nachrichtenflüsse.16 `mcp_client_rs` beispielsweise nutzt Tokio für asynchrone Operationen und stellt Methoden wie `initialize()`, `list_resources()`, `call_tool()` zur Verfügung, die diesen Flüssen folgen.18

### 3.3. Fehlerbehandlung und Fehlercodes

Eine robuste Fehlerbehandlung ist entscheidend für die Stabilität der MCP-Kommunikation im NovaDE-Projekt. MCP-Fehlerantworten folgen dem JSON-RPC 2.0 Standard 8 und enthalten ein `error`-Objekt mit den Feldern `code` (Integer), `message` (String) und optional `data` (beliebiger Typ).

**Standard-Fehlercodes (basierend auf JSON-RPC 2.0):**

- `-32700 Parse error`: Ungültiges JSON wurde empfangen.
- `-32600 Invalid Request`: Die JSON-Anfrage war nicht wohlgeformt.
- `-32601 Method not found`: Die angeforderte Methode existiert nicht oder ist nicht verfügbar.
- `-32602 Invalid params`: Ungültige Methodenparameter.
- `-32603 Internal error`: Interner JSON-RPC-Fehler.
- `-32000` bis `-32099 Server error`: Reserviert für implementierungsspezifische Serverfehler.

NovaDE-spezifische Fehlercodes:

Zusätzlich zu den Standard-JSON-RPC-Fehlercodes definiert das NovaDE-Projekt spezifische Fehlercodes im Bereich -32000 bis -32099 für anwendungsspezifische Fehler, die während der Verarbeitung von MCP-Anfragen auftreten können. Diese Fehlercodes werden pro Schnittstelle und Methode dokumentiert.

Fehlerbehandlung in Rust-Implementierungen:

In Rust-basierten MCP-Implementierungen für NovaDE wird die Verwendung von thiserror für Bibliotheksfehler und potenziell anyhow für Anwendungsfehler empfohlen, um eine klare und kontextreiche Fehlerbehandlung zu gewährleisten.29 Die mcp_client_rs Bibliothek stellt einen Error-Typ bereit, der verschiedene Fehlerquellen kapselt.27 Die Struktur ErrorResponse und das Enum ErrorCode [240 (angenommen)] sind Teil der Protokolldefinitionen zur strukturierten Fehlerkommunikation.

**Beispiel für eine Fehlerantwort:**

JSON

```
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32001,
    "message": "NovaDE Domain Error: Ressource nicht gefunden.",
    "data": {
      "resourceUri": "nova://domain/entity/123"
    }
  },
  "id": 123
}
```

### 3.4. Integration der Domänenschicht-Spezifikation

Die Domänenschicht-Spezifikation des NovaDE-Projekts ist ein zentrales Element, das die fachlichen Entitäten, Operationen und Geschäftsregeln definiert. Die MCP-Schnittstellen im NovaDE-Projekt müssen diese Domänenspezifikation nahtlos integrieren. Dies bedeutet:

- **Abbildung von Domänenentitäten:** Datenstrukturen innerhalb der MCP-Nachrichten (Parameter von Methoden, Rückgabewerte, Event-Payloads) müssen die Entitäten der Domänenschicht widerspiegeln oder direkt verwenden. Dies stellt sicher, dass die MCP-Kommunikation die fachlichen Anforderungen korrekt abbildet.
- **Domänenoperationen als MCP-Methoden:** Viele MCP-Methoden werden direkte Abbildungen von Operationen sein, die in der Domänenschicht definiert sind. Die Parameter und Rückgabewerte dieser MCP-Methoden korrespondieren mit den Ein- und Ausgaben der Domänenoperationen.
- **Validierung und Geschäftsregeln:** Bevor MCP-Anfragen an die Domänenschicht weitergeleitet oder Ergebnisse von der Domänenschicht über MCP zurückgegeben werden, müssen Validierungen und Geschäftsregeln der Domänenschicht angewendet werden. Dies kann sowohl im MCP-Server als auch in einer zwischengeschalteten Logikschicht geschehen.
- **Konsistente Terminologie:** Die in den MCP-Schnittstellen verwendete Terminologie (Namen von Methoden, Parametern, Datenfeldern) sollte mit der Terminologie der Domänenschicht-Spezifikation übereinstimmen, um Missverständnisse zu vermeiden und die Kohärenz im gesamten System zu fördern.

Die genauen Details der Integration hängen von den spezifischen Inhalten der Domänenschicht-Spezifikation ab. Jede detaillierte MCP-Schnittstellenspezifikation in Abschnitt 4 wird explizit auf die relevanten Teile der Domänenschicht-Spezifikation verweisen und die Abbildung erläutern.

## 4. Detaillierte MCP-Schnittstellenspezifikationen

Für das NovaDE-Projekt werden spezifische MCP-Schnittstellen definiert, um die Interaktion mit verschiedenen Modulen und Diensten zu ermöglichen. Jede Schnittstelle wird nach dem folgenden Schema spezifiziert. _Da die konkreten Schnittstellen für NovaDE nicht in den bereitgestellten Materialien definiert sind, dient der folgende Abschnitt als Vorlage und Beispielstruktur._

---

**Beispiel-Schnittstelle: `nova.dataAccess.document.v1`**

### 4.1. Beschreibung und Zweck

Die Schnittstelle `nova.dataAccess.document.v1` dient dem Zugriff auf und der Verwaltung von Dokumenten innerhalb des NovaDE-Projekts. Sie ermöglicht es MCP-Clients, Dokumente basierend auf Kriterien der Domänenschicht zu lesen, zu schreiben, zu aktualisieren und zu löschen. Diese Schnittstelle interagiert eng mit den Entitäten und Operationen, die in der "Domänenschicht-Spezifikation, Abschnitt X.Y (Dokumentenverwaltung)" definiert sind.

### 4.2. Methoden

#### 4.2.1. `readDocument`

- **Beschreibung:** Liest den Inhalt und die Metadaten eines spezifischen Dokuments.
- **Parameter:**
    - `uri` (String, erforderlich): Der eindeutige URI des Dokuments, konform zum NovaDE-URI-Schema (z.B. `nova://documents/internal/doc123`).
    - `options` (Object, optional): Zusätzliche Optionen für den Lesevorgang.
        - `version` (String, optional): Die spezifische Version des Dokuments, die gelesen werden soll. Falls nicht angegeben, wird die neueste Version gelesen.
- **Rückgabewerte:**
    - `document` (Object): Ein Objekt, das das gelesene Dokument repräsentiert. Die Struktur dieses Objekts ist in der Domänenschicht-Spezifikation definiert und könnte Felder wie `uri`, `mimeType`, `content` (String oder Binary), `metadata` (Object), `version` (String), `lastModified` (Timestamp) enthalten.
- **Mögliche Fehler:**
    - `-32001`: `DOCUMENT_NOT_FOUND` - Das angeforderte Dokument existiert nicht.
    - `-32002`: `ACCESS_DENIED` - Der Client hat keine Berechtigung, das Dokument zu lesen.
    - `-32003`: `VERSION_NOT_FOUND` - Die angeforderte Version des Dokuments existiert nicht.

#### 4.2.2. `writeDocument`

- **Beschreibung:** Schreibt ein neues Dokument oder aktualisiert ein bestehendes Dokument.
- **Parameter:**
    - `uri` (String, erforderlich): Der URI, unter dem das Dokument geschrieben werden soll. Bei Aktualisierung eines bestehenden Dokuments dessen URI.
    - `content` (String oder Binary, erforderlich): Der Inhalt des Dokuments. Der Typ (String oder Base64-kodiertes Binary) hängt vom `mimeType` ab.
    - `mimeType` (String, erforderlich): Der MIME-Typ des Dokuments (z.B. `text/plain`, `application/pdf`).
    - `metadata` (Object, optional): Domänenspezifische Metadaten für das Dokument.
    - `options` (Object, optional):
        - `overwrite` (Boolean, optional, default: `false`): Wenn `true` und ein Dokument unter dem URI existiert, wird es überschrieben. Andernfalls schlägt der Aufruf fehl, wenn das Dokument existiert.
- **Rückgabewerte:**
    - `newUri` (String): Der URI des geschriebenen oder aktualisierten Dokuments (kann sich bei Neuerstellung ändern, falls der Server URIs generiert).
    - `version` (String): Die Versionskennung des geschriebenen Dokuments.
- **Mögliche Fehler:**
    - `-32002`: `ACCESS_DENIED` - Keine Schreibberechtigung.
    - `-32004`: `DOCUMENT_EXISTS` - Dokument existiert bereits und `overwrite` ist `false`.
    - `-32005`: `INVALID_CONTENT` - Der bereitgestellte Inhalt ist für den `mimeType` ungültig.

_(Weitere Methoden wie `deleteDocument`, `listDocuments` würden hier analog spezifiziert werden.)_

### 4.3. Events/Notifications

#### 4.3.1. `documentChanged`

- **Beschreibung:** Wird vom Server gesendet, wenn ein Dokument, für das der Client möglicherweise Interesse bekundet hat (z.B. durch vorheriges Lesen), geändert wurde.
- **Parameter:**
    - `uri` (String): Der URI des geänderten Dokuments.
    - `changeType` (String): Art der Änderung (z.B. `UPDATED`, `DELETED`).
    - `newVersion` (String, optional): Die neue Versionskennung, falls `changeType` `UPDATED` ist.

### 4.4. Datenstrukturen

Die für diese Schnittstelle relevanten Datenstrukturen (z.B. die Struktur eines `Document`-Objekts, `Metadata`-Objekts) werden primär durch die Domänenschicht-Spezifikation des NovaDE-Projekts definiert. MCP-Nachrichten verwenden JSON-Repräsentationen dieser domänenspezifischen Strukturen.

**Beispiel `Document` (basierend auf einer hypothetischen Domänenspezifikation):**

JSON

```
{
  "uri": "nova://documents/internal/doc123",
  "mimeType": "text/plain",
  "content": "Dies ist der Inhalt des Dokuments.",
  "metadata": {
    "author": "NovaUser",
    "tags": ["wichtig", "projektA"],
    "customDomainField": "spezifischerWert"
  },
  "version": "v1.2.3",
  "lastModified": "2024-07-15T10:30:00Z"
}
```

### 4.5. Beispiele für Nachrichten

**Anfrage `readDocument`:**

JSON

```
{
  "jsonrpc": "2.0",
  "method": "nova.dataAccess.document.v1/readDocument",
  "params": {
    "uri": "nova://documents/internal/doc123"
  },
  "id": 1
}
```

**Antwort `readDocument` (Erfolg):**

JSON

```
{
  "jsonrpc": "2.0",
  "result": {
    "document": {
      "uri": "nova://documents/internal/doc123",
      "mimeType": "text/plain",
      "content": "Dies ist der Inhalt des Dokuments.",
      "metadata": {"author": "NovaUser"},
      "version": "v1.0.0",
      "lastModified": "2024-07-15T10:00:00Z"
    }
  },
  "id": 1
}
```

### 4.6. Interaktion mit der Domänenschicht

Die Methode `readDocument` ruft intern die Funktion `DomainLayer.getDocumentByUri(uri, options.version)` der Domänenschicht auf. Die zurückgegebenen Domänenobjekte werden gemäß den MCP-Datenstrukturen serialisiert. Die Methode `writeDocument` validiert die Eingaben anhand der Geschäftsregeln der Domänenschicht (z.B. `DomainLayer.validateDocumentContent(content, mimeType)`) und ruft dann `DomainLayer.saveDocument(documentData)` auf. Berechtigungsprüfungen erfolgen ebenfalls über dedizierte Domänenschicht-Services (z.B. `DomainLayer.Security.canReadDocument(userContext, uri)`).

---

_(Dieser beispielhafte Abschnitt würde für jede spezifische MCP-Schnittstelle im NovaDE-Projekt wiederholt werden.)_

## 5. Implementierung der MCP-Schnittstellen im NovaDE-Projekt

### 5.1. Verwendete Technologien

Die Kernimplementierung der MCP-Schnittstellen und der zugehörigen Logik im NovaDE-Projekt erfolgt in **Rust**. Dies schließt sowohl Client- als auch (potenzielle) Server-seitige Komponenten ein. Die Wahl von Rust begründet sich in dessen Stärken hinsichtlich Systemsicherheit, Performance und Nebenläufigkeit, welche für ein robustes Desktop Environment Projekt wie NovaDE essentiell sind.

Folgende Rust-Bibliotheken (Crates) sind für die MCP-Implementierung von zentraler Bedeutung:

- **MCP-Protokoll-Handling:**
    - `mcp_client_rs` (von darinkishore) [17 (angenommen), 241 (angenommen), 28 (angenommen), 243 (angenommen), 244 (angenommen), 243 (angenommen), 242 (angenommen), 245 (angenommen), 246 (angenommen), 246 (angenommen)] oder alternativ `mcpr` (von conikeec) 16 für die Client-seitige Implementierung. Die Entscheidung für eine spezifische Bibliothek hängt von den detaillierten Anforderungen und der Reife der jeweiligen Bibliothek zum Zeitpunkt der Implementierung ab. Beide bieten Mechanismen zur Serialisierung/Deserialisierung von MCP-Nachrichten und zur Verwaltung der Kommunikation.
- **Asynchrone Laufzeitumgebung:** `tokio` wird als primäre asynchrone Laufzeitumgebung für die nebenläufige Verarbeitung von MCP-Nachrichten und Interaktionen mit anderen Systemdiensten verwendet.25
- **Serialisierung/Deserialisierung:** `serde` und `serde_json` für die Umwandlung von Rust-Datenstrukturen in und aus dem JSON-Format, das von JSON-RPC verwendet wird.25
- **Fehlerbehandlung:** `thiserror` für die Definition von benutzerdefinierten Fehlertypen in Bibliotheks-Code und potenziell `anyhow` für eine vereinfachte Fehlerbehandlung in Anwendungscode.29
- **UUID-Generierung:** Das `uuid` Crate mit den Features `v4` und `serde` wird für die Erzeugung und Handhabung von eindeutigen Identifikatoren verwendet, die in MCP-Nachrichten oder domänenspezifischen Daten benötigt werden könnten.41
- **D-Bus-Kommunikation:** `zbus` für die Interaktion mit Systemdiensten über D-Bus.12
- **Wayland Compositing (falls NovaDE ein Compositor ist oder tief integriert):** `smithay` als Framework für Wayland-spezifische Interaktionen.10
- **PipeWire-Integration:** `pipewire-rs` für die Interaktion mit dem PipeWire Multimedia-Framework.14

### 5.2. MCP-Client-Implementierung (Rust)

Die MCP-Client-Komponenten im NovaDE-Projekt sind für die Kommunikation mit verschiedenen MCP-Servern zuständig, die Werkzeuge und Ressourcen bereitstellen.

#### 5.2.1. Initialisierung und Verbindungsaufbau

Die Initialisierung eines MCP-Clients beginnt mit der Konfiguration des Transports und der Erstellung einer Client-Instanz. Am Beispiel von `mcp_client_rs` (darinkishore):

- **Server-Spawning (für lokale Server via Stdio):** Die `ClientBuilder`-API ermöglicht das Starten eines lokalen MCP-Serverprozesses und die Verbindung zu dessen Stdio-Kanälen.17
    
    Rust
    
    ```
    // Beispielhafte Initialisierung (Pseudocode, da Servername und Argumente spezifisch für NovaDE sind)
    // use mcp_client_rs::client::ClientBuilder;
    // let client = ClientBuilder::new("nova-mcp-server-executable")
    //    .arg("--config-path")
    //    .arg("/etc/nova/mcp_server_config.json")
    //    .spawn_and_initialize().await?;
    ```
    
    Es ist wichtig zu beachten, dass `mcp_client_rs` (darinkishore) primär für lokal gespawnte Server konzipiert ist und keine direkte Unterstützung für Remote-Server plant.17 Für Remote-Verbindungen via HTTP/SSE müsste eine andere Bibliothek oder eine Erweiterung dieses Ansatzes in Betracht gezogen werden, wie sie z.B. in `mcpr` (conikeec) angedeutet ist.16
    
- **Verwendung eines existierenden Transports:** Alternativ kann ein Client mit einem bereits existierenden Transportobjekt initialisiert werden.14
    
    Rust
    
    ```
    // use std::sync::Arc;
    // use mcp_client_rs::client::Client;
    // use mcp_client_rs::transport::stdio::StdioTransport;
    // use tokio::io::{stdin, stdout};
    //
    // let transport = StdioTransport::with_streams(stdin(), stdout());
    // let client = Client::new(Arc::new(transport));
    ```
    
- **`initialize`-Nachricht:** Nach dem Aufbau der Transportverbindung sendet der Client eine `initialize`-Anfrage an den Server, um Protokollversionen und Fähigkeiten auszutauschen.8 Die `spawn_and_initialize()`-Methode von `mcp_client_rs` (darinkishore) handhabt dies implizit.17 Die `initialize()`-Methode auf der Client-Instanz von `mcpr` (conikeec) führt dies explizit durch.16
    

Die `InitializeParams` [240 (angenommen)] würden typischerweise die `protocolVersion` (z.B. "2025-03-26"), `clientName`, `clientVersion` und `supportedFeatures` enthalten. Die `InitializeResult` [240 (angenommen)] vom Server bestätigt die `protocolVersion` und listet die `serverCapabilities` und `serverInfo` auf.

#### 5.2.2. Senden von Requests

MCP-Clients im NovaDE-Projekt senden Anfragen an Server, um Ressourcen aufzulisten, Werkzeuge aufzurufen oder andere definierte Operationen auszuführen.

- **`ListResources`:**
    - Parameter: `ListResourcesParams` [240 (angenommen)] können Filterkriterien oder Paginierungsinformationen enthalten.
    - Antwort: `ListResourcesResult` [240 (angenommen)] enthält eine Liste von `Resource`-Objekten [240 (angenommen)], die jeweils URI, Name, Beschreibung und unterstützte Operationen definieren.
    - Beispielaufruf mit `mcp_client_rs`: `let resources = client.list_resources().await?;` 18
- **`CallTool`:**
    - Parameter: `CallToolParams` [240 (angenommen)] enthalten den `toolName` (String) und `arguments` (JSON-Objekt).
    - Antwort: `CallToolResult` [240 (angenommen)] enthält das Ergebnis der Werkzeugausführung, typischerweise als JSON-Objekt.
    - Beispielaufruf mit `mcp_client_rs`: `let tool_result = client.call_tool("domain.action.calculateSum", serde_json::json!({"op1": 10, "op2": 20})).await?;` 18
    - Die Definition von Werkzeugen (`ToolDefinition` [240 (angenommen)]) umfasst Name, Beschreibung und ein JSON-Schema für die Parameter.
- **`ReadResource`:** (und andere domänenspezifische Requests)
    - Parameter: Typischerweise ein URI und optionale Parameter.
    - Antwort: Der Inhalt oder Zustand der Ressource.
    - Beispielaufruf mit `mcp_client_rs`: `let read_result = client.read_resource("nova://domain/entity/123").await?;` 18

Alle diese Anfragen werden asynchron über den konfigurierten Transportmechanismus gesendet. Die `mcp_client_rs` Bibliothek nutzt Tokio für diese asynchronen Operationen.25

#### 5.2.3. Empfangen von Responses und Notifications

Der Empfang von Nachrichten ist ein kritischer Aspekt der MCP-Client-Implementierung.

- **Responses:** Antworten auf Client-Anfragen werden typischerweise über `async/await` Konstrukte direkt als Rückgabewerte der aufrufenden Methoden empfangen (z.B. `ListResourcesResult` von `list_resources().await?`).18 Die zugrundeliegende Transportlogik (z.B. in `StdioTransport` [242 (angenommen), 244 (angenommen), 242 (angenommen)]) liest die Rohdaten, parst sie als `McpMessage` [240 (angenommen)] und leitet sie an den entsprechenden wartenden Task weiter.
- **Notifications (Server Push Events):** Asynchrone Benachrichtigungen vom Server (z.B. `documentChanged` aus dem Beispiel in Abschnitt 4.3.1) erfordern einen dedizierten Mechanismus zum Empfang und zur Verarbeitung.
    - Die `mcpr` Bibliothek (conikeec) deutet auf Unterstützung für Server-Sent Events (SSE) hin, was einen Stream von Ereignissen impliziert, den der Client verarbeiten müsste.16
    - Die `mcp_client_rs` Bibliothek (darinkishore) ist primär auf Stdio ausgerichtet. Die Handhabung von Server-Push-Benachrichtigungen über Stdio würde erfordern, dass der `StdioTransport` kontinuierlich die Standardeingabe liest und eingehende Nachrichten (die keine direkten Antworten auf Anfragen sind) als `Notification` [240 (angenommen)] identifiziert und an einen Handler oder einen Ereignis-Stream weiterleitet. Die genaue Implementierung (z.B. ein dedizierter Empfangs-Loop oder ein Stream von `McpMessage`) ist in den bereitgestellten Snippets nicht vollständig ersichtlich [17 (fehlend), 246 (fehlend), 241 (fehlend), 243 (fehlend), 243 (fehlend), 245 (fehlend), 246 (fehlend), 246 (fehlend)]. Es ist davon auszugehen, dass eine `async_stream`-basierte Lösung oder ein `tokio::sync::broadcast` Kanal 36 verwendet wird, um diese Nachrichten an interessierte Teile der Anwendung zu verteilen.
    - Die `mcp_client_rs` Version 0.1.1 erwähnt "WebSocket Transport (Coming Soon)" mit "built-in reconnection handling", was auf zukünftige robustere Mechanismen für Server-Push und Verbindungsstatus hindeutet.25
- **Connection Status Events:** Die Überwachung des Verbindungsstatus (z.B. Verbindungsabbruch, Wiederverbindung) ist für robuste Anwendungen wichtig. Explizite Mechanismen hierfür sind in den Snippets zu `mcp_client_rs` (darinkishore) nicht detailliert, könnten aber Teil des `WebSocketTransport` sein 25 oder müssten auf der Transportebene (z.B. durch Überwachung der Stdio-Pipes) implementiert werden. Für SSE-Transporte könnten HTTP-Fehlercodes oder das Schließen des Event-Streams als Indikatoren dienen.26

#### 5.2.4. Fehlerbehandlung

Fehler können auf verschiedenen Ebenen auftreten: Transportfehler, JSON-RPC-Parsingfehler, oder anwendungsspezifische Fehler, die vom Server als `ErrorResponse` [240 (angenommen)] gesendet werden.

- Die `mcp_client_rs` Bibliothek verwendet `thiserror` zur Definition ihres `Error`-Typs, der verschiedene Fehlerquellen aggregiert.27
- Client-Code sollte `Result`-Typen sorgfältig behandeln, um auf Fehler angemessen reagieren zu können (z.B. Wiederholungsversuche, Benutzerbenachrichtigung, Logging).
- Spezifische `ErrorCode`-Werte [240 (angenommen)] in `ErrorResponse`-Nachrichten ermöglichen eine differenzierte Fehlerbehandlung basierend auf der Art des serverseitigen Fehlers.

#### 5.2.5. Transport Layer

- **StdioTransport:** Für die Kommunikation mit lokalen Serverprozessen. Implementierungen in `mcpr` 16 und `mcp_client_rs` [25 (angenommen), 244 (angenommen), 242 (angenommen)] lesen von `stdin` und schreiben nach `stdout` des Subprozesses. Die `StdioTransport` in `mcp_client_rs` verwendet typischerweise `tokio::io::AsyncRead` und `tokio::io::AsyncWrite` für die asynchrone Verarbeitung. Eingehende Nachrichten werden zeilenbasiert oder durch Längenpräfixe (gemäß JSON-RPC Framing) gelesen und dann als `McpMessage` deserialisiert.
- **SSETransport (Server-Sent Events):** Für webbasierte oder Remote-Server. `mcpr` erwähnt dessen Unterstützung.16 Dies involviert einen HTTP-Client, der eine Verbindung zu einem SSE-Endpunkt des Servers herstellt und einen kontinuierlichen Stream von Ereignissen empfängt.26

### 5.3. MCP-Server-Implementierung (Rust)

Obwohl der primäre Fokus des NovaDE-Projekts auf der Client-Seite liegen mag, könnten bestimmte Komponenten des Projekts auch als MCP-Server fungieren, um Fähigkeiten für andere Teile des Systems oder externe LLMs bereitzustellen.

- **Struktur:** Ein MCP-Server in Rust, beispielsweise unter Verwendung der `mcpr`-Bibliothek 16, würde eine `ServerConfig` definieren, die Name, Version und eine Liste der bereitgestellten `Tool`-Definitionen enthält. Jedes `Tool` spezifiziert seinen Namen, eine Beschreibung und ein JSON-Schema für seine Parameter.
- **Tool-Registrierung:** Für jedes definierte Werkzeug wird ein Handler registriert, der die Werkzeugparameter entgegennimmt, die Logik ausführt und ein Ergebnis (oder einen Fehler) zurückgibt.
    
    Rust
    
    ```
    // Beispielhafte Server-Konfiguration mit mcpr (conikeec)
    // use mcpr::{server::{Server, ServerConfig}, transport::stdio::StdioTransport, Tool, error::MCPError};
    // use serde_json::Value;
    //
    // let server_config = ServerConfig::new()
    //    .with_name("NovaDE.DomainService.v1")
    //    .with_version("1.0.0")
    //    .with_tool(Tool {
    //         name: "nova.domain.getEntityDetails".to_string(),
    //         description: Some("Ruft Details zu einer Domänenentität ab.".to_string()),
    //         parameters_schema: serde_json::json!({
    //             "type": "object",
    //             "properties": {
    //                 "entityUri": {"type": "string", "description": "URI der Entität"}
    //             },
    //             "required": ["entityUri"]
    //         }),
    //     });
    // let mut server: Server<StdioTransport> = Server::new(server_config);
    // server.register_tool_handler("nova.domain.getEntityDetails", |params: Value| {
    //     // Implementierung der Domänenlogik hier
    //     //...
    //     Ok(serde_json::json!({"status": "success", "data": { /*... */ }}))
    // })?;
    // let transport = StdioTransport::new();
    // server.start(transport)?;
    ```
    

Die Serverimplementierung ist verantwortlich für das Parsen eingehender Anfragen, das Weiterleiten an die entsprechenden Handler und das Senden von Antworten oder Benachrichtigungen über den gewählten Transportmechanismus.

### 5.4. Interaktion mit Systemdiensten und Protokollen

Die MCP-Schnittstellen im NovaDE-Projekt sind nicht isoliert, sondern interagieren intensiv mit bestehenden Systemdiensten und Protokollen. Diese Interaktionen sind entscheidend für den Zugriff auf Systemressourcen, die Verwaltung von Berechtigungen und die Integration in die Desktop-Umgebung. Die folgenden Abschnitte detaillieren diese Interaktionen.

## 6. Interaktion mit D-Bus-Diensten

Die Kommunikation mit systemweiten und benutzerspezifischen Diensten im NovaDE-Projekt erfolgt primär über D-Bus. Die Rust-Bibliothek `zbus` wird für diese Interaktionen verwendet.12

### 6.1. Allgemeine D-Bus-Integration mit `zbus`

`zbus` ermöglicht eine typsichere und asynchrone Kommunikation mit D-Bus-Diensten.

- **Proxy-Generierung:** Für die Interaktion mit D-Bus-Schnittstellen werden Proxys verwendet. Das `#[dbus_proxy]` (oder `#[proxy]`) Makro von `zbus` generiert Rust-Traits und Proxy-Strukturen aus D-Bus-Interface-Definitionen [12 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich), 62 (nicht zugänglich)].
    
    Rust
    
    ```
    // use zbus::{dbus_proxy, Connection, Result};
    // #
    // trait ExampleProxy {
    //     async fn some_method(&self, param: &str) -> Result<String>;
    //     #[dbus_proxy(signal)]
    //     async fn some_signal(&self, value: u32) -> Result<()>;
    // }
    ```
    
- **Verbindungsaufbau:** Eine Verbindung zum Session- oder Systembus wird mit `zbus::Connection::session().await?` bzw. `zbus::Connection::system().await?` hergestellt.45
- **Methodenaufrufe:** Methoden auf D-Bus-Schnittstellen werden asynchron über die generierten Proxy-Methoden aufgerufen.45
- **Signalempfang:** Signale werden als asynchrone Streams (`futures_util::stream::StreamExt`) über die Proxy-Methoden `receive_<signal_name>()` empfangen.46 Die Argumente des Signals können aus der `zbus::Message` deserialisiert werden [46 (nicht zugänglich), 65 (nicht zugänglich)].
- **Fehlerbehandlung:** `zbus`-Operationen geben `zbus::Result` zurück. Fehler werden durch das `zbus::Error`-Enum repräsentiert, das verschiedene Fehlerquellen wie I/O-Fehler, ungültige Nachrichten oder Fehler vom D-Bus-Dienst selbst abdeckt.52
- **Server-Implementierung:** `zbus` ermöglicht auch die Implementierung von D-Bus-Diensten. Mittels `ConnectionBuilder::serve_at` können Interfaces auf bestimmten Objektpfaden bereitgestellt werden [13 (nicht zugänglich), 57 (nicht zugänglich), 12 (nicht zugänglich), 56 (nicht zugänglich), 57 (nicht zugänglich), 12 (nicht zugänglich), 60]. Das `ObjectServer`-API kann für komplexere Szenarien mit mehreren Objekten und Interfaces auf derselben Verbindung genutzt werden [48 (nicht zugänglich), 57 (nicht zugänglich), 12 (nicht zugänglich), 56 (nicht zugänglich), 57 (nicht zugänglich), 58 (nicht zugänglich), 60].

### 6.2. `org.freedesktop.secrets` – Sichere Speicherung von Geheimnissen

Das NovaDE-Projekt nutzt die `org.freedesktop.Secrets`-Schnittstelle für die sichere Speicherung und Verwaltung von sensiblen Daten wie Passwörtern oder API-Tokens, die von MCP-Komponenten benötigt werden.70

- **Schnittstellenspezifikation:** 70
    - **`org.freedesktop.Secrets.Service`:** Verwalter von Collections und Sessions.
        - Methoden: `OpenSession`, `CreateCollection`, `SearchCollections`, `RetrieveSecrets`, `LockService`, `DeleteCollection`.
        - Signale: `CollectionCreated`, `CollectionDeleted`.
        - Properties: `Collections` (RO), `DefaultCollection` (RW).
    - **`org.freedesktop.Secrets.Collection`:** Eine Sammlung von Items (Geheimnissen).
        - Methoden: `Delete`, `SearchItems`, `CreateItem`.
        - Signale: `CreatedItem`, `DeletedItem`.
        - Properties: `Items` (RO), `Private` (RO), `Label` (RW), `Locked` (RO), `Created` (RO), `Modified` (RO).
    - **`org.freedesktop.Secrets.Item`:** Ein einzelnes Geheimnis mit Attributen.
        - Methoden: `Delete`.
        - Signale: `changed`.
        - Properties: `Locked` (RO), `Attributes` (RW), `Label` (RW), `Secret` (RW), `Created` (RO), `Modified` (RO).
    - **`org.freedesktop.Secrets.Session`:** Repräsentiert eine Sitzung zwischen Client und Dienst.
        - Methoden: `Close`, `Negotiate`, `BeginAuthenticate`, `CompleteAuthenticate`.
        - Signale: `Authenticated`.
- **Datentyp `Secret`:** 70
    - `algorithm` (String): Algorithmus zur Kodierung des Geheimnisses (z.B. "PLAIN").
    - `parameters` (Array<Byte>): Algorithmus-spezifische Parameter.
    - `value` (Array<Byte>): Der möglicherweise kodierte Geheimniswert.
- **Fehlerdomäne:** `org.freedesktop.Secrets.Error.*` (z.B. `AlreadyExists`, `IsLocked`, `NotSupported`).70
- **Nutzung im NovaDE-Projekt für MCP:**
    - MCP-Server oder -Clients im NovaDE-Projekt, die Zugriff auf persistente, sichere Anmeldeinformationen oder Tokens benötigen, interagieren mit diesem Dienst.
    - Beispiel: Ein MCP-Server, der eine Verbindung zu einem externen API herstellt, könnte das API-Token sicher über `org.freedesktop.Secrets` speichern und abrufen.
    - Die `CreateCollection`-Methode wird verwendet, um spezifische Sammlungen für NovaDE-Komponenten anzulegen, potenziell mit `private = true`, um den Zugriff einzuschränken.
    - `SearchItems` mit spezifischen `Attributes` wird verwendet, um gezielt nach Geheimnissen zu suchen.
    - Die `Negotiate`-Methode kann für eine verschlüsselte Übertragung der Geheimnisse genutzt werden, falls erforderlich.

### 6.3. `org.freedesktop.PolicyKit1.Authority` – Berechtigungsprüfung

PolicyKit wird im NovaDE-Projekt eingesetzt, um granulare Berechtigungsprüfungen für Aktionen durchzuführen, die von MCP-Schnittstellen oder den dahinterliegenden Diensten ausgelöst werden.71

- **Schnittstellenspezifikation:** `org.freedesktop.PolicyKit1.Authority` am Pfad `/org/freedesktop/PolicyKit1/Authority`.71
    - **Methoden:**
        - `CheckAuthorization(IN Subject subject, IN String action_id, IN Dict<String,String> details, IN CheckAuthorizationFlags flags, IN String cancellation_id, OUT AuthorizationResult result)`: Prüft, ob ein Subjekt berechtigt ist, eine Aktion auszuführen. `details` können verwendet werden, um kontextspezifische Informationen für die Autorisierungsentscheidung oder die dem Benutzer angezeigte Nachricht bereitzustellen. `AllowUserInteraction` im `flags`-Parameter ermöglicht eine interaktive Authentifizierung.
        - `CancelCheckAuthorization(IN String cancellation_id)`: Bricht eine laufende Autorisierungsprüfung ab.
        - `EnumerateActions(IN String locale, OUT Array<ActionDescription> action_descriptions)`: Listet alle registrierten Aktionen auf.
        - `RegisterAuthenticationAgent(IN Subject subject, IN String locale, IN String object_path)`: Registriert einen Authentifizierungsagenten.
    - **Signale:**
        - `Changed()`: Wird emittiert, wenn sich Aktionen oder Autorisierungen ändern.
- **Wichtige Datenstrukturen:** 71
    - `Subject`: Beschreibt das handelnde Subjekt (z.B. `unix-process`, `unix-session`).
    - `ActionDescription`: Beschreibt eine registrierte Aktion (ID, Beschreibung, Nachricht, Standardberechtigungen).
    - `AuthorizationResult`: Ergebnis der Prüfung (`is_authorized`, `is_challenge`, `details`).
- **Nutzung im NovaDE-Projekt für MCP-Zugriffssteuerung:**
    - Bevor eine MCP-Methode eine potenziell privilegierte Operation ausführt (z.B. Systemkonfiguration ändern, auf geschützte Benutzerdaten zugreifen), muss der MCP-Server oder die aufgerufene NovaDE-Komponente `CheckAuthorization` aufrufen.
    - Die `action_id` entspricht einer vordefinierten Aktion im NovaDE-PolicyKit-Regelwerk (z.B. `org.novade.mcp.filesystem.writeFile`).
    - Die `details` können MCP-spezifische Parameter enthalten, die für die Entscheidung oder die Benutzerinteraktion relevant sind.
    - Das Ergebnis von `CheckAuthorization` bestimmt, ob die MCP-Operation fortgesetzt oder mit einem Berechtigungsfehler abgelehnt wird.

### 6.4. XDG Desktop Portals

XDG Desktop Portals bieten sandboxed Anwendungen (und auch nicht-sandboxed Anwendungen) einen standardisierten Weg, um mit der Desktop-Umgebung zu interagieren, z.B. für Dateiauswahl oder Screenshots.6 MCP-Schnittstellen im NovaDE-Projekt können diese Portale nutzen, um solche Interaktionen sicher und konsistent zu gestalten.

#### 6.4.1. `org.freedesktop.portal.FileChooser`

Wird verwendet, um dem Benutzer Dialoge zur Datei- oder Ordnerauswahl anzuzeigen.6

- **Methoden:** 73
    - `OpenFile(IN String parent_window, IN String title, IN Dict<String,Variant> options, OUT ObjectPath handle)`: Öffnet einen Dialog zur Auswahl einer oder mehrerer Dateien.
        - Optionen (`a{sv}`): `handle_token` (s), `accept_label` (s), `modal` (b), `multiple` (b), `directory` (b), `filters` (`a(sa(us))`), `current_filter` (`(sa(us))`), `choices` (`a(ssa(ss)s)`), `current_folder` (ay).
        - Antwort über `org.freedesktop.portal.Request::Response`: `uris` (as), `choices` (`a(ss)`), `current_filter` (`(sa(us))`).
    - `SaveFile(IN String parent_window, IN String title, IN Dict<String,Variant> options, OUT ObjectPath handle)`: Öffnet einen Dialog zum Speichern einer Datei.
        - Optionen (`a{sv}`): Ähnlich wie `OpenFile`, zusätzlich `current_name` (s), `current_file` (ay).
        - Antwort über `org.freedesktop.portal.Request::Response`: `uris` (as), `choices` (`a(ss)`), `current_filter` (`(sa(us))`).
    - `SaveFiles(IN String parent_window, IN String title, IN Dict<String,Variant> options, OUT ObjectPath handle)`: Öffnet einen Dialog zum Speichern mehrerer Dateien in einem Ordner.
        - Optionen (`a{sv}`): Ähnlich wie `SaveFile`, zusätzlich `files` (aay).
        - Antwort über `org.freedesktop.portal.Request::Response`: `uris` (as), `choices` (`a(ss)`).
- **Nutzung im NovaDE-Projekt:** MCP-Methoden, die Dateiinteraktionen erfordern (z.B. das Hochladen eines Dokuments durch den Benutzer, das Speichern von generierten Inhalten), rufen diese Portalmethoden auf. Die `parent_window`-Kennung muss korrekt übergeben werden. Die `options` werden basierend auf dem Kontext der MCP-Aktion befüllt (z.B. Dateifilter basierend auf erwarteten MIME-Typen der Domänenschicht).

#### 6.4.2. `org.freedesktop.portal.Screenshot`

Ermöglicht das Erstellen von Screenshots und das Auswählen von Pixelfarben.3

- **Methoden (Version 2):** 79
    - `Screenshot(IN String parent_window, IN Dict<String,Variant> options, OUT ObjectPath handle)`: Erstellt einen Screenshot.
        - Optionen (`a{sv}`): `handle_token` (s), `modal` (b, default: true), `interactive` (b, default: false, seit v2).
        - Antwort über `org.freedesktop.portal.Request::Response`: `uri` (s) des Screenshots.
    - `PickColor(IN String parent_window, IN Dict<String,Variant> options, OUT ObjectPath handle)`: Wählt die Farbe eines Pixels aus.
        - Optionen (`a{sv}`): `handle_token` (s).
        - Antwort über `org.freedesktop.portal.Request::Response`: `color` (`(ddd)`) als RGB-Werte .
- **Nutzung im NovaDE-Projekt:** MCP-Schnittstellen, die visuelle Informationen vom Desktop benötigen (z.B. ein Werkzeug zur Fehlerberichterstattung, das einen Screenshot anhängt, oder ein Design-Tool, das Farben vom Bildschirm aufnimmt), verwenden diese Portalmethoden.
- **Backend-Implementierung:** Für Wayland-basierte Desktops wie potenziell NovaDE ist eine Backend-Implementierung wie `xdg-desktop-portal-wlr` 6, `xdg-desktop-portal-gnome` 6, `xdg-desktop-portal-kde` 6 oder eine spezifische Implementierung wie `xdg-desktop-portal-luminous` (Rust-basiert, nutzt `libwayshot` und `zwlr_screencopy`) 83 erforderlich. `xdg-desktop-portal-luminous` ist ein Beispiel für eine Rust-basierte Implementierung, die `zbus` für D-Bus verwenden könnte und über das `zwlr_screencopy`-Protokoll mit wlroots-basierten Compositors interagiert.88

### 6.5. `org.freedesktop.login1` – Sitzungs- und Benutzerverwaltung

Der `systemd-logind`-Dienst stellt über D-Bus Informationen und Kontrollfunktionen für Benutzersitzungen, Benutzer und Seats bereit [90 (nicht zugänglich), 253 (nicht zugänglich), 254 (nicht zugänglich)]. MCP-Komponenten im NovaDE-Projekt können diese Schnittstelle nutzen, um kontextbezogene Informationen über den aktuellen Benutzer oder die Sitzung zu erhalten oder um sitzungsbezogene Aktionen auszulösen.

- **Manager-Interface (`org.freedesktop.login1.Manager` auf `/org/freedesktop/login1`):** 90
    - **Methoden:**
        - `GetSession(IN String session_id, OUT ObjectPath object_path)`
        - `GetUser(IN UInt32 uid, OUT ObjectPath object_path)`
        - `ListSessions(OUT Array<(String session_id, UInt32 user_id, String user_name, String seat_id, ObjectPath session_path)> sessions)`
        - `LockSession(IN String session_id)`
        - `UnlockSession(IN String session_id)`
    - **Signale:**
        - `SessionNew(String session_id, ObjectPath object_path)` 91
        - `SessionRemoved(String session_id, ObjectPath object_path)` 91
        - `PrepareForSleep(Boolean start)` 90
- **Session-Interface (`org.freedesktop.login1.Session` auf dem jeweiligen Session-Pfad):**
    - **Signale:**
        - `Lock()` [90 (nicht zugänglich)]
        - `Unlock()` [90 (nicht zugänglich)]
- **Nutzung im NovaDE-Projekt für MCP-Kontext:**
    - Abfrage der aktuellen Sitzungs-ID oder Benutzer-ID, um MCP-Aktionen zu personalisieren oder Berechtigungen feingranularer zu steuern.
    - Reaktion auf `PrepareForSleep`-Signale, um z.B. laufende MCP-Operationen zu pausieren oder Daten zu sichern.
    - Auslösen von `LockSession` durch eine MCP-Methode, um den Bildschirm zu sperren.

### 6.6. `org.freedesktop.UPower` – Energieverwaltung

UPower liefert Informationen über Energiequellen und deren Status.92 Dies kann für MCP-Komponenten relevant sein, die ihr Verhalten an den Energiestatus anpassen müssen.

- **UPower-Interface (`org.freedesktop.UPower` auf `/org/freedesktop/UPower`):** 93
    - **Methoden:**
        - `EnumerateDevices(OUT Array<ObjectPath> devices)`
        - `GetDisplayDevice(OUT ObjectPath device)`
        - `GetCriticalAction(OUT String action)`
    - **Signale:**
        - `DeviceAdded(ObjectPath device)` [93 (nicht zugänglich)]
        - `DeviceRemoved(ObjectPath device)` [93 (nicht zugänglich)]
        - `DeviceChanged(ObjectPath device)` (impliziert durch `PropertiesChanged` auf Device-Objekt)
    - **Properties:**
        - `DaemonVersion` (String, RO)
        - `OnBattery` (Boolean, RO)
        - `LidIsClosed` (Boolean, RO)
        - `LidIsPresent` (Boolean, RO)
- **Device-Interface (`org.freedesktop.UPower.Device` auf dem jeweiligen Gerätepfad):** 93
    - **Properties (Auswahl):**
        - `Type` (UInt32, z.B. Battery, UPS, LinePower)
        - `State` (UInt32, z.B. Charging, Discharging, FullyCharged)
        - `Percentage` (Double)
        - `TimeToEmpty` (Int64, Sekunden)
        - `TimeToFull` (Int64, Sekunden)
        - `IsPresent` (Boolean)
        - `IconName` (String)
        - `WarningLevel` (UInt32)
    - **Signale:**
        - `PropertiesChanged` (via `org.freedesktop.DBus.Properties`) [257 (nicht zugänglich)]
- **Nutzung im NovaDE-Projekt für MCP-Kontext:**
    - MCP-Werkzeuge könnten den Batteriestatus abfragen (`OnBattery`, `Percentage`, `TimeToEmpty`), um langlaufende Operationen zu vermeiden oder den Benutzer zu warnen.
    - Anpassung des Verhaltens von NovaDE-Komponenten basierend auf dem Energiestatus (z.B. Reduzierung der Hintergrundaktivität bei niedrigem Akkustand).

### 6.7. `org.freedesktop.Notifications` – Desktop-Benachrichtigungen

Diese Schnittstelle ermöglicht es Anwendungen, Desktop-Benachrichtigungen anzuzeigen.95 MCP-Komponenten im NovaDE-Projekt können dies nutzen, um Benutzer über wichtige Ereignisse, den Abschluss von Aufgaben oder Fehler zu informieren.

- **Schnittstellenspezifikation (`org.freedesktop.Notifications` auf `/org/freedesktop/Notifications`):** 96
    - **Methoden:**
        - `Notify(IN String app_name, IN UInt32 replaces_id, IN String app_icon, IN String summary, IN String body, IN Array<String> actions, IN Dict<String,Variant> hints, IN Int32 expire_timeout, OUT UInt32 notification_id)`
        - `CloseNotification(IN UInt32 id)`
        - `GetCapabilities(OUT Array<String> capabilities)`
        - `GetServerInformation(OUT String name, OUT String vendor, OUT String version, OUT String spec_version)`
    - **Signale:**
        - `NotificationClosed(UInt32 id, UInt32 reason)`
        - `ActionInvoked(UInt32 id, String action_key)`
- **Wichtige Parameter und Hinweise:**
    - `actions`: Liste von Aktions-IDs und deren lesbaren Bezeichnungen.
    - `hints`: Diktionär für zusätzliche Hinweise (z.B. `urgency`, `sound-file`, `image-data`).
    - `expire_timeout`: `-1` für Server-Default, `0` für niemals auslaufend.
- **Nutzung im NovaDE-Projekt durch MCP:**
    - Ein MCP-Tool, das eine langlaufende Aufgabe abschließt, kann `Notify` aufrufen, um den Benutzer zu informieren.
    - Fehler, die in MCP-Operationen auftreten und Benutzereingriffe erfordern, können als Benachrichtigungen signalisiert werden.
    - Aktionen in Benachrichtigungen (`actions`-Parameter) können mit spezifischen MCP-Folgeaktionen im NovaDE-Client verknüpft werden.

## 7. Interaktion mit Wayland (Smithay)

Falls das NovaDE-Projekt einen eigenen Wayland-Compositor beinhaltet oder tief mit einem solchen interagiert (z.B. für spezifische Desktop-Umgebungsfeatures), kommt das Smithay-Framework zum Einsatz.10 Smithay ist eine Rust-Bibliothek zum Erstellen von Wayland-Compositoren.

### 7.1. Smithay Architekturüberblick

Smithay bietet Bausteine für Wayland-Compositoren und ist modular aufgebaut.10

- **Display und EventLoop:** Das Herzstück ist der `Display`-Typ (aus `wayland-server`) und ein `calloop::EventLoop`.98 `DisplayHandle` wird für Interaktionen mit dem Wayland-Protokoll verwendet [214 (nicht zugänglich)]. Der `EventLoopHandle` von `calloop` dient zur Verwaltung von Event-Quellen.234
- **State Management:** Ein zentraler `State`-Typ (z.B. `AnvilState` im Smithay-Beispielcompositor Anvil) hält den Zustand des Compositors [258 (nicht zugänglich), 124 (nicht zugänglich), 124 (nicht zugänglich), 98 (nicht zugänglich), 261 (nicht zugänglich), 262 (nicht zugänglich), 170 (nicht zugänglich)]. `ClientData` (oder `UserDataMap` auf Ressourcen) wird verwendet, um client-spezifischen Zustand zu speichern [98 (nicht zugänglich)].
- **Handler und Delegation:** Für verschiedene Wayland-Protokolle und -Objekte implementiert der `State`-Typ spezifische Handler-Traits (z.B. `CompositorHandler`, `ShmHandler`, `OutputHandler`, `SeatHandler`, `DataDeviceHandler`, `XdgShellHandler`, etc.). Smithay verwendet `delegate_<protocol>!` Makros, um die Dispatch-Logik zu vereinfachen [98 (nicht zugänglich), 136 (nicht zugänglich), 201 (nicht zugänglich), 205 (nicht zugänglich), 200 (nicht zugänglich), 200 (nicht zugänglich), 145 (nicht zugänglich), 222 (nicht zugänglich), 222 (nicht zugänglich), 200 (nicht zugänglich)].

### 7.2. Wayland Core Protokolle und ihre Handhabung durch MCP

#### 7.2.1. `wl_compositor`, `wl_subcompositor`, `wl_surface`, `wl_buffer`

Diese sind grundlegend für jede Wayland-Anzeige.

- **`CompositorState` und `CompositorHandler`:** Smithay stellt `CompositorState` zur Verwaltung von `wl_surface`-Objekten und deren Hierarchien (Subsurfaces) bereit.235 Der `CompositorHandler` im NovaDE-State muss implementiert werden, um auf Surface-Commits und -Zerstörungen zu reagieren.134 `SurfaceData` [263 (nicht zugänglich)] und `CompositorClientState` [201 (nicht zugänglich)] speichern oberflächen- bzw. clientbezogene Zustände. `SurfaceAttributes` enthalten Informationen wie die zugewiesene Rolle [123 (nicht zugänglich)].
- **`wl_buffer`:** Repräsentiert den Inhalt einer Surface. `BufferHandler` [145 (nicht zugänglich)] wird implementiert, um auf die Zerstörung von Buffern zu reagieren.
- **MCP-Interaktion:** MCP-Komponenten könnten indirekt mit diesen Objekten interagieren, z.B. wenn eine MCP-gesteuerte Anwendung eine UI auf dem Desktop darstellt. Die Spezifikation von Fenstergeometrien oder das Anfordern von Neuzeichnungen könnte über MCP-Methoden erfolgen, die dann auf die entsprechenden `wl_surface`-Operationen abgebildet werden.

#### 7.2.2. `wl_shm` – Shared Memory Buffers

Ermöglicht Clients, Buffer über Shared Memory bereitzustellen.

- **`ShmState` und `ShmHandler`:** `ShmState` verwaltet den `wl_shm`-Global und die unterstützten Formate. Der `ShmHandler` im NovaDE-State stellt den Zugriff auf `ShmState` sicher.136
- **Buffer-Import und Rendering:** `with_buffer_contents` erlaubt den Zugriff auf SHM-Buffer-Daten.145 Renderer wie `GlesRenderer` können SHM-Buffer importieren (`import_shm_buffer`) und rendern.171 MCP-Aktionen, die die Anzeige von Inhalten erfordern, die von einem Client als SHM-Buffer bereitgestellt werden, nutzen diese Mechanismen.

#### 7.2.3. `wl_output` und `xdg-output` – Output Management

Verwaltung von Bildschirmausgaben.

- **`Output` und `OutputHandler`:** Ein `Output`-Objekt repräsentiert eine physische Anzeige. `Output::new()` erstellt ein Output-Objekt, `Output::create_global()` macht es für Clients sichtbar [137 (nicht zugänglich), 137]. `Output::change_current_state()` aktualisiert Modus, Transformation, Skalierung und Position. Der `OutputHandler` im NovaDE-State behandelt clientseitige Interaktionen.101
- **`OutputManagerState`:** Kann verwendet werden, um `xdg-output` zusätzlich zu `wl_output` zu verwalten [137 (nicht zugänglich)].
- **MCP-Interaktion:** MCP-Methoden könnten es ermöglichen, Informationen über verfügbare Ausgaben abzurufen oder anwendungsspezifische Fenster auf bestimmten Ausgaben zu positionieren, basierend auf den von diesen Modulen bereitgestellten Informationen.

#### 7.2.4. `wl_seat`, `wl_keyboard`, `wl_pointer`, `wl_touch` – Input Handling

Verwaltung von Eingabegeräten und Fokus.

- **`SeatState` und `SeatHandler`:** `SeatState` verwaltet einen oder mehrere `Seat`-Instanzen. Der `SeatHandler` im NovaDE-State definiert, wie auf Eingabeereignisse und Fokusänderungen reagiert wird.113
- **Fokus-Management:** `KeyboardFocus`, `PointerFocus`, `TouchFocus` werden typischerweise auf `WlSurface` gesetzt, um den Eingabefokus zu lenken.113
- **Input Grabs:** Mechanismen wie `PointerGrab` und `KeyboardGrab` ermöglichen es, Eingabeereignisse exklusiv für eine bestimmte Oberfläche oder Aktion abzufangen [187 (nicht zugänglich)].
- **MCP-Interaktion:** MCP-gesteuerte Aktionen könnten den Fokus anfordern oder auf Eingabeereignisse reagieren, die über diese Seat-Abstraktionen verarbeitet werden. Beispielsweise könnte ein MCP-Tool eine Texteingabe erfordern, was das Setzen des Tastaturfokus auf ein entsprechendes Eingabefeld des MCP-Clients zur Folge hätte.

#### 7.2.5. `wl_data_

# Eine explizit spezifizierte MCP-Infrastruktur zur Widget-Integration für vereinfachte Linux-Interaktionen

## 1. Einführung

Der Übergang von Betriebssystemen wie Windows oder macOS zu Linux kann für Benutzer eine Herausforderung darstellen, insbesondere hinsichtlich der Interaktion mit Systemfunktionen, die sich oft hinter Kommandozeilen-Tools oder komplexen grafischen Oberflächen verbergen. Eine Möglichkeit, diese Umstellung erheblich zu vereinfachen, ist die Integration intuitiver Desktop-Widgets, die direkten Zugriff auf häufig genutzte Systemaktionen und -informationen bieten. Um eine robuste, standardisierte und erweiterbare Grundlage für solche Widgets zu schaffen, schlägt dieser Bericht die Implementierung einer Infrastruktur vor, die auf dem **Model Context Protocol (MCP)** basiert.

MCP ist ein offenes Protokoll, das ursprünglich von Anthropic entwickelt wurde, um die Integration zwischen Anwendungen für große Sprachmodelle (LLMs) und externen Datenquellen sowie Werkzeugen zu standardisieren.1 Es adressiert das sogenannte „M×N-Integrationsproblem“, bei dem M verschiedene Anwendungen (in unserem Fall Widgets oder die Desktop-Umgebung) mit N verschiedenen Systemfunktionen oder Datenquellen interagieren müssen.5 Anstatt M×N individuelle Integrationen zu erstellen, ermöglicht MCP die Entwicklung von M Clients und N Servern, die über ein standardisiertes Protokoll kommunizieren, wodurch die Komplexität auf M+N reduziert wird.5

Obwohl MCP ursprünglich für LLM-Anwendungen konzipiert wurde, eignet sich seine flexible Client-Server-Architektur und sein Fokus auf standardisierte Schnittstellen hervorragend für die Abstraktion von Linux-Systeminteraktionen. Durch die Definition spezifischer MCP-Server, die als Adapter für zugrunde liegende Linux-Mechanismen (wie D-Bus, Kommandozeilen-Tools und Freedesktop-Standards) fungieren, können Widgets (als MCP-Clients) Systemfunktionen auf eine Weise nutzen, die für Benutzer von Windows und macOS intuitiv und verständlich ist. Dieser Bericht legt eine explizite Architektur und Spezifikation für eine solche MCP-basierte Infrastruktur dar, die darauf abzielt, die Benutzerfreundlichkeit von Linux-Desktops für Umsteiger drastisch zu verbessern.

## 2. Grundlagen des Model Context Protocol (MCP)

Um die vorgeschlagene Infrastruktur zu verstehen, ist ein grundlegendes Verständnis der Kernkomponenten und Konzepte von MCP erforderlich. MCP definiert eine standardisierte Methode für die Kommunikation zwischen Anwendungen (Hosts), die Kontext benötigen, und Diensten (Servern), die diesen Kontext oder zugehörige Funktionen bereitstellen.1

### 2.1 Kernarchitektur: Host, Client und Server

MCP basiert auf einer Client-Server-Architektur mit drei Hauptkomponenten 3:

1. **Host:** Die Anwendung, die die Interaktion initiiert und den Kontext oder die Funktionalität benötigt. Im Kontext dieses Berichts ist der Host typischerweise die Desktop-Umgebung oder eine übergeordnete Widget-Verwaltungskomponente, die die Widgets selbst enthält und deren Kommunikation koordiniert.
2. **Client:** Eine Komponente, die innerhalb des Hosts läuft und eine dedizierte 1:1-Verbindung zu einem bestimmten MCP-Server aufbaut und verwaltet.3 Das Widget selbst oder eine vom Host bereitgestellte Abstraktionsschicht fungiert als Client.
3. **Server:** Ein (oft leichtgewichtiger) Prozess, der spezifische Fähigkeiten (Daten, Aktionen, Vorlagen) über das MCP-Protokoll bereitstellt.1 Im vorgeschlagenen Szenario kapseln diese Server spezifische Linux-Systemfunktionen (z. B. Netzwerkverwaltung, Energieoptionen, Dateisuche).

Diese Architektur ermöglicht eine klare Trennung von Belangen: Widgets (Clients) müssen nur das standardisierte MCP-Protokoll verstehen, während die Server die Komplexität der Interaktion mit den spezifischen Linux-Subsystemen kapseln.1

### 2.2 MCP-Primitive: Bausteine der Interaktion

Die Kommunikation und die Fähigkeiten innerhalb von MCP werden durch sogenannte _Primitive_ definiert. Diese legen fest, welche Arten von Interaktionen zwischen Client und Server möglich sind.5

**Server-seitige Primitive** (vom Server dem Client angeboten):

- **Tools:** Repräsentieren ausführbare Funktionen oder Aktionen, die der Client (im Auftrag des Benutzers oder einer KI) auf dem Server aufrufen kann.3 Beispiele im Desktop-Kontext wären das Umschalten von WLAN, das Ändern der Lautstärke oder das Herunterfahren des Systems. Tools können Parameter entgegennehmen und Ergebnisse zurückgeben. Sie sind typischerweise _modellgesteuert_ (im ursprünglichen MCP-Kontext) oder _widget-gesteuert_ (in unserem Kontext), da die Aktion vom Client initiiert wird.
- **Resources:** Stellen Daten oder Inhalte dar, die der Client vom Server lesen kann, um sie anzuzeigen oder als Kontext zu verwenden.3 Beispiele wären der aktuelle Batteriestatus, der Name des verbundenen WLAN-Netzwerks oder eine Liste kürzlich verwendeter Dateien. Ressourcen sind in der Regel schreibgeschützt aus Sicht des Clients und _anwendungsgesteuert_, d. h., die Host-Anwendung entscheidet, wann und wie sie verwendet werden.31
- **Prompts:** Sind vordefinierte Vorlagen oder Arbeitsabläufe, die vom Server bereitgestellt werden, um komplexe Interaktionen zu strukturieren oder zu vereinfachen.3 Im Widget-Kontext könnten sie weniger relevant sein, aber potenziell für geführte Konfigurationsdialoge genutzt werden, die von einem Widget ausgelöst werden. Sie sind typischerweise _benutzergesteuert_.31

**Client-seitige Primitive** (vom Client dem Server angeboten):

- **Roots:** Repräsentieren Einstiegspunkte oder definierte Bereiche im Dateisystem oder der Umgebung des Hosts, auf die der Server zugreifen darf, wenn die Berechtigung erteilt wird.5 Dies ist relevant für MCP-Server, die mit lokalen Dateien interagieren müssen (z. B. ein Dateisuche-Server).
- **Sampling:** Ermöglicht es dem Server, eine Anfrage zur Generierung von Inhalten (z. B. Text) durch ein LLM auf der Client-Seite zu stellen.3 Für die primäre Widget-Integration ist dies weniger relevant, könnte aber für zukünftige, KI-gestützte Widgets von Bedeutung sein. Anthropic betont die Notwendigkeit einer menschlichen Genehmigung für Sampling-Anfragen.5

Für die hier beschriebene Desktop-Widget-Infrastruktur sind **Tools** und **Resources** die wichtigsten serverseitigen Primitive, während **Roots** für dateibezogene Server relevant sind.

### 2.3 Ökosystem und Standardisierung

MCP wird als offener Standard entwickelt, unterstützt durch SDKs in verschiedenen Sprachen (Python, TypeScript, Java, C#, Kotlin, Rust, Swift) und eine wachsende Community.1 Es gibt bereits zahlreiche Open-Source-MCP-Server für gängige Dienste wie Google Drive, Slack, GitHub, Datenbanken und Betriebssysteminteraktionen.1 Frühe Anwender wie Block und Apollo haben MCP bereits in ihre Systeme integriert.1 Diese Standardisierung und das wachsende Ökosystem sind entscheidend für die Schaffung einer interoperablen und zukunftssicheren Infrastruktur für Desktop-Widgets.

## 3. Kernarchitektur und Kommunikation der MCP-Infrastruktur

Aufbauend auf den MCP-Grundlagen wird nun die spezifische Architektur für die Integration von Desktop-Widgets in Linux-Systemen detailliert beschrieben. Diese Architektur legt fest, wie Widgets (als Clients) über das MCP-Protokoll mit spezialisierten Servern kommunizieren, die Systemfunktionen kapseln.

### 3.1 Detaillierte Host-Client-Server-Interaktionen am Beispiel eines Widgets

Betrachten wir einen typischen Interaktionsfluss, ausgelöst durch ein Widget, z. B. ein "WLAN umschalten"-Widget:

1. **Benutzeraktion:** Der Benutzer klickt auf das Widget, um WLAN zu aktivieren.
2. **Host-Übersetzung:** Der Host (die Desktop-Umgebung oder Widget-Verwaltung) empfängt das Klick-Ereignis und identifiziert den zuständigen MCP-Server (z. B. den Netzwerk-MCP-Server). Der Host weist den entsprechenden MCP-Client an, eine Aktion auszuführen.
3. **MCP-Anfrage (Client -> Server):** Der Client formuliert eine MCP `tools/call`-Anfrage. Diese wird als JSON-RPC 2.0-Nachricht über den gewählten Transportkanal gesendet.
    - Beispiel JSON-RPC-Anfrage (vereinfacht):
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "id": 123,
          "method": "tools/call",
          "params": {
            "tool_name": "network.setWifiEnabled",
            "parameters": { "enabled": true }
          }
        }
        ```
        
4. **Server-Verarbeitung:** Der Netzwerk-MCP-Server empfängt die JSON-RPC-Nachricht über den Transportkanal (z. B. STDIO). Er parst die Anfrage, validiert die Parameter und identifiziert die angeforderte Aktion (`network.setWifiEnabled`).
5. **Systeminteraktion (Server -> D-Bus):** Der Server übersetzt die MCP-Anfrage in einen entsprechenden Aufruf an das zugrunde liegende Linux-System, in diesem Fall wahrscheinlich über D-Bus an den NetworkManager-Dienst.63 Er könnte beispielsweise eine Methode wie `ActivateConnection` oder eine gerätespezifische Methode aufrufen, um das WLAN-Gerät zu aktivieren.
6. **Systemantwort (D-Bus -> Server):** Der NetworkManager führt die Aktion aus und sendet eine Antwort (Erfolg oder Fehler) über D-Bus zurück an den MCP-Server.
7. **MCP-Antwort (Server -> Client):** Der MCP-Server empfängt die D-Bus-Antwort, formatiert sie als JSON-RPC 2.0-Antwortnachricht und sendet sie über den Transportkanal zurück an den Client.
    - Beispiel JSON-RPC-Antwort (Erfolg, vereinfacht):
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "id": 123,
          "result": { "output": { "success": true } }
        }
        ```
        
8. **Client-Verarbeitung:** Der Client empfängt die Antwort und leitet das Ergebnis an den Host weiter.
9. **Host-Aktualisierung:** Der Host aktualisiert den Zustand des Widgets, um den neuen WLAN-Status widerzuspiegeln (z. B. Änderung des Icons, Anzeige des verbundenen Netzwerks).

Dieser Ablauf demonstriert, wie MCP als standardisierte Zwischenschicht fungiert, die die Komplexität der direkten Systeminteraktion vor dem Widget verbirgt.

### 3.2 JSON-RPC 2.0 Nachrichtenstruktur

Die gesamte Kommunikation innerhalb der MCP-Infrastruktur basiert auf dem JSON-RPC 2.0-Protokoll.5 Dies gewährleistet eine klare, strukturierte und sprachunabhängige Nachrichtenübermittlung.

Die grundlegenden Nachrichtentypen sind 70:

- **Request:** Wird gesendet, um eine Methode auf der Gegenseite aufzurufen (z. B. `tools/call`, `resources/read`). Enthält `jsonrpc`, `id`, `method` und `params`.
- **Response:** Die Antwort auf eine Request-Nachricht. Enthält `jsonrpc`, die `id` der ursprünglichen Anfrage und entweder ein `result`-Objekt (bei Erfolg) oder ein `error`-Objekt.
- **Notification:** Eine einseitige Nachricht, die keine Antwort erwartet (z. B. `initialized`, `notifications/resources/updated`). Enthält `jsonrpc` und `method`, optional `params`, aber keine `id`.

Der Verbindungsaufbau beginnt mit einem **Handshake**, bei dem Client und Server Informationen über ihre unterstützten Protokollversionen und Fähigkeiten austauschen 6:

1. **Client -> Server:** `initialize` (Request) mit Client-Infos und -Fähigkeiten.
2. **Server -> Client:** `initialize` (Response) mit Server-Infos und -Fähigkeiten.
3. **Client -> Server:** `initialized` (Notification) zur Bestätigung des erfolgreichen Handshakes.

Danach kann der reguläre Austausch von Nachrichten beginnen. Die genauen JSON-Strukturen für spezifische MCP-Methoden wie `tools/list`, `tools/call`, `resources/list`, `resources/read` (`getResourceData` im Schema) usw. sind im offiziellen MCP JSON-Schema definiert.70

### 3.3 Überlegungen zur Transportschicht: STDIO als primäre Wahl

MCP unterstützt nativ zwei Haupttransportmechanismen für die JSON-RPC-Nachrichten 3:

1. **Standard Input/Output (STDIO):** Die Kommunikation erfolgt über die Standard-Eingabe- und Ausgabe-Streams zwischen dem Host-Prozess (der den Client enthält) und dem Server-Prozess. Der Host startet und verwaltet den Server-Prozess direkt.
2. **HTTP mit Server-Sent Events (SSE):** Die Kommunikation erfolgt über das Netzwerk. Der Client sendet Anfragen per HTTP POST, während der Server Nachrichten (insbesondere Notifications) über eine persistente SSE-Verbindung an den Client sendet.

Für die vorgeschlagene lokale Desktop-Widget-Integration ist **STDIO die empfohlene primäre Transportschicht**.3 Die Gründe hierfür sind:

- **Effizienz:** Direkte Prozesskommunikation auf derselben Maschine ist in der Regel performanter als Netzwerkkommunikation.
- **Einfachheit:** Es entfallen die Komplexitäten der Netzwerkkonfiguration, Port-Verwaltung und komplexer Authentifizierungsschemata, die bei SSE auftreten können. Der Host kann die Server-Prozesse einfach starten und über Pipes kommunizieren.
- **Sicherheit:** Die Kommunikation bleibt lokal auf der Maschine beschränkt, was das Risiko von Netzwerkangriffen wie DNS-Rebinding (ein spezifisches Risiko bei SSE 69) eliminiert. Die Sicherheit konzentriert sich auf die Kontrolle der gestarteten Server-Prozesse durch den Host.

Der Host wäre dafür verantwortlich, die benötigten MCP-Server-Prozesse (z. B. beim Systemstart oder bei Bedarf) zu starten und deren Lebenszyklus zu verwalten. Die Kommunikation über `stdin` und `stdout` der Server-Prozesse ist ein etabliertes Muster für lokale Interprozesskommunikation.

**HTTP+SSE** bleibt eine Option für zukünftige Erweiterungen, beispielsweise wenn Widgets Fernsteuerungsfunktionen ermöglichen oder auf Cloud-Dienste zugreifen sollen. Die Architektur sollte idealerweise so gestaltet sein, dass die Kernlogik der MCP-Server von der Transportschicht getrennt ist, um einen späteren Wechsel oder eine parallele Unterstützung von SSE zu erleichtern. Die Implementierung von SSE würde jedoch zusätzliche Sicherheitsüberlegungen erfordern, insbesondere robuste Authentifizierungs- und Autorisierungsmechanismen.28

### 3.4 Verwaltung des Verbindungslebenszyklus

Der MCP Host spielt eine zentrale Rolle bei der Verwaltung des Lebenszyklus jeder Client-Server-Verbindung.6 Dies umfasst die drei Hauptphasen:

1. **Initialisierung:** Der Host startet den MCP-Server-Prozess (bei STDIO) und initiiert über den Client den Handshake (`initialize`/`initialized`) zur Aushandlung von Protokollversionen und Fähigkeiten.
2. **Nachrichtenaustausch:** Der Host leitet Benutzeraktionen aus Widgets an den Client weiter, der daraus Requests an den Server generiert. Eingehende Responses und Notifications vom Server werden vom Client empfangen und an den Host zur Aktualisierung der Widgets oder zur weiteren Verarbeitung weitergeleitet.
3. **Terminierung:** Der Host ist dafür verantwortlich, die Verbindung sauber zu beenden, wenn das Widget geschlossen wird oder der Server nicht mehr benötigt wird. Dies kann durch ein explizites `shutdown`-Signal oder durch Beenden des Server-Prozesses geschehen. Fehlerbedingungen oder unerwartete Trennungen der Transportverbindung (z. B. Absturz des Server-Prozesses) müssen ebenfalls vom Host gehandhabt werden.

Eine robuste Verwaltung des Lebenszyklus durch den Host ist entscheidend für die Stabilität und Ressourceneffizienz der gesamten Infrastruktur.

## 4. Brückenschlag zwischen MCP und Linux-Desktop-Mechanismen

Das Herzstück der vorgeschlagenen Infrastruktur sind die MCP-Server, die als Adapter zwischen der standardisierten MCP-Welt und den vielfältigen Mechanismen des Linux-Desktops fungieren. Sie empfangen generische MCP-Anfragen und übersetzen diese in spezifische Aufrufe an D-Bus, Kommandozeilen-Tools oder andere relevante Schnittstellen.

### 4.1 Strategie für die Interaktion von MCP-Servern

Die Kernstrategie besteht darin, für jede logische Gruppe von Systemfunktionen (Netzwerk, Energie, Einstellungen, Dateien usw.) einen dedizierten MCP-Server zu erstellen. Jeder Server implementiert die MCP-Spezifikation und kapselt die Logik für die Interaktion mit dem entsprechenden Linux-Subsystem. Widgets kommunizieren ausschließlich über MCP mit diesen Servern und bleiben somit von den Implementierungsdetails der Linux-Seite isoliert.

### 4.2 Schnittstelle zu D-Bus

D-Bus ist der _de facto_ Standard für die Interprozesskommunikation (IPC) auf modernen Linux-Desktops und bietet Zugriff auf eine Vielzahl von Systemdiensten.72 MCP-Server können D-Bus nutzen, um Systemzustände abzufragen und Aktionen auszulösen.

Ein typischer MCP-Server (z. B. in Python geschrieben, unter Verwendung von Bibliotheken wie `dasbus` 73 oder `pydbus` 74) würde folgende Schritte ausführen:

1. **Verbindung zum Bus:** Aufbau einer Verbindung zum entsprechenden Bus – dem **System Bus** für systemweite Dienste (wie NetworkManager, logind, UPower) oder dem **Session Bus** für benutzerspezifische Dienste (wie Benachrichtigungen, anwendungsspezifische Schnittstellen).72
2. **Proxy-Objekt erhalten:** Anfordern eines Proxy-Objekts für einen bestimmten Dienst (über dessen wohlbekannten Busnamen, z. B. `org.freedesktop.NetworkManager`) und Objektpfad (z. B. `/org/freedesktop/NetworkManager/Devices/0`).65
3. **Methodenaufruf:** Aufrufen von Methoden auf der D-Bus-Schnittstelle des Proxy-Objekts basierend auf der empfangenen MCP `tools/call`-Anfrage. Zum Beispiel würde eine MCP-Anfrage `network.disconnectWifi` zu einem D-Bus-Aufruf wie `proxy.Disconnect()` auf der `org.freedesktop.NetworkManager.Device`-Schnittstelle führen.65
4. **Signal-Überwachung (optional):** Registrieren für D-Bus-Signale (z. B. `StateChanged` von NetworkManager 64 oder `PrepareForShutdown` von logind 81), um auf Systemänderungen zu reagieren. Diese Signale könnten dann als MCP-Notifications an den Client weitergeleitet werden, um Widgets proaktiv zu aktualisieren.72

Zahlreiche Beispiele und Tutorials für die D-Bus-Interaktion mit Python sind verfügbar und können als Grundlage für die Serverentwicklung dienen.63

### 4.3 Nutzung von Kommandozeilen-Tools (CLIs)

Für Aufgaben, die nicht direkt oder einfach über D-Bus zugänglich sind, können MCP-Server als Wrapper für Kommandozeilen-Tools fungieren.

- **Dateisuche:** Ein MCP-Server könnte das `plocate`-Kommando nutzen, um schnelle Dateisuchen durchzuführen.59 Ein MCP-Tool `filesystem.searchFiles` würde die Suchanfrage des Benutzers als Parameter entgegennehmen, `plocate <query>` ausführen und die formatierte Ausgabe als Ergebnis zurückgeben. Bestehende MCP-Server wie `Lilith-Shell` oder `Terminal-Control` demonstrieren bereits die Ausführung von Shell-Befehlen.46
- **Systemeinstellungen:** Das `gsettings`-Tool ermöglicht das Lesen und Schreiben von Konfigurationseinstellungen, die von vielen GNOME-basierten Anwendungen und der Desktop-Umgebung selbst verwendet werden.91 Ein MCP-Tool `settings.setGSetting` könnte Schema, Schlüssel und Wert als Parameter akzeptieren und den entsprechenden `gsettings set <schema> <key> <value>`-Befehl ausführen.

Beim Kapseln von CLIs ist äußerste Vorsicht geboten. MCP-Server **müssen** alle Eingaben, die zur Konstruktion von Kommandozeilenbefehlen verwendet werden, sorgfältig validieren und bereinigen (sanitizing), um Command-Injection-Schwachstellen zu verhindern.27

### 4.4 Schnittstelle zu Freedesktop-Standards

MCP-Server können auch mit etablierten Freedesktop.org-Standards interagieren:

- **Desktop-Einträge (`.desktop`-Dateien):** Diese Dateien beschreiben installierte Anwendungen und deren Startverhalten gemäß der Desktop Entry Specification.97 Ein MCP-Server könnte diese Dateien parsen (unter Verwendung von Bibliotheken wie `freedesktop-file-parser` 98 oder `freedesktop-desktop-entry` 100 für Rust, oder entsprechenden Bibliotheken für andere Sprachen 101), um eine Liste installierter Anwendungen als MCP `Resource` bereitzustellen oder das Starten einer Anwendung über ein MCP `Tool` zu ermöglichen (z. B. durch Ausführen von `gtk-launch <app.desktop>` oder über D-Bus-Aktivierung).
- **Benachrichtigungen:** Das Senden von Desktop-Benachrichtigungen erfolgt standardmäßig über die `org.freedesktop.Notifications`-D-Bus-Schnittstelle.75 Ein MCP-Server könnte ein einfaches `notifications.send`-Tool bereitstellen, das Titel, Text und optional ein Icon entgegennimmt und an den D-Bus-Dienst weiterleitet.

### 4.5 Tabelle: Zuordnung von Desktop-Aufgaben zu Linux-Mechanismen

Um die Implementierung der MCP-Server zu erleichtern, bietet die folgende Tabelle eine Zuordnung gängiger Desktop-Aufgaben, die für Umsteiger relevant sind, zu den primären zugrunde liegenden Linux-Mechanismen und spezifischen Schnittstellen oder Befehlen. Diese Zuordnung dient als Blaupause für die Entwicklung der Server-Logik.

|   |   |   |
|---|---|---|
|**Gängige Aufgabe für Umsteiger**|**Primärer Linux-Mechanismus**|**Spezifische Schnittstelle / Befehl / Datei (Beispiele)**|
|WLAN ein-/ausschalten|D-Bus: NetworkManager|`org.freedesktop.NetworkManager.Device` Methoden (z.B. `Disconnect`, `ActivateConnection`) 64|
|Mit WLAN verbinden|D-Bus: NetworkManager|`org.freedesktop.NetworkManager.ActivateConnection` 65|
|Lautstärke ändern|D-Bus: PulseAudio/PipeWire/DE|DE-spezifisch (z.B. `org.gnome.settings-daemon.plugins.media-keys.volume-up`) oder Audio-Server API|
|Display-Helligkeit ändern|D-Bus: UPower/logind/DE|DE-spezifisch oder `org.freedesktop.login1.Manager` (Backlight API)|
|Dunkelmodus umschalten|`gsettings` / DE-spezifisch D-Bus|`gsettings set org.gnome.desktop.interface color-scheme 'prefer-dark'` 91|
|Hintergrundbild ändern|`gsettings` / DE-spezifisch D-Bus|`gsettings set org.gnome.desktop.background picture-uri 'file:///...'` 91|
|Datei suchen|CLI: `plocate`|`plocate <pattern>` 86|
|Anwendung starten|`.desktop` / D-Bus Activation|`gtk-launch <app.desktop>` oder `org.freedesktop.Application.Activate`|
|Installierte Apps auflisten|`.desktop` Parsing|Parsen von `.desktop`-Dateien in Standardverzeichnissen 97|
|Batteriestatus prüfen|D-Bus: UPower / `sysfs`|`org.freedesktop.UPower.Device.Percentage`, `...State`|
|Bildschirm sperren|D-Bus: Session Lock / DE|DE-spezifisch (z.B. `org.gnome.ScreenSaver.Lock`) oder `loginctl lock-session`|
|Herunterfahren / Neustarten|D-Bus: logind|`org.freedesktop.login1.Manager.PowerOff`, `...Reboot` 81|
|Ruhezustand / Standby|D-Bus: logind|`org.freedesktop.login1.Manager.Suspend`, `...Hibernate` 81|

Diese Tabelle verdeutlicht, dass für die meisten gängigen Desktop-Interaktionen etablierte Linux-Mechanismen existieren, die von den MCP-Servern gekapselt werden können. Die Herausforderung für Entwickler besteht darin, die spezifischen D-Bus-Schnittstellen oder Kommandozeilenbefehle zu identifizieren und korrekt in den MCP-Servern zu implementieren. Die Tabelle dient hierbei als wertvolle Referenz und stellt sicher, dass die richtigen APIs angesprochen werden, was die Entwicklungszeit verkürzt und die Korrektheit der Implementierung fördert.

## 5. Gestaltung von MCP-Servern für die Bedürfnisse von Windows/Mac-Umsteigern

Ein zentrales Ziel dieser Infrastruktur ist es, die Interaktion für Benutzer zu vereinfachen, die von Windows oder macOS kommen. Dies erfordert ein durchdachtes Design der MCP-Server und der von ihnen bereitgestellten Schnittstellen (Tools und Resources).

### 5.1 Definition von MCP-Primitiven für Desktop-Aktionen

Die MCP-Primitive müssen so eingesetzt werden, dass sie den Interaktionen in Desktop-Widgets entsprechen 3:

- **Tools:** Werden primär für **Aktionen** verwendet, die durch Widget-Interaktionen wie Klicks, Umschalter oder Schieberegler ausgelöst werden.
    - _Beispiele:_ `network.setWifiEnabled(enabled: boolean)`, `audio.setVolume(level: integer)`, `power.shutdown()`, `files.moveToTrash(path: string)`.
    - Die Parameter für Tools sollten einfach, typisiert und intuitiv verständlich sein. Komplexe Konfigurationsobjekte sollten vermieden werden.
- **Resources:** Dienen dazu, System**zustände** oder **Daten** für die Anzeige in Widgets bereitzustellen.
    - _Beispiele:_ `network.getWifiState() -> {enabled: boolean, ssid: string, strength: integer}`, `power.getBatteryStatus() -> {level: integer, charging: boolean}`, `filesystem.listFiles(directory: string) -> list<object>`.
    - Ressourcen sollten aus Sicht des Clients schreibgeschützt sein.31 Änderungen erfolgen über Tools. Sie können optional Abonnementmechanismen unterstützen, um den Client über Änderungen zu informieren (`notifications/resources/updated`).51
- **Prompts:** Spielen für einfache Status- und Aktions-Widgets eine untergeordnete Rolle. Sie könnten jedoch verwendet werden, um komplexere, geführte Abläufe zu initiieren, die über das Widget gestartet werden (z. B. das Einrichten einer neuen VPN-Verbindung).
- **Roots:** Definieren Dateisystembereiche, auf die bestimmte Server zugreifen dürfen (z. B. der Home-Ordner für einen Dateisuche-Server).5 Der Host verwaltet diese und holt die Zustimmung des Benutzers ein.
- **Sampling:** Ist für die Kernfunktionalität der Widgets zunächst nicht erforderlich, bietet aber Potenzial für zukünftige KI-gestützte Widget-Funktionen.6

### 5.2 Abstraktion Linux-spezifischer Konzepte

Ein entscheidender Aspekt ist die **Abstraktion**. Die MCP-Schnittstellen (Tool-/Resource-Namen, Parameter, Rückgabewerte) dürfen keine Linux-spezifischen Details wie D-Bus-Pfade (`/org/freedesktop/...`), interne Servicenamen (`org.gnome.SettingsDaemon.Plugins.Color`) oder komplexe `gsettings`-Schemas offenlegen.

Die Benennung sollte klar, konsistent und plattformagnostisch sein, orientiert an der Terminologie, die Windows/Mac-Benutzer erwarten würden.

- **Statt:** `org.freedesktop.NetworkManager.Device.Disconnect`
    
- **Verwende:** MCP Tool `network.disconnectWifi()`
    
- **Statt:** `gsettings get org.gnome.desktop.interface color-scheme`
    
- **Verwende:** MCP Resource `settings.getColorScheme() -> string` (z.B. 'light' oder 'dark')
    

Diese Abstraktionsebene ist es, die MCP für die Vereinfachung der Linux-Benutzererfahrung so wertvoll macht. Sie entkoppelt die Benutzeroberfläche (Widgets) vollständig von der darunterliegenden Systemimplementierung.

### 5.3 Tabelle: MCP-Primitive im Kontext der Desktop-Widget-Integration

Die folgende Tabelle verdeutlicht die spezifische Rolle jedes MCP-Primitivs im Kontext der Desktop-Widget-Integration und liefert konkrete Beispiele. Dies hilft Architekten und Entwicklern, die Primitive konsistent und gemäß ihrer vorgesehenen Funktion in diesem spezifischen Anwendungsfall einzusetzen.

|   |   |   |   |
|---|---|---|---|
|**MCP Primitive**|**Definition (gemäß MCP-Spezifikation)**|**Rolle in der Desktop-Widget-Integration**|**Beispielhafte Widget-Interaktion**|
|**Tool**|Ausführbare Funktion, die vom Client aufgerufen wird, um eine Aktion auszuführen oder Informationen abzurufen 5|**Aktion auslösen:** Wird verwendet, wenn ein Widget eine Zustandsänderung im System bewirken soll (z. B. Umschalten, Wert setzen, Befehl ausführen).|Klick auf "Herunterfahren"-Button löst `power.shutdown()` Tool aus. Verschieben eines Lautstärkereglers löst `audio.setVolume(level)` Tool aus.|
|**Resource**|Strukturierte Daten oder Inhalte, die vom Server bereitgestellt und vom Client gelesen werden können, um Kontext bereitzustellen 5|**Zustand anzeigen:** Wird verwendet, um aktuelle Systeminformationen oder Daten abzurufen, die in einem Widget angezeigt werden sollen (z. B. Status, Wert, Liste).|Ein Batterie-Widget liest periodisch die `power.getBatteryStatus()` Resource, um die Anzeige zu aktualisieren. Ein Netzwerk-Widget liest `network.getWifiState()` Resource beim Start.|
|**Prompt**|Vorbereitete Anweisung oder Vorlage, die vom Server bereitgestellt wird, um Interaktionen zu leiten 5|**Geführter Arbeitsablauf (seltener):** Kann verwendet werden, um komplexere Konfigurations- oder Einrichtungsaufgaben zu initiieren, die über die Host-UI laufen.|Klick auf "VPN konfigurieren" in einem Netzwerk-Widget könnte einen `network.configureVPN` Prompt auslösen, der einen Dialog im Host startet.|
|**Root**|Einstiegspunkt in das Dateisystem/die Umgebung des Hosts, auf den der Server zugreifen darf 5|**Zugriffsbereich definieren:** Legt fest, auf welche Teile des Dateisystems ein Server (z. B. Dateisuche) zugreifen darf, nach Zustimmung des Benutzers durch den Host.|Ein Dateisuche-Widget verwendet einen Server, der nur auf die per Root definierten Ordner (z. B. `/home/user/Documents`) zugreifen darf.|
|**Sampling**|Mechanismus, der es dem Server ermöglicht, eine LLM-Vervollständigung vom Client anzufordern 5|**Zukünftige KI-Funktionen (optional):** Nicht für grundlegende Widgets erforderlich, könnte aber für erweiterte, KI-gestützte Widget-Aktionen genutzt werden.|Ein "Organisiere Downloads"-Widget könnte einen Server nutzen, der via Sampling den Host-LLM bittet, eine Ordnungsstrategie vorzuschlagen.|

Diese klare Zuordnung stellt sicher, dass die MCP-Primitive im Sinne der Vereinfachung und Abstraktion für Windows/Mac-Umsteiger korrekt eingesetzt werden.

## 6. Beispielhafte MCP-Server-Implementierungen

Um die vorgeschlagene Architektur zu konkretisieren, werden im Folgenden einige Beispiele für MCP-Server skizziert, die typische Bedürfnisse von Umsteigern adressieren. Für jeden Server werden Zweck, beispielhafte MCP-Schnittstellen (Tools/Resources) und die wahrscheinlich genutzten Linux-Mechanismen beschrieben.

### 6.1 Vereinfachter Dateiverwaltungs-Server

- **Zweck:** Ermöglicht schnelles Finden und grundlegende Operationen mit Dateien, ohne dass Benutzer sich mit komplexen Dateimanagern oder der Kommandozeile auseinandersetzen müssen. Adressiert die oft als umständlich empfundene Dateisuche unter Linux.
- **MCP-Schnittstellen:**
    - **Tools:**
        - `files.search(query: string) -> list<object>`: Führt eine schnelle Suche im indizierten Dateisystem durch.
        - `files.open(path: string) -> boolean`: Öffnet die angegebene Datei mit der Standardanwendung.
        - `files.moveToTrash(path: string) -> boolean`: Verschiebt die Datei sicher in den Papierkorb.
    - **Resources:**
        - `files.list(directory: string) -> list<object>`: Listet den Inhalt eines Verzeichnisses auf (unter Berücksichtigung der per Roots definierten Berechtigungen).
        - `files.getRecentFiles() -> list<object>`: Ruft eine Liste der zuletzt verwendeten Dateien ab (z. B. über Desktop-Suchindizes oder Lesezeichen).
- **Zugrunde liegende Mechanismen:**
    - Suche: `plocate`-Kommandozeilentool für schnelle, indizierte Suche.59
    - Öffnen: D-Bus-Aufrufe (`org.freedesktop.FileManager1.ShowItems` oder `xdg-open` CLI).
    - Papierkorb: Implementierung gemäß Freedesktop.org Trash Specification (oft über GLib/GIO-Bibliotheken).
    - Dateilisting/Recent: Standard-Dateisystem-APIs, Desktop-Suchdienste (z. B. Tracker).
- **Implementierung:** Python mit `subprocess` für `plocate` und Dateisystem-APIs, ggf. `pydbus`/`dasbus` für Öffnen/Papierkorb. Zugriffsbereiche sollten über MCP Roots gesteuert werden.29 Bestehende Filesystem-MCP-Server 59 können als Vorlage dienen.

### 6.2 Vereinheitlichter Systemeinstellungs-Server

- **Zweck:** Bietet einfache Umschalter und Schieberegler für häufig geänderte Einstellungen (z. B. Dunkelmodus, Helligkeit, Lautstärke, Maus-/Touchpad-Geschwindigkeit), die oft in verschachtelten Menüs versteckt sind.
- **MCP-Schnittstellen:**
    - **Tools:**
        - `settings.setDarkMode(enabled: boolean) -> boolean`
        - `settings.setBrightness(level: integer) -> boolean` (Level 0-100)
        - `settings.setVolume(level: integer) -> boolean` (Level 0-100)
        - `settings.setMouseSpeed(level: float) -> boolean` (Skala definieren, z. B. 0.0-1.0)
    - **Resources:**
        - `settings.getDarkMode() -> boolean`
        - `settings.getBrightness() -> integer`
        - `settings.getVolume() -> integer`
        - `settings.getMouseSpeed() -> float`
- **Zugrunde liegende Mechanismen:**
    - Primär: `gsettings`-Kommandozeilentool zum Lesen/Schreiben von Schemas wie `org.gnome.desktop.interface`, `org.gnome.desktop.peripherals` etc..91
    - Alternativ/Ergänzend: Direkte D-Bus-Aufrufe an spezifische Dienste der Desktop-Umgebung (z. B. GNOME Settings Daemon, KDE Powerdevil/KWin). Dies kann notwendig sein für Einstellungen, die nicht über GSettings verfügbar sind oder sofortige UI-Updates erfordern.
- **Implementierung:** Python mit `subprocess` für `gsettings` und/oder `pydbus`/`dasbus` für D-Bus. **Herausforderung:** Die spezifischen GSettings-Schemas oder D-Bus-Schnittstellen können sich zwischen Desktop-Umgebungen (GNOME, KDE, XFCE etc.) unterscheiden. Der Server muss entweder DE-spezifische Logik enthalten oder sich auf möglichst universelle Mechanismen konzentrieren.

### 6.3 Anwendungsstarter/-manager-Server

- **Zweck:** Bietet eine einfache Möglichkeit, installierte Anwendungen zu finden und zu starten, ähnlich dem Startmenü oder Launchpad.
- **MCP-Schnittstellen:**
    - **Tools:**
        - `apps.launch(appId: string) -> boolean`: Startet die Anwendung mit der gegebenen ID (typischerweise der Name der `.desktop`-Datei ohne Endung).
    - **Resources:**
        - `apps.listInstalled() -> list<{id: string, name: string, icon: string}>`: Gibt eine Liste aller gefundenen Anwendungen mit ID, Namen und Icon-Namen zurück.
- **Zugrunde liegende Mechanismen:**
    - Auflisten: Parsen von `.desktop`-Dateien in Standardverzeichnissen (`/usr/share/applications`, `~/.local/share/applications`) gemäß Desktop Entry Specification.97
    - Starten: Ausführen von `gtk-launch <appId>` oder Verwenden von D-Bus-Aktivierungsmechanismen (z. B. `org.freedesktop.Application.Activate`).
- **Implementierung:** Python mit einer Bibliothek zum Parsen von `.desktop`-Dateien und `subprocess` oder D-Bus-Bindings zum Starten.

### 6.4 Netzwerkkonfigurations-Server

- **Zweck:** Vereinfacht die Verwaltung von WLAN-Verbindungen und das Umschalten von VPNs, Aufgaben, die für Umsteiger oft verwirrend sind.
- **MCP-Schnittstellen:**
    - **Tools:**
        - `network.setWifiEnabled(enabled: boolean) -> boolean`
        - `network.connectWifi(ssid: string, password?: string) -> boolean`: Verbindet mit einem bekannten oder neuen Netzwerk.
        - `network.disconnectWifi() -> boolean`
        - `network.setVpnEnabled(vpnId: string, enabled: boolean) -> boolean`: Aktiviert/Deaktiviert eine konfigurierte VPN-Verbindung.
    - **Resources:**
        - `network.getWifiState() -> {enabled: boolean, connected: boolean, ssid?: string, strength?: integer}`: Gibt den aktuellen WLAN-Status zurück.
        - `network.listAvailableWifi() -> list<{ssid: string, strength: integer, security: string}>`: Listet sichtbare WLAN-Netzwerke auf.
        - `network.listVpns() -> list<{id: string, name: string, connected: boolean}>`: Listet konfigurierte VPN-Verbindungen auf.
- **Zugrunde liegende Mechanismen:** Ausschließlich die D-Bus-API von NetworkManager (`org.freedesktop.NetworkManager` und zugehörige Objekte/Schnittstellen).63 Diese API bietet umfassende Funktionen zur Abfrage und Steuerung von Netzwerkverbindungen.
- **Implementierung:** Python mit `pydbus` oder `dasbus`, um die komplexen D-Bus-Interaktionen mit NetworkManager zu kapseln.

### 6.5 Energieverwaltungs-Server

- **Zweck:** Bietet direkten Zugriff auf Aktionen wie Herunterfahren, Neustarten, Ruhezustand und das Abrufen des Batteriestatus.
- **MCP-Schnittstellen:**
    - **Tools:**
        - `power.shutdown() -> boolean`
        - `power.restart() -> boolean`
        - `power.suspend() -> boolean`
        - `power.hibernate() -> boolean`
        - `power.lockScreen() -> boolean`
    - **Resources:**
        - `power.getBatteryStatus() -> {level: integer, charging: boolean, timeRemaining?: string}`: Gibt den aktuellen Batteriestatus zurück (falls zutreffend).
- **Zugrunde liegende Mechanismen:**
    - Aktionen (Shutdown, Restart, Suspend, Hibernate): D-Bus-Aufrufe an `org.freedesktop.login1.Manager`.81 Diese Methoden berücksichtigen Inhibit-Locks und PolicyKit-Berechtigungen.
    - Bildschirm sperren: D-Bus-Aufruf an den Bildschirmschoner der Desktop-Umgebung (z. B. `org.gnome.ScreenSaver.Lock`) oder `loginctl lock-session`.
    - Batteriestatus: D-Bus-Aufrufe an `org.freedesktop.UPower` oder direktes Lesen aus `/sys/class/power_supply/`.
- **Implementierung:** Python mit `pydbus` oder `dasbus` für die D-Bus-Interaktionen.

Diese Beispiele zeigen, wie spezifische Linux-Funktionen hinter einfachen, benutzerfreundlichen MCP-Schnittstellen abstrahiert werden können, die direkt von Desktop-Widgets genutzt werden können.

## 7. Sicherheitsarchitektur und Best Practices

Da die MCP-Server potenziell sensible Systemaktionen ausführen und auf Benutzerdaten zugreifen können, ist eine robuste Sicherheitsarchitektur unerlässlich. MCP selbst betont die Bedeutung von Sicherheit und Benutzerkontrolle.6

### 7.1 Authentifizierung und Autorisierung für lokale Server

Während die MCP-Spezifikation für HTTP-basierte Transporte (SSE) ein auf OAuth 2.1 basierendes Autorisierungsmodell vorsieht 18, ist dieser Ansatz für lokale Server, die über STDIO kommunizieren, weniger praktikabel und oft überdimensioniert. Stattdessen sollte die Autorisierung für lokale Desktop-Interaktionen durch den **MCP Host** (die Desktop-Umgebung) verwaltet werden.

Vorgeschlagener Mechanismus:

1. **Server-Registrierung:** Der Host verwaltet eine Liste vertrauenswürdiger, installierter MCP-Server. Diese könnten über Paketverwaltung oder ein dediziertes Verzeichnis bereitgestellt werden.
2. **Berechtigungsdefinition:** Für jeden Server oder jede Server-Kategorie werden granulare Berechtigungsbereiche (Scopes) definiert, die die Aktionen beschreiben, die der Server ausführen darf (z. B. `network:read`, `network:manage`, `settings:read`, `settings:write:appearance`, `files:read:home`, `power:control`). Diese Scopes sollten in der Server-Metadatenbeschreibung enthalten sein.
3. **Benutzerzustimmung (Consent):** Wenn ein Widget zum ersten Mal versucht, ein MCP-Tool aufzurufen, das eine bestimmte Berechtigung erfordert (z. B. `network:manage` für `network.setWifiEnabled`), prüft der Host, ob der Benutzer dieser Berechtigung für diesen spezifischen Server bereits zugestimmt hat.
4. **Consent Prompt:** Falls keine Zustimmung vorliegt, zeigt der Host dem Benutzer einen klaren Dialog an, der erklärt:
    - _Welches Widget_ (oder welche Anwendung)
    - _Welchen Server_
    - _Welche Aktion_ (basierend auf der Tool-Beschreibung) ausführen möchte
    - _Welche Berechtigung_ dafür erforderlich ist. Der Benutzer kann die Berechtigung erteilen (einmalig oder dauerhaft) oder ablehnen.
5. **Speicherung der Zustimmung:** Erteilte Berechtigungen werden sicher vom Host gespeichert (z. B. in der dconf-Datenbank des Benutzers).
6. **Durchsetzung:** Der Host erlaubt dem Client nur dann den Aufruf eines Tools, wenn die entsprechende Berechtigung für den Server erteilt wurde.

Dieser Ansatz verlagert die Komplexität der Autorisierung vom einzelnen Server zum zentralen Host, was besser zum Sicherheitsmodell von Desktop-Anwendungen passt und dem Benutzer eine zentrale Kontrolle über die Berechtigungen ermöglicht. Er spiegelt die Kernprinzipien von MCP wider: explizite Benutzerzustimmung und Kontrolle.6

### 7.2 Verwaltung der Benutzerzustimmung

Die explizite Zustimmung des Benutzers ist ein Eckpfeiler der MCP-Sicherheit.6 Der Host **muss** sicherstellen, dass:

- Benutzer klar verstehen, welche Aktionen ausgeführt werden sollen und welche Daten betroffen sind, bevor sie zustimmen. Die von den Servern bereitgestellten Beschreibungen für Tools und Resources sind hierfür entscheidend.
- Benutzer die Möglichkeit haben, erteilte Berechtigungen jederzeit einzusehen und zu widerrufen (z. B. über ein zentrales Einstellungsmodul in der Desktop-Umgebung).

### 7.3 Transportsicherheit (STDIO)

Obwohl STDIO eine lokale Kommunikationsform ist, muss der Host sicherstellen, dass er nur vertrauenswürdige, validierte MCP-Server-Executables startet. Die Server selbst sollten grundlegende Validierungen der über STDIO empfangenen Daten durchführen, um unerwartetes Verhalten durch fehlerhafte oder manipulierte Eingaben zu verhindern.

### 7.4 Prinzip der geringsten Rechte (Least Privilege)

MCP-Server sollten nur mit den minimal erforderlichen Berechtigungen laufen, um ihre definierte Funktion zu erfüllen. Das Ausführen von Servern als Root sollte unbedingt vermieden werden. Wenn erhöhte Rechte erforderlich sind (z. B. zum Ändern bestimmter Systemeinstellungen), sollten etablierte Mechanismen wie PolicyKit genutzt werden, idealerweise indem der MCP-Server einen bereits privilegierten D-Bus-Dienst kontaktiert, der die PolicyKit-Interaktion übernimmt, anstatt selbst Root-Rechte anzufordern.

### 7.5 Eingabevalidierung und -bereinigung (Input Sanitization)

Dies ist besonders kritisch für MCP-Server, die Kommandozeilen-Tools kapseln oder mit Dateipfaden arbeiten. Alle vom Client empfangenen Parameter, die zur Konstruktion von Befehlen, Dateipfaden oder D-Bus-Aufrufen verwendet werden, **müssen** rigoros validiert und bereinigt werden, um Sicherheitslücken wie Command Injection oder Directory Traversal zu verhindern.27 JSON-Schema-Validierung für Tool-Parameter ist ein erster wichtiger Schritt.27

Durch die Kombination aus Host-verwalteter Autorisierung, expliziter Benutzerzustimmung und sorgfältiger Implementierung der Server unter Beachtung der Sicherheitsprinzipien kann eine robuste und vertrauenswürdige MCP-Infrastruktur für Desktop-Widgets geschaffen werden.

## 8. Empfehlungen und Implementierungs-Roadmap

Basierend auf der Analyse des Model Context Protocol und seiner Anwendbarkeit auf die Vereinfachung von Linux-Desktop-Interaktionen für Umsteiger werden folgende Empfehlungen und eine mögliche Roadmap für die Implementierung vorgeschlagen.

### 8.1 Schlüsselempfehlungen

1. **MCP als Standard etablieren:** MCP sollte als standardisierte Schnittstelle zwischen Desktop-Widgets und den zugrunde liegenden Systemfunktionen für die Ziel-Linux-Distribution(en) eingeführt werden. Dies fördert Modularität, Wiederverwendbarkeit und Interoperabilität.
2. **Priorisierung der Server:** Die Entwicklung von MCP-Servern sollte sich zunächst auf die Bereiche konzentrieren, die für Windows/Mac-Umsteiger die größten Hürden darstellen und den größten Nutzen bringen: Netzwerkverwaltung, grundlegende Systemeinstellungen (Helligkeit, Lautstärke, Dark Mode), einfache Dateisuche und Anwendungsstart.
3. **Robuste Host-Komponente:** Die Entwicklung einer soliden MCP-Host-Komponente innerhalb der Desktop-Umgebung ist entscheidend. Diese Komponente ist verantwortlich für das Management der Client-Server-Verbindungen (insbesondere über STDIO), die Implementierung des vorgeschlagenen Consent- und Berechtigungsmodells und die Bereitstellung von APIs für Widget-Entwickler.
4. **Implementierungssprache:** Python erscheint aufgrund seiner ausgezeichneten Unterstützung für D-Bus-Interaktion (`dasbus`, `pydbus`), einfacher Handhabung von Subprozessen (für CLIs) und umfangreicher Standardbibliothek als geeignete Wahl für die Entwicklung der meisten MCP-Server. Alternativen wie Rust oder Go sind ebenfalls möglich, insbesondere wenn Performance kritisch ist.
5. **API-Design:** Der Fokus bei der Gestaltung der MCP Tool- und Resource-Schnittstellen muss auf Einfachheit, Klarheit und Plattformunabhängigkeit liegen, um die Bedürfnisse der Zielgruppe (Umsteiger) zu erfüllen.

### 8.2 Phasierter Implementierungsansatz

Eine schrittweise Einführung wird empfohlen, um frühzeitig Feedback zu sammeln und die Komplexität zu managen:

- **Phase 1: Grundlage schaffen (Proof of Concept)**
    - Entwicklung der Kernfunktionen des MCP Hosts (Client-Management für STDIO, grundlegende Consent-UI).
    - Implementierung von 1-2 fundamentalen MCP-Servern (z. B. Netzwerkstatus/-umschaltung, Helligkeits-/Lautstärkeregelung).
    - Erstellung einfacher Proof-of-Concept-Widgets, die diese Server nutzen.
    - Definition des initialen Satzes von Berechtigungs-Scopes.
- **Phase 2: Erweiterung und Stabilisierung**
    - Implementierung weiterer priorisierter Server (z. B. Energieverwaltung, Dateisuche, Anwendungsstart).
    - Verfeinerung des Sicherheitsmodells und der Consent-Verwaltung im Host.
    - Entwicklung eines breiteren Satzes von Widgets für gängige Anwendungsfälle.
    - Einführung von Mechanismen zur Server-Entdeckung und -Installation.
- **Phase 3: Fortgeschrittene Funktionen und Ökosystem**
    - Erkundung fortgeschrittener MCP-Funktionen wie Ressourcen-Abonnements für Echtzeit-Updates.51
    - Untersuchung potenzieller Anwendungsfälle für serverübergreifende Interaktionen oder die Nutzung von Prompts.
    - Evaluierung der Notwendigkeit von SSE für spezifische Remote- oder Cloud-Anwendungsfälle.
    - Integration in weitere Desktop-Umgebungen (falls erforderlich).
    - Förderung von Community-Beiträgen zur Entwicklung neuer MCP-Server.

### 8.3 Zukünftige Überlegungen

- **Desktop-Umgebungs-Vielfalt:** Die Anpassung der Server oder der Host-Logik an die spezifischen D-Bus-Schnittstellen oder `gsettings`-Schemas verschiedener Desktop-Umgebungen (GNOME, KDE Plasma, etc.) wird eine Herausforderung darstellen, wenn eine breite Kompatibilität angestrebt wird. Eine sorgfältige Abstraktion innerhalb der Server ist hierbei wichtig.
- **Remote-Management/Cloud-Integration:** Die Nutzung von MCP über SSE könnte zukünftig Szenarien wie die Fernsteuerung des Desktops oder die Integration von Cloud-Diensten in Widgets ermöglichen, erfordert aber signifikante zusätzliche Arbeit im Bereich Sicherheit und Authentifizierung.
- **KI-Integration (Sampling):** Die `Sampling`-Primitive von MCP 6 eröffnet die Möglichkeit, LLM-Funktionen direkt in Widgets zu integrieren, die über den Host bereitgestellt werden. Dies könnte für komplexere Aufgaben wie die Organisation von Dateien oder die Zusammenfassung von Systeminformationen genutzt werden, erfordert jedoch strenge Sicherheitskontrollen und Benutzerzustimmung.5
- **Community-Aufbau:** Die Schaffung einer Dokumentation und von Richtlinien für Drittentwickler zur Erstellung eigener MCP-Server könnte das Ökosystem erheblich erweitern und Nischenanwendungsfälle abdecken.

## 9. Schlussfolgerung

Die Implementierung einer auf dem Model Context Protocol basierenden Infrastruktur bietet einen vielversprechenden Ansatz, um die Interaktion mit Linux-Systemen für Benutzer, die von Windows oder macOS wechseln, erheblich zu vereinfachen. Durch die Standardisierung der Kommunikation zwischen Desktop-Widgets und Systemfunktionen über eine klar definierte Client-Server-Architektur und die Kapselung Linux-spezifischer Mechanismen (wie D-Bus und Kommandozeilen-Tools) in dedizierten MCP-Servern, kann eine intuitive und benutzerfreundliche Oberfläche geschaffen werden.

Die Verwendung von STDIO als primärem Transportmechanismus für die lokale Kommunikation vereinfacht die initiale Implementierung und erhöht die Sicherheit. Ein durch den Host verwaltetes Consent- und Berechtigungsmodell stellt sicher, dass der Benutzer die Kontrolle über Systemzugriffe behält, im Einklang mit den Sicherheitsprinzipien von MCP.

Die vorgeschlagene Roadmap ermöglicht eine schrittweise Einführung, beginnend mit den wichtigsten Funktionen für Umsteiger. Der Erfolg dieses Ansatzes hängt von der sorgfältigen Gestaltung der MCP-Schnittstellen zur Abstraktion der Systemkomplexität und der robusten Implementierung sowohl der Host-Komponente als auch der einzelnen MCP-Server ab. Durch die Nutzung des offenen MCP-Standards wird eine flexible, erweiterbare und potenziell über verschiedene Desktop-Umgebungen hinweg interoperable Lösung geschaffen, die das Potenzial hat, die Akzeptanz von Linux als Desktop-Betriebssystem maßgeblich zu fördern.
# Ganzheitliche Spezifikation des Model-Context-Protocol (MCP) und Entwicklungsplan für Desktop-Widgets unter Linux

## 1. Einführung in das Model-Context-Protocol (MCP)

Das Model-Context-Protocol (MCP) stellt einen wegweisenden offenen Standard dar, der von Anthropic Ende 2024 eingeführt wurde.1 Seine primäre Funktion besteht darin, die Interaktion zwischen KI-Assistenten und den komplexen, datenreichen Ökosystemen, in denen sie operieren, zu standardisieren und zu vereinfachen. MCP adressiert die Herausforderung fragmentierter und ad-hoc entwickelter Integrationen, indem es ein universelles Framework für die Anbindung von Werkzeugen (Tools), Datenquellen (Resources) und vordefinierten Arbeitsabläufen (Prompts) bereitstellt.1 Dies ermöglicht KI-Systemen einen nahtlosen und sicheren Zugriff auf vielfältige Kontexte, was für die Entwicklung kontextbewusster und leistungsfähiger KI-Anwendungen unerlässlich ist. Die Analogie eines "USB-C-Ports für KI-Anwendungen" verdeutlicht das Ziel von MCP: eine standardisierte Schnittstelle für den Datenaustausch und die Funktionserweiterung von KI-Modellen.2

Die Relevanz von MCP ergibt sich aus mehreren Schlüsselfaktoren. Erstens fördert es die **Reproduzierbarkeit** von KI-Modellen, indem alle notwendigen Details – Datensätze, Umgebungsspezifikationen und Hyperparameter – zentralisiert und standardisiert zugänglich gemacht werden.1 Zweitens ermöglicht es eine verbesserte **Standardisierung und Kollaboration**, insbesondere bei der organisationsübergreifenden Nutzung spezialisierter KI-Werkzeuge oder proprietärer Datenquellen.1 Drittens adressiert MCP direkt die Herausforderungen der Interoperabilität, Skalierbarkeit und Sicherheit, die mit der Anbindung von Large Language Models (LLMs) an externe Systeme einhergehen.1 Durch die Bereitstellung eines offenen Protokolls wird die Entwicklungszeit für Integrationen reduziert, die Wartbarkeit durch selbstdokumentierende Schnittstellen verbessert und die Flexibilität erhöht, Komponenten auszutauschen oder zu aktualisieren.2

MCP ist nicht nur darauf ausgelegt, Informationen abzurufen, sondern auch Aktionen auszuführen, wie das Aktualisieren von Dokumenten oder das Automatisieren von Workflows, wodurch die Lücke zwischen isolierter Intelligenz und dynamischer, kontextabhängiger Funktionalität geschlossen wird.1 Die Entwicklung und Pflege des MCP-Standards erfolgt durch eine Arbeitsgruppe und wird durch eine offene Governance-Struktur vorangetrieben, die eine kollaborative Gestaltung durch KI-Anbieter und die Community sicherstellt.2

## 2. Kernziele und Designprinzipien des MCP

Das Model-Context-Protocol (MCP) verfolgt zentrale Ziele, die seine Architektur und Funktionalität maßgeblich prägen. Ein primäres Ziel ist die **Standardisierung der Kontextbereitstellung** für LLMs.3 Anstatt für jede Kombination aus KI-Modell und externem System eine individuelle Integrationslösung entwickeln zu müssen, bietet MCP eine einheitliche Methode, um LLMs mit Daten und Werkzeugen zu verbinden.6 Dies ist vergleichbar mit dem Language Server Protocol (LSP), das die Integration von Programmiersprachen in Entwicklungsumgebungen standardisiert.6

Weitere Kernziele umfassen:

- **Verbesserte Interoperabilität:** Ermöglichung der nahtlosen Zusammenarbeit verschiedener KI-Systeme und externer Dienste.1
- **Erhöhte Skalierbarkeit:** Vereinfachung der Erweiterung von KI-Anwendungen durch modulare Anbindung neuer Datenquellen und Werkzeuge.2
- **Gewährleistung von Sicherheit und Kontrolle:** Implementierung robuster Mechanismen für Benutzerzustimmung, Datenschutz und sichere Werkzeugausführung.1
- **Reduzierung des Entwicklungsaufwands:** Schnellere Integration durch standardisierte Muster und Protokolle.2

Diese Ziele spiegeln sich in den fundamentalen Designprinzipien des MCP wider, die insbesondere die Server-Implementierung und -Interaktion betreffen 10:

1. **Einfachheit der Server-Erstellung:** MCP-Server sollen extrem einfach zu erstellen sein. Host-Anwendungen übernehmen komplexe Orchestrierungsaufgaben, während sich Server auf spezifische, klar definierte Fähigkeiten konzentrieren. Einfache Schnittstellen und eine klare Trennung der Zuständigkeiten minimieren den Implementierungsaufwand und fördern wartbaren Code.10
2. **Hohe Komponierbarkeit der Server:** Jeder Server bietet isoliert eine fokussierte Funktionalität. Mehrere Server können nahtlos kombiniert werden, da das gemeinsame Protokoll Interoperabilität ermöglicht. Dieses modulare Design unterstützt die Erweiterbarkeit des Gesamtsystems.10
3. **Datenisolation und kontrollierter Kontextzugriff:** Server sollen nicht die gesamte Konversation lesen oder Einblick in andere Server erhalten können. Sie empfangen nur die notwendigen kontextuellen Informationen. Die vollständige Konversationshistorie verbleibt beim Host, und jede Serververbindung ist isoliert. Interaktionen zwischen Servern werden vom Host gesteuert, der die Sicherheitsgrenzen durchsetzt.10
4. **Progressive Erweiterbarkeit von Funktionen:** Funktionen können schrittweise zu Servern und Clients hinzugefügt werden. Das Kernprotokoll bietet eine minimale erforderliche Funktionalität, und zusätzliche Fähigkeiten können bei Bedarf ausgehandelt werden. Dies ermöglicht eine unabhängige Entwicklung von Servern und Clients und stellt die zukünftige Erweiterbarkeit des Protokolls unter Wahrung der Abwärtskompatibilität sicher.10

Diese Prinzipien unterstreichen das Bestreben von MCP, ein flexibles, sicheres und entwicklerfreundliches Ökosystem für die Integration von KI-Modellen mit ihrer Umgebung zu schaffen. Die Betonung der Benutzerkontrolle, des Datenschutzes und der Sicherheit von Werkzeugen sind dabei zentrale Säulen für vertrauenswürdige KI-Lösungen in realen Anwendungen.1

## 3. Die Architektur des Model-Context-Protocol

Das Model-Context-Protocol (MCP) basiert auf einer Client-Host-Server-Architektur, die darauf ausgelegt ist, KI-Anwendungen (Agenten) mit externen Systemen, Datenquellen und Werkzeugen zu verbinden, während klare Sicherheitsgrenzen gewahrt bleiben.1 Diese Architektur nutzt JSON-RPC für die Kommunikation und etabliert zustandsbehaftete Sitzungen zur Koordination des Kontexaustauschs und des Samplings.1

Die Kernkomponenten dieser Architektur sind:

### 3.1. MCP Host: Der Orchestrator

Der Host-Prozess fungiert als Container oder Koordinator für eine oder mehrere Client-Instanzen.1 Er ist die zentrale Anwendungsinstanz, die MCP nutzt, um auf Daten und Werkzeuge zuzugreifen, beispielsweise eine Desktop-Anwendung wie Claude Desktop, eine integrierte Entwicklungsumgebung (IDE) oder eine andere KI-gestützte Applikation.2

Zu den Hauptverantwortlichkeiten des Hosts gehören 1:

- Erstellung und Verwaltung des Lebenszyklus von Client-Instanzen.
- Kontrolle der Verbindungserlaubnisse für Clients.
- Durchsetzung von Sicherheitsrichtlinien, Benutzerautorisierung und Einholung von Zustimmungen (Consent).
- Koordination der Integration von KI- oder Sprachmodellen innerhalb jedes Clients, einschließlich des Sammelns und Zusammenführens von Kontextinformationen.
- Verwaltung der Kontextaggregation über verschiedene Clients hinweg.

Der Host spielt eine entscheidende Rolle bei der Wahrung der Sicherheit und des Datenschutzes, indem er sicherstellt, dass Benutzer explizit zustimmen und die Kontrolle über den Datenzugriff und die ausgeführten Operationen behalten.8

### 3.2. MCP Client: Der Vermittler

Jede Client-Instanz wird vom Host erstellt und läuft innerhalb des Host-Prozesses.1 Ein Client stellt eine dedizierte, zustandsbehaftete Eins-zu-Eins-Sitzung mit einem spezifischen MCP-Server her.1 Er fungiert als Vermittler, der die Kommunikation zwischen dem Host (und dem darin integrierten LLM) und dem Server handhabt.

Die Aufgaben des Clients umfassen 1:

- Aushandlung von Protokollversionen und Fähigkeiten (Capabilities) mit dem Server.
- Orchestrierung und Weiterleitung von Nachrichten zwischen sich und dem Server.
- Verwaltung von Abonnements und Benachrichtigungen.
- Aufrechterhaltung von Sicherheitsgrenzen, sodass ein Client nicht auf Ressourcen zugreifen kann, die einem anderen Client oder Server zugeordnet sind.
- Übersetzung der Anforderungen des Hosts in das MCP-Format und umgekehrt.

Die Client-Komponente ist somit für die zuverlässige und sichere Kommunikation sowie für die Verwaltung des Zustands der Verbindung zu einem einzelnen Server zuständig.2

### 3.3. MCP Server: Der Fähigkeitsanbieter

Ein MCP-Server ist ein eigenständiges Programm oder ein Dienst, der spezifische Datenquellen, APIs oder andere Dienstprogramme (wie CRMs, Git-Repositories oder Dateisysteme) kapselt und deren Fähigkeiten über das MCP-Protokoll bereitstellt.1 Server können lokal als Subprozess der Anwendung oder entfernt als über Netzwerk erreichbare Dienste betrieben werden.1

Die Hauptfunktionen eines Servers sind 1:

- Definition und Bereitstellung von "Tools" (ausführbare Funktionen), "Resources" (Datenquellen) und "Prompts" (vordefinierte Vorlagen), die der Client abrufen oder ausführen kann.
- Verarbeitung von Anfragen des Clients (z.B. Ausführung eines Tools, Lesen einer Ressource).
- Rückgabe von Ergebnissen oder Daten an den Client in einem standardisierten Format.
- Einhaltung der vom Host durchgesetzten Sicherheitsbeschränkungen und Benutzerberechtigungen.
- Potenzielles Anfordern von Sampling-Operationen über Client-Schnittstellen.

Server sind darauf ausgelegt, fokussierte Verantwortlichkeiten zu übernehmen und hochgradig komponierbar zu sein.10 Beispiele für MCP-Server sind der offizielle Dateisystem-Server 3, der PiecesOS-Server für personalisierten Kontext 11 oder der Merge MCP-Server, der Zugriff auf Hunderte von APIs über eine einzige Schnittstelle ermöglicht.12 Es gibt auch von der Community entwickelte Server für verschiedenste Anwendungen wie PostgreSQL, Slack, Git, GitHub und viele mehr.6

Die klare Trennung der Verantwortlichkeiten zwischen Host, Client und Server ermöglicht eine modulare und skalierbare Architektur. Der Host kann komplexe Orchestrierungslogik handhaben, während Server sich auf die Bereitstellung spezifischer Fähigkeiten konzentrieren. Dies erleichtert die Entwicklung und Wartung von sowohl den Host-Anwendungen als auch den einzelnen Server-Komponenten erheblich.10

## 4. Details des Model-Context-Protocol

Das Model-Context-Protocol (MCP) definiert die genauen Regeln und Formate für die Kommunikation zwischen den Komponenten seiner Architektur. Es baut auf etablierten Standards auf und erweitert diese um spezifische Mechanismen für den Austausch von Kontext und die Steuerung von KI-Interaktionen.

### 4.1. Kommunikationsgrundlage: JSON-RPC 2.0

MCP verwendet JSON-RPC 2.0 als zugrundeliegendes Nachrichtenformat für die gesamte Kommunikation zwischen Clients und Servern.1 JSON-RPC 2.0 ist ein leichtgewichtiges, zustandsloses Protokoll für Remote Procedure Calls, das sich durch seine Einfachheit und breite Unterstützung auszeichnet.4

Die Nachrichtenstruktur in JSON-RPC 2.0 umfasst drei Haupttypen 14:

1. **Requests (Anfragen):** Nachrichten, die eine Operation auf dem entfernten System initiieren und eine Antwort erwarten. Sie enthalten:
    - `jsonrpc: "2.0"`
    - `id: string | number` (eine eindeutige Kennung für die Anfrage, darf nicht `null` sein und nicht innerhalb derselben Sitzung vom Anforderer wiederverwendet werden 16)
    - `method: string` (Name der auszuführenden Methode/Prozedur)
    - `params?: object | array` (Parameter für die Methode)
2. **Responses (Antworten):** Nachrichten, die als Reaktion auf eine Anfrage gesendet werden. Sie enthalten:
    - `jsonrpc: "2.0"`
    - `id: string | number` (muss mit der ID der ursprünglichen Anfrage übereinstimmen 16)
    - Entweder `result: any` (bei erfolgreicher Ausführung) oder `error: object` (bei einem Fehler). Eine Antwort darf nicht sowohl `result` als auch `error` enthalten.16
    - Das `error`-Objekt enthält `code: number` (ein Integer-Fehlercode), `message: string` und optional `data: any` für zusätzliche Fehlerinformationen.16
3. **Notifications (Benachrichtigungen):** Nachrichten, die gesendet werden, um das entfernte System zu informieren, aber keine direkte Antwort erwarten. Sie enthalten:
    - `jsonrpc: "2.0"`
    - `method: string`
    - `params?: object | array`
    - Notifications dürfen keine `id` enthalten.16

Obwohl JSON-RPC 2.0 an sich zustandslos ist, baut MCP darauf **zustandsbehaftete Sitzungen** (stateful sessions) auf.1 Das bedeutet, dass die MCP-Schicht oberhalb von JSON-RPC für die Verwaltung des Sitzungskontexts, der Sequenz von Operationen und der ausgehandelten Fähigkeiten verantwortlich ist. Diese Zustandsbehaftung ist entscheidend für Funktionen wie Ressourcenabonnements oder die Verfolgung laufender Operationen.

#### 4.1.2. Standard-MCP-Methoden (z.B. `initialize`, `shutdown`, `ping`, `$/cancelRequest`)

Über die spezifischen Methoden für Tools, Resources und Prompts hinaus definiert MCP eine Reihe von Standard-JSON-RPC-Methoden, die für die Verwaltung der Sitzung und grundlegende Protokolloperationen unerlässlich sind.

Die folgende Tabelle gibt einen Überblick über wichtige Standardmethoden im MCP:

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Methodenname**|**Richtung**|**Zweck**|**Wichtige Parameter (Beispiele)**|**Erwartete Antwort/Verhalten**|**Referenzen**|
|`initialize`|Client → Server|Startet die Sitzung, handelt Protokollversion und Fähigkeiten aus.|`protocolVersion`, `capabilities` (Client), `clientInfo`|Antwort mit `protocolVersion` (Server), `capabilities` (Server), `serverInfo`|10|
|`initialized`|Client → Server (Notification)|Bestätigt den erfolgreichen Abschluss der Initialisierung durch den Client.|Keine|Keine (Notification)|14|
|`shutdown`|Client → Server (oder Server → Client)|Fordert ein sauberes Herunterfahren der Verbindung an.|Keine|Leere Erfolgsantwort oder Fehler|14|
|`exit`|Server → Client (oder Client → Server) (Notification)|Benachrichtigt die Gegenseite, dass der Sender sich beendet.|Keine|Keine (Notification)|19|
|`ping`|Client ↔ Server|Überprüft die Verbindung und misst ggf. Latenz.|Optional: `payload`|`pong`-Antwort mit demselben `payload`|8 (impliziert)|
|`$/cancelRequest`|Client ↔ Server (Notification)|Fordert den Abbruch einer zuvor gesendeten Anfrage mit einer bestimmten ID.|`id` der abzubrechenden Anfrage|Keine (Notification)|8|
|`notifications/message`|Server → Client (Notification)|Sendet Log- oder andere Informationsnachrichten vom Server an den Client.|`level` (z.B. "error", "info"), `logger`, `data`|Keine (Notification)|8|

Die `initialize`-Handshake-Sequenz ist von fundamentaler Bedeutung, da sie die Kompatibilität der Protokollversionen sicherstellt und die Fähigkeiten von Client und Server austauscht.10 Dies bildet den "Vertrag" für die Dauer der Sitzung und stellt sicher, dass beide Seiten verstehen, welche Operationen die andere Seite unterstützt, wodurch Fehler durch den Versuch, nicht unterstützte Funktionen zu nutzen, vermieden werden. Eine korrekte Implementierung von `shutdown` und `exit` ist ebenso kritisch, um Ressourcenlecks und verwaiste Prozesse zu verhindern, insbesondere bei `stdio`-basierten Servern, wo das Schließen von Streams und das Senden von Signalen Teil des geordneten Beendigungsprozesses sind.19

### 4.2. Transportmechanismen

MCP definiert zwei primäre Transportmechanismen für die Übermittlung der JSON-RPC-Nachrichten.3

#### 4.2.1. Standard Input/Output (stdio) für lokale Server

Bei diesem Transportmechanismus wird der MCP-Server als Subprozess der Client-Anwendung (des Hosts) gestartet.3 Die Kommunikation erfolgt über die Standard-Eingabe (`stdin`) und Standard-Ausgabe (`stdout`) des Subprozesses.14 Nachrichten werden typischerweise als JSON-RPC-formatierte Strings gesendet, die durch Zeilenumbrüche voneinander getrennt sind.14

**Anwendungsfälle:**

- Lokale Integrationen, bei denen Client und Server auf derselben Maschine laufen.6
- Kommandozeilenwerkzeuge (CLI-Tools), die MCP-Fähigkeiten bereitstellen.14

**Sicherheitsaspekte:** Die Sicherheit ist bei `stdio`-Transporten tendenziell einfacher zu handhaben, da die Kommunikation lokal erfolgt und oft in einer vertrauenswürdigen Umgebung stattfindet.15 Dennoch ist die Validierung von Eingaben weiterhin wichtig.

**Beispiel Serverstart (Merge MCP):**

JSON

```
{
  "mcpServers": {
    "merge-mcp": {
      "command": "uvx",
      "args": ["merge-mcp"],
      "env": {
        "MERGE_API_KEY": "your_api_key",
        "MERGE_ACCOUNT_TOKEN": "your_account_token"
      }
    }
  }
}
```

Dieses Beispiel aus der Merge-Dokumentation zeigt, wie ein `stdio`-basierter MCP-Server über einen Befehl und Argumente gestartet wird.12

#### 4.2.2. HTTP mit Server-Sent Events (SSE) für entfernte Server

Für die Kommunikation mit entfernten Servern unterstützt MCP HTTP in Kombination mit Server-Sent Events (SSE).3 Dabei werden Anfragen vom Client an den Server typischerweise über HTTP POST gesendet, während der Server SSE nutzt, um Nachrichten und Updates asynchron an den Client zu streamen.6

**Anwendungsfälle:**

- Entfernte MCP-Server, die über ein Netzwerk erreichbar sind.3
- Web-basierte Anwendungen, die MCP-Funktionalitäten integrieren.14

**Sicherheitsaspekte:** Dieser Transportmechanismus erfordert besondere Aufmerksamkeit hinsichtlich der Sicherheit 15:

- **Authentifizierung und Autorisierung:** Verbindungen müssen gesichert werden, z.B. durch Token-basierte Authentifizierung.
- **Transportverschlüsselung:** TLS (HTTPS) ist unerlässlich, um die Datenübertragung zu verschlüsseln.14
- **Origin-Header-Validierung:** Um Cross-Site-Request-Forgery (CSRF) und andere Angriffe zu verhindern, müssen Server die `Origin`-Header eingehender SSE-Verbindungen validieren.15
- **DNS Rebinding Schutz:** Server sollten nur an `localhost` (127.0.0.1) binden, wenn sie lokal laufen, und nicht an `0.0.0.0`, um DNS-Rebinding-Angriffe zu erschweren, bei denen entfernte Webseiten versuchen, mit lokalen MCP-Servern zu interagieren.15

Die Wahl des Transportmechanismus hat erhebliche Auswirkungen auf die Sicherheitsarchitektur und die Komplexität der Bereitstellung. Während `stdio` für lokale, vertrauenswürdige Umgebungen einfacher ist, erfordert HTTP/SSE robuste Netzwerksicherheitsmaßnahmen.15 Entwickler haben zudem die Möglichkeit, eigene, benutzerdefinierte Transportmechanismen zu implementieren, sofern diese die `Transport`-Schnittstelle erfüllen und die MCP-Nachrichtenformate und den Lebenszyklus korrekt handhaben.14 Dies bietet Flexibilität für spezialisierte Kommunikationskanäle, verlagert aber auch die Verantwortung für die korrekte und sichere Implementierung auf den Entwickler.

### 4.3. Management des Sitzungslebenszyklus

Eine MCP-Sitzung durchläuft klar definierte Phasen, von der Initialisierung über den aktiven Nachrichtenaustausch bis hin zur Beendigung.1

#### 4.3.1. Initialisierung und bidirektionale Fähigkeitsaushandlung (Capability Negotiation)

Die Sitzung beginnt mit einer Initialisierungsphase, die vom Client initiiert wird.14

1. Der Client sendet eine `initialize`-Anfrage an den Server. Diese Anfrage enthält:
    - Die vom Client unterstützte Protokollversion (sollte die neueste sein, die der Client unterstützt).19
    - Die Fähigkeiten (Capabilities) des Clients (z.B. Unterstützung für Sampling).10
    - Informationen zur Client-Implementierung (z.B. Name, Version).19
2. Der Server antwortet auf die `initialize`-Anfrage. Die Antwort enthält:
    - Die vom Server für diese Sitzung gewählte Protokollversion (muss mit der vom Client angeforderten übereinstimmen, wenn unterstützt).19
    - Die Fähigkeiten des Servers (z.B. welche Tools, Resources, Prompts er anbietet, Unterstützung für Ressourcenabonnements).10
    - Informationen zur Server-Implementierung.19
3. Nach Erhalt der erfolgreichen `initialize`-Antwort sendet der Client eine `initialized`-Benachrichtigung an den Server, um den Abschluss der Initialisierungsphase zu bestätigen.14

Während dieser Phase dürfen Client und Server vor der `initialize`-Antwort bzw. der `initialized`-Benachrichtigung keine anderen Anfragen als `ping` oder Logging-Nachrichten senden.19 Beide Parteien müssen die ausgehandelte Protokollversion respektieren und dürfen nur Fähigkeiten nutzen, die erfolgreich ausgehandelt wurden.19 Diese Fähigkeitsaushandlung ist ein Eckpfeiler der Erweiterbarkeit von MCP. Sie ermöglicht es dem Protokoll, sich mit neuen Funktionen weiterzuentwickeln, ohne bestehende Implementierungen zu brechen, falls diese neuere Fähigkeiten nicht unterstützen.10

#### 4.3.2. Aktiver Nachrichtenaustausch

Nach erfolgreicher Initialisierung beginnt der eigentliche Nachrichtenaustausch.14 Clients und Server können nun Anfragen (Request-Response) und Benachrichtigungen (Notifications) gemäß den ausgehandelten Fähigkeiten austauschen. Dies umfasst beispielsweise das Auflisten und Aufrufen von Tools, das Lesen von Ressourcen, das Abonnieren von Ressourcenänderungen oder das Abrufen von Prompts.

#### 4.3.3. Saubere Beendigung und Shutdown-Prozeduren

Die Verbindung kann auf verschiedene Weisen beendet werden 14:

- **Sauberes Herunterfahren:** Eine Seite (Client oder Server) sendet eine `shutdown`-Anfrage an die andere. Nach erfolgreicher Antwort auf `shutdown` sendet die initiierende Seite eine `exit`-Benachrichtigung, woraufhin beide Seiten die Verbindung schließen und Ressourcen freigeben.
- **Spezifische Prozeduren für `stdio`-Transport 19:**
    1. Der Client sollte das Herunterfahren initiieren, indem er zuerst den Eingabe-Stream zum Kindprozess (Server) schließt.
    2. Der Client wartet, bis der Server sich beendet.
    3. Wenn der Server sich nicht innerhalb einer angemessenen Zeit beendet, sendet der Client `SIGTERM`.
    4. Wenn der Server nach `SIGTERM` immer noch nicht beendet ist, sendet der Client `SIGKILL`.
- **Transport-Diskonnektion:** Eine unerwartete Unterbrechung der zugrundeliegenden Transportverbindung.
- **Fehlerbedingungen:** Kritische Fehler können ebenfalls zur Beendigung führen.

Ein robustes Management des Lebenszyklus ist entscheidend für zuverlässige, langlebige MCP-Integrationen, um Ressourcenlecks oder blockierte Zustände zu vermeiden.

### 4.4. Zustandsmanagement und Synchronisation in zustandsbehafteten Sitzungen

Obwohl JSON-RPC 2.0 ein zustandsloses Protokoll ist, sind MCP-Sitzungen explizit als zustandsbehaftet (stateful) konzipiert.1 Dieser Zustand wird über die Dauer der Verbindung zwischen einem Client und einem Server aufrechterhalten.

**Wie Zustand verwaltet wird:**

- **Initialisierungsphase:** Der grundlegende Zustand wird durch die während der `initialize`-Sequenz ausgehandelten Fähigkeiten (Capabilities) etabliert.19 Diese definieren, welche Operationen während der Sitzung gültig sind.
- **Serverseitiger Kontext:** Server müssen oft sitzungsspezifischen Zustand verwalten. Ein wichtiges Beispiel ist das Management von Ressourcenabonnements: Wenn ein Client eine Ressource abonniert (`resources/subscribe`), muss der Server sich diesen Client und die abonnierte Ressource merken, um bei Änderungen `notifications/resources/updated`-Benachrichtigungen senden zu können.23
- **Clientseitiges Wissen:** Clients müssen ebenfalls den Zustand der Verbindung und die Fähigkeiten des Servers kennen, um gültige Anfragen zu stellen.
- **Sequenz von Operationen:** Bestimmte Operationen können von vorherigen Aktionen abhängen (z.B. kann ein `tools/call` erst nach einem `tools/list` sinnvoll sein, wenn der Toolname nicht vorab bekannt ist).

Synchronisation:

Die Synchronisation des Zustands erfolgt implizit durch den definierten Nachrichtenfluss von Anfragen, Antworten und Benachrichtigungen.

- **Anfragen und Antworten:** Modifizieren oder fragen den Zustand ab (z.B. `resources/subscribe` ändert den Abonnementstatus auf dem Server).
- **Benachrichtigungen:** Informieren über Zustandsänderungen (z.B. `notifications/resources/updated` informiert den Client über eine geänderte Ressource, `notifications/tools/list_changed` über eine neue Werkzeugliste 25).

Entwickler von MCP-Servern, insbesondere solche, die Ressourcenabonnements oder langlebige Werkzeuge anbieten, müssen den sitzungsspezifischen Zustand sorgfältig verwalten. Da ein Server potenziell Verbindungen zu mehreren Clients gleichzeitig handhaben kann (obwohl jede Client-Instanz eine 1:1-Sitzung mit einem Server hat 1), ist die Isolation des Zustands zwischen den Sitzungen entscheidend, um Fehlinformationen oder "Cross-Talk" zu verhindern. Beispielsweise darf ein Update für eine von Client A abonnierte Ressource nicht an Client B gesendet werden, es sei denn, Client B hat dieselbe Ressource ebenfalls abonniert.

### 4.5. Umfassende Fehlerbehandlung und standardisierte Fehlercodes

MCP nutzt das Standard-Fehlerobjekt von JSON-RPC 2.0 für die Meldung von Fehlern.14 Dieses Objekt enthält die Felder `code` (eine Ganzzahl), `message` (eine menschenlesbare Beschreibung) und optional `data` (für zusätzliche, anwendungsspezifische Fehlerdetails).

MCP unterscheidet zwischen:

1. **Protokollfehlern:** Fehler, die auf der Ebene des JSON-RPC-Protokolls oder der grundlegenden MCP-Interaktion auftreten (z.B. eine falsch formatierte Anfrage, eine unbekannte Methode). Hierfür werden oft die Standard-JSON-RPC-Fehlercodes verwendet.
2. **Anwendungs-/Werkzeugausführungsfehlern:** Fehler, die während der Ausführung einer serverseitigen Logik auftreten (z.B. ein Tool kann eine externe API nicht erreichen). Diese werden oft innerhalb einer erfolgreichen JSON-RPC-Antwort signalisiert, typischerweise durch ein `isError: true`-Flag im `result`-Objekt eines `tools/call`.26

Die folgende Tabelle listet einige bekannte Standardfehlercodes und ihre Bedeutung im Kontext von MCP auf:

|   |   |   |   |   |
|---|---|---|---|---|
|**Fehlercode**|**Symbolischer Name (JSON-RPC)**|**Beschreibung**|**Typische Ursache im MCP**|**Referenzen**|
|-32700|Parse error|Ungültiges JSON wurde vom Server empfangen.|Fehlerhafte JSON-Serialisierung beim Client.|JSON-RPC 2.0 Spec|
|-32600|Invalid Request|Die gesendete JSON ist keine gültige Anfrage.|Anfrageobjekt entspricht nicht der JSON-RPC-Spezifikation.|18 (impliziert)|
|-32601|Method not found|Die angeforderte Methode existiert nicht oder ist nicht verfügbar.|Client ruft eine nicht unterstützte MCP-Methode auf.|18 (impliziert)|
|-32602|Invalid params|Ungültige Methodenparameter.|Falsche oder fehlende Parameter bei einem Methodenaufruf (z.B. unbekanntes Tool 27, ungültiger Prompt-Name 28, ungültiger Log-Level 20).|20|
|-32603|Internal error|Interner JSON-RPC-Fehler oder serverseitiger Fehler.|Nicht spezifizierter Fehler auf dem Server während der Protokollverarbeitung oder Ausführung (z.B. bei Ressourcen 24, Prompts 28).|24|
|-32000 bis -32099|Server error|Reserviert für implementierungsdefinierte Server-Fehler.||JSON-RPC 2.0 Spec|
|-32002|(MCP-spezifisch)|Ressource nicht gefunden.|Client fordert eine Ressource an, die nicht existiert oder nicht zugänglich ist.|24|

Diese mehrschichtige Fehlerbehandlung – Unterscheidung zwischen Protokollfehlern und anwendungsspezifischen Fehlern innerhalb der Tool-Ergebnisse – ermöglicht eine präzise Fehlerdiagnose. Clients müssen darauf vorbereitet sein, beide Arten von Fehlern adäquat zu verarbeiten, um eine stabile Benutzererfahrung zu gewährleisten und aussagekräftige Fehlermeldungen oder Fallback-Strategien zu implementieren.

## 5. MCP-Primitive: Tools, Resources und Prompts im Detail

MCP definiert drei Kernprimitive – Tools, Resources und Prompts – über die Server ihre Fähigkeiten und Daten für LLM-Anwendungen bereitstellen.1 Jedes Primitiv hat einen spezifischen Zweck und ein eigenes Interaktionsmodell.

Die folgende Tabelle gibt einen vergleichenden Überblick:

|   |   |   |   |   |
|---|---|---|---|---|
|**Primitiv**|**Primärer Zweck**|**Wichtige JSON-RPC-Methoden**|**Kontrolle durch**|**Typische Anwendungsfälle**|
|**Tools**|Ausführung von Aktionen, Interaktion mit Systemen|`tools/list`, `tools/call`, `notifications/tools/list_changed`|Modell (mit Benutzerzustimmung)|API-Aufrufe, Datenbankabfragen, Dateimanipulation, Berechnungen, Codeausführung|
|**Resources**|Bereitstellung von Daten und Kontext|`resources/list`, `resources/read`, `resources/subscribe`, `resources/unsubscribe`, `notifications/resources/list_changed`, `notifications/resources/updated`|Anwendung/Benutzer (ggf. Modell)|Dateiinhalte, Datenbankeinträge, API-Antworten, Systemstatus, Bilder, Logdateien|
|**Prompts**|Strukturierung von LLM-Interaktionen, Workflows|`prompts/list`, `prompts/get`, `notifications/prompts/list_changed`|Benutzer (oft über UI-Elemente)|Vordefinierte Abfragen, Code-Review-Anfragen, Zusammenfassungen, Slash-Befehle in Chats|

Diese Unterscheidung hilft Entwicklern, die passende Methode zur Integration ihrer spezifischen Funktionalitäten in das MCP-Ökosystem zu wählen.

### 5.1. Tools: Ermöglichung von KI-Aktionen

Tools sind ausführbare Funktionen, die von LLMs (modellgesteuert) aufgerufen werden können, um mit externen Systemen zu interagieren, Berechnungen durchzuführen oder Aktionen in der realen Welt auszulösen.2 Eine entscheidende Komponente ist dabei die explizite Zustimmung des Benutzers ("human in the loop") vor der Ausführung eines Tools, um Sicherheit und Kontrolle zu gewährleisten.2

#### 5.1.1. Definition, JSON Schema (Input/Output) und Annotationen

Eine Tool-Definition im MCP umfasst typischerweise 6:

- **`name: string`**: Ein eindeutiger Bezeichner für das Tool.
- **`description?: string`**: Eine menschenlesbare Beschreibung der Funktionalität des Tools.
- **`inputSchema: object`**: Ein JSON-Schema, das die erwarteten Eingabeparameter des Tools definiert. Dies ermöglicht Validierung und Typüberprüfung. In TypeScript-SDKs wird hierfür oft `zod` verwendet.21
- **`annotations?: object`**: Optionale Hinweise zum Verhalten des Tools, die primär für die Benutzeroberfläche gedacht sind und nicht den Modellkontext beeinflussen. Beispiele 25:
    - `title?: string`: Ein menschenlesbarer Titel für das Tool.
    - `readOnlyHint?: boolean`: Gibt an, ob das Tool seine Umgebung nicht verändert.
    - `destructiveHint?: boolean`: Gibt an, ob das Tool potenziell destruktive Änderungen vornehmen kann.
    - `idempotentHint?: boolean`: Gibt an, ob wiederholte Aufrufe mit denselben Argumenten keinen zusätzlichen Effekt haben.
    - `openWorldHint?: boolean`: Gibt an, ob das Tool mit der "offenen Welt" (z.B. Internet) interagiert.

Diese Annotationen sind besonders wertvoll, da sie es Host-Anwendungen ermöglichen, Benutzer transparent über die potenziellen Auswirkungen eines Tool-Aufrufs zu informieren, bevor diese ihre Zustimmung geben.25 Die Verwendung von JSON Schema für `inputSchema` fördert zudem robuste und typsichere Interaktionen, da sie eine standardisierte Validierung von Parametern erlaubt.25

**JSON Schema Beispiel für ein Tool (abgeleitet von 25):**

JSON

```
{
  "name": "get_weather",
  "description": "Get current weather information for a location",
  "inputSchema": {
    "type": "object",
    "properties": {
      "location": {
        "type": "string",
        "description": "City name or zip code"
      }
    },
    "required": ["location"]
  },
  "annotations": { "readOnlyHint": true }
}
```

#### 5.1.2. Entdeckung (`tools/list`) und Aufruf (`tools/call`)

- **`tools/list`**: Clients verwenden diese Methode, um eine Liste der vom Server bereitgestellten Tools zu erhalten.3 Die Antwort enthält die Definitionen der verfügbaren Tools. Clients können diese Liste zwischenspeichern, um Latenz zu reduzieren, sollten aber beachten, dass sich die Tool-Liste ändern kann (siehe `notifications/tools/list_changed`).3
- **`tools/call`**: Mit dieser Methode ruft ein Client ein spezifisches Tool auf dem Server auf, indem er den Tool-Namen und die erforderlichen Argumente übergibt.3

**JSON Beispiel für eine `tools/call`-Anfrage (abgeleitet von 7):**

JSON

```
{
  "jsonrpc": "2.0",
  "id": "call123",
  "method": "tools/call",
  "params": {
    "name": "get_weather",
    "arguments": { "location": "New York" }
  }
}
```

**JSON Beispiel für eine `tools/call`-Antwort (abgeleitet von 27):**

JSON

```
{
  "jsonrpc": "2.0",
  "id": "call123",
  "result": {
    "content": [{ "type": "text", "text": "Current weather in New York: 72°F, Partly cloudy" }],
    "isError": false
  }
}
```

Server können Clients über Änderungen in der Tool-Liste mittels der `notifications/tools/list_changed`-Benachrichtigung informieren.25

#### 5.1.3. Handhabung von Tool-Ergebnissen und Ausführungsfehlern

Die Antwort auf einen `tools/call`-Aufruf hat eine definierte Struktur 26:

- **`content: array`**: Ein Array von Inhaltsobjekten, die das Ergebnis der Tool-Ausführung darstellen. Jedes Objekt kann verschiedene Typen haben (z.B. `text`, `image`, `resource`).
- **`isError: boolean`**: Ein Flag, das angibt, ob bei der Ausführung des Tools ein Fehler aufgetreten ist.

Es ist wichtig, zwischen Protokollfehlern (z.B. Tool nicht gefunden, ungültige Parameter, gemeldet über das JSON-RPC `error`-Objekt) und Tool-Ausführungsfehlern (gemeldet via `isError: true` und einer Beschreibung im `content`-Array) zu unterscheiden.26

#### 5.1.4. Sicherheitsimperative für Tool-Design und -Ausführung

Aufgrund der potenziellen Mächtigkeit von Tools sind strenge Sicherheitsmaßnahmen unerlässlich 8:

- **Serverseitig:**
    - Strikte Validierung aller Eingabeparameter gegen das `inputSchema`.
    - Implementierung von Zugriffskontrollen (wer darf welche Tools aufrufen?).
    - Rate Limiting, um Missbrauch oder Überlastung zu verhindern.
    - Sorgfältige Behandlung und Bereinigung von Ausgaben.
- **Clientseitig (Host):**
    - Einholen expliziter Benutzerzustimmung vor jedem Tool-Aufruf.
    - Anzeige der Tool-Eingaben für den Benutzer vor dem Senden an den Server, um versehentliche oder böswillige Datenexfiltration zu vermeiden.
    - Validierung der Tool-Ergebnisse, bevor sie dem LLM oder Benutzer präsentiert werden.
    - Implementierung von Timeouts für Tool-Aufrufe.
    - Protokollierung von Tool-Nutzung für Audits.

### 5.2. Resources: Bereitstellung von Kontextdaten

Resources dienen dazu, Daten und Inhalte für LLMs als Kontext bereitzustellen.2 Im Gegensatz zu Tools, die modellgesteuert sind, ist die Verwendung von Resources typischerweise anwendungs- oder benutzergesteuert.23 Das bedeutet, die Host-Anwendung oder der Benutzer entscheidet, welche Ressourcen dem LLM zur Verfügung gestellt werden.

#### 5.2.1. Definition, URI-Schemata und Inhaltstypen (Text, Binär)

Eine Ressourcendefinition umfasst 23:

- **`uri: string`**: Ein eindeutiger Uniform Resource Identifier, der die Ressource adressiert. MCP unterstützt gängige URI-Schemata wie `file:///` für lokale Dateien oder `https://` für Webinhalte, erlaubt aber auch Servern, eigene benutzerdefinierte Schemata zu definieren (z.B. `postgres://`, `screen://`).14
- **`name: string`**: Ein menschenlesbarer Name für die Ressource.
- **`description?: string`**: Eine optionale Beschreibung.
- **`mimeType?: string`**: Der optionale MIME-Typ der Ressource (z.B. `text/plain`, `application/pdf`, `image/png`).

Ressourcen können zwei Arten von Inhalten haben 14:

- **Textressourcen**: Enthalten UTF-8-kodierten Text (z.B. Quellcode, Konfigurationsdateien, Logdateien).
- **Binärressourcen**: Enthalten Rohdaten, die Base64-kodiert übertragen werden (z.B. Bilder, PDFs, Audiodateien).

**JSON Beispiel für eine Ressourcendefinition (in einer `resources/list`-Antwort, abgeleitet von 23):**

JSON

```
{
  "uri": "file:///home/user/report.pdf",
  "name": "Project Report",
  "description": "Q3 Project Status Report",
  "mimeType": "application/pdf"
}
```

#### 5.2.2. Entdeckung (`resources/list`, Resource Templates) und Lesen (`resources/read`)

- **`resources/list`**: Clients verwenden diese Methode, um eine Liste der direkt vom Server bereitgestellten, konkreten Ressourcen zu erhalten.23
- **Resource Templates**: Für dynamisch generierte oder parametrisierte Ressourcen können Server URI-Vorlagen bereitstellen (z.B. `logs://{date}` oder `file:///logs/{filename}`).14 Clients können diese Vorlagen verwenden, um spezifische Ressourcen-URIs zu konstruieren.
- **`resources/read`**: Mit dieser Methode fordert ein Client den Inhalt einer oder mehrerer Ressourcen anhand ihrer URIs an.14 Ein Server kann auf eine einzelne `resources/read`-Anfrage mit den Inhalten mehrerer Ressourcen antworten, z.B. wenn die Anfrage-URI auf ein Verzeichnis zeigt und der Server die Inhalte der darin enthaltenen Dateien zurückgibt.23

**JSON Beispiel für eine `resources/read`-Antwort (abgeleitet von 23):**

JSON

```
{
  "jsonrpc": "2.0",
  "id": "read789",
  "result": {
    "contents":
  }
}
```

#### 5.2.3. Echtzeit-Updates: Abonnements (`resources/subscribe`, `notifications/resources/updated`) und Listenänderungen (`notifications/resources/list_changed`)

MCP unterstützt dynamische Aktualisierungen von Ressourcen 14:

- **`notifications/resources/list_changed`**: Der Server kann diese Benachrichtigung senden, um Clients darüber zu informieren, dass sich die Liste der verfügbaren Ressourcen geändert hat.
- **`resources/subscribe`**: Ein Client kann diese Methode verwenden, um Änderungen am Inhalt einer spezifischen Ressource zu abonnieren.
- **`notifications/resources/updated`**: Wenn eine abonnierte Ressource sich ändert, sendet der Server diese Benachrichtigung an den Client. Der Client kann dann mit `resources/read` den neuesten Inhalt abrufen.
- **`resources/unsubscribe`**: Ein Client verwendet diese Methode, um ein Abonnement für eine Ressource zu beenden.

Die Unterstützung für Abonnements (`subscribe`) und Benachrichtigungen über Listenänderungen (`listChanged`) wird während der Initialisierungsphase über die Server-Fähigkeiten ausgehandelt.24 Dieses Abonnementmodell ermöglicht es LLMs, mit dynamischen, sich in Echtzeit ändernden Kontexten zu arbeiten, was für Anwendungen, die aktuelle Informationen benötigen, von großer Bedeutung ist. Die Implementierung von Ressourcenabonnements erfordert jedoch auf Serverseite eine sorgfältige Verwaltung des Zustands der Abonnenten und der Ressourcen, um zeitnahe und korrekte Benachrichtigungen sicherzustellen.

### 5.3. Prompts: Strukturierung von KI-Interaktionen

Prompts im MCP sind wiederverwendbare Vorlagen und Arbeitsabläufe, die dazu dienen, Interaktionen mit LLMs zu standardisieren und zu vereinfachen.2 Sie sind typischerweise benutzergesteuert, d.h. der Benutzer wählt oft explizit einen Prompt aus, z.B. über UI-Elemente wie Slash-Befehle in einem Chat.14

#### 5.3.1. Definition, dynamische Argumente und Nachrichtenstruktur

Eine Prompt-Definition umfasst 14:

- **`name: string`**: Ein eindeutiger Bezeichner für den Prompt.
- **`description?: string`**: Eine menschenlesbare Beschreibung des Prompts.
- **`arguments?: array`**: Eine optionale Liste von Argumenten, die der Prompt akzeptiert. Jedes Argumentobjekt kann Felder wie `name`, `description`, `required` (boolean) und optional ein Schema zur Validierung enthalten.

Wenn ein Prompt abgerufen wird (`prompts/get`), liefert der Server eine Sequenz von Nachrichten, die an das LLM gesendet werden sollen. Jede Nachricht in dieser Sequenz hat 28:

- **`role: string`**: Entweder `"user"` oder `"assistant"`, um den Sprecher anzugeben.
- **`content: object`**: Der Inhalt der Nachricht, der verschiedene Typen annehmen kann:
    - **Text Content**: `{ "type": "text", "text": "..." }`
    - **Image Content**: `{ "type": "image", "data": "BASE64_ENCODED_IMAGE_DATA", "mimeType": "image/png" }` (muss Base64-kodiert sein und einen gültigen MIME-Typ haben)
    - **Embedded Resources**: `{ "type": "resource", "resource": { "uri": "...", "mimeType": "...", "text": "..." / "blob": "..." } }` (ermöglicht das direkte Einbetten von Server-verwalteten Ressourceninhalten)

**JSON Beispiel für eine Prompt-Definition (in einer `prompts/list`-Antwort, abgeleitet von 30):**

JSON

```
{
  "name": "analyze-code",
  "description": "Analyze code for potential improvements",
  "arguments":
}
```

#### 5.3.2. Entdeckung (`prompts/list`) und Abruf (`prompts/get`)

- **`prompts/list`**: Clients verwenden diese Methode, um eine Liste der vom Server angebotenen Prompts zu erhalten.14
- **`prompts/get`**: Mit dieser Methode ruft ein Client einen spezifischen Prompt ab. Dabei können Argumente übergeben werden, um den Prompt zu personalisieren oder mit spezifischen Daten zu füllen.14 Die Serverantwort enthält die resultierenden Nachrichten für das LLM.

Die Fähigkeit des Servers, über Änderungen in der Prompt-Liste zu informieren (`listChanged`), wird ebenfalls während der Initialisierung ausgehandelt.28

**JSON Beispiel für eine `prompts/get`-Antwort (abgeleitet von 28):**

JSON

```
{
  "jsonrpc": "2.0",
  "id": "getPrompt456",
  "result": {
    "description": "Analyze Python code for potential improvements",
    "messages":
  }
}
```

#### 5.3.3. Einbetten von Ressourcenkontext in Prompts

Prompts können Kontext aus Ressourcen einbetten, indem sie entweder direkt Ressourceninhalte in die Nachrichtenstruktur aufnehmen (wie im `Embedded Resources`-Typ oben gezeigt) oder indem sie auf Ressourcen-URIs verweisen, die der Client dann separat laden könnte.14 Dies ermöglicht es, LLM-Interaktionen mit spezifischen, aktuellen Informationen zu grundieren, die von MCP-Servern verwaltet werden, und fördert so reichhaltige, kontextualisierte Dialoge. Prompts dienen somit als Mechanismus zur Kapselung gängiger Interaktionsmuster, was die Konsistenz und Wiederverwendbarkeit fördert und die Benutzererfahrung durch klare, geführte Abläufe verbessert.14

## 6. Absicherung von MCP: Sicherheits- und Autorisierungsframework

Die Mächtigkeit des Model-Context-Protocol, das den Zugriff auf beliebige Daten und die Ausführung von Code ermöglicht, erfordert ein robustes Sicherheits- und Autorisierungsframework. Alle Implementierer müssen diese Aspekte sorgfältig berücksichtigen.8

### 6.1. Fundamentale Sicherheitsprinzipien: Benutzerzustimmung, Datenschutz, Werkzeugsicherheit

MCP basiert auf mehreren Kernprinzipien, um Vertrauen und Sicherheit zu gewährleisten 1:

- **Benutzerzustimmung und -kontrolle (User Consent and Control):** Benutzer müssen explizit allen Datenzugriffen und Operationen zustimmen und deren Umfang verstehen. Sie müssen die Kontrolle darüber behalten, welche Daten geteilt und welche Aktionen ausgeführt werden. Implementierungen sollten klare Benutzeroberflächen für die Überprüfung und Autorisierung von Aktivitäten bereitstellen.8 Der Host spielt hierbei eine zentrale Rolle bei der Verwaltung dieser Zustimmungsprozesse.1
- **Datenschutz (Data Privacy):** Hosts müssen die explizite Zustimmung des Benutzers einholen, bevor Benutzerdaten an Server weitergegeben werden. Benutzerdaten dürfen nicht ohne Zustimmung an anderer Stelle übertragen werden und sollten durch angemessene Zugriffskontrollen geschützt werden.8
- **Werkzeugsicherheit (Tool Safety):** Tools repräsentieren die Ausführung von beliebigem Code und müssen mit entsprechender Vorsicht behandelt werden. Beschreibungen des Tool-Verhaltens (z.B. Annotationen) sollten als nicht vertrauenswürdig betrachtet werden, es sei denn, sie stammen von einem vertrauenswürdigen Server. Hosts müssen die explizite Zustimmung des Benutzers einholen, bevor ein Tool aufgerufen wird, und Benutzer sollten verstehen, was jedes Tool tut, bevor sie dessen Verwendung autorisieren.8 Klare visuelle Indikatoren bei der Tool-Ausführung sind empfehlenswert.26 Das Prinzip des "Menschen im Kontrollkreis" (human in the loop) ist hierbei zentral.2
- **Kontrollen für LLM-Sampling (LLM Sampling Controls):** Benutzer müssen explizit allen LLM-Sampling-Anfragen zustimmen und kontrollieren können, ob Sampling überhaupt stattfindet, welcher Prompt gesendet wird und welche Ergebnisse der Server sehen kann. Das Protokoll schränkt die Sichtbarkeit des Servers auf Prompts absichtlich ein.8

Obwohl MCP diese Prinzipien nicht immer auf Protokollebene erzwingen kann, sollten Implementierer robuste Zustimmungs- und Autorisierungsflüsse in ihre Anwendungen integrieren und Sicherheitsbest Practices befolgen.8 Die Verantwortung für die korrekte Implementierung dieser Mechanismen liegt maßgeblich bei der Host-Anwendung.

### 6.2. Autorisierungsstrategien: OAuth 2.1 mit PKCE

Mit der zunehmenden Verbreitung von MCP, insbesondere im Kontext von entfernten Servern, wurde ein standardisierter Autorisierungsmechanismus notwendig. MCP hat OAuth 2.1 als Standard für die Autorisierung übernommen, insbesondere für Verbindungen zu Servern, die nicht lokal und vertrauenswürdig sind.31 Dies ist in der Protokollrevision `2025-03-26` formalisiert.31

Ein Schlüsselelement ist die **verbindliche Nutzung von PKCE (Proof Key for Code Exchange)** für öffentliche Clients (wie Desktop-Anwendungen oder CLI-Tools).31 PKCE schützt vor dem Abfangen des Autorisierungscodes, einem kritischen Angriffsszenario bei OAuth-Flüssen mit öffentlichen Clients.33 Die Integration von OAuth 2.1 spiegelt die Reifung des Protokolls und die Notwendigkeit wider, Interaktionen mit potenziell von Dritten betriebenen MCP-Servern abzusichern.

### 6.3. Integration mit Identity Providern (IdPs)

Die ursprüngliche MCP-Autorisierungsspezifikation legte nahe, dass der MCP-Server sowohl als Ressourcenserver als auch als Autorisierungsserver fungieren könnte, was eine erhebliche Implementierungskomplexität für Server-Entwickler darstellt.33 Ein Request For Comments (RFC) und die Community-Diskussion zielen darauf ab, diesen Ansatz zu verbessern.31

Die empfohlene Vorgehensweise ist nun, dass MCP-Server als **OAuth 2.1 Ressourcenserver** agieren und sich für die Ausstellung von Zugriffstokens auf **etablierte Identity Provider (IdPs)** verlassen.31 Dies hat mehrere Vorteile:

- Entwickler von MCP-Servern müssen keine OAuth-Experten sein oder komplexe Autorisierungsserver von Grund auf neu erstellen.31
- Es fördert die Standardisierung um gängige OAuth-Muster.
- Es sorgt für eine klare Trennung der Zuständigkeiten: Der IdP ist für die Authentifizierung und Token-Ausstellung zuständig, der MCP-Server für die Validierung der Tokens und die Durchsetzung von Berechtigungen.

Ein Beispiel für einen solchen externen IdP ist Stytch, das OAuth-Flüsse, Client-Registrierung und Token-Ausstellung übernehmen kann.32 MCP-Clients würden Benutzer zum IdP umleiten, um Tokens zu erhalten, die dann zur Authentifizierung gegenüber dem MCP-Server verwendet werden.33

### 6.4. Definition und Verwaltung von Scopes für granulare Zugriffskontrolle

Scopes (Berechtigungsbereiche) sind ein integraler Bestandteil von OAuth und spielen eine wichtige Rolle bei der Definition granularer Zugriffsberechtigungen im MCP.12 Sie bestimmen, welche Tools, Ressourcen oder spezifischen Operationen ein Client (und damit das LLM) im Namen des Benutzers ausführen darf.

Ein Beispiel ist der Merge MCP-Server, der Scopes im Format `<Kategorie>.<CommonModelName>:<Berechtigung>` verwendet, z.B. `ats.Candidate:read` für Lesezugriff auf Kandidatenobjekte im Bewerbermanagementsystem (ATS) oder `hris.Employee:write` für Schreibzugriff auf Mitarbeiterobjekte im HRIS.12

Wichtige Aspekte bei der Verwendung von Scopes:

- **Validierung:** MCP-Server müssen die vom Client angeforderten Scopes gegen die für das verknüpfte Konto oder den Benutzer tatsächlich aktivierten Berechtigungen validieren. Nur Tools und Ressourcen, die den gültigen und autorisierten Scopes entsprechen, werden aktiviert.12
- **Fehlerbehandlung:** Clients müssen darauf vorbereitet sein, dass angeforderte Scopes möglicherweise nicht gewährt werden (z.B. aufgrund von Kategorie- oder Berechtigungs-Nichtübereinstimmungen) und entsprechende Fehlermeldungen oder alternative Pfade implementieren.12

Scopes ermöglichen die Umsetzung des Prinzips der geringsten Rechte (Principle of Least Privilege), indem sichergestellt wird, dass Clients nur auf die Daten und Funktionen zugreifen, für die sie explizit autorisiert wurden. Dies ist besonders wichtig beim Umgang mit potenziell sensiblen Daten in Unternehmenssystemen.

### 6.5. Best Practices für sichere Client- und Server-Implementierungen

Zusätzlich zu den spezifischen Autorisierungsmechanismen sollten Entwickler von MCP-Clients und -Servern allgemeine Sicherheitsbest Practices befolgen 14:

- **Eingabevalidierung und -bereinigung:** Alle von Clients empfangenen Eingaben (z.B. Tool-Parameter, Ressourcen-URIs) müssen serverseitig rigoros validiert und bereinigt werden, um Injection-Angriffe und andere Sicherheitslücken zu verhindern.
- **Sichere Transporte:** Bei Netzwerktransporten wie HTTP/SSE ist die Verwendung von TLS zur Verschlüsselung der Datenübertragung unerlässlich.
- **Verschlüsselung sensibler Daten:** Sensible Daten sollten sowohl bei der Übertragung als auch im Ruhezustand (at rest) verschlüsselt werden.
- **Validierung der Nachrichtenintegrität:** Mechanismen zur Sicherstellung, dass Nachrichten während der Übertragung nicht manipuliert wurden.
- **Begrenzung der Nachrichtengröße:** Implementierung von Limits für die Größe von Nachrichten, um Denial-of-Service-Angriffe durch übergroße Nachrichten zu verhindern.
- **Vorsicht bei Binärdaten:** Sorgfältige Handhabung von Binärdaten, um Pufferüberläufe oder andere damit verbundene Schwachstellen zu vermeiden.

Durch die Kombination dieser fundamentalen Sicherheitsprinzipien, der standardisierten OAuth 2.1-Autorisierung und allgemeiner Best Practices strebt MCP danach, ein sicheres und vertrauenswürdiges Ökosystem für die Erweiterung von KI-Fähigkeiten zu schaffen.

## 7. Integration von MCP in Linux Desktop Widgets: Ein praktischer Leitfaden

Die Integration des Model-Context-Protocol (MCP) in Linux Desktop-Widgets eröffnet spannende Möglichkeiten, um diese kleinen, fokussierten Anwendungen intelligenter, kontextbewusster und stärker vernetzt zu gestalten. Dieser Abschnitt untersucht, wie MCP in gängige Linux-Widget-Technologien eingebettet werden kann.

### 7.1. Überblick über Linux Desktop-Widget-Technologien

Verschiedene Frameworks eignen sich für die Entwicklung von Desktop-Widgets unter Linux. Die Wahl hängt oft von der Ziel-Desktop-Umgebung, den bevorzugten Programmiersprachen und den spezifischen Anforderungen des Widgets ab.

#### 7.1.1. GTK (Gtk3/Gtk4) mit C/Python

GTK (GIMP Toolkit) ist ein weit verbreitetes, plattformübergreifendes Widget-Toolkit, das die Grundlage für die GNOME-Desktop-Umgebung bildet, aber auch in anderen Umgebungen eingesetzt wird.34 Es bietet einen umfassenden Satz an UI-Elementen und ist für Projekte jeder Größenordnung geeignet.35 GTK ist in C geschrieben, verfügt aber über stabile Bindungen zu vielen anderen Sprachen, darunter C++, Python, JavaScript und Rust, was die Integration von MCP-SDKs (insbesondere Python und JavaScript) erleichtert.35 GTK ist Open Source unter der LGPL lizenziert.35

#### 7.1.2. Qt/QML mit C++/Python

Qt ist ein leistungsstarkes, plattformübergreifendes Anwendungsframework, das häufig für die Entwicklung grafischer Benutzeroberflächen verwendet wird.36 Es bietet die Qt Widgets für traditionelle UIs und QML, eine deklarative Sprache, für moderne, flüssige Benutzeroberflächen.36 Qt wird mit dem Qt Creator, einer umfangreichen IDE, geliefert und unterstützt primär C++, bietet aber auch exzellente Python-Bindungen (PyQt oder PySide).36 Dies macht es ebenfalls zu einem guten Kandidaten für die Integration von MCP-SDKs.

#### 7.1.3. KDE Plasma Widgets (Plasmoids)

Plasma Widgets, auch Plasmoids genannt, sind speziell für die KDE Plasma Desktop-Umgebung konzipiert.38 Sie ermöglichen eine tiefe Integration in den Desktop und können vielfältige Funktionen bereitstellen, von einfachen Anzeigen (z.B. Wörterbuch, Ordneransicht 38) bis hin zu komplexeren Interaktionen. Die Entwicklung von Plasmoids erfolgt häufig mit QML und JavaScript, was eine direkte Nutzung des JavaScript/TypeScript MCP SDKs ermöglicht.39 Entwickler können bestehende Widgets als Vorlage nutzen und anpassen.39

#### 7.1.4. GNOME Shell Extensions

GNOME Shell Extensions erweitern die Funktionalität der GNOME Shell und werden typischerweise in JavaScript unter Verwendung von GJS (GNOME JavaScript Bindings) und Clutter für die UI-Darstellung geschrieben.40 Sie können UI-Elemente zur oberen Leiste hinzufügen, das Verhalten des Aktivitäten-Overviews ändern oder neue Dialoge und Popups erstellen.40 Die JavaScript-Basis macht sie zu einem natürlichen Kandidaten für die Integration des TypeScript/JavaScript MCP SDK.

Die folgende Tabelle vergleicht diese Technologien im Hinblick auf eine MCP-Integration:

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Technologie**|**Primäre Sprache(n)**|**UI-Paradigma**|**Eignung für MCP SDK-Integration (Python/JS Fokus)**|**Sandboxing/Sicherheit (typisch)**|**Darstellung reichhaltiger Inhalte (z.B. HTML/CSS)**|
|GTK (Gtk3/Gtk4)|C, Python, JS, Rust|Imperativ|Sehr gut (Python, JS)|Anwendungsabhängig|WebKitGTK für HTML/CSS, Pango für Rich Text|
|Qt/QML|C++, Python|Imperativ (Widgets), Deklarativ (QML)|Sehr gut (Python, JS in QML)|Anwendungsabhängig|QtWebEngine für HTML/CSS, Rich Text in Widgets|
|KDE Plasma Widgets|QML/JS, C++|Deklarativ/Imperativ|Exzellent (JS in QML)|Plasma-spezifisch|QtWebEngine über QML|
|GNOME Shell Ext.|JavaScript (GJS)|Imperativ (Clutter)|Exzellent (JS)|GNOME Shell-spezifisch|Begrenzt (St.Label mit Pango Markup), keine direkte Webview-Einbettung im Panel|

Die meisten dieser Technologien bieten robuste Entwicklungsumgebungen und unterstützen Sprachen, für die MCP SDKs existieren oder leicht angebunden werden können. Die Wahl wird oft von der gewünschten Integrationstiefe in die Desktop-Umgebung und der Komplexität der darzustellenden MCP-Informationen beeinflusst.

### 7.2. Architekturelle Überlegungen für MCP-fähige Widgets

Bei der Entwicklung eines MCP-fähigen Desktop-Widgets muss dessen Rolle innerhalb der MCP-Architektur klar definiert werden.

#### 7.2.1. Widget als MCP Host vs. Client innerhalb eines größeren Hosts

Es gibt zwei Hauptmuster:

1. **Das Widget als MCP Host:** Das Desktop-Widget agiert selbstständig als MCP Host-Anwendung.1 Es initialisiert und verwaltet seine eigenen MCP Client-Instanzen, um sich mit einem oder mehreren MCP Servern zu verbinden (z.B. ein Wetter-Widget, das sich mit einem Wetter-MCP-Server verbindet). Dieses Modell ist in sich geschlossen und gibt dem Widget volle Kontrolle über seine MCP-Interaktionen.
2. **Das Widget als reiner UI-Client für einen größeren Host:** Das Widget ist Teil einer umfassenderen Desktop-Anwendung oder eines Dienstes (z.B. vergleichbar mit PiecesOS 11 oder Claude Desktop 43), der als zentraler MCP Host für den Benutzer fungiert. In diesem Szenario ist das Widget primär für die Darstellung von Daten oder die Bereitstellung von UI-Elementen zuständig, die vom übergeordneten Host orchestriert werden. Das Widget selbst würde dann keine direkten MCP-Client-Verbindungen zu externen Servern aufbauen, sondern mit dem lokalen, zentralen Host kommunizieren (möglicherweise über proprietäre IPC oder eine vereinfachte Schnittstelle). Dieses Modell kann die Komplexität des einzelnen Widgets reduzieren und eine zentralisierte Verwaltung von MCP-Verbindungen und Benutzerberechtigungen ermöglichen.

Die Entscheidung zwischen diesen Mustern beeinflusst die Komplexität, die Verantwortlichkeiten und das Ressourcenmanagement des Widgets.

#### 7.2.2. Interprozesskommunikation (IPC), falls das Widget ein separater Prozess ist

Wenn das Widget als eigenständige Anwendung läuft (z.B. eine separate GTK- oder Qt-Anwendung) und mit einem zentralen MCP-Host-Prozess (z.B. einem Hintergrunddienst, der MCP-Verbindungen für den Benutzer verwaltet) kommunizieren muss, sind Mechanismen zur Interprozesskommunikation (IPC) erforderlich. Unter Linux kommen hierfür häufig D-Bus oder Sockets in Frage. Dieses Szenario ist relevant, wenn eine zentralisierte Verwaltung von MCP-Kontext und -Sicherheit über mehrere Widgets oder Anwendungen hinweg gewünscht wird.

### 7.3. Strategien zur Darstellung dynamischer UI-Inhalte von MCP-Servern

Ein Kernaspekt MCP-fähiger Widgets ist die dynamische Darstellung von Informationen, die von MCP-Servern stammen. Dies kann von einfachem Text bis hin zu komplexen, interaktiven UI-Elementen reichen.

#### 7.3.1. Serverseitig gerenderte UI-Schnipsel (HTML/CSS via MCP)

Ein vielversprechendes Muster, demonstriert durch das `mcp-widgets`-Projekt 44, besteht darin, dass der MCP-Server direkt HTML/CSS-Schnipsel als Teil seiner Antwort liefert. Das Widget auf dem Desktop, das eine Web-Rendering-Engine einbetten kann, ist dann lediglich für die Darstellung dieses HTML/CSS zuständig.

- **Vorteile:** Die UI-Logik und das Rendering-Know-how können auf dem Server liegen, was das Widget selbst vereinfacht. Änderungen am UI-Aussehen können serverseitig erfolgen, ohne das Widget neu kompilieren oder verteilen zu müssen.
- **Nachteile:** Weniger Flexibilität für tiefgreifende native Integrationen oder die Nutzung nativer Widget-Funktionen. Erfordert, dass der Server UI-Komponenten generiert.

#### 7.3.2. Clientseitiges Rendering unter Verwendung von Daten aus MCP (Native Widgets oder eingebettete Webansichten)

Alternativ empfängt das Widget strukturierte Daten (typischerweise JSON) vom MCP-Server und ist selbst für das Rendering der Benutzeroberfläche verantwortlich. Dies kann durch native UI-Elemente des gewählten Widget-Frameworks oder durch dynamische Generierung von HTML/CSS für eine eingebettete Webansicht geschehen.

##### 7.3.2.1. Einbetten von HTML/CSS in GTK: `WebKitWebView`

GTK-Anwendungen können `WebKitWebView` (oder `WebView` in neueren GTK-Versionen, die WebKitGTK verwenden) nutzen, um Webinhalte darzustellen.45 Dies ist ideal, um von MCP-Servern gelieferte HTML/CSS-Schnipsel anzuzeigen oder um auf Basis von MCP-Daten dynamisch HTML zu generieren.

- `webkit_web_view_load_html(webview, html_string, base_uri)`: Lädt einen HTML-String direkt.48 Der `base_uri` ist wichtig für die Auflösung relativer Pfade (z.B. für Bilder, CSS-Dateien innerhalb des HTML).
- `webkit_web_view_load_uri(webview, uri)`: Lädt Inhalte von einer URL.
- Sicherheitsaspekte beim Laden lokaler Dateien über `file:///`-URIs müssen beachtet werden.48

##### 7.3.2.2. Einbetten von HTML/CSS in Qt/QML: `QWebEngineView`

Qt bietet `QWebEngineView` für die Integration von Webinhalten in Qt Widgets und QML-Anwendungen.50

- `loadHtml(html_string, base_url)`: Methode des `WebEngineView` QML-Typs (oder der C++ Klasse) zum Laden eines HTML-Strings.54
- `setUrl(url)`: Lädt Inhalte von einer URL.
- **Kommunikation zwischen QML/C++ und der Webseite:** Qt WebChannel (`webChannel`-Eigenschaft in QML) ermöglicht eine bidirektionale Kommunikation zwischen dem QML/C++ Code und JavaScript innerhalb der geladenen Webseite.50 Dies kann nützlich sein, um Interaktionen innerhalb des HTML-Widgets zurück an die native Widget-Logik zu leiten.

##### 7.3.2.3. Natives Styling und Rich Text

Für weniger komplexe Darstellungen oder wenn eine Webview nicht gewünscht ist:

- **GTK CSS:** GTK-Widgets können mit CSS-ähnlichen Regeln gestaltet werden, was eine flexible Anpassung des Erscheinungsbilds nativer Widgets ermöglicht.57
- **Pango Markup (GTK/GNOME Shell):** Für Rich-Text-Darstellungen in GTK-Labels (und `St.Label` in GNOME Shell Extensions, das intern Pango verwendet) kann Pango Markup genutzt werden. Dies ist eine XML-ähnliche Syntax, um Textformatierungen wie Fett, Kursiv, Farben und Schriftarten direkt im Textstring zu definieren [60 (Qt-Kontext, aber Pango ist ähnlich), 59].
    - Beispiel Pango Markup: `<span foreground="blue" size="x-large">Blauer Text</span> ist <i>cool</i>!`.59
- **Qt Rich Text:** Qt-Widgets wie `QLabel` unterstützen eine Untermenge von HTML 4 für Rich-Text-Formatierungen.60

Die `mcp-widgets`-Strategie 44, bei der Server HTML/CSS liefern, ist für Desktop-Widgets besonders attraktiv, da sowohl GTK als auch Qt ausgereifte Webview-Komponenten bieten. Dies kann die Logik im Widget-Client erheblich vereinfachen. Die Wahl zwischen serverseitig gerenderter UI und clientseitigem Rendering basierend auf MCP-Daten ist jedoch ein Kompromiss: Serverseitiges Rendering vereinfacht die Client-Logik, ist aber möglicherweise weniger flexibel für eine tiefe native Integration; clientseitiges Rendering bietet mehr Kontrolle, erfordert aber mehr UI-Code im Widget.

### 7.4. Implementierung der MCP-Client-Logik in Widgets

Die Kernfunktionalität eines MCP-fähigen Widgets ist seine Fähigkeit, als MCP-Client zu agieren (oder mit einem übergeordneten Host zu kommunizieren, der als Client agiert).

#### 7.4.1. Nutzung offizieller MCP SDKs (Python, C++ über Bindings oder direktes JSON-RPC)

Die Model Context Protocol Organisation stellt offizielle SDKs für verschiedene Sprachen zur Verfügung, die die Implementierung von MCP-Clients und -Servern erheblich vereinfachen.61

- **Python SDK:** (]) Weit verbreitet und gut geeignet für die Entwicklung mit GTK (über PyGObject) und Qt (über PyQt/PySide).3 Das OpenAI Agents SDK enthält ebenfalls Unterstützung für MCP-Interaktionen mit Python.3
- **TypeScript/JavaScript SDK:** (`@modelcontextprotocol/sdk` 21) Ideal für GNOME Shell Extensions (GJS) und QML-basierte Plasma Widgets, die JavaScript als Skriptsprache verwenden.61
- **C# SDK:** (61) Könnte relevant sein, wenn.NET/Mono für die Widget-Entwicklung unter Linux verwendet wird.
- **Java und Kotlin SDKs:** (61) Weniger typisch für Linux Desktop-Widgets, aber vorhanden.
- **Rust SDK:** (61) Eine Option für performance-kritische Komponenten oder wenn Rust bevorzugt wird.
- **C++:** Zum Zeitpunkt der Recherche ist kein offizielles, breit hervorgehobenes C++ SDK so prominent wie die Python- oder JS-SDKs. Entwickler, die C++ für GTK oder Qt verwenden, müssten möglicherweise:
    1. Eine generische JSON-RPC-Bibliothek für C++ verwenden und die MCP-spezifischen Nachrichten und den Sitzungslebenszyklus manuell implementieren.
    2. Auf ein offizielles C++ SDK warten oder dazu beitragen.
    3. Wrapper um das C-API eines potenziellen zukünftigen C-SDKs erstellen.

Die Verfügbarkeit von Python- und JavaScript-SDKs passt gut zu den gängigen Skriptsprachen in der Linux-Desktop-Widget-Entwicklung. Für C++-basierte Widgets stellt dies eine größere Herausforderung dar, die entweder durch Eigenimplementierung des Protokolls oder durch Nutzung von Bindings zu anderen SDKs (falls möglich und performant) gelöst werden muss.

### 7.5. Beispielintegration 1: "Smart Clipboard"-Widget (GTK/Python mit Textverarbeitungs-MCP-Server)

Dieses Beispiel skizziert ein GTK-Widget, das den Inhalt der Zwischenablage überwacht und bei Bedarf eine Analyse über einen MCP-Server anbietet.

#### 7.5.1. Konzeptuelles Design und UI-Mockup

- **UI:** Ein einfaches GTK-Fenster oder Panel-Applet.
    - Ein mehrzeiliges Textfeld (`GtkTextView`), das den aktuellen Inhalt der Zwischenablage anzeigt (optional).
    - Ein Button "Zwischenablage analysieren (MCP)".
    - Ein Bereich zur Anzeige der Analyseergebnisse (z.B. als formatierter Text oder in strukturierten `GtkLabel`s).
- **Funktionalität:**
    1. Das Widget überwacht Änderungen in der Systemzwischenablage.
    2. Wenn neuer Textinhalt erkannt wird, wird der Button "Analysieren" aktiv.
    3. Bei Klick auf den Button:
        - Der Widget-Client verbindet sich mit einem (hypothetischen) `text_analyzer_mcp_server`.
        - Der Inhalt der Zwischenablage wird an ein Tool dieses Servers gesendet.
        - Das Ergebnis (z.B. Sentiment, Entitätenextraktion, Zusammenfassung) wird im Widget angezeigt.

#### 7.5.2. MCP-Client-Implementierung in Python (mit GTK)

Python

```
import gi
gi.require_version('Gtk', '4.0') # Oder '3.0'
from gi.repository import Gtk, Gdk, GLib
# Annahme: Das Python MCP SDK ist installiert und importierbar
# from modelcontextprotocol import MCPServerStdio, MCPServerSse # Beispielhafte Importe

# Hypothetischer MCP Server (lokal via stdio)
TEXT_ANALYZER_SERVER_COMMAND = ["python", "path/to/text_analyzer_mcp_server.py"]

class SmartClipboardWidget(Gtk.ApplicationWindow):
    def __init__(self, app):
        super().__init__(application=app, title="Smart Clipboard (MCP)")
        self.set_default_size(400, 300)

        self.clipboard = Gdk.Display.get_default().get_primary_clipboard()
        self.clipboard.connect("notify::text", self.on_clipboard_changed)

        self.vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        self.set_child(self.vbox)

        self.clipboard_display = Gtk.Label(label="Zwischenablage wird überwacht...")
        self.vbox.append(self.clipboard_display)

        self.analyze_button = Gtk.Button(label="Zwischenablage analysieren (MCP)")
        self.analyze_button.connect("clicked", self.on_analyze_clicked)
        self.analyze_button.set_sensitive(False)
        self.vbox.append(self.analyze_button)

        self.result_display = Gtk.Label(label="Analyseergebnis hier.")
        self.result_display.set_wrap(True)
        self.vbox.append(self.result_display)

        self.mcp_server_instance = None # Für die MCP-Server-Verbindung

    def on_clipboard_changed(self, clipboard, _props):
        text = clipboard.read_text_async(None, self._clipboard_read_callback)

    def _clipboard_read_callback(self, clipboard, result):
        text = clipboard.read_text_finish(result)
        if text:
            self.clipboard_display.set_text(f"Aktuell: {text[:50]}...")
            self.analyze_button.set_sensitive(True)
            self.current_clipboard_text = text
        else:
            self.analyze_button.set_sensitive(False)

    async def initialize_mcp_client(self):
        # Dieser Teil ist pseudocodeartig, da das genaue SDK-API variieren kann
        # Beispiel für stdio server
        # self.mcp_server_instance = MCPServerStdio(params={
        # "command": TEXT_ANALYZER_SERVER_COMMAND,
        # "args": TEXT_ANALYZER_SERVER_COMMAND[1:],
        # })
        # await self.mcp_server_instance.connect() # Annahme einer connect Methode
        # tools = await self.mcp_server_instance.list_tools()
        # if any(tool.name == "analyze_clipboard_content" for tool in tools):
        #     return True
        # return False
        print("MCP Client Initialisierung (Platzhalter)")
        return True # Simuliere Erfolg

    async def call_mcp_tool(self, tool_name, arguments):
        # if self.mcp_server_instance:
        #     try:
        #         result = await self.mcp_server_instance.call_tool(name=tool_name, arguments=arguments)
        #         return result
        #     except Exception as e:
        #         return {"isError": True, "content": [{"type": "text", "text": f"MCP Fehler: {e}"}]}
        print(f"MCP Tool Aufruf (Platzhalter): {tool_name} mit {arguments}")
        # Simuliere eine Antwort
        return {"isError": False, "content": [{"type": "text", "text": f"Analyse für '{arguments.get('text', '')[:20]}...': Positiv."}]}


    def on_analyze_clicked(self, _widget):
        if not hasattr(self, "current_clipboard_text") or not self.current_clipboard_text:
            self.result_display.set_text("Kein Text in der Zwischenablage.")
            return

        self.result_display.set_text("Analysiere...")

        async def analyze_task():
            if not self.mcp_server_instance: # Oder eine bessere Zustandsprüfung
                initialized = await self.initialize_mcp_client()
                if not initialized:
                    self.result_display.set_text("MCP Server nicht initialisierbar.")
                    return

            tool_result = await self.call_mcp_tool(
                tool_name="analyze_clipboard_content",
                arguments={"text": self.current_clipboard_text}
            )

            if tool_result.get("isError"):
                error_message = tool_result.get("content", [{"type": "text", "text": "Unbekannter Fehler"}]).get("text")
                self.result_display.set_markup(f"<span foreground='red'>Fehler: {GLib.markup_escape_text(error_message)}</span>")
            else:
                # Annahme: Ergebnis ist Text
                analysis = tool_result.get("content",).get("text", "Kein Ergebnis.")
                # Pango Markup für Formatierung verwenden [59]
                self.result_display.set_markup(f"<b>Analyse:</b>\n{GLib.markup_escape_text(analysis)}")

        # Ausführung der asynchronen Aufgabe in GTK
        GLib.idle_add(lambda: GLib.ensure_future(analyze_task()) and False)


class SmartClipboardApp(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="org.example.smartclipboardmcp")

    def do_activate(self):
        win = SmartClipboardWidget(self)
        win.present()

# app = SmartClipboardApp()
# exit_status = app.run() # Deaktiviert für diesen Bericht, da es eine laufende Anwendung erfordert
```

_Hinweis: Der obige Python-Code ist konzeptionell und verwendet Platzhalter für die eigentliche MCP SDK-Interaktion, da die genauen API-Aufrufe vom spezifischen Python MCP SDK abhängen. Die GTK-Teile sind jedoch funktional._

#### 7.5.3. Interaktion mit einem hypothetischen Textanalyse-MCP-Server (Tool: `analyze_clipboard_content`)

- **Tool-Definition auf dem Server (konzeptionell):**
    - Name: `analyze_clipboard_content`
    - `inputSchema`: `{ "type": "object", "properties": { "text": { "type": "string" } }, "required": ["text"] }`
    - Funktionalität: Nimmt einen Textstring entgegen, führt NLP-Aufgaben durch (z.B. Sentimentanalyse, Entitätserkennung, Schlüsselworterkennung, kurze Zusammenfassung).
    - `result`: `{ "content": }`
- **Widget-Interaktion:**
    1. Der Client im Widget sendet eine `tools/call`-Anfrage an den `text_analyzer_mcp_server` mit der Methode `analyze_clipboard_content` und dem Zwischenablageninhalt als `text`-Parameter.
    2. Der Server verarbeitet den Text und gibt das strukturierte Ergebnis zurück.
    3. Das GTK-Widget parst die Antwort und zeigt die Analyseergebnisse an. Pango Markup 59 kann verwendet werden, um die Ergebnisse formatiert in einem `GtkLabel` oder `GtkTextView` darzustellen (z.B. verschiedene Farben für Sentiment, fette Überschriften für Entitäten).

### 7.6. Beispielintegration 2: "Kontextueller Aufgabenhelfer"-Widget (Qt/QML/C++ mit Kalender- & Dateisystem-MCP-Servern)

Dieses Beispiel beschreibt ein Widget, das kontextbezogene Informationen aus Kalender- und Dateisystemdaten aggregiert, um den Benutzer bei seinen aktuellen Aufgaben zu unterstützen.

#### 7.6.1. Konzeptuelles Design und UI-Mockup

- **UI (QML):**
    - Eine Liste oder Ansicht (`ListView`, `GridView`) für bevorstehende Kalenderereignisse für den aktuellen Tag.
    - Ein Bereich, der relevante Dateien oder Dokumente anzeigt, die mit den aktuellen Kalenderereignissen oder kürzlich bearbeiteten Projekten in Verbindung stehen.
    - Möglicherweise eine Suchfunktion, um innerhalb des kontextuellen Aufgabenbereichs zu suchen.
    - Wenn die MCP-Server HTML/CSS-Snippets zurückgeben (inspiriert von `mcp-widgets` 44), könnte ein `WebEngineView` 54 zur Darstellung verwendet werden.
- **Funktionalität:**
    1. Das Widget verbindet sich beim Start mit einem `calendar_mcp_server` und einem `filesystem_mcp_server`.
    2. Es ruft Kalenderereignisse für den aktuellen Tag/die nahe Zukunft ab.
    3. Basierend auf den Ereignissen (z.B. Projektnamen, Teilnehmer) oder kürzlichen Aktivitäten fragt es den `filesystem_mcp_server` nach relevanten Dateien.
    4. Die aggregierten Informationen werden dem Benutzer übersichtlich präsentiert.

#### 7.6.2. MCP-Client-Implementierung in C++ (mit Qt/QML)

- **Architektur:** Die C++-Backend-Logik des Widgets würde als MCP Host agieren und zwei MCP Client-Instanzen verwalten, eine für jeden Server.
- **Verbindungsaufbau:** Code zum Herstellen von Verbindungen zu `calendar_mcp_server` und `filesystem_mcp_server` (z.B. über `stdio` für lokale Server oder HTTP/SSE für entfernte). Dies würde die Implementierung des JSON-RPC-Austauschs und des MCP-Lebenszyklus erfordern, wenn kein C++ SDK verwendet wird.
- **Datenmodell in C++:** Klassen zur Repräsentation von Kalenderereignissen und Dateiinformationen, die von den MCP-Servern empfangen werden.
- **Exposition gegenüber QML:** Die C++-Logik würde die verarbeiteten Daten und Funktionen über das Qt-Eigenschaftssystem und invokable Methoden für die QML-Frontend-Schicht verfügbar machen.

C++

```
// Konzeptioneller C++ Code-Ausschnitt (stark vereinfacht)
// Annahme: Eine JSON-RPC Bibliothek und manuelle MCP-Implementierung oder ein C++ MCP SDK existiert.

// #include <QObject>
// #include <QJsonObject>
// #include <QJsonArray>
// #include <QQmlApplicationEngine>
// #include <QtWebEngineQuick/QtWebEngineQuick> // Für QtWebEngine::initialize() in main

// class McpClientWrapper : public QObject { /*... */ }; // Wrapper für MCP-Client-Logik

class TaskHelperBackend : public QObject {
    Q_OBJECT
    // Q_PROPERTY(QVariantList calendarEvents READ calendarEvents NOTIFY calendarEventsChanged)
    // Q_PROPERTY(QVariantList relevantFiles READ relevantFiles NOTIFY relevantFilesChanged)

public:
    explicit TaskHelperBackend(QObject *parent = nullptr) : QObject(parent) {
        // m_calendarClient = new McpClientWrapper("calendar_mcp_server_config");
        // m_filesystemClient = new McpClientWrapper("filesystem_mcp_server_config");
        // connect_mcp_servers_and_fetch_initial_data();
    }

// Q_INVOKABLE void refreshData() { /*... */ }

// private:
    // McpClientWrapper* m_calendarClient;
    // McpClientWrapper* m_filesystemClient;
    // QVariantList m_calendarEvents;
    // QVariantList m_relevantFiles;

    // void connect_mcp_servers_and_fetch_initial_data() {
        // Placeholder: Hier würde die Logik zum Verbinden und Abrufen von Daten stehen
        // z.B. m_calendarClient->callMethod("resources/read", {"uri": "calendar://today/events"},...);
        // z.B. m_filesystemClient->callMethod("resources/read", {"uri": "file:///projects/current?relevant=true"},...);
    // }

// signals:
    // void calendarEventsChanged();
    // void relevantFilesChanged();
};

// In main.cpp:
// QtWebEngineQuick::initialize(); // Wenn WebEngineView verwendet wird [56]
// QQmlApplicationEngine engine;
// qmlRegisterType<TaskHelperBackend>("com.example.taskhelper", 1, 0, "TaskHelperBackend");
// engine.load(QUrl(QStringLiteral("qrc:/main.qml")));
```

#### 7.6.3. Aggregation von Kontext aus Kalender- (`calendar/events`) und Dateisystem- (`file:///relevant_project_docs`) MCP-Servern

- **Kalender-Server:**
    - Das Widget (bzw. dessen C++ Backend) sendet eine `resources/read`-Anfrage an den `calendar_mcp_server` für eine Ressource wie `calendar://today/events` oder `calendar://project_alpha/next_meeting`.
    - Der Server antwortet mit einer Liste von Ereignisobjekten (z.B. Titel, Zeit, Ort, Teilnehmer).
- **Dateisystem-Server:**
    - Basierend auf Schlüsselwörtern aus den Kalenderereignissen (z.B. Projektname) oder einer Liste kürzlich verwendeter Projekte sendet das Widget `resources/read`-Anfragen an den `filesystem_mcp_server`. Beispiele für Ressourcen-URIs: `file:///projects/alpha/docs?recent=5` oder `search:///keywords=MCP,Widget&limit=10`.
    - Der Server antwortet mit einer Liste von Datei- oder Verzeichnisinformationen (Name, Pfad, Typ, Änderungsdatum).
- **Aggregation und Korrelation:**
    - Die C++-Logik im Widget aggregiert diese Daten.
    - Es könnte eine einfache Korrelation implementiert werden, z.B. Dateien anzeigen, die um die Zeit eines Kalenderereignisses herum geändert wurden oder deren Pfad Projektnamen aus Kalendereinträgen enthält.
- **Darstellung in QML:**
    - Die aggregierten und korrelierten Daten werden über das Qt-Eigenschaftssystem an die QML-Schicht übergeben.
    - QML-Elemente (`ListView`, `Repeater` etc.) rendern die Informationen. Wenn der Server HTML/CSS-Snippets liefert (z.B. eine schön formatierte Kalenderansicht), kann ein `WebEngineView` 54 in QML diese direkt anzeigen. Die `loadHtml()`-Methode des `WebEngineView` 54 wäre hierfür geeignet.

Diese Beispiele illustrieren, wie MCP-Widgets spezifische Probleme lösen können, indem sie die standardisierte Schnittstelle des MCP nutzen, um auf vielfältige Datenquellen und Werkzeuge zuzugreifen und diese intelligent zu kombinieren.

## 8. Entwicklungsplan: Erstellung MCP-gestützter Linux Desktop-Widgets

Dieser Entwicklungsplan skizziert einen strukturierten Ansatz zur Erstellung von Linux Desktop-Widgets, die das Model-Context-Protocol (MCP) nutzen. Der Plan ist in Phasen unterteilt, um eine systematische Entwicklung, Integration und Bereitstellung zu gewährleisten.

### 8.1. Phase 1: Fundament, Forschung und Prototyping

Diese initiale Phase legt den Grundstein für das gesamte Projekt.

#### 8.1.1. Detaillierte Anforderungserhebung & Anwendungsfalldefinition

- **Aktivität:** Klare Definition der spezifischen Funktionalität des/der Widgets. Wer ist die Zielgruppe? Welchen Mehrwert bietet die MCP-Integration (z.B. Zugriff auf welche Daten/Tools, welche Art von KI-Unterstützung)?
- **Entscheidung:** Identifikation der benötigten MCP-Server. Sind diese bereits vorhanden (z.B. offizielle oder Community-Server 9) oder müssen sie im Rahmen des Projekts neu entwickelt werden? Welche spezifischen Tools, Resources oder Prompts dieser Server werden benötigt?
- **Ergebnis:** Ein detailliertes Anforderungsdokument und klar definierte Anwendungsfälle.

#### 8.1.2. Auswahl des Technologie-Stacks

Basierend auf den Anforderungen und den Ergebnissen aus Abschnitt 7.1 werden hier kritische Entscheidungen getroffen:

- **Entscheidung (Widget-Framework):** Wahl des Desktop-Widget-Frameworks.
    - **Optionen:** GTK, Qt/QML, KDE Plasma, GNOME Shell Extensions.
    - **Kriterien:** Gewünschte Integrationstiefe in die Desktop-Umgebung (z.B. Plasma für KDE), vorhandene Teamkompetenzen, Komplexität der geplanten UI, Portabilitätsanforderungen.
    - **Fakt:** Für eine tiefe Integration in KDE Plasma wären Plasma Widgets (QML/JS) ideal.39 Für GNOME eignen sich GNOME Shell Extensions (JS).40 GTK und Qt sind universeller.
    - **Entscheidung für diesen Plan:** **Qt/QML** wird als primäres Framework gewählt, da es eine gute Balance zwischen nativer Performance (C++ Backend), flexibler UI-Gestaltung (QML mit JavaScript) und plattformübergreifenden Möglichkeiten bietet. Es ermöglicht auch die einfache Einbettung von Web-Inhalten über `QWebEngineView`.50
- **Entscheidung (Primäre Programmiersprache):**
    - **Optionen:** Python, C++, JavaScript.
    - **Kriterien:** Performance-Anforderungen, Verfügbarkeit von MCP SDKs, Teamkompetenzen, Kompatibilität mit dem gewählten Widget-Framework.
    - **Fakt:** Qt/QML unterstützt C++ für das Backend und JavaScript in QML.36 Python-Bindungen (PySide/PyQt) sind ebenfalls exzellent.
    - **Entscheidung für diesen Plan:** **C++** für die Kernlogik und MCP-Client-Implementierung (falls kein C++ SDK direkt nutzbar ist, dann Implementierung des JSON-RPC-Protokolls) und **QML/JavaScript** für die UI. Dies ermöglicht hohe Performance und volle Qt-Integration.
- **Entscheidung (MCP SDK / Implementierung):**
    - **Optionen:** Nutzung eines offiziellen MCP SDK (TypeScript/JS für QML-Teil, Python mit Bindings, oder direkte C++ Implementierung).
    - **Kriterien:** Reifegrad des SDKs, Sprachpräferenz, Performance.
    - **Fakt:** Es gibt offizielle TypeScript/JS und Python SDKs.61 Ein C++ SDK ist weniger prominent.
    - **Entscheidung für diesen Plan:** Das **TypeScript/JavaScript SDK** wird für Interaktionen innerhalb der QML-Schicht evaluiert. Für das C++ Backend wird zunächst die **direkte Implementierung der MCP JSON-RPC-Kommunikation** unter Verwendung einer robusten C++ JSON-Bibliothek in Betracht gezogen, falls kein adäquates C++ SDK verfügbar ist oder die Overhead-Kosten eines Bindings zu hoch sind. Die Python SDK-Option wird als Alternative für schnellere Prototypenentwicklung beibehalten.
- **Entscheidung (Ziel-MCP-Server):**
    - **Kriterien:** Verfügbarkeit, Stabilität, bereitgestellte Fähigkeiten.
    - **Entscheidung für diesen Plan:** Für die Prototyping-Phase wird zunächst der offizielle **Filesystem MCP Server** 3 und ein einfacher, selbst entwickelter **Echo- oder Test-MCP-Server** verwendet, um die Client-Implementierung zu validieren.

#### 8.1.3. Initiale MCP-Client-Implementierung

- **Aktivität:** Entwicklung einer grundlegenden MCP-Client-Logik im gewählten Technologie-Stack (C++).
- **Schritte:** Implementierung des Verbindungsaufbaus (z.B. `stdio` oder HTTP/SSE, je nach Testserver), Senden der `initialize`-Anfrage, Verarbeiten der Server-Antwort, Aushandeln der Fähigkeiten und Senden der `initialized`-Benachrichtigung.19
- **Ergebnis:** Eine Codebibliothek, die eine grundlegende MCP-Sitzung aufbauen kann.

#### 8.1.4. Proof-of-Concept (PoC)

- **Aktivität:** Erstellung eines minimalen Qt/QML-Widgets mit einer rudimentären Benutzeroberfläche.
- **Schritte:** Das Widget soll eine einfache MCP-Interaktion durchführen, z.B. die `tools/list`-Methode eines Test-MCP-Servers aufrufen und die Namen der zurückgegebenen Tools in einem QML-Textfeld anzeigen.
- **Ergebnis:** Ein funktionierender Prototyp, der die technische Machbarkeit der MCP-Integration im gewählten Stack demonstriert.

### 8.2. Phase 2: Kernfunktionsentwicklung und MCP-Integration

In dieser Phase werden die Hauptfunktionen des Widgets entwickelt und die MCP-Integration vertieft.

#### 8.2.1. Implementierung der Widget-UI/UX für MCP-Interaktionen

- **Aktivität:** Entwurf und Implementierung der QML-Benutzeroberfläche.
- **Aspekte:** UI-Elemente zur Entdeckung und Auswahl von Ressourcen, zum Aufrufen von Tools (inklusive klarer Zustimmungsdialoge für den Benutzer 8), zur Anzeige von Prompts und zur Darstellung der von MCP-Servern gelieferten Ergebnisse.
- **Technologie:** Nutzung von QML für die UI-Struktur und JavaScript für die UI-Logik. Für die Darstellung von HTML/CSS-Inhalten von MCP-Servern wird `QWebEngineView` 54 verwendet. Für native Darstellungen werden Standard-QML-Elemente gestylt.

#### 8.2.2. Robuste Integration mit ausgewählten MCP-Servern

- **Aktivität:** Implementierung der vollständigen Interaktionslogik mit den Ziel-MCP-Servern (gemäß Phase 1).
- **Schritte:** Verarbeitung aller benötigten Tools, Resources und Prompts. Handhabung verschiedener Datentypen, Parameter und Antwortstrukturen. Implementierung einer umfassenden Fehlerbehandlung für die MCP-Kommunikation (basierend auf JSON-RPC-Fehlercodes und anwendungsspezifischen Fehlern 26).
- **Ergebnis:** Stabile und zuverlässige Kommunikation mit den MCP-Servern.

#### 8.2.3. Implementierung von Sicherheits- und Autorisierungsflüssen

- **Aktivität:** Absicherung der MCP-Interaktionen.
- **Schritte:**
    - Wenn entfernte oder gesicherte MCP-Server verwendet werden: Integration der OAuth 2.1 Client-Logik (Authorization Code Flow mit PKCE 31). Anforderung notwendiger Scopes.12 Sichere Speicherung und Handhabung von Tokens.
    - Implementierung klarer Benutzer-Zustimmungsmechanismen im UI für den Zugriff auf Ressourcen und die Ausführung von Tools, wie von den MCP-Sicherheitsprinzipien gefordert.8
- **Ergebnis:** Sichere Authentifizierung und Autorisierung sowie Einhaltung der MCP-Sicherheitsrichtlinien.

#### 8.2.4. Zustandsmanagement innerhalb des Widgets

- **Aktivität:** Verwaltung des internen Zustands des Widgets in Bezug auf MCP-Daten.
- **Aspekte:** Zwischenspeicherung von Ressourcenlisten oder Tool-Definitionen (unter Berücksichtigung von `list_changed`-Benachrichtigungen 23), Verfolgung laufender Tool-Operationen (für Abbruch oder Fortschrittsanzeige), Speicherung von Benutzereinstellungen für MCP-Interaktionen.
- **Technologie:** Nutzung von C++ Datenstrukturen und Qt-Signalen/Slots für die Aktualisierung der QML-UI.

### 8.3. Phase 3: Erweiterte Funktionen, Tests und Verfeinerung

Diese Phase konzentriert sich auf fortgeschrittene MCP-Funktionen, Qualitätssicherung und Optimierung.

#### 8.3.1. Implementierung erweiterter MCP-Funktionen (optional)

- **Aktivität:** Falls für die Widget-Funktionalität erforderlich, Implementierung von:
    - Ressourcenabonnements (`resources/subscribe`, `notifications/resources/updated`) für Echtzeit-Datenaktualisierungen.23
    - Verarbeitung komplexer, mehrstufiger Prompts.14
    - Clientseitige Anfragen für Sampling-Operationen (falls vom Host unterstützt und relevant).8

#### 8.3.2. Umfassende Tests

- **Aktivität:** Sicherstellung der Qualität und Stabilität des Widgets.
- **Methoden:**
    - **Unit-Tests:** Für die C++ MCP-Client-Logik und QML/JS UI-Komponenten (z.B. mit Qt Test).
    - **Integrationstests:** Mit realen oder gemockten MCP-Servern, um das Zusammenspiel zu testen.
    - **UI/UX-Tests:** Überprüfung der Benutzerfreundlichkeit, Klarheit der MCP-Interaktionen und der Zustimmungsdialoge.
    - **Sicherheitsaudit:** Insbesondere der Autorisierungsflüsse und der Handhabung sensibler Daten.
    - **Nutzung des MCP Inspector:** Ein Tool zur visuellen Prüfung und zum Debugging von Interaktionen mit MCP-Servern.61
- **Ergebnis:** Ein gut getestetes, stabiles Widget.

#### 8.3.3. Performance-Profiling und -Optimierung

- **Aktivität:** Identifizierung und Behebung von Leistungsengpässen.
- **Bereiche:** MCP-Kommunikationslatenz, Datenverarbeitung (JSON-Parsing, -Serialisierung), UI-Rendering in QML (insbesondere bei `QWebEngineView`). Optimierung der CPU- und Speichernutzung.
- **Ergebnis:** Ein performantes und ressourcenschonendes Widget.

#### 8.3.4. Benutzerakzeptanztests (UAT) und iterative Verfeinerung

- **Aktivität:** Einholung von Feedback von Zielbenutzern.
- **Schritte:** Durchführung von UATs, Sammlung von Feedback zu Funktionalität, Benutzerfreundlichkeit und dem Nutzen der MCP-Integration. Iterative Anpassungen basierend auf dem Feedback.
- **Ergebnis:** Ein benutzerorientiertes Widget, das den Bedürfnissen der Zielgruppe entspricht.

### 8.4. Phase 4: Paketierung, Bereitstellung und Wartung

Die letzte Phase befasst sich mit der Verteilung und dem langfristigen Support des Widgets.

#### 8.4.1. Paketierung für Linux-Distributionen

- **Aktivität:** Erstellung von Installationspaketen.
- **Optionen:** Flatpak, Snap, traditionelle Pakete (.deb,.rpm).
- **Überlegungen:** Abhängigkeiten (Qt-Versionen, WebEngine), Desktop-Integration (z.B. `.desktop`-Dateien für den Anwendungsstarter, Icons, ggf. Integration in Plasma- oder GNOME-spezifische Widget-Systeme, falls nicht direkt als solches entwickelt).
- **Ergebnis:** Einfach installierbare Pakete für Endbenutzer.

#### 8.4.2. Dokumentation

- **Aktivität:** Erstellung notwendiger Dokumentationen.
- **Typen:**
    - **Endbenutzer-Dokumentation:** Anleitung zur Installation, Konfiguration und Nutzung des Widgets und seiner MCP-Funktionen.
    - **Entwickler-Dokumentation:** Falls das Widget erweiterbar ist oder als Teil eines größeren Systems dient (z.B. API-Beschreibungen, Architekturübersicht).
- **Ergebnis:** Umfassende Dokumentation für verschiedene Zielgruppen.

#### 8.4.3. Etablierung einer Wartungs- und Update-Strategie

- **Aktivität:** Planung für den langfristigen Support.
- **Aspekte:** Mechanismen zur Meldung und Behebung von Fehlern. Umgang mit Sicherheitslücken. Anpassung an zukünftige Änderungen der MCP-Spezifikationen oder der APIs der genutzten MCP-Server. Regelmäßige Updates.
- **Ergebnis:** Ein Plan für die nachhaltige Pflege des Widgets.

### 8.5. Zusammenfassung der wichtigsten Entscheidungen, Meilensteine und Ressourcenüberlegungen

- **Wichtige Entscheidungen (Zusammenfassung):**
    - Widget-Framework: **Qt/QML**.
    - Programmiersprachen: **C++ (Backend), QML/JS (Frontend)**.
    - MCP-Implementierung: **Direkte JSON-RPC-Implementierung in C++** (primär), Evaluierung des JS SDK für QML.
    - Fehlerberichterstattung an Benutzer: Klare, verständliche Meldungen, die zwischen Protokoll- und Anwendungsfehlern unterscheiden.
    - Daten-Caching: Implementierung einer Caching-Strategie für `tools/list` und `resources/list` Ergebnisse, mit Invalidierung durch `list_changed` Benachrichtigungen.
- **Meilensteine (Beispiele):**
    - M1: PoC für MCP-Grundverbindung und UI-Darstellung abgeschlossen.
    - M2: Kern-MCP-Integration mit Zielservern (Tools, Resources, Prompts) funktionsfähig.
    - M3: Sicherheits- und Autorisierungsfunktionen implementiert und getestet.
    - M4: Umfassende Tests (Unit, Integration, UI) bestanden; Performance-Optimierung abgeschlossen.
    - M5: Beta-Version für UAT freigegeben.
    - M6: Finale Version paketiert und dokumentiert.
- **Ressourcenallokation (Überlegungen):**
    - **Entwicklungszeit:** Abhängig von der Komplexität des Widgets und der Anzahl der zu integrierenden MCP-Server. Die Phasenstruktur hilft bei der Schätzung.
    - **Benötigte Fähigkeiten:** Expertise in Qt/QML und C++; Verständnis von Netzwerkprotokollen (JSON-RPC, HTTP, SSE); Kenntnisse in Sicherheitskonzepten (OAuth 2.1); UI/UX-Design-Fähigkeiten; Testautomatisierung.
    - **Testaufwand:** Signifikanter Aufwand für alle Testebenen, insbesondere Integrationstests mit verschiedenen MCP-Servern und Sicherheitstests.

Dieser Entwicklungsplan berücksichtigt die Notwendigkeit einer frühen Technologieauswahl, da diese weitreichende Auswirkungen auf den Entwicklungsaufwand, die Performance und die Wartbarkeit hat. Die Verwendung von Qt/QML mit einem C++ Backend bietet eine solide Basis für leistungsstarke und ansprechende Desktop-Widgets, während die Flexibilität bei der MCP-SDK-Wahl bzw. -Implementierung eine Anpassung an die spezifischen Projektanforderungen ermöglicht.

## 9. Einhaltung von MCP-Standards und Best Practices

Die erfolgreiche und interoperable Implementierung von MCP-fähigen Desktop-Widgets hängt entscheidend von der strikten Einhaltung der offiziellen MCP-Spezifikationen und etablierter Best Practices ab.

### 9.1. Konformität mit MCP-Spezifikationsversionen

MCP ist ein sich entwickelnder Standard.1 Es ist unerlässlich, dass Entwicklungen gegen eine spezifische, stabile Version der MCP-Spezifikation erfolgen (z.B. die Version `2025-03-26`, die in mehreren offiziellen Dokumenten referenziert wird 8). Entwickler sollten die offizielle Dokumentation auf [modelcontextprotocol.io](https://modelcontextprotocol.io/) 8 und das Spezifikations-Repository auf GitHub 61 regelmäßig auf Updates, neue Versionen und Migrationsleitfäden prüfen. Ein Plan für den Umgang mit zukünftigen Protokollrevisionen sollte Teil der Wartungsstrategie sein, um die langfristige Kompatibilität und Funktionalität der Widgets sicherzustellen.

### 9.2. Empfohlene Praktiken für Client- und Server-Entwicklung

Obwohl dieser Bericht sich auf die Client-Seite (Widgets) konzentriert, ist das Verständnis serverseitiger Best Practices hilfreich. Die offiziellen MCP-Entwicklungsleitfäden (z.B. der MCP Server Development Guide 14) und die Dokumentationen der SDKs (z.B. für TypeScript 21) enthalten wertvolle Empfehlungen:

- **Klare Benennung und detaillierte Schemata:** Tools, Resources und Prompts sollten aussagekräftige Namen und Beschreibungen haben. Ihre `inputSchema` (für Tools und Prompt-Argumente) und Datenstrukturen sollten präzise mit JSON Schema definiert werden.14
- **Korrekte Fehlerbehandlung:** Implementierung einer robusten Fehlerbehandlung, die sowohl Protokollfehler als auch anwendungsspezifische Fehler abdeckt und klare Fehlermeldungen liefert.14
- **Sicherheit:** Strikte Einhaltung der MCP-Sicherheitsprinzipien (Benutzerzustimmung, Datenschutz, Werkzeugsicherheit) und Implementierung der Autorisierungsmechanismen wie OAuth 2.1.8
- **Zustandsmanagement:** Sorgfältige Verwaltung des Sitzungszustands, insbesondere bei Servern, die Abonnements oder langlebige Operationen unterstützen.8
- **Performance:** Effiziente Implementierungen, um Latenzen gering zu halten und Ressourcen zu schonen.

### 9.3. Einbindung in die MCP-Community und Nutzung von Ressourcen

Als offener Standard lebt MCP von seiner Community.61 Entwickler von MCP-fähigen Widgets sollten die offiziellen Ressourcen aktiv nutzen:

- **GitHub Repositories:** Die `modelcontextprotocol` Organisation auf GitHub hostet die Spezifikation, SDKs, Beispielserver und andere wichtige Werkzeuge wie den MCP Inspector.13 Diese sind primäre Quellen für Code, Dokumentation und zur Verfolgung der Entwicklung.
- **Offizielle Dokumentation:** Die Website [modelcontextprotocol.io](https://modelcontextprotocol.io/) dient als zentraler Anlaufpunkt für Einführungen, Anleitungen, die Spezifikation und Neuigkeiten.8
- **Community-Kanäle:** (Falls vorhanden, z.B. Diskussionsforen, Mailinglisten, Chat-Kanäle) Aktive Teilnahme kann helfen, Probleme zu lösen, Feedback zu geben und über neue Entwicklungen informiert zu bleiben.

Die Behandlung der offiziellen Spezifikation 8 als maßgebliche Quelle und die Nutzung der bereitgestellten SDKs 61 sind entscheidend, um Konformität sicherzustellen, Implementierungsfehler zu reduzieren und die Interoperabilität mit anderen Komponenten im MCP-Ökosystem zu gewährleisten.

## 10. Schlussfolgerung und zukünftige Entwicklung von MCP in Desktop-Umgebungen

Das Model-Context-Protocol (MCP) besitzt das transformative Potenzial, die Art und Weise, wie Linux Desktop-Widgets und -Anwendungen mit KI-Systemen und externen Datenquellen interagieren, grundlegend zu verändern. Durch die Bereitstellung eines standardisierten, sicheren und erweiterbaren Frameworks ermöglicht MCP die Entwicklung von Widgets, die nicht nur Informationen passiv anzeigen, sondern aktiv Kontext verstehen, intelligente Aktionen vorschlagen oder ausführen und nahtlos mit einem breiten Ökosystem von KI-Werkzeugen und -Diensten zusammenarbeiten können.

Die in diesem Bericht detaillierte Spezifikation – von der Client-Host-Server-Architektur über die JSON-RPC-basierte Kommunikation und die Kernprimitive (Tools, Resources, Prompts) bis hin zum robusten Sicherheits- und Autorisierungsframework – bildet eine solide Grundlage für Entwickler. Die klare Definition von Verantwortlichkeiten, der Fokus auf Benutzerkontrolle und -zustimmung sowie die Betonung der Komponierbarkeit und einfachen Servererstellung sind Schlüsselfaktoren, die die Adaption von MCP fördern dürften.

Für Linux Desktop-Widgets bedeutet dies konkret:

- **Erhöhte Intelligenz:** Widgets können auf kontextuelle Informationen zugreifen (z.B. Kalender, lokale Dateien, Anwendungszustände), die über MCP-Server bereitgestellt werden, um relevantere und proaktivere Unterstützung zu bieten.
- **Erweiterte Funktionalität:** Durch die Anbindung an MCP-Tools können Widgets komplexe Aufgaben delegieren (z.B. Datenanalyse, API-Interaktionen, Code-Generierung), die weit über ihre traditionellen Fähigkeiten hinausgehen.
- **Verbesserte Benutzererfahrung:** Standardisierte Interaktionsmuster (Prompts) und die Möglichkeit, reichhaltige, dynamische UIs (ggf. serverseitig gerendert) darzustellen, können zu intuitiveren und ansprechenderen Widgets führen.
- **Nahtlose Integration:** MCP kann die Grenzen zwischen lokalen Desktop-Anwendungen und Cloud-basierten KI-Diensten verwischen und so eine hybride Computing-Erfahrung schaffen, bei der KI-Fähigkeiten allgegenwärtig und leicht zugänglich sind.

Die zukünftige Entwicklung und der Erfolg von MCP im Desktop-Bereich werden von mehreren Faktoren abhängen:

1. **Wachstum des MCP-Server-Ökosystems:** Die Verfügbarkeit einer breiten Palette nützlicher und stabiler MCP-Server für verschiedenste Anwendungsfälle (von Produktivitätswerkzeugen bis hin zu spezialisierten Branchenlösungen) ist entscheidend.9
2. **Einfachheit der Client-Implementierung:** Die Qualität und Benutzerfreundlichkeit der MCP SDKs für gängige Desktop-Entwicklungssprachen (insbesondere C++, Python, JavaScript) wird die Bereitschaft der Entwickler beeinflussen, MCP zu adoptieren.
3. **Demonstration konkreter Mehrwerte:** Es bedarf überzeugender Anwendungsbeispiele und Widgets, die den Benutzern klare Vorteile durch die MCP-Integration bieten.
4. **Weiterentwicklung des Standards:** Das MCP-Konsortium muss den Standard kontinuierlich pflegen, auf Feedback aus der Community reagieren und ihn an neue Anforderungen und technologische Entwicklungen im KI-Bereich anpassen, beispielsweise hinsichtlich neuer Modalitäten oder komplexerer Agentenarchitekturen.
5. **Sicherheitsvertrauen:** Die konsequente Umsetzung und Weiterentwicklung der Sicherheits- und Autorisierungsmechanismen ist unerlässlich, um das Vertrauen der Benutzer und Entwickler in die Plattform zu gewinnen und zu erhalten.

Der vorgestellte Entwicklungsplan für MCP-gestützte Linux Desktop-Widgets unter Verwendung von Qt/QML und C++ bietet einen pragmatischen Weg, um die Potenziale von MCP zu erschließen. Die sorgfältige Auswahl des Technologie-Stacks, die phasenweise Entwicklung und die strikte Einhaltung der MCP-Standards sind dabei erfolgskritisch.

Zusammenfassend lässt sich sagen, dass das Model-Context-Protocol gut positioniert ist, um eine Schlüsselrolle in der nächsten Generation intelligenter Desktop-Anwendungen zu spielen. Es bietet die notwendige Standardisierung und Flexibilität, um die wachsende Leistungsfähigkeit von LLMs sicher und effektiv in die täglichen Arbeitsabläufe der Benutzer zu integrieren. Die Reise hat gerade erst begonnen, aber die Richtung ist vielversprechend.
# Tiefenanalyse des Model Context Protocol (MCP) für Standardisierte Plug-and-Play-Interaktionen mit LLMs unter Linux

## I. Einleitung

Die rasante Entwicklung von Large Language Models (LLMs) hat zu einer neuen Generation von KI-gestützten Anwendungen geführt. Diese Modelle besitzen beeindruckende Fähigkeiten zur Sprachverarbeitung und Generierung, sind jedoch oft von den Datenquellen und Werkzeugen isoliert, die für kontextbezogene und relevante Antworten in realen Szenarien notwendig sind.1 Jede Integration eines LLMs mit einem externen System – sei es eine Datenbank, eine API oder ein lokales Dateisystem – erforderte bisher oft maßgeschneiderte Implementierungen. Diese Fragmentierung behindert die Skalierbarkeit und Interoperabilität von KI-Systemen erheblich.

Als Antwort auf diese Herausforderung wurde Ende November 2024 von Anthropic das Model Context Protocol (MCP) vorgestellt.1 MCP ist ein offener Standard, der darauf abzielt, die Art und Weise zu vereinheitlichen, wie KI-Anwendungen, insbesondere solche, die auf LLMs basieren, mit externen Datenquellen, Werkzeugen und Diensten interagieren.3 Es fungiert als universelle Schnittstelle, vergleichbar mit einem „USB-C-Anschluss für KI-Anwendungen“ 3, und ermöglicht eine standardisierte Plug-and-Play-Konnektivität.

Dieser Bericht bietet eine Tiefenanalyse des Model Context Protocol, mit besonderem Fokus auf dessen Definition, technische Architektur, Kernkomponenten, Sicherheitsmechanismen und die spezifischen Aspekte der Integration in Desktop-Betriebssysteme, insbesondere Linux. Ziel ist es, eine umfassende Wissensquelle zu schaffen, die alle im MCP-Protokoll festgelegten Standards und Regeln detailliert darlegt.

## II. Grundlagen des Model Context Protocol (MCP)

### A. Definition und Zielsetzung

Das Model Context Protocol (MCP) ist ein **offener Standard**, der von Anthropic initiiert wurde, um die Verbindung zwischen KI-Modellen (wie LLMs) und externen Datenquellen sowie Werkzeugen zu standardisieren.1 Sein Hauptziel ist es, KI-Systeme aus ihrer Isolation zu befreien, indem es ihnen eine einheitliche Methode bietet, um auf relevanten Kontext zuzugreifen und Aktionen in anderen Systemen auszuführen.1 MCP definiert eine gemeinsame Sprache und einen Satz von Regeln für die Kommunikation, wodurch die Notwendigkeit entfällt, für jede Kombination aus KI-Anwendung und externem Dienst eine eigene Integrationslösung zu entwickeln.1 Es wird oft als „USB-C für KI“ beschrieben, da es eine universelle Schnittstelle bereitstellt, die es jeder KI-Anwendung ermöglicht, sich mit jeder Datenquelle oder jedem Dienst zu verbinden, der den MCP-Standard unterstützt, ohne dass dafür spezifischer Code erforderlich ist.3

### B. Problemstellung: Lösung der „M×N-Integrationsproblematik“

Vor der Einführung von MCP standen Entwickler vor dem sogenannten **„M×N-Integrationsproblem“**.3 Dieses Problem beschreibt die kombinatorische Komplexität, die entsteht, wenn _M_ verschiedene KI-Anwendungen oder LLMs mit _N_ verschiedenen externen Werkzeugen, Datenquellen oder Diensten verbunden werden müssen. Ohne einen gemeinsamen Standard müsste potenziell für jede der M×N Kombinationen eine individuelle, maßgeschneiderte Schnittstelle entwickelt und gewartet werden.3 Dies führt zu einem enormen Entwicklungsaufwand, erhöht die Fehleranfälligkeit und behindert die Skalierbarkeit und Wartbarkeit von KI-Systemen erheblich.1

MCP löst dieses Problem grundlegend, indem es die M×N-Komplexität in ein wesentlich einfacheres **M+N-Setup** umwandelt.3 Anstatt unzähliger Punkt-zu-Punkt-Integrationen müssen Werkzeuge (als MCP-Server) und KI-Anwendungen (als MCP-Clients/Hosts) nur einmalig den MCP-Standard implementieren. Sobald dies geschehen ist, kann prinzipiell jedes MCP-konforme Modell mit jedem MCP-konformen Werkzeug interagieren.3 Dies reduziert den Integrationsaufwand drastisch und fördert die Interoperabilität innerhalb des KI-Ökosystems.7

Durch die Definition eines standardisierten _Protokolls_ agiert MCP auf einer fundamentalen Kommunikationsebene. Diese Abstraktion ermöglicht es unterschiedlichen KI-Systemen und Werkzeugen, miteinander zu interagieren, ohne die internen Implementierungsdetails des jeweils anderen kennen zu müssen. Dies fördert nicht nur die Interoperabilität, sondern reduziert auch die Abhängigkeit von spezifischen Anbietern (Vendor Lock-in) und schafft die Grundlage für ein skalierbares und flexibles Ökosystem.7

### C. Entstehungskontext und frühe Anwender

MCP wurde Ende November 2024 von Anthropic, dem Unternehmen hinter der Claude-Familie von Sprachmodellen, initiiert und als Open-Source-Projekt veröffentlicht.1 Die Motivation war die Erkenntnis, dass selbst die fortschrittlichsten LLMs durch ihre Isolation von Echtzeitdaten und externen Systemen eingeschränkt sind.1 Anthropic positionierte MCP von Anfang an als kollaboratives Projekt, das auf die Beiträge der gesamten Community angewiesen ist, um ein breites Ökosystem zu fördern.1

Bereits kurz nach der Veröffentlichung zeigten sich frühe Anwender (Early Adopters), die das Potenzial von MCP erkannten und es in ihre Systeme integrierten. Dazu gehörten namhafte Unternehmen wie **Block** (ehemals Square) und **Apollo**, die MCP nutzten, um internen KI-Systemen den Zugriff auf proprietäre Wissensdatenbanken, CRM-Systeme und Entwicklerwerkzeuge zu ermöglichen.1 Auch Unternehmen aus dem Bereich der Entwicklerwerkzeuge wie **Zed, Replit, Codeium** und **Sourcegraph** begannen frühzeitig, mit MCP zu arbeiten, um die KI-Funktionen ihrer Plattformen zu verbessern, indem sie KI-Agenten einen besseren Zugriff auf relevanten Kontext für Programmieraufgaben ermöglichten.1 Diese frühe Validierung durch Industrieunternehmen unterstrich den praktischen Nutzen und die Relevanz des Protokolls.14

## III. Technische Architektur und Kernkomponenten

MCP basiert auf einer Client-Server-Architektur, die speziell für die sichere und standardisierte Kommunikation zwischen LLM-Anwendungen und externen Systemen konzipiert ist.3 Die Architektur umfasst drei Hauptkomponenten: Host, Client und Server.

### A. Das Client-Host-Server-Modell

1. **Host:**
    
    - **Definition:** Der Host ist die KI-gestützte Anwendung oder Agentenumgebung, mit der der Endbenutzer interagiert.3 Beispiele hierfür sind Desktop-Anwendungen wie Claude Desktop, IDE-Plugins (z. B. für VS Code), Chat-Schnittstellen oder jede benutzerdefinierte LLM-basierte Anwendung.3
    - **Rolle:** Der Host fungiert als Koordinator oder Container für eine oder mehrere Client-Instanzen.4 Er initiiert die Verbindungen zu MCP-Servern über die Clients.6 Entscheidend ist, dass der Host für die Verwaltung des Lebenszyklus der Client-Verbindungen und die Durchsetzung von Sicherheitsrichtlinien verantwortlich ist. Dazu gehören die Einholung der Zustimmung des Benutzers (Consent Management), die Benutzerautorisierung und die Verwaltung von Berechtigungen.4 Der Host überwacht auch, wie die KI- oder LLM-Integration innerhalb jedes Clients erfolgt, und führt bei Bedarf Kontextinformationen von mehreren Servern zusammen.3
2. **Client:**
    
    - **Definition:** Der Client ist eine Komponente oder Instanz, die innerhalb des Hosts läuft und als Vermittler für die Kommunikation mit _einem_ spezifischen MCP-Server dient.3
    - **Rolle:** Jeder Client verwaltet eine **1:1-Verbindung** zu einem MCP-Server.3 Diese Eins-zu-eins-Beziehung ist ein wichtiges Sicherheitsmerkmal, da sie die Verbindungen zu verschiedenen Servern voneinander isoliert (Sandboxing).3 Der Client ist für die Aushandlung der Protokollfähigkeiten mit dem Server verantwortlich und orchestriert den Nachrichtenaustausch (Anfragen, Antworten, Benachrichtigungen) gemäß dem MCP-Standard.4 Der Host startet für jeden benötigten Server eine eigene Client-Instanz.3
3. **Server:**
    
    - **Definition:** Ein MCP-Server ist ein (oft leichtgewichtiger) Prozess oder Dienst, der spezifische externe Datenquellen, Werkzeuge oder Fähigkeiten über das standardisierte MCP-Protokoll zugänglich macht.3 Server können lokal auf dem Rechner des Benutzers oder remote (z. B. in der Cloud oder im Unternehmensnetzwerk) laufen.8
    - **Rolle:** Der Server stellt dem verbundenen Client seine Fähigkeiten zur Verfügung. Diese Fähigkeiten werden durch die MCP-Primitive **Tools**, **Ressourcen** und **Prompts** definiert.3 Er empfängt Anfragen vom Client (z. B. zum Ausführen eines Tools oder zum Lesen einer Ressource), verarbeitet diese (indem er z. B. eine API aufruft, eine Datenbank abfragt oder auf lokale Dateien zugreift) und sendet die Ergebnisse oder Daten an den Client zurück.4

Die klare Trennung zwischen Host, Client und Server in der MCP-Architektur fördert die Modularität und Wiederverwendbarkeit. Ein einmal entwickelter MCP-Server kann von verschiedenen Hosts und Clients genutzt werden, und ein Host kann problemlos Verbindungen zu neuen Servern hinzufügen, um seine Fähigkeiten zu erweitern.8 Diese Struktur ist fundamental für die Lösung des M×N-Integrationsproblems.

### B. Kommunikationsprotokoll: JSON-RPC 2.0

MCP verwendet **JSON-RPC 2.0** als Nachrichtenformat für die gesamte Kommunikation zwischen Clients und Servern.4 JSON-RPC 2.0 ist ein leichtgewichtiger Standard für Remote Procedure Calls (RPC), der auf JSON (JavaScript Object Notation) basiert.

- **Nachrichtenstruktur:** Die Kommunikation erfolgt über strukturierte JSON-Nachrichten. MCP nutzt die drei von JSON-RPC 2.0 definierten Nachrichtentypen 21:
    
    - **Requests (Anfragen):** Nachrichten, die eine Operation auf der Gegenseite auslösen sollen und eine Antwort erwarten. Sie enthalten `jsonrpc: "2.0"`, eine eindeutige `id` (Zahl oder String), den `method` (Name der aufzurufenden Methode, z. B. `tools/call`) und optional `params` (ein strukturiertes Objekt oder Array mit den Parametern für die Methode).
    - **Responses (Antworten):** Nachrichten, die als Antwort auf eine Anfrage gesendet werden. Sie enthalten `jsonrpc: "2.0"`, die `id` der ursprünglichen Anfrage und entweder ein `result`-Feld (bei Erfolg) oder ein `error`-Objekt (bei einem Fehler).
    - **Notifications (Benachrichtigungen):** Nachrichten, die wie Anfragen eine Operation auslösen, aber keine Antwort erwarten. Sie enthalten `jsonrpc: "2.0"`, den `method` und optional `params`, aber keine `id`.
- **Vorteile:** Die Wahl von JSON-RPC 2.0 bietet mehrere Vorteile:
    
    - **Standardisierung:** Es ist ein etablierter Standard, was die Implementierung und Interoperabilität erleichtert.
    - **Lesbarkeit:** JSON ist menschenlesbar, was die Fehlersuche und Entwicklung vereinfacht.
    - **Leichtgewichtigkeit:** Es erzeugt relativ wenig Overhead im Vergleich zu anderen RPC-Mechanismen wie XML-RPC oder SOAP.
    - **Transportunabhängigkeit:** JSON-RPC 2.0 definiert das Nachrichtenformat, nicht den Transportmechanismus, was MCP Flexibilität bei der Wahl der Transportprotokolle gibt.26

Die Verwendung eines bewährten Standards wie JSON-RPC 2.0, der auch im Language Server Protocol (LSP) genutzt wird, von dem MCP Inspiration zog 6, unterstreicht das Ziel, eine robuste und interoperable Kommunikationsgrundlage zu schaffen.

### C. Transport Layer: STDIO und HTTP+SSE

MCP definiert, wie Nachrichten strukturiert sind (JSON-RPC 2.0), überlässt aber die Wahl des tatsächlichen Transportmechanismus für diese Nachrichten den Implementierungen. Die Spezifikation und die offiziellen SDKs unterstützen zwei primäre Transportmethoden 17:

1. **Standard Input/Output (STDIO):**
    
    - **Funktionsweise:** Bei diesem Transport startet der Host (oder der Client im Host) den MCP-Server als lokalen Kindprozess. Die Kommunikation erfolgt dann über die Standard-Eingabe (`stdin`) und Standard-Ausgabe (`stdout`) dieses Prozesses.17 JSON-RPC-Nachrichten werden über diese Pipes gesendet und empfangen, oft zeilenbasiert getrennt.22 Die Standard-Fehlerausgabe (`stderr`) wird häufig für Logging-Zwecke verwendet.22
    - **Anwendungsfälle:** STDIO eignet sich **ideal für lokale Integrationen**, bei denen Client und Server auf derselben Maschine laufen.17 Dies ist besonders relevant für die Integration in Desktop-Anwendungen (wie IDEs oder lokale KI-Assistenten unter Linux), die auf lokale Ressourcen zugreifen oder lokale Kommandozeilenwerkzeuge kapseln müssen.20
    - **Vorteile:** Einfachheit (keine Netzwerk-Konfiguration erforderlich), Effizienz (geringer Overhead für lokale Kommunikation), gute Integration mit bestehenden Kommandozeilen-Tools.19
    - **Sicherheitsaspekte:** Da die Kommunikation lokal erfolgt, sind die Hauptbedenken die Sicherheit des lokalen Systems und der beteiligten Prozesse. Ein Angreifer mit lokalem Zugriff könnte die Kommunikation potenziell abfangen oder manipulieren.26
2. **HTTP mit Server-Sent Events (SSE):**
    
    - **Funktionsweise:** Dieser Transportmechanismus ist für **Netzwerkkommunikation und Remote-Integrationen** konzipiert.17 Er verwendet eine Kombination aus Standard-HTTP-Methoden und Server-Sent Events:
        - **Client-zu-Server:** Der Client sendet JSON-RPC-Anfragen und -Benachrichtigungen über HTTP POST-Requests an den Server.17
        - **Server-zu-Client:** Der Server nutzt Server-Sent Events (SSE), einen Standard für unidirektionales Streaming vom Server zum Client über eine persistente HTTP-Verbindung, um JSON-RPC-Antworten und -Benachrichtigungen an den Client zu senden.17
    - **Anwendungsfälle:** Geeignet für Szenarien, in denen Client und Server über ein Netzwerk kommunizieren, z. B. wenn ein Desktop-Client auf einen zentral gehosteten Unternehmens-MCP-Server zugreift oder wenn MCP-Server als Webdienste bereitgestellt werden.18 Auch nützlich, wenn nur Server-zu-Client-Streaming benötigt wird oder in restriktiven Netzwerkumgebungen, die Standard-HTTP erlauben.26
    - **Vorteile:** Nutzt etablierte Web-Technologien, ermöglicht verteilte Architekturen, kann Firewalls oft leichter passieren als andere Protokolle.24
    - **Sicherheitsaspekte:** HTTP-basierte Transporte erfordern besondere Aufmerksamkeit bezüglich der Sicherheit:
        - **Transportverschlüsselung:** Die Verwendung von TLS (HTTPS) ist unerlässlich, um die Kommunikation abzusichern.22
        - **Authentifizierung/Autorisierung:** Da die Verbindung über ein potenziell unsicheres Netzwerk erfolgt, sind Mechanismen zur Authentifizierung des Clients und zur Autorisierung von Anfragen oft notwendig. MCP spezifiziert hierfür optional die Verwendung von OAuth 2.1 (siehe Abschnitt V.B).19
        - **DNS Rebinding:** SSE-Transporte können anfällig für DNS-Rebinding-Angriffe sein, insbesondere wenn lokale Server auf unsichere Weise an Netzwerkschnittstellen gebunden werden. Schutzmaßnahmen umfassen die Validierung des `Origin`-Headers, das Binden an `localhost` (127.0.0.1) statt `0.0.0.0` für lokale Server und die Implementierung von Authentifizierung.26

Die Wahl des Transports hängt vom spezifischen Anwendungsfall ab, wobei STDIO die natürliche Wahl für lokale Desktop-Integrationen (insbesondere unter Linux) darstellt, während HTTP+SSE für vernetzte Szenarien vorgesehen ist. Beide nutzen jedoch das gleiche JSON-RPC 2.0 Nachrichtenformat, was die Konsistenz des Protokolls über verschiedene Transportwege hinweg gewährleistet.19

### D. Kernprimitive des Protokolls

MCP definiert eine Reihe von Kernkonzepten, sogenannte „Primitive“, die die Art der Fähigkeiten beschreiben, die Server anbieten und Clients nutzen können. Diese Primitive strukturieren die Interaktion und ermöglichen es dem LLM bzw. der Host-Anwendung zu verstehen, welche Art von Kontext oder Funktionalität verfügbar ist.3

1. **Server-seitige Primitive (Angeboten vom Server):**
    
    - **Tools (Werkzeuge):**
        
        - **Definition:** Ausführbare Funktionen oder Aktionen, die das LLM (über den Client und Host) beim Server aufrufen kann.3 Tools repräsentieren typischerweise Operationen, die einen Zustand ändern können oder externe Systeme aktiv beeinflussen (z. B. eine E-Mail senden, einen Datenbankeintrag erstellen, eine Suche durchführen, Code ausführen).3
        - **Struktur:** Jedes Tool hat einen Namen, eine Beschreibung (die dem LLM hilft zu verstehen, wann es das Tool verwenden soll) und typischerweise ein definiertes Schema (oft JSON Schema) für seine Eingabeparameter und manchmal auch für die erwartete Ausgabe.7
        - **Verwendung:** Tools sind dafür gedacht, vom KI-Modell initiiert zu werden, wobei die Ausführung in der Regel die explizite Zustimmung des Benutzers erfordert (verwaltet durch den Host).6 MCP definiert JSON-RPC-Methoden wie `tools/list` (um verfügbare Tools auf einem Server zu entdecken) und `tools/call` (um ein bestimmtes Tool mit Parametern aufzurufen).7 Dieses Konzept ähnelt dem „Function Calling“ in anderen LLM-APIs, ist aber in MCP Teil eines breiteren, standardisierten Frameworks.7 Tools repräsentieren potenziell die Ausführung von beliebigem Code und MÜSSEN daher mit Vorsicht behandelt werden.6 Beschreibungen von Tools SOLLTEN als nicht vertrauenswürdig betrachtet werden, es sei denn, sie stammen von einem vertrauenswürdigen Server.6
    - **Resources (Ressourcen):**
        
        - **Definition:** Strukturierte Daten oder Kontextinformationen, die der Server dem Client (und damit dem LLM oder Benutzer) zur Verfügung stellt.3 Ressourcen sind in der Regel schreibgeschützt (read-only) und dienen dazu, den Kontext des LLMs anzureichern.7 Beispiele sind Dateiinhalte, Codefragmente, Datenbankeinträge, Log-Auszüge oder beliebige Informationen, die in den Prompt des Modells eingefügt werden können.3
        - **Struktur:** Ressourcen werden typischerweise über einen eindeutigen URI (Uniform Resource Identifier) identifiziert.29
        - **Verwendung:** Der Client kann Ressourcen vom Server anfordern (z. B. über eine Methode wie `resources/get` oder `read_resource` in den SDKs 29), um dem LLM relevante Informationen für seine aktuelle Aufgabe bereitzustellen. Der Host MUSS die Zustimmung des Benutzers einholen, bevor Benutzerdaten als Ressourcen an einen Server übermittelt oder von diesem abgerufen werden, und darf diese Daten nicht ohne Zustimmung weitergeben.6
    - **Prompts (Vorlagen):**
        
        - **Definition:** Vordefinierte Anweisungsvorlagen, Prompt-Templates oder Skripte für Arbeitsabläufe, die der Server dem Client anbieten kann, um komplexe Interaktionen zu steuern oder zu vereinfachen.3 Sie sind oft für den Benutzer oder den Host gedacht, um sie auszuwählen und anzuwenden.7
        - **Struktur:** Prompts können Argumente akzeptieren und potenziell mehrere Schritte verketten, z. B. eine Sequenz von Tool-Aufrufen oder Ressourcenabrufen spezifizieren.7
        - **Verwendung:** Sie dienen als wiederverwendbare „Rezepte“ für die Interaktion mit dem Server und dem LLM, um häufige Aufgaben zu erleichtern.7 Ein Beispiel wäre ein Prompt wie „Überprüfe diesen Code auf Fehler“, der intern möglicherweise ein Linter-Tool aufruft und relevante Dokumentation als Ressource abruft.7 Clients können verfügbare Prompts über eine Methode wie `prompts/list` abfragen.7
2. **Client-seitige Primitive (Angeboten vom Client an den Server):**
    
    - **Roots:**
        
        - **Definition:** Obwohl in einigen frühen Diskussionen oder Dokumenten erwähnt 3, wird das „Roots“-Primitive in der offiziellen Spezifikation 6 und den Kern-SDK-Dokumentationen 29 nicht explizit als eigenständiges, standardisiertes Primitiv für Client-Angebote definiert. Die ursprüngliche Idee 3 schien sich auf Einstiegspunkte in das Dateisystem oder die Umgebung des Hosts zu beziehen, auf die ein Server mit Erlaubnis zugreifen könnte. In der aktuellen Spezifikation wird der Zugriff auf lokale Ressourcen eher durch Server (die lokal laufen und Ressourcen anbieten) oder als Teil der allgemeinen Sicherheits- und Consent-Mechanismen des Hosts gehandhabt.
    - **Sampling (Stichprobennahme):**
        
        - **Definition:** Ein Mechanismus, der es dem _Server_ erlaubt, den _Host_ (über den Client) aufzufordern, eine Textvervollständigung durch das LLM basierend auf einem vom Server bereitgestellten Prompt zu generieren.3 Dies ermöglicht server-initiierte agentische Verhaltensweisen und rekursive oder verschachtelte LLM-Aufrufe.3
        - **Verwendung:** Dies ist eine fortgeschrittene Funktion, die komplexe, mehrstufige Denkprozesse ermöglichen kann, bei denen ein Agent auf der Serverseite das LLM im Host für Teilaufgaben aufrufen könnte.3
        - **Sicherheitsaspekte:** Anthropic betont, dass Sampling-Anfragen **immer die explizite Zustimmung des Benutzers erfordern MÜSSEN** 3, um unkontrollierte, sich selbst aufrufende Schleifen zu verhindern. Der Benutzer SOLLTE kontrollieren können, ob Sampling überhaupt stattfindet, welcher Prompt gesendet wird und welche Ergebnisse der Server sehen darf.6 Das Protokoll schränkt bewusst die Sichtbarkeit des Servers auf die Prompts während des Samplings ein.6

Diese Primitive bilden das Kernvokabular von MCP und ermöglichen eine strukturierte und standardisierte Art und Weise, wie LLM-Anwendungen sowohl Kontext (über Ressourcen und Prompts) abrufen als auch Aktionen (über Tools) auslösen können, wobei fortgeschrittene Interaktionsmuster (über Sampling) ebenfalls unterstützt werden.3

### E. Verbindungslebenszyklus

Die Interaktion zwischen einem MCP-Client und einem MCP-Server folgt einem definierten Lebenszyklus, der sicherstellt, dass beide Seiten über die Fähigkeiten des anderen informiert sind und die Kommunikation geordnet abläuft.18

1. **Initialisierung (Initialization):**
    
    - Der Prozess beginnt, wenn der Client eine Verbindung zum Server herstellt (über den gewählten Transportmechanismus).
    - Der Client sendet eine `initialize`-Anfrage an den Server. Diese Anfrage MUSS die vom Client unterstützte Protokollversion und optional dessen Fähigkeiten (z. B. Unterstützung für Sampling) enthalten.18
    - Der Server antwortet auf die `initialize`-Anfrage mit seiner eigenen unterstützten Protokollversion und einer Liste seiner Fähigkeiten (advertised capabilities), d. h. welche Tools, Ressourcen und Prompts er anbietet.18
    - Nachdem der Server geantwortet hat, sendet der Client eine `initialized`-Benachrichtigung an den Server, um zu bestätigen, dass der Handshake abgeschlossen ist und die normale Kommunikation beginnen kann.18
    - Dieser Aushandlungsprozess stellt sicher, dass beide Parteien kompatibel sind und die Fähigkeiten des Gegenübers kennen, bevor sie mit dem Austausch von Anwendungsdaten beginnen.18
2. **Nachrichtenaustausch (Message Exchange):**
    
    - Nach erfolgreicher Initialisierung können Client und Server Nachrichten gemäß dem JSON-RPC 2.0-Format austauschen.18
    - Dies umfasst Anfragen vom Client an den Server (z. B. `tools/call`, `resources/get`, `prompts/activate`), Anfragen vom Server an den Client (z. B. `sampling/request`, falls vom Client unterstützt und vom Benutzer genehmigt), die entsprechenden Antworten auf diese Anfragen sowie unidirektionale Benachrichtigungen in beide Richtungen (z. B. für Fortschritts-Updates oder Logging).6
3. **Beendigung (Termination):**
    
    - Die Verbindung kann auf verschiedene Weisen beendet werden 18:
        - **Sauberes Herunterfahren (Clean Shutdown):** Client oder Server können die Verbindung explizit und geordnet schließen (z. B. durch eine `shutdown`-Anfrage gefolgt von einer `exit`-Benachrichtigung, ähnlich wie im Language Server Protocol, oder spezifische Methoden im SDK).
        - **Transport-Trennung:** Eine Unterbrechung der zugrunde liegenden Transportverbindung (z. B. Schließen des STDIO-Streams, Trennung der HTTP-Verbindung) führt zur Beendigung der MCP-Sitzung.
        - **Fehlerbedingungen:** Kritische Fehler auf einer der beiden Seiten können ebenfalls zur sofortigen Beendigung der Verbindung führen.

Dieser klar definierte Lebenszyklus trägt zur Robustheit und Vorhersagbarkeit von MCP-Interaktionen bei.18

## IV. Implementierungspraktiken

Die Implementierung von MCP umfasst typischerweise das Erstellen von MCP-Servern, die externe Systeme kapseln, und die Integration von MCP-Clients in Host-Anwendungen, um diese Server zu nutzen.

### A. Erstellung von MCP-Servern

Das Erstellen eines MCP-Servers bedeutet, eine Brücke zwischen einem externen System (wie einer API, einer Datenbank oder dem lokalen Dateisystem) und dem MCP-Protokoll zu bauen.

- **Werkzeuge und SDKs:** Entwickler können MCP-Server erstellen, indem sie die offiziellen Software Development Kits (SDKs) nutzen, die von Anthropic und Partnern bereitgestellt werden. Diese SDKs sind für gängige Programmiersprachen wie **TypeScript, Python, Java, Kotlin, C# (in Zusammenarbeit mit Microsoft), Rust** und **Swift (in Zusammenarbeit mit loopwork-ai)** verfügbar.1 Die SDKs abstrahieren viele der Low-Level-Details des Protokolls (JSON-RPC-Handling, Transportmanagement) und bieten einfache Schnittstellen zur Definition von Server-Fähigkeiten.4 Alternativ kann das Protokoll auch direkt implementiert werden, basierend auf der Spezifikation.6 Die Verfügbarkeit dieser SDKs ist entscheidend für die Akzeptanz des Protokolls, da sie die Einstiegshürde für Entwickler erheblich senken. Ohne sie müssten Entwickler die Komplexität der Netzwerkprotokoll-Implementierung selbst bewältigen, einschließlich Nachrichten-Framing, Serialisierung, Transportbesonderheiten und Verbindungslebenszyklusmanagement.22 Die SDKs kapseln diese Komplexität und ermöglichen es Entwicklern, sich auf die Implementierung der eigentlichen Logik für ihre Tools, Ressourcen und Prompts zu konzentrieren, was die Erstellung neuer Server beschleunigt und das Wachstum des Ökosystems fördert.1
    
- **Prozess:**
    
    1. **Server-Instanziierung:** Ein Server-Objekt wird mithilfe des entsprechenden SDKs instanziiert (z. B. `FastMCP` in Python 29, `McpServer` in TypeScript 30).
    2. **Fähigkeiten definieren:** Tools, Ressourcen und Prompts werden mithilfe von Decorators (Python: `@mcp.tool()`, `@mcp.resource()`, `@mcp.prompt()` 25) oder spezifischen Methoden (TypeScript: `server.tool()`, `server.resource()`, `server.prompt()` 30) des SDKs definiert.
    3. **Logik implementieren:** Innerhalb der Funktionen, die diese Fähigkeiten definieren, wird die eigentliche Logik implementiert. Dies kann API-Aufrufe, Datenbankabfragen, Dateisystemoperationen oder andere Berechnungen umfassen.3
    4. **Server starten:** Der Server wird gestartet, um auf eingehende Verbindungen vom Client über den gewählten Transportmechanismus (STDIO oder HTTP+SSE) zu lauschen.
- **Beispiele:** Es gibt zahlreiche Referenzimplementierungen und Community-Beiträge für MCP-Server, die eine Vielzahl von Systemen integrieren, darunter Google Drive, Slack, GitHub, Git, Postgres, Puppeteer, Dateisystemzugriff, Shell-Ausführung und viele mehr.1 Diese dienen als Vorlagen und Bausteine für eigene Implementierungen.
    
- **Best Practices:** Bei der Entwicklung von Servern sollten bewährte Praktiken befolgt werden:
    
    - Klare und aussagekräftige Namen und Beschreibungen für Fähigkeiten verwenden.
    - Detaillierte Schemata für Tool-Parameter definieren (z. B. mit Zod in TypeScript 22).
    - Robuste Fehlerbehandlung implementieren.19
    - Tool-Operationen fokussiert und atomar halten.22
    - Rate Limiting implementieren, falls externe APIs genutzt werden.22
    - Umfassendes Logging implementieren (z. B. nach `stderr` bei STDIO 22 oder über `server.sendLoggingMessage()` 22).
    - Sicherheitsaspekte berücksichtigen: Eingabevalidierung und -sanitisierung, Schutz sensibler Daten.19
- **Debugging:** Werkzeuge wie der **MCP Inspector** können verwendet werden, um MCP-Server während der Entwicklung zu testen, zu inspizieren und zu validieren.8
    

### B. Integration von MCP-Clients

MCP-Clients sind die Komponenten innerhalb von Host-Anwendungen, die die tatsächliche Kommunikation mit den MCP-Servern durchführen.

- **Integration in Hosts:** Clients werden in Host-Anwendungen wie Claude Desktop, IDEs oder benutzerdefinierten Agenten integriert.3
    
- **Prozess:**
    
    1. **SDK verwenden:** Client-Bibliotheken aus den offiziellen SDKs werden genutzt (z. B. die `Client`-Klasse in TypeScript 30, `stdio_client` in Python 29).
    2. **Transport wählen:** Der passende Transportmechanismus (STDIO für lokale Server, HTTP+SSE für remote Server) wird ausgewählt und konfiguriert, um die Verbindung zum Zielserver herzustellen.23
    3. **Verbindung herstellen:** Eine Verbindung zum Server wird aufgebaut, und der Initialisierungs-Handshake (Aushandlung von Version und Fähigkeiten) wird durchgeführt.19
- **Interaktion mit Servern:**
    
    1. **Fähigkeiten entdecken:** Der Client kann die vom Server angebotenen Tools, Ressourcen und Prompts auflisten (z. B. über `list_tools`, `list_resources`, `list_prompts` 29).
    2. **Fähigkeiten nutzen:** Der Client ruft Tools auf (`tools/call` 29), liest Ressourcen (`resources/get` oder `read_resource` 29) oder aktiviert Prompts (`prompts/activate`) mithilfe der vom SDK bereitgestellten Methoden.
    3. **Antworten verarbeiten:** Der Client empfängt und verarbeitet die Antworten, Fehler und Benachrichtigungen vom Server und leitet sie gegebenenfalls an die Host-Anwendung oder das LLM weiter.19
- **Verantwortlichkeiten des Hosts:** Es ist wichtig zu verstehen, dass der Client selbst primär für die Protokollkommunikation zuständig ist. Die eigentliche Steuerung und Intelligenz liegt in der **Host-Anwendung**, die den Client einbettet.3 Der Host entscheidet, _welche_ Server wann verbunden werden sollen, basierend auf Benutzerinteraktionen oder der Logik des KI-Agenten. Er ist verantwortlich für die Verwaltung der Verbindungen und vor allem für die **Durchsetzung der Sicherheitsrichtlinien**. Dies umfasst das Einholen und Verwalten der **Benutzerzustimmung (Consent)** für den Zugriff auf Ressourcen oder die Ausführung von Tools.3 Der Host kann auch für die Abwicklung von Authentifizierungsflüssen (wie OAuth) verantwortlich sein und muss möglicherweise Kontextinformationen von mehreren verbundenen Servern integrieren und für das LLM oder den Benutzer aufbereiten.4 Der Host fungiert somit als zentrale Kontroll- und Sicherheitsebene, während der Client als gesteuerter Kommunikationskanal dient.
    

## V. Sicherheit und Governance in MCP

Sicherheit und Vertrauenswürdigkeit sind zentrale Aspekte des Model Context Protocol, insbesondere da es den Zugriff von KI-Modellen auf potenziell sensible Daten und die Ausführung von Aktionen in externen Systemen ermöglicht.3 Die Spezifikation legt daher großen Wert auf klare Sicherheitsprinzipien und -mechanismen.

### A. Fundamentale Sicherheitsprinzipien

Die MCP-Spezifikation 6 definiert mehrere Schlüsselprinzipien, die von allen Implementierern (Hosts und Server) beachtet werden MÜSSEN oder SOLLTEN:

- **Benutzerzustimmung und -kontrolle (User Consent and Control):**
    
    - Benutzer MÜSSEN explizit jeder Datenzugriffs- oder Tool-Ausführungsoperation zustimmen und deren Umfang verstehen.
    - Benutzer MÜSSEN die Kontrolle darüber behalten, welche Daten geteilt und welche Aktionen ausgeführt werden.
    - Hosts SOLLTEN klare Benutzeroberflächen zur Überprüfung und Autorisierung von Aktivitäten bereitstellen.
- **Datenschutz (Data Privacy):**
    
    - Hosts MÜSSEN explizite Benutzerzustimmung einholen, bevor Benutzerdaten an Server weitergegeben werden.
    - Ressourcendaten DÜRFEN NICHT ohne Benutzerzustimmung an andere Stellen übertragen werden.
    - Benutzerdaten SOLLTEN durch angemessene Zugriffskontrollen geschützt werden. MCP ermöglicht es, sensible Daten innerhalb der eigenen Infrastruktur zu halten, indem Server lokal oder im eigenen Netzwerk betrieben werden.7
- **Tool-Sicherheit (Tool Safety):**
    
    - Tools repräsentieren potenziell beliebige Codeausführung und MÜSSEN mit entsprechender Vorsicht behandelt werden.
    - Hosts MÜSSEN explizite Benutzerzustimmung einholen, bevor ein Tool aufgerufen wird.
    - Benutzer SOLLTEN verstehen, was jedes Tool tut, bevor sie dessen Verwendung autorisieren.
    - Beschreibungen des Tool-Verhaltens (z. B. Annotationen) SOLLTEN als nicht vertrauenswürdig betrachtet werden, es sei denn, sie stammen von einem vertrauenswürdigen Server.
- **Kontrolle über LLM-Sampling (LLM Sampling Controls):**
    
    - Benutzer MÜSSEN explizit allen LLM-Sampling-Anfragen vom Server zustimmen.
    - Benutzer SOLLTEN kontrollieren können, ob Sampling überhaupt stattfindet, welcher Prompt tatsächlich gesendet wird und welche Ergebnisse der Server sehen darf.
    - Das Protokoll schränkt die Sichtbarkeit des Servers auf die Prompts während des Samplings bewusst ein.

Obwohl das Protokoll selbst nicht alle diese Prinzipien auf Protokollebene erzwingen kann, SOLLTEN Implementierer robuste Zustimmungs- und Autorisierungsabläufe entwickeln, klare Dokumentationen der Sicherheitsimplikationen bereitstellen, angemessene Zugriffskontrollen und Datenschutzmaßnahmen implementieren, Sicherheitspraktiken befolgen und Datenschutzaspekte bei der Gestaltung von Funktionen berücksichtigen.6

Die detaillierte Ausformulierung dieser Prinzipien und die explizite Zuweisung von Verantwortlichkeiten, insbesondere an den Host, direkt in der Kernspezifikation 6 deuten darauf hin, dass Sicherheit und Benutzervertrauen von Anfang an zentrale Designziele waren. Angesichts der potenziellen Risiken, die mit der Verbindung leistungsfähiger KI-Modelle zu externen Systemen verbunden sind 2, ist dieser Fokus auf eine starke, transparente Sicherheitsgrundlage entscheidend für die Akzeptanz des Protokolls, insbesondere im Unternehmensumfeld.

### B. Authentifizierung und Autorisierung: OAuth 2.1 Integration

Für HTTP-basierte Transporte bietet MCP **optionale** Autorisierungsfähigkeiten auf Transportebene, die auf dem modernen **OAuth 2.1**-Standard basieren.27 Dies ermöglicht es MCP-Clients, Anfragen an geschützte MCP-Server im Namen von Ressourcenbesitzern (typischerweise Endbenutzern) zu stellen.

- **Rollen im OAuth-Fluss:**
    
    - **MCP-Server:** Agiert als OAuth 2.1 **Resource Server**, der geschützte Ressourcen (Tools, Ressourcen, Prompts) bereitstellt und Access Tokens validiert.
    - **MCP-Client:** Agiert als OAuth 2.1 **Client**, der im Namen des Benutzers Access Tokens von einem Authorization Server anfordert und diese bei Anfragen an den Resource Server (MCP-Server) mitsendet.
    - **Authorization Server:** Eine separate Entität (kann vom Server-Betreiber bereitgestellt werden), die Benutzer authentifiziert, deren Zustimmung einholt und Access Tokens (und ggf. Refresh Tokens) an den Client ausstellt.27
- **Unterstützte Grant Types:** MCP-Server SOLLTEN OAuth Grant Types unterstützen, die zum Anwendungsfall passen 27:
    
    - **Authorization Code Grant (mit PKCE):** Der empfohlene Fluss, wenn der Client im Namen eines menschlichen Endbenutzers handelt (z. B. ein KI-Agent ruft ein externes SaaS-Tool auf). **PKCE (Proof Key for Code Exchange) ist für alle Clients OBLIGATORISCH (REQUIRED)**, um Code Interception Attacks zu verhindern.27
    - **Client Credentials Grant:** Geeignet für Machine-to-Machine-Kommunikation, bei der der Client nicht im Namen eines Benutzers handelt (z. B. ein interner Agent ruft ein gesichertes internes Tool auf).27
- **Server Discovery und Client Registration:** Um die Interoperabilität und das Plug-and-Play-Ziel zu unterstützen, definiert die Spezifikation Mechanismen für Discovery und Registrierung:
    
    - **Server Metadata Discovery:** Clients MÜSSEN dem **OAuth 2.0 Authorization Server Metadata**-Protokoll (RFC8414) folgen, um Informationen über den Authorization Server zu erhalten (z. B. Endpunkte für Autorisierung und Token-Austausch).27 Server MÜSSEN entweder **OAuth 2.0 Protected Resource Metadata** (RFC9728, über den `WWW-Authenticate`-Header bei 401-Antworten) implementieren oder SOLLTEN RFC8414 unterstützen, um dem Client den Weg zum Authorization Server zu weisen.27 Fallback-URLs MÜSSEN unterstützt werden, falls keine Metadaten-Discovery verfügbar ist.28
    - **Dynamic Client Registration:** Clients und Authorization Servers SOLLTEN das **OAuth 2.0 Dynamic Client Registration Protocol** (RFC7591) unterstützen.27 Dies ermöglicht es Clients, sich automatisch bei neuen Authorization Servern zu registrieren und eine Client-ID zu erhalten, ohne dass manuelle Konfiguration durch den Benutzer erforderlich ist. Dies ist entscheidend für eine nahtlose Verbindung zu bisher unbekannten Servern.27 Ohne dynamische Registrierung müssten Clients möglicherweise auf hartcodierte IDs zurückgreifen oder den Benutzer auffordern, Registrierungsdetails manuell einzugeben.27
- **Token-Handhabung:**
    
    - Access Tokens MÜSSEN im `Authorization`-HTTP-Header als Bearer Token gesendet werden (`Authorization: Bearer <token>`).28 Sie DÜRFEN NICHT im URI-Query-String enthalten sein.28
    - Clients DÜRFEN KEINE Tokens an einen MCP-Server senden, die nicht vom zugehörigen Authorization Server dieses MCP-Servers ausgestellt wurden.27
    - Authorization Servers MÜSSEN sicherstellen, dass sie nur Tokens akzeptieren, die für ihre eigenen Ressourcen gültig sind.27 MCP-Server DÜRFEN KEINE anderen Tokens akzeptieren oder weiterleiten.27
    - Die Verwendung kurzlebiger Access Tokens wird EMPFOHLEN (RECOMMENDED), um die Auswirkungen gestohlener Tokens zu minimieren.27 Token-Rotation (mittels Refresh Tokens) SOLLTE implementiert werden.28
    - Clients MÜSSEN Tokens sicher speichern.27
- **Sicherheitsbest Practices:** Implementierungen MÜSSEN den Sicherheitspraktiken von OAuth 2.1 folgen.27 Dazu gehören die Verwendung von PKCE, die Validierung von Redirect URIs zur Verhinderung von Open Redirection Attacks und der Schutz vor Token-Diebstahl.27
    
- **Third-Party Authorization:** Die Spezifikation beschreibt auch Szenarien, in denen ein MCP-Server als Frontend für einen anderen Dienst fungiert, der seine eigene Authentifizierung erfordert (z. B. das Kapseln einer SaaS-API). Dies erfordert eine sichere Handhabung und Zuordnung von Tokens.28
    

Die Wahl von OAuth 2.1 als Standard für die optionale Autorisierung ist ein Schlüsselelement für die Interoperabilität und Unternehmensreife von MCP. Es bietet einen bekannten, robusten Rahmen, um den Zugriff zwischen potenziell heterogenen Clients und Servern abzusichern, ohne auf proprietäre Mechanismen angewiesen zu sein. Insbesondere die Unterstützung für dynamische Client-Registrierung unterstreicht die Vision eines flexiblen Plug-and-Play-Ökosystems, in dem Clients nahtlos und sicher mit neuen Diensten interagieren können, ohne dass umfangreiche manuelle Konfigurationen erforderlich sind.

### C. Zugriffskontroll- und Datenisolationsmechanismen

MCP implementiert Zugriffskontrolle und Isolation auf mehreren Ebenen, um die Sicherheit zu erhöhen:

- **Host-basierte Zustimmung:** Die primäre Kontrollebene ist der Host, der die explizite Zustimmung des Benutzers für den Zugriff auf Ressourcen und die Ausführung von Tools einholt.3 Dies stellt sicher, dass der Benutzer die ultimative Kontrolle behält.
- **Architektonische Isolation:** Das 1:1-Verhältnis zwischen Client und Server in der Architektur sorgt für eine natürliche Isolation (Sandboxing) zwischen verschiedenen Server-Verbindungen innerhalb des Hosts.3 Ein Client, der mit Server A verbunden ist, kann nicht auf die Ressourcen oder Daten zugreifen, die über einen anderen Client von Server B gehandhabt werden.4
- **OAuth Scopes:** Innerhalb des OAuth-Autorisierungsflusses können Scopes verwendet werden, um fein granulare Berechtigungen zu definieren und zu erzwingen. Der Authorization Server kann Tokens ausstellen, die nur den Zugriff auf bestimmte Aktionen oder Datenbereiche erlauben (impliziert durch OAuth-Nutzung, erwähnt in Fehlercodes für ungültige Scopes 27).
- **Server-seitige Logik:** MCP-Server können und sollten zusätzliche, anwendungsspezifische Zugriffskontrollen implementieren, basierend auf der Identität des authentifizierten Clients oder Benutzers, die über das OAuth-Token übermittelt wird.

Dieser mehrschichtige Ansatz (Host-Zustimmung, architektonische Isolation, transportbasierte Authentifizierung/Autorisierung via OAuth und server-seitige Logik) schafft eine robuste "Defense-in-Depth"-Strategie. Es wird erschwert, dass ein einzelner Fehlerpunkt das gesamte System kompromittiert, was die Gesamtsicherheit des MCP-Ökosystems stärkt.

### D. Zusammenfassung der Sicherheitsanforderungen

Die folgende Tabelle fasst die wesentlichen Sicherheitsanforderungen gemäß der MCP-Spezifikation und den referenzierten Standards zusammen und dient als Referenz für Implementierer und Prüfer. Die Schlüsselwörter MUSS (MUST), MUSS NICHT (MUST NOT), SOLLTE (SHOULD), SOLLTE NICHT (SHOULD NOT), KANN (MAY) sind gemäß RFC2119/RFC8174 zu interpretieren.6

|   |   |   |   |   |
|---|---|---|---|---|
|**Komponente**|**Kategorie**|**Spezifische Anforderung**|**Schlüsselwort**|**Standard / Referenz**|
|**Host**|Consent (Tool)|Explizite Benutzerzustimmung vor Tool-Aufruf einholen.|MUST|MCP Spec 6|
|**Host**|Consent (Resource)|Explizite Benutzerzustimmung vor Weitergabe von Benutzerdaten an Server einholen.|MUST|MCP Spec 6|
|**Host**|Consent (Sampling)|Explizite Benutzerzustimmung vor jeder Sampling-Anfrage einholen.|MUST|MCP Spec 6|
|**Host**|Data Privacy|Ressourcendaten nicht ohne Benutzerzustimmung an Dritte weitergeben.|MUST NOT|MCP Spec 6|
|**Host**|UI/UX|Klare UI für Überprüfung/Autorisierung von Aktivitäten bereitstellen.|SHOULD|MCP Spec 6|
|**Host/Client/Server**|General Security|Sicherheitspraktiken befolgen, Access Controls implementieren, Datenschutzaspekte berücksichtigen.|SHOULD|MCP Spec 6|
|**Server**|Tool Safety|Tool-Beschreibungen als nicht vertrauenswürdig betrachten (außer von vertrauenswürdigen Servern).|SHOULD|MCP Spec 6|
|**Client (HTTP)**|Authorization (PKCE)|PKCE für alle Authorization Code Grant Flows verwenden.|MUST|MCP Auth Spec 27, OAuth 2.1|
|**Client (HTTP)**|Authorization (Token)|Nur Tokens an Server senden, die vom zugehörigen Auth Server ausgestellt wurden.|MUST NOT|MCP Auth Spec 27|
|**Client (HTTP)**|Authorization (Token)|Access Tokens im Authorization Header senden (Bearer).|MUST|MCP Auth Spec 28|
|**Client (HTTP)**|Authorization (Token)|Access Tokens nicht im URI Query String senden.|MUST NOT|MCP Auth Spec 28|
|**Client (HTTP)**|Auth Discovery|RFC8414 zur Ermittlung von Auth Server Metadaten folgen.|MUST|MCP Auth Spec 27, RFC8414|
|**Client (HTTP)**|Dynamic Registration|RFC7591 für dynamische Client-Registrierung unterstützen.|SHOULD|MCP Auth Spec 27, RFC7591|
|**Server (HTTP)**|Auth Discovery|RFC9728 (via WWW-Authenticate) implementieren oder RFC8414 unterstützen. Fallbacks unterstützen, falls keine Metadaten-Discovery.|MUST/SHOULD|MCP Auth Spec 27, RFC9728/8414|
|**Server (HTTP)**|Authorization (Token)|Nur Tokens akzeptieren, die für eigene Ressourcen gültig sind.|MUST|MCP Auth Spec 27|
|**Server (HTTP)**|Authorization (Token)|Keine anderen Tokens akzeptieren oder weiterleiten.|MUST NOT|MCP Auth Spec 27|
|**Auth Server**|Dynamic Registration|RFC7591 für dynamische Client-Registrierung unterstützen.|SHOULD|MCP Auth Spec 27, RFC7591|
|**Auth Server**|Token Lifetime|Kurzlebige Access Tokens ausstellen.|SHOULD|MCP Auth Spec 27|
|**Auth Server**|Redirect URI|Redirect URIs exakt validieren (gegen vorregistrierte Werte).|MUST|MCP Auth Spec 27|
|**Client/Server (All)**|Transport Security|TLS für Remote-Verbindungen verwenden (impliziert für HTTP+SSE).|SHOULD/MUST|General Best Practice 22|
|**Client/Server (SSE)**|Transport Security|Origin Header validieren, nur an localhost binden (lokal), Authentifizierung implementieren (gegen DNS Rebinding).|MUST/SHOULD|MCP Transport Spec 26|

## VI. MCP-Integration in Desktop-Betriebssysteme (Linux-Fokus)

Ein Kernanliegen der Nutzeranfrage ist die standardisierte Integration von MCP in Desktop-Betriebssysteme, speziell Linux. MCP bietet durch seine Architektur und Transportmechanismen gute Voraussetzungen hierfür.

### A. Nutzung des STDIO-Transports für lokale Integration

Der **STDIO-Transport** ist der primäre und am besten geeignete Mechanismus für die Integration von MCP-Komponenten auf einem lokalen Desktop-System, einschließlich Linux.17

- **Funktionsweise unter Linux:** Eine Host-Anwendung (z. B. ein Desktop-KI-Assistent, eine IDE-Erweiterung) startet den MCP-Server als Kindprozess. Die Kommunikation erfolgt über die Standard-Datenströme (`stdin`, `stdout`), die unter Linux und anderen Unix-artigen Systemen ein fundamentaler Mechanismus für die Interprozesskommunikation (IPC) mittels Pipes sind.20 JSON-RPC-Nachrichten werden über diese Pipes ausgetauscht.22
- **Vorteile für Desktop-Integration:**
    - **Einfachheit:** Es ist keine Netzwerk-Konfiguration (Ports, Firewalls) erforderlich.19
    - **Effizienz:** Die lokale IPC über Pipes hat einen sehr geringen Overhead.19
    - **Kompatibilität:** Viele bestehende Linux-Tools und -Dienstprogramme sind Kommandozeilen-basiert und interagieren über STDIO, was die Kapselung als MCP-Server erleichtert.20
    - **Sicherheit:** Die Kommunikation bleibt auf die lokale Maschine beschränkt, was die Angriffsfläche im Vergleich zu Netzwerkdiensten reduziert (obwohl lokale Sicherheit weiterhin wichtig ist).

Der STDIO-Transport stellt somit eine natürliche Brücke dar, um MCP-Funktionalitäten in die lokale Linux-Desktop-Umgebung zu integrieren. Er ermöglicht es Host-Anwendungen, auf einfache und standardisierte Weise mit lokalen MCP-Servern zu kommunizieren, die Zugriff auf das Dateisystem, lokale Datenbanken oder andere Systemressourcen bieten.

### B. Beispiele für OS-interagierende MCP-Server unter Linux

Die Flexibilität von MCP zeigt sich in der Vielfalt der bereits existierenden Server, die direkt mit dem Betriebssystem interagieren. Viele dieser Beispiele sind plattformübergreifend oder leicht an Linux anpassbar:

- **Dateisystemzugriff:** Server, die Lese-, Schreib- und Auflistungsoperationen auf dem Dateisystem ermöglichen, oft mit konfigurierbaren Zugriffsbeschränkungen 33 ('Filesystem', 'Golang Filesystem Server'). Unter Linux würden diese auf Standard-POSIX-Dateisystem-APIs zugreifen.
- **Dateisuche:** Server, die systemeigene Suchwerkzeuge nutzen. Für Linux wird explizit die Verwendung von `locate` oder `plocate` erwähnt 33 ('Everything Search').
- **Shell-Ausführung:** Server, die die sichere Ausführung von Shell-Befehlen ermöglichen. Beispiele wie 'Terminal-Control' oder 'Windows CLI' 33 konzentrieren sich auf Windows, aber das Konzept ist direkt auf Linux übertragbar (z. B. durch Kapselung von `bash` oder anderen Shells). Projekte wie 'Lilith-Shell' 32 oder Container-basierte Code-Executor 32 demonstrieren dies.
- **Anwendungssteuerung:** Während AppleScript 33 macOS-spezifisch ist, könnten unter Linux ähnliche Server entwickelt werden, die z. B. über D-Bus (siehe unten) oder andere IPC-Mechanismen mit Desktop-Anwendungen interagieren. Browser-Automatisierung 32 und CAD-Steuerung 32 sind weitere Beispiele, die OS-Interaktion erfordern.

Diese Beispiele verdeutlichen, dass MCP nicht nur für den Zugriff auf Remote-APIs oder Datenbanken dient, sondern auch als **standardisierte und sichere Schnittstelle zu lokalen OS-Funktionen** fungieren kann. Anstatt LLMs direkt potenziell gefährliche Shell-Befehle generieren zu lassen, kann ein MCP-Server als Vermittler dienen. Das LLM fordert eine spezifische Aktion über ein MCP-Tool an (z. B. `filesystem/delete_file`), der Host holt die Benutzerzustimmung ein, und erst dann führt der Server die Aktion kontrolliert aus, möglicherweise mit zusätzlichen Sicherheitsprüfungen.6 MCP bietet somit einen sichereren Weg, die Fähigkeiten von LLMs mit den Möglichkeiten des Betriebssystems zu verbinden.

### C. Etablierung von Konventionen für die Linux-Desktop-Integration

Während MCP das _Kommunikationsprotokoll_ standardisiert, definiert es selbst keine spezifischen Konventionen dafür, _wie_ lokale Server auf einem Desktop-System wie Linux entdeckt, gestartet oder verwaltet werden sollen, oder wie gängige Desktop-Funktionen einheitlich abgebildet werden. Für eine nahtlose „Plug-and-Play“-Erfahrung sind jedoch solche Konventionen wahrscheinlich notwendig.

- **Aktueller Stand:** Die Entdeckung und Verwaltung lokaler Server ist oft anwendungsspezifisch. Claude Desktop beispielsweise erlaubt Benutzern das manuelle Hinzufügen von Servern.5
- **Potenzielle Konventionen (Diskussion):**
    - **Server Discovery:** Wie findet eine Host-Anwendung verfügbare lokale MCP-Server?
        - **Dateisystem-basiert:** Standardisierte Verzeichnisse (z. B. `~/.local/share/mcp-servers/` für Benutzer, `/usr/share/mcp-servers/` für systemweite Server) könnten Manifest-Dateien (z. B. im JSON- oder INI-Format) enthalten, die den Server beschreiben (Name, Fähigkeiten, Startbefehl für STDIO). Dies ähnelt dem Vorgehen bei `.desktop`-Dateien oder Systemd Unit-Files.
        - **Registrierungsdienst:** Ein zentraler Dienst (möglicherweise über D-Bus implementiert) könnte eine Liste verfügbarer Server verwalten.
    - **Server Management:** Wie werden lokale Server gestartet und gestoppt?
        - **On-Demand durch Host:** Der Host startet den Serverprozess bei Bedarf über STDIO und beendet ihn danach.23 Dies ist der einfachste Ansatz für STDIO-Server.
        - **Systemd User Services:** Für persistent laufende lokale Server könnten Systemd User Services genutzt werden.
        - **D-Bus Activation:** Falls eine D-Bus-Integration erfolgt, könnte dessen Aktivierungsmechanismus genutzt werden.34
    - **Standardisierte Schnittstellen:** Analog zu Freedesktop.org D-Bus-Schnittstellen (z. B. `org.freedesktop.Notifications`) könnten sich Community-Standards für MCP-Tool- und Ressourcen-Namen für gängige Desktop-Aufgaben entwickeln (z. B. `org.mcpstandard.FileManager.ReadFile`, `org.mcpstandard.Notifications.Send`). Dies würde die Interoperabilität zwischen verschiedenen Hosts und Servern, die ähnliche Funktionen anbieten, erheblich verbessern.

Die Erkenntnis hieraus ist, dass für eine echte Plug-and-Play-Integration auf dem Linux-Desktop wahrscheinlich **zusätzliche Konventionen über das Kern-MCP-Protokoll hinaus** erforderlich sind. Ähnlich wie Freedesktop.org-Standards die Interoperabilität im traditionellen Linux-Desktop ermöglichen, könnten solche Konventionen für MCP die Entdeckung, Verwaltung und konsistente Nutzung lokaler Server vereinfachen. Dies stellt einen Bereich für zukünftige Standardisierungsbemühungen oder die Etablierung von Best Practices durch die Community dar.

### D. Diskussion: MCP und D-Bus – Potenzielle Synergien und Herausforderungen

D-Bus ist der etablierte Standard für lokale IPC und Service-Messaging auf modernen Linux-Desktops.34 Er bietet Mechanismen für Methodenaufrufe, Signale (Events), Properties, Service Discovery und Aktivierung über zentrale Bus-Daemons (Session und System).34 Ein Vergleich mit MCP ergibt:

- **Ziele und Fokus:** Beide ermöglichen lokale IPC, aber mit unterschiedlichen Schwerpunkten. MCP ist speziell auf die Integration von KI/LLMs mit Kontext und Tools ausgerichtet, plattformübergreifend konzipiert und enthält KI-spezifische Primitive wie Sampling.3 D-Bus ist ein allgemeiner IPC-Mechanismus, primär für Linux.34
- **Potenzielle Synergien:**
    - **Discovery/Activation:** D-Bus könnte von MCP-Hosts genutzt werden, um lokal verfügbare MCP-Server zu finden (über registrierte D-Bus-Namen) oder sie bei Bedarf zu starten (D-Bus Activation), insbesondere für Server, die nicht über STDIO laufen.34
    - **Bridging:** Ein MCP-Server könnte als Brücke fungieren und bestehende D-Bus-Dienste als MCP-Tools/Ressourcen für einen KI-Host verfügbar machen. Umgekehrt könnte ein D-Bus-Dienst einen MCP-Client einbetten.
    - **Benachrichtigungen:** D-Bus-Signale könnten von lokalen MCP-Servern genutzt werden, um Hosts über asynchrone Ereignisse zu informieren, obwohl MCP selbst auch Benachrichtigungen unterstützt.
- **Herausforderungen:**
    - **Komplexität:** Eine Integration könnte zusätzliche Komplexität einführen.
    - **Mapping:** Die Abbildung von MCP-Primitiven auf D-Bus-Konzepte (Methoden, Signale, Properties) ist möglicherweise nicht immer direkt oder trivial.
    - **Plattformunabhängigkeit:** Eine starke Abhängigkeit von D-Bus könnte die Portierbarkeit von MCP-Hosts und -Servern auf andere Plattformen erschweren, was dem plattformübergreifenden Ziel von MCP widerspräche.13

MCP und D-Bus erscheinen eher als **komplementäre Technologien** denn als direkte Konkurrenten im Kontext der Linux-Desktop-Integration. MCP liefert das standardisierte, KI-zentrierte Kommunikationsprotokoll, während D-Bus etablierte Mechanismen für Service-Management (Discovery, Activation) und allgemeine IPC auf dem Linux-Desktop bietet. Eine durchdachte Integration könnte die Stärken beider Systeme nutzen, beispielsweise indem D-Bus für das Management lokaler MCP-Server verwendet wird, während die eigentliche Kommunikation über MCP (z. B. via STDIO) läuft. Ein direkter Ersatz des einen durch das andere erscheint unwahrscheinlich und für die jeweiligen Ziele nicht sinnvoll.

### E. Empfehlungen für standardisierte Linux-Integrationsmuster

Basierend auf der Analyse lassen sich folgende Empfehlungen für die Förderung einer standardisierten MCP-Integration unter Linux ableiten:

1. **Priorisierung von STDIO:** Die Verwendung des STDIO-Transports für lokale Linux-Desktop-Server sollte aufgrund seiner Einfachheit, Effizienz und Kompatibilität mit der Prozessverwaltung unter Linux als primärer Mechanismus empfohlen und gefördert werden.
2. **Dateisystem-basierte Discovery:** Eine einfache Konvention zur Server-Entdeckung mittels Manifest-Dateien in standardisierten Verzeichnissen (z. B. `~/.local/share/mcp-servers/`, `/usr/share/mcp-servers/`) sollte etabliert werden. Diese Manifeste sollten Metadaten über den Server und dessen Startmechanismus enthalten.
3. **Definition von Freedesktop-Style-Schnittstellen:** Die Community sollte ermutigt werden, gemeinsame MCP-Tool- und Ressourcen-Schnittstellen für Standard-Desktop-Aufgaben zu definieren (z. B. Dateiverwaltung, Benachrichtigungen, Kalenderzugriff), wobei eine Namenskonvention ähnlich zu D-Bus (z. B. `org.mcpstandard.Namespace.Operation`) verwendet werden könnte, um Interoperabilität zu fördern.
4. **Optionale D-Bus-Integration für Aktivierung:** Muster für die Nutzung von D-Bus zur Aktivierung von Servern (insbesondere für nicht-STDIO-Server oder komplexere Szenarien) könnten als optionale Erweiterung dokumentiert werden. Es sollte jedoch sichergestellt werden, dass die Kernfunktionalität für plattformübergreifende Kompatibilität auch ohne D-Bus erreichbar bleibt.

## VII. MCP in der Praxis: Anwendungsfälle und Beispiele

Die praktische Relevanz von MCP wird durch eine wachsende Zahl von Anwendungsfällen und Implementierungen in verschiedenen Bereichen unterstrichen.

### A. Workflow-Automatisierung

- **Meeting-Planung:** Ein KI-Assistent kann über einen MCP-Server für Google Calendar die Verfügbarkeit prüfen, Zeiten vorschlagen und Meetings planen.4
- **Echtzeit-Datenabfragen:** KI-Systeme können über MCP-Server auf Live-Daten aus Datenbanken wie Postgres zugreifen, um aktuelle Informationen in ihre Antworten einzubeziehen.1
- **Unternehmens-Chatbots:** Ein Chatbot kann über verschiedene MCP-Server hinweg Informationen aus unterschiedlichen internen Systemen (z. B. HR-Datenbank, Projektmanagement-Tool, Slack) in einer einzigen Konversation abrufen und kombinieren.3

### B. Verbesserung von Entwicklerwerkzeugen

- **Kontextbezogene Code-Generierung/-Überprüfung:** IDEs können über MCP-Server für GitHub oder Git auf den spezifischen Kontext eines Projekts (Repository-Inhalte, Issues) zugreifen, wodurch KI-Assistenten relevantere Code-Vorschläge oder Code-Reviews liefern können.1
- **Steuerung von CI/CD-Pipelines:** Integrationen mit Git-Servern über MCP können die Steuerung von Continuous Integration/Continuous Deployment-Prozessen ermöglichen.3
- **Integration in Entwicklungsplattformen:** Werkzeuge wie Zed, Replit, Codeium und Sourcegraph nutzen MCP, um ihre KI-Funktionen zu erweitern.1
- **Debugging-Werkzeuge:** Der MCP Inspector hilft Entwicklern beim Testen und Debuggen ihrer MCP-Server-Implementierungen.8

### C. Integration in Unternehmenssysteme

- **CRM-Zugriff:** KI-Agenten für Vertriebsmitarbeiter können über MCP auf CRM-Systeme wie HubSpot 10 oder Salesforce (impliziert) zugreifen, um Kundeninformationen abzurufen.
- **Kommunikationsanalyse:** MCP-Server für Plattformen wie Slack ermöglichen die Analyse und Priorisierung von Nachrichten.1
- **Interne Systeme bei Early Adopters:** Unternehmen wie Block (Square) und Apollo setzen MCP ein, um internen KI-Assistenten den Zugriff auf proprietäre Dokumente, Wissensdatenbanken, CRM-Daten und Entwicklerwerkzeuge zu ermöglichen.1
- **Zahlungsabwicklung:** Es existieren MCP-Server für die Integration mit Zahlungsdienstleistern wie PayPal.12

Die Breite dieser Anwendungsfälle – von persönlicher Produktivität über spezialisierte Entwicklerwerkzeuge bis hin zu komplexen Unternehmenssystemen – unterstreicht das Potenzial von MCP als universeller Integrationsstandard. Die Flexibilität der Architektur und der Primitive scheint ausreichend zu sein, um Interaktionen mit einer Vielzahl externer Systeme zu modellieren, was die Vision des „USB-C für KI“ 3 stützt und MCP nicht auf eine bestimmte Nische beschränkt.

## VIII. MCP im Vergleich: Kontext im Ökosystem

Um die Positionierung von MCP zu verstehen, ist ein Vergleich mit anderen Ansätzen zur Verbindung von LLMs mit externen Fähigkeiten sinnvoll.

### A. MCP vs. ChatGPT Plugins

- **Standardisierung:** MCP ist als offener, universeller Standard konzipiert, der modell- und anbieterunabhängig ist.7 ChatGPT Plugins sind hingegen spezifisch für das OpenAI-Ökosystem und basieren auf proprietären Spezifikationen.7
- **Architektur:** MCP nutzt eine Client-Server-Architektur, bei der der Host die Clients verwaltet.7 Plugins werden als vom Entwickler gehostete APIs implementiert, die von ChatGPT aufgerufen werden.7
- **Fähigkeiten:** MCP definiert klar die Primitive Tools, Ressourcen und Prompts.7 Plugins konzentrieren sich primär auf Tools (von OpenAI als „Functions“ bezeichnet).7
- **Sicherheit:** MCP legt den Fokus auf Host-seitige Benutzerzustimmung, Sandboxing und optionale OAuth 2.1-Integration.6 Die Sicherheit von Plugins hängt stärker von der Implementierung der Entwickler-API und dem Review-Prozess von OpenAI ab.7
- **Ökosystem:** MCP zielt auf ein breites, herstellerneutrales Ökosystem ab.7 Das Plugin-Ökosystem ist an die ChatGPT-Plattform gebunden.7

### B. MCP vs. LangChain

- **Standardisierung:** MCP ist ein **Kommunikationsprotokoll-Standard**.7 LangChain ist ein **Framework** und eine Bibliothek, kein Protokollstandard.7
- **Architektur:** MCP definiert die Kommunikation zwischen separaten Prozessen oder über Netzwerke (Client-Server).7 LangChain stellt Komponenten bereit, die direkt in den Code der KI-Anwendung integriert werden (Bibliotheks-Ansatz).7
- **Fähigkeiten:** MCP standardisiert die Primitive Tools, Ressourcen und Prompts als Teil des Protokolls.7 LangChain bietet Framework-Abstraktionen für Konzepte wie Tools, Agents, Chains und Prompt Templates.7
- **Sicherheit:** MCP implementiert Kontrollen auf Protokoll- und Host-Ebene (Zustimmung, OAuth).7 Bei LangChain liegt die Verantwortung für die sichere Nutzung externer Ressourcen beim Entwickler der Anwendung.7
- **Ökosystem:** MCP konzentriert sich auf interoperable Server und Clients.7 Das LangChain-Ökosystem fokussiert sich auf Framework-Komponenten, Integrationen und Vorlagen für den Aufbau von Anwendungen.7

### C. Analyse: Standardisierung, Offenheit, Fähigkeiten, Sicherheit

Das Hauptunterscheidungsmerkmal und der primäre Vorteil von MCP liegen in seinem Fokus darauf, ein **offener, interoperabler Protokollstandard** zu sein.1 Ziel ist es, KI-Anwendungen von spezifischen Werkzeugen und Plattformen zu entkoppeln.

MCP, ChatGPT Plugins und LangChain adressieren zwar ähnliche Probleme (Verbindung von LLMs mit externen Fähigkeiten), tun dies jedoch auf unterschiedlichen Ebenen oder mit unterschiedlichen Philosophien. Plugins erweitern eine spezifische Plattform (ChatGPT). LangChain bietet ein Framework zum _Bauen_ von Anwendungen, _innerhalb_ derer Integrationen stattfinden. MCP hingegen konzentriert sich auf die Standardisierung des **Kommunikationskanals** zwischen potenziell unterschiedlichen Systemen (Hosts und Servern). Dieser Fokus auf das "Wire Protocol" positioniert MCP einzigartig, um ein heterogenes Ökosystem zu fördern, in dem Komponenten von verschiedenen Anbietern oder Entwicklern zusammenarbeiten können.

Es besteht auch Potenzial für **Komplementarität**. Eine mit LangChain gebaute Anwendung könnte als MCP-Host fungieren und die Logik von LangChain-Agents nutzen, um Interaktionen mit externen Systemen über standardisierte MCP-Clients und -Server zu orchestrieren.12 Bestehende LangChain-Tools könnten als MCP-Server gekapselt werden. MCP definiert die _Schnittstelle_ (den Stecker), während Frameworks wie LangChain die _Logik_ hinter dem Agenten bereitstellen können, der diesen Stecker verwendet.

## IX. Das MCP-Ökosystem und zukünftige Richtungen

Seit seiner Einführung Ende 2024 hat MCP schnell an Dynamik gewonnen und ein wachsendes Ökosystem aufgebaut.

### A. Aktueller Stand: SDKs, Server-Repositories, Community-Beiträge

- **SDKs:** Offizielle SDKs sind für eine breite Palette von Sprachen verfügbar (TypeScript, Python, Java, Kotlin, C#, Rust, Swift), was die Entwicklung erleichtert.13 Einige davon werden in Zusammenarbeit mit wichtigen Akteuren der Branche wie Microsoft, JetBrains, Spring AI und loopwork-ai gepflegt.13
- **Server-Repositories:** Ein offizielles Repository (`modelcontextprotocol/servers`) enthält Referenzimplementierungen für gängige Systeme.1 Darüber hinaus katalogisieren Community-Listen wie "Awesome MCP Servers" Hunderte oder sogar Tausende von Servern 31, was auf ein schnelles Wachstum hindeutet.4
- **Community und Tooling:** MCP wird als offenes Projekt von Anthropic betrieben und ist offen für Beiträge.1 Es entstehen inoffizielle SDKs (z. B. für.NET 15) und ergänzende Werkzeuge.15 Der MCP Inspector ist ein wichtiges Werkzeug für das Debugging.8

### B. Adoption und Schlüsselakteure

- **Initiator:** Anthropic nutzt MCP selbst in seiner Claude Desktop App.1
- **Frühe Anwender:** Unternehmen wie Block, Apollo, Sourcegraph, Zed, Replit und Codeium haben MCP frühzeitig adaptiert.1
- **Breitere Akzeptanz:** Es gibt Berichte über eine Übernahme durch OpenAI und Google DeepMind 11 (wobei diese über die vorliegenden Quellen hinaus verifiziert werden müssten). Die Zusammenarbeit bei SDKs mit Microsoft, JetBrains und Spring AI 13 sowie Integrationen wie die von PayPal 12 deuten auf eine breitere Akzeptanz hin.

Das schnelle Wachstum von SDKs, Community-Servern und die Adoption durch diverse Unternehmen kurz nach dem Start deuten auf eine starke anfängliche Dynamik und einen wahrgenommenen Wert des Standards hin.1 Die Kollaborationen bei den SDKs sind besonders bemerkenswert, da sie MCP tief in populäre Entwicklungsökosysteme integrieren und signalisieren, dass MCP ein echtes Problem (das M×N-Problem 3) auf eine Weise löst, die bei Industrie und Community Anklang findet.

### C. Potenzielle Roadmap und zukünftige Erweiterungen

Offizielle, detaillierte Roadmap-Informationen sind in den analysierten Quellen begrenzt.35 Es gibt jedoch Hinweise und plausible Annahmen über zukünftige Entwicklungen:

- **Fokus auf Enterprise Deployment:** Anthropic hat Pläne für Entwickler-Toolkits zur Bereitstellung von Remote-Produktions-MCP-Servern für Unternehmenskunden (Claude for Work) erwähnt.1 Dies deutet auf einen Fokus hin, MCP für den stabilen, skalierbaren und managebaren Einsatz in Unternehmen zu härten.
- **Ökosystem-Reifung:** Zukünftige Arbeiten werden wahrscheinlich die Verbesserung der Entwicklererfahrung (bessere Werkzeuge, Dokumentation 4), die Erweiterung des Server-Ökosystems 4 und potenziell die Ergänzung von Funktionen für komplexere Orchestrierung oder Governance basierend auf Praxis-Feedback umfassen.
- **Mögliche neue Funktionen:** In frühen Planungsdokumenten wurden Ideen wie erweiterte Prompt-Vorlagen oder Multi-Server-Orchestrierung genannt (dies bleibt spekulativ ohne offizielle Bestätigung). Community-Vorschläge wie MCPHub als Discovery Service 15 könnten ebenfalls Einfluss nehmen.
- **Weitere SDKs:** Die Unterstützung weiterer Programmiersprachen ist denkbar.15

Die Weiterentwicklung wird sich wahrscheinlich darauf konzentrieren, MCP robuster für den Unternehmenseinsatz zu machen und das Ökosystem durch verbesserte Werkzeuge und eine wachsende Zahl von Servern weiter zu stärken. Die genauen Features werden sich vermutlich aus den Bedürfnissen der frühen Anwender und der Community ergeben.

## X. Fazit: MCP als fundamentaler Standard

Das Model Context Protocol (MCP) positioniert sich als eine potenziell transformative Technologie im Bereich der künstlichen Intelligenz. Durch die Bereitstellung eines **offenen, standardisierten Protokolls** adressiert es effektiv das **M×N-Integrationsproblem**, das bisher die nahtlose Verbindung von LLMs mit der Außenwelt behinderte.1

Die Kernvorteile von MCP liegen in der Förderung von **Interoperabilität**, der **Reduzierung von Entwicklungskomplexität** und der **Erhöhung der Flexibilität**, da Anwendungen und Werkzeuge unabhängig von spezifischen LLM-Anbietern oder Plattformen entwickelt werden können.3 Die klare Client-Host-Server-Architektur, gepaart mit definierten Primitiven (Tools, Ressourcen, Prompts) und Transportmechanismen (STDIO, HTTP+SSE), schafft eine robuste Grundlage für die Kommunikation.3

Besonders hervorzuheben ist der **integrierte Fokus auf Sicherheit und Governance**. Die Betonung der Benutzerzustimmung, die architektonische Isolation und die optionale Integration von modernen Standards wie OAuth 2.1 tragen dazu bei, Vertrauen aufzubauen und den Einsatz in sensiblen Umgebungen zu ermöglichen.6

Für die **Integration in Desktop-Betriebssysteme wie Linux** bietet MCP mit dem STDIO-Transport einen natürlichen und effizienten Mechanismus für lokale Interaktionen.17 Um jedoch das volle Potenzial einer Plug-and-Play-Erfahrung zu realisieren, sind wahrscheinlich zusätzliche Konventionen für die Server-Entdeckung und -Verwaltung sowie für standardisierte Schnittstellen für gängige Desktop-Aufgaben erforderlich, möglicherweise inspiriert von bestehenden Freedesktop.org-Standards.

MCP erleichtert die Entwicklung von **leistungsfähigeren, kontextbezogeneren und agentischeren KI-Anwendungen**, indem es ihnen einen universellen Zugang zu den benötigten externen Fähigkeiten ermöglicht.2 Die schnelle anfängliche Adoption und das wachsende Ökosystem deuten darauf hin, dass MCP das Potenzial hat, sich als **fundamentale Schicht für die nächste Generation integrierter KI-Systeme** zu etablieren.1 Sein langfristiger Erfolg wird jedoch von der kontinuierlichen Weiterentwicklung des Standards und vor allem von der breiten Annahme und den Beiträgen der Entwickler-Community abhängen.
Die tiefe Integration des Model Context Protocol (MCP) in die beschriebene Desktop-Umgebung eröffnet eine Vielzahl von Möglichkeiten, um eine KI-gestützte, aber stets benutzerkontrollierte und sichere Erfahrung zu schaffen. MCP fungiert als standardisierte Schnittstelle ("USB-Port für KI" ), die es der Desktop-Umgebung (dem "Host" ) ermöglicht, sicher und flexibel mit verschiedenen KI-Modellen (LLMs) sowie externen Datenquellen und Werkzeugen über sogenannte MCP-Server zu kommunizieren.

Hier sind die Kernmöglichkeiten, die sich daraus ergeben:

1. **Sichere und kontrollierte KI-Interaktionen:**
    
    - **Benutzereinwilligung im Zentrum:** Das Kernprinzip ist, dass keine KI-Aktion (Tool-Nutzung) oder kein Datenzugriff (Ressourcen-Nutzung) ohne die explizite, informierte Zustimmung des Benutzers erfolgen darf. Der Desktop als Host ist dafür verantwortlich, diese Einwilligungen über klare Dialoge einzuholen.
        
    - **Granulare Kontrolle:** Benutzer behalten die Kontrolle darüber, welche Daten geteilt und welche Aktionen ausgeführt werden. Dies schließt auch die fortgeschrittene "Sampling"-Funktion ein, bei der der Server LLM-Interaktionen anstoßen kann – auch hier ist explizite Benutzerkontrolle unerlässlich.
        
    - **Datenschutz:** Der Host stellt sicher, dass Benutzerdaten gemäß den erteilten Einwilligungen geschützt und nicht unbefugt weitergegeben werden.
        
2. **Zugriff auf externe Werkzeuge (Tools):**
    
    - **KI-gesteuerte Aktionen:** LLMs können über MCP definierte "Tools" aufrufen, um Aktionen in externen Systemen auszuführen. Die Entscheidung zur Tool-Nutzung trifft primär das LLM basierend auf der Benutzeranfrage.
        
    - **Vielfältige Anwendungsfälle:** Beispiele reichen vom Senden von E-Mails, Erstellen von Kalendereinträgen bis hin zur Interaktion mit Diensten wie GitHub (Issues erstellen/lesen, Code suchen) oder anderen APIs.
        
3. **Nutzung externer Datenquellen (Resources):**
    
    - **Kontextanreicherung:** LLMs können über "Resources" auf Daten aus externen Quellen zugreifen, um ihre Antworten mit aktuellem oder spezifischem Kontext anzureichern. Dies geschieht primär lesend, ohne Seiteneffekte.
        
    - **Beispiele:** Abruf von Benutzerprofilen, Produktkatalogen, Dokumentinhalten, Kalenderdaten oder auch (mit Zustimmung) lokalen Dateien.
        
4. **Standardisierte Interaktionsmuster (Prompts):**
    
    - **Benutzergeführte Interaktion:** "Prompts" sind vordefinierte Vorlagen, die der Benutzer (über den Desktop-Host) auswählen kann, um Interaktionen mit Tools oder Ressourcen optimal und standardisiert zu gestalten.
        
    - **Anwendungsbeispiele:** Standardisierte Abfragen (z.B. "Fasse Pull Request X zusammen"), geführte Workflows oder häufig genutzte Befehlssätze, die in der UI als Buttons o.ä. erscheinen können.
        
5. **Ermöglichung intelligenter Agenten (Sampling):**
    
    - **Proaktive KI:** Die "Sampling"-Funktion erlaubt es einem MCP-Server (mit expliziter Zustimmung und Kontrolle des Benutzers), das LLM über den Desktop-Client proaktiv zu Interaktionen aufzufordern.
        
    - **Potenzial:** Dies ermöglicht intelligentere, proaktivere Agenten, die auf externe Ereignisse reagieren oder komplexe, mehrstufige Aufgaben ausführen können. Aufgrund des hohen Potenzials für Missbrauch unterliegt diese Funktion strengsten Kontrollanforderungen.
        

**Konkrete Beispiele im Desktop-Kontext:**

- **Intelligente Sprachsteuerung:** Benutzer können Befehle wie "Öffne den Dateimanager" oder "Aktiviere den Dunkelmodus" sprechen. Die KI interpretiert dies und nutzt (nach Zustimmung) interne MCP-Tools, um die Desktop-Funktionen zu steuern.
- **Automatisierte Dateibearbeitung/-analyse:** Die KI kann (nach expliziter Freigabe durch den Benutzer) Inhalte von Dokumenten zusammenfassen, Daten analysieren oder Textentwürfe erstellen, indem sie auf das Dateisystem als MCP-Ressource zugreift oder spezielle Analyse-Tools nutzt.
- **Kontextbezogene Webansichten/Widgets:** Widgets können, gesteuert durch die KI und MCP, relevante Informationen aus dem Web oder anderen Quellen anzeigen, die zum aktuellen Arbeitskontext passen (z.B. über ein Web-Such-Tool ).
    
- **Entwickler-Workflows:** Direkte Interaktion mit GitHub aus der IDE/Desktop-Umgebung heraus, z.B. zum Zusammenfassen von Issues oder Analysieren von Pull Requests über einen GitHub-MCP-Server.
    

Zusammenfassend ermöglicht die tiefe MCP-Integration eine leistungsstarke und flexible KI-Unterstützung direkt im Desktop, wobei durch das Protokoll-Design und die Host-Implementierung Sicherheit und Benutzerkontrolle stets gewährleistet bleiben. Es standardisiert die Anbindung externer Fähigkeiten und Daten, reduziert die Integrationskomplexität und schafft die Basis für vielfältige, kontextbewusste KI-Anwendungen
# Entwicklungsrichtlinien und Spezifikation für die Integration und Implementierung des Model Context Protocol (MCP)

**Präambel:** Dieses Dokument dient als maßgebliche Ressource für Entwickler, die das Model Context Protocol (MCP) integrieren oder implementieren. Es legt die Spezifikationen des Protokolls dar und bietet detaillierte Richtlinien zur Gewährleistung robuster, sicherer und interoperabler Implementierungen. Die in diesem Dokument verwendeten Schlüsselwörter “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,...[source](https://www.funkschau.de/office-kommunikation/sip-oder-sip-ein-protokoll-bereitet-probleme.82250/seite-4.html) “NOT RECOMMENDED”, “MAY”, und “OPTIONAL” sind gemäß BCP 14, zu interpretieren, wenn sie in Großbuchstaben erscheinen.1

**1. Einführung in das Model Context Protocol (MCP)**

Das Model Context Protocol (MCP) stellt einen Paradigmenwechsel in der Art und Weise dar, wie KI-Systeme mit externen Daten und Werkzeugen interagieren. Es wurde entwickelt, um die wachsenden Herausforderungen der Integration von Large Language Models (LLMs) in komplexe Anwendungslandschaften zu bewältigen.

- **1.1. Zweck und Vision des MCP**

Das Model Context Protocol (MCP), eingeführt von Anthropic Ende 2024, ist ein bahnbrechender offener Standard, der konzipiert wurde, um die Lücke zwischen KI-Assistenten und den datenreichen Ökosystemen, in denen sie operieren müssen, zu schließen.2 Die Kernvision des MCP besteht darin, die oft fragmentierten und ad-hoc entwickelten Integrationen durch ein universelles Framework zu ersetzen. Dieses Framework ermöglicht es KI-Systemen, nahtlos auf diverse Kontexte zuzugreifen und mit externen Tools und Datenquellen zu interagieren.2

Das primäre Ziel des MCP ist die Standardisierung der Art und Weise, wie KI-Anwendungen – seien es Chatbots, in IDEs integrierte Assistenten oder benutzerdefinierte Agenten – Verbindungen zu externen Werkzeugen, Datenquellen und Systemen herstellen.3 Man kann sich MCP als eine Art "USB-Port" für KI-Anwendungen vorstellen: eine universelle Schnittstelle, die es jedem KI-Assistenten erlaubt, sich ohne spezifischen Code für jede einzelne Verbindung an jede Datenquelle oder jeden Dienst anzuschließen.4

Die Bedeutung des MCP liegt in seiner Fähigkeit, die Reproduzierbarkeit von KI-Ergebnissen zu verbessern, indem der gesamte Modellkontext – Datensätze, Umgebungsspezifikationen und Hyperparameter – an einem Ort zusammengeführt wird. Darüber hinaus fördert es die Standardisierung und erleichtert die organisationsübergreifende Zusammenarbeit, da Unternehmen spezialisierte KI-Tools oder benutzerdefinierte Datenquellen auf einer gemeinsamen Basis teilen können.2

- **1.2. Kernvorteile für Entwickler und Organisationen**

Die Einführung und Adaption des MCP bietet signifikante Vorteile für Entwicklerteams und die Organisationen, in denen sie tätig sind. Diese Vorteile manifestieren sich in Effizienzsteigerungen, beschleunigter Innovation und verbesserter Systemstabilität.

Ein zentraler Vorteil ist die **Reduzierung der Integrationskomplexität**. Traditionell stehen Entwickler vor einem M×N-Integrationsproblem: M verschiedene KI-Anwendungen müssen mit N verschiedenen Tools oder Systemen (wie GitHub, Slack, Datenbanken etc.) verbunden werden. Dies führt oft zu M×N individuellen Integrationen, was erheblichen Mehraufwand, duplizierte Arbeit über Teams hinweg und inkonsistente Implementierungen zur Folge hat. MCP zielt darauf ab, dies zu vereinfachen, indem es das Problem in ein "M+N-Problem" transformiert: Tool-Ersteller entwickeln N MCP-Server (einen für jedes System), während Anwendungsentwickler M MCP-Clients (einen für jede KI-Anwendung) erstellen.3 Dieser Ansatz stellt einen fundamentalen Effizienzgewinn dar, da er die Notwendigkeit redundanter Integrationsarbeit eliminiert.

Direkt damit verbunden ist die **schnellere Tool-Integration**. MCP ermöglicht einen "Plug-and-Play"-Ansatz für die Anbindung neuer Fähigkeiten. Anstatt jede Integration von Grund auf neu zu entwickeln, können bestehende MCP-Server, die als standardisierte Schnittstellen für spezifische Tools oder Datenquellen dienen, einfach angebunden werden.6 Wenn beispielsweise ein MCP-Server für Google Drive oder eine SQL-Datenbank existiert, kann jede MCP-kompatible KI-Anwendung diesen Server nutzen und sofort die entsprechende Fähigkeit erlangen.6

Des Weiteren führt MCP zu einer **verbesserten Interoperabilität**. Indem es ein standardisiertes Protokoll bereitstellt, können verschiedene KI-gesteuerte Anwendungen dieselbe zugrundeliegende Infrastruktur für die Verbindung mit Tools, Ressourcen und Prompts nutzen.4 Dies bedeutet, dass Anfragen und Antworten über verschiedene Tools hinweg konsistent formatiert und gehandhabt werden, was die Entwicklung und Wartung vereinfacht.6

Schließlich **ermöglicht MCP die Entwicklung autonomerer Agenten**. KI-Agenten sind nicht länger auf ihr internes, vortrainiertes Wissen beschränkt. Sie können aktiv Informationen aus externen Quellen abrufen oder Aktionen in mehrstufigen, komplexen Workflows ausführen.6 Ein Agent könnte beispielsweise Daten aus einem CRM-System abrufen, darauf basierend eine E-Mail über ein Kommunikationstool senden und anschließend einen Eintrag in einer Datenbank protokollieren – alles über MCP-gesteuerte Interaktionen.6

Die Summe dieser Vorteile – reduzierte Komplexität, schnellere Integration, Interoperabilität und die Befähigung autonomer Agenten – positioniert MCP nicht nur als eine technische Verbesserung, sondern als einen fundamentalen Baustein. Dieser Baustein hat das Potenzial, die Entwicklung anspruchsvollerer, kontextbewusster und handlungsfähiger KI-Systeme maßgeblich voranzutreiben und zu beschleunigen. Für Unternehmen, die KI-gestützte Produkte entwickeln, ergeben sich hieraus strategische Implikationen hinsichtlich Entwicklungsgeschwindigkeit und Innovationsfähigkeit.

- **1.3. Abgrenzung zu bestehenden Standards**

Obwohl etablierte Standards wie OpenAPI, GraphQL oder SOAP für API-Interaktionen existieren und weit verbreitet sind, wurde das Model Context Protocol speziell mit den Anforderungen moderner KI-Agenten im Fokus entwickelt – es ist sozusagen "AI-Native".3 Während die genannten Standards primär auf den Datenaustausch zwischen Diensten ausgerichtet sind, adressiert MCP die spezifischen Bedürfnisse von LLMs, die nicht nur Daten konsumieren, sondern auch Aktionen ausführen und in komplexen, kontextabhängigen Dialogen agieren müssen.

MCP verfeinert und standardisiert Muster, die sich in der Entwicklung von KI-Agenten bereits abzeichnen. Eine Schlüsselunterscheidung ist die klare Trennung der exponierten Fähigkeiten in drei Kategorien: **Tools** (modellgesteuerte Aktionen), **Resources** (anwendungsgesteuerte Daten) und **Prompts** (benutzergesteuerte Interaktionsvorlagen).3 Diese granulare Unterscheidung ermöglicht eine feinere Steuerung und ein besseres Verständnis der Interaktionsmöglichkeiten eines LLMs mit seiner Umgebung, was über die typischen Request-Response-Zyklen traditioneller APIs hinausgeht.

- **1.4. Inspiration und Ökosystem-Vision**

Die Konzeption des MCP ist maßgeblich vom Language Server Protocol (LSP) inspiriert. Das LSP hat erfolgreich standardisiert, wie Entwicklungswerkzeuge (IDEs, Editoren) Unterstützung für verschiedene Programmiersprachen integrieren können, was zu einem florierenden Ökosystem von Sprachservern und kompatiblen Tools geführt hat.1

Analog dazu zielt MCP darauf ab, die Integration von zusätzlichem Kontext und externen Werkzeugen in das wachsende Ökosystem von KI-Anwendungen zu standardisieren.1 Diese Analogie deutet auf ein erhebliches Potenzial für eine breite Akzeptanz und das Wachstum einer aktiven Community hin. Die Vision ist ein Ökosystem, in dem Entwickler eine Vielzahl von vorgefertigten MCP-Servern für unterschiedlichste Dienste und Datenquellen finden und nutzen können, und ebenso einfach eigene Server bereitstellen können, die von einer breiten Palette von KI-Anwendungen konsumiert werden. Die "Offenheit" des Standards ist hierbei ein kritischer Erfolgsfaktor. Offene Standards, die nicht an einen einzelnen Anbieter gebunden sind und von einer Community weiterentwickelt werden können, fördern typischerweise eine breitere Akzeptanz.3 Die Existenz einer detaillierten und qualitativ hochwertigen Spezifikation, wie sie für MCP vorliegt 3, unterstreicht die Ernsthaftigkeit dieses offenen Ansatzes. Für Entwickler bedeutet dies eine höhere Wahrscheinlichkeit für langfristige Stabilität des Protokolls, eine größere Auswahl an kompatiblen Tools und Bibliotheken sowie die Möglichkeit, aktiv zum Ökosystem beizutragen. Eine Investition in MCP-Kenntnisse und -Implementierungen erscheint somit zukunftssicherer.

**2. MCP-Architektur und Komponenten**

Das Fundament des Model Context Protocol bildet eine klar definierte Architektur, die auf einem Client-Host-Server-Modell basiert. Dieses Modell strukturiert die Interaktionen und Verantwortlichkeiten der beteiligten Systeme und ist entscheidend für das Verständnis der Funktionsweise von MCP.

- **2.1. Das Client-Host-Server-Modell**

MCP verwendet ein Client-Host-Server-Muster, um die Kommunikation und den Austausch von "Kontext" zwischen KI-Anwendungen und externen Systemen zu standardisieren.2 Dieses Muster ist nicht nur eine technische Wahl, sondern eine grundlegende Designentscheidung, die Skalierbarkeit, Sicherheit und Wartbarkeit des Gesamtsystems beeinflusst. Die klare Trennung der Verantwortlichkeiten zwischen Host, Client und Server ermöglicht es, dass verschiedene Teams oder sogar Organisationen diese Komponenten unabhängig voneinander entwickeln und warten können. Dies ist ein direkter Lösungsansatz für das zuvor erwähnte M+N-Integrationsproblem.3

- Host (Anwendung):
    
    Der Host ist die primäre Anwendung, mit der der Endbenutzer direkt interagiert.3 Beispiele hierfür sind Desktop-Anwendungen wie Claude Desktop, integrierte Entwicklungsumgebungen (IDEs) wie Cursor oder auch speziell entwickelte, benutzerdefinierte KI-Agenten.3 Der Host fungiert als eine Art "Container" oder Koordinator für eine oder mehrere Client-Instanzen.2 Eine seiner zentralen Aufgaben ist die Verwaltung von Lebenszyklus- und Sicherheitsrichtlinien. Dies umfasst die Handhabung von Berechtigungen, die Benutzerautorisierung und insbesondere die Durchsetzung von Einwilligungsanforderungen für Datenzugriffe und Tool-Ausführungen.1 Diese Rolle ist kritisch für die Gewährleistung der Sicherheit und des Datenschutzes im MCP-Ökosystem. Der Host überwacht zudem, wie die Integration von KI- oder Sprachmodellen innerhalb jeder Client-Instanz erfolgt, und führt bei Bedarf Kontextinformationen aus verschiedenen Quellen zusammen.2 Eine unverzichtbare Anforderung an den Host ist, dass er die explizite Zustimmung des Benutzers einholen MUSS, bevor Benutzerdaten an MCP-Server weitergegeben werden.1
    
- Client (Konnektor):
    
    Der Client ist eine Komponente, die innerhalb der Host-Anwendung angesiedelt ist.2 Seine Hauptaufgabe ist die Verwaltung der Kommunikation und der Verbindung zu einem spezifischen MCP-Server. Es besteht eine strikte 1:1-Beziehung zwischen einer Client-Instanz und einer Server-Verbindung.2 Ein Host kann jedoch mehrere solcher Client-Instanzen initialisieren, um mit verschiedenen Servern gleichzeitig zu kommunizieren, falls die KI-Anwendung Zugriff auf unterschiedliche Tools oder Datenquellen benötigt.2 Der Client ist verantwortlich für die Aushandlung der Fähigkeiten (Capability Negotiation) mit dem Server und orchestriert den Nachrichtenfluss zwischen sich und dem Server.2 Ein wichtiger Aspekt ist die Wahrung von Sicherheitsgrenzen: Ein Client sollte nicht in der Lage sein, auf Ressourcen zuzugreifen oder Informationen einzusehen, die einem anderen Client (und somit einer anderen Server-Verbindung) zugeordnet sind.2 Er fungiert somit als dedizierter und isolierter Vermittler zwischen dem Host und den externen Ressourcen, die über einen bestimmten MCP-Server bereitgestellt werden.4 Die 1:1-Beziehung zwischen Client und Server vereinfacht das Design dieser beiden Komponenten erheblich, da sie sich jeweils nur auf eine einzige, klar definierte Kommunikationsbeziehung konzentrieren müssen. Dies verlagert jedoch die Komplexität der Orchestrierung mehrerer solcher Beziehungen in den Host, der Mechanismen für die Entdeckung, Initialisierung und Koordination der verschiedenen Clients implementieren muss.
    
- Server (Dienst):
    
    Der MCP-Server ist ein externes Programm oder ein Dienst, der Funktionalitäten in Form von Tools, Daten als Ressourcen und vordefinierte Interaktionsmuster als Prompts über eine standardisierte API bereitstellt.2 Ein Server kann entweder als lokaler Prozess auf derselben Maschine wie der Host/Client laufen oder als ein entfernter Dienst implementiert sein. Er kapselt typischerweise den Zugriff auf spezifische Datenquellen (z.B. Datenbanken, Dateisysteme), externe APIs (z.B. CRM-Systeme, Git-Repositories) oder andere Dienstprogramme.2 Der Server agiert als Brücke oder API zwischen der abstrakten MCP-Welt und der konkreten Funktionalität eines externen Systems.3 Dabei ist es unerlässlich, dass der Server die vom Host durchgesetzten Sicherheitsbeschränkungen und Benutzerberechtigungen strikt einhält.2
    

Die folgende Tabelle fasst die Rollen und Verantwortlichkeiten der MCP-Komponenten zusammen:

**Tabelle 1: MCP-Rollen und Verantwortlichkeiten**

|   |   |   |   |
|---|---|---|---|
|**Rolle**|**Hauptverantwortlichkeiten**|**Schlüsselfunktionen/Interaktionen**|**Wichtige Sicherheitsaspekte**|
|**Host**|Benutzerinteraktion, Koordination von Clients, Verwaltung von Lebenszyklus- und Sicherheitsrichtlinien, KI-Integration|Startet Clients, führt Kontext zusammen, zeigt UI für Einwilligungen an, leitet Anfragen an Clients weiter|**MUSS** Benutzereinwilligung für Datenzugriff/Tool-Nutzung einholen 1, Berechtigungsmanagement, Durchsetzung von Datenschutzrichtlinien, Schutz vor unautorisiertem Client-Zugriff|
|**Client**|Verwaltung der Verbindung zu einem spezifischen Server, Nachrichtenorchestrierung, Capability Negotiation|Stellt Verbindung zu einem Server her (1:1), handelt Fähigkeiten aus, sendet Anfragen an Server, empfängt Antworten, wahrt Sicherheitsgrenzen|Stellt sicher, dass Ressourcen nicht zwischen Clients geteilt werden 2, sichere Kommunikation mit dem Server (Transportverschlüsselung)|
|**Server**|Bereitstellung von Tools, Ressourcen und Prompts, Kapselung externer Systeme|Definiert und exponiert Fähigkeiten, verarbeitet Client-Anfragen, greift auf Backend-Systeme zu, liefert Ergebnisse/Daten zurück|**MUSS** vom Host durchgesetzte Sicherheitsbeschränkungen/Benutzerberechtigungen einhalten 2, sichere Anbindung an Backend-Systeme, Schutz der exponierten Daten und Funktionen|

Diese klare Abgrenzung der Rollen ist fundamental. Entwickler müssen die spezifische Rolle ihrer Komponente genau verstehen und die definierten Schnittstellen und Verantwortlichkeiten respektieren. Insbesondere Host-Entwickler tragen eine große Verantwortung für die korrekte Implementierung der Sicherheits- und Einwilligungsmechanismen, während Server-Entwickler sich darauf verlassen können müssen, dass der Host diese korrekt handhabt.

- **2.2. Interaktionsfluss zwischen den Komponenten**

Ein typischer Interaktionsfluss im MCP-Modell verdeutlicht das Zusammenspiel der Komponenten:

1. **KI-Anfrage:** Eine KI-Anwendung (oder ein Benutzer über den Host) initiiert eine Anfrage, beispielsweise um freie Zeitfenster im Kalender eines Benutzers abzurufen oder eine Zusammenfassung eines Dokuments zu erstellen.2 Diese Anfrage wird im Host verarbeitet.
2. **Weiterleitung an den Client:** Der Host identifiziert den zuständigen Client, der mit dem MCP-Server verbunden ist, welcher die benötigte Funktionalität (z.B. Kalenderzugriff) bereitstellt. Die Anfrage wird an diesen Client übergeben.
3. **Client-Server-Kommunikation:** Der Client formatiert die Anfrage gemäß dem MCP-Protokoll (JSON-RPC) und sendet sie an den verbundenen MCP-Server.
4. **Serververarbeitung:** Der MCP-Server empfängt die Anfrage, validiert sie und führt die entsprechende Aktion aus – beispielsweise den Abruf der Kalenderdaten des Benutzers aus einem Backend-Kalendersystem.2
5. **Antwort an den Client:** Der Server sendet das Ergebnis (z.B. die Liste der freien Zeitfenster) als MCP-Antwort zurück an den Client.2
6. **Weiterleitung an den Host/KI:** Der Client empfängt die Antwort und leitet die relevanten Daten an den Host oder direkt an die KI-Logik innerhalb des Hosts weiter.
7. **KI-Output/Aktion:** Die KI verarbeitet die erhaltenen Daten und erstellt eine passende Antwort für den Benutzer oder führt eine weiterführende Aktion aus, wie beispielsweise das automatische Planen eines Termins.2

Dieser exemplarische Workflow unterstreicht die zentrale Betonung von Benutzerkontrolle, Datenschutz, Sicherheit bei der Tool-Ausführung und Kontrollen für das LLM-Sampling. Diese Aspekte werden als grundlegende Pfeiler für die Entwicklung vertrauenswürdiger und praxistauglicher KI-Lösungen im Rahmen des MCP angesehen.2

**3. MCP Kernfunktionalitäten für Entwickler**

MCP-Server bieten Clients drei Hauptkategorien von Fähigkeiten (Capabilities) an: Tools, Resources und Prompts. Zusätzlich können Clients Servern die Fähigkeit zum Sampling anbieten. Diese Unterscheidung ist nicht nur terminologisch, sondern fundamental für das Design von MCP-Interaktionen, da sie verschiedene Kontroll- und Verantwortlichkeitsbereiche widerspiegelt: Das LLM entscheidet über die Nutzung von Tools, die Anwendung (Host) über den bereitzustellenden Ressourcenkontext und der Benutzer über die Auswahl von Prompts. Diese Trennung ermöglicht es Entwicklern, feingranulare Kontrollen darüber zu implementieren, wie und wann ein LLM auf externe Systeme zugreifen oder Aktionen ausführen darf.

- **3.1. Tools (Modellgesteuert)**

**Definition:** Tools sind im Wesentlichen Funktionen, die von Large Language Models (LLMs) aufgerufen werden können, um spezifische Aktionen in externen Systemen auszuführen.3 Man kann dies als eine standardisierte Form des "Function Calling" betrachten, wie es auch in anderen LLM-Frameworks bekannt ist.3 Die Entscheidung, wann und wie ein Tool basierend auf einer Benutzeranfrage oder einem internen Ziel des LLMs verwendet wird, liegt primär beim Modell selbst.

**Anwendungsfälle:** Die Bandbreite reicht von einfachen Aktionen wie dem Abruf aktueller Wetterdaten über eine API 3 bis hin zu komplexeren Operationen. Beispiele hierfür sind das Senden von E-Mails, das Erstellen von Kalendereinträgen, das Ausführen von Code-Snippets oder die Interaktion mit Diensten wie GitHub, um beispielsweise Issues zu erstellen, Code in Repositories zu suchen oder Pull Requests zu bearbeiten.8

Implementierungsaspekte:

MCP-Server sind dafür verantwortlich, die verfügbaren Tools zu definieren. Dies beinhaltet den Namen des Tools, eine Beschreibung seiner Funktion und ein Schema für die erwarteten Parameter [16 (Tool struct in mcpr)]. Diese Informationen werden dem Client während der Initialisierungsphase mitgeteilt.

Ein kritischer Aspekt bei der Implementierung ist die Sicherheit: Der Host MUSS die explizite Zustimmung des Benutzers einholen, bevor ein vom LLM initiiertes Tool tatsächlich aufgerufen wird.1 Dies wird oft durch ein UI-Element realisiert, das den Benutzer über die geplante Aktion informiert und eine Bestätigung erfordert.4

Weiterhin ist zu beachten, dass Beschreibungen des Tool-Verhaltens und eventuelle Annotationen, die vom Server bereitgestellt werden, als potenziell nicht vertrauenswürdig eingestuft werden sollten, es sei denn, der Server selbst gilt als vertrauenswürdig.1 Dies unterstreicht die Notwendigkeit für Hosts, Mechanismen zur Überprüfung oder Kennzeichnung von Servern zu implementieren.

- **3.2. Resources (Anwendungsgesteuert)**

**Definition:** Resources repräsentieren Datenquellen, auf die LLMs zugreifen können, um Informationen abzurufen, die für die Bearbeitung einer Anfrage oder die Anreicherung des Kontexts benötigt werden.3 Sie verhalten sich ähnlich wie GET-Endpunkte in einer REST-API, indem sie primär Daten liefern, ohne dabei signifikante serverseitige Berechnungen durchzuführen oder Seiteneffekte (wie Datenmodifikationen) auszulösen.3 Die abgerufenen Ressourcen werden Teil des Kontexts, der dem LLM für seine nächste Inferenzrunde zur Verfügung gestellt wird.3

**Anwendungsfälle:** Typische Beispiele sind der Abruf von Benutzerprofilinformationen, Produktdetails aus einem Katalog, Inhalten aus Dokumenten oder Datenbanken, aktuellen Kalenderdaten 2 oder der Zugriff auf Dateien im lokalen Dateisystem des Benutzers (mit dessen expliziter Zustimmung).4

Implementierungsaspekte:

Server definieren die Struktur und Verfügbarkeit der Ressourcen, die sie anbieten. Wie bei Tools muss der Host auch hier die explizite Zustimmung des Benutzers einholen, bevor Benutzerdaten (die als Ressourcen von einem Server abgerufen oder an einen Server gesendet werden sollen) transferiert werden.1 Der Host ist zudem verpflichtet, Benutzerdaten, die als Ressourcen gehandhabt werden, mit geeigneten Zugriffskontrollen zu schützen, um unautorisierten Zugriff zu verhindern.1

- **3.3. Prompts (Benutzergesteuert)**

**Definition:** Prompts im MCP-Kontext sind vordefinierte Vorlagen oder Schablonen, die dazu dienen, die Interaktion mit Tools oder Ressourcen auf eine optimale und standardisierte Weise zu gestalten.3 Im Gegensatz zu Tools, deren Nutzung vom LLM initiiert wird, werden Prompts typischerweise vom Benutzer (über die Host-Anwendung) ausgewählt, bevor eine Inferenz oder eine spezifische Aktion gestartet wird.3

**Nutzungsszenarien:** Prompts können für standardisierte Abfragen (z.B. "Fasse mir die Änderungen im Pull Request X zusammen"), geführte Workflows (z.B. ein mehrstufiger Prozess zur Fehlerbehebung) oder häufig verwendete Befehlssätze dienen. In Benutzeroberflächen können sie als dedizierte Schaltflächen oder Menüpunkte für benutzerdefinierte Aktionen erscheinen.4

Gestaltung:

Server können parametrisierbare Prompts anbieten, d.h. Vorlagen, die Platzhalter für benutzerspezifische Eingaben enthalten.7 Ein wichtiger Aspekt des Protokolldesigns ist, dass die Sichtbarkeit des Servers auf den Inhalt von Prompts, insbesondere während des LLM-Samplings (siehe unten), absichtlich begrenzt ist.1 Dies dient dem Schutz der Benutzerprivatsphäre und der Wahrung der Benutzerkontrolle über die an das LLM gesendeten Informationen.

- **3.4. Sampling (Server-initiierte Interaktionen)**

**Konzept:** "Sampling" ist eine fortgeschrittene Fähigkeit, die Clients den Servern anbieten können. Sie ermöglicht es dem _Server_, agentische Verhaltensweisen und rekursive LLM-Interaktionen über den Client zu initiieren.1 Dies stellt eine Abkehr vom typischen reaktiven Modell dar, bei dem der Client/Host Anfragen an den Server sendet. Beim Sampling kann der Server proaktiv das LLM (vermittelt durch den Client und Host) auffordern, basierend auf serverseitiger Logik, externen Ereignissen oder dem Ergebnis vorheriger Interaktionen zu "denken" oder zu handeln.

**Kontrollmechanismen:** Aufgrund der potenziellen Mächtigkeit und der damit verbundenen Risiken dieser Funktion legt die MCP-Spezifikation größten Wert auf strenge Benutzerkontrolle:

- Benutzer **MÜSSEN** allen LLM-Sampling-Anfragen, die von einem Server initiiert werden, explizit zustimmen.1
- Benutzer **SOLLTEN** die volle Kontrolle darüber haben, ob Sampling überhaupt stattfinden darf, welchen genauen Prompt-Inhalt das LLM erhält und welche Ergebnisse oder Zwischenschritte der Server einsehen kann.1

Diese Funktion ist zwar mächtig und kann zu intelligenteren, proaktiveren Agenten führen, die beispielsweise auf sich ändernde Umgebungsbedingungen reagieren, ohne für jeden Schritt eine direkte Benutzeraufforderung zu benötigen. Jedoch birgt sie auch erhebliche Sicherheitsimplikationen. Entwickler, die die Sampling-Funktion nutzen – sowohl auf Client- als auch auf Serverseite – müssen höchste Priorität auf transparente Benutzeraufklärung und robuste, unmissverständliche Einwilligungsmechanismen legen. Missbrauch oder unkontrolliertes Sampling könnten zu unerwünschtem Verhalten, exzessiver Ressourcennutzung oder Datenschutzverletzungen führen. Es ist die vielleicht wirkungsvollste, aber auch die verantwortungsvollste Funktion im MCP-Framework.

Die folgende Tabelle gibt eine vergleichende Übersicht über die Kernfunktionalitäten des MCP:

**Tabelle 2: Übersicht der MCP-Kernfunktionalitäten**

|   |   |   |   |   |
|---|---|---|---|---|
|**Funktionalität**|**Primäre Steuerungsebene**|**Kurzbeschreibung und Zweck**|**Typische Anwendungsbeispiele**|**Wichtige Sicherheitsüberlegung**|
|**Tool**|Modell (LLM)|Ausführbare Funktion für spezifische Aktionen; LLM entscheidet über Nutzung.|API-Aufrufe (Wetter, GitHub), E-Mail senden, Kalendereintrag erstellen.3|Host **MUSS** Benutzerzustimmung vor Aufruf einholen.1 Tool-Beschreibungen potenziell nicht vertrauenswürdig.1|
|**Resource**|Anwendung/Host|Datenquelle für Informationsabruf; liefert Kontext ohne Seiteneffekte.|Benutzerprofile, Produktdaten, Dokumentinhalte, Dateisystemzugriff.2|Host **MUSS** Benutzerzustimmung für Datenweitergabe/-abruf einholen.1 Datenschutz und Zugriffskontrollen sind kritisch.|
|**Prompt**|Benutzer|Vordefinierte Vorlage zur optimalen Nutzung von Tools/Ressourcen; vom Benutzer ausgewählt.|Standardisierte Abfragen, geführte Workflows, häufige Befehle.3|Serverseitige Sichtbarkeit auf Prompt-Inhalte ist begrenzt, um Benutzerkontrolle zu wahren.1|
|**Sampling**|Server / Benutzer|Server-initiierte agentische LLM-Interaktion; erfordert explizite Client-Fähigkeit.|Proaktive Agenten, rekursive LLM-Aufgaben, Reaktion auf externe Server-Events.1|Benutzer **MUSS** explizit zustimmen und Kontrolle über Prompt/Ergebnisse behalten.1 Hohes Missbrauchspotenzial.|

Entwickler von MCP-Servern müssen sorgfältig abwägen, welche Funktionalitäten sie als Tool, Ressource oder Prompt exponieren. Diese Entscheidung hat direkte Auswirkungen auf die Steuerungsmöglichkeiten, die Sicherheitsparadigmen und letztendlich die Benutzererfahrung, da sie bestimmt, wer die primäre Kontrolle über die jeweilige Interaktion ausübt.

**4. MCP Kommunikationsprotokoll: JSON-RPC 2.0**

Für die Kommunikation zwischen den Komponenten (Host, Client und Server) setzt das Model Context Protocol auf JSON-RPC 2.0.1 JSON-RPC ist ein leichtgewichtiges Remote Procedure Call (RPC) Protokoll, das sich durch seine Einfachheit und die Verwendung des weit verbreiteten JSON-Formats auszeichnet.

- **4.1. Grundlagen von JSON-RPC 2.0 im MCP-Kontext**

JSON-RPC 2.0 wurde als Basis für MCP gewählt, da es eine klare Struktur für Anfragen und Antworten bietet und gleichzeitig transportagnostisch ist, obwohl MCP spezifische Transportmechanismen vorschreibt, wie später erläutert wird.9 Die Verwendung von JSON macht die Nachrichten für Entwickler leicht lesbar und einfach zu parsen.

Die Kernkomponenten einer JSON-RPC 2.0 Nachricht sind:

- **Request-Objekt:** Eine Anfrage an den Server besteht aus den folgenden Feldern 7:
    - `jsonrpc`: Eine Zeichenkette, die die Version des JSON-RPC-Protokolls angibt, hier immer `"2.0"`.
    - `method`: Eine Zeichenkette, die den Namen der aufzurufenden Methode (Funktion) auf dem Server enthält.
    - `params`: Ein strukturiertes Objekt oder ein Array, das die Parameter für die aufzurufende Methode enthält. MCP verwendet typischerweise benannte Parameter (Objektform).
    - `id`: Ein eindeutiger Identifikator (String oder Integer, darf nicht Null sein), der vom Client generiert wird. Dieses Feld ist notwendig, um Antworten den entsprechenden Anfragen zuordnen zu können. Fehlt die `id`, handelt es sich um eine Notification.
- **Response-Objekt:** Eine Antwort vom Server auf eine Anfrage enthält 7:
    - `jsonrpc`: Ebenfalls `"2.0"`.
    - `id`: Derselbe Wert wie in der korrespondierenden Anfrage.
    - Entweder `result`: Dieses Feld ist bei einer erfolgreichen Ausführung der Methode vorhanden und enthält das Ergebnis der Operation. Der Datentyp des Ergebnisses ist methodenspezifisch.
    - Oder `error`: Dieses Feld ist vorhanden, wenn während der Verarbeitung der Anfrage ein Fehler aufgetreten ist.
- **Notification:** Eine Notification ist eine spezielle Form einer Anfrage, die keine `id` enthält. Da keine `id` vorhanden ist, sendet der Server keine Antwort auf eine Notification. Notifications eignen sich für unidirektionale Benachrichtigungen, bei denen der Client keine Bestätigung oder Ergebnis erwartet.
- **Error-Objekt:** Im Fehlerfall enthält das `error`-Feld ein Objekt mit den folgenden Feldern 7:
    - `code`: Ein numerischer Wert, der den Fehlertyp angibt (Standard-JSON-RPC-Fehlercodes oder anwendungsspezifische Codes).
    - `message`: Eine kurze, menschenlesbare Beschreibung des Fehlers.
    - `data` (optional): Ein Feld, das zusätzliche, anwendungsspezifische Fehlerinformationen enthalten kann.

Die folgende Tabelle fasst die JSON-RPC 2.0 Nachrichtenkomponenten im Kontext von MCP zusammen:

**Tabelle 3: JSON-RPC 2.0 Nachrichtenkomponenten im MCP**

|   |   |   |   |
|---|---|---|---|
|**Komponente**|**Datentyp (Beispiel)**|**Beschreibung im MCP-Kontext**|**Erforderlichkeit (Nachrichtentyp)**|
|`jsonrpc`|String (`"2.0"`)|Version des JSON-RPC Protokolls.|Request, Response, Notification|
|`id`|String, Integer, Null|Eindeutiger Identifikator zur Korrelation von Request und Response. `Null` ist nicht erlaubt.|Request (wenn Antwort erwartet), Response. Fehlt bei Notification.|
|`method`|String|Name der auf dem Server auszuführenden MCP-spezifischen Methode (z.B. `initialize`).|Request, Notification|
|`params`|Object / Array|Parameter für die aufzurufende Methode. MCP verwendet typischerweise benannte Parameter (Object).|Request (optional), Notification (optional)|
|`result`|Object / Array / Scalar|Ergebnis der erfolgreichen Methodenausführung.|Response (bei Erfolg)|
|`error`|Object|Strukturiertes Objekt, das Fehlerdetails enthält.|Response (bei Fehlschlag)|
|`error.code`|Integer|Numerischer Fehlercode.|Innerhalb des `error`-Objekts|
|`error.message`|String|Menschenlesbare Fehlerbeschreibung.|Innerhalb des `error`-Objekts|
|`error.data`|Any|Zusätzliche, anwendungsspezifische Fehlerinformationen.|Innerhalb des `error`-Objekts (optional)|

Ein klares Verständnis dieser Nachrichtenstruktur ist die Grundlage für die Implementierung der MCP-Kommunikation und unerlässlich für Entwickler, die MCP-Nachrichten direkt verarbeiten oder Debugging auf Protokollebene durchführen müssen.

- **4.2. Zustandsbehaftete Verbindungen (Stateful Connections)**

Ein wesentliches Merkmal des MCP ist, dass die etablierten Verbindungen zwischen Client und Server zustandsbehaftet ("stateful") sind.1 Dies bedeutet, dass der Server Informationen über den Zustand jedes verbundenen Clients über mehrere Anfragen und Antworten hinweg speichert und verwaltet.1 Dieser Zustand kann beispielsweise die während der Initialisierung ausgehandelten Fähigkeiten, Informationen über laufende Operationen oder sitzungsspezifische Konfigurationen umfassen.

Die Zustandsbehaftung von MCP-Verbindungen hat signifikante Implikationen für Entwickler:

- **Serverseitiges Zustandsmanagement:** Server müssen Mechanismen implementieren, um den individuellen Zustand für jede aktive Client-Sitzung zu verwalten.10 Dies erfordert sorgfältiges Design, um Ressourcenkonflikte zu vermeiden und die Integrität der Sitzungsdaten sicherzustellen.
- **Verbindungslebenszyklus:** Die Verbindung durchläuft einen definierten Lebenszyklus, der mindestens eine Initialisierungsphase, eine Phase des aktiven Nachrichtenaustauschs und eine Terminierungsphase umfasst.1 Jede dieser Phasen muss von Client und Server korrekt gehandhabt werden.
- **Unterschied zu zustandslosen Protokollen:** Dies unterscheidet MCP grundlegend von typischen zustandslosen Protokollen wie vielen REST-APIs, bei denen jede Anfrage unabhängig von vorherigen Anfragen behandelt wird. Die Zustandsbehaftung ermöglicht zwar kontextreichere und effizientere Interaktionen (da nicht bei jeder Anfrage der gesamte Kontext neu übertragen werden muss), sie stellt aber auch höhere Anforderungen an die Fehlerbehandlung und die Mechanismen zur Wiederherstellung nach Verbindungsabbrüchen oder Serverausfällen.10
- **Robustheit und Skalierbarkeit:** Die Zustandsbehaftung kann das Serverdesign komplexer machen.11 Der Server muss den Zustand für potenziell viele Clients verwalten, was Speicher- und Verarbeitungsressourcen beansprucht. Fehlerbehandlung und Wiederherstellung nach Ausfällen sind kritischer, da der Sitzungszustand möglicherweise wiederhergestellt oder zumindest sauber beendet werden muss, um Ressourcenlecks oder inkonsistente Zustände zu vermeiden.10 Auch die Skalierbarkeit kann im Vergleich zu zustandslosen Architekturen schwieriger zu erreichen sein, da Anfragen eines bestimmten Clients möglicherweise immer zum selben Server (oder zu einem Server mit Zugriff auf denselben verteilten Zustand) geleitet werden müssen.

Entwickler von MCP-Servern müssen daher Strategien für ein robustes Session-Management, eine umfassende Fehlerbehandlung (einschließlich Timeouts und gegebenenfalls Wiederverbindungslogik auf Client-Seite), eine zuverlässige Ressourcenbereinigung bei Verbindungsabbrüchen und potenziell für die Verteilung von Sitzungszuständen in skalierten Umgebungen entwickeln. Die vordergründige Einfachheit von JSON-RPC sollte nicht über diese systemischen Herausforderungen hinwegtäuschen, die mit dem zustandsbehafteten Charakter von MCP einhergehen.

- **4.3. Transportmechanismen**

MCP spezifiziert, wie die JSON-RPC-Nachrichten zwischen Client und Server transportiert werden. Derzeit sind zwei primäre Transportmechanismen definiert 3, deren Wahl direkte Auswirkungen auf Deployment-Szenarien und die Implementierungskomplexität hat.

- 4.3.1. Standard I/O (stdio)
    
    Dieser Mechanismus wird typischerweise verwendet, wenn sowohl der MCP-Client als auch der MCP-Server auf derselben physischen oder virtuellen Maschine laufen.3 In diesem Szenario startet der Client (bzw. der Host, in dem der Client läuft) den Serverprozess oft als einen Kindprozess. Die Kommunikation erfolgt dann über die Standard-Datenströme des Kindprozesses: Der Client sendet JSON-RPC-Anfragen an den Standard-Input (stdin) des Servers, und der Server sendet seine JSON-RPC-Antworten über seinen Standard-Output (stdout) zurück an den Client.7 Der Standard-Error-Stream (stderr) des Servers kann für Log-Meldungen oder unspezifische Fehlerausgaben genutzt werden, die nicht Teil des strukturierten JSON-RPC-Fehlerprotokolls sind.7
    
    stdio ist ein einfacher und effektiver Transport für lokale Integrationen, beispielsweise wenn eine Desktop-Anwendung (Host) auf lokale Tools zugreifen muss, die als MCP-Server implementiert sind (z.B. Zugriff auf das lokale Dateisystem oder Ausführung lokaler Skripte).3
    
    Bei der Implementierung, beispielsweise in Rust, ermöglichen Funktionen wie Stdio::piped() aus dem std::process-Modul die Einrichtung der notwendigen Pipes für die Kommunikation mit Kindprozessen.12 Es ist jedoch Vorsicht geboten: Wenn große Datenmengen über stdin geschrieben werden, ohne gleichzeitig von stdout (und stderr) zu lesen, kann es zu Deadlocks kommen, da die Pipe-Puffer volllaufen können.12 Die Größe dieser Puffer variiert je nach Betriebssystem.
    
- 4.3.2. HTTP mit Server-Sent Events (SSE)
    
    Für Szenarien, in denen Client und Server über ein Netzwerk kommunizieren, insbesondere wenn der Server die Fähigkeit benötigt, Nachrichten oder Ereignisse aktiv an den Client zu pushen, wird HTTP in Kombination mit Server-Sent Events (SSE) verwendet.3
    
    Der Kommunikationsaufbau ist hier mehrstufig: Der Client stellt zunächst eine HTTP-Verbindung zum Server her und initiiert einen SSE-Stream. Über diesen SSE-Stream kann der Server dann asynchron Nachrichten (Events) an den Client senden. Diese Verbindung bleibt persistent.3 Für Anfragen vom Client an den Server sieht der Prozess laut 7 wie folgt aus: Der Client öffnet eine SSE-Verbindung zum Server und empfängt als eines der ersten Events ein spezielles endpoint-Event. Dieses Event enthält eine URI. An diese spezifische URI sendet der Client dann seine JSON-RPC-Anfragen mittels HTTP POST. Der Server verarbeitet diese POST-Anfragen und sendet die JSON-RPC-Antworten wiederum über die bereits etablierte, persistente SSE-Verbindung zurück an den Client.7
    
    Dieser Mechanismus ist komplexer als stdio, ermöglicht aber die notwendige Flexibilität für verteilte Architekturen, Cloud-basierte MCP-Server oder die Anbindung an Software-as-a-Service (SaaS)-Produkte. Die Implementierung erfordert die Handhabung von HTTP-Verbindungen, das Management des SSE-Event-Streams und typischerweise auch robustere Authentifizierungs- und Sicherheitsmaßnahmen (z.B. die Verwendung von HTTPS). Für Rust-Entwickler bieten Bibliotheken wie actix-web-lab Unterstützung für die Implementierung von SSE-Endpunkten.14 Es ist zu beachten, dass SSE primär für die unidirektionale Kommunikation vom Server zum Client für Events gedacht ist; die Anfragen vom Client zum Server erfolgen über separate HTTP POST-Requests auf eine dynamisch während des SSE-Handshakes mitgeteilte URL.7
    

Die folgende Tabelle vergleicht die beiden Haupttransportmechanismen:

**Tabelle 4: Vergleich der MCP-Transportmechanismen**

|   |   |   |   |   |
|---|---|---|---|---|
|**Mechanismus**|**Typische Anwendungsfälle**|**Vorteile**|**Nachteile/Herausforderungen**|**Wichtige Implementierungsaspekte**|
|**stdio**|Lokale Integrationen (Client/Server auf derselben Maschine)|Einfach zu implementieren, geringer Overhead, effektiv für lokale Tools|Nicht für Netzwerkkommunikation geeignet, potenzielle Deadlocks bei unsachgemäßer Pufferbehandlung 12|Prozessmanagement (Starten/Stoppen des Servers), korrekte Handhabung von `stdin`/`stdout`/`stderr`, Vermeidung von Puffer-Deadlocks, Fehlerbehandlung bei Prozessende|
|**HTTP/SSE**|Verteilte Architekturen, Remote-Server, Web-Anwendungen|Ermöglicht Netzwerkkommunikation, Server-Push-Fähigkeit (via SSE)|Komplexer in der Implementierung, erfordert HTTP-Server/-Client-Logik, Management persistenter Verbindungen, Sicherheit (HTTPS)|HTTP-Request/Response-Handling, SSE-Event-Stream-Management, URI-Management für POST-Requests 7, Authentifizierung, Fehlerbehandlung bei Netzwerkproblemen|

Entwickler müssen den Transportmechanismus sorgfältig basierend auf dem geplanten Einsatzszenario ihres MCP-Servers oder -Clients auswählen. Die Spezifikation unterstützt beide Optionen, aber die Anforderungen an Entwicklung, Deployment und Betrieb unterscheiden sich erheblich.

**5. MCP Protokollspezifikation: Methoden und Nachrichtenfluss**

Dieser Abschnitt detailliert die spezifischen JSON-RPC-Methoden, die das Model Context Protocol definiert, sowie den typischen Nachrichtenfluss für Kerninteraktionen. Es ist essenziell zu verstehen, dass die exakten Schemata für Anfragen und Antworten in der offiziellen `schema.ts`-Datei des MCP-Projekts definiert sind.1 Implementierungen in Sprachen wie Rust, beispielsweise durch die `rust-mcp-schema`-Bibliothek 15, bieten typisierte Strukturen, die auf diesen Schemata basieren und die Entwicklung erleichtern. Die hier beschriebenen Methodennamen und Parameter sind repräsentativ und sollten stets mit der offiziellen Spezifikation abgeglichen werden.

- **5.1. Initialisierungsphase: `initialize` Methode**

**Zweck:** Die `initialize`-Methode ist der erste und grundlegende Schritt jeder MCP-Kommunikation nach dem Aufbau der Transportverbindung. Der Client initiiert diesen Aufruf, um eine Sitzung mit dem Server zu etablieren. Während dieses Austauschs werden Protokollversionen abgeglichen und, entscheidend, die Fähigkeiten (Capabilities) beider Seiten ausgetauscht.3

**Nachrichtenfluss:**

1. Client sendet `initialize` Request an den Server.
2. Server antwortet mit `initialize` Response (oft als `InitializeResult` in SDKs bezeichnet 15).

**Client `initialize` Request Parameter (Beispiel basierend auf 7):**

- `jsonrpc`: `"2.0"`
- `id`: Eine eindeutige Request-ID (z.B. `"4711"` 7).
- `method`: `"initialize"`
- `params`: Ein Objekt, das typischerweise folgende Felder enthält:
    - `protocolVersion` (String): Die Version des MCP-Protokolls, die der Client unterstützt (z.B. `"2024-11-05"` 7).
    - `capabilities` (Object): Ein Objekt, das die Fähigkeiten beschreibt, die der Client dem Server anbietet. Ein wichtiges Beispiel ist die `sampling`-Fähigkeit, die es dem Server erlaubt, LLM-Interaktionen über den Client zu initiieren.7
    - `clientInfo` (Object): Informationen über die Client-Anwendung, wie `name` (z.B. `"SomeClient"`) und `version` (z.B. `"1.2.3"`).7

**Server `initialize` Response (`InitializeResult`) Parameter (Beispiel basierend auf 15):**

- `jsonrpc`: `"2.0"`
- `id`: Die ID aus dem korrespondierenden Request.
- `result`: Ein Objekt, das typischerweise folgende Felder enthält:
    - `protocolVersion` (String): Die vom Server gewählte und unterstützte Protokollversion. Diese sollte mit der vom Client angebotenen Version kompatibel sein.
    - `serverInfo` (Object): Informationen über den Server, wie `name`, `version` und möglicherweise weitere Metadaten.
    - `capabilities` (Object): Ein Objekt, das die vom Server angebotenen Fähigkeiten detailliert beschreibt. Dies ist ein Kernstück der Antwort und beinhaltet typischerweise Unterobjekte für:
        - `prompts`: Definitionen der verfügbaren Prompts.
        - `resources`: Definitionen der verfügbaren Ressourcen.
        - `tools`: Definitionen der verfügbaren Tools, inklusive ihrer Parameter-Schemata und Beschreibungen.
    - `meta` (Object, optional): Zusätzliche, serverseitige Metadaten.
    - `instructions` (String, optional): Spezifische Anweisungen oder Hinweise vom Server an den Client.

Die `initialize`-Methode ist das Fundament jeder MCP-Interaktion. Sie legt die Spielregeln für die nachfolgende Kommunikation fest. Es geht nicht nur um den Austausch von Versionsinformationen, sondern vor allem um die Deklaration und Aushandlung der gegenseitigen Fähigkeiten. Der Client deklariert, welche serverseitig nutzbaren Funktionen er anbietet (z.B. `sampling`), und der Server legt umfassend dar, welche Tools, Ressourcen und Prompts er zur Verfügung stellt. Ohne eine erfolgreiche Initialisierung und eine klare Übereinkunft über die unterstützten Fähigkeiten können keine weiteren sinnvollen MCP-Operationen stattfinden. Entwickler müssen diese Sequenz daher mit größter Sorgfalt implementieren. Fehler oder Missverständnisse in dieser kritischen Phase führen unweigerlich zu Problemen in der weiteren Kommunikation. Die dynamische Natur der Fähigkeiten bedeutet auch, dass Clients und Server flexibel auf die vom jeweiligen Gegenüber angebotenen und unterstützten Funktionen reagieren müssen.

- **5.2. Aufruf von Tools (z.B. `mcp/tool_call`)**

**Zweck:** Diese Methode wird vom Client aufgerufen, wenn das LLM (oder in manchen Fällen die Host-Anwendung) die Ausführung eines vom Server bereitgestellten Tools anfordert. Der genaue Methodenname (hier als `mcp/tool_call` angenommen) ist der Spezifikation zu entnehmen.

**Nachrichtenfluss:**

1. Client sendet `mcp/tool_call` Request an den Server.
2. Server antwortet mit `mcp/tool_call` Response.

**Request Parameter:**

- `tool_name` (String): Der eindeutige Name des aufzurufenden Tools, wie vom Server in den `capabilities` während der Initialisierung deklariert.
- `params` (Object): Ein Objekt, das die Parameter für das Tool enthält. Die Struktur dieses Objekts muss dem Schema entsprechen, das der Server für dieses spezifische Tool definiert hat.

**Response (`result`):**

- Das Ergebnis der Tool-Ausführung. Die Struktur dieses Ergebnisses ist ebenfalls durch das vom Server definierte Schema für das jeweilige Tool bestimmt.

Rust-Bibliotheken wie `mcpr` abstrahieren diesen JSON-RPC-Nachrichtenaustausch durch Methodenaufrufe wie `client.call_tool("my_tool", &request)` 16, was die Entwicklung vereinfacht.

- **5.3. Zugriff auf Resources (z.B. `mcp/fetch_resource`)**

**Zweck:** Diese Methode dient dem Abruf von Daten aus einer vom Server bereitgestellten Ressource. Sie wird vom Client initiiert, wenn das LLM oder die Host-Anwendung kontextuelle Informationen benötigt. (Methodenname `mcp/fetch_resource` ist hier angenommen).

**Nachrichtenfluss:**

1. Client sendet `mcp/fetch_resource` Request an den Server.
2. Server antwortet mit `mcp/fetch_resource` Response.

**Request Parameter:**

- `resource_id` (String): Der eindeutige Bezeichner der Ressource, wie vom Server in den `capabilities` deklariert.
- `params` (Object, optional): Parameter zur weiteren Spezifizierung der Anfrage, z.B. Filterkriterien oder Paginierungsinformationen, falls die Ressource dies unterstützt.

**Response (`result`):**

- Die angeforderten Ressourcendaten in der vom Server für diese Ressource definierten Struktur.
    
- **5.4. Verwendung von Prompts (z.B. `mcp/execute_prompt`)**
    

**Zweck:** Ermöglicht dem Benutzer (über den Client), einen vom Server vordefinierten Prompt auszuwählen und auszuführen. Die Auflistung der verfügbaren Prompts und ihrer Parameter erfolgt typischerweise basierend auf den Informationen aus der `initialize`-Antwort des Servers.7 (Methodenname `mcp/execute_prompt` ist hier angenommen).

**Nachrichtenfluss:** Variiert je nach Design, aber typischerweise:

1. Client sendet `mcp/execute_prompt` Request an den Server (nachdem der Benutzer einen Prompt ausgewählt hat).
2. Server antwortet mit `mcp/execute_prompt` Response (z.B. das Ergebnis der Prompt-Ausführung oder eine Bestätigung).

**Request Parameter:**

- `prompt_id` (String): Der eindeutige Bezeichner des auszuführenden Prompts.
- `params` (Object, optional): Parameter, die in den Prompt eingesetzt werden sollen, falls dieser parametrisierbar ist.

**Response (`result`):**

- Das Ergebnis der Prompt-Ausführung, dessen Struktur vom spezifischen Prompt abhängt.
    
- **5.5. Durchführung von Sampling-Anfragen (z.B. `mcp/sampling_request`)**
    

**Zweck:** Diese Interaktion wird vom _Server_ initiiert, wenn dieser eine agentische LLM-Interaktion oder eine rekursive LLM-Nutzung durch den Client anstoßen möchte. Dies ist nur möglich, wenn der Client in seiner `initialize`-Anfrage die `sampling`-Fähigkeit angeboten und der Benutzer dem zugestimmt hat. (Methodenname `mcp/sampling_request` ist hier angenommen).

**Nachrichtenfluss:**

1. Server sendet `mcp/sampling_request` Request (oder Notification) an den Client.
2. Client verarbeitet die Anfrage (potenziell nach erneuter Benutzerzustimmung) und kann eine Response an den Server senden.

**Request Parameter (vom Server an Client):**

- `prompt` (String oder strukturiertes Objekt): Der Prompt, den das LLM verarbeiten soll.
- `sampling_params` (Object, optional): Spezifische Parameter für den Sampling-Prozess (z.B. Temperatur, max. Tokens).

**Response (vom Client an Server, falls keine Notification):**

- Das Ergebnis der LLM-Verarbeitung des vom Server initiierten Prompts.
    
- **5.6. Zusätzliche Utilities**
    

MCP definiert auch eine Reihe von Hilfsmethoden und -mechanismen, die für eine robuste Kommunikation unerlässlich sind.1

- **`Ping`:** Eine einfache Methode (Client -> Server Request, Server -> Client Response), um die Lebendigkeit der Verbindung und die Erreichbarkeit des Servers zu überprüfen. Enthält typischerweise keine signifikanten Parameter.
- **`$/cancelRequest` (JSON-RPC Standard):** Eine Notification vom Client an den Server, um eine zuvor gesendete, noch laufende Anfrage abzubrechen. Die Notification enthält die `id` der abzubrechenden Anfrage in ihren Parametern.
- **`$/progress` (JSON-RPC Standard für Progress Notification):** Eine Notification vom Server an den Client, um diesen über den Fortschritt einer langlaufenden Operation zu informieren. Die Notification enthält typischerweise eine `id` (die sich auf die ursprüngliche Anfrage bezieht) und Fortschrittsdetails.
- **Error Reporting:** Erfolgt über das Standard-JSON-RPC-Error-Objekt in Responses, wenn eine Methode nicht erfolgreich ausgeführt werden konnte.
- **Logging:** Kann über `stderr` (im `stdio`-Transportmodus) oder über spezifische, im Protokoll definierte Log-Notifications erfolgen.

Obwohl diese Utilities als "zusätzlich" bezeichnet werden, sollten Entwickler sie als integralen Bestandteil einer professionellen MCP-Implementierung betrachten. Ihre Implementierung verbessert die Stabilität, Reaktionsfähigkeit und Benutzererfahrung erheblich, insbesondere in verteilten oder zeitintensiven Szenarien. Beispielsweise hat der Benutzer ohne `Progress Tracking` keine Rückmeldung über den Status langlaufender Operationen. Ohne `Cancellation` können versehentlich gestartete oder zu lange dauernde Operationen nicht abgebrochen werden, was zu Ressourcenverschwendung oder Frustration führt. `Ping` ist entscheidend für Health Checks und die frühzeitige Erkennung von Verbindungsproblemen. Das Fehlen dieser Utilities kann zu schwer diagnostizierbaren Problemen und einer insgesamt schlechten User Experience führen.

- **5.7. Verbindungslebenszyklus und Zustandsmanagement**

Der Lebenszyklus einer MCP-Verbindung und das damit verbundene Zustandsmanagement sind kritische Aspekte:

1. **Aufbau:**
    - Herstellen der physischen Transportverbindung (`stdio` oder `HTTP/SSE`).
    - Durchführung der `initialize`-Sequenz (Client sendet Request, Server antwortet). Bei Erfolg ist die MCP-Sitzung etabliert.
2. **Betrieb:**
    - Austausch von anwendungsspezifischen MCP-Nachrichten: Tool-Aufrufe, Ressourcenanfragen, Prompt-Ausführungen, Sampling-Nachrichten.
    - Austausch von Utility-Nachrichten: `Ping`, `$/cancelRequest`, `$/progress`.
3. **Abbau:**
    - Explizit: Durch eine `shutdown`-Methode (z.B. `client.shutdown()` in 16), die der Client an den Server sendet, um die Sitzung ordnungsgemäß zu beenden. Der Server sollte daraufhin alle mit dieser Sitzung verbundenen Ressourcen freigeben.
    - Implizit: Durch das Schließen der zugrundeliegenden Transportverbindung (z.B. Schließen der Pipes bei `stdio` oder Trennen der HTTP-Verbindung bei SSE). Auch hier **SOLLTEN** Server versuchen, Ressourcen aufzuräumen.
4. **Zustandsmanagement:**
    - Server **MÜSSEN** den Zustand für jede aktive Client-Sitzung verwalten. Dazu gehören mindestens die während der `initialize`-Phase ausgehandelten Fähigkeiten, Informationen über aktuell laufende Anfragen (um z.B. Duplikate oder Konflikte zu erkennen) und sitzungsspezifische Daten.
    - Clients **MÜSSEN** den Verbindungsstatus zum Server verwalten und in der Lage sein, auf Verbindungsabbrüche oder Fehler zu reagieren (z.B. durch Wiederverbindungsversuche oder Information des Benutzers).

Die folgende Tabelle gibt einen exemplarischen Überblick über wichtige MCP-Methoden. Die genauen Namen und Parameter sind der offiziellen Spezifikation zu entnehmen.

**Tabelle 5: Wichtige MCP-Methoden und ihre Parameter (Beispiele)**

|   |   |   |   |   |
|---|---|---|---|---|
|**Methode (angenommen/Standard)**|**Richtung**|**Wichtige Parameter (Request)**|**Erwartete Antwort/Struktur (Response/Result)**|**Zweck im MCP**|
|`initialize`|Client -> Server|`protocolVersion`, `clientInfo`, `capabilities` (client-seitig, z.B. `sampling`) 7|`protocolVersion`, `serverInfo`, `capabilities` (serverseitig: `tools`, `resources`, `prompts`) 15|Aufbau der Sitzung, Aushandlung von Protokollversion und Fähigkeiten.|
|`mcp/tool_call` (angenommen)|Client -> Server|`tool_name`, `params` (toolspezifisch)|Ergebnis der Tool-Ausführung (toolspezifisch)|Ausführung einer vom Server bereitgestellten Funktion (Tool).|
|`mcp/fetch_resource` (angenommen)|Client -> Server|`resource_id`, `params` (ressourcenspezifisch, optional)|Angefragte Ressourcendaten|Abruf von Daten aus einer vom Server bereitgestellten Quelle (Resource).|
|`mcp/execute_prompt` (angenommen)|Client -> Server|`prompt_id`, `params` (promptspezifisch, optional)|Ergebnis der Prompt-Ausführung|Ausführung eines vom Benutzer ausgewählten, vordefinierten Prompts.|
|`mcp/sampling_request` (angenommen)|Server -> Client|`prompt`, `sampling_params` (optional)|Ergebnis der LLM-Verarbeitung (optional, falls keine Notification)|Server-initiierte LLM-Interaktion über den Client.|
|`Ping`|Client <-> Server|Keine oder minimale Parameter|Bestätigung (z.B. leeres Objekt oder Pong-Nachricht)|Überprüfung der Verbindungsintegrität und Serververfügbarkeit.|
|`$/cancelRequest`|Client -> Server|`id` der abzubrechenden Anfrage|Keine (Notification)|Abbruch einer zuvor gesendeten, noch laufenden Anfrage.|
|`$/progress`|Server -> Client|`id` der ursprünglichen Anfrage, Fortschrittsdetails (z.B. Prozent, Statusnachricht)|Keine (Notification)|Information des Clients über den Fortschritt einer langlaufenden serverseitigen Operation.|

Diese Tabelle dient als Referenz für Entwickler, um die grundlegenden Interaktionsmuster und die damit verbundenen Datenstrukturen im MCP zu verstehen, bevor sie sich in die Details der offiziellen Schemadateien vertiefen.

**6. Entwicklungsrichtlinien für MCP-Implementierungen**

Die erfolgreiche Implementierung von MCP-Komponenten erfordert die Beachtung spezifischer Designprinzipien und Best Practices. Diese Richtlinien zielen darauf ab, robuste, sichere, wartbare und interoperable MCP-Server und -Clients zu schaffen.

- **6.1. Server-Implementierung**

MCP-Server sind die Brücke zwischen der abstrakten Welt des Protokolls und den konkreten Funktionalitäten externer Systeme. Ihre Qualität bestimmt maßgeblich die Nützlichkeit des gesamten MCP-Systems.

- **Designprinzipien:**
    
    - **Robustheit:** Server **MÜSSEN** so konzipiert sein, dass sie Fehlerfälle, unerwartete Eingaben und ungültige Anfragen tolerant behandeln. Dies beinhaltet eine umfassende Fehlerbehandlung gemäß dem JSON-RPC-Standard und aussagekräftiges Logging für Diagnosezwecke.1 Ungültige Anfragen sollten mit entsprechenden Fehlermeldungen beantwortet und nicht zum Absturz des Servers führen.
    - **Erweiterbarkeit:** Das Design des Servers **SOLLTE** darauf ausgelegt sein, dass neue Tools, Ressourcen und Prompts mit minimalem Aufwand hinzugefügt oder bestehende modifiziert werden können. Eine modulare Architektur ist hier oft vorteilhaft.
    - **Effizienz:** Insbesondere bei häufig genutzten Funktionen oder beim Zugriff auf große Datenmengen ist auf eine performante Implementierung der Datenabfragen und Tool-Ausführungen zu achten. Langsame Server können die Benutzererfahrung der Host-Anwendung negativ beeinflussen.
    - **Zustandsmanagement:** Da MCP-Verbindungen zustandsbehaftet sind, **MUSS** ein sorgfältiges Session-Management implementiert werden.10 Dies umfasst die korrekte Initialisierung und Verwaltung des Zustands pro Client, die Behandlung von Verbindungsabbrüchen (z.B. durch Timeouts) und die zuverlässige Freigabe von Ressourcen (Speicher, Handles, etc.), wenn eine Sitzung beendet wird, um Ressourcenlecks zu vermeiden.
- Wrapper für externe Systeme:
    
    In vielen Fällen agieren MCP-Server als Wrapper oder Adapter für bereits bestehende APIs, Datenbanken, Dateisysteme oder andere unternehmensinterne oder externe Dienste.3 Die inhärente Komplexität dieser Backend-Systeme (z.B. unterschiedliche Authentifizierungsmethoden, Datenformate oder Fehlerbehandlungslogiken) SOLLTE vor dem MCP-Client verborgen werden. Der Server hat die Aufgabe, eine saubere, standardisierte MCP-Schnittstelle anzubieten, die diese Komplexität abstrahiert.
    
- Best Practices für Tool-, Resource- und Prompt-Definitionen:
    
    Die Qualität der Definitionen von Tools, Ressourcen und Prompts auf dem Server ist entscheidend, da sie die Schnittstelle darstellen, mit der LLMs und Benutzer interagieren.
    
    - **Klare Semantik:** Namen, Beschreibungen und Parameter von Tools, Ressourcen und Prompts **MÜSSEN** präzise, verständlich und eindeutig sein. Diese Informationen werden oft direkt in den Benutzeroberflächen der Host-Anwendungen angezeigt (wie z.B. Icons und Tooltips in 4) und dienen dem LLM als Grundlage für Entscheidungen (bei Tools).
    - **Granularität:** Es ist oft besser, mehrere spezifische, fokussierte Tools oder Ressourcen anzubieten, anstatt ein einziges, monolithisches Tool oder eine Ressource mit einer Vielzahl von Optionen und komplexer Logik. Dies erleichtert die Nutzung und das Verständnis.
    - **Schema-Validierung:** Eingabeparameter für Tools und die Struktur von Ressourcen **MÜSSEN** serverseitig strikt gegen die zuvor definierten Schemata validiert werden. Anfragen, die nicht dem Schema entsprechen, sind mit einem entsprechenden JSON-RPC-Fehler abzulehnen.
    - **Idempotenz:** Wo immer es sinnvoll und möglich ist, **SOLLTEN** Tools idempotent gestaltet sein. Das bedeutet, dass eine mehrfache Ausführung des Tools mit denselben Eingangsparametern immer zum selben Ergebnis führt und keine unerwünschten Mehrfach-Seiteneffekte verursacht.
- Sprachagnostische Überlegungen und SDK-Nutzung:
    
    MCP-Server können prinzipiell in jeder Programmiersprache entwickelt werden (z.B. Python, TypeScript, Java, Rust), solange die Implementierung die MCP-Spezifikation hinsichtlich JSON-RPC und der unterstützten Transportmechanismen (stdio, HTTP/SSE) einhält.3
    
    Die Verwendung von offiziellen oder von der Community bereitgestellten Software Development Kits (SDKs) kann die Entwicklung von MCP-Servern (und Clients) erheblich vereinfachen und beschleunigen. SDKs wie mcpr für Rust 15 oder das Python-Paket mcp[cli] 17 abstrahieren viele der Low-Level-Protokolldetails, wie die Serialisierung/Deserialisierung von JSON-RPC-Nachrichten oder das Management der Transportverbindung.7 Beispielsweise bieten rust-mcp-sdk und das zugehörige rust-mcp-schema 15 typensichere Implementierungen der MCP-Schemata für Rust-Entwickler, was die Fehleranfälligkeit reduziert. mcpr 16 geht noch einen Schritt weiter und bietet High-Level-Abstraktionen für Client und Server sowie einen Projektgenerator, um schnell mit der Entwicklung starten zu können.
    
    Die Nutzung solcher SDKs ist nicht nur eine Frage der Bequemlichkeit, sondern ein wichtiger Faktor für die Sicherstellung der Protokollkonformität und die Reduzierung von Implementierungsfehlern. Sie erlauben es Entwicklern, sich stärker auf die eigentliche Anwendungslogik ihrer Tools und Ressourcen zu konzentrieren, anstatt sich mit den Feinheiten der MCP-Protokollmechanik auseinandersetzen zu müssen.
    
- **6.2. Client-Implementierung**
    

MCP-Clients sind die Bindeglieder zwischen der Host-Anwendung und den MCP-Servern. Ihre korrekte Implementierung ist entscheidend für eine nahtlose Benutzererfahrung.

- Integration in Host-Anwendungen:
    
    Clients sind integraler Bestandteil der Host-Anwendung.3 Die Host-Anwendung ist verantwortlich für die Instanziierung, Konfiguration und Verwaltung des Lebenszyklus der Client-Instanzen. Dies beinhaltet auch die Bereitstellung der notwendigen Benutzeroberflächenelemente, insbesondere für die Einholung der Benutzereinwilligung vor dem Aufruf von Tools oder dem Zugriff auf Ressourcen.1
    
- Verbindungsmanagement und Fehlerbehandlung:
    
    Clients MÜSSEN den Status der Verbindung zu ihrem jeweiligen Server aktiv überwachen. Dies beinhaltet die Implementierung einer robusten Logik zur Handhabung von Verbindungsabbrüchen und gegebenenfalls automatische oder benutzerinitiierte Wiederverbindungsversuche. Eine umfassende Fehlerbehandlung für fehlgeschlagene Anfragen oder vom Server gemeldete Fehler (gemäß JSON-RPC-Error-Objekt) ist unerlässlich, um dem Benutzer aussagekräftiges Feedback geben zu können. Clients SOLLTEN auch Timeouts für Serverantworten implementieren, um zu verhindern, dass die Host-Anwendung bei einem nicht antwortenden Server blockiert.
    
- Umgang mit Server-Capabilities:
    
    Ein zentraler Aspekt der Client-Implementierung ist der dynamische Umgang mit den vom Server während der initialize-Phase angebotenen Fähigkeiten (capabilities). Clients MÜSSEN in der Lage sein, diese Informationen zu parsen und ihre Funktionalität bzw. die der Host-Anwendung entsprechend anzupassen. Beispielsweise SOLLTEN UI-Elemente, die dem Benutzer verfügbare Tools, Ressourcen oder Prompts anzeigen, dynamisch basierend auf den vom Server gemeldeten Fähigkeiten generiert und aktualisiert werden.4
    
- **6.3. Allgemeine Richtlinien**
    

Diese Richtlinien gelten sowohl für Server- als auch für Client-Implementierungen.

- Konfigurationsmanagement:
    
    Sensible Informationen wie API-Schlüssel, Authentifizierungstokens (z.B. das in 8 erwähnte GITHUB_PERSONAL_ACCESS_TOKEN) oder Datenbank-Zugangsdaten MÜSSEN sicher verwaltet werden. Sie DÜRFEN NICHT fest im Quellcode verankert sein. Stattdessen SOLLTEN Mechanismen wie Umgebungsvariablen, sicher gespeicherte Konfigurationsdateien mit restriktiven Zugriffsberechtigungen oder dedizierte Secrets-Management-Systeme verwendet werden.8
    
- Versionierung:
    
    Es wird RECOMMENDED, semantische Versionierung (SemVer) für MCP-Server und -Clients zu verwenden, um Änderungen und Kompatibilität klar zu kommunizieren. Die protocolVersion, die während des MCP-Handshakes (initialize-Methode) ausgetauscht wird 7, ist entscheidend für die Sicherstellung der grundlegenden Protokollkompatibilität zwischen Client und Server. Anwendungen MÜSSEN auf Inkompatibilitäten bei der Protokollversion angemessen reagieren.
    
- Teststrategien:
    
    Eine umfassende Teststrategie ist unerlässlich für die Entwicklung qualitativ hochwertiger MCP-Komponenten.
    
    - **Unit-Tests:** Testen Sie einzelne Module und Funktionen isoliert (z.B. die Logik eines spezifischen Tools auf dem Server, die Parsing-Logik für Server-Antworten im Client).
    - **Integrationstests:** Testen Sie den gesamten MCP-Fluss zwischen einem Client und einem Server, einschließlich des Handshakes, des Aufrufs von Tools/Ressourcen und der Fehlerbehandlung.
    - **Mocking:** Verwenden Sie Mocking-Frameworks, um Abhängigkeiten zu externen Systemen (z.B. Datenbanken, Drittanbieter-APIs, die ein Server wrappt) während der Tests zu isolieren und kontrollierbare Testbedingungen zu schaffen.
    - **Sicherheitstests:** Testen Sie explizit sicherheitsrelevante Aspekte wie die korrekte Implementierung von Einwilligungsabfragen (im Host), die Validierung von Eingaben und die Handhabung von Authentifizierung und Autorisierung.

**7. Sicherheitsrichtlinien und Trust & Safety im MCP**

Das Model Context Protocol ermöglicht durch seinen direkten Zugriff auf Daten und die Ausführung von Code potenziell sehr mächtige Funktionalitäten. Mit dieser Macht geht jedoch eine erhebliche Verantwortung einher. Alle Entwickler und Implementierer von MCP-Komponenten **MÜSSEN** den Sicherheits- und Vertrauensaspekten höchste Priorität einräumen.1 Die folgenden Prinzipien und Richtlinien sind nicht optional, sondern fundamental für den Aufbau eines vertrauenswürdigen MCP-Ökosystems.

- **7.1. Grundprinzipien (gemäß 1)**

Die MCP-Spezifikation selbst legt vier zentrale Sicherheitsprinzipien fest, die als Leitfaden für alle Implementierungen dienen müssen:

- **User Consent and Control (Benutzereinwilligung und -kontrolle):**
    
    - Benutzer **MÜSSEN** explizit allen Datenzugriffen und Operationen, die über MCP erfolgen, zustimmen. Es ist nicht ausreichend, dass eine Aktion technisch möglich ist; der Benutzer muss sie verstehen und ihr aktiv zustimmen.1
    - Benutzer **MÜSSEN** jederzeit die Kontrolle darüber behalten, welche ihrer Daten mit welchen Servern geteilt und welche Aktionen von Tools in ihrem Namen ausgeführt werden.1
    - Implementierer (insbesondere von Host-Anwendungen) **SOLLTEN** klare, verständliche und leicht zugängliche Benutzeroberflächen bereitstellen, über die Benutzer Aktivitäten überprüfen, genehmigen oder ablehnen können.1 Ein Beispiel hierfür ist das in 4 gezeigte Popup-Fenster, das vor der Nutzung eines Tools um Bestätigung bittet.
- **Data Privacy (Datenschutz):**
    
    - Hosts **MÜSSEN** die explizite Benutzereinwilligung einholen, _bevor_ irgendwelche Benutzerdaten an MCP-Server weitergegeben werden.1
    - Hosts **DÜRFEN** Ressourcendaten, die sie von Servern erhalten oder selbst verwalten, NICHT ohne erneute, spezifische Benutzereinwilligung an andere Stellen (z.B. andere Server, Dienste Dritter) übertragen.1
    - Alle Benutzerdaten, die im Kontext von MCP verarbeitet werden, **SOLLTEN** mit geeigneten technischen und organisatorischen Maßnahmen, einschließlich Zugriffskontrollen, geschützt werden.1
- **Tool Safety (Toolsicherheit):**
    
    - Tools, die von MCP-Servern angeboten werden, können potenziell beliebigen Code ausführen oder weitreichende Aktionen in externen Systemen initiieren. Sie **MÜSSEN** daher mit äußerster Vorsicht behandelt werden.1
    - Hosts **MÜSSEN** die explizite Benutzereinwilligung einholen, _bevor_ irgendein Tool aufgerufen wird.1
    - Benutzer **SOLLTEN** in die Lage versetzt werden zu verstehen, welche Aktionen ein Tool ausführt und welche potenziellen Konsequenzen dies hat, bevor sie dessen Nutzung autorisieren.1
    - Ein wichtiger Aspekt ist, dass Beschreibungen des Tool-Verhaltens (z.B. Annotationen, die vom Server geliefert werden) als potenziell nicht vertrauenswürdig betrachtet werden müssen, es sei denn, sie stammen von einem explizit als vertrauenswürdig eingestuften Server.1 Dies hat erhebliche Implikationen: Host-Anwendungen können sich nicht blind auf die Selbstauskunft eines Servers verlassen. Es könnten Mechanismen zur Verifizierung von Servern oder zur Warnung vor potenziell irreführenden Beschreibungen notwendig werden. Langfristig könnten Reputationssysteme oder Zertifizierungsstellen für MCP-Server entstehen, um die Vertrauenswürdigkeit zu erhöhen. Entwickler sollten sich dieser potenziellen Angriffsvektoren bewusst sein und defensive Designentscheidungen treffen.
- **LLM Sampling Controls (Kontrollen für LLM-Sampling):**
    
    - Da die Sampling-Funktion es Servern ermöglicht, LLM-Interaktionen proaktiv zu initiieren, **MÜSSEN** Benutzer allen solchen LLM-Sampling-Anfragen explizit zustimmen.1
    - Benutzer **SOLLTEN** die Kontrolle darüber haben: (a) ob Sampling durch einen bestimmten Server überhaupt erlaubt ist, (b) welchen genauen Prompt-Inhalt das LLM im Rahmen einer Sampling-Anfrage erhält, und (c) welche Ergebnisse dieser serverseitig initiierten LLM-Verarbeitung der Server einsehen darf.1 Die Protokollarchitektur begrenzt hier absichtlich die Sichtbarkeit des Servers auf Prompts, um die Benutzerkontrolle zu wahren.

Sicherheit im MCP ist eine geteilte Verantwortung zwischen Host, Client und Server. Die Spezifikation 1 betont jedoch wiederholt, dass der _Host_ die Hauptlast bei der direkten Benutzerinteraktion und der Einholung von Einwilligungen trägt. Der Server stellt die Funktionalität bereit, aber der Host ist das Tor zum Benutzer und kontrolliert, was dem Benutzer präsentiert wird und welche Berechtigungen letztendlich erteilt werden. Beispiele wie das Bestätigungs-Popup in Claude Desktop 4 illustrieren diese zentrale Rolle des Hosts in der Praxis. Entwickler von Host-Anwendungen haben daher eine immense Verantwortung, die Einwilligungs- und Kontrollmechanismen korrekt, transparent und benutzerfreundlich zu implementieren. Fehler oder Nachlässigkeiten in diesem Bereich können gravierende Datenschutz- und Sicherheitsverletzungen zur Folge haben. Server-Entwickler müssen sich darauf verlassen können, dass der Host diese kritische Aufgabe zuverlässig erfüllt.

- **7.2. Verantwortlichkeiten des Implementierers (gemäß 1)**

Obwohl das MCP-Protokoll selbst diese Sicherheitsprinzipien nicht auf technischer Ebene erzwingen kann (z.B. kann das Protokoll nicht überprüfen, ob eine UI-Einwilligung tatsächlich stattgefunden hat), legt die Spezifikation klare Erwartungen an die Implementierer fest. Diese **SOLLTEN**:

- Robuste und unmissverständliche Zustimmungs- und Autorisierungsflüsse als integralen Bestandteil ihrer Anwendungen entwerfen und implementieren.
    
- Eine klare und verständliche Dokumentation der Sicherheitsimplikationen ihrer MCP-Integrationen bereitstellen, sowohl für Endbenutzer als auch für andere Entwickler.
    
- Geeignete Zugriffskontrollen und Datenschutzmaßnahmen auf allen Ebenen ihrer Systeme implementieren.
    
- Anerkannte Sicherheits-Best-Practices (z.B. OWASP-Richtlinien) in ihren Integrationen befolgen.
    
- Die Datenschutzimplikationen neuer Funktionen oder Änderungen sorgfältig prüfen und in ihren Designs berücksichtigen (Privacy by Design).
    
- **7.3. Spezifische Sicherheitsrichtlinien für Entwickler**
    

Über die oben genannten Grundprinzipien hinaus gibt es konkrete technische Maßnahmen, die Entwickler ergreifen müssen:

- **Input Validierung:** Alle externen Eingaben – seien es JSON-RPC-Parameter von Clients, Daten von Backend-Systemen, die ein Server verarbeitet, oder Benutzereingaben in der Host-Anwendung – **MÜSSEN** serverseitig (oder an der jeweiligen Verarbeitungsgrenze) sorgfältig validiert werden. Dies ist entscheidend, um Injection-Angriffe (z.B. SQL-Injection, Command-Injection, wenn Tools Shell-Befehle ausführen), Cross-Site-Scripting (XSS, falls Tool-Ausgaben in Web-UIs gerendert werden) und andere datenbasierte Schwachstellen zu verhindern.9
- **Authentifizierung und Autorisierung:** Es **MÜSSEN** robuste Mechanismen zur Authentifizierung von Clients gegenüber Servern (und ggf. umgekehrt) implementiert werden, insbesondere wenn die Kommunikation über unsichere Netzwerke erfolgt oder sensible Daten übertragen werden. Nach erfolgreicher Authentifizierung **MUSS** eine Autorisierungsprüfung erfolgen, um sicherzustellen, dass der authentifizierte Akteur auch die Berechtigung für die angeforderte Operation oder den Datenzugriff hat.
- **Secrets Management:** API-Schlüssel, Datenbank-Passwörter, private Schlüssel und andere "Secrets" **MÜSSEN** sicher gespeichert und gehandhabt werden. Sie dürfen niemals im Quellcode hartcodiert oder unverschlüsselt in Konfigurationsdateien abgelegt werden, die leicht zugänglich sind.8 Mechanismen wie Umgebungsvariablen, verschlüsselte Konfigurations-Stores oder dedizierte Secrets-Management-Systeme sind zu verwenden.
- **Rate Limiting und Quotas:** Um Missbrauch durch übermäßige Anfragen (Denial-of-Service-Angriffe oder einfach fehlerhafte Clients) zu verhindern und die Stabilität des Servers zu gewährleisten, **SOLLTEN** Mechanismen für Rate Limiting (Begrenzung der Anzahl von Anfragen pro Zeiteinheit) und gegebenenfalls Quotas (Begrenzung des Gesamtressourcenverbrauchs) implementiert werden.
- **Audit Logging:** Es **SOLLTE** ein detailliertes Audit-Log aller sicherheitsrelevanten Ereignisse geführt werden. Dazu gehören mindestens: erteilte und abgelehnte Einwilligungen, Aufrufe kritischer Tools, fehlgeschlagene Authentifizierungs- und Autorisierungsversuche sowie signifikante Konfigurationsänderungen. Solche Logs sind unerlässlich für die spätere Analyse von Sicherheitsvorfällen (Forensik) und können für Compliance-Anforderungen notwendig sein.5
- **Abhängigkeitsmanagement:** Software-Abhängigkeiten (Bibliotheken, Frameworks) **MÜSSEN** regelmäßig auf bekannte Schwachstellen überprüft und zeitnah aktualisiert werden. Die Verwendung veralteter Komponenten mit bekannten Sicherheitslücken ist ein häufiges Einfallstor für Angreifer.

Die folgende Tabelle dient als Checkliste für Entwickler, um die Einhaltung der Sicherheitsprinzipien zu unterstützen:

**Tabelle 6: Checkliste der Sicherheitsprinzipien für MCP-Entwickler**

|   |   |   |   |
|---|---|---|---|
|**Sicherheitsprinzip**|**Konkrete "Do's" für die Implementierung**|**Konkrete "Don'ts" (zu vermeidende Praktiken)**|**Relevante MCP-Komponente(n)**|
|**User Consent & Control**|Klare, granulare Einwilligungsdialoge in der Host-UI implementieren. Benutzer über Zweck und Umfang jeder Aktion/jedes Datenzugriffs informieren. Widerruf ermöglichen.|Implizite Einwilligungen annehmen. Unklare oder versteckte Einwilligungsoptionen. Fehlende Möglichkeit zum Widerruf.|Host|
|**Data Privacy**|Datenminimierung praktizieren. Zugriffskontrollen implementieren. Sichere Übertragung (HTTPS für HTTP/SSE). Benutzereinwilligung vor _jeder_ Datenweitergabe einholen.|Unnötige Daten sammeln/speichern. Daten ohne explizite Zustimmung weitergeben. Schwache oder fehlende Verschlüsselung sensibler Daten.|Host, Client, Server|
|**Tool Safety**|Explizite Benutzerzustimmung vor _jedem_ Tool-Aufruf. Tool-Beschreibungen kritisch prüfen (wenn nicht von vertrauenswürdigem Server). Sandboxing erwägen.|Automatische Tool-Ausführung ohne Zustimmung. Blindes Vertrauen in Server-Beschreibungen. Ausführung von Tools mit übermäßigen Berechtigungen.|Host, Server|
|**LLM Sampling Controls**|Explizite Benutzerzustimmung für Sampling-Anfragen. Benutzerkontrolle über Prompt-Inhalt und Ergebnis-Sichtbarkeit für den Server sicherstellen.|Sampling ohne explizite Zustimmung aktivieren. Dem Server unkontrollierten Zugriff auf LLM-Interaktionen gewähren.|Host, Client, Server|
|**Input Validierung**|Alle Eingaben (Parameter, Daten) serverseitig strikt validieren (Typ, Länge, Format, erlaubte Werte).|Eingaben von Clients/Servern blind vertrauen. Fehlende oder unzureichende Validierung.|Server, Client (Host-UI)|
|**Authentifizierung/Autorisierung**|Starke Authentifizierungsmethoden für Clients/Server verwenden. Zugriff auf Ressourcen/Tools basierend auf Berechtigungen prüfen.|Schwache oder keine Authentifizierung. Fehlende Autorisierungsprüfungen (Zugriff für alle authentifizierten Entitäten).|Client, Server|
|**Secrets Management**|Secrets sicher speichern (Umgebungsvariablen, Vaults). Zugriff auf Secrets minimieren. Regelmäßige Rotation von Schlüsseln.|Secrets im Code hartcodieren. Secrets unverschlüsselt in Konfigurationsdateien speichern. Lange Gültigkeitsdauern für Secrets.|Client, Server|
|**Audit Logging**|Sicherheitsrelevante Ereignisse (Einwilligungen, Tool-Aufrufe, Fehler) detailliert protokollieren. Logs sicher speichern und regelmäßig überprüfen.|Fehlendes oder unzureichendes Logging. Logs an unsicheren Orten speichern oder nicht vor Manipulation schützen.|Host, Client, Server|

Diese Checkliste dient als praktisches Werkzeug während des gesamten Entwicklungszyklus, um sicherzustellen, dass kritische Sicherheitsaspekte nicht übersehen werden. Sie ist ein Muss für die Entwicklung vertrauenswürdiger MCP-Anwendungen.

**8. Anwendungsfälle und Beispiele (Kurzübersicht)**

Die Flexibilität des Model Context Protocol ermöglicht eine breite Palette von Anwendungsfällen, die von der Anreicherung von LLM-Antworten mit Echtzeitdaten bis hin zur Orchestrierung komplexer, agentischer Workflows reichen. Die Stärke von MCP liegt hierbei insbesondere in seiner Fähigkeit, domänenspezifisches Wissen und spezialisierte Tools für LLMs zugänglich zu machen. LLMs verfügen zwar über ein breites Allgemeinwissen, ihnen fehlt jedoch oft der aktuelle, spezifische Kontext oder die Fähigkeit zur direkten Interaktion mit proprietären Systemen – Lücken, die MCP schließen kann. Entwickler sollten MCP als ein Mittel betrachten, um das "Gehirn" eines LLMs mit den "Augen, Ohren und Händen" zu versehen, die es benötigt, um in spezifischen Domänen wertvolle und präzise Arbeit zu leisten. Der Wert einer MCP-Implementierung steigt somit mit der Relevanz, Einzigartigkeit und Leistungsfähigkeit der angebundenen Daten und Tools.

- 8.1. Real-time Grounding für Finanzrisikobewertung
    
    Finanzinstitute können MCP nutzen, um LLMs direkten Zugriff auf aktuelle Unternehmensdaten zu ermöglichen. Dies umfasst Transaktionshistorien, Betrugsdatenbanken und Kundeninformationen. Solche Integrationen erlauben es KI-Systemen, in Echtzeit Betrug zu erkennen, Risiken präziser zu bewerten und Identitäten zu verifizieren, während gleichzeitig strenge Compliance-Vorschriften eingehalten werden.5
    
- 8.2. Personalisierte Gesundheitsversorgung und Patientenreisen
    
    Im Gesundheitswesen können KI-gestützte Anwendungen, die über MCP angebunden sind, Patienten bei Aufgaben wie der Terminplanung oder der Erinnerung an Rezeptaktualisierungen unterstützen. MCP gewährleistet hierbei den sicheren und konformen Zugriff auf sensible Patientenhistorien, wodurch personalisierte Interaktionen unter Wahrung des Datenschutzes ermöglicht werden.5
    
- 8.3. Customer 360 für Handel und Telekommunikation
    
    Um personalisierte Kundenerlebnisse zu schaffen, benötigen Unternehmen im Einzelhandel und in der Telekommunikationsbranche einen umfassenden Echtzeit-Überblick über ihre Kunden. Ein MCP-Server kann diesen Kontext liefern, indem er Bestelldaten, frühere Interaktionen, Präferenzen und den aktuellen Servicestatus aus verschiedenen Backend-Systemen zusammenführt und der KI-Anwendung zur Verfügung stellt.5
    
- 8.4. Konversationelle und agentische KI-Workflows
    
    MCP ist ein Schlüssel-Enabler für anspruchsvolle konversationelle und agentische KI-Workflows, die komplexe Geschäftsoperationen autonom oder teilautonom durchführen. Ein LLM-basierter Agent könnte beispielsweise über MCP ein Support-Ticket in einem System erstellen, parallel dazu regulatorische Vorgaben in einer Wissensdatenbank prüfen und den Lieferstatus einer Bestellung über ein weiteres angebundenes System abfragen.5 MCP stellt hierfür sowohl den notwendigen Kontext als auch die Aktionsmöglichkeiten (Tools) bereit.
    
- 8.5. GitHub-Integration für Entwickler-Workflows
    
    Ein besonders anschauliches Beispiel ist die Integration von Entwicklungswerkzeugen mit GitHub über MCP. Ein MCP-Server, der die GitHub-API kapselt, kann es einer KI wie GitHub Copilot (oder einer anderen IDE-integrierten Assistenz) ermöglichen, direkt mit GitHub-Repositories zu interagieren.8
    
    - **Beispiel-Setup:** In Visual Studio Code kann beispielsweise das NPX-Paket `@modelcontextprotocol/server-github` als MCP-Server konfiguriert werden. Für die Authentifizierung gegenüber der GitHub-API wird ein `GITHUB_PERSONAL_ACCESS_TOKEN` sicher in der Konfiguration hinterlegt.8
    - **Mögliche Aktionen:** Die KI kann dann Issues zusammenfassen oder neu erstellen, Dateien im Repository lesen, Code durchsuchen oder sogar Pull Requests analysieren und kommentieren.8 Ein spezifischer Anwendungsfall ist ein PR-Review-Server, der automatisch Details zu Pull Requests und die geänderten Dateien von GitHub abruft, diese Code-Änderungen (z.B. mittels Claude Desktop über MCP) analysieren lässt und darauf basierend Zusammenfassungen oder Vorschläge für das Review generiert.17
- 8.6. Web-Suche und erweiterte Reasoning-Fähigkeiten
    
    Um LLMs mit aktuellen Informationen aus dem Internet zu versorgen, kann ein MCP-Server eine Websuchfunktion als Tool bereitstellen. Eine Host-Anwendung wie Claude Desktop kann dieses Tool dann nutzen, um Anfragen des Benutzers mit aktuellen Suchergebnissen zu beantworten oder seine Wissensbasis zu erweitern.4 Ein interessanter Aspekt ist, dass die KI das Such-Tool iterativ verwenden kann, um sich auf verschiedene Facetten einer komplexen Anfrage zu konzentrieren und so fundiertere Antworten zu generieren.4
    

Diese Beispiele illustrieren nur einen Bruchteil der Möglichkeiten. Die wahre Stärke von MCP entfaltet sich, wenn Entwickler beginnen, eigene, hochspezialisierte Server für ihre jeweiligen Domänen und Anwendungsfälle zu erstellen.

**9. Schlussfolgerungen und Empfehlungen**

Das Model Context Protocol (MCP) stellt einen signifikanten Fortschritt in der Standardisierung der Interaktion zwischen KI-Systemen und ihrer externen Umgebung dar. Es bietet ein robustes Framework, das darauf abzielt, die Komplexität von Integrationen zu reduzieren, die Entwicklungsgeschwindigkeit zu erhöhen und die Schaffung interoperabler, kontextbewusster und handlungsfähiger KI-Anwendungen zu fördern.

**Kernelemente für Entwickler:**

- **Architekturverständnis:** Ein tiefes Verständnis des Client-Host-Server-Modells und der jeweiligen Verantwortlichkeiten ist fundamental. Insbesondere die Rolle des Hosts bei der Durchsetzung von Sicherheitsrichtlinien und Benutzereinwilligungen kann nicht genug betont werden.
- **Protokollmechanik:** Vertrautheit mit JSON-RPC 2.0, den MCP-spezifischen Methoden (insbesondere `initialize`) und den Transportmechanismen (`stdio`, `HTTP/SSE`) ist für die Implementierung unerlässlich. Die Zustandsbehaftung der Verbindungen erfordert sorgfältiges Design im Hinblick auf Session-Management und Fehlerbehandlung.
- **Fähigkeitsdesign:** Die klare Unterscheidung und das durchdachte Design von Tools, Ressourcen und Prompts auf Serverseite sind entscheidend für die Nützlichkeit und Benutzerfreundlichkeit des MCP-Systems. Die Sampling-Funktion bietet mächtige Möglichkeiten, erfordert aber höchste Sorgfalt bei der Implementierung von Kontrollmechanismen.
- **Sicherheit als Priorität:** Die Sicherheitsprinzipien des MCP (User Consent and Control, Data Privacy, Tool Safety, LLM Sampling Controls) müssen von Beginn an in jedes Design und jede Implementierung integriert werden. Dies ist eine geteilte Verantwortung, bei der Hosts eine Schlüsselrolle spielen.

**Empfehlungen für die Implementierung:**

1. **SDKs nutzen:** Entwickler **SOLLTEN** wann immer möglich auf offizielle oder etablierte Community-SDKs zurückgreifen. Diese abstrahieren viele Protokolldetails, reduzieren die Fehleranfälligkeit und beschleunigen die Entwicklung (siehe 15).
2. **Sicherheitsrichtlinien strikt befolgen:** Die in Abschnitt 7 dargelegten Sicherheitsprinzipien und -richtlinien **MÜSSEN** als integraler Bestandteil des Entwicklungsprozesses betrachtet werden. Insbesondere die Implementierung robuster Einwilligungs- und Autorisierungsflüsse ist kritisch.
3. **Klare und granulare Schnittstellen definieren:** Server-Entwickler **SOLLTEN** großen Wert auf klare, verständliche und granulare Definitionen ihrer Tools, Ressourcen und Prompts legen. Dies verbessert die Nutzbarkeit sowohl für LLMs als auch für menschliche Benutzer.
4. **"Additional Utilities" implementieren:** Funktionen wie `Ping`, `Cancellation` und `Progress Tracking` **SOLLTEN** als Standard für robuste und benutzerfreundliche MCP-Anwendungen angesehen und implementiert werden, nicht als optionale Extras.
5. **Umfassend testen:** Eine gründliche Teststrategie, die Unit-, Integrations- und Sicherheitstests umfasst, ist unerlässlich, um die Qualität und Zuverlässigkeit von MCP-Komponenten sicherzustellen.
6. **Dokumentation pflegen:** Sowohl Server- als auch Client-Implementierungen **SOLLTEN** gut dokumentiert werden, um die Wartung, Weiterentwicklung und Nutzung durch andere Entwickler zu erleichtern.

Die Einführung von MCP hat das Potenzial, ein lebendiges Ökosystem von interoperablen KI-Anwendungen und -Diensten zu schaffen, ähnlich wie es das Language Server Protocol für Entwicklungswerkzeuge getan hat. Für Entwickler bietet MCP die Möglichkeit, sich von repetitiver Integrationsarbeit zu befreien und sich stattdessen auf die Schaffung innovativer KI-Funktionalitäten zu konzentrieren. Die Einhaltung der hier dargelegten Spezifikationen und Richtlinien ist der Schlüssel, um dieses Potenzial voll auszuschöpfen und vertrauenswürdige, leistungsfähige KI-Systeme der nächsten Generation zu entwickeln.

**Anhang A: Glossar der Begriffe**

- **Client:** Eine Komponente innerhalb einer Host-Anwendung, die eine 1:1-Verbindung zu einem MCP-Server verwaltet und die Kommunikation orchestriert.
- **Host:** Die primäre Anwendung, mit der der Benutzer interagiert und die MCP-Clients koordiniert sowie Sicherheitsrichtlinien durchsetzt.
- **HTTP/SSE:** Hypertext Transfer Protocol mit Server-Sent Events; ein Transportmechanismus für MCP über Netzwerke.
- **JSON-RPC 2.0:** Ein leichtgewichtiges Remote Procedure Call Protokoll, das von MCP für die Kommunikation verwendet wird.
- **MCP (Model Context Protocol):** Ein offener Standard zur Verbindung von KI-Anwendungen mit externen Tools, Datenquellen und Systemen.
- **Prompt (MCP):** Eine benutzergesteuerte, vordefinierte Vorlage zur optimalen Nutzung von Tools oder Ressourcen.
- **Resource (MCP):** Eine anwendungsgesteuerte Datenquelle, auf die LLMs zugreifen können, um Informationen abzurufen.
- **Sampling (MCP):** Eine serverinitiierte, agentische LLM-Interaktion, die explizite Client-Fähigkeit und Benutzerzustimmung erfordert.
- **Server (MCP):** Ein externes Programm oder Dienst, das Tools, Ressourcen und Prompts über eine standardisierte MCP-API bereitstellt.
- **stdio (Standard Input/Output):** Ein Transportmechanismus für MCP, wenn Client und Server auf derselben Maschine laufen.
- **Tool (MCP):** Eine modellgesteuerte Funktion, die LLMs aufrufen können, um spezifische Aktionen auszuführen.

**Anhang B: Referenzen und weiterführende Quellen**

- Offizielle MCP-Spezifikation: [https://modelcontextprotocol.io/specification/2025-03-26](https://modelcontextprotocol.io/specification/2025-03-26) (basierend auf 1)
- MCPR - Model Context Protocol für Rust (SDK): [https://github.com/conikeec/mcpr](https://github.com/conikeec/mcpr) (basierend auf 16)
- Rust MCP Schema (Typensichere MCP-Schemata für Rust): [https://github.com/rust-mcp-stack/rust-mcp-schema](https://github.com/rust-mcp-stack/rust-mcp-schema) (basierend auf 15)
- Einführung in MCP von Phil Schmid: [https://www.philschmid.de/mcp-introduction](https://www.philschmid.de/mcp-introduction) (basierend auf 3)
- OpenCV Blog zu MCP: [https://opencv.org/blog/model-context-protocol/](https://opencv.org/blog/model-context-protocol/) (basierend auf 2)
# Technische Spezifikation: LLM-Integriertes Desktop-System mit MCP

**1. Einleitung**

**1.1 Projektübersicht (Technischer Fokus)**

Dieses Dokument definiert die technische Spezifikation für die Entwicklung einer Desktop-Anwendung (im Folgenden als "System" bezeichnet). Das Kernziel ist die Bereitstellung erweiterter Funktionalitäten durch die Integration lokaler oder cloudbasierter Large Language Models (LLMs). Der Zugriff auf diese LLMs wird über das Model Context Protocol (MCP) standardisiert und durch ein differenziertes Berechtigungssystem gesteuert. Die Systemarchitektur folgt einem klar definierten 4-Schichten-Modell.

**1.2 Architekturvorstellung**

Das System ist in vier logische Schichten unterteilt, um eine klare Trennung der Verantwortlichkeiten, hohe Kohäsion und lose Kopplung zu gewährleisten:

1. **Kernschicht (Core):** Enthält anwendungsunabhängige Logik, Datentypen und Algorithmen.
2. **Domänenschicht (Domain):** Beinhaltet die anwendungsspezifische Geschäftslogik, Regeln und Zustände.
3. **Systemschicht (System):** Implementiert Schnittstellen der Domänenschicht und handhabt die Kommunikation mit externen Systemen und Infrastruktur.
4. **Benutzeroberflächenschicht (UI):** Verantwortlich für die Präsentation von Informationen und die Entgegennahme von Benutzereingaben.

**1.3 Integration des Model Context Protocol (MCP)**

Die Integration des Model Context Protocol (MCP) ist ein zentrales Architekturelement.1 Es ermöglicht eine sichere und standardisierte Kommunikation zwischen der Anwendung (die als MCP-Client fungiert) und verschiedenen LLM-Diensten (MCP-Server). Dies umfasst Funktionalitäten wie Sprachsteuerung, Dateibearbeitung, Verzeichnisanalyse und die Anzeige benutzerdefinierter Webansichten innerhalb der Anwendungsoberfläche. Die Implementierung folgt den MCP-Spezifikationen und Best Practices für Sicherheit und Benutzerkontrolle.2

**1.4 Zielgruppe und Zweck**

Dieses Dokument dient als definitive technische Blaupause für das Entwicklungsteam. Es detailliert die Implementierungsanforderungen für jede Komponente und jedes Modul innerhalb der definierten Architektur. Gemäß Anforderung werden triviale Erklärungen und Begründungen ausgelassen; der Fokus liegt auf präzisen technischen Details für erfahrene Entwickler.

**1.5 Tabelle 1: Schichtenübersicht**

|   |   |   |
|---|---|---|
|**Schicht**|**Hauptverantwortung**|**Wichtige Technologien/Konzepte (Beispiele)**|
|Kern (Core)|Anwendungsunabhängige Logik, Datenstrukturen, Algorithmen. Keine externen Abhängigkeiten (außer Standardbibliothek/Basiskisten).|Basisdatentypen (Structs, Enums), generische Algorithmen, Kernfehlerdefinitionen.|
|Domäne (Domain)|Anwendungsspezifische Geschäftslogik, Regeln, Zustand, Orchestrierung. Hängt nur vom Kern ab.|Aggregates, Entities, Value Objects, Domain Services, Repository Interfaces, Domain Events, Berechtigungslogik.|
|System|Implementierung von Domain-Interfaces, Infrastruktur-Interaktion, externe Dienste.|Datenbankzugriff (SQL, ORM), Dateisystem-API, MCP-Client-Implementierung (SDK), D-Bus (zbus), Secret Service API, Input/Output-Sicherheit (`ammonia`, `shlex`).|
|Benutzeroberfläche (UI)|Präsentation, Benutzereingabe, UI-Framework-spezifischer Code.|UI-Framework (GTK, Tauri), Views, ViewModels/Controllers, Widgets, MCP Consent UI, Event Handling, Theming.|

**2. Schicht 1: Kernschicht Spezifikation (Core Layer Specification)**

**2.1 Verantwortlichkeiten**

Die Kernschicht bildet das Fundament des Systems. Sie enthält ausschließlich Code, der unabhängig von spezifischen Anwendungsfällen oder externen Systemen ist. Dazu gehören grundlegende Datenstrukturen, wiederverwendbare Algorithmen und Kernkonfigurationstypen. Diese Schicht darf keinerlei Abhängigkeiten zu den Domänen-, System- oder UI-Schichten aufweisen. Ebenso sind Abhängigkeiten zu spezifischen Frameworks (z.B. UI-Toolkits, Datenbank-ORMs) untersagt.

**2.2 Submodul-Definitionen**

- **2.2.1 Submodul 1.1: `Core.DataTypes` (Kerndatentypen)**
    
    - **Zweck:** Definition fundamentaler, wiederverwendbarer Datenstrukturen (Structs, Enums), die potenziell über Domänengrenzen hinweg genutzt werden, aber keine domänenspezifische Logik enthalten. Beispiele: `UserID`, `Timestamp`, `FilePath`, `PermissionLevel`.
    - **Komponenten:** Struct-Definitionen, Enum-Definitionen.
    - **Technische Details:** Strukturen sollten, wo sinnvoll, unveränderlich (immutable) sein. Falls diese Typen häufig über Schichtgrenzen oder Prozessgrenzen hinweg serialisiert werden, sind entsprechende Traits (z.B. `serde::Serialize`, `serde::Deserialize` in Rust) zu implementieren.
- **2.2.2 Submodul 1.2: `Core.Algorithms` (Kernalgorithmen)**
    
    - **Zweck:** Implementierung fundamentaler, wiederverwendbarer Algorithmen, die von spezifischen Anwendungsmerkmalen entkoppelt sind. Beispiele: Generische Sortier-/Suchfunktionen, Basis-Textverarbeitungsroutinen, grundlegende kryptographische Hilfsfunktionen (z.B. Hashing-Wrapper unter Verwendung von `ring`).
    - **Komponenten:** Funktionen, ggf. Hilfsklassen/-strukturen.
    - **Technische Details:** Algorithmische Komplexität (O-Notation) ist bei Bedarf zu dokumentieren. Externe Abhängigkeiten (z.B. `ring` Crate) sind explizit zu benennen.
- **2.2.3 Submodul 1.3: `Core.Configuration` (Kernkonfiguration)**
    
    - **Zweck:** Definition von Strukturen zur Aufnahme von Anwendungskonfigurations_werten_. Diese Schicht ist nicht für das Laden der Konfiguration verantwortlich (dies erfolgt in der Systemschicht). Repräsentiert Einstellungen, die das Kernverhalten beeinflussen können.
    - **Komponenten:** Structs, die Konfigurationsabschnitte repräsentieren.
    - **Technische Details:** Strikte Typisierung verwenden. Standardwerte definieren. Sicherstellen, dass die Strukturen leicht serialisierbar/deserialisierbar sind (z.B. via `serde`).
- **2.2.4 Submodul 1.4: `Core.ErrorHandling` (Kernfehlerbehandlung)**
    
    - **Zweck:** Definition von Basis-Fehlertypen oder Traits, die systemweit für eine konsistente Fehlerbehandlung und -weitergabe verwendet werden.
    - **Komponenten:** Enum-basierte Fehlertypen (z.B. `CoreError`), ggf. unter Verwendung von Bibliotheken wie `thiserror` in Rust.
    - **Technische Details:** Fehler-Varianten klar definieren. Sicherstellen, dass Standard-Error-Traits (z.B. `std::error::Error`) implementiert sind.
- **2.2.5 Submodul 1.5: `Core.Events` (Kernereignisse)**
    
    - **Zweck:** Definition fundamentaler Ereignisstrukturen, die potenziell von einem domänenspezifischen Event-Bus verwendet werden könnten, aber generisch genug für die Kernschicht sind. Beispiele: `ApplicationStartedEvent`, `ConfigurationChangedEvent`.
    - **Komponenten:** Structs, die Ereignisdaten repräsentieren.
    - **Technische Details:** Ereignisse sollten serialisierbar sein, falls sie Prozessgrenzen überqueren müssen (typischerweise werden sie jedoch innerhalb desselben Prozesses konsumiert).

Die strikte Trennung der Kernschicht gewährleistet maximale Wiederverwendbarkeit und Testbarkeit ihrer Komponenten, unabhängig von Änderungen in der UI oder der Infrastruktur. Diese Isolation ermöglicht Unit-Tests ohne die Notwendigkeit, komplexe externe Systeme zu mocken. Änderungen an UI-Frameworks oder Datenbanktechnologien in äußeren Schichten erfordern keine Anpassungen im Kern, was Wartungsaufwand und Risiko reduziert. Entwickler müssen daher sorgfältig darauf achten, keine Abhängigkeiten von äußeren Schichten _in_ die Kernschicht einzuführen; Code-Reviews müssen diese Grenze strikt durchsetzen.

**3. Schicht 2: Domänenschicht Spezifikation (Domain Layer Specification)**

**3.1 Verantwortlichkeiten**

Die Domänenschicht enthält die Essenz der Anwendung: die spezifische Geschäftslogik, Regeln und den Anwendungszustand. Sie orchestriert Kernfunktionalitäten und definiert das Verhalten des Systems. Diese Schicht hängt ausschließlich von der Kernschicht ab und ist unabhängig von UI- und Infrastrukturdetails.

**3.2 Submodul-Definitionen**

- **3.3.1 Submodul 2.1: `Domain.UserManagement` (Benutzerverwaltung)**
    
    - **Zweck:** Verwaltung von Benutzerprofilen, Authentifizierungszuständen (nicht der Authentifizierungsmechanismus selbst) und potenziell benutzerspezifischer Einstellungslogik.
    - **Komponenten:** `UserService` (Anwendungslogik), `UserRepository` (Interface für Persistenz), `User` Aggregate Root (zentrale Entität), Domain Events (z.B. `UserLoggedIn`, `UserProfileUpdated`).
    - **Technische Details:** Aggregate-Grenzen definieren. Validierungsregeln für Benutzerdaten spezifizieren (z.B. E-Mail-Format, Passwortstärke-Anforderungen – die eigentliche Hash-Berechnung erfolgt im System Layer). Repository-Interface-Methoden definieren (z.B. `findById`, `save`, `findByEmail`).
- **3.3.2 Submodul 2.2: `Domain.FileOperations` (Dateiverwaltung)**
    
    - **Zweck:** Definition der Domänenlogik für Dateioperationen, die über MCP angefordert werden könnten (z.B. Analyse von Verzeichnissen, potenziell Bearbeiten von Dateien). Definiert die _Absicht_ der Operation, führt aber keine tatsächlichen I/O-Operationen durch.
    - **Komponenten:** `FileOperationService`, `DirectoryAnalysisRequest` (Value Object), `FileEditCommand` (Command Object), `FileSystemRepository` (Interface für Dateisystemzugriff).
    - **Technische Details:** Definition von Commands und Value Objects, die Dateioperationen repräsentieren. Spezifikation von Vor- und Nachbedingungen für Operationen. Definition von Repository-Interface-Methoden (z.B. `getDirectoryContents`, `readFileContent`, `writeFileContent`).
- **3.3.3 Submodul 2.3: `Domain.LLMInteraction` (LLM-Interaktion)**
    
    - **Zweck:** Modellierung der Domänenkonzepte im Zusammenhang mit der Interaktion mit LLMs über MCP. Definiert, _was_ getan werden kann (z.B. Textgenerierung, Analyseaufgaben), aber nicht, _wie_ MCP technisch genutzt wird.
    - **Komponenten:** `LLMTaskService`, `LLMTask` (Entity/Value Object), `PromptTemplate` (Value Object), `LLMInteractionRepository` (Interface für die Ausführung).
    - **Technische Details:** Definition von Strukturen für verschiedene LLM-Aufgabentypen (z.B. `SummarizationTask`, `CodeGenerationTask`). Definition des Repository-Interfaces (`executeTask`).
- **3.3.4 Submodul 2.4: `Domain.Permissions` (Berechtigungslogik)**
    
    - **Zweck:** Implementierung der Kernlogik für das geforderte "clevere Berechtigungssystem". Bestimmt, ob ein Benutzer oder eine Sitzung das Recht hat, spezifische Aktionen durchzuführen (z.B. Zugriff auf ein bestimmtes MCP-Tool, Lesen eines bestimmten Dateityps).
    - **Komponenten:** `PermissionService`, `PermissionPolicy`, `RequiredPermission` (Value Object), `PermissionRepository` (Interface zum Laden von Rollen/Berechtigungen).
    - **Technische Details:** Definition der Berechtigungsprüfungslogik, z.B. mittels Role-Based Access Control (RBAC). Spezifikation, wie Berechtigungen strukturiert und gegen Benutzerrollen oder -attribute ausgewertet werden. Definition des Repository-Interfaces (`getUserPermissions`).
- **3.3.5 Submodul 2.5: `Domain.VoiceControl` (Sprachsteuerung)**
    
    - **Zweck:** Definition der Domänenlogik zur Interpretation von Sprachbefehlen und deren Übersetzung in Anwendungsaktionen oder LLM-Aufgaben.
    - **Komponenten:** `VoiceCommandParser` (Interface/Implementierung), `VoiceCommandInterpreterService`, `VoiceCommandRepository` (Interface, z.B. für benutzerdefinierte Befehle).
    - **Technische Details:** Definition der Struktur für geparste Sprachbefehle. Spezifikation der Logik zur Zuordnung von Befehlen zu Aktionen/Aufgaben. Definition des Repository-Interfaces (`getCustomCommands`).
- **3.3.6 Submodul 2.6: `Domain.WebViewWidget` (Webansicht-Widget Logik)**
    
    - **Zweck:** Handhabt die Domänenlogik im Zusammenhang mit der benutzerdefinierten Webansicht, die über MCP angefordert werden kann (z.B. Definition, welche Inhalte angezeigt werden dürfen, Verwaltung des Zustands der Ansicht).
    - **Komponenten:** `WebViewService`, `WebViewContentPolicy`, `WebViewState`.
    - **Technische Details:** Definition von Richtlinien für erlaubte URLs oder Inhaltstypen. Spezifikation der Zustandsverwaltungslogik für die Webansicht.

Die Domänenschicht kapselt den Kernwert und die Komplexität der Anwendung. Die Definition klarer Schnittstellen (Repositories) für externe Abhängigkeiten (wie Persistenz oder die tatsächliche MCP-Kommunikation) ist entscheidend für die Entkopplung. Diese Interfaces erlauben der Domänenschicht, ihre _Bedürfnisse_ auszudrücken (z.B. "speichere Benutzer", "führe LLM-Aufgabe aus"), ohne die konkrete _Implementierung_ zu kennen. Die Systemschicht liefert dann die Implementierungen. Dies folgt dem Dependency Inversion Principle und macht die Domänenschicht testbar und unabhängig von Infrastrukturentscheidungen. Das Submodul `Domain.Permissions` ist zentral für die Umsetzung des geforderten Berechtigungssystems, das den Zugriff auf MCP-Funktionen steuert. Diese Kontrolllogik ist eine Kerngeschäftsregel und gehört daher in die Domänenschicht, getrennt von der technischen Authentifizierung (System) oder der Einholung von Zustimmungen (UI/System). Das Design der Repository-Interfaces muss sorgfältig erfolgen, um die notwendigen Abstraktionen zu bieten, ohne Implementierungsdetails preiszugeben.

**4. Schicht 3: Systemschicht Spezifikation (System Layer Specification)**

**4.1 Verantwortlichkeiten**

Die Systemschicht fungiert als Brücke zwischen der Domänenschicht und der Außenwelt. Sie implementiert die von der Domänenschicht definierten Interfaces (z.B. Repositories) und handhabt die technische Kommunikation mit externen Systemen und Diensten. Dazu gehören Datenbanken, das Dateisystem, Netzwerkdienste (insbesondere MCP-Server) und Betriebssystemdienste (wie der D-Bus für die Secret Service API). Diese Schicht enthält infrastruktur-spezifischen Code und hängt von der Domänen- und Kernschicht ab.

**4.2 Submodul-Definitionen**

- **4.3.1 Submodul 3.1: `System.Persistence` (Persistenz)**
    
    - **Zweck:** Bereitstellung konkreter Implementierungen für Repository-Interfaces aus der Domänenschicht (z.B. `UserRepository`, `PermissionRepository`). Interagiert mit dem gewählten Datenbanksystem.
    - **Komponenten:** `SqlUserRepository` (implementiert `Domain.UserManagement.UserRepository`), `DatabaseClientWrapper`, ORM-Entitäten/Mappings (falls ORM genutzt wird).
    - **Technische Details:** Spezifikation des Datenbanktyps (z.B. PostgreSQL, SQLite). Detaillierung relevanter Schema-Ausschnitte. Spezifikation des ORMs oder Datenbanktreibers (z.B. `sqlx`, `diesel` in Rust). Definition der Connection-Pooling-Strategie.
- **4.3.2 Submodul 3.2: `System.FileSystemAccess` (Dateisystemzugriff)**
    
    - **Zweck:** Implementiert das `FileSystemRepository`-Interface aus `Domain.FileOperations`. Führt tatsächliche Datei-I/O-Operationen durch.
    - **Komponenten:** `LocalFileSystemRepository` (implementiert `Domain.FileOperations.FileSystemRepository`).
    - **Technische Details:** Verwendung von Standardbibliotheksfunktionen für Dateizugriff (z.B. `std::fs` in Rust). Implementierung der Fehlerbehandlung für I/O-Ausnahmen. **Wichtig:** Falls Dateipfade oder verwandte Argumente (die aus Dateioperationen stammen) an externe Shell-Befehle übergeben werden, muss Shell Argument Escaping mittels der `shlex`-Bibliothek implementiert werden, um Command Injection zu verhindern.4
- **4.3.3 Submodul 3.3: `System.MCP.Client` (MCP Client Implementierung)**
    
    - **Zweck:** Implementiert das `LLMInteractionRepository`-Interface. Handhabt die technischen Details der MCP-Kommunikation: Verbindungsaufbau, Serialisierung/Deserialisierung von Nachrichten, Aufruf von MCP Resources und Tools. Fungiert als MCP _Host_ oder _Client_ gemäß MCP-Terminologie.2
    - **Komponenten:** `MCPClientService` (implementiert `Domain.LLMInteraction.LLMInteractionRepository`), `MCPConnectionManager`, `MCPMessageSerializer`.
    - **Technische Details:** Nutzung des offiziellen MCP SDK für Rust (`modelcontextprotocol/rust-sdk` 1). Implementierung des Verbindungslebenszyklus (Verbinden, Trennen, Wiederverbinden). Handhabung der JSON-RPC 2.0 Nachrichtenübermittlung über WebSockets.2 Implementierung der Logik zur Interaktion mit MCP `Resources`, `Tools` und potenziell `Prompts`.2 Verwaltung des Sitzungszustands, falls erforderlich.6 Implementierung von Rate Limiting und Timeouts für MCP-Anfragen.3
- **4.3.4 Submodul 3.4: `System.Security.Credentials` (Sichere Speicherung)**
    
    - **Zweck:** Sicheres Speichern und Abrufen sensibler Daten wie API-Schlüssel oder Tokens, die für den Zugriff auf MCP-Server oder andere Dienste benötigt werden. Implementiert potenziell ein in der Domäne definiertes Interface oder wird direkt von anderen Systemmodulen genutzt.
    - **Komponenten:** `SecretServiceClient`, `CredentialManager`.
    - **Technische Details:** Nutzung der D-Bus Secret Service API auf Linux/Desktop-Umgebungen.7 Verwendung der `zbus`-Bibliothek für die D-Bus-Kommunikation aufgrund ihrer reinen Rust-Implementierung und async-Unterstützung.9 Implementierung von Methoden, die den Secret Service API-Aufrufen entsprechen, wie `CreateItem`, `SearchItems`, `RetrieveSecrets`.7 Speicherung der Credentials in der Standard-Collection des Benutzers (`/org/freedesktop/secrets/aliases/default`), sofern keine spezifischen Anforderungen etwas anderes vorschreiben.7 Behandlung potenzieller Fehler wie gesperrte Keyrings.
- **4.3.5 Submodul 3.5: `System.Security.InputOutput` (Ein-/Ausgabe-Sicherheit)**
    
    - **Zweck:** Bereitstellung von Diensten zur Bereinigung (Sanitization) und Validierung von Daten, die von externen Quellen in das System gelangen (z.B. LLM-Antworten zur Anzeige oder Ausführung) und potenziell von Daten, die das System verlassen.
    - **Komponenten:** `HtmlSanitizerService`, `CommandArgumentSanitizer`.
    - **Technische Details:** Für HTML-Inhalte, die von LLMs oder MCP-Webansichten empfangen werden, ist die `ammonia`-Bibliothek in Rust zu verwenden.11 Diese ermöglicht eine robuste, Whitelist-basierte Bereinigung mit einer strikten Konfiguration (ähnliche Prinzipien wie beim OWASP Java Sanitizer 12), um Cross-Site Scripting (XSS) zu verhindern.13 Für Argumente, die an Shell-Befehle übergeben werden (z.B. über `System.FileSystemAccess`), ist die `shlex`-Bibliothek in Rust für korrektes Escaping zu verwenden, um Command Injection zu verhindern.4 Implementierung von Validierungslogik basierend auf erwarteten Datenformaten (z.B. mittels JSON Schema Validierung oder Konzepten wie `guardrails-ai` 14 für LLM-Ausgabestrukturen). Anwendung eines Zero-Trust-Ansatzes auf LLM-Ausgaben.13
- **4.3.6 Submodul 3.6: `System.ConfigurationLoader` (Konfigurationslader)**
    
    - **Zweck:** Lädt die Anwendungskonfiguration aus Dateien oder Umgebungsvariablen und füllt die in `Core.Configuration` definierten Strukturen.
    - **Komponenten:** `ConfigFileLoader`, `EnvVarLoader`.
    - **Technische Details:** Spezifikation des Konfigurationsdateiformats (z.B. TOML, YAML). Verwendung von Bibliotheken wie `config-rs` in Rust. Handhabung der Ladereihenfolge und von Overrides.
- **4.3.7 Submodul 3.7: `System.IPC.DBus` (D-Bus Kommunikation)**
    
    - **Zweck:** Verwaltung allgemeiner D-Bus-Verbindungen und Interaktionen über den Secret Service hinaus, falls für andere Integrationen erforderlich (z.B. Desktop-Benachrichtigungen, Mediensteuerung).
    - **Komponenten:** `DBusConnectionService`.
    - **Technische Details:** Nutzung der `zbus`-Bibliothek.9 Verwaltung des Verbindungsaufbaus und -lebenszyklus. Bereitstellung von Wrappern für gängige D-Bus-Muster (Methodenaufrufe, Signal-Empfang).

Diese Schicht bildet die entscheidende Verbindung zwischen der abstrakten Domänenlogik und der konkreten externen Welt. Ihre Korrektheit ist für Sicherheit und Funktionalität von zentraler Bedeutung. Während die Domänenschicht definiert, _was_ geschehen muss, implementiert die Systemschicht das _Wie_ unter Verwendung spezifischer Technologien. Diese Trennung lokalisiert Infrastrukturabhängigkeiten, was Anpassungen (z.B. Datenbankwechsel) und Tests (durch Mocking von Systemkomponenten) erleichtert. Fehler in dieser Schicht (z.B. unzureichende SQL-Injection-Prävention, fehlerhafte MCP-Nachrichtenformatierung) wirken sich jedoch direkt auf Funktion und Sicherheit aus. Die Integration externer Sicherheitsbibliotheken (`ammonia`, `shlex`) und OS-Dienste (Secret Service via `zbus`) in dieser Schicht zentralisiert kritische Sicherheitsmechanismen und verhindert deren Verstreuung im Code. Gründliche Tests, einschließlich Sicherheitstests, sind für Komponenten der Systemschicht unerlässlich. Die Konfiguration von Sicherheitsbibliotheken (z.B. `ammonia`-Richtlinien) muss strikt sein und sorgfältig überprüft werden. Die Fehlerbehandlung für externe Interaktionen muss robust sein.

**5. Schicht 4: Benutzeroberflächenschicht Spezifikation (UI Layer Specification)**

**5.1 Verantwortlichkeiten**

Die Benutzeroberflächenschicht (UI) ist für die Interaktion mit dem Benutzer verantwortlich. Sie präsentiert Informationen und nimmt Benutzereingaben entgegen. Sie interagiert typischerweise mit der System- oder Domänenschicht (oft über Application Services oder dedizierte ViewModels/Controller), um Daten abzurufen und Aktionen auszulösen. Diese Schicht enthält den UI-Framework-spezifischen Code.

**5.2 Submodul-Definitionen**

- **5.3.1 Submodul 4.1: `UI.MainWindow` (Hauptfenster)**
    
    - **Zweck:** Definition der Struktur des Hauptanwendungsfensters, des Layouts und der primären Navigationselemente (z.B. Seitenleiste, Menüleiste).
    - **Komponenten:** `MainWindowView`, `MainWindowViewModel` (oder Controller), `SidebarComponent`, `MenuBarComponent`.
    - **Technische Details:** Spezifikation des UI-Frameworks (z.B. GTK über `gtk-rs`, Tauri mit Web-Frontend, Qt). Definition der Layoutstruktur (z.B. mittels GtkBuilder UI-Definitionen, HTML/CSS in Tauri, oder programmatisch). Implementierung von Data Binding zwischen View und ViewModel. Handhabung grundlegender Fensterereignisse. Konzepte zur Organisation von UI-Kontexten wie "Tab Islands" 15 oder "Spaces" 16 können mittels der Fähigkeiten des gewählten UI-Frameworks implementiert werden (z.B. durch Tab-Container, Ansichtswechsel-Logik).
- **5.3.2 Submodul 4.2: `UI.Views.[Feature]` (Feature-Ansichten)**
    
    - **Zweck:** Definition spezifischer Ansichten für verschiedene Anwendungsfunktionen (z.B. Benutzerprofil-Editor, Dateibrowser-Ansicht, LLM-Chat-Interface).
    - **Komponenten:** `UserProfileView`, `UserProfileViewModel`, `FileBrowserView`, `FileBrowserViewModel`, etc.
    - **Technische Details:** Definition der UI-Elemente für jede Ansicht. Implementierung von Data Binding. Handhabung von Benutzerinteraktionen (Button-Klicks, Texteingabe) und Delegation von Aktionen an das ViewModel/Controller.
- **5.3.3 Submodul 4.3: `UI.MCP.Consent` (MCP Consent Dialoge)**
    
    - **Zweck:** Implementierung der Benutzeroberflächenelemente, die für die MCP-Zustimmungsflüsse gemäß der MCP-Spezifikation erforderlich sind.2 Präsentiert dem Benutzer Anfragen für Datenzugriff, Werkzeugausführung und Sampling zur Genehmigung.
    - **Komponenten:** `MCPConsentDialogView`, `MCPConsentViewModel`, `PermissionRequestDisplayComponent`.
    - **Technische Details:** Gestaltung klarer und unmissverständlicher Dialoge, die erklären, _welche_ Berechtigung angefordert wird, _welcher_ MCP-Server sie anfordert und (wenn möglich) _warum_. Bereitstellung klarer "Erlauben" / "Ablehnen"-Optionen. Implementierung der Logik zur Auslösung dieser Dialoge basierend auf Signalen vom `System.MCP.Client` oder der Domänenschicht. Sicherstellung, dass Benutzerentscheidungen sicher zurückgemeldet werden. Diese Komponente ist kritisch für die Erfüllung der MCP Host-Verantwortlichkeiten.2
- **5.3.4 Submodul 4.4: `UI.Widgets.WebView` (Webansicht Widget)**
    
    - **Zweck:** Implementierung der UI-Komponente zur Anzeige der benutzerdefinierten Webansicht, die über MCP angefordert werden kann.
    - **Komponenten:** `WebViewWidgetComponent`.
    - **Technische Details:** Nutzung der Web-View-Komponente des UI-Frameworks (z.B. `WebKitGTK`, `WebView2` via Tauri). Implementierung einer Kommunikationsbrücke, falls Interaktion zwischen Webinhalt und Hauptanwendung erforderlich ist. **Wichtig:** Sicherstellen, dass jeder geladene HTML-Inhalt (insbesondere wenn er durch LLM-Ausgaben oder MCP beeinflusst wird) entweder aus einer vertrauenswürdigen Quelle stammt oder vor dem Rendern durch `System.Security.InputOutput.HtmlSanitizerService` bereinigt wird, um XSS zu verhindern.13
- **5.3.5 Submodul 4.5: `UI.Theming` (Theming/Styling)**
    
    - **Zweck:** Verwaltung des visuellen Erscheinungsbilds (Farben, Schriftarten, Stile) der Anwendung.
    - **Komponenten:** CSS-Dateien, Stildefinitionen, Theme-Manager-Service.
    - **Technische Details:** Spezifikation des Styling-Mechanismus (z.B. CSS, QSS). Definition der Theme-Struktur. Implementierung der Logik zum Wechseln von Themes (z.B. Hell/Dunkel-Modus, ähnlich wie in Arc 16).
- **5.3.6 Submodul 4.6: `UI.Notifications` (Benachrichtigungen)**
    
    - **Zweck:** Anzeige von Benachrichtigungen für den Benutzer (z.B. Abschluss von Operationen, Fehler, MCP-Ereignisse).
    - **Komponenten:** `NotificationView`, `NotificationService`.
    - **Technische Details:** Nutzung des Benachrichtigungssystems des UI-Frameworks oder Integration mit Desktop-Benachrichtigungsstandards (potenziell über `System.IPC.DBus`).

Die UI-Schicht ist der primäre Interaktionspunkt für das benutzerzentrierte Sicherheitsmodell von MCP (Zustimmung). Ihr Design beeinflusst direkt die Benutzerfreundlichkeit und die Wirksamkeit der Sicherheitsmaßnahmen. Da MCP explizite Benutzerzustimmung für kritische Operationen vorschreibt 2, ist das `UI.MCP.Consent`-Submodul nicht nur ein UI-Feature, sondern eine kritische Sicherheitskomponente. Schlecht gestaltete Zustimmungsdialoge können dazu führen, dass Benutzer Berechtigungen erteilen, die sie nicht verstehen, was das Sicherheitsmodell untergräbt. Klare, informative und kontextbezogene Zustimmungsaufforderungen sind daher unerlässlich. Darüber hinaus erfordert die Anzeige potenziell von LLMs generierter Inhalte (z.B. in Chat-Ansichten oder dem WebView-Widget) eine sorgfältige Behandlung, um clientseitige Angriffe wie XSS zu verhindern. LLMs können Ausgaben mit Markup oder Code generieren.13 Wenn diese direkt im UI gerendert werden, ohne Bereinigung, könnte schädlicher Inhalt im Kontext des Benutzers ausgeführt werden. Daher MÜSSEN alle Komponenten, die potenziell unsichere Inhalte rendern, die Bereinigungsdienste der Systemschicht (`System.Security.InputOutput.HtmlSanitizerService`) nutzen.11 Die UI-Entwicklung muss Klarheit und Sicherheit priorisieren, insbesondere bei Zustimmungsflüssen und der Darstellung externer Inhalte.

**6. Querschnittsthema: Model Context Protocol (MCP) Integration**

**6.1 Architekturüberblick**

Die MCP-Integration ist ein Querschnittsthema, das mehrere Schichten durchdringt: Die UI-Schicht ist für die Einholung der Benutzerzustimmung (`UI.MCP.Consent`) verantwortlich. Die Systemschicht implementiert den eigentlichen MCP-Client (`System.MCP.Client`), handhabt die sichere Kommunikation und die Ein-/Ausgabe-Sicherheit (`System.Security.*`). Die Domänenschicht definiert die Logik der LLM-Interaktionen (`Domain.LLMInteraction`) und die Berechtigungsregeln (`Domain.Permissions`). Das Modul `System.MCP.Client` agiert als MCP Host/Client im Sinne der MCP-Spezifikation.2

**6.2 MCP Client Implementierung (UI & Core Apps)**

- **SDK-Wahl:** Das offizielle MCP SDK für Rust (`modelcontextprotocol/rust-sdk`) wird verwendet.1
- **Verbindungsmanagement:** Implementierung in `System.MCP.Client`. Umfasst den Aufbau von WebSocket-Verbindungen zu MCP-Servern (lokal oder Cloud), Fehlerbehandlung bei Verbindungsabbrüchen, Wiederverbindungslogik und die Sicherstellung sicherer Verbindungen mittels TLS.
- **Resource/Tool Handling:** Der Client (`System.MCP.Client`) implementiert die Logik zur Entdeckung und Interaktion mit `Resources` (Bereitstellung von Kontext für LLMs) und `Tools` (Ausführung von Aktionen), die vom MCP-Server angeboten werden.2 MCP-Tool-Aufrufe werden an entsprechende Aktionen in der Domänen- oder Systemschicht gemappt.
- **Sampling Handling:** Implementierung der clientseitigen Logik zur Handhabung von server-initiierten `sampling`-Anfragen.2 Der Prozess umfasst:
    1. Empfang der Sampling-Anfrage durch `System.MCP.Client`.
    2. Auslösen des `UI.MCP.Consent`-Flusses zur Einholung der Benutzergenehmigung. Der Benutzer MUSS explizit zustimmen.2
    3. Dem Benutzer SOLLTE die Möglichkeit gegeben werden, den zu sendenden Prompt zu überprüfen und zu kontrollieren.2
    4. Senden des Prompts an das LLM (entweder über eine weitere MCP-Interaktion oder direkt, abhängig von der Architektur).
    5. Kontrolle darüber, welche Ergebnisse der Sampling-Operation an den anfragenden MCP-Server zurückgesendet werden dürfen (Benutzerkontrolle über `UI.MCP.Consent`).2

**6.3 Interaktion mit MCP Servern**

- **Protokolldetails:** Strikte Einhaltung von JSON-RPC 2.0 über WebSocket.2 Definition der erwarteten Nachrichtenformate für Anfragen und Antworten bezüglich benutzerdefinierter Tools und Ressourcen.
- **Datenflüsse:** Klare Definition und ggf. Diagramme der Datenflüsse für Schlüsselinteraktionen. Beispiel: Benutzer fordert Verzeichnisanalyse an -> UI sendet Anfrage -> Domänenlogik (`Domain.FileOperations`) -> System ruft MCP Tool über `System.MCP.Client` auf -> MCP Server führt Analyse durch -> Antwort über MCP -> UI zeigt Ergebnis an.
- **Server Discovery/Configuration:** Die Konfiguration, zu welchen MCP-Servern (lokale LLM-Wrapper, Cloud-Dienste) eine Verbindung hergestellt werden soll, erfolgt über `System.ConfigurationLoader`, basierend auf Konfigurationsdateien oder Umgebungsvariablen.

**6.4 Sicherheit & Berechtigungen**

Die sichere Integration von MCP erfordert einen mehrschichtigen Ansatz, der über die reine Protokollimplementierung hinausgeht.

- **Authentifizierungs-/Autorisierungsstrategie:**
    
    - _Client-Authentifizierung:_ Falls MCP-Server eine Authentifizierung des Clients (dieser Anwendung) erfordern, sind Mechanismen wie API-Schlüssel oder Tokens zu verwenden. Diese Credentials MÜSSEN sicher über `System.Security.Credentials` (Secret Service API) gespeichert werden.7 Standardisierte Protokolle wie OAuth 2.0 oder JWTs sollten bevorzugt werden, wenn vom Server unterstützt.3
    - _Benutzer-Authentifizierung:_ Die Authentifizierung des Benutzers _innerhalb_ der Anwendung wird durch `Domain.UserManagement` und entsprechende System-Layer-Mechanismen gehandhabt und ist von der MCP-Client-Authentifizierung getrennt.
- **Consent Management Flow:** Der Prozess zur Einholung der Benutzerzustimmung ist zentral für die MCP-Sicherheit 2:
    
    1. Ein MCP-Server fordert Zugriff auf eine Ressource, ein Tool oder initiiert Sampling. `System.MCP.Client` empfängt die Anfrage.
    2. Die System-/Domänenschicht prüft, ob für diese spezifische Aktion und diesen Server eine Zustimmung erforderlich ist (basierend auf der Aktion und ggf. gecachten Benutzerentscheidungen) und ob der Benutzer gemäß `Domain.Permissions` überhaupt dazu berechtigt ist.
    3. Falls Zustimmung benötigt wird, wird `UI.MCP.Consent` ausgelöst, um eine klare und verständliche Anfrage anzuzeigen.
    4. Der Benutzer erteilt oder verweigert die Erlaubnis über die UI.
    5. Die Entscheidung wird sicher gehandhabt (z.B. temporär in der Sitzung oder persistent in Benutzereinstellungen).
    6. Die Aktion wird basierend auf der Zustimmung ausgeführt oder abgelehnt.
    
    - Dieser Fluss implementiert die Kernprinzipien von MCP.2 Granularität (Zustimmung pro Tool/Ressourcentyp/Server) ist anzustreben.
- **Eingabevalidierung/-sanitisierung:**
    
    - _Prompt Injection Abwehr:_ Bevor Prompts (aus Benutzereingaben oder MCP-Interaktionen konstruiert) an ein LLM gesendet werden, MÜSSEN Filterung und Kontexttrennung implementiert werden. Techniken wie die Kennzeichnung der Vertrauenswürdigkeit von Eingabequellen (Trennung von Benutzer-Prompts und potenziell unvertrauenswürdigen Daten aus MCP-Ressourcen) sind anzuwenden.18 Parameter, die an MCP-Tools übergeben werden, MÜSSEN rigoros validiert werden (`System.MCP.Client` oder empfangendes Systemmodul).3 Tool-Beschreibungen von Servern sind als potenziell unvertrauenswürdig zu betrachten, es sei denn, der Server ist verifiziert.2 Maßnahmen gegen OWASP LLM Top 10 Risiken wie Prompt Injection sind zu implementieren.18
    - _Parameter Validation:_ Typen, Bereiche, Formate und Größen von Parametern, die an MCP-Tools gesendet werden, sind zu validieren.3
- **Ausgabeverarbeitung:**
    
    - _LLM Response Validation/Sanitization:_ Alle über MCP empfangenen LLM-Ausgaben sind als unvertrauenswürdig zu behandeln.13 Die Struktur ist zu validieren, wenn ein bestimmtes Format erwartet wird (z.B. JSON 14). HTML/Markdown MUSS mittels `System.Security.InputOutput.HtmlSanitizerService` (`ammonia` 11) bereinigt werden, bevor es im UI gerendert wird, um XSS zu verhindern.12 Auf Inkonsistenzen oder potenzielle Halluzinationen ist, wo möglich, zu prüfen.13 Unbeabsichtigte Befehlsausführung basierend auf der Ausgabe ist zu verhindern.
    - _Tool Output Validation:_ Struktur und Inhalt der von MCP-Tool-Ausführungen empfangenen Ergebnisse sind zu validieren.3
- **Sichere Speicherung von Credentials:** Erneute Betonung der Verwendung von `System.Security.Credentials` mit der D-Bus Secret Service API über `zbus` 7 zur Speicherung von Authentifizierungsdaten für MCP-Server.
    
- **Least Privilege:** Das Prinzip der geringsten Rechte ist durchzusetzen. Die Anwendung (als MCP Host/Client) sollte nur die Berechtigungen anfordern, die sie benötigt. Die Logik in `Domain.Permissions` stellt sicher, dass Benutzer/Sitzungen nur mit den minimal notwendigen Rechten operieren.18 Für risikoreiche Aktionen ist eine menschliche Bestätigung über `UI.MCP.Consent` (Human-in-the-Loop) unerlässlich.18
    
- **6.4.1 Tabelle 3: MCP Sicherheitsmaßnahmen**
    

|   |   |   |   |
|---|---|---|---|
|**Risikobereich**|**Maßnahme**|**Verantwortliche(s) Modul(e)**|**Referenz (Beispiele)**|
|Prompt Injection|Eingabefilterung, Kontexttrennung (User vs. External Data), Parameter-Validierung, Tool-Beschreibungen als unsicher behandeln.|`System.Security.InputOutput`, `System.MCP.Client`|3|
|Unsichere Tool-Ausführung|Explizite Benutzerzustimmung (Consent UI), Berechtigungsprüfung (RBAC), Parameter-Validierung, Rate Limiting, Timeouts.|`UI.MCP.Consent`, `Domain.Permissions`, `System.MCP.Client`|2|
|Datenschutzverletzung|Explizite Benutzerzustimmung für Datenzugriff/Übertragung, Sichere Speicherung von Credentials, Zugriffskontrolle.|`UI.MCP.Consent`, `System.Security.Credentials`, `Domain.Permissions`|2|
|Unsichere Ausgabeverarbeitung|Zero-Trust für LLM/Tool-Output, Output-Sanitization (HTML/Markdown), Output-Validierung (Struktur, Inhalt), Verhinderung von Code Execution.|`System.Security.InputOutput`, `UI.Widgets.WebView`, UI-Komponenten (z.B. Chat)|11|
|Unautorisierter Zugriff|Client-Authentifizierung bei MCP-Servern (Tokens/Keys), Benutzer-Authentifizierung in der App, RBAC, Least Privilege Prinzip.|`System.Security.Credentials`, `Domain.UserManagement`, `Domain.Permissions`, `System.MCP.Client`|3|
|Unerwünschtes Sampling|Explizite Benutzerzustimmung pro Anfrage, Benutzerkontrolle über Prompt & Ergebnis-Sichtbarkeit.|`UI.MCP.Consent`, `System.MCP.Client`|2|

Eine sichere MCP-Integration ist nicht nur eine Frage der Protokollimplementierung, sondern erfordert einen ganzheitlichen Sicherheitsansatz. Dieser umfasst robuste Eingabevalidierung, Ausgabebereinigung, klare und sichere Zustimmungsmechanismen sowie sicheres Credential Management. Dabei müssen sowohl allgemeine Best Practices der Anwendungssicherheit als auch LLM-spezifische Risiken berücksichtigt werden.2 Das "clevere Berechtigungssystem" ist untrennbar mit dem MCP-Zustimmungsfluss verbunden. Die in `Domain.Permissions` definierten Berechtigungen müssen die Notwendigkeit und Granularität der Zustimmung beeinflussen, die auf der UI/System-Ebene für MCP-Aktionen eingeholt wird. Berechtigungen gewähren die generelle Fähigkeit, während die Zustimmung die spezifische Ausführung autorisiert. Dies erfordert eine sorgfältige Koordination zwischen `Domain.Permissions`, `System.MCP.Client` und `UI.MCP.Consent`. Die Sicherheit der gesamten Kette hängt vom schwächsten Glied ab.

**7. Anhang**

**7.1 Verwendete Technologien und Bibliotheken (Auswahl)**

- **Programmiersprache:** Rust
- **MCP Integration:** `modelcontextprotocol/rust-sdk` 1
- **D-Bus Kommunikation:** `zbus` 9
- **Sichere Speicherung (Linux):** D-Bus Secret Service API (via `zbus`) 7
- **HTML Sanitization:** `ammonia` 11
- **Shell Argument Escaping:** `shlex` 4
- **UI Framework:** Zu spezifizieren (Optionen: GTK via `gtk-rs`, Tauri, Qt via Bindings)
- **Datenbankzugriff:** Zu spezifizieren (Optionen: `sqlx`, `diesel`)
- **Konfiguration:** `config-rs` (oder äquivalent)
- **Fehlerbehandlung:** `thiserror` (oder äquivalent)
- **Serialisierung:** `serde`

# Planung und Spezifikation einer KI-gestützten Desktop-Sidebar für Manjaro Linux

## I. Einleitung

### Zweck

Dieses Dokument beschreibt den Entwurf und die Spezifikation für die Entwicklung einer neuartigen, KI-gesteuerten Desktop-Komponente für das Manjaro Linux-Betriebssystem. Das Kernziel ist die Schaffung eines intelligenten Assistenten, der als persistente Sidebar in die Desktop-Umgebung integriert ist. Die technologische Basis bilden C++, das Qt-Framework (insbesondere Qt 6), QML für die Benutzeroberfläche und Qt-Wayland für die nahtlose Integration in moderne Display-Server-Umgebungen.

### Vision

Die Vision ist eine transformative Benutzererfahrung, bei der ein stets präsenter KI-Assistent den Anwendern zur Seite steht. Dieser Assistent soll natürliche Sprache verstehen und darauf basierend Systemoperationen und Aktionen in Manjaro ausführen können. Dies umfasst das Starten von Anwendungen, die Verwaltung von Systemressourcen, die Abfrage von Informationen und die Interaktion mit Systemeinstellungen. Die Sidebar soll die Produktivität steigern und die Interaktion mit dem Manjaro-System intuitiver gestalten.

### Kerninnovation: Manjaro Control Protocol (MCP)

Ein zentrales Element dieses Projekts ist die Definition und Spezifikation des "Manjaro Control Protocol" (MCP). Dieses Protokoll dient als standardisierte Schnittstelle zwischen der KI (speziell dem Large Language Model, LLM) und der Systemsteuerungsschicht von Manjaro. Eine wesentliche Anforderung ist, dass das MCP so präzise und selbsterklärend definiert wird, dass ein LLM dessen Funktionsweise und Semantik _ausschließlich_ anhand der in diesem Bericht enthaltenen Spezifikation verstehen und korrekt anwenden kann, ohne auf externes Wissen, Trainingsdaten oder Internetzugriff angewiesen zu sein.

### Umfang des Berichts

Dieser Bericht deckt alle wesentlichen Aspekte der Planung und Spezifikation ab:

1. **Anforderungsanalyse:** Definition der Kernfunktionen und Interaktionen.
2. **Technologieintegration:** Untersuchung der Integration von Qt/QML und Qt-Wayland in Manjaro-Desktop-Umgebungen.
3. **Anwendungsarchitektur:** Entwurf der Softwarekomponenten und ihres Zusammenspiels.
4. **MCP-Spezifikation:** Detaillierte Definition des Kommunikationsprotokolls.
5. **LLM-Integration:** Strategien zur Einbindung eines LLM und Sicherstellung der MCP-Interpretierbarkeit.
6. **C++ Backend-Logik:** Details zur Implementierung der serverseitigen Logik.
7. **Sicherheitsaspekte:** Analyse potenzieller Risiken und Definition von Schutzmaßnahmen.
8. **Entwicklungs- & Testplan:** Grober Plan für Implementierung und Verifizierung.

### Zielgruppe

Dieses Dokument richtet sich an ein technisch versiertes Publikum, insbesondere an Softwarearchitekten, Systementwickler und Projektleiter, die an der Konzeption und Implementierung des beschriebenen Systems beteiligt sind. Es dient als detaillierte technische Grundlage für die Entwicklung.

## II. Anforderungsanalyse

Die erfolgreiche Entwicklung der KI-gestützten Sidebar erfordert eine klare Definition der funktionalen und nicht-funktionalen Anforderungen.

### A. Kernfunktionalität der Sidebar

- **Persistenz:** Die Sidebar muss als dauerhaftes Element der Desktop-Umgebung fungieren. Sie soll über virtuelle Desktops und Arbeitsbereiche hinweg sichtbar bleiben und eine konsistente Positionierung (z. B. am linken oder rechten Bildschirmrand) beibehalten. Dies erfordert eine tiefe Integration in die Shell-Protokolle des Wayland-Compositors, um sicherzustellen, dass die Sidebar korrekt positioniert wird und den benötigten Platz auf dem Bildschirm reserviert.
- **Benutzeroberfläche (UI):** Die UI, implementiert in QML, muss grundlegende Elemente zur Interaktion bereitstellen. Dazu gehören ein Eingabebereich für Anfragen in natürlicher Sprache, ein Ausgabebereich zur Darstellung der KI-Antworten und Ergebnisse sowie potenziell Statusindikatoren (z. B. für laufende Operationen oder Verbindungsstatus zum LLM).
- **Responsivität:** Die Benutzeroberfläche muss flüssig und reaktionsschnell sein. QML bietet hierfür die notwendigen Werkzeuge, um eine moderne und ansprechende User Experience zu gewährleisten, auch bei laufenden Hintergrundoperationen des Backends.

### B. Fähigkeiten des LLM

- **Verständnis natürlicher Sprache (NLU):** Das zugrundeliegende LLM muss in der Lage sein, Benutzeranfragen in natürlicher Sprache (initial Deutsch, mit potenzieller Erweiterbarkeit auf andere Sprachen) zu verarbeiten und deren Bedeutung zu erfassen.
- **Intentionerkennung:** Aus der Benutzeranfrage muss die Absicht (Intent) extrahiert werden. Beispiele für Intents sind das Öffnen einer Anwendung, das Abfragen von Systeminformationen oder das Ändern einer Einstellung.
- **MCP-Befehlsgenerierung:** Dies ist ein kritischer Schritt. Das LLM muss die erkannte Absicht und die extrahierten Parameter (z. B. Anwendungsname, Dateipfad, Lautstärkepegel) in einen syntaktisch und semantisch korrekten MCP-Befehl im JSON-Format übersetzen. Die Fähigkeit des LLM, dies _allein_ auf Basis der MCP-Spezifikation (Abschnitt V) zu tun, ist eine Kernanforderung.
- **Antwortinterpretation:** Das LLM muss strukturierte MCP-Antworten (JSON-Format), die vom Backend zurückkommen, verarbeiten können. Dies kann bedeuten, Fehlercodes zu interpretieren oder erfolgreiche Ergebnisdaten in eine natürlichsprachliche Antwort für den Benutzer umzuwandeln.
- **Kontextuelles Bewusstsein (Optional, aber empfohlen):** Für eine natürlichere Interaktion wäre es wünschenswert, wenn das LLM den Gesprächskontext über mehrere Anfragen hinweg beibehalten könnte. Der initiale Fokus liegt jedoch auf der Verarbeitung einzelner, in sich geschlossener Anfragen, die über MCP abgebildet werden.

### C. Umfang der Systeminteraktion

Die KI soll über das MCP eine Reihe von Systemfunktionen in Manjaro steuern können. Der initiale Satz umfasst:

- **Anwendungsmanagement:** Starten von Anwendungen (`open_application`). Das Schließen von Anwendungen ist optional und erfordert zusätzliche Überlegungen bezüglich der Prozessidentifikation und Berechtigungen.
- **Dateisystemoperationen:** Auflisten von Dateien und Verzeichnissen in einem bestimmten Pfad (`list_files`). Grundlegende Dateioperationen (Kopieren, Verschieben, Löschen) sind denkbar, erfordern jedoch eine sehr sorgfältige Sicherheitsanalyse und Implementierung (siehe Abschnitt VIII).
- **Systemeinstellungen:**
    - Abfragen allgemeiner Systeminformationen (`query_system_info`), z. B. Betriebssystemversion, CPU-/Speicherauslastung, Batteriestatus.
    - Ändern der Systemlautstärke (`change_volume`).
    - Anpassen der Bildschirmhelligkeit (`set_brightness`) über dedizierte Tools wie `brightnessctl`.1
    - Modifizieren spezifischer Desktop-Einstellungen, die über `dconf`/`gsettings` (für GNOME/GTK-basierte Umgebungen) zugänglich sind (`modify_setting_dconf`).3 Eine äquivalente Funktionalität für KDE Plasma (KConfig) muss separat betrachtet werden.
- **Paketverwaltung:** Interaktion mit dem Pamac-Kommandozeilenwerkzeug (`pamac`) zum Suchen, Installieren und Entfernen von Paketen sowie zur Update-Verwaltung (`manage_packages_pamac`). Die unterstützten Aktionen müssen klar definiert werden, basierend auf den Fähigkeiten der Pamac-CLI.8
- **Zwischenablage:** Kopieren von Text in die Zwischenablage (`clipboard_copy`) und Einfügen von Text aus der Zwischenablage (`clipboard_paste`). Unter Wayland erfordert dies spezielle Werkzeuge wie `wl-clipboard`.12

### D. Interaktionsfluss

Der typische Ablauf einer Benutzerinteraktion ist wie folgt:

1. Der Benutzer gibt eine Anfrage in natürlicher Sprache in die QML-Sidebar ein.
2. Das QML-Frontend sendet die reine Textanfrage an das C++ Backend.
3. Das Backend leitet die Anfrage an das LLM-Integrationsmodul weiter.
4. Das LLM-Modul sendet die Anfrage an das LLM (lokal oder API).
5. Das LLM analysiert die Anfrage, erkennt die Absicht und generiert einen entsprechenden MCP-Befehl im JSON-Format.
6. Das LLM (oder das LLM-Modul) sendet den MCP-Befehl (als JSON-String) zurück an das Backend.
7. Der MCP Interface Handler im Backend empfängt und validiert den MCP-Befehl gegen die Spezifikation.
8. Bei Erfolg parst der Handler den Befehl und ruft die entsprechende Funktion in der System Interaction Layer auf, wobei die Parameter übergeben werden.
9. Die System Interaction Layer führt die angeforderte Systemaktion aus (z. B. Starten eines Prozesses via `QProcess`, Senden einer DBus-Nachricht via `QDBus`).
10. Die System Interaction Layer empfängt das Ergebnis, den Status oder einen Fehler von der Systemaktion.
11. Das Backend (MCP Interface Handler) formatiert das Ergebnis in eine MCP-Antwort (JSON-Format).
12. Das Backend sendet die MCP-Antwort entweder zurück an das LLM-Modul (zur Interpretation und Umwandlung in natürliche Sprache) oder direkt an das QML-Frontend.
13. Das QML-Frontend zeigt die finale Antwort oder das Ergebnis dem Benutzer an.

### E. Zentrale Randbedingung: MCP-Verständnis

Die entscheidende Anforderung ist, dass das LLM lernen muss, das MCP _ausschließlich_ auf Basis der in Abschnitt V dieses Dokuments bereitgestellten Spezifikation zu verwenden. Es darf kein Vorwissen über MCP oder Manjaro-spezifische Interna vorausgesetzt werden, und es darf kein externer Zugriff (z. B. Internet) zur Klärung benötigt werden. Dies stellt hohe Anforderungen an die Klarheit, Vollständigkeit und Eindeutigkeit der MCP-Spezifikation.

## III. Technologieintegrationsstrategie (Qt/QML & Wayland unter Manjaro)

Die Wahl der Technologien und deren Integration ist entscheidend für die Realisierung der persistenten Sidebar und ihrer Funktionalität unter Manjaro, insbesondere im Kontext von Wayland.

### A. Qt/QML Framework

- **Begründung:** Qt (Version 6 wird für die beste Wayland-Unterstützung empfohlen) wird als primäres Framework gewählt. Es bietet leistungsstarke C++-Bibliotheken, exzellente Werkzeuge und mit QML eine deklarative Sprache zur effizienten Entwicklung moderner Benutzeroberflächen.15 Obwohl Qt plattformübergreifend ist, liegt der Fokus hier klar auf Manjaro Linux.
- **QML für das Frontend:** Die Sidebar-UI wird vollständig in QML implementiert. Dies ermöglicht eine schnelle Entwicklung, einfache Anpassung des Erscheinungsbilds und die Nutzung von Qt Quick Controls für Standard-UI-Elemente.17 Die Logik im QML-Teil wird minimal gehalten und konzentriert sich auf die Präsentation und die Weiterleitung von Benutzeraktionen an das C++ Backend.
- **C++ für das Backend:** Die Kernlogik der Anwendung, die Kommunikation mit dem LLM, die Verarbeitung von MCP-Nachrichten und die gesamte Systeminteraktion werden in C++ implementiert. Dies gewährleistet die notwendige Performance, Robustheit und den Zugriff auf systemnahe APIs und Bibliotheken.16

### B. Wayland-Integration

- **Qt-Wayland Modul:** Die Basis für den Betrieb der Qt-Anwendung als nativer Wayland-Client bildet das `qt6-wayland` Paket.21 Dieses Modul stellt die notwendige Abstraktionsebene für die Kommunikation mit dem Wayland-Compositor bereit.
- **Implementierung der persistenten Sidebar:**
    - **Kernprotokoll:** Das `wlr-layer-shell-unstable-v1` Protokoll ist der De-facto-Standard für die Erstellung von Desktop-Shell-Komponenten wie Panels, Docks und Sidebars unter Wayland-Compositors, die dieses Protokoll unterstützen.22 Dazu gehören Compositors, die auf `wlroots` basieren (z. B. Sway) und auch KWin (KDE Plasma).
    - **Wichtige `wlr-layer-shell` Merkmale 22:**
        - _Anchoring (Verankerung):_ Erlaubt das Festlegen der Sidebar an einem oder mehreren Bildschirmrändern (z. B. `left` oder `right`, optional auch `top` und `bottom` für volle Höhe).
        - _Layering (Ebenen):_ Weist die Sidebar einer bestimmten Ebene zu (z. B. `top` oder `overlay`), um ihre Sichtbarkeit relativ zu anderen Anwendungsfenstern zu steuern.
        - _Exclusive Zone (Exklusivbereich):_ Ermöglicht der Sidebar, einen Bereich des Bildschirms für sich zu reservieren, sodass maximierte Fenster diesen Bereich nicht überlappen. Dies ist entscheidend für eine persistente Sidebar.
        - _Keyboard Interactivity (Tastaturinteraktivität):_ Steuert, ob und wie die Sidebar Tastatureingaben empfangen kann. Der Modus `on_demand` ist typischerweise für interaktive Elemente wie eine Sidebar geeignet, die Texteingaben ermöglichen soll.
    - **Qt-Integrationsbibliothek:** Um die Nutzung von `wlr-layer-shell` aus einer Qt-Anwendung heraus zu vereinfachen, wird die Verwendung der `layer-shell-qt` Bibliothek empfohlen.23 Diese Bibliothek, ein KDE-Projekt, stellt die Klasse `LayerShellQt::Window` bereit, mit der die spezifischen Eigenschaften einer Layer-Shell-Oberfläche (Layer, Anker, Exklusivzone etc.) für ein `QWindow` verwaltet werden können. Die Verwendung dieser Bibliothek ist deutlich einfacher als die direkte Interaktion mit Wayland-Protokollen über die Qt Wayland Compositor APIs 24, welche primär für die Entwicklung von Compositors selbst gedacht sind.
    - **Technische Abwägung:** Die Analyse der verfügbaren Technologien 22 zeigt klar, dass `wlr-layer-shell` das geeignete Protokoll für die geforderte persistente Sidebar ist. Die Existenz von `layer-shell-qt` als dedizierte Client-Bibliothek für Qt vereinfacht die Implementierung erheblich. Daher ist dies der bevorzugte Ansatz.

### C. Kompatibilität mit Desktop-Umgebungen (Manjaro)

Die nahtlose Integration der Sidebar hängt stark von der verwendeten Desktop-Umgebung und deren Wayland-Unterstützung ab.

- **KDE Plasma:**
    - **Compositor:** KWin ist der Wayland-Compositor von Plasma.26 KWin's Wayland-Unterstützung gilt als ausgereift 27 und unterstützt das `wlr-layer-shell` Protokoll.
    - **Integration:** Da `layer-shell-qt` ein KDE-Projekt ist 23 und KWin das zugrundeliegende Protokoll unterstützt, ist eine gute Kompatibilität und eine vergleichsweise reibungslose Integration zu erwarten. Die Wayland-spezifische Integration in Qt-Anwendungen wird durch Komponenten wie `kwayland-integration` (für Qt5) bzw. dessen Nachfolger in `kwindowsystem` (für Qt6) unterstützt.29
    - **Strategische Implikation:** KDE Plasma stellt aufgrund der technologischen Nähe (Qt) und der Unterstützung des Schlüsselprotokolls (`wlr-layer-shell`) durch KWin den wahrscheinlichsten Pfad für eine erfolgreiche und vollständige Implementierung der Sidebar dar. Die Entwicklung sollte initial auf Plasma abzielen.
- **GNOME:**
    - **Compositor:** Mutter ist der Wayland-Compositor für GNOME.21
    - **Integrationsherausforderungen:** Mutter unterstützt das `wlr-layer-shell` Protokoll _nicht_ nativ.21 GNOME verwendet eigene Mechanismen für Panels und Docks, die oft als GNOME Shell Extensions implementiert sind. Historisch gab es Kompatibilitätsprobleme zwischen Mutter und Nicht-GTK-Wayland-Anwendungen 32, und Regressionen mit QtWayland wurden beobachtet.33 Zudem fehlt Mutter unter Wayland die Unterstützung für Server-Side Decorations (SSD), was das Erscheinungsbild von Qt-Anwendungen beeinflussen kann, da diese dann Client-Side Decorations (CSD) zeichnen müssen.31
    - **Mögliche Lösungsansätze:**
        1. _GNOME Shell Extension:_ Entwicklung einer separaten Erweiterung, die die QML-Sidebar hostet oder mit ihr interagiert. Dies ist komplex und erfordert Kenntnisse in JavaScript/GJS und der GNOME Shell Extension API.
        2. _Standard-Fenster:_ Ausführung der Sidebar als reguläres Wayland-Fenster. Die Persistenz, Positionierung und das Reservieren von Platz müssten programmatisch (und potenziell unzuverlässig) über Standard-Wayland-Fensterverwaltung versucht werden.
        3. _Abwarten auf Mutter-Entwicklung:_ Beobachten, ob zukünftige Mutter-Versionen relevante Protokolle unterstützen.30 Dies ist kurzfristig unwahrscheinlich für `wlr-layer-shell`.
    - **Strategische Implikation:** Die Integration in GNOME stellt eine erhebliche Herausforderung dar. Ohne `wlr-layer-shell`-Unterstützung 21 wird die Sidebar wahrscheinlich nicht die gewünschte Persistenz und Platzreservierung erreichen, es sei denn, es wird erheblicher Zusatzaufwand betrieben (z. B. Extension-Entwicklung). Es muss akzeptiert werden, dass die Funktionalität unter GNOME möglicherweise eingeschränkt ist oder eine abweichende Implementierungsstrategie erfordert.
- **XFCE:**
    - **Wayland-Status:** Die Umstellung von XFCE auf Wayland ist ein laufender Prozess. Standardmäßig könnte Manjaro XFCE noch X11 verwenden, wo Persistenz über Fenstermanager-Hints realisiert wird. Wenn XFCE unter Wayland läuft (z. B. über `xfce4-session-wayland`), hängt die Unterstützung für `wlr-layer-shell` vom verwendeten Compositor ab. Viele Wayland-Implementierungen für XFCE setzen auf `wlroots`-basierte Compositors, die `wlr-layer-shell` unterstützen.
    - **Strategische Implikation:** Die Kompatibilität hängt vom Compositor ab. Bei Verwendung eines `wlroots`-basierten Compositors ist der `layer-shell-qt`-Ansatz gangbar. Unter X11 wären traditionelle Xlib-Methoden nötig. Der Fokus sollte zunächst auf den primären Wayland-DEs Plasma und GNOME liegen.

### D. Mechanismen zur Systeminteraktion

Das C++ Backend wird verschiedene Mechanismen nutzen, um mit dem Manjaro-System zu interagieren:

- **`QProcess`:** Zum Ausführen von Kommandozeilenwerkzeugen und Skripten. Dies ist der primäre Mechanismus für Interaktionen mit `pamac` 8, `brightnessctl` 1, `wl-clipboard` (`wl-copy`/`wl-paste`) 12 und `gsettings`.4 Erfordert sorgfältige Handhabung von Argumenten, Parsing der Ausgabe (stdout/stderr) und strikte Sicherheitsvorkehrungen (siehe Abschnitte VII und VIII).34
- **`QDBus`:** Zur Kommunikation mit Systemdiensten und Desktop-Daemons, die eine DBus-Schnittstelle anbieten.39 Anwendungsfälle sind z. B. die Steuerung der Lautstärke (über PulseAudio/PipeWire), das Senden von Benachrichtigungen oder die Interaktion mit Energieverwaltungsdiensten (z. B. `org.gnome.SettingsDaemon.Power` 44 oder KDE-Äquivalente).
- **`dconf`/`gsettings`:** Zum Lesen und Schreiben von Konfigurationseinstellungen von GNOME/GTK-Anwendungen, die in der dconf-Datenbank gespeichert sind. Der Zugriff erfolgt am sichersten über das `gsettings`-Kommandozeilenwerkzeug (via `QProcess`), da dieses Schema-Validierungen durchführt.3 Für KDE-Einstellungen (KConfig) sind andere Mechanismen erforderlich (wahrscheinlich DBus oder direkte Konfigurationsdatei-Interaktion).
- **Direkter Datei-/API-Zugriff:** Für spezifische Low-Level-Informationen, wie z. B. das Lesen von Helligkeitswerten aus `/sys/class/backlight/` 2, obwohl die Verwendung von `brightnessctl` vorzuziehen ist. Erfordert sorgfältige Prüfung der Berechtigungen und Fehlerbehandlung.

## IV. Anwendungsarchitektur

Die Architektur der Anwendung folgt bewährten Praktiken für Qt/QML-Anwendungen und trennt klar zwischen Benutzeroberfläche, Anwendungslogik, LLM-Interaktion und Systeminteraktion.16

### A. Überblick

Die Architektur ist modular aufgebaut:

Code-Snippet

```
graph LR
    subgraph User Interface
        A
    end
    subgraph Backend (C++)
        B[Core Application Logic]
        C[LLM Integration Module]
        D[MCP Interface Handler]
        E
    end
    subgraph External Systems
        F
        G
    end

    A -- User Input --> B
    B -- Query --> C
    C -- Query --> F
    F -- MCP Command (JSON) --> C
    C -- MCP Command (JSON) --> D
    D -- Parsed Command --> E
    E -- System Call --> G
    G -- System Result/Error --> E
    E -- Result/Error --> D
    D -- MCP Response (JSON) --> B
    B -- Response Data/Formatted Response --> A
    A -- Display Output --> User

    D -- Validation Failure --> B  // Error path
```

_Diagramm-Beschreibung:_ Das Diagramm zeigt die Hauptkomponenten: QML Frontend, C++ Backend (unterteilt in Kernlogik, LLM-Modul, MCP-Handler, Systeminteraktionsschicht), LLM Service und Manjaro System. Pfeile illustrieren den Datenfluss von der Benutzereingabe über die Verarbeitung im Backend und LLM bis zur Systemaktion und der finalen Ausgabe.

### B. QML Frontend (Sidebar UI)

- **Verantwortlichkeiten:** Rendern der Sidebar-Oberfläche, Erfassen der Benutzereingabe (Text), Anzeigen von KI-Antworten und Statusinformationen, Handhabung von UI-Animationen und Übergängen.
- **Implementierung:** Hauptsächlich deklaratives QML, eventuell unter Verwendung von Qt Quick Controls für Standardelemente.17 Die Logik beschränkt sich auf Präsentationsaspekte und die Delegation von Aktionen an das C++ Backend.
- **Kommunikation:** Interagiert mit dem C++ Backend über Qt's Signal-Slot-Mechanismus und durch Zugriff auf C++-Objekte und deren Eigenschaften (`Q_PROPERTY`), die dem QML-Kontext bekannt gemacht werden.19

### C. C++ Backend

Das Backend ist das Herzstück der Anwendung und beherbergt die Kernlogik und die Schnittstellen zu externen Systemen.

- **1. Core Application Logic:**
    - Verwaltet den globalen Zustand der Anwendung.
    - Orchestriert die Kommunikation zwischen dem Frontend, dem LLM-Modul und der Systeminteraktionsschicht.
    - Initialisiert die Anwendung und macht die notwendigen C++-Objekte (insbesondere den MCP Interface Handler oder ein übergeordnetes Controller-Objekt) dem QML-Kontext zugänglich, z. B. über `QQmlContext::setContextProperty()`.19
- **2. LLM Integration Module:**
    - **Verantwortlichkeiten:** Kapselt die gesamte Logik für die Kommunikation mit dem ausgewählten LLM (ob lokal oder über eine API). Sendet die Benutzeranfragen (als Text) an das LLM und empfängt die generierten MCP-Befehle (als JSON-String). Optional kann es auch MCP-Antworten vom Backend an das LLM senden, um diese in natürliche Sprache formatieren zu lassen.
    - **Schnittstelle:** Definiert eine klare C++-Schnittstelle (z. B. eine Klasse mit Signalen und Slots) für das Senden von Anfragen und das Empfangen von strukturierten MCP-Befehls-Strings.
- **3. MCP Interface Handler:**
    - **Verantwortlichkeiten:** Nimmt die MCP-Befehls-JSON-Strings vom LLM-Modul entgegen. Validiert die JSON-Struktur und die Syntax des Befehls rigoros gegen die MCP-Spezifikation (Abschnitt V). Parst valide Befehle und leitet sie an die System Interaction Layer weiter. Empfängt strukturierte Ergebnisse oder Fehler von der System Interaction Layer und formatiert diese in MCP-Antwort-JSON-Strings.
    - **Implementierung:** Eine C++-Klasse, die JSON-Parsing (z. B. mit `QJsonDocument`, `QJsonObject`, `QJsonArray`) und die gesamte Validierungslogik gemäß der MCP-Spezifikation implementiert.
- **4. System Interaction Layer:**
    - **Verantwortlichkeiten:** Führt die konkreten Systemaktionen aus, die durch die geparsten MCP-Befehle spezifiziert wurden. Interagiert mit dem Manjaro-System über die geeigneten Mechanismen (`QProcess`, `QDBus`, `gsettings`-Aufrufe, Dateisystemzugriffe etc.). Kapselt die Details der jeweiligen Systeminteraktion, behandelt Fehler auf Systemebene und liefert standardisierte Ergebnisse oder Fehlercodes an den MCP Interface Handler zurück.
    - **Implementierung:** Modulare Struktur mit separaten C++-Klassen oder Funktionsgruppen für jeden Interaktionstyp (z. B. `PamacManager`, `SettingsManager`, `ProcessRunner`, `ClipboardManager`, `DBusInterface`). Diese Schicht abstrahiert die Komplexität der Systemaufrufe vom Rest des Backends.

### D. Best Practices für die Architektur

- **Trennung der Belange (Separation of Concerns):** Strikte Trennung zwischen der UI-Logik (QML) und der Backend-/Geschäftslogik (C++).16 Das QML-Frontend sollte "dumm" sein und nur Daten anzeigen und Benutzerereignisse weiterleiten.
- **Model-View(-Controller/Delegate):** Anwendung von MVC-, MVVM- oder ähnlichen Mustern, wo immer Daten aus dem Backend in der UI dargestellt werden. C++-Datenmodelle (abgeleitet von `QAbstractListModel` etc.) oder Kontext-Properties (`Q_PROPERTY`) werden dem QML-Frontend zur Verfügung gestellt.19 Änderungen im Backend werden über Signale an das Frontend gemeldet, das sich daraufhin aktualisiert.
- **Asynchrone Operationen:** Alle potenziell blockierenden Operationen – insbesondere Netzwerkaufrufe zum LLM, das Starten und Warten auf externe Prozesse mit `QProcess` 34 und DBus-Aufrufe – müssen asynchron implementiert werden, um ein Einfrieren der Benutzeroberfläche zu verhindern. Qt's Signal-Slot-Mechanismus ist hierfür das zentrale Werkzeug.

## V. Manjaro Control Protocol (MCP) Spezifikation

Das Manjaro Control Protocol (MCP) ist die definierte Schnittstelle, über die das LLM Systemaktionen anfordert und Ergebnisse empfängt. Die folgende Spezifikation ist darauf ausgelegt, von einem LLM ohne externes Wissen verstanden zu werden.

### A. Zweck und Designziele

- **Zweck:** Bereitstellung einer standardisierten, eindeutigen und maschinenlesbaren Schnittstelle, die es einer KI/einem LLM ermöglicht, spezifische Systemaktionen unter Manjaro Linux anzufordern und strukturierte Ergebnisse zu erhalten.
- **LLM-Interpretierbarkeit:** Explizit entworfen, um von einem LLM _allein_ auf Basis dieser Spezifikation verstanden und genutzt zu werden. Dies erfordert höchste Klarheit, explizite Definitionen aller Elemente und eine in sich geschlossene Beschreibung.
- **Plattformspezifität:** Zugeschnitten auf Manjaro Linux, unter Berücksichtigung spezifischer Werkzeuge (`pamac`), Konfigurationsmechanismen (`dconf`/`gsettings`) und Systempfade/Dienste.
- **Erweiterbarkeit:** Die Struktur (JSON-basiert, klare Befehlsdefinition) ermöglicht die zukünftige Ergänzung neuer Befehle, ohne die bestehende Struktur zu brechen.
- **Sicherheit:** Das Format unterstützt die Validierung und Bereinigung von Befehlen und Parametern durch das Backend, bevor eine Ausführung stattfindet.

### B. Nachrichtenformat

- **Transport:** JSON-Objekte werden sowohl für Anfragen (LLM -> Backend) als auch für Antworten (Backend -> LLM/Frontend) verwendet.
    
- **Anfragestruktur (Request):**
    
    JSON
    
    ```
    {
      "mcp_version": "1.0",
      "request_id": "string",
      "command": "string",
      "parameters": {
        "param1_name": "value1", // Typ: string | integer | boolean | array[string] | object
        "param2_name": "value2",
        //... weitere Parameter
      }
    }
    ```
    
    - `mcp_version` (string, erforderlich): Die Version des MCP-Protokolls, die verwendet wird (z. B. "1.0"). Dies ermöglicht zukünftige Versionierung.
    - `request_id` (string, erforderlich): Ein eindeutiger Identifikator für diese spezifische Anfrage, generiert vom anfragenden System (LLM-Modul). Wird verwendet, um Antworten der entsprechenden Anfrage zuzuordnen.
    - `command` (string, erforderlich): Der Name der auszuführenden Aktion (z. B. `open_application`, `query_system_info`). Muss exakt einem der im Core Command Set definierten Befehle entsprechen.
    - `parameters` (object, erforderlich): Ein JSON-Objekt, das die für den spezifischen `command` benötigten Parameter als Schlüssel-Wert-Paare enthält. Die Namen, Datentypen (string, integer, boolean, array von strings, etc.) und die Erforderlichkeit (required: true/false) jedes Parameters sind für jeden Befehl streng definiert (siehe Core Command Set).
- **Antwortstruktur (Response):**
    
    JSON
    
    ```
    {
      "mcp_version": "1.0",
      "request_id": "string",
      "status": "string", // "success" oder "error"
      "data": {... }, // Optional: Nur bei status="success"
      "error": {         // Optional: Nur bei status="error"
        "code": "string",
        "message": "string"
      }
    }
    ```
    
    - `mcp_version` (string, erforderlich): Die Version des MCP-Protokolls (z. B. "1.0").
    - `request_id` (string, erforderlich): Der eindeutige Identifikator aus der korrespondierenden Anfrage.
    - `status` (string, erforderlich): Gibt an, ob die Ausführung des Befehls erfolgreich war (`"success"`) oder fehlgeschlagen ist (`"error"`).
    - `data` (object, optional): Ein JSON-Objekt, das die Ergebnisse des Befehls enthält, falls `status` `"success"` ist. Die Struktur dieses Objekts hängt vom ausgeführten Befehl ab (z. B. eine Liste von Dateien, abgefragte Systeminformationen, eine Bestätigungsnachricht). Dieses Feld ist nur vorhanden, wenn `status` `"success"` ist.
    - `error` (object, optional): Ein JSON-Objekt, das nur vorhanden ist, wenn `status` `"error"` ist.
        - `code` (string, erforderlich): Ein vordefinierter Fehlercode-String, der die Art des Fehlers klassifiziert (z. B. `INVALID_COMMAND`, `PERMISSION_DENIED`, `EXECUTION_FAILED`, `TIMEOUT`, `INVALID_PARAMETER`). Eine Liste der Standard-Fehlercodes befindet sich am Ende dieses Abschnitts.
        - `message` (string, erforderlich): Eine menschenlesbare Beschreibung des Fehlers, primär für Logging- und Debugging-Zwecke. Diese Nachricht sollte vom LLM interpretiert werden, bevor sie dem Endbenutzer angezeigt wird.

### C. Definition des Kernbefehlssatzes (Core Command Set)

Die folgende Tabelle definiert die initialen Befehle, die das MCP unterstützt. Das LLM muss in der Lage sein, aus natürlicher Sprache auf diese Befehle zu schließen und die Anfragen gemäß den hier definierten Parametern zu strukturieren.

**Tabelle: MCP Core Commands (Version 1.0)**

|   |   |   |   |   |
|---|---|---|---|---|
|**Command Name (string)**|**Description**|**Parameters (object: {name: {type, required, description}})**|**Success Data Structure (object)**|**Potential Error Codes (array[string])**|
|`open_application`|Startet eine Desktop-Anwendung.|`{"name": {"type": "string", "required": true, "description": "Name oder ausführbarer Pfad der Anwendung (z.B. 'firefox', '/usr/bin/gimp')."}}`|`{"pid": {"type": "integer", "description": "Prozess-ID der gestarteten Anwendung (optional, falls ermittelbar)"}, "message": {"type": "string", "description": "Bestätigungsnachricht, z.B. 'Anwendung [Name] gestartet.'"}}`|`EXECUTION_FAILED`, `APP_NOT_FOUND`, `INVALID_PARAMETER`|
|`list_files`|Listet Dateien und Verzeichnisse in einem Pfad auf.|`{"path": {"type": "string", "required": true, "description": "Absoluter Pfad zum Verzeichnis (muss mit '/' beginnen). Symbolische Links werden nicht aufgelöst."}}`|`{"path": {"type": "string", "description": "Der abgefragte Pfad"}, "entries": {"type": "array", "items": {"type": "object", "properties": {"name": {"type": "string"}, "type": {"type": "string", "enum": ["file", "directory"]}, "size_bytes": {"type": "integer", "description": "Dateigröße in Bytes (nur für Typ 'file')"}}}}, "description": "Liste der Einträge im Verzeichnis."}}`|`PATH_NOT_FOUND`, `PERMISSION_DENIED`, `INVALID_PARAMETER`, `FILESYSTEM_ERROR`|
|`change_volume`|Stellt die Systemlautstärke ein oder passt sie an.|`{"level": {"type": "integer", "required": false, "description": "Absoluter Lautstärkepegel in Prozent (0-100)."}, "change": {"type": "integer", "required": false, "description": "Relative Änderung in Prozentpunkten (+/-). 'level' und 'change' schließen sich gegenseitig aus."}}`|`{"new_level": {"type": "integer", "description": "Der resultierende Lautstärkepegel in Prozent (0-100)."}}`|`INVALID_PARAMETER`, `EXECUTION_FAILED`, `DBUS_ERROR` (falls DBus verwendet)|
|`query_system_info`|Ruft spezifische Systeminformationen ab.|`{"query": {"type": "string", "required": true, "description": "Art der angeforderten Information. Gültige Werte: 'os_version', 'hostname', 'cpu_usage' (als Prozentwert), 'memory_total_mb', 'memory_available_mb', 'memory_usage' (als Prozentwert), 'battery_status' (als Objekt mit 'percentage', 'charging_status' [boolean]), 'uptime_seconds'."}}`|`{"query": {"type": "string", "description": "Die gestellte Abfrage"}, "value": {"type": "string|integer|
|`manage_packages_pamac`|Interagiert mit dem Pamac CLI zur Paketverwaltung.9|`{"action": {"type": "string", "required": true, "enum": ["search", "install", "remove", "update_check", "update_all", "list_installed", "list_orphans", "remove_orphans"], "description": "Die auszuführende Pamac-Aktion."}, "package_name": {"type": "string", "required": false, "description": "Ziel-Paketname (erforderlich für 'install', 'remove', 'search')."}, "include_aur": {"type": "boolean", "required": false, "default": false, "description": "AUR in die Aktion einbeziehen ('search', 'update_check', 'update_all')."}}`|Hängt von `action` ab: `search`: `{"results": array[{"name": string, "version": string, "repository": string, "description": string}]}`. `install`/`remove`: `{"message": string}`. `update_check`: `{"updates_available": boolean, "packages": array[string]}`. `update_all`: `{"message": string}`. `list_installed`/`list_orphans`: `{"packages": array[string]}`. `remove_orphans`: `{"message": string}`.|`PAMAC_ERROR`, `INVALID_ACTION`, `INVALID_PARAMETER`, `PACKAGE_NOT_FOUND`, `PERMISSION_DENIED`, `EXECUTION_FAILED`|
|`modify_setting_dconf`|Ändert eine dconf-Einstellung (primär für GNOME/GTK) via `gsettings`.4|`{"schema": {"type": "string", "required": true, "description": "Das GSettings-Schema (z.B. 'org.gnome.desktop.interface')."}, "key": {"type": "string", "required": true, "description": "Der Schlüssel innerhalb des Schemas (z.B. 'gtk-theme')."}, "value": {"type": "string|integer|boolean", "required": true, "description": "Der neue Wert für den Schlüssel. Muss dem Typ des Schlüssels im Schema entsprechen."}}`|
|`set_brightness`|Passt die Bildschirmhelligkeit an via `brightnessctl`.1|`{"level": {"type": "integer", "required": true, "description": "Absoluter Helligkeitspegel in Prozent (0-100)."}}`|`{"new_level": {"type": "integer", "description": "Der resultierende Helligkeitspegel in Prozent (0-100)."}}`|`INVALID_PARAMETER`, `EXECUTION_FAILED`, `BRIGHTNESS_CONTROL_ERROR`|
|`clipboard_copy`|Kopiert Text in die System-Zwischenablage via `wl-copy`.12|`{"text": {"type": "string", "required": true, "description": "Der zu kopierende Text."}}`|`{"message": {"type": "string", "description": "Text erfolgreich kopiert."}}`|`EXECUTION_FAILED`, `CLIPBOARD_ERROR`|
|`clipboard_paste`|Ruft Text aus der System-Zwischenablage ab via `wl-paste`.12|`{}` (Keine Parameter benötigt)|`{"text": {"type": "string", "description": "Der Text aus der Zwischenablage."}}`|`EXECUTION_FAILED`, `CLIPBOARD_EMPTY`, `CLIPBOARD_ERROR`|

_Anmerkung zur LLM-Interpretierbarkeit:_ Die `description`-Felder in der Tabelle sind entscheidend. Sie liefern dem LLM den notwendigen Kontext, um die Parameter korrekt zu interpretieren und zu befüllen (z. B. was unter `os_version` bei `query_system_info` zu verstehen ist oder welche Werte für `action` bei `manage_packages_pamac` gültig sind). Die `enum`-Angabe bei `action` und `type` (in `list_files`) schränkt die möglichen Werte explizit ein.

### D. Kommunikationsfluss

1. **Anfragegenerierung:** Das LLM empfängt die natürlichsprachliche Anfrage des Benutzers, analysiert sie und identifiziert den passenden MCP-Befehl sowie die erforderlichen Parameter gemäß der obigen Tabelle. Es konstruiert das MCP Request JSON-Objekt, inklusive einer eindeutigen `request_id`.
2. **Anfrageübermittlung:** Das LLM-Modul sendet den JSON-String an den MCP Interface Handler im C++ Backend.
3. **Validierung im Backend:** Der MCP Interface Handler parst den JSON-String. Er überprüft die `mcp_version`, die Gültigkeit des `command`-Namens und ob alle erforderlichen `parameters` vorhanden sind und den korrekten Datentyp haben. Bei Fehlern wird sofort eine MCP Error Response generiert und zurückgesendet.
4. **Dispatching:** Bei erfolgreicher Validierung ruft der MCP Interface Handler die zuständige Methode in der System Interaction Layer auf und übergibt die extrahierten und validierten Parameter.
5. **Systemaktion:** Die System Interaction Layer führt die Aktion aus (z. B. Starten eines `QProcess`, Senden einer `QDBus`-Nachricht). Dies geschieht asynchron.
6. **Ergebnisverarbeitung:** Nach Abschluss der Systemaktion (erfolgreich oder fehlerhaft) meldet die System Interaction Layer das Ergebnis (Daten oder Fehlercode/-nachricht) an den MCP Interface Handler zurück.
7. **Antwortgenerierung:** Der MCP Interface Handler konstruiert das MCP Response JSON-Objekt. Er füllt `request_id` (aus der Anfrage), `status` (`success` oder `error`) und entweder das `data`-Objekt (bei Erfolg) oder das `error`-Objekt (bei Fehler) gemäß der Spezifikation.
8. **Antwortübermittlung:** Der JSON-String der Antwort wird zurück an das LLM-Modul oder direkt an das Frontend gesendet.

### E. Konkrete Beispiele (Request/Response Paare)

- **Beispiel 1: Firefox starten**
    - Request:
        
        JSON
        
        ```
        {
          "mcp_version": "1.0",
          "request_id": "req-123",
          "command": "open_application",
          "parameters": {
            "name": "firefox"
          }
        }
        ```
        
    - Response (Success):
        
        JSON
        
        ```
        {
          "mcp_version": "1.0",
          "request_id": "req-123",
          "status": "success",
          "data": {
            "pid": 12345,
            "message": "Anwendung firefox gestartet."
          }
        }
        ```
        
- **Beispiel 2: Dateien im Home-Verzeichnis auflisten**
    - Request:
        
        JSON
        
        ```
        {
          "mcp_version": "1.0",
          "request_id": "req-124",
          "command": "list_files",
          "parameters": {
            "path": "/home/user"
          }
        }
        ```
        
    - Response (Success):
        
        JSON
        
        ```
        {
          "mcp_version": "1.0",
          "request_id": "req-124",
          "status": "success",
          "data": {
            "path": "/home/user",
            "entries": [
              {"name": "Documents", "type": "directory"},
              {"name": "image.jpg", "type": "file", "size_bytes": 102400},
              {"name": ".bashrc", "type": "file", "size_bytes": 3500}
            ]
          }
        }
        ```
        
- **Beispiel 3: Pamac nach 'gimp' durchsuchen (inkl. AUR)**
    - Request:
        
        JSON
        
        ```
        {
          "mcp_version": "1.0",
          "request_id": "req-125",
          "command": "manage_packages_pamac",
          "parameters": {
            "action": "search",
            "package_name": "gimp",
            "include_aur": true
          }
        }
        ```
        
    - Response (Success):
        
        JSON
        
        ```
        {
          "mcp_version": "1.0",
          "request_id": "req-125",
          "status": "success",
          "data": {
            "results":
          }
        }
        ```
        
- **Beispiel 4: Helligkeit auf 75% setzen**
    - Request:
        
        JSON
        
        ```
        {
          "mcp_version": "1.0",
          "request_id": "req-126",
          "command": "set_brightness",
          "parameters": {
            "level": 75
          }
        }
        ```
        
    - Response (Success):
        
        JSON
        
        ```
        {
          "mcp_version": "1.0",
          "request_id": "req-126",
          "status": "success",
          "data": {
            "new_level": 75
          }
        }
        ```
        
- **Beispiel 5: Fehler beim Installieren eines nicht existierenden Pakets**
    - Request:
        
        JSON
        
        ```
        {
          "mcp_version": "1.0",
          "request_id": "req-127",
          "command": "manage_packages_pamac",
          "parameters": {
            "action": "install",
            "package_name": "nonexistent_package_xyz"
          }
        }
        ```
        
    - Response (Error):
        
        JSON
        
        ```
        {
          "mcp_version": "1.0",
          "request_id": "req-127",
          "status": "error",
          "error": {
            "code": "PACKAGE_NOT_FOUND",
            "message": "Pamac Fehler: Ziel nicht gefunden: nonexistent_package_xyz"
          }
        }
        ```
        

### F. Fehlerbehandlung und Fehlercodes

Eine robuste Fehlerbehandlung ist essenziell. Das Backend muss Fehler auf verschiedenen Ebenen abfangen und in standardisierte MCP-Fehlercodes übersetzen.

- **Standard-Fehlercodes:**
    - `INVALID_COMMAND`: Der angegebene `command` ist nicht im MCP definiert.
    - `INVALID_PARAMETER`: Ein oder mehrere Parameter sind ungültig (falscher Typ, fehlender erforderlicher Parameter, ungültiger Wert, z. B. Pfad existiert nicht, wo erwartet).
    - `PERMISSION_DENIED`: Die Aktion erfordert höhere Berechtigungen, die der Backend-Prozess nicht hat.
    - `EXECUTION_FAILED`: Ein externer Prozess (`QProcess`) konnte nicht gestartet werden oder ist mit einem Fehler abgestürzt.
    - `TIMEOUT`: Eine Operation hat das Zeitlimit überschritten.
    - `APP_NOT_FOUND`: Die zu startende Anwendung wurde nicht gefunden.
    - `PATH_NOT_FOUND`: Ein angegebener Datei- oder Verzeichnispfad existiert nicht.
    - `FILESYSTEM_ERROR`: Allgemeiner Fehler bei Dateisystemoperationen.
    - `DBUS_ERROR`: Fehler bei der Kommunikation über DBus.
    - `PAMAC_ERROR`: Spezifischer Fehler bei der Interaktion mit Pamac CLI.
    - `GSETTINGS_ERROR`: Spezifischer Fehler bei der Interaktion mit `gsettings` CLI.
    - `BRIGHTNESS_CONTROL_ERROR`: Spezifischer Fehler bei der Helligkeitssteuerung.
    - `CLIPBOARD_ERROR`: Allgemeiner Fehler bei der Interaktion mit der Zwischenablage.
    - `CLIPBOARD_EMPTY`: Versuch, aus einer leeren Zwischenablage zu lesen.
    - `INVALID_QUERY`: Der Wert für `query` in `query_system_info` ist ungültig.
    - `FAILED_TO_RETRIEVE`: Konnte die angeforderten Informationen nicht abrufen (`query_system_info`).
    - `LLM_ERROR`: Fehler bei der Kommunikation mit dem LLM oder bei der Verarbeitung durch das LLM.
    - `BACKEND_ERROR`: Interner Fehler im C++ Backend.
    - `UNKNOWN_ERROR`: Ein nicht klassifizierter Fehler ist aufgetreten.
- **Fehlermeldungen (`message`):** Sollten präzise genug für Entwickler-Debugging sein (z. B. die exakte Fehlermeldung von `stderr` eines `QProcess`), aber nicht unbedingt für die direkte Anzeige an den Benutzer gedacht. Das LLM kann beauftragt werden, diese technischen Meldungen in eine benutzerfreundlichere Form zu übersetzen.

## VI. LLM-Integrationsplan

Die Integration des Large Language Models (LLM) ist der Schlüssel zur Übersetzung natürlicher Sprache in MCP-Befehle und zur Interpretation der Ergebnisse. Die Strategie muss die Kernanforderung berücksichtigen, dass das LLM das MCP allein durch die Spezifikation in diesem Bericht verstehen muss.

### A. LLM-Auswahlkriterien

Die Wahl des geeigneten LLM hängt von mehreren Faktoren ab:

- **Function Calling / Strukturierte Ausgabe:** Dies ist das wichtigste Kriterium. Das LLM muss zuverlässig strukturierte Ausgaben, idealerweise im JSON-Format, generieren können, die exakt der MCP-Spezifikation entsprechen. Modelle mit expliziter "Function Calling" oder "Tool Calling" Fähigkeit sind zu bevorzugen.45 Benchmarks wie BFCL (Berkeley Function-Calling Leaderboard) 49 und APIBank 50 können bei der Bewertung helfen. Aktuelle Kandidaten sind Cloud-Modelle wie GPT-4o, Claude 3.5 Sonnet, Gemini 1.5 Flash 46 oder potenziell leistungsfähige lokale Modelle (z. B. Llama 3, Mistral, Qwen), die entweder speziell für Tool Use feinabgestimmt wurden oder deren Ausgabe durch Techniken wie Constrained Generation 53 auf das korrekte JSON-Format gezwungen wird. Die Pythonic-Ansätze 57 sind hier weniger relevant, da MCP auf JSON basiert.
- **Lokal vs. API:**
    - _API-basiert (z. B. OpenAI, Anthropic):_ Bietet oft höhere Genauigkeit und einfachere initiale Einrichtung der Function Calling-Fähigkeit.45 Nachteile sind die Abhängigkeit von einer Internetverbindung, laufende Kosten und potenzielle Datenschutzbedenken, da Benutzeranfragen an einen externen Dienst gesendet werden.
    - _Lokal (z. B. Ollama + Llama 3, llama.cpp + Mistral):_ Bietet maximale Privatsphäre, Offline-Fähigkeit und keine direkten API-Kosten.52 Erfordert jedoch signifikante lokale Hardware-Ressourcen (CPU, RAM, VRAM) und die Implementierung robuster Mechanismen zur Erzeugung strukturierter Ausgaben (Constrained Generation), da die Genauigkeit bei der reinen Befolgung von Formatierungsanweisungen im Prompt geringer sein kann als bei spezialisierten APIs.56
- **Leistung (Latenz/Genauigkeit):** Die Antwortzeit des LLM (Latenz) und die Genauigkeit bei der Generierung korrekter MCP-Befehle müssen gegeneinander abgewogen werden.58 Zu hohe Latenz beeinträchtigt die Benutzererfahrung.
- **Kosten:** API-Nutzungsgebühren oder die Anschaffungs- und Betriebskosten für die Hardware zum lokalen Betrieb müssen berücksichtigt werden.

### B. Integrationsstrategie

Die Integration erfolgt im LLM Integration Module des C++ Backends.

- **Prompt Engineering:** Ein sorgfältig gestalteter System-Prompt ist unerlässlich. Er muss dem LLM seine Rolle als Manjaro-Assistent erklären, die verfügbaren "Werkzeuge" (implizit durch die MCP-Befehle in Abschnitt V definiert) beschreiben und das exakte JSON-Format für Anfragen (MCP Request) vorgeben. Der Prompt muss klarstellen, dass die Ausgabe _nur_ im spezifizierten JSON-Format erfolgen darf.
- **Function Calling Mechanismus:**
    - _Bei Nutzung einer API mit nativer Unterstützung (z. B. OpenAI Tools API 48, Anthropic Tools):_ Die MCP-Befehle aus Abschnitt V werden in das spezifische Format der API für Funktions-/Werkzeugdefinitionen übersetzt (Name, Beschreibung, Parameter-Schema). Das LLM wird dann direkt von der API aufgefordert, das passende Werkzeug (MCP-Befehl) und die Argumente zu nennen. Das LLM Integration Module parst die API-Antwort und extrahiert den MCP-Befehl und die Parameter zur Weiterleitung an den MCP Interface Handler.
    - _Bei Nutzung lokaler Modelle oder APIs ohne native Unterstützung:_ Hier ist Prompt Engineering entscheidend. Der Prompt muss das LLM anweisen, direkt das vollständige MCP Request JSON zu generieren. Zusätzlich _muss_ im LLM Interface Layer eine Technik zur **Constrained Generation** implementiert werden. Dies stellt sicher, dass die Ausgabe des LLM syntaktisch korrektes JSON ist und dem in Abschnitt V definierten Schema entspricht. Bibliotheken und Frameworks wie `instructor` (Python) 53, `outlines` (Python) 56, JSON Schema in Ollama 53 oder die Grammatik-Funktion (GBNF) von `llama.cpp` 55 bieten solche Möglichkeiten. Diese Technik filtert oder steuert die Token-Generierung des LLM, sodass nur gültige Ausgaben gemäß dem Schema erzeugt werden.54 Ohne Constrained Generation ist die Wahrscheinlichkeit hoch, dass lokale Modelle vom geforderten Format abweichen.56
- **Antwortbehandlung:** Das LLM Integration Module empfängt die MCP Response JSON vom Backend. Abhängig von der gewünschten Benutzererfahrung kann diese JSON-Antwort entweder direkt (nach einfacher Formatierung) an das Frontend weitergegeben werden, oder sie wird erneut an das LLM gesendet mit der Aufforderung, eine natürlichsprachliche Zusammenfassung oder Erklärung für den Benutzer zu generieren (z. B. "Ich habe Firefox gestartet" statt nur `{"status": "success",...}`).

### C. Anforderung an das MCP-Verständnis

- **Strikte Vorgabe:** Es muss sichergestellt werden, dass die gesamte Logik der LLM-Integration davon ausgeht, dass das LLM _kein_ Vorwissen über MCP hat und _ausschließlich_ auf die Informationen in Abschnitt V dieses Berichts zugreift.
- **Ableitung aus Spezifikation:** Alle Prompts, Funktions-/Werkzeugdefinitionen oder Grammatiken, die dem LLM zur Verfügung gestellt werden, müssen direkt und nachvollziehbar aus der MCP-Spezifikation in Abschnitt V abgeleitet sein.
- **Verifizierung:** Eine kritische Testphase muss überprüfen, ob das ausgewählte LLM, wenn ihm die MCP-Spezifikation als Kontext gegeben wird (z. B. als Teil eines langen System-Prompts oder über die Werkzeugbeschreibung), in der Lage ist, korrekte MCP-JSON-Anfragen für diverse natürlichsprachliche Eingaben zu generieren, ohne auf externes Wissen zurückzugreifen.

Die Notwendigkeit, dass das LLM MCP allein aus diesem Bericht lernt, unterstreicht die Bedeutung einer exzellenten "Function Calling" bzw. "Structured Output"-Fähigkeit.45 Da Standard-Trainingsdaten MCP nicht enthalten, muss die Definition zur Laufzeit bereitgestellt werden. Das LLM muss dann zuverlässig die Abbildung von natürlicher Sprache auf den korrekten MCP-Befehl und dessen JSON-Struktur durchführen. Dies macht Modelle mit starker Instruktionsbefolgung und Format-Treue unerlässlich. Für lokale Modelle wird Constrained Generation 53 quasi zur Pflicht, um die strikte Einhaltung des MCP-Formats zu garantieren, was die Integration im Vergleich zu APIs mit eingebauter, zuverlässiger Funktion aufwändiger macht.

## VII. C++ Backend Implementierungsdetails

Das C++ Backend bildet die Brücke zwischen der QML-Oberfläche, dem LLM und dem Manjaro-System. Die Implementierung muss robust, sicher und asynchron sein.

### A. Verarbeitung von MCP-Nachrichten

Der MCP Interface Handler ist für die Entgegennahme, Validierung und Weiterleitung von MCP-Befehlen sowie die Erzeugung von MCP-Antworten zuständig.

- **Empfang:** Eine Funktion oder ein Slot (verbunden mit dem LLM Integration Module) empfängt den MCP-Befehl als JSON-String.
- **Validierung:**
    1. **JSON-Parsing:** Verwendung von `QJsonDocument::fromJson()`, um den String in ein JSON-Objekt zu parsen. Bei Parsing-Fehlern wird sofort eine `INVALID_PARAMETER` (oder spezifischer `JSON_PARSE_ERROR`) MCP-Antwort generiert.
    2. **Strukturprüfung:** Überprüfung auf das Vorhandensein und die korrekten Basistypen (string, object) der Top-Level-Felder: `mcp_version`, `request_id`, `command`, `parameters`.
    3. **Versionsprüfung:** Abgleich der `mcp_version` mit der vom Backend unterstützten Version.
    4. **Befehlsprüfung:** Überprüfung, ob der Wert von `command` einem der in Abschnitt V.C definierten Befehle entspricht. Bei unbekanntem Befehl: `INVALID_COMMAND` Fehler.
    5. **Parameterprüfung:** Detaillierte Validierung des `parameters`-Objekts basierend auf der Definition für den spezifischen `command` aus Abschnitt V.C: Sind alle erforderlichen Parameter vorhanden? Haben alle Parameter den korrekten Datentyp (string, integer, boolean, array[string])? Sind Enum-Werte gültig? Bei Fehlern: `INVALID_PARAMETER` Fehler mit spezifischer Meldung.
- **Dispatching:** Nach erfolgreicher Validierung wird die entsprechende Methode in der System Interaction Layer aufgerufen. Die validierten und typisierten Parameter werden dabei übergeben.
- **Antwortgenerierung:** Die Methode empfängt das Ergebnis (als Datenstruktur oder Objekt) oder einen Fehler (als Fehlercode und Nachricht) von der System Interaction Layer. Sie konstruiert das MCP Response JSON unter Verwendung von `QJsonObject`, `QJsonArray` etc. und `QJsonDocument::toJson()`. Die `request_id` aus der Anfrage wird übernommen, `status` wird auf `success` oder `error` gesetzt, und entsprechend wird das `data`- oder `error`-Objekt befüllt.

### B. Implementierung der System Interaction Layer

Diese Schicht kapselt die tatsächliche Interaktion mit dem Manjaro-System.

- **Verwendung von `QProcess`:**
    - **Anwendungsfälle:** Ausführung von Kommandozeilenbefehlen für MCP-Kommandos wie `manage_packages_pamac`, `modify_setting_dconf`, `set_brightness`, `clipboard_copy`, `clipboard_paste`.
    - **Methoden:** `QProcess::start()` wird für asynchrone Ausführung verwendet. Die Signale `finished(int exitCode, QProcess::ExitStatus exitStatus)` und `errorOccurred(QProcess::ProcessError error)` müssen verbunden werden, um das Ergebnis oder Fehler zu behandeln.34 `QProcess::execute()` ist eine statische, blockierende Methode; sie sollte nur mit Vorsicht und idealerweise in einem separaten Worker-Thread verwendet werden, um die Haupt-Event-Loop nicht zu blockieren.34 `QProcess::startDetached()` ist ungeeignet, da keine Rückmeldung über Erfolg/Misserfolg oder Ausgabe benötigt wird.64 Der `QProcess`-Instanz muss eine ausreichende Lebensdauer gegeben werden (z.B. als Member-Variable oder Heap-Allokation mit Parent), da der Prozess sonst terminiert wird, wenn das `QProcess`-Objekt zerstört wird.64
    - **Argumentübergabe:** Kommandozeilenargumente müssen _immer_ als `QStringList` an `start()` übergeben werden.34 Dies verhindert Shell-Injection-Angriffe, da Qt die Argumente korrekt escaped und direkt an den auszuführenden Prozess übergibt, ohne eine Shell dazwischenzuschalten.37 Niemals Befehle durch String-Konkatenation mit Benutzereingaben zusammenbauen.
    - **Ausgabe lesen:** `stdout` und `stderr` werden über die Signale `readyReadStandardOutput()` und `readyReadStandardError()` oder nach Beendigung des Prozesses mit `readAllStandardOutput()` und `readAllStandardError()` gelesen.34 Die Ausgabe muss ggf. geparst werden (z. B. JSON-Ausgabe von Pamac, Textausgabe von `gsettings get`).
    - **Fehlerbehandlung:** Fehler wie "Programm nicht gefunden" (`QProcess::FailedToStart`), Absturz des Prozesses oder ein Exit-Code ungleich Null müssen abgefangen und in entsprechende MCP-Fehlercodes übersetzt werden.34
- **Verwendung von `QDBus`:**
    - **Anwendungsfälle:** Interaktion mit Diensten, die DBus-Schnittstellen anbieten (z. B. Lautstärkeregelung, Benachrichtigungen, Energieverwaltung).
    - **Identifikation:** Dienste, Objektpfade, Interfaces und Methoden/Signale müssen identifiziert werden (z. B. mit `qdbusviewer` oder durch Dokumentation der Desktop-Umgebung).39
    - **Implementierung:** Verwendung von `QDBusInterface` zum Aufrufen von Methoden oder `QDBusConnection::connect()` zum Verbinden mit Signalen.40 Asynchrone Aufrufe (`QDBusPendingCallWatcher`) sind zu bevorzugen. DBus-Fehler (`QDBusError`) müssen behandelt werden.
- **Interaktion mit `gsettings`/`dconf`:**
    - **Bevorzugter Ansatz:** Verwendung des `gsettings`-Kommandozeilenwerkzeugs via `QProcess`, da dies Schema-Validierung durchführt und als stabiler gilt als die direkte Interaktion mit der dconf-API.4
    - **Befehle:** Konstruktion von Befehlen wie `gsettings get <schema> <key>` oder `gsettings set <schema> <key> <value>`. Werte müssen korrekt für die Kommandozeile escaped/quotiert werden. Der Datentyp des Wertes muss dem Schema entsprechen.
    - **Ergebnis:** Bei `get`-Befehlen wird die `stdout`-Ausgabe geparst. Bei `set`-Befehlen wird der Exit-Code überprüft (0 für Erfolg). Fehler werden als `GSETTINGS_ERROR` gemeldet.
- **Allgemeine Fehlerbehandlung:** Jede Interaktionsmethode muss robust Fehler behandeln (Kommando nicht gefunden, Berechtigungsfehler, ungültige Argumente, Zeitüberschreitungen, unerwartete Ausgabeformate) und diese in die definierten MCP-Fehlercodes und aussagekräftige Meldungen übersetzen.

### C. Sicherheitsaspekte bei der Implementierung

Sicherheit muss auf Implementierungsebene berücksichtigt werden:

- **Eingabevalidierung und -bereinigung:** Obwohl das LLM das MCP generiert, muss das Backend _jede_ eingehende MCP-Anfrage und _alle_ Parameter erneut rigoros validieren und bereinigen, bevor sie in Systemaufrufen verwendet werden. Dies gilt insbesondere für Dateipfade, Paketnamen, Shell-Befehle (falls Skripte ausgeführt werden) und Konfigurationswerte.
- **Sichere Befehlskonstruktion:** Wie oben erwähnt, niemals Shell-Befehle durch String-Konkatenation erstellen. Immer `QProcess` mit `QStringList` für Argumente verwenden, um Shell-Interpretation zu umgehen.34
- **Privilegientrennung:** Der Backend-Prozess muss mit den Rechten des angemeldeten Benutzers laufen, nicht mit Root-Rechten. Wenn Aktionen höhere Rechte erfordern (z. B. Paketinstallation), sollte dies über etablierte Mechanismen wie Polkit erfolgen, die eine feingranulare Rechteverwaltung ermöglichen. Die direkte Verwendung von `sudo` im Backend ist zu vermeiden. Die Komplexität und Angriffsfläche erhöhen sich jedoch durch Polkit-Integration.

## VIII. Sicherheitsanalyse und Mitigation

Die Möglichkeit, Systemaktionen über eine KI-Schnittstelle auszulösen, birgt inhärente Sicherheitsrisiken, die sorgfältig analysiert und mitigiert werden müssen.

### A. Bedrohungsmodell

- **Angreifer:**
    - Ein böswilliger Benutzer, der versucht, durch geschickte Eingaben (Prompt Injection) das LLM zur Generierung schädlicher MCP-Befehle zu verleiten.
    - Ein kompromittiertes LLM (insbesondere bei Nutzung externer APIs).
    - Malware, die bereits auf dem System des Benutzers aktiv ist und versucht, die Sidebar oder deren Backend-Prozess auszunutzen.
- **Schützenswerte Güter (Assets):**
    - Benutzerdaten (persönliche Dateien, Konfigurationen, potenziell Zugangsdaten).
    - Systemintegrität (stabile Funktion des Betriebssystems und installierter Software).
    - Benutzerprivilegien und -identität.
    - Systemressourcen (CPU, Speicher, Netzwerkbandbreite).
- **Angriffsvektoren:**
    - **Prompt Injection:** Manipulation der LLM-Eingabe, um unerwünschte MCP-Befehle zu generieren.
    - **Exploitation von Befehlsausführung:** Ausnutzung von Schwachstellen in der Art, wie `QProcess` externe Befehle startet und verarbeitet, oder in den aufgerufenen Tools selbst.
    - **Unsichere DBus-Interaktion:** Ausnutzung von Schwachstellen in DBus-Diensten oder unsichere Kommunikation.
    - **Missbrauch von Dateisystemzugriff:** Generierung von MCP-Befehlen (`list_files` oder potenziell zukünftige Schreibbefehle), die auf sensible Bereiche zugreifen oder diese verändern.
    - **Unsichere Handhabung sensibler Daten:** Falls die Sidebar jemals Passwörter oder API-Schlüssel verarbeiten sollte (was vermieden werden sollte).

### B. Risikoidentifikation

Basierend auf dem Bedrohungsmodell ergeben sich folgende Hauptrisiken:

- **R1: Ausführung beliebigen Codes/Befehle (Arbitrary Code/Command Execution):** Höchstes Risiko. Ein manipuliertes LLM könnte MCP-Befehle generieren, die schädliche Aktionen auslösen (z. B. `open_application` mit Shell-Metazeichen im Namen, `manage_packages_pamac` zur Installation von Malware, `list_files` kombiniert mit Shell-Pipes in unsicherer Ausführung).
- **R2: Privilegieneskalation:** Wenn das Backend mit erhöhten Rechten läuft oder unsicher mit privilegierten Prozessen (z. B. via Polkit oder `sudo`) interagiert, könnte ein Angreifer Root-Zugriff erlangen.
- **R3: Informationspreisgabe:** MCP-Befehle wie `query_system_info` oder `list_files` könnten, wenn sie auf sensible Pfade oder Informationen angewendet werden, Daten an das LLM oder den Angreifer leaken.
- **R4: Denial of Service (DoS):** Gezielte MCP-Befehle könnten Systemressourcen überlasten (z. B. `list_files /`, exzessive `pamac`-Aufrufe) oder das System instabil machen.
- **R5: Datenkorruption/-löschung:** Befehle, die Einstellungen (`modify_setting_dconf`) oder potenziell Dateien ändern, könnten bei unzureichender Parameter-Validierung zu Datenverlust führen.
- **R6: LLM-Schwachstellen:** Eine Kompromittierung des LLM selbst (insbesondere bei Cloud-Diensten) oder erfolgreiche Prompt-Injection-Angriffe könnten zur Generierung schädlicher MCP-Befehle führen.

### C. Mitigationsstrategien

Um die identifizierten Risiken zu minimieren, müssen mehrere Verteidigungslinien implementiert werden:

1. **Strikte MCP-Validierung:** Das Backend _muss_ jede eingehende MCP-Anfrage rigoros gegen die in Abschnitt V definierte Spezifikation validieren. Dies umfasst die Struktur, den Befehlsnamen, die Anwesenheit und Typen aller Parameter sowie gültige Enum-Werte. Jede Abweichung führt zur sofortigen Ablehnung der Anfrage mit einem Fehler. (Adressiert R1, R5, R6)
2. **Parameter-Sanitisierung/-Escaping:** Alle Parameter, die in Systemaufrufen verwendet werden, müssen sorgfältig bereinigt und/oder escaped werden. Für `QProcess` ist die Verwendung von `QStringList` zur Argumentübergabe essenziell, um Shell-Interpretation zu vermeiden.34 Dateipfade und andere Strings müssen auf gefährliche Zeichen oder Sequenzen geprüft werden. (Adressiert R1, R5)
3. **Prinzip der geringsten Rechte (Least Privilege):** Der Backend-Prozess muss mit den Standardrechten des angemeldeten Benutzers laufen. Root-Rechte oder `sudo` sind zu vermeiden. Falls einzelne Aktionen erhöhte Rechte benötigen (z. B. systemweite Paketinstallation), ist eine feingranulare Autorisierung über Polkit zu prüfen, wobei die zusätzliche Komplexität und Angriffsfläche bedacht werden muss. (Adressiert R2)
4. **Command Whitelisting/Allowlisting (Optional):** Wenn möglich, sollte der Satz der erlaubten Aktionen weiter eingeschränkt werden. Beispielsweise könnte `open_application` nur auf Anwendungen aus einem vordefinierten, sicheren Satz beschränkt werden, oder `modify_setting_dconf` nur auf bestimmte, ungefährliche Schemata/Schlüssel. Dies reduziert die Angriffsfläche, kann aber die Flexibilität einschränken. (Adressiert R1, R5)
5. **Sandboxing der `QProcess`-Ausführung:** Dies ist eine kritische Maßnahme zur Eindämmung von R1.
    - _Konzept:_ Externe Prozesse, die über `QProcess` gestartet werden (insbesondere `pamac`, `gsettings`, `wl-clipboard`, `brightnessctl`), sollten in einer isolierten Umgebung (Sandbox) ausgeführt werden, die ihre Zugriffsrechte auf das System stark einschränkt.69
    - _Werkzeuge:_ `firejail` 71 und `bubblewrap` 73 sind geeignete Werkzeuge unter Linux. `firejail` bietet oft vordefinierte Profile, verwendet aber standardmäßig ein SUID-Binary, was eigene Risiken birgt.71 `bubblewrap` ist die Basis für Flatpak-Sandboxing, erfordert oft mehr manuelle Konfiguration, kann aber potenziell ohne SUID (mit User Namespaces) genutzt werden, wenn die Kernel-Unterstützung gegeben ist.73
    - _Implementierung:_ Statt `process->start("pamac", args)` würde man `process->start("firejail", QStringList() << "--profile=custom_pamac_profile" << "pamac" << args)` oder einen äquivalenten `bwrap`-Aufruf verwenden.
    - _Vorteile:_ Begrenzt den Schaden, den ein kompromittierter oder fehlgeleiteter Befehl anrichten kann, erheblich, indem Dateisystemzugriff, Netzwerkzugriff und erlaubte Systemaufrufe (via Seccomp) eingeschränkt werden.71
    - _Herausforderungen:_ Erfordert die Erstellung und Pflege spezifischer Sandbox-Profile für jedes verwendete externe Werkzeug. Kann zu Kompatibilitätsproblemen führen, wenn das Werkzeug legitime Zugriffe benötigt, die vom Profil blockiert werden. Potenzieller Performance-Overhead.
    - _Abwägung:_ Angesichts des Risikos, dass ein LLM unvorhersehbare oder manipulierte Befehle generiert, bietet Sandboxing eine essenzielle zusätzliche Sicherheitsebene. Die Komplexität der Profilerstellung muss gegen den Sicherheitsgewinn abgewogen werden. Es ist eine stark empfohlene Maßnahme. (Adressiert R1, R3, R4, R5)
6. **Rate Limiting:** Implementierung einer Begrenzung der Häufigkeit, mit der MCP-Befehle (insbesondere ressourcenintensive wie `pamac`) ausgeführt werden können, um DoS-Angriffe zu erschweren. (Adressiert R4)
7. **Benutzerbestätigung (Optional):** Für potenziell destruktive oder sicherheitskritische Aktionen (z. B. `pamac remove`, `pamac install`, Ändern wichtiger Systemeinstellungen) könnte eine explizite Bestätigung durch den Benutzer über einen Dialog im Frontend erforderlich sein, selbst wenn der Befehl vom LLM generiert wurde. Dies erhöht die Sicherheit, verringert aber die Automatisierung. (Adressiert R1, R5)
8. **Sichere LLM-Interaktion:** Bei Nutzung einer externen API muss die Kommunikation über HTTPS erfolgen. API-Schlüssel müssen sicher gespeichert und übertragen werden. Es ist zu überlegen, welche Daten (Benutzereingaben) an externe Dienste gesendet werden (Datenschutz). (Adressiert R6)

### D. Sicherheitsfokussiertes Testen

Zusätzlich zu den funktionalen Tests sind spezifische Sicherheitstests erforderlich:

- Penetration Testing: Gezielte Versuche, die Sicherheitsmechanismen zu umgehen.
- Fuzzing: Testen des MCP-Parsers und der System Interaction Layer mit ungültigen oder unerwarteten Eingaben.
- Prompt Injection Testing: Versuche, das LLM durch speziell gestaltete Eingaben zur Generierung unerwünschter MCP-Befehle zu bringen.
- Sandbox-Effektivität: Überprüfung, ob die implementierten Sandboxes (falls verwendet) die erwarteten Einschränkungen durchsetzen.

### Tabelle: Risikobewertung und Mitigation

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Risiko ID**|**Beschreibung**|**Wahrscheinlichkeit**|**Auswirkung**|**Mitigationsstrategie(n) (Ref. C.x)**|**Restrisiko**|
|R1|Ausführung beliebigen Codes/Befehle|Hoch (ohne Mitigation)|Kritisch|C.1, C.2, C.4, C.5, C.7|Mittel (mit C.5), Hoch (ohne C.5)|
|R2|Privilegieneskalation|Mittel|Kritisch|C.3|Niedrig|
|R3|Informationspreisgabe|Mittel|Hoch|C.1, C.2, C.5|Niedrig-Mittel|
|R4|Denial of Service (DoS)|Mittel|Mittel|C.5, C.6|Niedrig|
|R5|Datenkorruption/-löschung|Mittel|Hoch|C.1, C.2, C.5, C.7|Niedrig-Mittel|
|R6|LLM-Schwachstellen / Prompt Injection|Hoch (API), Mittel (Lokal)|Hoch|C.1, C.2, C.5, C.7, C.8|Mittel|

_Anmerkung zur Tabelle:_ Die Bewertungen (Wahrscheinlichkeit, Auswirkung, Restrisiko) sind qualitativ und dienen der Priorisierung. Die Effektivität der Mitigationen, insbesondere von C.5 (Sandboxing), beeinflusst das Restrisiko maßgeblich. Diese Tabelle erzwingt eine systematische Betrachtung der Risiken und stellt sicher, dass für jedes identifizierte Risiko eine geplante Gegenmaßnahme existiert.

## IX. Grober Entwicklungs- und Testplan

Dieser Plan skizziert die Hauptphasen der Entwicklung und die dazugehörigen Testaktivitäten.

### A. Entwicklungsphasen

1. **Phase 1: Kern-Backend & Basis-MCP (ca. 4-6 Wochen)**
    - Implementierung der grundlegenden C++ Backend-Struktur (Core Logic, leere Module für LLM, MCP, System Interaction).
    - Implementierung des MCP Interface Handlers für das Parsen und Validieren von JSON-Anfragen und das Generieren von Antworten.
    - Implementierung der System Interaction Layer für eine kleine Teilmenge von MCP-Befehlen (z. B. `query_system_info`, `open_application`) unter Verwendung von `QProcess` und ggf. `QDBus` für einfache Tests.
    - Fokus: Robuste MCP-Verarbeitung und grundlegende Systeminteraktion.
2. **Phase 2: Sidebar UI & Wayland-Integration (ca. 3-4 Wochen)**
    - Entwicklung der initialen QML-Benutzeroberfläche für die Sidebar (Eingabefeld, Ausgabebereich).
    - Integration des QML-Frontends mit dem C++ Backend für einen einfachen Request/Response-Fluss (initial mit fest kodierten oder simulierten MCP-Nachrichten).
    - Implementierung der persistenten Sidebar-Funktionalität unter Wayland mithilfe von `layer-shell-qt`.22 Initialer Fokus auf KDE Plasma.
    - Fokus: Funktionierende UI und korrekte Darstellung/Positionierung unter Wayland (Plasma).
3. **Phase 3: LLM-Integration & MCP-Generierung (ca. 5-7 Wochen)**
    - Auswahl des initialen LLM (API-basiert für schnellere Iteration empfohlen, oder lokal mit Fokus auf Constrained Generation).
    - Implementierung des LLM Integration Module zur Kommunikation mit dem LLM.
    - Entwicklung des Prompt Engineerings bzw. der Function/Tool-Definitionen, um das LLM zur Generierung von MCP-Befehlen basierend auf natürlicher Sprache zu bewegen.
    - **Kritischer Test:** Überprüfung, ob das LLM valide MCP-Befehle _ausschließlich_ basierend auf der Spezifikation aus Abschnitt V generieren kann.45
    - Fokus: Übersetzung von natürlicher Sprache in korrekte MCP-JSON-Anfragen.
4. **Phase 4: Erweiterung des MCP-Befehlssatzes (ca. 6-8 Wochen)**
    - Implementierung der verbleibenden MCP-Befehle aus Abschnitt V.C.
    - Implementierung der entsprechenden Logik in der System Interaction Layer (Interaktion mit `pamac` 9, `gsettings` 4, `brightnessctl` 1, `wl-clipboard` 12 etc.).
    - Umfassende Tests der einzelnen Systeminteraktionen.
    - Fokus: Abdeckung der definierten Systemfunktionalität.
5. **Phase 5: Sicherheits-Hardening & Sandboxing (ca. 4-5 Wochen)**
    - Implementierung der definierten Sicherheitsmitigationen (strikte Validierung, Parameter-Sanitisierung).
    - Falls entschieden: Implementierung des Sandboxings für `QProcess`-Aufrufe mittels `firejail` oder `bubblewrap`, inklusive Erstellung der notwendigen Profile.68
    - Durchführung initialer Sicherheitstests.
    - Fokus: Absicherung der Anwendung gegen die identifizierten Risiken.
6. **Phase 6: Cross-DE Testing & Verfeinerung (ca. 3-4 Wochen)**
    - Testen der Anwendung unter verschiedenen Manjaro Desktop-Umgebungen (insbesondere GNOME und ggf. XFCE/Wayland).
    - Identifikation von Kompatibilitätsproblemen (speziell bei GNOME bzgl. `wlr-layer-shell` 21) und Entwicklung von Anpassungen oder Dokumentation von Einschränkungen.
    - Verfeinerung der UI/UX basierend auf Testergebnissen.
    - Fokus: Sicherstellung der bestmöglichen Funktion und Integration über verschiedene Umgebungen hinweg.
7. **Phase 7: Beta-Testing & Release (kontinuierlich)**
    - Durchführung von Beta-Tests mit einer breiteren Benutzergruppe.
    - Sammeln von Feedback, Behebung von Fehlern.
    - Erstellung von Benutzer- und Entwicklerdokumentation.
    - Vorbereitung des Releases.

### B. Teststrategie

Eine mehrschichtige Teststrategie ist erforderlich:

- **Unit-Tests:** Testen einzelner C++-Klassen und Funktionen im Backend (MCP-Parser, Validierer, einzelne Module der System Interaction Layer) isoliert voneinander unter Verwendung eines Test-Frameworks (z. B. Qt Test).
- **Integrationstests:** Testen des Zusammenspiels der Komponenten: QML-Frontend -> Core Logic -> LLM Module -> MCP Handler -> System Interaction Layer -> System -> Response -> Frontend. Simulation von LLM-Antworten und Systemverhalten.
- **MCP-Konformitätstests:**
    - _LLM-Generierung:_ Systematisches Testen, ob das LLM für eine breite Palette von natürlichsprachlichen Anfragen die korrekten MCP-JSON-Anfragen gemäß Spezifikation V generiert (Genauigkeit, Format, Parameter). Dies muss _ohne_ externes Wissen erfolgen.
    - _Backend-Verarbeitung:_ Testen, ob das Backend alle in V.C definierten Befehle korrekt validiert, verarbeitet und die erwarteten `data`- oder `error`-Strukturen in der MCP-Antwort zurückgibt. Testen aller definierten Fehlerfälle.
- **Systeminteraktionstests:** Verifizierung, dass jede Systemaktion (Pamac, gsettings, Helligkeit, Zwischenablage etc.) auf einem realen Manjaro-System korrekt ausgeführt wird. Testen von Grenzfällen (z. B. Paket nicht gefunden, Berechtigung verweigert, ungültige Eingaben). Tests sollten idealerweise auf den Ziel-Desktop-Umgebungen (Plasma, GNOME) durchgeführt werden.
- **Sicherheitstests:** Gezielte Tests zur Überprüfung der Sicherheitsmitigationen: Penetration Testing, Versuche von Prompt Injection, Überprüfung der Effektivität der Sandboxing-Maßnahmen (falls implementiert).
- **UI/UX-Tests:** Überprüfung der Benutzerfreundlichkeit, Responsivität und visuellen Integration der Sidebar auf den Ziel-Desktop-Umgebungen (Plasma, GNOME, XFCE).
- **Performancetests:** Messung der Ende-zu-Ende-Latenz von Benutzeranfrage bis zur Antwort, insbesondere der Latenz des LLM und der Systembefehlsausführung. Identifikation von Flaschenhälsen.

## X. Schlussfolgerung

### Zusammenfassung

Dieser Bericht hat einen detaillierten Plan und eine technische Spezifikation für die Entwicklung einer KI-gestützten Desktop-Sidebar für Manjaro Linux unter Verwendung von C++, Qt, QML und Qt-Wayland vorgestellt. Die vorgeschlagene Architektur trennt klar zwischen Frontend, Backend-Logik, LLM-Interaktion und Systemzugriff. Das Kernstück bildet das Manjaro Control Protocol (MCP), eine JSON-basierte Schnittstelle, die speziell darauf ausgelegt ist, von einem LLM allein anhand dieser Spezifikation verstanden und genutzt zu werden. Die Integration in Wayland-Umgebungen, insbesondere die Nutzung des `wlr-layer-shell`-Protokolls mittels `layer-shell-qt`, wurde ebenso detailliert wie die notwendigen Mechanismen zur Systeminteraktion (`QProcess`, `QDBus`, `gsettings`) und die Strategien zur LLM-Integration (lokal vs. API, strukturierte Ausgabe). Ein besonderer Fokus lag auf der Analyse von Sicherheitsrisiken und der Definition von Mitigationsstrategien, einschließlich der Möglichkeit des Sandboxing für externe Prozessaufrufe.

### Potenzial

Die Realisierung dieses Projekts bietet erhebliches Potenzial. Eine nahtlos integrierte, sprachgesteuerte KI-Assistenz kann die Interaktion mit dem Manjaro-System erheblich vereinfachen und beschleunigen. Aufgaben wie das Starten von Anwendungen, das Verwalten von Paketen oder das Anpassen von Einstellungen werden intuitiver. Dies stellt eine moderne und leistungsfähige Erweiterung der Desktop-Erfahrung dar und positioniert Manjaro als innovative Plattform.

### Herausforderungen

Die Umsetzung birgt auch Herausforderungen. Die Gewährleistung einer konsistenten Funktionalität und visuellen Integration über verschiedene Wayland-basierte Desktop-Umgebungen hinweg, insbesondere die Kompatibilität mit GNOME/Mutter aufgrund der fehlenden `wlr-layer-shell`-Unterstützung 21, erfordert sorgfältige Planung und möglicherweise umgebungsspezifische Anpassungen. Die Absicherung des Systems gegen Missbrauch durch die KI-Schnittstelle, insbesondere die Risiken der Befehlsausführung (R1) und der LLM-Manipulation (R6), bedarf rigoroser Implementierung der Sicherheitsmaßnahmen, wobei Sandboxing 70 eine wichtige, aber komplexe Komponente darstellt. Die Sicherstellung, dass das LLM das MCP korrekt und zuverlässig _allein_ aus der Spezifikation anwendet, ist eine zentrale Anforderung, die sorgfältiges Prompt Engineering und möglicherweise den Einsatz von Constrained Generation Techniken erfordert.

### Nächste Schritte

Basierend auf dieser detaillierten Speifikation wird empfohlen, mit der Entwicklung gemäß Phase 1 des vorgeschlagenen Plans zu beginnen. Dies umfasst die Implementierung des Kern-Backends und der Basis-MCP-Verarbeitung, um eine solide Grundlage für die weiteren Schritte zu schaffen. Parallel dazu sollte die Auswahl des LLM und die Verfeinerung der Integrationsstrategie unter Berücksichtigung der strukturierten Ausgabeanforderungen erfolgen.


# Entwickler-Implementierungsleitfaden: MCP in der UI-Schicht (Ultra-Feinspezifikation)

**Vorwort des Architekten**

Die Integration des Model Context Protocol (MCP) in die Benutzeroberfläche (UI) einer Anwendung stellt einen signifikanten Schritt zur Ermöglichung einer tiefgreifenden und kontextbewussten Kollaboration mit künstlicher Intelligenz dar. Die UI fungiert hierbei als zentrale Schnittstelle, die dem Benutzer nicht nur die Interaktion mit KI-Funktionen ermöglicht, sondern auch die Kontrolle und Transparenz über die zugrundeliegenden MCP-Operationen gewährleisten muss. Dieser Implementierungsleitfaden ist das Ergebnis einer sorgfältigen Analyse der offiziellen MCP-Spezifikationen, existierender Implementierungen und bewährter Praktiken im UI-Design. Er zielt darauf ab, eine robuste, wartbare und benutzerfreundliche Implementierung der UI-Schicht zu ermöglichen, indem er eine präzise und lückenlose Spezifikation aller relevanten Komponenten, Dienste, Datenstrukturen und Prozesse bereitstellt. Die Einhaltung dieses Leitfadens soll sicherstellen, dass Entwickler eine konsistente und qualitativ hochwertige MCP-Integration ohne eigene, grundlegende Designentscheidungen umsetzen können.

## 1. Einleitung und Protokollgrundlagen für UI-Entwickler

Dieser Abschnitt legt die fundamentalen Konzepte des Model Context Protocol (MCP) dar, die für Entwickler der UI-Schicht von entscheidender Bedeutung sind. Ein solides Verständnis dieser Grundlagen ist unerlässlich, um die nachfolgenden detaillierten Spezifikationen korrekt interpretieren und implementieren zu können.

### 1.1. Zielsetzung dieses Implementierungsleitfadens

Das primäre Ziel dieses Dokuments ist die Bereitstellung einer finalen, lückenlosen Entwickler-Implementierungsanleitung für die UI-Schicht im Kontext der MCP-Integration. Diese Spezifikation ist als "Ultra-Feinspezifikation" konzipiert, was bedeutet, dass sie so detailliert ist, dass Entwickler sie direkt zur Implementierung verwenden können, ohne eigene architektonische Entscheidungen treffen oder grundlegende Logiken und Algorithmen entwerfen zu müssen. Alle relevanten Aspekte wurden recherchiert, entschieden und werden hier präzise spezifiziert. Dieser Leitfaden soll jegliche Ambiguität eliminieren und eine konsistente Implementierung über das gesamte Entwicklungsteam hinweg sicherstellen.

### 1.2. MCP-Überblick: Kernkonzepte für die UI-Integration

Das Model Context Protocol (MCP) ist ein offener Standard, der darauf abzielt, die Art und Weise zu standardisieren, wie KI-Anwendungen mit externen Werkzeugen, Datenquellen und Systemen interagieren.1 Für die UI-Schicht, die typischerweise als Host für MCP-Interaktionen agiert, sind folgende Kernkonzepte maßgeblich.

#### 1.2.1. MCP-Architektur: Host, Client, Server

Die MCP-Architektur basiert auf drei Hauptkomponenten 1:

- **Host:** Die Anwendung, mit der der Benutzer direkt interagiert, beispielsweise eine Desktop-Applikation, eine IDE oder ein Chat-Interface. In diesem Leitfaden ist die UI-Anwendung der Host. Der Host ist verantwortlich für die Verwaltung der MCP-Clients und die Durchsetzung von Sicherheitsrichtlinien, insbesondere der Benutzerzustimmung.2
- **Client:** Eine Komponente, die innerhalb des Hosts residiert und die Verbindung zu einem spezifischen MCP-Server verwaltet. Es besteht eine Eins-zu-Eins-Beziehung zwischen einer Client-Instanz und einer Server-Verbindung.1 Wenn eine Host-Anwendung startet, kann sie mehrere MCP-Clients erstellen, von denen jeder für die Verbindung zu einem anderen MCP-Server vorgesehen ist.
- **Server:** Ein externes Programm oder ein Dienst, der Funktionalitäten (Tools), Datenquellen (Ressourcen) und vordefinierte Interaktionsvorlagen (Prompts) über eine standardisierte API bereitstellt, auf die der Client zugreift.1

Die Eins-zu-Eins-Beziehung zwischen einem MCP-Client und einem MCP-Server 1 hat direkte Auswirkungen auf die Architektur der UI-Schicht. Wenn die UI-Anwendung als Host mit mehreren externen Systemen (die jeweils durch einen MCP-Server repräsentiert werden) interagieren soll, muss sie eine robuste Verwaltungslogik für mehrere, potenziell gleichzeitig aktive Client-Instanzen implementieren. Dies erfordert nicht nur Mechanismen zur Kommunikation, sondern auch ein ausgefeiltes Zustandsmanagement für jede einzelne Verbindung sowie eine effiziente Ressourcenverwaltung (z.B. für Threads oder Netzwerkverbindungen, die pro Client benötigt werden könnten). Die UI muss in der Lage sein, diese Client-Instanzen zu erstellen, zu überwachen, ordnungsgemäß zu beenden und deren Status dem Benutzer transparent darzustellen.

#### 1.2.2. MCP-Fähigkeiten: Tools, Ressourcen, Prompts

MCP-Server können drei Haupttypen von Fähigkeiten (Capabilities) anbieten, die für die Interaktion mit dem LLM und dem Benutzer relevant sind 1:

- **Tools (Modellgesteuert):** Dies sind Funktionen, die ein Large Language Model (LLM) aufrufen kann, um spezifische Aktionen auszuführen, beispielsweise eine API abzufragen oder eine Datei zu ändern.1 Die UI muss dem Benutzer klar anzeigen, welche Tools verfügbar sind, und die Ausführung dieser Tools – nach expliziter Zustimmung des Benutzers – orchestrieren und überwachen.
- **Ressourcen (Anwendungsgesteuert):** Dies sind Datenquellen, auf die das LLM zugreifen kann, um Informationen abzurufen, z.B. den Inhalt einer Datei, Ergebnisse einer Datenbankabfrage oder Kontextinformationen aus der Anwendung.1 Die UI muss den Zugriff auf diese Ressourcen ermöglichen, die abgerufenen Daten gegebenenfalls visualisieren oder sie dem LLM zur weiteren Verarbeitung zuführen.
- **Prompts (Benutzergesteuert):** Dies sind vordefinierte Vorlagen oder parametrisierbare Anfragen, die entwickelt wurden, um die Nutzung von Tools oder Ressourcen in einer optimalen und standardisierten Weise zu lenken.1 Die UI muss diese Prompts auflisten und dem Benutzer zur Auswahl und Konfiguration anbieten.

Die unterschiedliche Steuerung dieser Fähigkeiten – modellgesteuert für Tools, anwendungsgesteuert für Ressourcen und benutzergesteuert für Prompts – hat direkte und wichtige Konsequenzen für das Design der Benutzeroberfläche, insbesondere im Hinblick auf Interaktionsabläufe und die Einholung der Benutzerzustimmung.

Für "Tools" ist die explizite Zustimmung des Benutzers vor jeder Ausführung kritisch, da diese Aktionen in externen Systemen auslösen und potenziell Seiteneffekte haben können.3 Die UI muss dem Benutzer klar kommunizieren, welches Tool mit welchen Parametern ausgeführt werden soll und welche Konsequenzen dies haben könnte.

Für "Ressourcen" ist die Zustimmung zum Datenabruf und zur potenziellen Weitergabe dieser Daten an das LLM oder den MCP-Server von zentraler Bedeutung.3 Auch hier muss der Benutzer die Kontrolle darüber behalten, welche Informationen preisgegeben werden.

"Prompts" hingegen stellen primär eine Auswahlmöglichkeit für den Benutzer dar, die den Kontext oder die Art der Interaktion mit Tools und Ressourcen vorstrukturieren. Hier steht die Benutzerfreundlichkeit der Auswahl und Parametrisierung im Vordergrund, während das direkte Sicherheitsrisiko im Vergleich zu Tool-Ausführungen geringer sein kann, aber dennoch die zugrundeliegenden Tool- und Ressourcenzugriffe den üblichen Zustimmungsprozessen unterliegen müssen. Diese Unterscheidungen müssen sich in klar differenzierten UI-Flüssen, Informationsdarstellungen und Zustimmungsdialogen widerspiegeln.

#### 1.2.3. MCP-Zusatzfunktionen (Sampling, Konfiguration, Fortschritt, Abbruch, Fehler, Logging)

Neben den Kernfähigkeiten definiert MCP auch eine Reihe von unterstützenden Protokollfunktionen ("Additional Utilities"), die für eine robuste und benutzerfreundliche UI-Integration von Bedeutung sind 3:

- **Sampling:** Ermöglicht serverseitig initiierte agentische Verhaltensweisen und rekursive LLM-Interaktionen. Die UI muss hierfür strenge Benutzerkontrollen und Zustimmungsmechanismen implementieren.3
- **Konfiguration:** Mechanismen zur Konfiguration von Servern oder der Verbindung.
- **Fortschrittsverfolgung (Progress Tracking):** Erlaubt es Servern, den Fortschritt langlaufender Operationen an den Client zu melden.
- **Abbruch (Cancellation):** Ermöglicht es dem Client, eine laufende Operation auf dem Server abzubrechen.
- **Fehlerberichterstattung (Error Reporting):** Standardisierte Wege zur Meldung von Fehlern.
- **Logging:** Mechanismen für das Logging von Informationen auf Client- oder Serverseite.

Insbesondere Funktionen wie `Progress Tracking` und `Cancellation` sind für die UI von hoher Relevanz. Langlaufende KI-Operationen oder Tool-Aufrufe sind im MCP-Kontext häufig zu erwarten. Ohne eine sichtbare FortschR_S1Anzeige könnte die UI als eingefroren wahrgenommen werden, was zu einer negativen Benutzererfahrung führt. Die Möglichkeit, Operationen abzubrechen, gibt dem Benutzer die notwendige Kontrolle zurück. `Error Reporting` muss in der UI so umgesetzt werden, dass Fehler nicht nur als technische Codes, sondern als verständliche Meldungen mit möglichen Handlungsanweisungen für den Benutzer dargestellt werden. Die UI-Schicht muss also nicht nur die entsprechenden MCP-Nachrichten senden und empfangen, sondern auch die zugehörigen UI-Elemente (z.B. Fortschrittsbalken, Abbrechen-Schaltflächen, detaillierte Fehlermeldungsdialoge) bereitstellen und deren Logik präzise implementieren.

### 1.3. Kommunikationsprotokoll: JSON-RPC 2.0 und Transportmechanismen

Die Kommunikation zwischen MCP-Clients und -Servern basiert auf etablierten Standards.

#### 1.3.1. JSON-RPC 2.0 als Basis

MCP verwendet JSON-RPC 2.0 für den Nachrichtenaustausch.3 JSON-RPC ist ein leichtgewichtetes Remote Procedure Call Protokoll.

Eine Request-Nachricht enthält typischerweise folgende Felder 5:

- `jsonrpc`: Eine Zeichenkette, die die Version des JSON-RPC-Protokolls angibt (muss "2.0" sein).
- `id`: Ein eindeutiger Identifikator (String oder Zahl), der vom Client festgelegt wird. Bei Notifications wird dieses Feld weggelassen.
- `method`: Eine Zeichenkette, die den Namen der aufzurufenden Methode enthält (z.B. "initialize", "tools/list").
- `params`: Ein strukturiertes Objekt oder Array, das die Parameter für die Methode enthält.

Eine **Response-Nachricht** enthält 5:

- `jsonrpc`: Muss "2.0" sein.
- `id`: Muss mit der `id` der korrespondierenden Request-Nachricht übereinstimmen.
- `result`: Dieses Feld enthält das Ergebnis des Methodenaufrufs bei Erfolg. Der Datentyp ist methodenspezifisch.
- `error`: Dieses Feld ist nur bei einem Fehler vorhanden und enthält ein Fehlerobjekt mit den Feldern `code` (eine Zahl), `message` (eine Zeichenkette) und optional `data`.

Für die UI bedeutet dies, dass sie in der Lage sein muss, diese JSON-Strukturen korrekt zu serialisieren (für ausgehende Requests) und zu deserialisieren (für eingehende Responses und Notifications). Die Fehlerbehandlung in der UI muss auf den empfangenen JSON-RPC-Fehlerobjekten basieren und diese in anwendungsspezifische Ausnahmen oder benutzerfreundliche Meldungen umwandeln. JSON-RPC ist besonders gut für aktions- oder funktionsorientierte APIs geeignet, was gut zur Natur von MCP passt, bei dem es um das Aufrufen von Tools und den Zugriff auf Ressourcen geht.6

#### 1.3.2. Transportmechanismen: stdio und HTTP/SSE

MCP unterstützt primär zwei Transportmechanismen für die Übertragung der JSON-RPC-Nachrichten 1:

- **stdio (Standard Input/Output):** Dieser Mechanismus wird typischerweise verwendet, wenn der MCP-Server als lokaler Kindprozess des Hosts (der UI-Anwendung) ausgeführt wird. Der Host sendet JSON-RPC-Requests über den Standard-Input (`stdin`) des Serverprozesses und empfängt Antworten über dessen Standard-Output (`stdout`). Der Standard-Error (`stderr`) kann für Log-Meldungen oder separate Fehlerkanäle genutzt werden.5 Die Verbindung wird typischerweise durch Schließen des `stdin` und Warten auf die Beendigung des Kindprozesses terminiert.
- **HTTP/SSE (Server-Sent Events):** Dieser Mechanismus ist für die Kommunikation mit potenziell entfernten Servern über das Netzwerk vorgesehen. Der Client initiiert eine HTTP-Verbindung zu einem speziellen SSE-Endpunkt des Servers. Nach dem Verbindungsaufbau kann der Server asynchron Ereignisse (JSON-RPC-Responses oder Notifications) an den Client pushen.15 spezifiziert, dass der Client bei diesem Transport eine SSE-Verbindung öffnet und vom Server ein `endpoint` Event mit einer URI erhält. An diese URI sendet der Client dann seine Requests via HTTP POST, während die Antworten des Servers über die bestehende SSE-Verbindung eintreffen.

Die Wahl des Transportmechanismus hat direkte Implikationen für die UI. Sie muss in der Lage sein, beide Mechanismen zu konfigurieren und zu handhaben. Für `stdio` bedeutet dies, dass die UI Pfade zu ausführbaren Dateien und Startargumente verwalten muss.7 Für `HTTP/SSE` sind es URLs und potenziell Authentifizierungsdaten. Die UI muss auch Sicherheitsaspekte berücksichtigen, insbesondere bei `HTTP/SSE`, wo Netzwerkzugriffe und damit verbundene Risiken (Firewalls, Zertifikate, Datensicherheit bei der Übertragung) eine Rolle spielen. Eine flexible UI sollte dem Benutzer oder Administrator die Konfiguration beider Transporttypen ermöglichen, oder es muss eine fundierte Entscheidung für die ausschließliche Unterstützung eines Typs getroffen werden, basierend auf den Anforderungen der Anwendung. Die `mcpr` Rust-Bibliothek demonstriert beispielsweise, wie solche Transportmechanismen abstrahiert werden können.9 Cursor unterstützt und konfiguriert ebenfalls beide Transportarten.10

#### 1.3.3. Zustandsbehaftete Verbindungen (Stateful Connections)

MCP-Verbindungen sind explizit als zustandsbehaftet (stateful) definiert.3 Dies bedeutet, dass der Server Informationen über den Zustand einer Verbindung mit einem bestimmten Client über mehrere Anfragen hinweg speichert und berücksichtigt.11 Der typische Lebenszyklus einer Verbindung beginnt mit einer `initialize`-Nachricht, in der Client und Server Protokollversionen und Fähigkeiten austauschen.5 Erst nach erfolgreicher Initialisierung sind weitere Aufrufe (z.B. `tools/list` oder `tools/call`) gültig und sinnvoll.

Für die UI-Implementierung ist diese Zustandsbehaftung von großer Bedeutung. Die UI muss nicht nur einzelne Nachrichten austauschen, sondern den gesamten Lebenszyklus jeder MCP-Sitzung aktiv managen. Dies beinhaltet:

- Korrekte Initialisierung jeder Verbindung.
- Speicherung und Verwaltung des ausgetauschten Fähigkeitsstatus (`capabilities`) pro Verbindung.5
- Sicherstellung, dass Operationen nur auf korrekt initialisierten und aktiven Verbindungen ausgeführt werden.
- Sauberes Beenden von Verbindungen (`shutdown`).
- Visualisierung des aktuellen Verbindungsstatus (z.B. "verbindend", "initialisiert", "verbunden", "getrennt", "Fehler") für den Benutzer.

Fehler in einer frühen Phase des Verbindungsaufbaus, wie z.B. ein Fehlschlagen der `initialize`-Nachricht, können die gesamte Sitzung für diesen Server ungültig machen. Die UI muss solche Zustände erkennen und entsprechend reagieren, beispielsweise indem sie Operationen für diesen Server deaktiviert oder den Benutzer informiert.

### 1.4. Sicherheits- und Zustimmungserwägungen in der UI (User Consent)

Sicherheit und Benutzerkontrolle sind fundamentale Aspekte des MCP-Protokolls. Die Spezifikation legt großen Wert auf folgende Kernprinzipien 3:

- **Benutzerzustimmung und -kontrolle (User Consent and Control):** Benutzer müssen explizit zustimmen und verstehen, auf welche Daten zugegriffen wird und welche Operationen ausgeführt werden. Sie müssen die Kontrolle darüber behalten, welche Daten geteilt und welche Aktionen durchgeführt werden.
- **Datenschutz (Data Privacy):** Hosts (UI-Anwendungen) **MÜSSEN** explizite Benutzerzustimmung einholen, bevor Benutzerdaten an Server weitergegeben werden. Ressourcendaten dürfen nicht ohne Zustimmung des Benutzers an andere Stellen übertragen werden.
- **Toolsicherheit (Tool Safety):** Tools repräsentieren potenziell beliebige Codeausführung und müssen mit Vorsicht behandelt werden. Beschreibungen des Tool-Verhaltens (Annotationen) sind als nicht vertrauenswürdig zu betrachten, es sei denn, sie stammen von einem vertrauenswürdigen Server. Hosts **MÜSSEN** explizite Benutzerzustimmung einholen, bevor ein Tool aufgerufen wird.
- **LLM-Sampling-Kontrollen:** Benutzer müssen explizit allen LLM-Sampling-Anfragen zustimmen und kontrollieren können, ob Sampling stattfindet, welcher Prompt gesendet wird und welche Ergebnisse der Server sehen kann.

Die Notwendigkeit der Benutzerzustimmung ist nicht nur ein formales Erfordernis, sondern erfordert ein durchdachtes UI/UX-Design. Es reicht nicht aus, ein einfaches Kontrollkästchen anzubieten. Der Benutzer muss klar und unmissverständlich darüber informiert werden, _wozu_ er seine Zustimmung gibt: Welches spezifische Tool soll ausgeführt werden? Mit welchen Parametern? Welche Daten werden von welcher Ressource abgerufen? Welche potenziellen Auswirkungen hat die Aktion? Dies kann granulare und kontextsensitive Zustimmungsdialoge erfordern. Die UI muss zudem den "Vertrauensstatus" eines MCP-Servers berücksichtigen und dem Benutzer signalisieren, falls ein Tool oder eine Beschreibung von einem als "untrusted" eingestuften Server stammt 3, möglicherweise durch eine deutlichere Warnung oder zusätzliche Bestätigungsschritte. Cursor implementiert beispielsweise einen "Tool Approval Flow", bei dem der Benutzer die Argumente sieht, mit denen ein Tool aufgerufen werden soll, bevor er zustimmt.10

Für Desktop-Anwendungen, insbesondere unter Linux-basierten Betriebssystemen, bieten **XDG Desktop Portals** eine standardisierte Methode, um Berechtigungen vom Benutzer über systemeigene Dialoge anzufordern.14 Die Nutzung von XDG Portals (z.B. über Bibliotheken wie `ashpd` in Rust 16) kann die Implementierung von Zustimmungsdialogen erheblich verbessern, da sie eine konsistente Benutzererfahrung über verschiedene Desktop-Umgebungen hinweg gewährleistet und die Anwendung besser in das Betriebssystem integriert. Die `ashpd`-Bibliothek ermöglicht beispielsweise die Interaktion mit Portalen für Farbauswahl oder Kamerazugriff nach Benutzerzustimmung.16 Ein ähnlicher Ansatz wäre für MCP-spezifische Zustimmungen denkbar, wobei `WindowIdentifier` 16 verwendet wird, um den Zustimmungsdialog korrekt dem Elternfenster der Anwendung zuzuordnen. XDG Portals unterstützen sogar Konzepte wie "Pre-Authorization" 14, was für fortgeschrittene Benutzer relevant sein könnte, die bestimmten MCP-Servern oder Tools dauerhaft vertrauen möchten.

### Tabelle 1: Wichtige MCP JSON-RPC Methoden (Client-Sicht)

Die folgende Tabelle fasst die wichtigsten JSON-RPC-Methoden zusammen, die von der UI-Schicht (als MCP-Client) typischerweise initiiert werden, um mit MCP-Servern zu interagieren. Sie dient als Referenz für die Implementierung der Kommunikationslogik.

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**MCP Funktion**|**JSON-RPC Methode (Request)**|**Richtung**|**Schlüsselparameter (Request)**|**Erwartete Antwortstruktur (Result/Error)**|**Referenz-Snippet**|
|Initialisierung|`initialize`|Client -> Server|`protocolVersion: string`, `capabilities: ClientCapabilities`, `clientInfo: ClientInfo`|`ServerInfo`, `capabilities: ServerCapabilities` (tools, resources, prompts), `protocolVersion: string`|5|
|Tools auflisten|`tools/list`|Client -> Server|`{}` (oft leer, ggf. Filteroptionen)|`ListOf<ToolDefinition>`|17|
|Tool aufrufen|`tools/call`|Client -> Server|`name: string` (Tool-Name), `arguments: object` (Tool-Parameter)|`ToolResult` (methodenspezifisch) oder `ErrorObject`|17|
|Ressourcen auflisten|`resources/list`|Client -> Server|`{}` (oft leer, ggf. Filteroptionen)|`ListOf<ResourceDefinition>`|(Analog zu Tools)|
|Ressource abrufen|`resources/get`|Client -> Server|`name: string` (Ressourcen-Name), `params: object` (optionale Parameter)|`ResourceData` (methodenspezifisch) oder `ErrorObject`|(Analog zu Tools)|
|Prompts auflisten|`prompts/list`|Client -> Server|`{}` (oft leer, ggf. Filteroptionen)|`ListOf<PromptDefinition>`|(Analog zu Tools)|
|Prompt ausführen|`prompts/invoke`|Client -> Server|`name: string` (Prompt-Name), `arguments: object` (Prompt-Parameter)|`PromptResult` (methodenspezifisch) oder `ErrorObject`|(Analog zu Tools)|
|Ping (Lebenszeichen)|`ping`|Client -> Server|`{}` (oder spezifische Ping-Daten)|`PongResponse` (oder spezifische Pong-Daten)|5|
|Operation abbrechen|`$/cancelRequest`|Client -> Server|`id: string \|number` (ID der abzubrechenden Anfrage)|(Notification, keine direkte Antwort erwartet)|
|Fortschrittsbenachrichtigung|`$/progress`|Server -> Client|`token: string \|number`(Fortschrittstoken),`value: any` (Fortschrittsdaten)|(Notification, vom Client zu verarbeiten)|
|Shutdown|`shutdown`|Client -> Server|`{}`|`null` oder `ErrorObject` (oder keine Antwort, wenn als Notification implementiert)|9|

_Hinweis: Die genauen Methodennamen für Ressourcen und Prompts (`resources/list`, `resources/get`, `prompts/list`, `prompts/invoke`) können je nach MCP-Serverimplementierung oder spezifischeren MCP-Erweiterungen variieren. Die Tabelle listet plausible Namen basierend auf der Analogie zu `tools/list` und `tools/call`. Die Methoden `$/cancelRequest` und `$/progress` sind typische JSON-RPC-Benachrichtigungen (Notifications), wobei `$/` eine Konvention für protokollinterne Nachrichten ist._

## 2. Architektur der UI-Schicht mit MCP-Integration

Dieser Abschnitt beschreibt die übergeordnete Architektur der UI-Schicht und wie die MCP-Integration darin verankert ist. Ziel ist es, eine modulare, wartbare und erweiterbare Struktur zu definieren, die den Anforderungen des MCP gerecht wird.

### 2.1. Gesamtarchitektur: Die UI als MCP-Host und ihre Interaktion mit MCP-Servern

Die UI-Anwendung agiert als MCP-Host. Innerhalb dieser Host-Anwendung werden eine oder mehrere MCP-Client-Instanzen verwaltet, wobei jede Client-Instanz für die Kommunikation mit genau einem MCP-Server zuständig ist.1 Die UI-Komponenten selbst (z.B. Buttons, Menüs, Ansichten) interagieren nicht direkt mit den rohen JSON-RPC-Nachrichten oder den Transportmechanismen. Stattdessen greifen sie auf eine Reihe von internen Diensten zurück, die die Komplexität der MCP-Kommunikation kapseln und eine abstrahierte Schnittstelle bereitstellen.

Eine schematische Darstellung der Architektur könnte wie folgt aussehen:

```

     ^
| Interaktion
     v
+---+
| UI-Schicht (MCP Host) |
| +---+ |
| | UserInterfaceModule (Widgets, Views, Controller)| |
| | ^                               V | |
| | | Interaktion       Daten/Events | |
| | +---+ |
| | | Kern-UI-Interaktionsdienste für MCP | |
| | | (ToolOrchestration, ResourceAccess, ConsentUI)| |
| | ^                               V | |
| | | Abstrahierte Aufrufe  Status/Ergebnisse | |
| | +---+ |
| | | MCP-Client-Management-Komponenten | |
| | | (MCPConnectionService, MCPClientInstance) | |
| | ^                           V | |
| +---| JSON-RPC über Transport |---+ |
| (stdio / HTTP+SSE) |
          v                           ^
+---+     +---+
| Externer MCP Server 1 | | Externer MCP Server 2 |
| (Tools, Ressourcen) | | (Tools, Ressourcen) |
+---+     +---+
```

Diese Architektur fördert die Entkopplung:

- **UI-Komponenten** sind für die Darstellung und Benutzerinteraktion zuständig. Sie kennen die MCP-spezifischen Details nur über die Schnittstellen der Kern-UI-Interaktionsdienste.
- **Kern-UI-Interaktionsdienste** (siehe Abschnitt 4) orchestrieren komplexere Abläufe wie Tool-Aufrufe inklusive Zustimmung und aggregieren Daten von verschiedenen Servern.
- **MCP-Client-Management-Komponenten** (siehe Abschnitt 3) kümmern sich um den Lebenszyklus der Verbindungen und die grundlegende JSON-RPC-Kommunikation.

Diese Schichtung ermöglicht es, Änderungen in der MCP-Spezifikation oder bei einzelnen MCP-Servern primär in den unteren Schichten zu behandeln, ohne dass umfangreiche Anpassungen an den eigentlichen UI-Widgets erforderlich werden.

### 2.2. Kernmodule der UI-Schicht und ihre Verantwortlichkeiten im MCP-Kontext

Um die oben beschriebene Architektur umzusetzen, wird die UI-Schicht in mehrere Kernmodule unterteilt, die spezifische Verantwortlichkeiten im MCP-Kontext tragen:

- **`MCPConnectionModule`**:
    
    - **Verantwortung:** Verwaltung des Lebenszyklus aller MCP-Client-Instanzen. Stellt Verbindungen zu MCP-Servern her, überwacht diese und beendet sie. Kapselt die Logik für `MCPConnectionService` und `MCPClientInstance`.
    - **Primäre MCP-Interaktionen:** Senden von `initialize` und `shutdown` Nachrichten, Handling der Transportebene (stdio/SSE).
- **`ToolInteractionModule`**:
    
    - **Verantwortung:** Orchestrierung der Interaktion mit MCP-Tools. Stellt Funktionen zum Auflisten verfügbarer Tools, zum Aufrufen von Tools (nach Zustimmung) und zur Verarbeitung der Ergebnisse bereit. Kapselt den `ToolOrchestrationService`.
    - **Primäre MCP-Interaktionen:** Senden von `tools/list` und `tools/call` Nachrichten, Verarbeitung der Antworten.
- **`ResourceInteractionModule`**:
    
    - **Verantwortung:** Analog zum `ToolInteractionModule`, jedoch für MCP-Ressourcen. Kapselt den `ResourceAccessService`.
    - **Primäre MCP-Interaktionen:** Senden von `resources/list` und `resources/get` (oder äquivalenten) Nachrichten.
- **`PromptInteractionModule`**:
    
    - **Verantwortung:** Handhabung von MCP-Prompts, inklusive Auflistung, Auswahl und Ausführung. Kapselt den `PromptExecutionService`.
    - **Primäre MCP-Interaktionen:** Senden von `prompts/list` und `prompts/invoke` (oder äquivalenten) Nachrichten.
- **`UserInterfaceModule`**:
    
    - **Verantwortung:** Enthält die eigentlichen UI-Komponenten (Widgets, Dialoge, Ansichten), mit denen der Benutzer interagiert (z.B. Kontextmenüs, Sidebar, Chat-Interface). Diese Komponenten nutzen die Dienste der anderen Module, um MCP-Funktionalität darzustellen und zugänglich zu machen. Kapselt Komponenten wie `MCPContextualMenuController`, `MCPSidebarView`, `MCPWidgetFactory`, `AICoPilotInterface`.
- **`ConsentModule`**:
    
    - **Verantwortung:** Zentralisierte Verwaltung und Darstellung von Zustimmungsdialogen für alle MCP-Operationen, die eine explizite Benutzerfreigabe erfordern. Kapselt den `UserConsentUIManager`.
    - **Primäre MCP-Interaktionen:** Keine direkten MCP-Nachrichten, aber eng gekoppelt an die Ausführung von Tool-Aufrufen und Ressourcenzugriffen.
- **`StateManagementModule`**:
    
    - **Verantwortung:** Hält den globalen, reaktiven Zustand aller MCP-bezogenen Informationen (verbundene Server, verfügbare Tools/Ressourcen, laufende Operationen etc.). Kapselt den `MCPGlobalContextManager`.
    - **Primäre MCP-Interaktionen:** Empfängt Status-Updates von anderen Modulen.

Die Modularisierung muss die inhärente Asynchronität der MCP-Kommunikation berücksichtigen. Module, die Netzwerkkommunikation oder Interprozesskommunikation durchführen (insbesondere `MCPConnectionModule`, `ToolInteractionModule`, `ResourceInteractionModule`, `PromptInteractionModule`), müssen dies auf nicht-blockierende Weise tun. Sie sollten asynchrone Programmiermuster (z.B. `async/await`, Promises, Futures) verwenden und Callbacks, Events oder andere reaktive Mechanismen bereitstellen, um das `UserInterfaceModule` und das `StateManagementModule` über abgeschlossene Operationen, empfangene Daten oder Fehler zu informieren, ohne den Haupt-UI-Thread zu blockieren. Dies ist entscheidend für eine responsive Benutzeroberfläche.18

### Tabelle 2: Kern-UI-Module und MCP-Verantwortlichkeiten

|   |   |   |   |
|---|---|---|---|
|**Modulname**|**Kurzbeschreibung der Gesamtverantwortung**|**Primäre MCP-Interaktionen/Aufgaben**|**Wichtige Abhängigkeiten (Beispiele)**|
|`MCPConnectionModule`|Verwaltung des Lebenszyklus von MCP-Client-Verbindungen|`initialize`, `shutdown`, Transport-Handling (stdio/SSE), Senden/Empfangen roher JSON-RPC Nachrichten|Betriebssystem (Prozessmanagement, Netzwerk), JSON-Bibliothek|
|`ToolInteractionModule`|Orchestrierung von Tool-Auflistung und -Ausführung|`tools/list`, `tools/call`|`MCPConnectionModule`, `ConsentModule`, `StateManagementModule`|
|`ResourceInteractionModule`|Orchestrierung von Ressourcen-Auflistung und -Zugriff|`resources/list`, `resources/get`|`MCPConnectionModule`, `ConsentModule`, `StateManagementModule`|
|`PromptInteractionModule`|Handhabung von Prompt-Auflistung, -Auswahl und -Ausführung|`prompts/list`, `prompts/invoke`|`MCPConnectionModule`, `ConsentModule`, `StateManagementModule`, potenziell `ToolInteractionModule` / `ResourceInteractionModule`|
|`UserInterfaceModule`|Darstellung und Benutzerinteraktion mit MCP-Funktionen|Aufruf von Diensten der Interaktionsmodule, Anzeige von Daten und Zuständen|`StateManagementModule`, alle Interaktionsmodule, UI-Toolkit (z.B. GTK, Qt, Web-Framework)|
|`ConsentModule`|Einholung der Benutzerzustimmung für MCP-Aktionen|Anzeige von Zustimmungsdialogen, Verwaltung von Zustimmungsentscheidungen|`UserInterfaceModule` (für Dialogdarstellung), XDG Portal Bibliothek (optional)|
|`StateManagementModule`|Zentraler Speicher für reaktiven MCP-Zustand|Empfang und Bereitstellung von Status-Updates (Server, Tools, Ressourcen, Operationen)|Alle anderen MCP-Module (als Datenquelle oder -konsument)|

Diese Tabelle bietet eine klare Übersicht über die Aufteilung der Verantwortlichkeiten und dient als Grundlage für das detaillierte Design der einzelnen Module und ihrer Schnittstellen. Sie hilft Entwicklern, den Kontext ihrer Arbeit innerhalb der Gesamtarchitektur zu verstehen und die Interaktionspunkte zwischen den Modulen zu identifizieren.

### 2.3. Datenflussdiagramme für typische MCP-Operationen

Um das Zusammenspiel der Komponenten zu visualisieren, werden im Folgenden Datenflussdiagramme für typische MCP-Operationen skizziert. Diese basieren auf dem allgemeinen Workflow, wie er auch in 17 beschrieben wird (Connect, Discover, LLM chooses, Invoke, Return result).

#### 2.3.1. Tool-Auflistung und -Auswahl durch den Benutzer

Code-Snippet

```
sequenceDiagram
    participant Benutzer
    participant UserInterfaceModule (z.B. MCPSidebarView)
    participant ToolInteractionModule (ToolOrchestrationService)
    participant MCPConnectionModule (MCPClientInstance)
    participant ExternerMCPServer

    Benutzer->>UserInterfaceModule: Fordert Tool-Liste an (z.B. Klick auf "Tools anzeigen")
    UserInterfaceModule->>ToolInteractionModule: listAvailableTools()
    ToolInteractionModule->>MCPConnectionModule: Für jede aktive ClientInstance: listTools()
    MCPConnectionModule->>ExternerMCPServer: JSON-RPC Request (method: "tools/list")
    ExternerMCPServer-->>MCPConnectionModule: JSON-RPC Response (result:)
    MCPConnectionModule-->>ToolInteractionModule: Tool-Listen der Server
    ToolInteractionModule-->>UserInterfaceModule: Aggregierte und aufbereitete Tool-Liste
    UserInterfaceModule->>Benutzer: Zeigt verfügbare Tools an
    Benutzer->>UserInterfaceModule: Wählt ein Tool aus
    UserInterfaceModule->>Benutzer: Zeigt Parameter-Eingabefelder für ausgewähltes Tool an (via MCPWidgetFactory)
```

#### 2.3.2. Tool-Aufruf mit Benutzerzustimmung

Code-Snippet

```
sequenceDiagram
    participant Benutzer
    participant UserInterfaceModule (z.B. AICoPilotInterface oder Tool-Widget)
    participant ConsentModule (UserConsentUIManager)
    participant ToolInteractionModule (ToolOrchestrationService)
    participant MCPConnectionModule (MCPClientInstance)
    participant ExternerMCPServer
    participant XDGPortal (optional)

    Benutzer->>UserInterfaceModule: Löst Tool-Aufruf aus (z.B. mit eingegebenen Parametern)
    UserInterfaceModule->>ToolInteractionModule: callTool(toolId, params, parentWindowId)
    ToolInteractionModule->>ConsentModule: requestConsentForTool(toolDefinition, params, parentWindowId)
    ConsentModule->>XDGPortal: (Optional) Fordert System-Dialog an
    XDGPortal-->>ConsentModule: (Optional) Dialog-Ergebnis
    ConsentModule->>Benutzer: Zeigt Zustimmungsdialog an (falls nicht XDG oder als Fallback)
    Benutzer->>ConsentModule: Erteilt/Verweigert Zustimmung
    alt Zustimmung erteilt
        ConsentModule-->>ToolInteractionModule: Zustimmung = true
        ToolInteractionModule->>MCPConnectionModule: callTool(toolName, params) auf spezifischer ClientInstance
        MCPConnectionModule->>ExternerMCPServer: JSON-RPC Request (method: "tools/call", params: {name, arguments})
        ExternerMCPServer-->>MCPConnectionModule: JSON-RPC Response (result: ToolResult oder error)
        MCPConnectionModule-->>ToolInteractionModule: Ergebnis des Tool-Aufrufs
        ToolInteractionModule-->>UserInterfaceModule: Ergebnis/Fehler
        UserInterfaceModule->>Benutzer: Zeigt Ergebnis oder Fehlermeldung an
    else Zustimmung verweigert
        ConsentModule-->>ToolInteractionModule: Zustimmung = false
        ToolInteractionModule-->>UserInterfaceModule: Fehler (MCPConsentDeniedError)
        UserInterfaceModule->>Benutzer: Informiert über verweigerte Zustimmung
    end
```

#### 2.3.3. Ressourcenabruf

Der Datenfluss für den Ressourcenabruf ist analog zum Tool-Aufruf, wobei `ResourceInteractionModule` und `resources/get` (oder äquivalent) verwendet werden. Der Zustimmungsdialog würde sich auf den Zugriff auf spezifische Daten beziehen.

Diese Diagramme illustrieren die typischen Interaktionspfade und die involvierten Module. Sie verdeutlichen die Notwendigkeit einer klaren Aufgabenverteilung und gut definierter Schnittstellen zwischen den Modulen.

### 2.4. Spezifikation der globalen Ausnahmeklassen und Fehlerbehandlungsstrategie

Eine robuste Fehlerbehandlung ist entscheidend für die Stabilität und Benutzerfreundlichkeit der Anwendung. MCP-Interaktionen können aus vielfältigen Gründen fehlschlagen (Netzwerkprobleme, Serverfehler, ungültige Parameter, verweigerte Zustimmung etc.). Die UI muss diese Fehler angemessen behandeln und dem Benutzer verständliches Feedback geben.

Es wird eine Hierarchie von spezifischen Exception-Klassen für MCP-bezogene Fehler definiert. Alle MCP-spezifischen Ausnahmen sollten von einer gemeinsamen Basisklasse `MCPError` erben.

- **`MCPError` (Basisklasse)**
    
    - Attribute:
        - `message: string` (Benutzerfreundliche Standardnachricht oder Nachrichtenschlüssel für Internationalisierung)
        - `originalError?: Error` (Die ursprüngliche Ausnahme, z.B. ein Netzwerkfehler)
        - `jsonRpcError?: JsonRpcErrorObject` (Das JSON-RPC-Fehlerobjekt vom Server, falls vorhanden 5)
        - `isRecoverable: boolean` (Gibt an, ob der Fehler potenziell behebbar ist, z.B. durch einen erneuten Versuch)
    - Methoden: `getUserFriendlyMessage(locale: string): string`
- **Spezifische Ausnahmeklassen (erben von `MCPError`):**
    
    - **`MCPConnectionError extends MCPError`**: Fehler im Zusammenhang mit dem Aufbau oder der Aufrechterhaltung der Verbindung zum MCP-Server (z.B. Server nicht erreichbar, Transportfehler).
        - Zusätzliche Attribute: `serverId: ServerId`, `transportType: 'stdio' | 'sse'`.
    - **`MCPInitializationError extends MCPConnectionError`**: Fehler während der `initialize`-Phase der Verbindung.
    - **`MCPToolExecutionError extends MCPError`**: Fehler bei der Ausführung eines Tools auf dem Server, nachdem die Verbindung erfolgreich hergestellt und das Tool aufgerufen wurde.
        - Zusätzliche Attribute: `toolName: string`, `toolParams: object`.
    - **`MCPResourceAccessError extends MCPError`**: Fehler beim Zugriff auf eine Ressource.
        - Zusätzliche Attribute: `resourceName: string`.
    - **`MCPConsentDeniedError extends MCPError`**: Spezieller Fall, der signalisiert, dass der Benutzer die Zustimmung für eine Aktion verweigert hat. Dies ist technisch gesehen kein "Fehler", aber ein Grund für den Abbruch eines Workflows.
        - `isRecoverable` ist hier typischerweise `false` ohne erneute Benutzerinteraktion.
    - **`MCPInvalidResponseError extends MCPError`**: Die Antwort vom Server entsprach nicht dem erwarteten Format oder der MCP-Spezifikation.
    - **`MCPTimeoutError extends MCPError`**: Zeitüberschreitung beim Warten auf eine Antwort vom Server.

**Fehlerbehandlungsstrategie:**

1. **Erkennung:** Fehler werden entweder in der Transportlogik (z.B. Netzwerk-Timeouts), durch Prüfung der JSON-RPC-Error-Objekte in Serverantworten oder durch interne Validierungen im Client erkannt.
2. **Kapselung:** Der erkannte Fehler wird in eine der oben definierten spezifischen `MCPError`-Ausnahmeklassen gekapselt.
3. **Propagation:** Fehler werden von den unteren Schichten (z.B. `MCPClientInstance`) an die aufrufenden Dienste (z.B. `ToolOrchestrationService`) weitergegeben. Diese Dienste können versuchen, den Fehler zu behandeln (z.B. Retry bei `isRecoverable = true`) oder ihn an die UI-Komponenten weiterzureichen.
4. **Darstellung:** Die UI-Komponenten sind dafür verantwortlich, dem Benutzer eine verständliche Rückmeldung zu geben. Dies kann eine Benachrichtigung, ein Dialog oder eine Statusanzeige sein. Die Nachricht sollte auf `MCPError.getUserFriendlyMessage()` basieren.
    - Es muss klar zwischen technischen Fehlern (z.B. `MCPConnectionError`) und anwendungsspezifischen Fehlern (z.B. `MCPToolExecutionError` aufgrund ungültiger Parameter, die vom Server gemeldet werden) unterschieden werden. `MCPConsentDeniedError` sollte nicht als technischer Fehler, sondern als normaler, vom Benutzer initiierter Abbruch des Vorgangs dargestellt werden.
5. **Logging:** Alle MCP-Fehler **MÜSSEN** detailliert geloggt werden (siehe Abschnitt 7.4), inklusive des ursprünglichen Fehlers und des JSON-RPC-Fehlerobjekts, um die Diagnose zu erleichtern.

Diese strukturierte Fehlerbehandlung stellt sicher, dass Fehler konsistent gehandhabt werden und sowohl Entwickler als auch Benutzer angemessen informiert werden.

### Tabelle 4: Definierte Ausnahmeklassen für MCP-Interaktionen

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Klassenname**|**Erbt von**|**Beschreibung des Fehlerszenarios**|**Typische Auslöser**|**Wichtige Attribute (Beispiele)**|**Behandlungsempfehlung in der UI**|
|`MCPError`|(Basis)|Generischer MCP-Fehler|-|`message`, `originalError`, `jsonRpcError`, `isRecoverable`|Basis für spezifischere Meldungen, ggf. generische Fehlermeldung|
|`MCPConnectionError`|`MCPError`|Fehler beim Verbindungsaufbau oder -erhalt|Netzwerkprobleme, Server nicht gestartet, falsche Konfiguration (URL/Pfad)|`serverId`, `transportType`|Meldung "Verbindung zu Server X fehlgeschlagen", Option zum erneuten Versuch oder Überprüfung der Konfiguration|
|`MCPInitializationError`|`MCPConnectionError`|Fehler während der `initialize`-Phase|Inkompatible Protokollversionen, Server lehnt Client ab|-|Meldung "Initialisierung mit Server X fehlgeschlagen", Details aus `jsonRpcError` anzeigen|
|`MCPToolExecutionError`|`MCPError`|Fehler bei der Ausführung eines Tools serverseitig|Ungültige Tool-Parameter, serverseitige Logikfehler im Tool, fehlende Berechtigungen des Servers|`toolName`, `toolParams`|Meldung "Tool X konnte nicht ausgeführt werden", Details aus `jsonRpcError` (falls vorhanden) anzeigen|
|`MCPResourceAccessError`|`MCPError`|Fehler beim Zugriff auf eine Ressource|Ressource nicht gefunden, Zugriff verweigert (serverseitig)|`resourceName`|Meldung "Ressource X konnte nicht abgerufen werden", Details anzeigen|
|`MCPConsentDeniedError`|`MCPError`|Benutzer hat die Zustimmung verweigert|Benutzer klickt "Ablehnen" im Zustimmungsdialog|-|Keine Fehlermeldung, sondern neutrale Info "Aktion vom Benutzer abgebrochen" oder UI kehrt zum vorherigen Zustand zurück|
|`MCPInvalidResponseError`|`MCPError`|Antwort vom Server ist nicht valide (Format, Schema)|Server-Bug, Protokollverletzung|-|Technische Fehlermeldung (primär für Logs), Benutzerinfo "Unerwartete Antwort vom Server"|
|`MCPTimeoutError`|`MCPError`|Zeitüberschreitung beim Warten auf Serverantwort|Langsames Netzwerk, überlasteter Server, Server antwortet nicht|`timeoutDuration`|Meldung "Keine Antwort von Server X innerhalb der Zeitgrenze", Option zum erneuten Versuch|

## 3. Spezifikation der MCP-Client-Management-Komponenten

Dieser Abschnitt detailliert die Komponenten innerhalb der UI-Host-Anwendung, die für die Erstellung, Verwaltung und Kommunikation der MCP-Client-Instanzen zuständig sind. Diese Komponenten bilden das Fundament für alle MCP-Interaktionen.

### 3.1. `MCPConnectionService`

- Zweck:
    
    Der MCPConnectionService ist der zentrale Dienst für die Verwaltung des gesamten Lebenszyklus aller MCPClientInstance-Objekte. Er ist verantwortlich für das dynamische Erstellen, Starten, Stoppen und Überwachen von Verbindungen zu verschiedenen MCP-Servern. Diese Aktionen basieren auf Benutzerkonfigurationen (z.B. aus einer mcp.json-Datei 10) oder auf dynamischen Anforderungen der Anwendung. Der Dienst stellt sicher, dass die UI stets einen aktuellen Überblick über alle aktiven und potenziellen MCP-Verbindungen hat.
    
- **Eigenschaften:**
    
    - `private static instance: MCPConnectionService | null = null;`
        - Für Singleton-Implementierung.
    - `private activeConnections: Map<ServerId, MCPClientInstance> = new Map();`
        - Eine Map, die alle aktiven `MCPClientInstance`-Objekte verwaltet. Der Schlüssel `ServerId` ist eine eindeutige Kennung für einen MCP-Server (z.B. eine aus der Konfiguration abgeleitete ID oder die Server-URL).
    - `private serverConfigurations: Map<ServerId, MCPServerConfig> = new Map();`
        - Eine Map, die die Konfigurationen aller bekannten MCP-Server speichert, typischerweise geladen beim Start der Anwendung.
- **Methoden:**
    
    - `public static getInstance(): MCPConnectionService`
        - **Signatur:** `public static getInstance(): MCPConnectionService noexcept`
        - **Beschreibung:** Implementiert das Singleton-Pattern. Gibt die einzige Instanz des `MCPConnectionService` zurück. Erstellt die Instanz beim ersten Aufruf.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt eine valide Instanz von `MCPConnectionService` zurück.
    - `public async loadAndInitializeConnections(configs: MCPServerConfig): Promise<void>`
        - **Signatur:** `public async loadAndInitializeConnections(configs: MCPServerConfig): Promise<void>`
        - **Beschreibung:** Lädt eine Liste von Serverkonfigurationen, speichert sie in `serverConfigurations` und versucht, für jede Konfiguration eine Verbindung herzustellen und zu initialisieren. Iteriert über `configs`, erstellt für jede eine `MCPClientInstance` (falls nicht bereits vorhanden und unterschiedlich konfiguriert) und ruft deren `connectAndInitialize()` Methode auf. Fehler beim Verbindungsaufbau zu einzelnen Servern dürfen den Prozess für andere Server nicht blockieren.
        - **Parameter:**
            - `configs: MCPServerConfig`: Eine Liste von Serverkonfigurationsobjekten.
        - **Vorbedingungen:** `configs` ist ein valides Array.
        - **Nachbedingungen:** Für jede Konfiguration in `configs` wurde versucht, eine `MCPClientInstance` zu erstellen und zu initialisieren. `activeConnections` und `serverConfigurations` sind aktualisiert. Entsprechende Events (`ServerConnectionStatusChanged`, `ClientInstanceAdded`) wurden ausgelöst.
        - **Ausnahmen:** Kann `MCPError` werfen, wenn ein grundlegender Fehler beim Laden der Konfigurationen auftritt (selten, da einzelne Verbindungsfehler intern behandelt werden sollten).
    - `public async connectToServer(config: MCPServerConfig): Promise<MCPClientInstance | MCPError>`
        - **Signatur:** `public async connectToServer(config: MCPServerConfig): Promise<MCPClientInstance | MCPError>`
        - **Beschreibung:** Stellt explizit eine Verbindung zu einem einzelnen, spezifizierten MCP-Server her und initialisiert diese. Erstellt eine neue `MCPClientInstance` basierend auf der `config`, fügt sie zu `activeConnections` hinzu und ruft `connectAndInitialize()` auf. Gibt die `MCPClientInstance` bei Erfolg oder ein `MCPError`-Objekt bei Fehlschlag zurück.
        - **Parameter:**
            - `config: MCPServerConfig`: Die Konfiguration des zu verbindenden Servers.
        - **Vorbedingungen:** `config` ist ein valides Objekt.
        - **Nachbedingungen:** Eine `MCPClientInstance` wurde erstellt und versucht zu verbinden. `activeConnections` ist aktualisiert. Events wurden ausgelöst.
    - `public async disconnectFromServer(serverId: ServerId): Promise<void | MCPError>`
        - **Signatur:** `public async disconnectFromServer(serverId: ServerId): Promise<void | MCPError>`
        - **Beschreibung:** Trennt die Verbindung zu einem bestimmten MCP-Server und entfernt die zugehörige `MCPClientInstance` aus der Verwaltung. Ruft `shutdown()` auf der `MCPClientInstance` auf, bevor sie aus `activeConnections` entfernt wird.
        - **Parameter:**
            - `serverId: ServerId`: Die ID des Servers, dessen Verbindung getrennt werden soll.
        - **Vorbedingungen:** `serverId` ist eine gültige ID eines potenziell aktiven Servers.
        - **Nachbedingungen:** Die Verbindung zum Server wurde (versucht zu) getrennt und die `MCPClientInstance` wurde aus `activeConnections` entfernt. `ClientInstanceRemoved`-Event wurde ausgelöst.
    - `public getClientInstance(serverId: ServerId): MCPClientInstance | undefined`
        - **Signatur:** `public getClientInstance(serverId: ServerId): MCPClientInstance | undefined noexcept`
        - **Beschreibung:** Gibt die aktive `MCPClientInstance` für eine gegebene `ServerId` zurück, falls vorhanden.
        - **Parameter:**
            - `serverId: ServerId`: Die ID des gesuchten Servers.
        - **Rückgabewert:** Die `MCPClientInstance` oder `undefined`.
    - `public getAllClientInstances(): MCPClientInstance`
        - **Signatur:** `public getAllClientInstances(): MCPClientInstance noexcept`
        - **Beschreibung:** Gibt eine Liste aller aktuell aktiven `MCPClientInstance`-Objekte zurück.
        - **Rückgabewert:** Ein Array von `MCPClientInstance`-Objekten.
    - `public subscribeToServerStatusChanges(serverId: ServerId, callback: (status: ConnectionStatus, clientInstance?: MCPClientInstance, error?: MCPError) => void): UnsubscribeFunction`
        - **Signatur:** `public subscribeToServerStatusChanges(serverId: ServerId, callback: (status: ConnectionStatus, clientInstance?: MCPClientInstance, error?: MCPError) => void): UnsubscribeFunction noexcept`
        - **Beschreibung:** Ermöglicht anderen UI-Teilen oder Diensten, Änderungen im Verbindungsstatus eines spezifischen Servers zu abonnieren. Der Callback wird aufgerufen, wenn sich der `connectionStatus` der entsprechenden `MCPClientInstance` ändert.
        - **Parameter:**
            - `serverId: ServerId`: Die ID des zu beobachtenden Servers.
            - `callback`: Die Funktion, die bei Statusänderungen aufgerufen wird.
        - **Rückgabewert:** Eine `UnsubscribeFunction`, die aufgerufen werden kann, um das Abonnement zu beenden.
    - `public subscribeToClientListChanges(callback: (clients: MCPClientInstance) => void): UnsubscribeFunction`
        - **Signatur:** `public subscribeToClientListChanges(callback: (clients: MCPClientInstance) => void): UnsubscribeFunction noexcept`
        - **Beschreibung:** Benachrichtigt Abonnenten, wenn `MCPClientInstance`s hinzugefügt oder entfernt werden (d.h., die Liste der aktiven Verbindungen ändert sich).
        - **Parameter:**
            - `callback`: Die Funktion, die bei Änderungen aufgerufen wird und die aktuelle Liste der Clients erhält.
        - **Rückgabewert:** Eine `UnsubscribeFunction`.
- **Events (ausgehend, intern über ein Event-Bus-System oder direkt an Abonnenten):**
    
    - **`ServerConnectionStatusChanged`**
        - **Payload:** `{ serverId: ServerId, newStatus: ConnectionStatus, clientInstance?: MCPClientInstance, error?: MCPError }`
        - **Beschreibung:** Wird ausgelöst, wenn sich der `connectionStatus` einer `MCPClientInstance` ändert.
    - **`ClientInstanceAdded`**
        - **Payload:** `{ client: MCPClientInstance }`
        - **Beschreibung:** Wird ausgelöst, nachdem eine neue `MCPClientInstance` erfolgreich erstellt und initial mit dem Verbindungsaufbau begonnen wurde.
    - **`ClientInstanceRemoved`**
        - **Payload:** `{ serverId: ServerId, reason?: 'disconnected' | 'error' }`
        - **Beschreibung:** Wird ausgelöst, nachdem eine `MCPClientInstance` entfernt wurde (z.B. nach `disconnectFromServer` oder einem fatalen Fehler).
- **Zustandsdiagramm für `MCPConnectionService`:**
    
    Code-Snippet
    
    ```
    stateDiagram-v2
        [*] --> Idle
        Idle --> InitializingConnections : loadAndInitializeConnections()
        InitializingConnections --> Running : Alle initialen Verbindungsversuche abgeschlossen
        Running --> Running : connectToServer() / disconnectFromServer()
        Running --> Idle : shutdownAllConnections() (hypothetische Methode für Anwendungsende)
    ```
    
    (Hinweis: Die Zustände einer einzelnen `MCPClientInstance` sind komplexer und werden dort beschrieben.)
    
- Fehlerbehandlung:
    
    Der MCPConnectionService fängt Fehler von den MCPClientInstance-Methoden (connectAndInitialize, shutdown) ab. Diese Fehler werden geloggt und über das ServerConnectionStatusChanged-Event mit dem Status Error und dem entsprechenden MCPError-Objekt signalisiert. Kritische Fehler, die den Service selbst betreffen (z.B. Speicherprobleme), sollten als schwerwiegende Anwendungsfehler behandelt werden.
    

Der `MCPConnectionService` ist der zentrale Dreh- und Angelpunkt für die gesamte MCP-Konnektivität der UI. Seine Fähigkeit, mehrere Verbindungen – auch fehlerhafte – effizient und robust zu managen, ist entscheidend für die Stabilität der MCP-Funktionen. Da Verbindungen potenziell parallel aufgebaut oder abgebaut werden könnten (z.B. durch Benutzeraktionen oder bei Anwendungsstart), muss der Zugriff auf geteilte Zustände wie `activeConnections` und `serverConfigurations` Thread-sicher gestaltet sein, falls die zugrundeliegende Plattform dies erfordert (z.B. durch Mutexe oder andere Synchronisationsprimitive).

### 3.2. `MCPClientInstance`

- Zweck:
    
    Die MCPClientInstance repräsentiert und verwaltet die aktive Kommunikationssitzung mit einem einzelnen MCP-Server. Sie kapselt die Details der JSON-RPC-Nachrichtenübertragung für diesen spezifischen Server, den Verbindungslebenszyklus (Initialisierung, Betrieb, Beendigung) und den aktuellen Zustand dieser Verbindung. Jede Instanz ist für genau einen Server zuständig, wie durch ihre Konfiguration definiert.
    
- **Eigenschaften:**
    
    - `public readonly serverId: ServerId`
        - Eindeutige Kennung des Servers, abgeleitet aus der `MCPServerConfig`.
    - `public readonly config: MCPServerConfig`
        - Das Konfigurationsobjekt, das zur Erstellung dieser Instanz verwendet wurde. Enthält Informationen wie Transporttyp, URL/Kommando etc.
    - `private currentProtocolVersion: string | null = null;`
        - Die vom Server während der `initialize`-Phase gemeldete Protokollversion.5
    - `private serverCapabilitiesInternal: ServerCapabilities | null = null;`
        - Die vom Server während der `initialize`-Phase gemeldeten Fähigkeiten (unterstützte Tools, Ressourcen, Prompts etc.).5
    - `public readonly clientCapabilities: ClientCapabilities;`
        - Die Fähigkeiten, die dieser Client dem Server anbietet (z.B. Unterstützung für `sampling` 3). Wird im Konstruktor gesetzt.
    - `private currentConnectionStatus: ConnectionStatus = ConnectionStatus.Idle;`
        - Der aktuelle Zustand der Verbindung. Enum: `Idle`, `Connecting`, `Initializing`, `Connected`, `Reconnecting`, `Disconnecting`, `Disconnected`, `Error`.
    - `private lastErrorEncountered: MCPError | null = null;`
        - Das letzte aufgetretene `MCPError`-Objekt für diese Verbindung.
    - `private transportHandler: IMCPTransport;`
        - Eine Instanz eines Transport-Handlers (z.B. `StdioTransportHandler` oder `SSETransportHandler`), der für die tatsächliche Nachrichtenübertragung zuständig ist. Wird basierend auf `config.transportType` instanziiert.
    - `private pendingRequests: Map<string | number, (response: JsonRpcResponse | JsonRpcError) => void> = new Map();`
        - Verwaltet Callbacks für ausstehende JSON-RPC-Anfragen anhand ihrer `id`.
    - `private notificationSubscribers: Map<string, Array<(notification: JsonRpcNotification) => void>> = new Map();` // Key: method name or '*' for all
        - Verwaltet Abonnenten für serverseitige Notifications.
- **Methoden:**
    
    - `public constructor(config: MCPServerConfig, clientCapabilities: ClientCapabilities)`
        - **Signatur:** `public constructor(config: MCPServerConfig, clientCapabilities: ClientCapabilities)`
        - **Beschreibung:** Initialisiert eine neue `MCPClientInstance`. Setzt `serverId`, `config`, `clientCapabilities`. Instanziiert den passenden `transportHandler` basierend auf `config.transportType`. Registriert einen internen Handler beim `transportHandler` für eingehende Nachrichten (Responses, Notifications).
        - **Vorbedingungen:** `config` und `clientCapabilities` sind valide.
        - **Nachbedingungen:** Die Instanz ist initialisiert und bereit für `connectAndInitialize()`.
    - `public async connectAndInitialize(): Promise<void | MCPError>`
        - **Signatur:** `public async connectAndInitialize(): Promise<void | MCPError>`
        - **Beschreibung:**
            1. Setzt `currentConnectionStatus` auf `Connecting`. Löst `StatusChanged`-Event aus.
            2. Ruft `transportHandler.connect()` auf. Bei Fehler: Setzt Status auf `Error`, speichert Fehler, löst Event aus, gibt Fehler zurück.
            3. Setzt `currentConnectionStatus` auf `Initializing`. Löst Event aus.
            4. Baut die `initialize`-Nachricht zusammen (siehe unten, basierend auf 5).
            5. Sendet die `initialize`-Nachricht über `this.sendRequestInternal(...)`.
            6. Bei Erfolg: Verarbeitet die Antwort, setzt `currentProtocolVersion` und `serverCapabilitiesInternal`. Setzt `currentConnectionStatus` auf `Connected`. Löst `StatusChanged`- und `CapabilitiesChanged`-Events aus. Gibt `void` zurück.
            7. Bei Fehler: Setzt Status auf `Error`, speichert Fehler, löst Event aus, gibt `MCPInitializationError` zurück.
        - **`initialize`-Request-Struktur (Beispiel):**
            
            JSON
            
            ```
            {
              "jsonrpc": "2.0",
              "id": "generierte_eindeutige_id_1",
              "method": "initialize",
              "params": {
                "protocolVersion": "2025-03-26", // Aktuell unterstützte MCP-Version
                "capabilities": { // this.clientCapabilities
                  "sampling": { /* ggf. Optionen für Sampling */ }
                },
                "clientInfo": {
                  "name": "MeineSuperUIAnwendung",
                  "version": "1.0.0"
                }
              }
            }
            ```
            
        - **`initialize`-Response-Verarbeitung:** Speichert `result.serverInfo`, `result.capabilities` (z.B. `result.capabilities.tools`, `result.capabilities.resources`, `result.capabilities.prompts`), `result.protocolVersion` in den internen Eigenschaften.
    - `public async shutdown(): Promise<void>`
        - **Signatur:** `public async shutdown(): Promise<void>`
        - **Beschreibung:**
            1. Setzt `currentConnectionStatus` auf `Disconnecting`. Löst Event aus.
            2. Versucht, eine `shutdown`-Nachricht an den Server zu senden (falls im MCP-Standard für den Client vorgesehen und der Server verbunden ist). Dies ist oft eine Notification.
            3. Ruft `transportHandler.disconnect()` auf.
            4. Setzt `currentConnectionStatus` auf `Disconnected`. Löst Event aus. Bereinigt interne Zustände (z.B. `pendingRequests`).
    - `public async callTool(toolName: string, params: object): Promise<ToolResult | MCPError>`
        - **Signatur:** `public async callTool(toolName: string, params: object): Promise<any | MCPError>` (Rückgabetyp `any` für `ToolResult`, da tool-spezifisch)
        - **Beschreibung:** Sendet eine `tools/call`-Nachricht an den Server.17
            1. Prüft, ob `currentConnectionStatus === ConnectionStatus.Connected`. Wenn nicht, gibt `MCPConnectionError` zurück.
            2. Baut die `tools/call`-Request-Nachricht:
                
                JSON
                
                ```
                {
                  "jsonrpc": "2.0",
                  "id": "generierte_eindeutige_id_N",
                  "method": "tools/call",
                  "params": { "name": toolName, "arguments": params }
                }
                ```
                
            3. Sendet die Nachricht über `this.sendRequestInternal(...)`.
            4. Gibt das `result` der Antwort oder ein `MCPToolExecutionError` zurück.
    - `public async listTools(): Promise<ToolDefinition | MCPError>`
        - **Signatur:** `public async listTools(): Promise<ToolDefinition | MCPError>`
        - **Beschreibung:** Sendet eine `tools/list`-Nachricht.17
            1. Prüft `currentConnectionStatus`.
            2. Request: `{ "jsonrpc": "2.0", "id": "...", "method": "tools/list", "params": {} }`
            3. Sendet via `this.sendRequestInternal(...)`.
            4. Gibt `result` (Array von `ToolDefinition`) oder `MCPError` zurück.
    - `public async getResource(resourceName: string, params?: object): Promise<any | MCPError>` (analog zu `callTool`, Methode z.B. `resources/get`)
    - `public async listResources(): Promise<ResourceDefinition | MCPError>` (analog zu `listTools`, Methode z.B. `resources/list`)
    - `public async invokePrompt(promptName: string, params?: object): Promise<any | MCPError>` (analog zu `callTool`, Methode z.B. `prompts/invoke`)
    - `public async listPrompts(): Promise<PromptDefinition | MCPError>` (analog zu `listTools`, Methode z.B. `prompts/list`)
    - `public async ping(): Promise<any | MCPError>`
        - **Signatur:** `public async ping(): Promise<any | MCPError>`
        - **Beschreibung:** Sendet eine `ping`-Nachricht.5
            1. Prüft `currentConnectionStatus`.
            2. Request: `{ "jsonrpc": "2.0", "id": "...", "method": "ping", "params": {} }` (oder spezifische Ping-Daten)
            3. Sendet via `this.sendRequestInternal(...)`.
            4. Gibt `result` oder `MCPError` zurück.
    - `public async cancelRequest(idToCancel: string | number): Promise<void | MCPError>`
        - **Signatur:** `public async cancelRequest(idToCancel: string | number): Promise<void | MCPError>`
        - **Beschreibung:** Sendet eine `$/cancelRequest`-Notification, um eine vorherige Anfrage abzubrechen.3
            1. Prüft `currentConnectionStatus`.
            2. Notification: `{ "jsonrpc": "2.0", "method": "$/cancelRequest", "params": { "id": idToCancel } }`
            3. Sendet via `this.sendNotificationInternal(...)`.
    - `private async sendRequestInternal<TParams, TResult>(method: string, params: TParams): Promise<TResult | MCPError>`
        - **Beschreibung:** Interne Hilfsmethode. Generiert eine eindeutige `id`, erstellt das `JsonRpcRequest`-Objekt, registriert einen Callback in `pendingRequests` und sendet die Nachricht über `transportHandler.sendMessage()`. Gibt ein Promise zurück, das mit dem Ergebnis oder einem Fehlerobjekt aufgelöst wird.
    - `private async sendNotificationInternal<TParams>(method: string, params: TParams): Promise<void | MCPError>`
        - **Beschreibung:** Interne Hilfsmethode zum Senden von JSON-RPC-Notifications (ohne `id`). Sendet über `transportHandler.sendMessage()`.
    - `private handleIncomingMessage(message: JsonRpcResponse | JsonRpcError | JsonRpcNotification): void`
        - **Beschreibung:** Wird vom `transportHandler` aufgerufen. Unterscheidet, ob es eine Response auf eine `pendingRequest` ist (dann Callback aufrufen und aus Map entfernen) oder eine Notification (dann registrierte `notificationSubscribers` informieren).
    - `public subscribeToNotifications(methodFilter: string | null, callback: (notification: JsonRpcNotification) => void): UnsubscribeFunction`
        - **Signatur:** `public subscribeToNotifications(methodFilter: string | null, callback: (notification: JsonRpcNotification<any>) => void): UnsubscribeFunction noexcept`
        - **Beschreibung:** Ermöglicht das Abonnieren von serverseitigen Notifications. `methodFilter` kann ein spezifischer Methodenname (z.B. `$/progress`) oder `null` (oder `'*'`) für alle Notifications sein.
        - **Rückgabewert:** Eine `UnsubscribeFunction`.
    - `public getConnectionStatus(): ConnectionStatus`
        - **Signatur:** `public getConnectionStatus(): ConnectionStatus noexcept`
    - `public getLastError(): MCPError | null`
        - **Signatur:** `public getLastError(): MCPError | null noexcept`
    - `public getServerCapabilities(): ServerCapabilities | null`
        - **Signatur:** `public getServerCapabilities(): ServerCapabilities | null noexcept`
- **Events (ausgehend, typischerweise an den `MCPConnectionService` oder einen internen Event-Bus):**
    
    - **`StatusChanged`**
        - **Payload:** `{ newStatus: ConnectionStatus, error?: MCPError }`
    - **`CapabilitiesChanged`**
        - **Payload:** `{ newCapabilities: ServerCapabilities }` (nach erfolgreicher Initialisierung)
    - **`NotificationReceived`**
        - **Payload:** `{ notification: JsonRpcNotification }` (z.B. für `$/progress`)
- Interaktion mit IMCPTransport:
    
    Die MCPClientInstance verwendet eine Instanz, die die folgende Schnittstelle IMCPTransport implementiert:
    
    TypeScript
    
    ```
    interface IMCPTransport {
        connect(): Promise<void | MCPError>;
        disconnect(): Promise<void>;
        sendMessage(message: JsonRpcRequest | JsonRpcNotification): Promise<void | MCPError>; // Sendet, erwartet keine direkte Antwort hier
        registerMessageHandler(handler: (message: JsonRpcResponse | JsonRpcError | JsonRpcNotification) => void): void;
        // Optional: getTransportStatus(): TransportStatusEnum;
    }
    ```
    
    Konkrete Implementierungen sind `StdioTransportHandler` und `SSETransportHandler`. Der `StdioTransportHandler` würde Methoden zum Starten und Überwachen des Kindprozesses sowie zum Lesen/Schreiben von dessen `stdin`/`stdout` kapseln.7 Der `SSETransportHandler` würde die HTTP-Verbindung und den SSE-Eventstream verwalten.20
    

Die MCPClientInstance ist der Kern der Protokollimplementierung für eine einzelne Serververbindung. Sie muss die JSON-RPC-Spezifikation exakt umsetzen, die Zustandsübergänge der Verbindung sauber managen und eine klare Schnittstelle für das Senden von Anfragen und den Empfang von Antworten und Notifications bieten. Die Abstraktion des Transports durch IMCPTransport ist entscheidend für die Flexibilität, verschiedene Kommunikationswege zu unterstützen, ohne die Kernlogik der MCPClientInstance ändern zu müssen.

Die während der Initialisierung vom Server empfangenen serverCapabilities 5 sind von entscheidender Bedeutung. Sie informieren die UI darüber, welche Tools, Ressourcen und Prompts der verbundene Server überhaupt anbietet. Diese Informationen müssen von der MCPClientInstance persistent gehalten (für die Dauer der Sitzung) und den übergeordneten UI-Diensten (wie ToolOrchestrationService, siehe Abschnitt 4) zur Verfügung gestellt werden. Diese Dienste nutzen die Fähigkeiten, um die Benutzeroberfläche dynamisch anzupassen – beispielsweise, um zu entscheiden, welche Menüeinträge, Schaltflächen oder Optionen dem Benutzer für die Interaktion mit diesem spezifischen Server angezeigt werden. Ohne Kenntnis der serverCapabilities wüsste die UI nicht, welche Operationen sie dem Server anbieten kann.

## 4. Spezifikation der Kern-UI-Interaktionsdienste für MCP

Diese Dienste bauen auf dem `MCPConnectionService` und den einzelnen `MCPClientInstance`s auf. Sie bieten eine höhere Abstraktionsebene für UI-Komponenten, um mit MCP-Funktionalitäten zu interagieren. Ihre Hauptaufgaben umfassen die Aggregation von Informationen über mehrere Server hinweg, die Orchestrierung von komplexeren Arbeitsabläufen (wie Tool-Aufrufe inklusive Benutzerzustimmung) und die Bereitstellung eines konsolidierten Zustands für die UI.

### 4.1. `ToolOrchestrationService`

- Zweck:
    
    Der ToolOrchestrationService ist der zentrale Dienst für alle Interaktionen, die MCP-Tools betreffen. Er bietet Funktionen zur Auflistung aller verfügbaren Tools von allen verbundenen und initialisierten MCP-Servern, zur Initiierung von Tool-Aufrufen (wobei er die notwendige Benutzerzustimmung über den UserConsentUIManager einholt) und zur Weiterleitung und initialen Verarbeitung der Ergebnisse dieser Aufrufe.
    
- **Eigenschaften:**
    
    - `private mcpConnectionService: MCPConnectionService;`
        - Abhängigkeit zum `MCPConnectionService`, um Zugriff auf die aktiven `MCPClientInstance`s zu erhalten. Wird typischerweise per Dependency Injection injiziert.
    - `private userConsentUIManager: UserConsentUIManager;`
        - Abhängigkeit zum `UserConsentUIManager` (siehe Abschnitt 4.4) für die Einholung der Benutzerzustimmung.
    - `private availableToolsCache: Map<GlobalToolId, ToolDefinitionExtended> = new Map();`
        - Ein interner Cache, der eine aggregierte Liste aller bekannten Tools von allen verbundenen Servern hält. `GlobalToolId` ist eine eindeutige Kennung für ein Tool über alle Server hinweg (z.B. eine Kombination aus `ServerId` und `tool.name`, um Namenskonflikte zwischen Tools verschiedener Server zu vermeiden). `ToolDefinitionExtended` erweitert die Standard-`ToolDefinition` um die `ServerId` und ggf. weitere UI-relevante Metadaten.
    - `private static instance: ToolOrchestrationService | null = null;`
- **Methoden:**
    
    - `public static getInstance(connService: MCPConnectionService, consentUIManager: UserConsentUIManager): ToolOrchestrationService`
        - **Signatur:** `public static getInstance(connService: MCPConnectionService, consentUIManager: UserConsentUIManager): ToolOrchestrationService noexcept`
        - **Beschreibung:** Singleton-Zugriffsmethode.
    - `public async refreshAvailableTools(): Promise<ToolDefinitionExtended>`
        - **Signatur:** `public async refreshAvailableTools(): Promise<ToolDefinitionExtended>`
        - **Beschreibung:** Fordert von allen aktiven und verbundenen `MCPClientInstance`s (via `mcpConnectionService.getAllClientInstances()`) deren Tool-Listen an (durch Aufruf von `client.listTools()`). Aggregiert diese Listen, erstellt `GlobalToolId`s, aktualisiert den `availableToolsCache` und gibt die vollständige, aktualisierte Liste zurück. Löst das `ToolListUpdated`-Event aus.
        - **Rückgabewert:** Ein Promise, das mit einem Array von `ToolDefinitionExtended` aufgelöst wird.
        - **Ausnahmen:** Kann Fehler von `client.listTools()` sammeln und aggregiert melden oder einzelne Fehler loggen und nur erfolgreiche Ergebnisse zurückgeben.
    - `public getAvailableTools(): ToolDefinitionExtended`
        - **Signatur:** `public getAvailableTools(): ToolDefinitionExtended noexcept`
        - **Beschreibung:** Gibt die aktuell im Cache gehaltene Liste aller verfügbaren Tools zurück. Ruft nicht aktiv `refreshAvailableTools` auf.
    - `public async callTool(toolId: GlobalToolId, params: object, parentWindowId?: WindowIdentifier): Promise<any | MCPError | MCPConsentDeniedError>`
        - **Signatur:** `public async callTool(toolId: GlobalToolId, params: object, parentWindowId?: WindowIdentifier): Promise<any | MCPError | MCPConsentDeniedError>`
        - **Beschreibung:** Führt ein spezifisches Tool aus:
            1. Ermittelt die `ToolDefinitionExtended` und die zugehörige `ServerId` aus `toolId` und dem `availableToolsCache`. Falls nicht gefunden, wird ein Fehler zurückgegeben.
            2. Ermittelt die zuständige `MCPClientInstance` über `mcpConnectionService.getClientInstance(serverId)`. Falls nicht gefunden oder nicht verbunden, wird ein `MCPConnectionError` zurückgegeben.
            3. Ruft `userConsentUIManager.requestConsentForTool(toolDefinition, params, parentWindowId)` auf, um die explizite Zustimmung des Benutzers einzuholen.10
            4. Wenn die Zustimmung verweigert wird, wird ein `MCPConsentDeniedError` zurückgegeben.
            5. Wenn die Zustimmung erteilt wird: Löst das `ToolCallStarted`-Event aus. Ruft `clientInstance.callTool(toolDefinition.name, params)` auf.9
            6. Das Ergebnis (Erfolg oder Fehler von `clientInstance.callTool`) wird zurückgegeben. Löst das `ToolCallCompleted`-Event aus.
        - **Parameter:**
            - `toolId: GlobalToolId`: Die eindeutige ID des auszuführenden Tools.
            - `params: object`: Die Parameter für den Tool-Aufruf.
            - `parentWindowId?: WindowIdentifier`: Optionale Kennung des Elternfensters für den Zustimmungsdialog.16
        - **Rückgabewert:** Ein Promise, das mit dem Tool-Ergebnis, einem `MCPError` oder einem `MCPConsentDeniedError` aufgelöst wird.
    - `public getToolDefinition(toolId: GlobalToolId): ToolDefinitionExtended | undefined`
        - **Signatur:** `public getToolDefinition(toolId: GlobalToolId): ToolDefinitionExtended | undefined noexcept`
        - **Beschreibung:** Gibt die zwischengespeicherte `ToolDefinitionExtended` für eine gegebene `GlobalToolId` zurück.
- **Events (ausgehend, über einen Event-Bus oder direkt an Abonnenten):**
    
    - **`ToolListUpdated`**
        - **Payload:** `{ tools: ToolDefinitionExtended }`
        - **Beschreibung:** Wird ausgelöst, nachdem `refreshAvailableTools` erfolgreich neue Tool-Definitionen geladen hat.
    - **`ToolCallStarted`**
        - **Payload:** `{ toolId: GlobalToolId, params: object }`
        - **Beschreibung:** Wird ausgelöst, unmittelbar bevor `clientInstance.callTool` aufgerufen wird (nach erteilter Zustimmung).
    - **`ToolCallCompleted`**
        - **Payload:** `{ toolId: GlobalToolId, result: any | MCPError }` (wobei `result` nicht `MCPConsentDeniedError` sein wird, da dies vorher behandelt wird)
        - **Beschreibung:** Wird ausgelöst, nachdem der Aufruf von `clientInstance.callTool` abgeschlossen ist, entweder erfolgreich oder mit einem Fehler.

Dieser Dienst entkoppelt die spezifische UI-Logik (z.B. ein Button-Klick in einem Widget) vom direkten Management der `MCPClientInstance`. Er zentralisiert die Logik für Tool-Interaktionen, insbesondere die kritische Überprüfung der Benutzerzustimmung, und stellt eine konsistente Schnittstelle für alle UI-Teile bereit, die Tools ausführen müssen. Die Verwendung einer `GlobalToolId` und der `ToolDefinitionExtended` (welche die `ServerId` enthält) ist hierbei entscheidend. Es ist durchaus möglich, dass zwei verschiedene MCP-Server Tools mit identischen Namen anbieten (z.B. ein Tool namens `search`). Um diese eindeutig identifizieren und den Aufruf an die korrekte `MCPClientInstance` weiterleiten zu können, muss die `ServerId` Teil der globalen Tool-Identifikation sein. Der `ToolOrchestrationService` stellt diese Eindeutigkeit sicher und leitet Anfragen korrekt weiter.

### 4.2. `ResourceAccessService`

- Zweck:
    
    Der ResourceAccessService ist das Pendant zum ToolOrchestrationService, jedoch spezialisiert auf MCP-Ressourcen. Er stellt Funktionen zur Auflistung aller verfügbaren Ressourcen von allen verbundenen MCP-Servern, zum Abruf von Ressourcendaten (inklusive Einholung der Benutzerzustimmung für den Datenzugriff) und zur Verarbeitung der Ergebnisse bereit.
    
- **Eigenschaften:**
    
    - `private mcpConnectionService: MCPConnectionService;` (Abhängigkeit)
    - `private userConsentUIManager: UserConsentUIManager;` (Abhängigkeit)
    - `private availableResourcesCache: Map<GlobalResourceId, ResourceDefinitionExtended> = new Map();`
        - Analoger Cache wie bei Tools. `GlobalResourceId` (z.B. `serverId + ":" + resourceName`). `ResourceDefinitionExtended` enthält die `ResourceDefinition` plus `serverId`.
    - `private static instance: ResourceAccessService | null = null;`
- **Methoden:**
    
    - `public static getInstance(connService: MCPConnectionService, consentUIManager: UserConsentUIManager): ResourceAccessService`
        - **Signatur:** `public static getInstance(connService: MCPConnectionService, consentUIManager: UserConsentUIManager): ResourceAccessService noexcept`
    - `public async refreshAvailableResources(): Promise<ResourceDefinitionExtended>`
        - **Signatur:** `public async refreshAvailableResources(): Promise<ResourceDefinitionExtended>`
        - **Beschreibung:** Analog zu `refreshAvailableTools`, ruft `client.listResources()` auf allen aktiven Clients auf. Aktualisiert `availableResourcesCache`. Löst `ResourceListUpdated`-Event aus.
    - `public getAvailableResources(): ResourceDefinitionExtended`
        - **Signatur:** `public getAvailableResources(): ResourceDefinitionExtended noexcept`
        - **Beschreibung:** Gibt den aktuellen Cache der verfügbaren Ressourcen zurück.
    - `public async getResourceData(resourceId: GlobalResourceId, params?: object, parentWindowId?: WindowIdentifier): Promise<any | MCPError | MCPConsentDeniedError>`
        - **Signatur:** `public async getResourceData(resourceId: GlobalResourceId, params?: object, parentWindowId?: WindowIdentifier): Promise<any | MCPError | MCPConsentDeniedError>`
        - **Beschreibung:** Ruft Daten einer spezifischen Ressource ab:
            1. Ermittelt `ResourceDefinitionExtended` und `ServerId` aus `resourceId`.
            2. Ermittelt die `MCPClientInstance`.
            3. Ruft `userConsentUIManager.requestConsentForResource(resourceDefinition, parentWindowId)` auf.3
            4. Bei Ablehnung: `MCPConsentDeniedError`.
            5. Bei Zustimmung: Ruft `clientInstance.getResource(resourceDefinition.name, params)` auf.
            6. Gibt Ergebnis oder Fehler zurück. Löst `ResourceAccessCompleted`-Event aus.
        - **Parameter:**
            - `resourceId: GlobalResourceId`: Die eindeutige ID der Ressource.
            - `params?: object`: Optionale Parameter für den Ressourcenzugriff.
            - `parentWindowId?: WindowIdentifier`: Für den Zustimmungsdialog.
    - `public getResourceDefinition(resourceId: GlobalResourceId): ResourceDefinitionExtended | undefined`
        - **Signatur:** `public getResourceDefinition(resourceId: GlobalResourceId): ResourceDefinitionExtended | undefined noexcept`
        - **Beschreibung:** Gibt die Definition einer Ressource aus dem Cache zurück.
- **Events (ausgehend):**
    
    - **`ResourceListUpdated`**
        - **Payload:** `{ resources: ResourceDefinitionExtended }`
    - **`ResourceAccessCompleted`**
        - **Payload:** `{ resourceId: GlobalResourceId, data: any | MCPError }`

Die Trennung von Tool- und Ressourcenzugriff in separate Dienste (`ToolOrchestrationService` und `ResourceAccessService`) ist trotz vieler Ähnlichkeiten im Ablauf sinnvoll. Tools implizieren typischerweise die Ausführung von Aktionen, die Seiteneffekte haben können, während Ressourcen primär dem Abruf von Daten dienen.1 Diese semantische Unterscheidung kann sich in unterschiedlichen Zustimmungsanforderungen, Caching-Strategien oder Fehlerbehandlungen niederschlagen. Ein eigener Dienst für Ressourcen macht die API der UI-Schicht klarer und ermöglicht spezifische Optimierungen oder Darstellungslogiken für Ressourcendaten.

### 4.3. `PromptExecutionService`

- Zweck:
    
    Der PromptExecutionService ist für die Handhabung von MCP-Prompts zuständig. Prompts sind benutzergesteuerte, vordefinierte Vorlagen oder parametrisierbare Anfragen, die die Nutzung von Tools oder Ressourcen optimieren oder komplexe Interaktionsflüsse standardisieren können.1 Dieser Dienst ermöglicht das Auflisten verfügbarer Prompts, die Auswahl durch den Benutzer und die Initiierung der Prompt-Ausführung.
    
- **Eigenschaften:**
    
    - `private mcpConnectionService: MCPConnectionService;` (Abhängigkeit)
    - `private toolOrchestrationService: ToolOrchestrationService;` (Potenzielle Abhängigkeit, falls Prompts Tools aufrufen)
    - `private resourceAccessService: ResourceAccessService;` (Potenzielle Abhängigkeit, falls Prompts Ressourcen abrufen)
    - `private availablePromptsCache: Map<GlobalPromptId, PromptDefinitionExtended> = new Map();`
        - Cache für Prompts. `GlobalPromptId` (z.B. `serverId + ":" + promptName`). `PromptDefinitionExtended` enthält die `PromptDefinition` plus `serverId`.
    - `private static instance: PromptExecutionService | null = null;`
- **Methoden:**
    
    - `public static getInstance(connService: MCPConnectionService, toolService: ToolOrchestrationService, resourceService: ResourceAccessService): PromptExecutionService`
        - **Signatur:** `public static getInstance(connService: MCPConnectionService, toolService: ToolOrchestrationService, resourceService: ResourceAccessService): PromptExecutionService noexcept`
    - `public async refreshAvailablePrompts(): Promise<PromptDefinitionExtended>`
        - **Signatur:** `public async refreshAvailablePrompts(): Promise<PromptDefinitionExtended>`
        - **Beschreibung:** Analog zu `refreshAvailableTools`, ruft `client.listPrompts()` auf. Aktualisiert `availablePromptsCache`. Löst `PromptListUpdated`-Event aus.
    - `public getAvailablePrompts(): PromptDefinitionExtended`
        - **Signatur:** `public getAvailablePrompts(): PromptDefinitionExtended noexcept`
    - `public async invokePrompt(promptId: GlobalPromptId, params: object, parentWindowId?: WindowIdentifier): Promise<any | MCPError | MCPConsentDeniedError>`
        - **Signatur:** `public async invokePrompt(promptId: GlobalPromptId, params: object, parentWindowId?: WindowIdentifier): Promise<any | MCPError | MCPConsentDeniedError>`
        - **Beschreibung:** Führt einen Prompt aus:
            1. Ermittelt `PromptDefinitionExtended` und `ServerId`.
            2. Ermittelt die `MCPClientInstance`.
            3. **Wichtig:** Die Ausführung eines Prompts kann komplex sein. Sie kann serverseitig gesteuert sein oder clientseitig eine Sequenz von Tool-Aufrufen und/oder Ressourcenabrufen erfordern, die jeweils eigene Zustimmungen benötigen.
            4. Wenn der Prompt direkt über eine MCP-Methode (z.B. `prompts/invoke`) aufgerufen wird:
                - Ggf. Zustimmung für den Prompt selbst einholen (falls der Prompt als Ganzes eine "Aktion" darstellt).
                - Ruft `clientInstance.invokePrompt(promptDefinition.name, params)` auf.
            5. Wenn der Prompt clientseitig orchestriert wird (basierend auf der `PromptDefinition`):
                - Der `PromptExecutionService` interpretiert die Prompt-Definition und ruft nacheinander die notwendigen Methoden des `ToolOrchestrationService` oder `ResourceAccessService` auf. Jeder dieser Aufrufe durchläuft den dortigen Zustimmungsflow.
            6. Gibt das finale Ergebnis des Prompts oder einen Fehler zurück. Löst `PromptExecutionCompleted`-Event aus.
    - `public getPromptDefinition(promptId: GlobalPromptId): PromptDefinitionExtended | undefined`
        - **Signatur:** `public getPromptDefinition(promptId: GlobalPromptId): PromptDefinitionExtended | undefined noexcept`
- **Events (ausgehend):**
    
    - **`PromptListUpdated`**
        - **Payload:** `{ prompts: PromptDefinitionExtended }`
    - **`PromptExecutionStarted`**
        - **Payload:** `{ promptId: GlobalPromptId, params: object }`
    - **`PromptExecutionCompleted`**
        - **Payload:** `{ promptId: GlobalPromptId, result: any | MCPError }`

Prompts sind als "user-controlled" 1 und "templated messages and workflows" 3 charakterisiert. Dies impliziert, dass die UI dem Benutzer diese Prompts optimal präsentieren und die notwendigen Parameter für den Aufruf eines Prompts abfragen muss. Die Ausführung eines Prompts ist potenziell mehr als nur ein einzelner Request-Response-Zyklus; sie kann eine geführte Interaktion oder eine Kaskade von Operationen darstellen. Der `PromptExecutionService` muss diese Komplexität kapseln. Wenn ein Prompt beispielsweise definiert ist als "Suche Dokumente (Ressource), fasse sie mit Tool A zusammen und sende das Ergebnis an Tool B", dann muss der `PromptExecutionService` diese Schritte koordinieren und dabei sicherstellen, dass für jeden einzelnen Schritt die notwendigen Zustimmungen eingeholt werden.

### 4.4. `UserConsentUIManager`

- Zweck:
    
    Der UserConsentUIManager ist der zentrale Dienst für die Anzeige von Zustimmungsdialogen und die Einholung der expliziten Benutzerzustimmung für alle MCP-Aktionen, die dies erfordern. Dazu gehören Tool-Aufrufe, Ressourcenzugriffe und potenziell LLM-Sampling-Anfragen, die vom Server initiiert werden.3 Dieser Manager ist kritisch für die Einhaltung der Sicherheits- und Datenschutzprinzipien von MCP.
    
- **Methoden:**
    
    - `public async requestConsentForTool(toolDefinition: ToolDefinitionExtended, params: object, parentWindowId?: WindowIdentifier): Promise<boolean>`
        - **Signatur:** `public async requestConsentForTool(toolDefinition: ToolDefinitionExtended, params: object, parentWindowId?: WindowIdentifier): Promise<boolean>`
        - **Beschreibung:** Zeigt einen modalen Dialog an, der den Benutzer über das aufzurufende Tool informiert. Der Dialog **MUSS** folgende Informationen klar und verständlich darstellen:
            - Name und Beschreibung des Tools (aus `toolDefinition`).
            - Der MCP-Server, der das Tool bereitstellt (`toolDefinition.serverId`, ggf. mit Name des Servers).
            - Die Parameter (`params`), mit denen das Tool aufgerufen werden soll. Diese sollten dem Benutzer lesbar präsentiert werden.10
            - Eine klare Frage, ob der Benutzer der Ausführung zustimmt.
            - Buttons für "Zustimmen" und "Ablehnen".
        - Optional kann der Dialog eine Option "Details anzeigen" bieten, um z.B. das vollständige `parameters_schema` oder eine längere Beschreibung des Tools anzuzeigen.
        - Gibt `true` zurück, wenn der Benutzer zustimmt, andernfalls `false` (bei Ablehnung oder Schließen des Dialogs ohne Zustimmung).
        - **Parameter:**
            - `toolDefinition: ToolDefinitionExtended`: Die Definition des Tools.
            - `params: object`: Die Parameter für den Aufruf.
            - `parentWindowId?: WindowIdentifier`: ID des Elternfensters für korrekte modale Darstellung.16
    - `public async requestConsentForResource(resourceDefinition: ResourceDefinitionExtended, accessParams?: object, parentWindowId?: WindowIdentifier): Promise<boolean>`
        - **Signatur:** `public async requestConsentForResource(resourceDefinition: ResourceDefinitionExtended, accessParams?: object, parentWindowId?: WindowIdentifier): Promise<boolean>`
        - **Beschreibung:** Analog zu `requestConsentForTool`, aber für den Zugriff auf eine Ressource. Der Dialog informiert über die Ressource, den Server und die Art des Zugriffs (z.B. "Daten von Ressource X lesen").
    - `public async requestConsentForSampling(samplingRequestDetails: object, serverId: ServerId, parentWindowId?: WindowIdentifier): Promise<boolean>`
        - **Signatur:** `public async requestConsentForSampling(samplingRequestDetails: object, serverId: ServerId, parentWindowId?: WindowIdentifier): Promise<boolean>`
        - **Beschreibung:** Fordert Zustimmung für eine vom Server (`serverId`) initiierte LLM-Sampling-Operation an.3 Der Dialog muss Details der Anfrage (`samplingRequestDetails`) klar darstellen.
    - `public async showUntrustedServerWarning(serverConfig: MCPServerConfig, parentWindowId?: WindowIdentifier): Promise<UserTrustDecision>`
        - **Signatur:** `public async showUntrustedServerWarning(serverConfig: MCPServerConfig, parentWindowId?: WindowIdentifier): Promise<UserTrustDecision>` (`UserTrustDecision` könnte ein Enum sein: `AllowOnce`, `AllowAlways`, `Block`)
        - **Beschreibung:** Zeigt eine Warnung an, wenn versucht wird, eine Verbindung zu einem Server herzustellen, der als nicht vertrauenswürdig markiert ist oder dessen Vertrauensstatus unbekannt ist. Dies ist besonders relevant, wenn Tool-Beschreibungen als potenziell unsicher gelten.3
        - Der Dialog sollte Optionen bieten, dem Server einmalig zu vertrauen, dauerhaft zu vertrauen (was eine Speicherung dieser Entscheidung erfordert) oder die Verbindung abzulehnen.
- **UI-Anforderungen für Zustimmungsdialoge:**
    
    - **Klarheit und Verständlichkeit:** Die Informationen müssen so aufbereitet sein, dass ein durchschnittlicher Benutzer die Konsequenzen seiner Entscheidung versteht. Fachjargon ist zu vermeiden oder zu erklären.
    - **Transparenz:** Es muss klar sein, welche Anwendung (der Host) die Zustimmung anfordert und welcher externe MCP-Server involviert ist.
    - **Granularität:** Zustimmungen sollten so granular wie möglich sein (z.B. pro Tool-Aufruf, nicht pauschal für einen ganzen Server, es sei denn, der Benutzer wählt dies explizit).
    - **Sicherheitshinweise:** Bei potenziell riskanten Operationen oder nicht vertrauenswürdigen Servern sollten explizite Warnungen angezeigt werden.
    - **Option "Immer erlauben/blockieren":** Wenn diese Option angeboten wird, muss es eine Möglichkeit für den Benutzer geben, diese gespeicherten Entscheidungen einzusehen und zu widerrufen (z.B. in den Anwendungseinstellungen). Die Speicherung dieser Präferenzen muss sicher erfolgen. 14 erwähnt `flatpak permission-set kde-authorized` für KDE, was auf systemseitige Mechanismen zur Speicherung solcher Berechtigungen hindeutet, die ggf. genutzt werden könnten.
- **Integration mit XDG Desktop Portals (Empfohlen für Desktop-Anwendungen unter Linux):**
    
    - Für eine nahtlose Integration in Desktop-Umgebungen **SOLLTE** die Verwendung von XDG Desktop Portals für Zustimmungsdialoge in Betracht gezogen werden. Bibliotheken wie `ashpd` für Rust 16 können die Interaktion mit diesen Portalen vereinfachen.
    - Der `parentWindowId` Parameter (als `WindowIdentifier` 16) ist hierbei wichtig, um dem Portal-Backend mitzuteilen, zu welchem Anwendungsfenster der Dialog gehören soll.
    - Dies würde systemeigene Dialoge verwenden, was die Benutzerakzeptanz und Konsistenz erhöht.

Der `UserConsentUIManager` ist eine kritische Komponente für die Sicherheit und das Vertrauen der Benutzer in die MCP-Funktionen der Anwendung. Die Dialoge müssen sorgfältig gestaltet werden, um eine informierte Entscheidungsfindung zu ermöglichen. Die Verwaltung von dauerhaften Zustimmungsentscheidungen ("Immer erlauben") ist ein komplexes Thema, das über einfache Dialoganzeige hinausgeht und eine Persistenzschicht sowie UI-Elemente zur Verwaltung dieser Einstellungen erfordert.

## 5. Spezifikation der UI-Komponenten und Widgets für die MCP-gestützte KI-Kollaboration

Dieser Abschnitt beschreibt die konkreten UI-Elemente (Widgets, Ansichten, Controller), die der Benutzer sieht und mit denen er interagiert, um die durch MCP bereitgestellten KI-Kollaborationsfunktionen zu nutzen. Diese Komponenten bauen auf den Diensten aus Abschnitt 4 auf und nutzen den globalen Zustand aus dem `MCPGlobalContextManager`.

### 5.1. `MCPGlobalContextManager` (oder `MCPStateService`)

- Zweck:
    
    Der MCPGlobalContextManager dient als zentraler, global zugänglicher Speicher (Store) oder Dienst, der den übergreifenden, reaktiven Zustand aller MCP-Interaktionen für die gesamte UI-Anwendung bereithält. Er fungiert als "Single Source of Truth" für MCP-bezogene Daten, auf die verschiedene UI-Komponenten zugreifen und auf deren Änderungen sie reagieren können. Dies kann durch ein State-Management-Framework (wie Redux, Vuex, Zustand in Web-Technologien oder entsprechende Äquivalente in Desktop-Frameworks) oder durch ein implementiertes Observable-Pattern erreicht werden.
    
- **Eigenschaften (Beispiele, als reaktive Datenfelder konzipiert):**
    
    - `public readonly allConnectedServers: Computed<MCPServerInfo>`
        - Eine reaktive Liste der aktuell verbundenen und initialisierten MCP-Server, inklusive Basisinformationen wie `ServerId`, Name, Status, ggf. Icon.
    - `public readonly allAvailableTools: Computed<ToolDefinitionExtended>`
        - Eine reaktive, aggregierte Liste aller Tools, die von den verbundenen Servern angeboten werden. Aktualisiert durch den `ToolOrchestrationService`.
    - `public readonly allAvailableResources: Computed<ResourceDefinitionExtended>`
        - Analog für alle verfügbaren Ressourcen. Aktualisiert durch den `ResourceAccessService`.
    - `public readonly allAvailablePrompts: Computed<PromptDefinitionExtended>`
        - Analog für alle verfügbaren Prompts. Aktualisiert durch den `PromptExecutionService`.
    - `public readonly pendingToolCalls: Computed<Map<CallId, ToolCallState>>`
        - Eine reaktive Map, die den Status laufender Tool-Aufrufe verfolgt (z.B. `CallId` als eindeutige ID des Aufrufs, `ToolCallState` mit Infos wie `toolId`, `startTime`, `progress`, `status`).
    - `public readonly recentMcpErrors: Computed<MCPError>`
        - Eine reaktive Liste der zuletzt aufgetretenen MCP-Fehler, die UI-weit angezeigt werden könnten oder für Debugging-Zwecke nützlich sind.
    - `public readonly mcpFeatureEnabled: Computed<boolean>`
        - Ein Flag, das anzeigt, ob die MCP-Funktionalität global aktiviert ist.
- **Methoden:**
    
    - Primär Getter-Methoden für die oben genannten reaktiven Eigenschaften.
    - Interne Setter-Methoden oder Mechanismen, die von den MCP-Interaktionsdiensten (aus Abschnitt 4) aufgerufen werden, um den Zustand zu aktualisieren (z.B. `updateToolList(tools: ToolDefinitionExtended)`, `addPendingToolCall(callId: CallId, initialState: ToolCallState)`). Diese sollten nicht direkt von UI-Widgets aufgerufen werden.
    - `public getToolDefinitionById(toolId: GlobalToolId): ToolDefinitionExtended | undefined`
    - `public getResourceDefinitionById(resourceId: GlobalResourceId): ResourceDefinitionExtended | undefined`
    - `public getPromptDefinitionById(promptId: GlobalPromptId): PromptDefinitionExtended | undefined`
- Abonnementmechanismus:
    
    Der MCPGlobalContextManager MUSS einen Mechanismus bereitstellen, der es UI-Komponenten ermöglicht, auf Änderungen spezifischer Teile des MCP-Zustands zu reagieren (zu "abonnieren"). Wenn sich beispielsweise die Liste der allAvailableTools ändert, sollten alle UI-Komponenten, die diese Liste anzeigen oder davon abhängen, automatisch benachrichtigt und neu gerendert werden.
    
- Relevanz:
    
    Dieser Manager ist entscheidend für die Entwicklung einer reaktiven und konsistenten Benutzeroberfläche. Er entkoppelt die Datenerzeugung und -aktualisierung (durch die Services) von der Datenkonsumption (durch die UI-Widgets). Wenn beispielsweise ein neuer MCP-Server verbunden wird und dieser neue Tools bereitstellt, aktualisiert der ToolOrchestrationService den MCPGlobalContextManager, welcher wiederum automatisch alle abhängigen UI-Elemente (wie Kontextmenüs oder Seitenleisten) dazu veranlasst, sich neu darzustellen und die neuen Tools anzuzeigen. Ohne einen solchen zentralen State Manager wäre es schwierig, den UI-Zustand über viele Komponenten hinweg synchron zu halten, was zu Inkonsistenzen und einer schlechten Benutzererfahrung führen würde.
    

### 5.2. `MCPContextualMenuController`

- Zweck:
    
    Der MCPContextualMenuController ist dafür verantwortlich, dynamisch Kontextmenüeinträge zu generieren, die MCP-bezogene Aktionen anbieten. Diese Einträge basieren auf dem aktuellen Kontext der Benutzeroberfläche (z.B. ausgewählter Text, eine Datei im Explorer, das aktive UI-Element) und den über den MCPGlobalContextManager bekannten, verfügbaren MCP-Tools, -Ressourcen und -Prompts.
    
- **Eigenschaften:**
    
    - `private mcpGlobalContextManager: MCPGlobalContextManager;` (Abhängigkeit)
    - `private toolOrchestrationService: ToolOrchestrationService;` (Abhängigkeit, um Aktionen auszulösen)
    - `private resourceAccessService: ResourceAccessService;` (Abhängigkeit)
    - `private promptExecutionService: PromptExecutionService;` (Abhängigkeit)
    - `private currentAppContext: AppSpecificContext | null = null;`
        - Hält den Kontext, für den das Menü generiert werden soll. `AppSpecificContext` ist ein Platzhalter für eine Struktur, die den relevanten Kontext der Host-Anwendung beschreibt (z.B. `{ type: 'textSelection', content: string }` oder `{ type: 'file', path: string, mimeType: string }`).
- **Methoden:**
    
    - `public constructor(contextManager: MCPGlobalContextManager, toolService: ToolOrchestrationService, /*...andere Dienste... */)`
    - `public updateCurrentAppContext(context: AppSpecificContext): void`
        - **Signatur:** `public updateCurrentAppContext(context: AppSpecificContext): void noexcept`
        - **Beschreibung:** Wird von der UI aufgerufen, wenn sich der Kontext ändert, auf den sich ein potenzielles Kontextmenü beziehen würde (z.B. bei Fokuswechsel, neuer Auswahl).
    - `public generateContextMenuItems(): MenuItem`
        - **Signatur:** `public generateContextMenuItems(): MenuItem noexcept`
        - **Beschreibung:**
            1. Greift auf `this.currentAppContext` zu. Wenn kein Kontext vorhanden ist oder dieser für MCP-Aktionen irrelevant ist, wird ein leeres Array oder ein Standardmenü zurückgegeben.
            2. Ruft die Listen der verfügbaren Tools, Ressourcen und Prompts vom `mcpGlobalContextManager` ab.
            3. Filtert diese Listen basierend auf `this.currentAppContext`. Die Relevanz eines Tools/einer Ressource/eines Prompts für einen gegebenen Kontext kann durch Metadaten in deren Definitionen bestimmt werden (z.B. ein Feld `applicableContextTypes: string` in `ToolDefinitionExtended`, das MIME-Typen oder abstrakte Kontexttypen wie "text", "code", "image" enthält).
            4. Für jede relevante MCP-Aktion wird ein `MenuItem`-Objekt erstellt. Ein `MenuItem` sollte mindestens enthalten:
                - `label: string` (Anzeigetext, z.B. Tool-Name)
                - `icon?: string` (Optionales Icon)
                - `action: () => Promise<void>` (Eine Funktion, die bei Auswahl des Eintrags ausgeführt wird. Diese Funktion ruft die entsprechende Methode des zuständigen Dienstes auf, z.B. `toolOrchestrationService.callTool(...)` mit den notwendigen Parametern, die ggf. aus `currentAppContext` extrahiert werden).
                - `isEnabled: boolean` (Ob der Eintrag aktiv ist).
                - Optional: Untermenüs für Tools/Ressourcen von verschiedenen Servern oder nach Kategorien.
            5. Gibt das Array der generierten `MenuItem`-Objekte zurück.
    - `public registerContextProvider(provider: () => AppSpecificContext | null): void` (Alternativer Ansatz zu `updateCurrentAppContext`)
        - **Signatur:** `public registerContextProvider(provider: () => AppSpecificContext | null): void noexcept`
        - **Beschreibung:** Ermöglicht verschiedenen Teilen der UI (z.B. einem Texteditor, einem Dateibrowser), eine Funktion zu registrieren, die bei Bedarf den aktuellen Kontext liefert. `generateContextMenuItems` würde dann diesen Provider aufrufen.
- Logik zur Aktionsauswahl:
    
    Die "Relevanz" von MCP-Aktionen für einen bestimmten Kontext ist der Schlüssel zu einem nützlichen Kontextmenü. Ein einfaches Auflisten aller verfügbaren Tools ist selten benutzerfreundlich. Der Controller MUSS intelligent filtern und idealerweise priorisieren. Dies kann erreicht werden durch:
    
    - **Explizite Metadaten:** Tool-/Ressourcen-/Prompt-Definitionen enthalten Informationen darüber, auf welche Kontexttypen sie anwendbar sind.
    - **Heuristiken:** Basierend auf dem Typ und Inhalt des Kontexts (z.B. Dateiendung, ausgewählter Textinhalt).
    - **Benutzerkonfiguration:** Der Benutzer kann bevorzugte Aktionen für bestimmte Kontexte definieren.
    - **(Fortgeschritten) LLM-basierte Vorschläge:** Eine kleine, schnelle LLM-Anfrage könnte basierend auf dem Kontext und den verfügbaren Aktionen die relevantesten vorschlagen (dies würde jedoch eine weitere LLM-Interaktion bedeuten und muss sorgfältig abgewogen werden).
- Relevanz:
    
    Ein gut implementiertes kontextsensitives Menü macht MCP-Funktionen nahtlos im Arbeitsfluss des Benutzers zugänglich. Es reduziert die Notwendigkeit, separate Dialoge oder Paletten zu öffnen, und steigert so die Effizienz und Akzeptanz der KI-Kollaborationsfeatures. Die Intelligenz bei der Auswahl der angezeigten Aktionen ist dabei entscheidend für die Qualität der Benutzererfahrung.
    

### 5.3. `MCPSidebarView` (oder `MCPToolPalette`)

- Zweck:
    
    Die MCPSidebarView ist eine dedizierte, persistentere UI-Komponente (z.B. eine Seitenleiste, ein andockbares Fenster oder eine Werkzeugpalette), die dem Benutzer einen umfassenden Überblick und direkte Interaktionsmöglichkeiten mit allen Aspekten der MCP-Integration bietet. Sie dient als zentrale Anlaufstelle für die Verwaltung von MCP-Servern, das Entdecken von Tools, Ressourcen und Prompts sowie die Überwachung laufender Operationen. 4 beschreibt eine ähnliche Funktionalität ("Attach from MCP" Icon mit Popup-Menü). 10 zeigt, wie Cursor MCP-Tools in einer Liste darstellt.
    
- **Unterkomponenten (als separate Widgets oder Bereiche innerhalb der Sidebar):**
    
    - **`ServerListView`**:
        - **Anzeige:** Listet alle konfigurierten und/oder dynamisch erkannten MCP-Server auf. Zeigt für jeden Server:
            - Name/ID des Servers.
            - Verbindungsstatus (z.B. "Verbunden", "Getrennt", "Fehler") mit Icon.
            - Optionale Details (z.B. Protokollversion, Anzahl der bereitgestellten Tools/Ressourcen).
        - **Interaktion:**
            - Manuelles Verbinden/Trennen einzelner Server (ruft Methoden des `MCPConnectionService` auf).
            - Öffnen eines Konfigurationsdialogs für einen Server (falls serverseitige Konfiguration über MCP unterstützt wird oder für clientseitige Einstellungen wie Umgebungsvariablen 10).
            - Anzeigen von Server-Logs oder Fehlerdetails.
        - **Datenquelle:** Abonniert `allConnectedServers` und Statusänderungen vom `MCPGlobalContextManager` bzw. `MCPConnectionService`.
    - **`ToolListView`**:
        - **Anzeige:** Listet alle verfügbaren Tools von allen (oder einem ausgewählten) verbundenen Server(n).
            - Filteroptionen (nach Server, Kategorie, Suchbegriff).
            - Gruppierungsoptionen (z.B. nach Server, nach Funktionalität).
            - Für jedes Tool: Name, Beschreibung, Serverzugehörigkeit.
        - **Interaktion:**
            - Auswahl eines Tools führt zur Anzeige eines Parameter-Eingabebereichs (ggf. generiert durch `MCPWidgetFactory`).
            - Button zum Auslösen des Tools (ruft `toolOrchestrationService.callTool()` auf).
        - **Datenquelle:** Abonniert `allAvailableTools` vom `MCPGlobalContextManager`.
    - **`ResourceListView`**:
        - **Anzeige:** Analog zur `ToolListView` für MCP-Ressourcen.
        - **Interaktion:** Auswahl einer Ressource ermöglicht ggf. Eingabe von Zugriffsparametern und löst den Abruf über `resourceAccessService.getResourceData()` aus. Die abgerufenen Daten können direkt in der Sidebar oder in einem dedizierten Viewer angezeigt werden.
        - **Datenquelle:** Abonniert `allAvailableResources` vom `MCPGlobalContextManager`.
    - **`PromptListView`**:
        - **Anzeige:** Analog zur `ToolListView` für MCP-Prompts.
        - **Interaktion:** Auswahl eines Prompts führt zur Anzeige eines Parameter-Eingabebereichs für den Prompt und löst dessen Ausführung über `promptExecutionService.invokePrompt()` aus.
        - **Datenquelle:** Abonniert `allAvailablePrompts` vom `MCPGlobalContextManager`.
    - **`ActiveOperationsView`**:
        - **Anzeige:** Listet alle aktuell laufenden MCP-Operationen (Tool-Aufrufe, Ressourcenabrufe, Prompt-Ausführungen).
            - Für jede Operation: Name des Tools/Ressource/Prompts, Zielserver, Startzeit.
            - Fortschrittsanzeige (Balken oder Text), falls der Server `$/progress`-Notifications sendet und die `MCPClientInstance` diese weiterleitet.
        - **Interaktion:**
            - Möglichkeit, laufende Operationen abzubrechen (ruft `clientInstance.cancelRequest()` über den entsprechenden Service auf).
            - Anzeigen von Detail-Logs für eine Operation.
        - **Datenquelle:** Abonniert `pendingToolCalls` (und äquivalente Zustände für Ressourcen/Prompts) vom `MCPGlobalContextManager` sowie `Progress`-Events.
- **Eigenschaften (der gesamten `MCPSidebarView`):**
    
    - Abonniert relevante Zustände und Listen vom `MCPGlobalContextManager`, um ihre Unterkomponenten zu aktualisieren.
    - Kann einen eigenen internen Zustand für Filter, Sortierungen oder ausgewählte Elemente haben.
- **Methoden (primär interne Handler für Benutzerinteraktionen):**
    
    - Interagiert mit den Diensten aus Abschnitt 4 (`MCPConnectionService`, `ToolOrchestrationService` etc.), um Aktionen basierend auf Benutzereingaben in den Unterkomponenten auszulösen.
- **Event-Handling:**
    
    - Reagiert auf Klicks, Eingaben, Auswahländerungen in ihren Unterkomponenten.
    - Löst ggf. eigene UI-Events aus, um andere Teile der Anwendung zu benachrichtigen (z.B. "ToolXYWurdeAusgewählt").
- Relevanz:
    
    Die MCPSidebarView bietet einen zentralen und persistenten Ort für den Benutzer, um einen umfassenden Überblick über die verfügbaren MCP-Fähigkeiten zu erhalten und diese gezielt zu nutzen. Sie ergänzt das schnell zugängliche, aber flüchtige Kontextmenü. Die Sidebar könnte auch der Ort sein, an dem der Benutzer serverseitige Konfigurationen vornimmt, falls dies vom MCP-Server oder der Anwendung unterstützt wird.10
    

### 5.4. `MCPWidgetFactory`

- Zweck:
    
    Die MCPWidgetFactory ist eine Hilfskomponente, die dafür zuständig ist, dynamisch spezifische UI-Widgets für die Interaktion mit bestimmten MCP-Tools oder für die Anzeige von MCP-Ressourcendaten zu erzeugen. Die Generierung basiert auf den Schema-Definitionen, die von den MCP-Servern bereitgestellt werden (z.B. das JSON-Schema für Tool-Parameter 9).
    
- **Methoden:**
    
    - `public createWidgetForToolParams(toolDefinition: ToolDefinitionExtended, currentValues?: object): UIElement | null`
        - **Signatur:** `public createWidgetForToolParams(toolDefinition: ToolDefinitionExtended, currentValues?: object): UIElement | null`
        - **Beschreibung:**
            1. Analysiert das `toolDefinition.parametersSchema` (typischerweise ein JSON-Schema-Objekt 9).
            2. Basierend auf dem Schema generiert die Methode ein UI-Element (oder eine Sammlung von UI-Elementen), das Formularfelder für jeden Parameter des Tools bereitstellt.
            3. Unterstützte JSON-Schema-Typen und ihre UI-Entsprechungen (Beispiele):
                - `"type": "string"`: Text-Eingabefeld.
                - `"type": "string", "format": "date-time"`: Datums-/Zeitauswahl-Widget.
                - `"type": "number"`, `"type": "integer"`: Numerisches Eingabefeld (ggf. mit Min/Max-Validierung aus dem Schema).
                - `"type": "boolean"`: Checkbox oder Umschalter.
                - `"type": "array"` (mit `items` definiert): Liste von Eingabefeldern, ggf. mit Buttons zum Hinzufügen/Entfernen von Elementen.
                - `"type": "object"` (mit `properties` definiert): Gruppe von verschachtelten Eingabefeldern.
                - `"enum"`: Dropdown-Liste oder Radio-Buttons.
            4. Die generierten Widgets sollten Beschriftungen (aus `title` oder Property-Name im Schema), Platzhalter (aus `description` oder `examples`) und Validierungsregeln (aus `required`, `minLength`, `pattern` etc. im Schema) berücksichtigen.
            5. `currentValues` kann verwendet werden, um die Widgets mit vorhandenen Werten vorzubelegen.
            6. Gibt das Wurzelelement der generierten UI zurück oder `null`, wenn kein Schema vorhanden ist oder keine Parameter benötigt werden.
        - **Parameter:**
            - `toolDefinition: ToolDefinitionExtended`: Die Definition des Tools, inklusive seines Parameter-Schemas.
            - `currentValues?: object`: Optionale aktuelle Werte für die Parameter.
        - **Rückgabewert:** Ein `UIElement` (plattformspezifischer Typ für ein UI-Steuerelement oder einen Container) oder `null`.
    - `public createWidgetForResourceDisplay(resourceDefinition: ResourceDefinitionExtended, data: ResourceData, options?: DisplayOptions): UIElement | null`
        - **Signatur:** `public createWidgetForResourceDisplay(resourceDefinition: ResourceDefinitionExtended, data: ResourceData, options?: DisplayOptions): UIElement | null`
        - **Beschreibung:**
            1. Analysiert den Typ und die Struktur der `data` (ggf. unter Zuhilfenahme von Metadaten aus `resourceDefinition` oder MIME-Typen).
            2. Generiert ein UI-Element zur angemessenen Darstellung dieser Daten. Beispiele:
                - Textdaten: Mehrzeiliges Textfeld (ggf. mit Syntaxhervorhebung, wenn es sich um Code handelt).
                - JSON/XML-Daten: Strukturierte Baumansicht oder formatierter Text.
                - Bilddaten: Bildanzeige-Widget.10
                - Tabellarische Daten: Tabellenansicht.
                - Binärdaten: Hex-Viewer oder Download-Link.
            3. `options` können steuern, wie die Daten dargestellt werden (z.B. ob sie editierbar sein sollen, welche Felder angezeigt werden etc.).
        - **Parameter:**
            - `resourceDefinition: ResourceDefinitionExtended`: Die Definition der Ressource.
            - `data: ResourceData`: Die abgerufenen Ressourcendaten.
            - `options?: DisplayOptions`: Optionale Darstellungsoptionen.
        - **Rückgabewert:** Ein `UIElement` oder `null`.
- Relevanz:
    
    Die MCPWidgetFactory ermöglicht eine hochgradig flexible und typsichere Benutzeroberfläche für variable MCP-Interaktionen. Anstatt für jedes einzelne Tool oder jeden Ressourcentyp eine feste UI im Code zu implementieren, kann die UI dynamisch auf die vom Server bereitgestellten Schemata reagieren. Dies reduziert den Entwicklungsaufwand erheblich, wenn neue Tools oder Server mit unterschiedlichen Parameterstrukturen integriert werden, und stellt sicher, dass die UI immer die korrekten Eingabefelder und Darstellungen anbietet.
    
- Herausforderungen:
    
    Die Komplexität dieser Factory hängt stark von der Vielfalt und Komplexität der unterstützten JSON-Schema-Konstrukte und Ressourcendatenformate ab. Eine umfassende Implementierung, die alle Aspekte von JSON-Schema (bedingte Logik, komplexe Abhängigkeiten etc.) und eine breite Palette von Datenformaten abdeckt, kann sehr anspruchsvoll sein. Es ist ratsam, mit einer Unterstützung für die gängigsten Typen zu beginnen und die Factory iterativ zu erweitern.
    

### 5.5. `AICoPilotInterface` (oder `ChatInteractionManager`)

- Zweck:
    
    Die AICoPilotInterface ist die primäre UI-Komponente, über die der Benutzer direkt mit der KI-Funktionalität der Anwendung interagiert. Dies ist oft ein Chat-Fenster, eine erweiterte Eingabeaufforderung oder ein ähnliches Interface. Diese Komponente ist dafür verantwortlich, Benutzereingaben entgegenzunehmen, diese ggf. an ein LLM (entweder ein internes oder ein über MCP angebundenes) weiterzuleiten, MCP-Aktionen zu initiieren (basierend auf Benutzerbefehlen oder LLM-Vorschlägen) und die Ergebnisse – angereichert durch MCP-Tool-Ausgaben oder Ressourcendaten – dem Benutzer darzustellen. 4 beschreibt, wie Claude Desktop nach Bestätigung eines Tools dieses nutzt und Ergebnisse anzeigt. 23 erläutert die Interaktion mit GitHub Copilot über MCP.
    
- **Eigenschaften:**
    
    - `private conversationHistory: ChatMessage =;`
        - Eine Liste von `ChatMessage`-Objekten, die den bisherigen Dialogverlauf speichert.
    - `private inputField: TextInputElement;` (Plattformspezifisches UI-Element für Texteingabe)
    - `private sendButton: ButtonElement;`
    - `private mcpGlobalContextManager: MCPGlobalContextManager;` (Abhängigkeit)
    - `private toolOrchestrationService: ToolOrchestrationService;` (Abhängigkeit)
    - `private resourceAccessService: ResourceAccessService;` (Abhängigkeit)
    - `private promptExecutionService: PromptExecutionService;` (Abhängigkeit)
    - `private userConsentUIManager: UserConsentUIManager;` (Abhängigkeit)
    - `private currentLLMContext: any;` (Kontext, der an das LLM gesendet wird, z.B. vorherige Nachrichten, System-Prompt)
- **Methoden:**
    
    - `public constructor(...)`
        - Initialisiert UI-Elemente und Abhängigkeiten. Registriert Event-Listener für Eingabefeld (Enter-Taste) und Sende-Button.
    - `public async handleUserInput(text: string): Promise<void>`
        - **Signatur:** `public async handleUserInput(text: string): Promise<void>`
        - **Beschreibung:**
            1. Fügt die Benutzereingabe als `ChatMessage` zur `conversationHistory` hinzu und aktualisiert die UI.
            2. Leert das `inputField`.
            3. **Logik zur Intent-Erkennung:**
                - Prüft, ob `text` ein direkter Befehl zur Nutzung eines MCP-Tools/Ressource/Prompts ist (z.B. "/callTool meinTool --paramWert X").
                - Andernfalls wird `text` (zusammen mit `currentLLMContext`) an das zuständige LLM gesendet (dies kann ein internes LLM sein oder ein Aufruf an einen MCP-Server, der LLM-Funktionalität bereitstellt).
            4. Wenn ein direkter Befehl erkannt wurde: Ruft die entsprechende Methode des zuständigen MCP-Dienstes auf (z.B. `toolOrchestrationService.callTool`). Das Ergebnis wird dann über `displayAIResponse` oder `displayError` angezeigt.
            5. Wenn die Eingabe an ein LLM geht: Wartet auf die Antwort des LLMs. Die LLM-Antwort kann Text, einen Vorschlag zur Tool-Nutzung oder eine Kombination davon sein.
    - `public displayAIResponse(response: AIResponse): void`
        - **Signatur:** `public displayAIResponse(response: AIResponse): void noexcept` (`AIResponse` könnte `{ text?: string, toolCallSuggestion?: ModelInitiatedToolCall, mcpData?: any }` sein)
        - **Beschreibung:**
            1. Fügt die KI-Antwort als `ChatMessage` zur `conversationHistory` hinzu und aktualisiert die UI.
            2. Wenn `response.toolCallSuggestion` vorhanden ist, wird `this.handleToolSuggestion(response.toolCallSuggestion)` aufgerufen.
            3. Wenn `response.mcpData` vorhanden ist (z.B. direkt abgerufene Ressourcendaten, die Teil der Antwort sind), wird dies entsprechend formatiert und angezeigt (ggf. mit `MCPWidgetFactory`).
    - `private async handleToolSuggestion(toolCallRequest: ModelInitiatedToolCall): Promise<void>`
        - **Signatur:** `private async handleToolSuggestion(toolCallRequest: ModelInitiatedToolCall): Promise<void>` (`ModelInitiatedToolCall` enthält `toolId`, `params`)
        - **Beschreibung:** Wird aufgerufen, wenn das LLM vorschlägt, ein MCP-Tool zu verwenden.
            1. Ruft `toolOrchestrationService.getToolDefinition(toolCallRequest.toolId)` ab.
            2. Ruft `userConsentUIManager.requestConsentForTool(definition, toolCallRequest.params, this.getWindowId())` auf.
            3. Bei Zustimmung: Ruft `toolOrchestrationService.callTool(toolCallRequest.toolId, toolCallRequest.params, this.getWindowId())` auf. Das Ergebnis dieses Aufrufs wird dann typischerweise wieder an das LLM gesendet (als Teil des nächsten `currentLLMContext`), damit es seine Antwort darauf basierend formulieren kann. Dieser Schritt ist Teil des "Agenten-Loops".
            4. Bei Ablehnung: Informiert das LLM (optional) oder zeigt eine entsprechende Nachricht an.
    - `public displayError(error: MCPError | Error): void`
        - **Signatur:** `public displayError(error: MCPError | Error): void noexcept`
        - **Beschreibung:** Zeigt eine Fehlermeldung im Chat-Interface an.
    - `public clearConversation(): void`
        - **Signatur:** `public clearConversation(): void noexcept`
        - **Beschreibung:** Leert die `conversationHistory` und aktualisiert die UI.
- Relevanz:
    
    Die AICoPilotInterface ist oft das "Gesicht" der KI-Kollaboration für den Benutzer. Ihre Fähigkeit, nahtlos zwischen reiner Textkonversation, der Nutzung von MCP-Tools (initiiert durch Benutzer oder LLM) und der Darstellung von Ergebnissen zu wechseln, ist entscheidend für eine positive Benutzererfahrung. Sie muss eng mit dem zugrundeliegenden LLM (falls die UI-Anwendung eines direkt steuert) oder dem MCP-Server (falls dieser das LLM steuert und Tool-Aufrufe vorschlägt) zusammenarbeiten. Sie ist der primäre Ort, an dem der komplexe "Dialog" zwischen Benutzer, LLM und den über MCP angebundenen externen Fähigkeiten stattfindet und sichtbar wird.
    

## 6. Detaillierte Event-Spezifikationen und Datenstrukturen

Dieser Abschnitt definiert die detaillierten Strukturen für UI-interne Events, die für die Kommunikation zwischen den MCP-Modulen verwendet werden, sowie die zentralen Datenobjekte (Entitäten und Wertobjekte), die MCP-Konzepte innerhalb der UI-Schicht repräsentieren. Zusätzlich werden die exakten JSON-RPC-Nachrichtenstrukturen aus Sicht des Clients spezifiziert.

### 6.1. UI-Interne Events für MCP-Operationen

Um eine lose Kopplung zwischen den verschiedenen UI-Modulen und -Komponenten zu erreichen, wird ein internes Event-System (z.B. basierend auf dem Observer-Pattern oder einem dedizierten Pub/Sub-Mechanismus) verwendet. Dies ermöglicht es Komponenten, auf Zustandsänderungen und abgeschlossene Operationen zu reagieren, ohne direkte Abhängigkeiten voneinander zu haben. Ein robustes Event-System ist entscheidend für die Skalierbarkeit und Wartbarkeit der UI, insbesondere bei der Handhabung asynchroner Operationen wie MCP-Aufrufen, und hilft, komplexe Callback-Ketten ("Callback Hell") zu vermeiden.

Für jedes definierte Event werden folgende Aspekte spezifiziert:

- **Eindeutiger Event-Name/Typ:** Eine klare und eindeutige Bezeichnung für das Event (z.B. als String-Konstante oder Enum-Wert).
- **Payload-Struktur (Typdefinition):** Die genaue Definition der Daten, die mit dem Event transportiert werden.
- **Typische Publisher:** Die Komponente(n) oder der/die Dienst(e), die dieses Event typischerweise auslösen.
- **Typische Subscriber:** Die Komponenten oder Dienste, die typischerweise auf dieses Event reagieren.
- **Beschreibung:** Kurze Erläuterung des Zwecks und des Kontexts des Events.

**Beispiele für UI-interne Events:**

- **Event: `mcp:ServerConnectionStatusChanged`**
    - **Payload:** `{ serverId: ServerId, newStatus: ConnectionStatus, clientInstance?: MCPClientInstance, error?: MCPError }`
    - **Publisher:** `MCPConnectionService` (via `MCPClientInstance`)
    - **Subscriber:** `MCPGlobalContextManager`, `MCPSidebarView.ServerListView`, ggf. andere UI-Komponenten, die den Serverstatus anzeigen.
    - **Beschreibung:** Wird ausgelöst, wenn sich der Verbindungsstatus eines MCP-Servers ändert.
- **Event: `mcp:ClientInstanceAdded`**
    - **Payload:** `{ client: MCPClientInstance }`
    - **Publisher:** `MCPConnectionService`
    - **Subscriber:** `MCPGlobalContextManager`, `MCPSidebarView.ServerListView`
    - **Beschreibung:** Wird ausgelöst, nachdem eine neue `MCPClientInstance` erstellt und der initiale Verbindungsversuch gestartet wurde.
- **Event: `mcp:ClientInstanceRemoved`**
    - **Payload:** `{ serverId: ServerId, reason?: 'disconnected' | 'error' }`
    - **Publisher:** `MCPConnectionService`
    - **Subscriber:** `MCPGlobalContextManager`, `MCPSidebarView.ServerListView`
    - **Beschreibung:** Wird ausgelöst, nachdem eine `MCPClientInstance` entfernt wurde.
- **Event: `mcp:ToolListUpdated`**
    - **Payload:** `{ tools: ToolDefinitionExtended }`
    - **Publisher:** `ToolOrchestrationService`
    - **Subscriber:** `MCPGlobalContextManager`, `MCPSidebarView.ToolListView`, `MCPContextualMenuController`
    - **Beschreibung:** Wird ausgelöst, wenn die Liste der verfügbaren Tools aktualisiert wurde.
- **Event: `mcp:ResourceListUpdated`**
    - **Payload:** `{ resources: ResourceDefinitionExtended }`
    - **Publisher:** `ResourceAccessService`
    - **Subscriber:** `MCPGlobalContextManager`, `MCPSidebarView.ResourceListView`, `MCPContextualMenuController`
    - **Beschreibung:** Wird ausgelöst, wenn die Liste der verfügbaren Ressourcen aktualisiert wurde.
- **Event: `mcp:PromptListUpdated`**
    - **Payload:** `{ prompts: PromptDefinitionExtended }`
    - **Publisher:** `PromptExecutionService`
    - **Subscriber:** `MCPGlobalContextManager`, `MCPSidebarView.PromptListView`, `MCPContextualMenuController`
    - **Beschreibung:** Wird ausgelöst, wenn die Liste der verfügbaren Prompts aktualisiert wurde.
- **Event: `mcp:ToolCallStarted`**
    - **Payload:** `{ callId: string, toolId: GlobalToolId, params: object }` (callId ist eine eindeutige ID für diesen spezifischen Aufruf)
    - **Publisher:** `ToolOrchestrationService`
    - **Subscriber:** `MCPGlobalContextManager` (zur Aktualisierung von `pendingToolCalls`), `MCPSidebarView.ActiveOperationsView`
    - **Beschreibung:** Wird ausgelöst, bevor ein Tool-Aufruf an den Server gesendet wird (nach Zustimmung).
- **Event: `mcp:ToolCallCompleted`**
    - **Payload:** `{ callId: string, toolId: GlobalToolId, result: any | MCPError }`
    - **Publisher:** `ToolOrchestrationService`
    - **Subscriber:** `MCPGlobalContextManager`, `MCPSidebarView.ActiveOperationsView`, `AICoPilotInterface`
    - **Beschreibung:** Wird ausgelöst, nachdem ein Tool-Aufruf abgeschlossen ist (erfolgreich oder fehlerhaft).
- **Event: `mcp:ResourceAccessCompleted`** (analog zu `ToolCallCompleted`)
- **Event: `mcp:PromptExecutionCompleted`** (analog zu `ToolCallCompleted`)
- **Event: `mcp:ProgressNotificationReceived`**
    - **Payload:** `{ callId: string, progressToken: string | number, progressData: any }`
    - **Publisher:** `MCPClientInstance` (nach Empfang einer `$/progress` Notification)
    - **Subscriber:** `MCPGlobalContextManager` (zur Aktualisierung von `pendingToolCalls`), `MCPSidebarView.ActiveOperationsView`
    - **Beschreibung:** Wird ausgelöst, wenn eine Fortschrittsbenachrichtigung vom Server empfangen wird.
- **Event: `ui:ContextMenuRequestMcptool`**
    - **Payload:** `{ context: AppSpecificContext, position: {x: number, y: number} }`
    - **Publisher:** UI-Elemente, auf denen ein Rechtsklick erfolgt.
    - **Subscriber:** `MCPContextualMenuController` (oder ein übergeordneter UI-Manager, der das Kontextmenü anzeigt).
    - **Beschreibung:** Signalisiert, dass ein Kontextmenü mit MCP-Aktionen für den gegebenen Kontext angefordert wird.

### Tabelle 3: UI-Interne MCP-Events

|   |   |   |   |   |
|---|---|---|---|---|
|**Event-Name/Typ**|**Payload-Schema (Beispiel)**|**Typische(r) Publisher**|**Typische(r) Subscriber**|**Kurzbeschreibung des Zwecks**|
|`mcp:ServerConnectionStatusChanged`|`{ serverId, newStatus, clientInstance?, error? }`|`MCPConnectionService`|`MCPGlobalContextManager`, `MCPSidebarView.ServerListView`|Änderung des Server-Verbindungsstatus.|
|`mcp:ClientInstanceAdded`|`{ client }`|`MCPConnectionService`|`MCPGlobalContextManager`, `MCPSidebarView.ServerListView`|Neue MCP-Client-Instanz hinzugefügt.|
|`mcp:ClientInstanceRemoved`|`{ serverId, reason? }`|`MCPConnectionService`|`MCPGlobalContextManager`, `MCPSidebarView.ServerListView`|MCP-Client-Instanz entfernt.|
|`mcp:ToolListUpdated`|`{ tools }`|`ToolOrchestrationService`|`MCPGlobalContextManager`, `MCPSidebarView.ToolListView`, `MCPContextualMenuController`|Liste der verfügbaren Tools aktualisiert.|
|`mcp:ResourceListUpdated`|`{ resources }`|`ResourceAccessService`|`MCPGlobalContextManager`, `MCPSidebarView.ResourceListView`, `MCPContextualMenuController`|Liste der verfügbaren Ressourcen aktualisiert.|
|`mcp:PromptListUpdated`|`{ prompts }`|`PromptExecutionService`|`MCPGlobalContextManager`, `MCPSidebarView.PromptListView`, `MCPContextualMenuController`|Liste der verfügbaren Prompts aktualisiert.|
|`mcp:ToolCallCompleted`|`{ callId, toolId, result }`|`ToolOrchestrationService`|`MCPGlobalContextManager`, `AICoPilotInterface`|Ein Tool-Aufruf wurde abgeschlossen.|
|`mcp:ProgressNotificationReceived`|`{ callId, progressToken, progressData }`|`MCPClientInstance`|`MCPGlobalContextManager`, `MCPSidebarView.ActiveOperationsView`|Fortschrittsinfo vom Server erhalten.|

### 6.2. Objekte und Wertobjekte (Entitäten) für MCP-bezogene Daten

Dieser Unterabschnitt definiert die zentralen Datenstrukturen (Objekte und Wertobjekte), die MCP-Konzepte innerhalb der UI-Schicht repräsentieren. Diese Strukturen werden für die interne Datenhaltung, die Kommunikation zwischen Modulen und die Konfiguration verwendet. MCP-Nachrichten selbst enthalten Daten (Tool-Parameter, Ressourcen-Inhalte), die in diese Strukturen abgebildet werden müssen. Beispielsweise muss das `parameters_schema` eines Tools 9 in einer internen `ToolDefinition`-Struktur gespeichert werden können, damit die `MCPWidgetFactory` daraus eine UI generieren kann. Die `rust-mcp-schema` Bibliothek 13 dient als gute Referenz für typsichere Schemata, auch wenn die Zielsprache dieses Dokuments nicht Rust ist.

Für jede Entität (mit Identität, potenziell veränderlich) und jedes Wertobjekt (unveränderlich, durch seine Werte definiert) werden folgende Aspekte spezifiziert:

- **Name:** Der Klassen- oder Typname.
- **Typ:** Entität oder Wertobjekt.
- **Attribute:**
    - `name: string` (Attributname)
    - `type: DataType` (z.B. `string`, `number`, `boolean`, `JSONSchemaObject`, `URI`, oder ein anderer definierter Typ)
    - `visibility: public | private | protected` (aus Sicht der Klasse)
    - `initialValue?: any` (Optionaler Initialwert)
    - `readonly?: boolean` (Ob das Attribut nach Initialisierung unveränderbar ist)
    - `invariants: string` (Bedingungen, die für das Objekt immer gelten müssen, als textuelle Beschreibung)
- **Methoden (falls zutreffend, insbesondere für Entitäten mit Verhalten):**
    - Signaturen (Parameter: Name, Typ; Rückgabetyp; `const` und `noexcept` sind hier weniger relevant, da es sich um Sprachkonstrukte handelt, die von der Zielsprache abhängen. Wichtig sind Parameter und Rückgabetypen).
    - Vor- und Nachbedingungen.
    - Geschäftsregeln, die sie durchsetzen.
- **Beziehungen zu anderen Entitäten/Wertobjekten.**

**Beispiele für Entitäten und Wertobjekte:**

- **`MCPServerConfig` (Wertobjekt)**
    
    - Basierend auf.10
    - Attribute:
        - `id: string` (public, readonly): Eindeutige ID für diese Serverkonfiguration (z.B. ein Hash des Namens oder manuell vergeben).
        - `name: string` (public, readonly): Anzeigename des Servers.
        - `transportType: 'stdio' | 'sse'` (public, readonly): Der zu verwendende Transportmechanismus.
        - `command?: string` (public, readonly): Das auszuführende Kommando (nur bei `transportType === 'stdio'`).
        - `args?: string` (public, readonly): Argumente für das Kommando (nur bei `transportType === 'stdio'`).
        - `url?: string` (public, readonly): Die URL des SSE-Endpunkts (nur bei `transportType === 'sse'`).
        - `env?: Record<string, string>` (public, readonly): Umgebungsvariablen für den Serverprozess (primär für `stdio`).
        - `isTrusted?: boolean` (public, readonly, initialValue: `false`): Gibt an, ob diesem Server standardmäßig vertraut wird.
    - Invarianten:
        - "Wenn `transportType` 'stdio' ist, MUSS `command` definiert sein."
        - "Wenn `transportType` 'sse' ist, MUSS `url` definiert sein."
- **`ClientCapabilities` (Wertobjekt)**
    
    - Attribute:
        - `sampling?: { [key: string]: any }` (public, readonly): Optionen für Sampling, falls vom Client unterstützt.3
        - `otherCapabilities?: { [key: string]: any }` (public, readonly): Platz für weitere Client-spezifische Fähigkeiten.
- **`ServerInfo` (Wertobjekt)**
    
    - Empfangen vom Server während `initialize`.5
    - Attribute:
        - `name: string` (public, readonly): Name des Servers.
        - `version: string` (public, readonly): Version des Servers.
        - `meta?: { [key: string]: any }` (public, readonly): Zusätzliche Metadaten über den Server.
- **`ServerCapabilities` (Wertobjekt)**
    
    - Empfangen vom Server während `initialize`.5
    - Attribute:
        - `tools?: { [toolName: string]: ToolDefinitionFromServer }` (public, readonly): Map von Tool-Namen zu deren Definitionen.
        - `resources?: { [resourceName: string]: ResourceDefinitionFromServer }` (public, readonly): Map von Ressourcen-Namen zu deren Definitionen.
        - `prompts?: { [promptName: string]: PromptDefinitionFromServer }` (public, readonly): Map von Prompt-Namen zu deren Definitionen.
        - `protocolExtensions?: string` (public, readonly): Liste der unterstützten Protokollerweiterungen.
- **`ToolDefinitionFromServer` (Wertobjekt)** (Basis für `ToolDefinitionExtended`)
    
    - Attribute:
        - `description: string` (public, readonly): Beschreibung des Tools.9
        - `parametersSchema?: JSONSchemaObject` (public, readonly): JSON-Schema für die Parameter des Tools.9
        - `responseSchema?: JSONSchemaObject` (public, readonly): JSON-Schema für das Ergebnis des Tools (optional).
        - `annotations?: { [key: string]: any }` (public, readonly): Zusätzliche Annotationen, z.B. Kategorien, anwendbare Kontexte.
- **`ToolDefinitionExtended` (Wertobjekt)** (Intern in der UI verwendet)
    
    - Erbt/kombiniert `ToolDefinitionFromServer`.
    - Zusätzliche Attribute:
        - `name: string` (public, readonly): Der Name des Tools (Schlüssel aus `ServerCapabilities.tools`).
        - `globalId: GlobalToolId` (public, readonly): Eindeutige ID über alle Server.
        - `serverId: ServerId` (public, readonly): ID des Servers, der dieses Tool bereitstellt.
- **`ResourceDefinitionFromServer` / `ResourceDefinitionExtended`** (analog zu Tools)
    
- **`PromptDefinitionFromServer` / `PromptDefinitionExtended`** (analog zu Tools)
    
- **`JSONSchemaObject` (Wertobjekt)**
    
    - Repräsentiert ein JSON-Schema. Die genaue Struktur ist durch die JSON-Schema-Spezifikation definiert (z.B. `type`, `properties`, `items`, `required`, etc.).
- **`ChatMessage` (Wertobjekt)**
    
    - Attribute:
        - `id: string` (public, readonly): Eindeutige ID der Nachricht.
        - `sender: 'user' | 'ai' | 'system'` (public, readonly): Absender der Nachricht.
        - `text?: string` (public, readonly): Textinhalt der Nachricht.
        - `toolCallRequest?: ModelInitiatedToolCall` (public, readonly): Falls die KI ein Tool aufrufen möchte.
        - `toolCallResult?: { toolId: GlobalToolId, resultData: any }` (public, readonly): Ergebnis eines Tool-Aufrufs, das angezeigt wird.
        - `timestamp: Date` (public, readonly): Zeitstempel der Nachricht.
        - `relatedMcpCallId?: string` (public, readonly): ID des zugehörigen MCP-Aufrufs (für Korrelation).
        - `uiElement?: UIElement` (public, readonly): Optional ein spezielles UI-Element zur Darstellung (z.B. für Bilder, Karten).
- **`ConnectionStatus` (Enum/String-Literal Union)**
    
    - Werte: `Idle`, `Connecting`, `Initializing`, `Connected`, `Reconnecting`, `Disconnecting`, `Disconnected`, `Error`.

### Tabelle 5: Entitäten und Wertobjekte – Schlüsselliste

|   |   |   |   |   |
|---|---|---|---|---|
|**Objektname**|**Typ (Entität/Wertobjekt)**|**Kurzbeschreibung/Zweck**|**Wichtige Attribute (Beispiele)**|**Beziehung zu anderen Objekten (Beispiele)**|
|`MCPServerConfig`|Wertobjekt|Konfiguration für die Verbindung zu einem MCP-Server.|`id`, `name`, `transportType`, `command`/`url`|-|
|`ClientCapabilities`|Wertobjekt|Fähigkeiten, die der UI-Client dem Server anbietet.|`sampling`|-|
|`ServerInfo`|Wertobjekt|Vom Server empfangene Metainformationen.|`name`, `version`|-|
|`ServerCapabilities`|Wertobjekt|Vom Server empfangene Liste seiner Fähigkeiten.|`tools`, `resources`, `prompts`|Enthält `ToolDefinitionFromServer` etc.|
|`ToolDefinitionFromServer`|Wertobjekt|Definition eines Tools, wie vom Server bereitgestellt.|`description`, `parametersSchema`|Verwendet `JSONSchemaObject`.|
|`ToolDefinitionExtended`|Wertobjekt|UI-interne, erweiterte Tool-Definition.|`globalId`, `serverId`, `name`|Basiert auf `ToolDefinitionFromServer`.|
|`JSONSchemaObject`|Wertobjekt|Repräsentation eines JSON-Schemas.|`type`, `properties`, `required`|-|
|`ChatMessage`|Wertobjekt|Einzelne Nachricht in einer Konversation (z.B. im Chat).|`sender`, `text`, `timestamp`, `toolCallRequest`|-|
|`MCPError`|Entität (da Zustand wie `originalError` sich ändern könnte, aber oft als Wertobjekt behandelt)|Basisklasse für MCP-spezifische Fehler.|`message`, `jsonRpcError`|Kann `JsonRpcErrorObject` enthalten.|
|`ConnectionStatus`|Enum/Wertobjekt|Mögliche Zustände einer MCP-Verbindung.|- (`Idle`, `Connected`, etc.)|-|

### 6.3. JSON-RPC Nachrichtenstrukturen (Client-Perspektive) für MCP-Kommunikation

Dieser Unterabschnitt spezifiziert die exakten JSON-Payloads für die wichtigsten MCP-Methoden, die der Client (die UI-Anwendung) an den Server sendet, sowie die Struktur der erwarteten Antworten. Dies ist kritisch für Entwickler, die die Kommunikationsschicht in `MCPClientInstance` implementieren. Die `id` in JSON-RPC Requests 5 muss sorgfältig verwaltet werden (eindeutig pro Request), um Antworten den richtigen Anfragen zuordnen zu können, insbesondere bei nebenläufigen Aufrufen an denselben Server.

**Allgemeine JSON-RPC Struktur:**

- **Request:**
    
    JSON
    
    ```
    {
      "jsonrpc": "2.0",
      "method": "method_name",
      "params": { /* Parameterobjekt */ } /* oder [Parameterarray] */,
      "id": "eindeutige_id_string_oder_zahl" /* oder weggelassen für Notifications */
    }
    ```
    
- **Response (Erfolg):**
    
    JSON
    
    ```
    {
      "jsonrpc": "2.0",
      "result": { /* Ergebnisobjekt oder Primitivwert */ },
      "id": "gleiche_id_wie_request"
    }
    ```
    
- **Response (Fehler):**
    
    JSON
    
    ```
    {
      "jsonrpc": "2.0",
      "error": {
        "code": -32xxx, /* Fehlercode (Integer) */
        "message": "Fehlerbeschreibung (String)",
        "data": { /* Optionale zusätzliche Fehlerdetails */ }
      },
      "id": "gleiche_id_wie_request" /* oder null bei bestimmten Fehlern vor ID-Verarbeitung */
    }
    ```
    

**Spezifische Methoden:**

1. **`initialize`** 5
    
    - **Request Payload:**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "method": "initialize",
          "params": {
            "protocolVersion": "2025-03-26", // Die vom Client unterstützte MCP-Version
            "capabilities": { // ClientCapabilities Objekt
              "sampling": {}, // Beispiel
              // weitere Client-Fähigkeiten
            },
            "clientInfo": { // ClientInfo Objekt
              "name": "UIAnwendungsName",
              "version": "UIAnwendungsVersion",
              "meta": { /* optionale Metadaten über den Client */ }
            }
          },
          "id": "init_1"
        }
        ```
        
    - **Response Payload (Erfolg):**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "result": { // ServerInfo & ServerCapabilities Objekt
            "protocolVersion": "2025-03-26", // Die vom Server gewählte/bestätigte MCP-Version
            "serverInfo": {
              "name": "MCPTestServer",
              "version": "0.1.0",
              "meta": { /* optionale Metadaten über den Server */ }
            },
            "capabilities": {
              "tools": { /* Map von ToolDefinitionFromServer */ },
              "resources": { /* Map von ResourceDefinitionFromServer */ },
              "prompts": { /* Map von PromptDefinitionFromServer */ },
              "protocolExtensions": ["ext1", "ext2"]
            },
            "instructions": "Optionale Anweisungen vom Server an den Client"
          },
          "id": "init_1"
        }
        ```
        
    - **Response Payload (Error Beispiel):**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "error": {
            "code": -32602, // Invalid params
            "message": "Unsupported protocolVersion",
            "data": { "supportedVersions": ["2024-11-05"] }
          },
          "id": "init_1"
        }
        ```
        
2. **`tools/list`** 17
    
    - **Request Payload:**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "method": "tools/list",
          "params": {
            // Optionale Filterparameter, z.B. "categories": ["cat1"]
          },
          "id": "tools_list_1"
        }
        ```
        
    - **Response Payload (Erfolg):**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "result":
              }
            }
            //... weitere Tools
          ],
          "id": "tools_list_1"
        }
        ```
        
3. **`tools/call`** 17
    
    - **Request Payload:**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "method": "tools/call",
          "params": {
            "name": "get_weather", // Name des aufzurufenden Tools
            "arguments": { // Objekt mit den Tool-Parametern
              "location": "Berlin"
            }
          },
          "id": "tool_call_123"
        }
        ```
        
    - **Response Payload (Erfolg):**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "result": { /* Ergebnis des Tool-Aufrufs, Struktur ist tool-spezifisch */
            "temperature": "15°C",
            "condition": "Cloudy"
          },
          "id": "tool_call_123"
        }
        ```
        
4. **`resources/list`** (analog zu `tools/list`)
    
    - **Request Payload:**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "method": "resources/list",
          "params": {},
          "id": "res_list_1"
        }
        ```
        
    - **Response Payload (Erfolg):** Array von `ResourceDefinitionFromServer`-Objekten.
5. **`resources/get`** (analog zu `tools/call` für den Abruf)
    
    - **Request Payload:**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "method": "resources/get",
          "params": {
            "name": "document.txt",
            "accessParams": { /* optionale Zugriffsparameter */ }
          },
          "id": "res_get_1"
        }
        ```
        
    - **Response Payload (Erfolg):** `result` enthält die Ressourcendaten (Struktur ist ressourcenspezifisch).
6. **`ping`** 5
    
    - **Request Payload:**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "method": "ping",
          "params": { "payload": "optional_client_data" },
          "id": "ping_1"
        }
        ```
        
    - **Response Payload (Erfolg):**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "result": { "payload": "optional_server_data_echoing_client_data" },
          "id": "ping_1"
        }
        ```
        
7. **`$/cancelRequest` (Notification)** 3
    
    - **Request Payload (Notification, daher keine `id` im Request und keine Response erwartet):**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "method": "$/cancelRequest",
          "params": {
            "id": "tool_call_123" // ID des Requests, der abgebrochen werden soll
          }
        }
        ```
        
8. **`$/progress` (Notification vom Server an Client)** 3
    
    - **Payload (vom Server empfangen):**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "method": "$/progress",
          "params": {
            "token": "progress_token_fuer_tool_call_123", // Korreliert mit einem laufenden Request
            "value": { /* Fortschrittsdaten, Struktur ist operationsspezifisch */
              "percentage": 50,
              "message": "Processing data..."
            }
          }
        }
        ```
        
9. **`shutdown`** 9
    
    - **Request Payload (kann Request oder Notification sein, je nach Server-Erwartung):**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "method": "shutdown",
          "params": {},
          "id": "shutdown_1" // falls als Request
        }
        ```
        
    - **Response Payload (Erfolg, falls als Request):**
        
        JSON
        
        ```
        {
          "jsonrpc": "2.0",
          "result": null, // Typischerweise null bei Erfolg
          "id": "shutdown_1"
        }
        ```
        

Diese detaillierten Strukturen sind essenziell für die korrekte Implementierung der Kommunikationslogik. Abweichungen können zu Inkompatibilitäten mit MCP-Servern führen.

## 7. Implementierungsrichtlinien und Lebenszyklusmanagement

Dieser Abschnitt bietet praktische Anleitungen für typische Implementierungsaufgaben im Kontext der MCP-Integration und behandelt wichtige Aspekte des Lebenszyklusmanagements von UI-Komponenten sowie der Nebenläufigkeit.

### 7.1. Schritt-für-Schritt-Anleitungen für typische Implementierungsaufgaben

Diese Anleitungen sollen Entwicklern den Einstieg erleichtern und konsistente Implementierungsmuster fördern.

#### 7.1.1. Hinzufügen eines neuen MCP-Servers zur Konfiguration und UI

1. **Konfiguration erweitern:**
    - Der Benutzer (oder Administrator) fügt die Details des neuen MCP-Servers zur zentralen Konfigurationsquelle hinzu (z.B. die `mcp.json`-Datei 10 oder eine Datenbank). Dies beinhaltet `id`, `name`, `transportType` und die transport-spezifischen Details (`command`/`args` für stdio, `url` für SSE).
2. **`MCPConnectionService` informieren:**
    - Beim Start der Anwendung oder bei einer dynamischen Konfigurationsänderung lädt der `MCPConnectionService` die aktualisierten Konfigurationen (z.B. über `loadAndInitializeConnections()`).
    - Für den neuen Server wird eine `MCPClientInstance` erstellt und `connectAndInitialize()` aufgerufen.
3. **Status-Updates verarbeiten:**
    - Der `MCPGlobalContextManager` und die `MCPSidebarView.ServerListView` abonnieren Status-Events vom `MCPConnectionService`.
    - Sobald die neue `MCPClientInstance` hinzugefügt wird und ihren Status ändert (z.B. zu `Connected`), wird die UI automatisch aktualisiert, um den neuen Server anzuzeigen.
4. **Fähigkeiten abrufen und anzeigen:**
    - Nach erfolgreicher Initialisierung des neuen Servers rufen die Dienste (`ToolOrchestrationService`, `ResourceAccessService`, `PromptExecutionService`) dessen Fähigkeiten ab (via `client.listTools()` etc.).
    - Diese Dienste aktualisieren den `MCPGlobalContextManager`.
    - UI-Komponenten wie `MCPSidebarView.ToolListView` reagieren auf die Aktualisierung im `MCPGlobalContextManager` und zeigen die neuen Tools/Ressourcen/Prompts an.

#### 7.1.2. Implementierung eines neuen UI-Widgets, das ein MCP-Tool aufruft

1. **Widget-Design:**
    - Entwurf des UI-Widgets (z.B. ein Button mit Beschriftung oder ein komplexeres Formular).
2. **Abhängigkeiten injizieren:**
    - Das Widget erhält Zugriff auf den `ToolOrchestrationService` und ggf. den `UserConsentUIManager` (oder löst Events aus, die von einem Controller mit diesen Diensten verarbeitet werden).
3. **Aktion auslösen:**
    - Bei einer Benutzerinteraktion (z.B. Klick) ruft das Widget die Methode `toolOrchestrationService.callTool(toolId, params, parentWindowId)` auf.
    - `toolId` ist die `GlobalToolId` des gewünschten Tools.
    - `params` werden entweder im Widget selbst gesammelt (z.B. aus Eingabefeldern) oder sind vordefiniert.
    - `parentWindowId` wird übergeben, falls das Widget Teil eines modalen Dialogs ist oder um den Zustimmungsdialog korrekt zuzuordnen.
4. **Ergebnisverarbeitung:**
    - Das Widget behandelt das zurückgegebene Promise von `callTool`.
    - Bei Erfolg: Zeigt das Ergebnis an oder löst ein weiteres Event mit dem Ergebnis aus.
    - Bei Fehler (`MCPError` oder `MCPConsentDeniedError`): Zeigt eine benutzerfreundliche Fehlermeldung an.
5. **Statusanzeige (optional):**
    - Das Widget kann den `MCPGlobalContextManager` abonnieren, um den Status des Tool-Aufrufs (aus `pendingToolCalls`) anzuzeigen und z.B. während der Ausführung deaktiviert zu werden.

#### 7.1.3. Anzeigen von Daten aus einer MCP-Ressource in einer neuen Ansicht

1. **Ansicht-Design:**
    - Entwurf der UI-Ansicht, die die Ressourcendaten darstellen soll.
2. **Datenabruf initiieren:**
    - Die Ansicht (oder ihr Controller) ruft `resourceAccessService.getResourceData(resourceId, params, parentWindowId)` auf, um die Daten zu laden.
3. **Datenaufbereitung und -darstellung:**
    - Nach erfolgreichem Abruf werden die Rohdaten (`ResourceData`) empfangen.
    - Die `MCPWidgetFactory` kann verwendet werden (`createWidgetForResourceDisplay()`), um ein passendes UI-Element für die Darstellung der Daten zu generieren, basierend auf dem Datentyp oder der `ResourceDefinition`.
    - Das generierte Widget wird in die Ansicht eingefügt.
4. **Fehlerbehandlung:**
    - Fehler beim Abruf werden in der Ansicht angezeigt.

#### 7.1.4. Behandlung eines neuen Typs von MCP-Notification

1. **`MCPClientInstance` erweitern:**
    - In `MCPClientInstance.handleIncomingMessage()`: Logik hinzufügen, um Notifications mit dem neuen Methodennamen zu erkennen.
2. **Event definieren:**
    - Ein neues UI-internes Event (z.B. `mcp:CustomNotificationReceived`) mit einer passenden Payload-Struktur definieren (siehe Abschnitt 6.1).
3. **Event auslösen:**
    - Die `MCPClientInstance` löst dieses neue Event aus, wenn die entsprechende Notification empfangen wird.
4. **Subscriber implementieren:**
    - Relevante Dienste oder UI-Komponenten (z.B. `MCPGlobalContextManager` oder spezifische Widgets) abonnieren dieses neue Event.
    - Die Subscriber implementieren die Logik zur Verarbeitung der Notification-Payload und zur Aktualisierung des UI-Zustands oder der Anzeige.

### 7.2. Lebenszyklusmanagement für MCP-bezogene UI-Komponenten mit komplexem Zustand

UI-Komponenten, die MCP-Daten halten, MCP-Verbindungen repräsentieren oder auf MCP-Events reagieren (wie die Unterkomponenten der `MCPSidebarView` oder dynamisch generierte Widgets), erfordern ein sorgfältiges Lebenszyklusmanagement, um Speicherlecks, veraltete Zustände und unnötige Ressourcenbindung zu vermeiden.

- **Initialisierung:**
    - Komponenten sollten ihre Abhängigkeiten (Dienste, ContextManager) im Konstruktor oder einer Initialisierungsmethode erhalten.
    - Abonnements auf Events oder reaktive Zustände sollten bei der Initialisierung oder wenn die Komponente sichtbar/aktiv wird, eingerichtet werden.
    - Initialdaten sollten von den Diensten oder dem `MCPGlobalContextManager` abgerufen werden.
- **Aktualisierung:**
    - Komponenten müssen auf Änderungen im globalen MCP-Zustand oder auf spezifische Events reagieren und ihre Darstellung entsprechend aktualisieren. Dies sollte effizient geschehen, um die UI-Performance nicht zu beeinträchtigen.
    - Bei der Aktualisierung von Daten (z.B. einer Tool-Liste) sollte darauf geachtet werden, bestehende UI-Elemente intelligent wiederzuverwenden oder zu aktualisieren, anstatt die gesamte Ansicht neu zu erstellen, falls das UI-Toolkit dies unterstützt.
- **Zerstörung (Deregistrierung):**
    - Wenn eine Komponente zerstört wird oder nicht mehr sichtbar/aktiv ist, **MÜSSEN** alle Abonnements auf Events oder reaktive Zustände explizit beendet werden (durch Aufruf der zurückgegebenen `UnsubscribeFunction` oder äquivalenter Mechanismen). Dies ist entscheidend zur Vermeidung von Speicherlecks, da sonst Callbacks auf nicht mehr existierende Objekte zeigen könnten.
    - Event-Listener, die direkt an UI-Elementen registriert wurden, müssen entfernt werden.
    - Alle gehaltenen Referenzen auf externe Objekte, die nicht mehr benötigt werden, sollten freigegeben werden, um die Garbage Collection zu unterstützen.

### 7.3. Aspekte der Nebenläufigkeit und UI-Aktualisierungen (Threading-Modell)

MCP-Interaktionen sind inhärent asynchron, da sie oft Netzwerkkommunikation (HTTP/SSE) oder Interprozesskommunikation (stdio) beinhalten. Es ist absolut kritisch, dass diese Operationen den Haupt-UI-Thread nicht blockieren, da dies zum Einfrieren der Benutzeroberfläche führen würde.

- **Asynchrone Operationen:**
    - Alle Methoden in den MCP-Diensten (`MCPConnectionService`, `ToolOrchestrationService` etc.), die I/O-Operationen durchführen, **MÜSSEN** asynchron implementiert sein (z.B. `async/await` in JavaScript/TypeScript/C#, Futures in Rust, Coroutinen in Kotlin).
    - Die `MCPClientInstance` muss ihre Kommunikation mit dem `IMCPTransport` ebenfalls asynchron gestalten.
- **UI-Aktualisierungen aus Hintergrund-Threads/Callbacks:**
    - Die meisten UI-Toolkits erlauben UI-Aktualisierungen nur aus dem Haupt-UI-Thread. Ergebnisse von asynchronen MCP-Operationen (die typischerweise in einem Hintergrund-Thread oder einem Callback-Kontext ankommen) müssen daher sicher an den UI-Thread übergeben werden, bevor UI-Elemente modifiziert werden.
    - **Plattformspezifische Mechanismen:**
        - **GTK (mit Rust und `gtk-rs`):** `glib::MainContext::spawn_local()` oder `glib::MainContext::channel()` können verwendet werden, um Code im Haupt-Loop auszuführen oder Nachrichten an diesen zu senden.18
        - **WPF (C#):** `Dispatcher.Invoke()` oder `Dispatcher.BeginInvoke()`.
        - **Android (Java/Kotlin):** `Activity.runOnUiThread()` oder Handler, die mit dem Main Looper assoziiert sind.
        - **Web (JavaScript):** Da JavaScript single-threaded ist, aber eine Event-Loop hat, werden UI-Aktualisierungen nach `await` oder in Promise-`.then()`-Blöcken typischerweise korrekt von der Event-Loop behandelt. Dennoch ist Vorsicht bei langlaufenden synchronen Berechnungen innerhalb dieser Callbacks geboten.
- **Vermeidung von Race Conditions:**
    - Beim Zugriff auf geteilte Zustände (z.B. Caches in den Diensten oder der Zustand im `MCPGlobalContextManager`) aus verschiedenen asynchronen Kontexten müssen geeignete Synchronisationsmechanismen verwendet werden, falls die Plattform dies erfordert (z.B. Mutexe, Semaphore, atomare Operationen), um Race Conditions und inkonsistente Daten zu vermeiden.
    - Reaktive State-Management-Frameworks bieten oft eingebaute Mechanismen zur sicheren Zustandsaktualisierung.

Eine klare Strategie für Nebenläufigkeit und UI-Thread-Management ist unerlässlich für eine responsive, stabile und korrekte Anwendung.

### 7.4. Logging, Monitoring und Debugging von MCP-Interaktionen

Umfassendes Logging und Möglichkeiten zum Monitoring sind entscheidend für die Entwicklung, Wartung und Fehleranalyse von MCP-Integrationen. Das MCP-Protokoll selbst erwähnt "Logging" als eine der "Additional Utilities".3

- **Logging-Spezifikation:**
    
    - **Was loggen?**
        - **Verbindungsmanagement:** Start/Ende von Verbindungsversuchen, erfolgreiche Verbindungen, Trennungen, Fehler beim Verbindungsaufbau (mit `MCPServerConfig`-Details und Fehlermeldung).
        - **JSON-RPC-Nachrichten:** Alle ausgehenden Requests und eingehenden Responses/Notifications (optional auf einem detaillierten Loglevel, um die Log-Größe zu kontrollieren). Dies ist extrem nützlich für das Debugging von Kommunikationsproblemen. Die `id` der Nachricht sollte immer geloggt werden.
        - **Tool-/Ressourcen-/Prompt-Aufrufe:** Start eines Aufrufs (mit Name, Parametern), Erfolg (mit Zusammenfassung des Ergebnisses), Fehler (mit Fehlerdetails).
        - **Zustimmungsentscheidungen:** Welche Aktion wurde angefragt, welche Entscheidung hat der Benutzer getroffen.
        - **Fehler:** Alle `MCPError`-Instanzen und andere relevante Ausnahmen mit Stack-Trace und Kontextinformationen.
        - **Wichtige Zustandsänderungen:** z.B. Aktualisierung von Server-Capabilities.
    - **Log-Level:** Verwendung von Standard-Log-Levels (DEBUG, INFO, WARN, ERROR) zur Kategorisierung der Nachrichten. JSON-RPC-Nachrichten-Dumps sollten typischerweise auf DEBUG-Level geloggt werden.
    - **Format:** Konsistentes Log-Format mit Zeitstempel, Modulname, Loglevel und Nachricht. Strukturierte Logs (z.B. JSON-Format) können die spätere Analyse erleichtern.
    - **Sensible Daten:** Parameter oder Ergebnisse von MCP-Aufrufen können sensible Daten enthalten. Es muss eine Strategie zur Maskierung oder zum selektiven Logging solcher Daten implementiert werden, um Datenschutzanforderungen zu genügen.
- **Monitoring:**
    
    - Die UI sollte intern (oder über externe Tools, falls angebunden) den Zustand der MCP-Verbindungen und -Operationen überwachen können.
    - Der `MCPGlobalContextManager` kann hierfür Daten bereitstellen (z.B. Anzahl aktiver Verbindungen, Fehlerraten, durchschnittliche Antwortzeiten).
    - Eine dedizierte Debugging-/Statusansicht in der UI (ggf. nur in Entwickler-Builds aktiviert) kann nützlich sein, um diese Informationen live anzuzeigen.
- **Debugging-Techniken:**
    
    - **Nachrichteninspektion:** Die Möglichkeit, die tatsächlich gesendeten und empfangenen JSON-RPC-Nachrichten einzusehen (über Logs oder eine Debug-UI), ist oft der schnellste Weg, um Kommunikationsprobleme zu identifizieren.
    - **Haltepunkte und Tracing:** Standard-Debugging-Tools der Entwicklungsumgebung.
    - **Transport-spezifisches Debugging:**
        - Für `stdio`: Überprüfung der Standard-Input/Output-Ströme des Serverprozesses.
        - Für `HTTP/SSE`: Verwendung von Netzwerk-Sniffern (z.B. Wireshark) oder Browser-Entwicklertools (für SSE-Verbindungen, die über einen Browser-Client getestet werden).
    - **Isolierte Tests:** Testen einzelner `MCPClientInstance`s gegen einen Mock-Server oder einen bekannten, funktionierenden MCP-Server.

Durch die Implementierung dieser Richtlinien wird die Entwicklung und Wartung der MCP-Integration erheblich erleichtert und die Fähigkeit zur schnellen Problemlösung verbessert.

## Anhang

### A.1. Glossar der MCP- und UI-spezifischen Begriffe

- **AI:** Artificial Intelligence (Künstliche Intelligenz).
- **API:** Application Programming Interface (Anwendungsprogrammierschnittstelle).
- **Client (MCP):** Eine Komponente innerhalb des Hosts, die die Verbindung zu einem spezifischen MCP-Server verwaltet.
- **GlobalResourceId, GlobalToolId, GlobalPromptId:** UI-intern verwendete, eindeutige Bezeichner für Ressourcen, Tools oder Prompts über alle verbundenen Server hinweg (typischerweise eine Kombination aus `ServerId` und dem lokalen Namen des Elements).
- **Host (MCP):** Die Anwendung, mit der der Benutzer interagiert und die MCP-Clients beherbergt (in diesem Dokument die UI-Anwendung).
- **HTTP:** Hypertext Transfer Protocol.
- **IDE:** Integrated Development Environment (Integrierte Entwicklungsumgebung).
- **IMCPTransport:** Die in diesem Dokument definierte Schnittstelle für Transport-Handler.
- **JSON:** JavaScript Object Notation.
- **JSON-RPC:** Ein Remote Procedure Call Protokoll, das JSON für den Nachrichtenaustausch verwendet.
- **LLM:** Large Language Model (Großes Sprachmodell).
- **MCP:** Model Context Protocol.
- **MCPClientInstance:** Eine Klasse in der UI-Schicht, die eine einzelne Verbindung zu einem MCP-Server verwaltet.
- **MCPConnectionService:** Ein Dienst in der UI-Schicht, der alle `MCPClientInstance`-Objekte verwaltet.
- **MCPServerConfig:** Eine Datenstruktur, die die Konfigurationsdetails für die Verbindung zu einem MCP-Server enthält.
- **Notification (JSON-RPC):** Eine JSON-RPC-Request-Nachricht ohne `id`-Feld, für die keine Antwort vom Server erwartet wird.
- **Prompt (MCP):** Eine benutzergesteuerte, vordefinierte Vorlage oder parametrisierbare Anfrage zur optimalen Nutzung von Tools oder Ressourcen.
- **Resource (MCP):** Eine anwendungsgesteuerte Datenquelle, auf die ein LLM zugreifen kann.
- **Server (MCP):** Ein externes Programm oder Dienst, das Tools, Ressourcen und Prompts über MCP bereitstellt.
- **ServerCapabilities:** Die Fähigkeiten (Tools, Ressourcen, Prompts), die ein MCP-Server während der Initialisierung meldet.
- **ServerId:** Eine eindeutige Kennung für einen MCP-Server innerhalb der UI-Anwendung.
- **SSE:** Server-Sent Events. Ein Mechanismus, der es einem Server erlaubt, asynchron Daten an einen Client über eine persistente HTTP-Verbindung zu senden.
- **stdio:** Standard Input/Output/Error Streams eines Prozesses.
- **Tool (MCP):** Eine modellgesteuerte Funktion, die ein LLM aufrufen kann, um Aktionen auszuführen.
- **ToolDefinition, ResourceDefinition, PromptDefinition:** Strukturen, die die Metadaten eines Tools, einer Ressource oder eines Prompts beschreiben.
- **UI:** User Interface (Benutzeroberfläche).
- **UX:** User Experience (Benutzererfahrung).
- **WindowIdentifier:** Eine plattformunabhängige Kennung für ein Anwendungsfenster, oft verwendet für XDG Portals.
- **XDG Desktop Portals:** Ein Framework unter Linux, das sandboxed Anwendungen den sicheren Zugriff auf Ressourcen außerhalb der Sandbox über benutzergenehmigte Dialoge ermöglicht.

### A.2. Referenzen auf externe Spezifikationen

- **Model Context Protocol (MCP) Specification:** Die offizielle Spezifikation ist die primäre Referenz. (z.B. 3 und die Website modelcontextprotocol.io)
- **JSON-RPC 2.0 Specification:** [https://www.jsonrpc.org/specification](https://www.jsonrpc.org/specification) (5)
- **XDG Desktop Portal Specification:** [https://flatpak.github.io/xdg-desktop-portal/docs/](https://flatpak.github.io/xdg-desktop-portal/docs/) (15)
- **RFC2119 / RFC8174 (BCP 14):** Für die Interpretation von Schlüsselwörtern wie MUST, SHOULD, MAY in Speifikationen (3).

### A.3. Vollständige JSON-Schemata für Tool/Ressourcen-Parameter (Beispiele)

Dieser Anhang würde vollständige Beispiele für JSON-Schemata enthalten, wie sie in `ToolDefinition.parametersSchema` oder `ResourceDefinition.parametersSchema` (falls Ressourcen parametrisiert sind) vorkommen könnten. Diese dienen als Referenz für die Implementierung der `MCPWidgetFactory` und das Verständnis der Datenstrukturen, die von MCP-Servern erwartet oder geliefert werden.

**Beispiel 1: JSON-Schema für ein einfaches "get_weather" Tool**

JSON

```
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "GetWeatherParameters",
  "description": "Parameters for the get_weather tool.",
  "type": "object",
  "properties": {
    "location": {
      "type": "string",
      "description": "The city name or zip code for which to fetch the weather."
    },
    "unit": {
      "type": "string",
      "description": "Temperature unit.",
      "
```

# Granulare Technische Implementierungsspezifikation (Pflichtenheft)

Dieses Dokument beschreibt die detaillierten technischen Spezifikationen für die Implementierung des Projekts. Es konzentriert sich auf technische Details, die für Entwickler relevant sind, einschließlich spezifischer Bibliotheken, Methoden und Protokolle.

## 1. Kernarchitektur und Setup

### 1.1. Programmiersprache und Laufzeitumgebung

Die primäre Programmiersprache für dieses Projekt ist Rust. Rust wird aufgrund seiner Betonung auf Sicherheit (insbesondere Speichersicherheit), Leistung und Konkurrenzfähigkeit ausgewählt.1 Die asynchrone Natur vieler Aufgaben (UI-Events, D-Bus-Kommunikation, Netzwerk-I/O, LLM-Interaktionen) erfordert eine robuste asynchrone Laufzeitumgebung.

### 1.2. Build-System

Das Standard-Build-System und Paketmanagement-Tool für Rust, Cargo, wird für die Verwaltung von Abhängigkeiten, das Kompilieren des Projekts und die Ausführung von Tests verwendet.

### 1.3. Asynchrone Laufzeitumgebung

Tokio wird als asynchrone Laufzeitumgebung eingesetzt.1 Tokio bietet eine leistungsstarke, multi-threaded Laufzeitumgebung, die für I/O-gebundene Anwendungen optimiert ist und eine umfangreiche Sammlung von asynchronen APIs und ein breites Ökosystem an kompatiblen Bibliotheken bereitstellt. Die Haupt-Event-Schleife der Anwendung (sofern nicht durch spezifische UI-Frameworks wie Smithay/Calloop vorgegeben, siehe Abschnitt 4) wird mit Tokio implementiert. Asynchrone Funktionen werden mittels `async fn` deklariert und mit `.await` aufgerufen. Der Einstiegspunkt der Anwendung wird mit dem `#[tokio::main]` Makro versehen.

### 1.4. Fehlerbehandlung

Ein robustes und typisiertes Fehlerbehandlungsmodell ist entscheidend. Das Crate `thiserror` wird verwendet, um benutzerdefinierte Fehlertypen zu definieren.2

- **Zentraler Fehlertyp:** Eine zentrale `enum AppError` wird im Haupt-Crate definiert, die alle möglichen Fehlerquellen der Anwendung aggregiert.
- **Modulspezifische Fehler:** Jedes Modul, das potenziell Fehler erzeugen kann (z.B. D-Bus-Interaktion, MCP-Client, Datenbankzugriff), definiert seine eigene `enum` für spezifische Fehler, ebenfalls unter Verwendung von `#[derive(thiserror::Error)]`.
- **Fehlerkonvertierung:** Das Attribut `#[from]` wird in der zentralen `AppError` verwendet, um die automatische Konvertierung von modulspezifischen Fehlern in Varianten des zentralen Fehlertyps zu ermöglichen.2 Dies vermeidet Boilerplate-Code für die Fehlerkonvertierung.
- **Rückgabetypen:** Funktionen, die fehlschlagen können, geben `Result<T, AppError>` (oder einen modulspezifischen Fehlertyp, der dann konvertiert wird) zurück. Dies erzwingt eine explizite Fehlerbehandlung an der Aufrufstelle.

Diese Strategie, die sich an der Verwendung von `std::io::Error` in der Standardbibliothek orientiert 2, bietet einen Kompromiss zwischen Granularität (spezifische Fehler pro Modul) und Benutzerfreundlichkeit (einheitlicher Fehlertyp auf höherer Ebene), ohne die Aufrufer mit unerreichbaren Fehlerfällen zu belasten.

## 2. Textverarbeitung und Bereinigung

### 2.1. HTML-Bereinigung

Jeglicher nicht vertrauenswürdiger HTML-Inhalt, insbesondere von LLM-Ausgaben oder externen Webquellen, muss vor der Darstellung bereinigt werden, um Cross-Site-Scripting (XSS) und andere Angriffe zu verhindern.3

- **Bibliothek:** Das Crate `ammonia` wird für die HTML-Bereinigung verwendet.3 `ammonia` basiert auf einer Whitelist und nutzt `html5ever` für das Parsen, was es robust gegen Verschleierungstechniken macht.5
- **Konfiguration:** Die Bereinigung wird über das `ammonia::Builder` Pattern konfiguriert.5
    - **Erlaubte Tags:** Eine strikte Whitelist von erlaubten HTML-Tags (z.B. `p`, `b`, `i`, `ul`, `ol`, `li`, `br`, `a`, `img`, `code`, `pre`) wird mittels `builder.tags()` definiert.5 Potenziell gefährliche Tags wie `<script>`, `<style>`, `<iframe`> sind standardmäßig verboten und dürfen nicht hinzugefügt werden.
    - **Erlaubte Attribute:** Eine strikte Whitelist von erlaubten Attributen pro Tag wird mittels `builder.attributes()` definiert.5 Event-Handler-Attribute (`onerror`, `onload` etc.) und `style`-Attribute sollten generell vermieden oder stark eingeschränkt werden. Globale Attribute wie `lang` können über `("*", vec!["lang"])` erlaubt werden.
    - **Link-Attribute:** Für `<a>`-Tags muss das `rel`-Attribut mittels `builder.link_rel()` konfiguriert werden, um mindestens `noopener`, `noreferrer` und `nofollow` für externe Links zu erzwingen.5 URL-Schemata für `href`-Attribute sollten auf `http`, `https` und `mailto` beschränkt werden.
- **Anwendung:** Die Methode `builder.clean(dirty_html)` wird aufgerufen, um den Bereinigungsprozess durchzuführen.5 Der `Builder` sollte einmal konfiguriert und für mehrere Bereinigungsoperationen wiederverwendet werden.

### 2.2. Kommandozeilenargument-Maskierung

Bei der Interaktion mit externen Prozessen (siehe Abschnitt 10) ist die korrekte Behandlung von Kommandozeilenargumenten entscheidend, um Command-Injection-Schwachstellen zu verhindern.6

- **Bevorzugte Methode:** Die sicherste Methode ist die Verwendung von `std::process::Command` ohne Einbeziehung einer Shell. Das Kommando und jedes Argument werden separat über `.arg()` oder `.args()` übergeben.8 Dies verhindert, dass die Shell spezielle Zeichen im Argument interpretiert.
    
    Rust
    
    ```
    use std::process::Command;
    let user_input = "some potentially unsafe string; rm -rf /";
    let output = Command::new("plocate")
       .arg("--basename") // Example argument
       .arg(user_input) // Argument passed directly, not interpreted by shell
       .output()?;
    ```
    
- **Alternative (Nur wenn unvermeidbar):** Wenn Argumente dynamisch zu einem String zusammengesetzt werden müssen, der von einer Shell (`sh -c`) interpretiert wird (stark abgeraten), muss jedes Argument rigoros maskiert werden.
    
    - **Bibliothek:** Das Crate `shlex` wird verwendet.
    - **Funktion:** Die Funktion `shlex::quote(argument_string)` wird für jedes einzelne Argument aufgerufen, bevor es in den Befehlsstring eingefügt wird.7
    
    Rust
    
    ```
    // Strongly discouraged approach
    use std::process::Command;
    use shlex::Shlex;
    let user_input = "file with spaces; dangerous command";
    let quoted_input = Shlex::quote(user_input); // Escapes the input for shell safety
    let command_string = format!("ls {}", quoted_input);
    let output = Command::new("sh")
       .arg("-c")
       .arg(&command_string) // Shell executes the constructed string
       .output()?;
    ```
    

Die bevorzugte Methode (direkte Argumentübergabe) ist anzuwenden, wann immer dies möglich ist.

## 3. Benutzeroberfläche (Wayland-Integration)

Diese Spezifikation geht primär von einer Implementierung mittels des Smithay-Frameworks aus, was auf die Entwicklung einer spezialisierten Desktop-Shell oder eines Compositor-Bestandteils hindeutet. Alternative Ansätze mittels GTK oder Tauri werden nachrangig behandelt. Die Wahl des UI-Ansatzes hat tiefgreifende Auswirkungen auf die Implementierungsdetails dieses Abschnitts.

### 3.1. Compositor/Shell-Integration (Smithay)

- **Initialisierung:** Die Initialisierung des Compositors erfolgt unter Verwendung der Backend-Module von Smithay.9
    - **Grafik:** `smithay::backend::renderer` (mit Adaptern für EGL/GBM/DRM), `smithay::backend::drm` für die Verwaltung von Displays und Modi. Die Verwendung von `backend_egl` und `backend_drm` ist für typische Linux-Systeme erforderlich.
    - **Input:** `smithay::backend::input` oder bevorzugt `colpetto` für die Integration mit `libinput` und Tokio (siehe unten). `smithay::backend::session` (z.B. `libseat`) für das Session- und Gerätemanagement.
    - **Event Loop:** Die zentrale Event-Schleife basiert auf `calloop`, wie von Smithay vorgegeben.9 Alle Ereignisse (Wayland-Protokoll, Input, Timer) werden über Callbacks in dieser Schleife verarbeitet. Der zentrale Anwendungszustand wird als mutable Referenz an die Callbacks übergeben.
- **Fensterverwaltung (Window Management):** Die Verwaltung von Anwendungsfenstern erfolgt durch die Implementierung des `xdg-shell`-Protokolls.10
    - **Protokoll-Implementierung:** Smithay's Delegations-Makros (`delegate_xdg_shell`, `delegate_xdg_toplevel`, `delegate_xdg_popup`, `delegate_xdg_decoration`, etc.) werden genutzt, um die Server-seitige Logik für `xdg-shell` zu implementieren.9
    - **`xdg_toplevel` Handling:**
        - Anfragen verarbeiten: `set_title`, `set_app_id`, `set_maximized`, `unset_maximized`, `set_fullscreen`, `unset_fullscreen`, `set_minimized`, `move`, `resize`.10
        - Events beantworten: Auf `configure`-Events reagieren (Größe/Status anpassen) und mit `ack_configure` bestätigen. Auf `close`-Events reagieren.10
    - **`xdg_popup` Handling:**
        - Anfragen verarbeiten: `grab`, `reposition`.10
        - Events beantworten: Auf `configure`-Events reagieren (Position/Größe setzen) und mit `ack_configure` bestätigen. Auf `popup_done`-Events reagieren (Popup zerstören).10
    - **Tiling/Snapping:** Implementierung einer benutzerdefinierten Logik für Fensteranordnung (Tiling) oder Andocken (Snapping), inspiriert von Konzepten wie in Tiling Shell oder Snap Assistant.11 Algorithmen definieren, wie Fenster basierend auf Benutzeraktionen (z.B. Ziehen an den Rand), Tastenkürzeln oder der Anzahl der Fenster positioniert und in der Größe angepasst werden.
- **Eingabeverarbeitung (Input Handling):** Die Verarbeitung von Eingabeereignissen von Tastatur, Maus, Touchpad etc. erfolgt über `libinput`.
    - **Bibliothek:** Das Crate `colpetto` wird für die asynchrone Integration von `libinput` mit Tokio verwendet.12 `colpetto` bietet eine Stream-basierte API und berücksichtigt Thread-Sicherheitsaspekte von `libinput` in Tokio-Tasks.12
    - **Initialisierung:** Eine `colpetto::Libinput`-Instanz wird mit `Libinput::new()` erstellt, wobei Closures für das Öffnen und Schließen von Gerätedateien (mittels `rustix::fs::open`) übergeben werden.12 Ein Sitz wird mittels `libinput.assign_seat(c"seat0")` zugewiesen.
    - **Event Stream:** Der asynchrone Event-Stream wird mit `libinput.event_stream()` abgerufen.12
    - **Event Verarbeitung:** Der Stream wird asynchron mittels `while let Some(event) = stream.try_next().await?` verarbeitet.12 Eingehende `colpetto::Event`-Objekte werden mittels Pattern Matching auf `event.event_type()` unterschieden:
        - `EventType::KeyboardKey`: Downcast zu `KeyboardEvent` für Tastencode, Status (Pressed/Released).
        - `EventType::PointerMotion`, `PointerButton`, `PointerAxis`: Downcast zu entsprechenden `Pointer...Event`-Typen für Mausbewegungen, Klicks, Scrollen.
        - `EventType::TouchDown`, `TouchUp`, `TouchMotion`: Downcast zu `Touch...Event`-Typen für Touch-Interaktionen.
        - `EventType::GestureSwipe...`, `GesturePinch...`: Downcast zu `Gesture...Event`-Typen für Gesten.12
    - Die extrahierten Event-Daten werden verwendet, um Aktionen in der Anwendung oder Fensterverwaltungsbefehle auszulösen.
- **Theming:**
    - **Ansatz:** Implementierung eines benutzerdefinierten Theming-Systems. Dies kann auf einem System von Design Tokens basieren, ähnlich wie bei Material Design 3 oder USWDS.13 Tokens definieren Farbpaletten, Typografie, Abstände etc.
    - **Implementierung:** Die Token-Werte werden (z.B. aus einer Konfigurationsdatei) geladen und zur Laufzeit beim Rendern der UI-Elemente angewendet. Alternativ kann eine Integration mit Systemeinstellungen über D-Bus/GSettings erfolgen (siehe Abschnitt 5.8), um z.B. das System-Theme (hell/dunkel) zu übernehmen.

### 3.2. Framework-Integration (Alternativ: GTK/Tauri)

- **GTK:**
    - **Bibliothek:** `gtk4-rs` Bindings verwenden.15
    - **Wayland:** `gdk4-wayland` für spezifische Wayland-Interaktionen nutzen, falls erforderlich.16 Das Standard-GTK-Wayland-Backend übernimmt die meiste Integration.
    - **Systemeinstellungen:** `Gtk.Settings` abfragen, z.B. `is_gtk_application_prefer_dark_theme()`.15
    - **Styling:** `GtkCssProvider` verwenden, um CSS-Daten zu laden und auf Widgets anzuwenden. CSS-Selektoren zielen auf GTK-Widget-Namen und -Klassen. (Hinweis: Detaillierte `GtkCssProvider`-API-Dokumentation muss extern konsultiert werden, da 17 nicht verfügbar war).
- **Tauri:**
    - **Framework:** Tauri-Framework nutzen.18
    - **Backend-Kommunikation:** Rust-Funktionen mit `#[tauri::command]` annotieren.19 Aufruf vom Frontend mittels `invoke()`. Datenübergabe (Argumente, Rückgabewerte, Fehler) zwischen Frontend und Backend definieren.
    - **Events:** Tauri's Event-System (`emit`, `listen`) für asynchrone Benachrichtigungen nutzen.
    - **Frontend:** UI und Styling erfolgen mit Standard-Webtechnologien (HTML, CSS, JavaScript-Framework) innerhalb der Tauri-Webview.

## 4. Systemdienste-Integration (D-Bus APIs)

Die Interaktion mit verschiedenen Systemdiensten erfolgt über deren D-Bus-Schnittstellen.

### 4.1. D-Bus Bibliothek

Die `zbus`-Bibliothek wird für sämtliche D-Bus-Interaktionen verwendet.20 Die `tokio`-Integration von `zbus` wird aktiviert (`features = ["tokio"]`, `default-features = false`), um eine nahtlose Integration in die asynchrone Architektur der Anwendung zu gewährleisten.22 Das `#[proxy]`-Makro von `zbus` wird zur Definition von Client-seitigen Proxies für die D-Bus-Schnittstellen verwendet.22

### 4.2. Geheimnisverwaltung (Freedesktop Secret Service)

Zur sicheren Speicherung von sensiblen Daten wie API-Schlüsseln wird die Freedesktop Secret Service API genutzt.23

- **Schnittstelle:** `org.freedesktop.Secrets` auf dem **Session Bus**.23
- **Proxy:** Es werden `zbus`-Proxy-Traits für die Schnittstellen `org.freedesktop.Secrets.Service`, `org.freedesktop.Secrets.Collection` und `org.freedesktop.Secrets.Item` definiert.22
- **Schlüsselmethoden und Eigenschaften:**
    - `Service::OpenSession()`: Erforderlich vor Operationen wie `CreateItem`. Nur eine Session pro Client.23
    - `Service::DefaultCollection` (Eigenschaft): Pfad zur Standard-Collection abrufen (`/org/freedesktop/secrets/aliases/default`).23 Geheimnisse sollten standardmäßig hier gespeichert werden.
    - `Collection::CreateItem(fields: Dict<String,String>, secret: Secret, label: String, replace: bool)`: Speichert ein neues Geheimnis. `fields` sind Suchattribute. `secret` ist eine Struktur mit `algorithm` (z.B. "PLAIN"), `parameters` (`Array<Byte>`) und `value` (`Array<Byte>`).23
    - `Collection::SearchItems(fields: Dict<String,String>)`: Sucht nach Items innerhalb der Collection anhand von Attributen.23
    - `Service::RetrieveSecrets(items: Array<ObjectPath>)`: Ruft die Geheimniswerte für gegebene Item-Pfade ab.23
    - `Item::Delete()`: Löscht ein spezifisches Geheimnis.23
    - `Item::Secret` (Eigenschaft): Lesen/Schreiben des Geheimniswerts (als `Secret`-Struktur).23
    - `Item::Attributes` (Eigenschaft): Lesen/Schreiben der Suchattribute.23
- **Sperren/Entsperren:** Der `Locked`-Status wird über Eigenschaften der Collection/Item geprüft. Falls `true`, muss die `org.freedesktop.Secrets.Session`-Schnittstelle (erhalten von `OpenSession`) verwendet werden: `Session::BeginAuthenticate()` initiiert den Entsperrvorgang.23
- **Datenstrukturen:** `std::collections::HashMap<String, String>` für Attribute. Für die `Secret`-Struktur und andere D-Bus-Typen werden entsprechende Rust-Typen oder `zbus::zvariant::Value` / `OwnedValue` in den Proxy-Definitionen verwendet.22

### 4.3. Netzwerkverwaltung (NetworkManager)

Zur Abfrage des Netzwerkstatus und zur Verwaltung von Verbindungen wird NetworkManager über D-Bus angesprochen.

- **Schnittstelle:** `org.freedesktop.NetworkManager` und zugehörige Schnittstellen (z.B. `.Device`, `.Connection.Active`) auf dem **System Bus**.26
- **Proxy:** `zbus`-Proxy-Traits definieren.
- **Schlüsselmethoden, Eigenschaften und Signale:**
    - `Manager::GetDevices()`: Liste der Netzwerkgeräte abrufen.
    - `Manager::ActivateConnection()`, `Manager::DeactivateConnection()`: Netzwerkverbindungen aktivieren/deaktivieren (erfordert PolicyKit-Berechtigungen).
    - `Manager::State` (Eigenschaft): Globalen Netzwerkstatus abrufen (z.B. verbunden, getrennt).
    - `Manager::ActiveConnections` (Eigenschaft): Liste der aktiven Verbindungspfade.
    - `Manager::StateChanged` (Signal): Änderungen im globalen Netzwerkstatus überwachen.27
    - `Device::State` (Eigenschaft): Status eines spezifischen Geräts.
    - `ActiveConnection::State` (Eigenschaft): Status einer aktiven Verbindung.

### 4.4. Energieverwaltung (UPower)

Informationen über den Batteriestatus und die Stromversorgung werden über UPower abgefragt.

- **Schnittstelle:** `org.freedesktop.UPower`, `org.freedesktop.UPower.Device` auf dem **System Bus**.28
- **Proxy:** `zbus`-Proxy-Traits definieren oder das Crate `upower_dbus` verwenden.29
- **Schlüsselmethoden, Eigenschaften und Signale:**
    - `UPower::EnumerateDevices()`: Liste der Energieverwaltungsgeräte.
    - `UPower::GetDisplayDevice()`: Primäres Anzeigegerät (Batterie/USV) abrufen.
    - `UPower::DeviceAdded`, `UPower::DeviceRemoved` (Signale): Geräteänderungen überwachen.
    - `Device::OnBattery` (Eigenschaft): Prüfen, ob auf Batteriebetrieb.
    - `Device::Percentage` (Eigenschaft): Ladezustand in Prozent.
    - `Device::State` (Eigenschaft): Lade-/Entladezustand (z.B. Charging, Discharging, FullyCharged).
    - `Device::TimeToEmpty`, `Device::TimeToFull` (Eigenschaften): Geschätzte Restlaufzeit/Ladezeit in Sekunden.
    - `Device::Changed` (Signal): Änderungen an Geräteeigenschaften überwachen.28

### 4.5. Sitzungs- und Systemsteuerung (logind)

Systemweite Aktionen wie Suspend, Reboot oder das Sperren der Sitzung werden über `systemd-logind` gesteuert.

- **Schnittstelle:** `org.freedesktop.login1.Manager`, `org.freedesktop.login1.Session` auf dem **System Bus**.30
- **Proxy:** `zbus`-Proxy-Traits definieren oder das Crate `logind-dbus` verwenden.31
- **Schlüsselmethoden, Eigenschaften und Signale:**
    - `Manager::Suspend(interactive: false)`, `Hibernate(false)`, `Reboot(false)`, `PowerOff(false)`: Systemzustandsänderungen initiieren (erfordert PolicyKit-Berechtigungen).30 Der Parameter `interactive=false` wird verwendet, um Benutzerinteraktion für die Autorisierung zu vermeiden.
    - `Manager::LockSessions()`: Alle aktiven Sitzungen sperren.
    - `Session::Lock()`: Die spezifische Sitzung sperren, die dem Session-Objekt zugeordnet ist.30
    - `Manager::GetSession(session_id)`, `Manager::GetUser(uid)`: Objektpfade für spezifische Sitzungen/Benutzer abrufen.
    - `Manager::IdleHint` (Eigenschaft): System-Idle-Status abfragen.
    - `Manager::PrepareForShutdown(start: bool)` (Signal): Signal vor (`true`) und nach (`false`) dem Beginn des Shutdown-Prozesses.30 Kann für Aufräumarbeiten genutzt werden (ggf. mit Inhibitor Locks).

### 4.6. Benachrichtigungen (Freedesktop Notifications)

Desktop-Benachrichtigungen werden über die standardisierte Notifications-Schnittstelle gesendet.

- **Schnittstelle:** `org.freedesktop.Notifications` auf dem **Session Bus**.32
- **Proxy:** `zbus`-Proxy-Trait definieren.22
- **Schlüsselmethoden und Signale:**
    - `Notify(app_name: String, replaces_id: u32, app_icon: String, summary: String, body: String, actions: Array<String>, hints: Dict<String, Variant>, expire_timeout: i32) -> u32`: Sendet eine Benachrichtigung. `actions` ist ein Array von `[action_key1, display_name1, action_key2, display_name2,...]`. Der Standard-Aktionsschlüssel ist `"default"`. `hints` können z.B. Dringlichkeit (`urgency`) oder Kategorie (`category`) enthalten. `expire_timeout` in ms (-1 = default, 0 = nie).32 Gibt die Benachrichtigungs-ID zurück.
    - `CloseNotification(id: u32)`: Schließt eine Benachrichtigung anhand ihrer ID.32
    - `NotificationClosed(id: u32, reason: u32)` (Signal): Wird gesendet, wenn eine Benachrichtigung geschlossen wird (Grund: 1=expired, 2=dismissed, 3=closed by call, 4=undefined).32
    - `ActionInvoked(id: u32, action_key: String)` (Signal): Wird gesendet, wenn der Benutzer auf eine Aktion (oder den Benachrichtigungskörper für `"default"`) klickt.32

### 4.7. Berechtigungsverwaltung (PolicyKit)

Für Aktionen, die erhöhte Rechte erfordern, wird PolicyKit zur Autorisierungsprüfung verwendet.

- **Schnittstelle:** `org.freedesktop.PolicyKit1.Authority` auf dem **System Bus**.33
- **Proxy:** `zbus`-Proxy-Trait definieren.
- **Verwendung:** Notwendig für privilegierte Operationen wie `logind`-Energieaktionen oder `NetworkManager`-Verbindungsänderungen.27
- **Schlüsselmethode:** `CheckAuthorization(subject, action_id, details, flags, cancellation_id) -> AuthorizationResult`: Prüft, ob das anfragende Subjekt (Prozess) die Berechtigung für die angegebene `action_id` hat.
    - `subject`: Identifiziert den Prozess/Benutzer, für den die Prüfung erfolgt (oft der aufrufende Prozess).
    - `action_id`: Die spezifische PolicyKit-Aktions-ID (z.B. `org.freedesktop.login1.power-off`). Diese IDs müssen für alle privilegierten Aktionen der Anwendung identifiziert und dokumentiert werden.
    - `details`: Zusätzliche kontextabhängige Informationen.
    - `flags`: Steuert das Verhalten (z.B. ob Interaktion erlaubt ist).
    - **Rückgabe (`AuthorizationResult`):** Enthält Informationen, ob die Aktion erlaubt ist (`authorized`), ob Benutzerinteraktion/Authentifizierung erforderlich ist (`challenge`) oder ob sie verboten ist (`not_authorized`).
- **Authentifizierungsagenten:** Wenn das Ergebnis `challenge` ist, muss die Anwendung möglicherweise mit einem PolicyKit Authentication Agent interagieren, um den Benutzer zur Eingabe eines Passworts aufzufordern.33 Die genaue Interaktion hängt von der Systemkonfiguration und den `flags` ab.

Die Notwendigkeit von PolicyKit-Prüfungen impliziert, dass für die korrekte Funktion der Anwendung auf dem Zielsystem entsprechende PolicyKit-Regeln konfiguriert sein müssen, die der Anwendung die notwendigen Berechtigungen erteilen (ggf. nach Authentifizierung). Dies ist ein wichtiger Aspekt für die Installation und Systemadministration.

### 4.8. Systemeinstellungen (GSettings/DConf)

Zum Lesen von systemweiten oder benutzerspezifischen Einstellungen (z.B. Theme, Schriftarten) wird GSettings verwendet, das typischerweise DConf als Backend nutzt.

- **Schnittstelle:** Direkte Interaktion mit der D-Bus-Schnittstelle des DConf-Dienstes (z.B. `ca.desrt.dconf` auf dem **Session Bus**) mittels `zbus` oder Verwendung von GIO-Bindings (`gtk-rs`/`gio`), falls GTK integriert ist. Das Crate `gnome-dbus-api` 34 bietet spezifische Abstraktionen, ist aber möglicherweise zu GNOME-spezifisch.
- **Proxy:** Bei direkter D-Bus-Nutzung: `zbus`-Proxy für die DConf-Schnittstelle (z.B. `ca.desrt.dconf.Read`).
- **Verwendung:** Lesen von relevanten Schlüsseln (z.B. unter `/org/gnome/desktop/interface/` für GTK-Theme, Schriftart; `/org/gnome/desktop/a11y/` für Barrierefreiheit). Überwachung von Schlüsseländerungen mittels D-Bus-Signalen (`ca.desrt.dconf.Watch`).

### 4.9. D-Bus Schnittstellenübersicht

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Schnittstellenname**|**D-Bus Pfad**|**Bus Typ**|**Schlüsselmethoden/Eigenschaften/Signale**|**Zweck in der Anwendung**|**Erforderliche Berechtigungen (PolicyKit Action ID)**|
|`org.freedesktop.Secrets.Service`|`/org/freedesktop/secrets`|Session|`OpenSession`, `DefaultCollection`, `RetrieveSecrets`|Sichere Speicherung/Abruf von API-Schlüsseln etc.|-|
|`org.freedesktop.Secrets.Collection`|`/org/freedesktop/secrets/collection/*`|Session|`CreateItem`, `SearchItems`, `Locked` (Prop)|Verwaltung von Geheimnissen in einer Collection|-|
|`org.freedesktop.Secrets.Item`|`/org/freedesktop/secrets/item/*`|Session|`Delete`, `Secret` (Prop), `Attributes` (Prop), `Locked` (Prop)|Zugriff/Verwaltung einzelner Geheimnisse|-|
|`org.freedesktop.Secrets.Session`|(von `OpenSession` erhalten)|Session|`BeginAuthenticate`|Entsperren von Collections/Items|-|
|`org.freedesktop.NetworkManager`|`/org/freedesktop/NetworkManager`|System|`GetDevices`, `ActivateConnection`, `DeactivateConnection`, `State` (Prop), `ActiveConnections` (Prop), `StateChanged` (Sig)|Netzwerkstatus abfragen, Verbindungen verwalten|`org.freedesktop.NetworkManager.network-control`|
|`org.freedesktop.UPower`|`/org/freedesktop/UPower`|System|`EnumerateDevices`, `GetDisplayDevice`, `DeviceAdded` (Sig), `DeviceRemoved` (Sig)|Energiegeräte erkennen|-|
|`org.freedesktop.UPower.Device`|`/org/freedesktop/UPower/devices/*`|System|`OnBattery` (Prop), `Percentage` (Prop), `State` (Prop), `TimeToEmpty` (Prop), `TimeToFull` (Prop), `Changed` (Sig)|Batteriestatus/Energiequelle abfragen|-|
|`org.freedesktop.login1.Manager`|`/org/freedesktop/login1`|System|`Suspend`, `Hibernate`, `Reboot`, `PowerOff`, `LockSessions`, `GetSession`, `GetUser`, `IdleHint` (Prop), `PrepareForShutdown` (Sig)|Systemsteuerung (Energie, Idle, Sitzungen sperren)|`org.freedesktop.login1.suspend`, `.hibernate`, `.reboot`, `.power-off`, `.lock-sessions`|
|`org.freedesktop.login1.Session`|`/org/freedesktop/login1/session/*`|System|`Lock`|Einzelne Sitzung sperren|`org.freedesktop.login1.lock-session` (implizit)|
|`org.freedesktop.Notifications`|`/org/freedesktop/Notifications`|Session|`Notify`, `CloseNotification`, `NotificationClosed` (Sig), `ActionInvoked` (Sig)|Desktop-Benachrichtigungen senden/verwalten|-|
|`org.freedesktop.PolicyKit1.Authority`|`/org/freedesktop/PolicyKit1/Authority`|System|`CheckAuthorization`|Berechtigungen für privilegierte Aktionen prüfen|-|
|`ca.desrt.dconf` (Beispiel)|`/ca/desrt/dconf`|Session|`Read`, `Watch` (Signale)|Systemeinstellungen (Theme, Fonts etc.) lesen/überwachen|-|

## 5. LLM-Integration (Model Context Protocol - MCP)

Die Integration mit Large Language Models (LLMs) erfolgt über das Model Context Protocol (MCP).35 Die Anwendung agiert als MCP-Host/Client.

### 5.1. MCP Client Implementierungsstrategie

Die Implementierung des MCP-Clients erfolgt unter Verwendung des offiziellen Rust SDKs (`modelcontextprotocol/rust-sdk`), sofern dieses bei Projektstart ausreichend stabil und vollständig ist.35 Sollte das offizielle SDK nicht verfügbar oder unzureichend sein, wird das inoffizielle SDK (`jeanlucthumm/modelcontextprotocol-rust-sdk`) evaluiert und ggf. genutzt.37 Als Fallback-Option wird der MCP-Client manuell implementiert, basierend auf der JSON-RPC 2.0 Spezifikation unter Verwendung des `jsonrpc-v2`-Crates 38 und `serde` für die (De-)Serialisierung. **Die gewählte Strategie ist:**.

### 5.2. Transportmechanismus

Der für die MCP-Kommunikation zu unterstützende Transportmechanismus ist ****.

- **WebSocket:** Die Implementierung erfolgt mittels `tokio-tungstenite` oder einer äquivalenten, Tokio-kompatiblen WebSocket-Client-Bibliothek.40
- **Standard I/O (stdio):** Nachrichten werden über die Standard-Ein-/Ausgabe des Prozesses gesendet/empfangen, wobei JSON-RPC-Nachrichten korrekt gerahmt (z.B. durch Längenpräfixe oder Trennzeichen) und geparst werden müssen.
- **Server-Sent Events (SSE):** Eine HTTP-Verbindung wird aufgebaut, und Nachrichten vom Server werden als SSE empfangen. Anfragen vom Client an den Server erfordern einen separaten Mechanismus (typischerweise HTTP POST an einen definierten Endpunkt).

### 5.3. Verbindungsaufbau und Initialisierung

Die Logik zum Aufbau der Verbindung über den gewählten Transportmechanismus wird implementiert. Nach erfolgreichem Verbindungsaufbau erfolgt der MCP-Initialisierungs-Handshake gemäß Spezifikation 36:

1. Client sendet `initialize`-Request mit seinen Fähigkeiten (`ClientCapabilities`).
2. Server antwortet mit `initialize`-Response, die seine Fähigkeiten (`ServerCapabilities`) enthält.
3. Client sendet `initialized`-Notification an den Server.

### 5.4. Anfrage/Antwort-Verarbeitung (JSON-RPC 2.0)

Alle MCP-Nachrichten folgen dem JSON-RPC 2.0 Format.36

- **Serialisierung/Deserialisierung:** Das `serde`-Crate 41 wird verwendet, um Rust-Datenstrukturen (die die MCP-Schema-Typen abbilden) in JSON zu serialisieren (für Requests/Notifications) und JSON-Antworten/Notifications in Rust-Strukturen zu deserialisieren. Die MCP-Schema-Definitionen 36 sind maßgeblich für die Struktur der Rust-Typen.
- **Methoden-Handler (Server -> Client):** Implementierung von Handlern für vom Server initiierte Anfragen:
    - **`tool/call`:**
        1. Empfange `tool/call`-Request vom Server.
        2. **Einwilligungsprüfung:** Zeige dem Benutzer eine Aufforderung zur expliziten Bestätigung an, die klar beschreibt, welche Aktion das Tool (`toolId`) mit den gegebenen Argumenten (`inputs`) ausführen wird.36 Warte auf Benutzerinteraktion.
        3. Bei Zustimmung: Führe die lokale Funktion aus, die dem `toolId` entspricht.
        4. Bei Ablehnung oder Fehler: Sende eine entsprechende JSON-RPC-Fehlerantwort an den Server.
        5. Bei erfolgreicher Ausführung: Serialisiere das Ergebnis und sende eine `tool/result`-Antwort an den Server.
    - **`resource/read`:**
        1. Empfange `resource/read`-Request vom Server.
        2. **Einwilligungsprüfung:** Zeige dem Benutzer eine Aufforderung zur expliziten Bestätigung an, die klar beschreibt, welche Daten (`resourceId`) angefragt werden.36 Warte auf Benutzerinteraktion.
        3. Bei Zustimmung: Rufe die angeforderten Ressourcendaten ab (z.B. Dateiinhalt, Datenbankabfrage).
        4. Bei Ablehnung oder Fehler: Sende eine entsprechende JSON-RPC-Fehlerantwort.
        5. Bei Erfolg: Serialisiere die Ressourcendaten und sende eine `resource/result`-Antwort.
    - **`sampling/request`:**
        1. Empfange `sampling/request`-Request vom Server.
        2. **Einwilligungsprüfung (Stufe 1):** Prüfe, ob der Benutzer Sampling generell erlaubt hat.
        3. **Einwilligungsprüfung (Stufe 2 - Kritisch):** Zeige dem Benutzer den exakten Prompt (`prompt`), der an das LLM gesendet werden soll, zur expliziten Genehmigung an.36 Der Benutzer muss die Möglichkeit haben, den Prompt zu ändern oder abzulehnen.
        4. **Einwilligungsprüfung (Stufe 3):** Konfiguriere, welche Teile der LLM-Antwort der Server sehen darf, basierend auf Benutzereinstellungen/-genehmigung.36
        5. Bei Zustimmung: Interagiere mit dem LLM (lokal oder über API).
        6. Filtere die LLM-Antwort gemäß Stufe 3 der Einwilligung.
        7. Bei Ablehnung oder Fehler: Sende eine entsprechende JSON-RPC-Fehlerantwort.
        8. Bei Erfolg: Serialisiere die (gefilterte) LLM-Antwort und sende eine `sampling/response`-Antwort.

### 5.5. Notification-Verarbeitung (Server -> Client)

Implementierung von Handlern für eingehende MCP-Notifications vom Server (z.B. `$/progress`, Statusänderungen), um den UI-Zustand entsprechend zu aktualisieren.

### 5.6. Einwilligungsmanagement (Consent Management)

Die Verwaltung der Benutzereinwilligung ist ein **zentraler und kritischer Aspekt** der MCP-Implementierung.36

- **Explizite Zustimmung:** Für _jede_ `tool/call`-, `resource/read`- und `sampling`-Anfrage vom Server _muss_ eine explizite, informierte Zustimmung des Benutzers eingeholt werden, _bevor_ die Aktion ausgeführt oder Daten preisgegeben werden.
- **UI-Fluss:** Implementierung klarer und verständlicher UI-Dialoge für Einwilligungsanfragen. Diese müssen präzise angeben:
    - Welches Tool ausgeführt werden soll und was es tut.
    - Welche Ressource gelesen werden soll und welche Daten sie enthält.
    - Welcher genaue Prompt für das Sampling verwendet wird (mit Änderungs-/Ablehnungsoption).
    - Welche Ergebnisse der Server sehen darf (bei Sampling).
- **Persistenz:** Einwilligungsentscheidungen können optional persistent gespeichert werden (z.B. "Für diese Sitzung merken", "Immer erlauben/ablehnen für dieses Tool/diese Ressource"). Diese persistenten Zustimmungen müssen sicher gespeichert werden, idealerweise über die Freedesktop Secret Service API (siehe Abschnitt 4.2), falls sie sensible Berechtigungen abdecken.

### 5.7. Sicherheitsaspekte

Die Implementierung muss die MCP-Sicherheitsprinzipien strikt befolgen 36:

- **User Consent and Control:** Absolute Priorität (siehe 5.6).
- **Data Privacy:** Keine Datenweitergabe ohne explizite Zustimmung. Strenge Zugriffskontrollen auf lokale Daten.
- **Tool Safety:** Tool-Beschreibungen vom Server als potenziell nicht vertrauenswürdig behandeln.36 Tools mit minimal notwendigen Rechten ausführen. Kritische Aktionen erfordern menschliche Bestätigung.
- **LLM Sampling Controls:** Benutzerkontrolle über Prompt und Sichtbarkeit der Ergebnisse sicherstellen.36
- **Input Validation:** Alle vom Server empfangenen Daten (insbesondere in `tool/call`-Argumenten) validieren.42
- **Rate Limiting/Timeouts:** Implementierung von Timeouts für MCP-Anfragen. Falls die Anwendung auch als MCP-Server agiert, ist Rate Limiting erforderlich.42

Die Sicherheit des Gesamtsystems hängt maßgeblich von der korrekten Implementierung der Einwilligungs- und Kontrollmechanismen im MCP-Client ab, da das Protokoll selbst diese nicht erzwingt.

### 5.8. MCP Nachrichtenverarbeitung

|   |   |   |   |   |
|---|---|---|---|---|
|**MCP Methode/Notification**|**Richtung**|**Schlüsselparameter**|**Aktion im Client**|**Einwilligungsanforderung**|
|`initialize`|C -> S|`processId`, `clientInfo`, `capabilities`|Sende Client-Fähigkeiten an Server.|-|
|`initialize`|S -> C|`serverInfo`, `capabilities`|Empfange und speichere Server-Fähigkeiten.|-|
|`initialized`|C -> S|-|Bestätige erfolgreiche Initialisierung.|-|
|`shutdown`|C -> S|-|Informiere Server über bevorstehende Trennung.|-|
|`shutdown`|S -> C|-|Empfange Bestätigung für Shutdown.|-|
|`exit`|C -> S|-|Informiere Server über sofortige Trennung.|-|
|`exit`|S -> C|-|Informiere Client über sofortige Trennung durch Server.|-|
|`tool/call`|S -> C|`callId`, `toolId`, `inputs`|**Fordere explizite Zustimmung an.** Bei Zustimmung: Führe Tool aus. Sende `tool/result` oder Fehlerantwort.|**Ja (Explizit, pro Aufruf)** für Ausführung des Tools mit gegebenen Parametern.36|
|`tool/result`|C -> S|`callId`, `result` / `error`|Sende Ergebnis oder Fehler der Tool-Ausführung an Server.|- (Einwilligung erfolgte vor Ausführung)|
|`resource/read`|S -> C|`readId`, `resourceId`, `params`|**Fordere explizite Zustimmung an.** Bei Zustimmung: Lese Ressource. Sende `resource/result` oder Fehlerantwort.|**Ja (Explizit, pro Lesezugriff)** für Zugriff auf die spezifische Ressource.36|
|`resource/result`|C -> S|`readId`, `resource` / `error`|Sende Ressourcendaten oder Fehler an Server.|- (Einwilligung erfolgte vor Lesezugriff)|
|`sampling/request`|S -> C|`sampleId`, `prompt`, `params`|**Fordere explizite Zustimmung an (Prompt-Review!).** Bei Zustimmung: Führe LLM-Sampling aus. Sende `sampling/response`.|**Ja (Explizit, pro Anfrage)**, muss Genehmigung des _exakten Prompts_ und Kontrolle über Ergebnis-Sichtbarkeit beinhalten.36|
|`sampling/response`|C -> S|`sampleId`, `response` / `error`|Sende (gefiltertes) LLM-Ergebnis oder Fehler an Server.|- (Einwilligung erfolgte vor Sampling)|
|`$/progress`|S -> C|`token`, `value`|Aktualisiere UI, um Fortschritt anzuzeigen.|-|
|_Weitere Notifications_|S -> C|_Spezifisch_|Verarbeite server-spezifische Benachrichtigungen.|-|

## 6. Sicherheitsimplementierungsdetails

Eine umfassende Sicherheitsstrategie ist erforderlich, die verschiedene Angriffsvektoren berücksichtigt.

### 6.1. Eingabebereinigung

- **HTML:** Wie in Abschnitt 2.1 beschrieben, wird `ammonia` mit einer strikten Whitelist-Konfiguration verwendet, um jeglichen von externen Quellen (insbesondere LLM-Ausgaben) stammenden HTML-Code zu bereinigen.3
- **Kommandozeilenargumente:** Wie in Abschnitt 2.2 beschrieben, wird die direkte Übergabe von Argumenten an `std::process::Command` bevorzugt, um Shell-Injection zu verhindern.7 Bei unvermeidbarer Shell-Nutzung wird `shlex::quote` verwendet.

### 6.2. LLM-Interaktionssicherheit

LLM-Interaktionen bergen spezifische Risiken, die adressiert werden müssen.

- **Ausgabebewertung/-bereinigung:**
    - **Zero-Trust-Ansatz:** Jede LLM-Ausgabe wird als nicht vertrauenswürdig behandelt.4
    - **Validierung:** Wenn strukturierte Ausgabe (z.B. JSON) erwartet wird, muss diese gegen ein Schema validiert werden.43 Ungültige oder unerwartete Strukturen werden abgelehnt.
    - **Bereinigung:** Freitextausgaben, die potenziell Markup enthalten könnten, werden mit `ammonia` bereinigt (siehe 6.1).4
    - **Downstream-Schutz:** Es muss sichergestellt werden, dass LLM-Ausgaben keine schädlichen Aktionen in nachgelagerten Komponenten auslösen können (z.B. Ausführung von generiertem Code, Einschleusung von Befehlen, XSS in Webviews).4
- **Prompt-Injection-Mitigation:** Maßnahmen gegen Prompt Injection (OWASP LLM #1 44) sind unerlässlich:
    - **Eingabefilterung:** Benutzereingaben, die Teil eines Prompts werden, werden gefiltert, um bekannte Angriffsmuster zu erkennen und zu neutralisieren.44
    - **Trennung von Instruktionen und Daten:** Innerhalb des Prompts werden Systeminstruktionen klar von Benutzereingaben oder externen Daten getrennt (z.B. durch spezielle Markierungen oder strukturierte Formate wie ChatML, falls vom LLM unterstützt).45
    - **Least Privilege:** Über MCP bereitgestellte Tools, die vom LLM aufgerufen werden können, dürfen nur die minimal notwendigen Berechtigungen haben.44
    - **Menschliche Bestätigung:** Hoch-Risiko-Aktionen, die durch LLM-Interaktion ausgelöst werden (z.B. Dateilöschung, Senden von E-Mails), erfordern eine explizite Bestätigung durch den Benutzer über die MCP-Einwilligungsmechanismen (siehe 5.6).44

### 6.3. Sichere Speicherung

Sensible Daten wie API-Schlüssel oder persistente Benutzereinwilligungen werden ausschließlich über die Freedesktop Secret Service API gespeichert (siehe Abschnitt 4.2).23 Sie dürfen niemals im Klartext in Konfigurationsdateien oder im Quellcode gespeichert werden.

Die Kombination dieser Maßnahmen (Input Sanitization, Output Validation, Prompt Injection Mitigation, Secure Storage) bildet eine mehrschichtige Verteidigung (Defense in Depth), die für die Sicherheit der Anwendung entscheidend ist. Die Orientierung an den OWASP Top 10 für LLMs 4 hilft dabei, die relevantesten Risiken zu adressieren.

## 7. Konfigurationsmanagement

### 7.1. Format

Die Konfiguration der Anwendung erfolgt über Dateien im TOML-Format. TOML ist gut lesbar und wird von `serde` unterstützt.41

### 7.2. Parsen

- **Bibliothek:** Das `serde`-Crate 41 in Kombination mit `serde_toml` wird zum Parsen der TOML-Dateien verwendet. Eine zentrale `Config`-Struktur wird mit `#` annotiert.
- **Optional:** Das `config-rs`-Crate kann alternativ verwendet werden, um das Mergen von Konfigurationen aus verschiedenen Quellen (Datei, Umgebungsvariablen) zu vereinfachen.
- **Beispielgenerierung:** Das `toml-example`-Crate 47 kann optional genutzt werden, um automatisch Beispiel-Konfigurationsdateien basierend auf der `Config`-Struktur und deren Dokumentationskommentaren zu generieren.

### 7.3. Speicherort

Konfigurationsdateien werden an standardkonformen Orten gemäß der XDG Base Directory Specification gesucht:

1. Benutzerspezifisch: `$XDG_CONFIG_HOME/app-name/config.toml` (Fallback: `~/.config/app-name/config.toml`)
2. Systemweit: `/etc/xdg/app-name/config.toml` (Fallback: `/etc/app-name/config.toml`)

Benutzerspezifische Einstellungen überschreiben systemweite Einstellungen.

### 7.4. Parameter

Alle konfigurierbaren Parameter werden in der zentralen `Config`-Struktur definiert und in der folgenden Tabelle dokumentiert.

### 7.5. Konfigurationsparameter

|   |   |   |   |   |
|---|---|---|---|---|
|**Parameter Name (TOML Schlüssel)**|**Rust Typ**|**Standardwert**|**Beschreibung**|**Erforderlich**|
|`mcp.transport_type`|`String`|`"websocket"`|Transportmechanismus für MCP ("websocket", "stdio", "sse").|Nein|
|`mcp.server_address`|`Option<String>`|`None`|Adresse des MCP-Servers (z.B. "ws://localhost:8080" für WebSocket).|Ja (falls!= stdio)|
|`llm.api_key_secret_service_key`|`Option<String>`|`None`|Attribut-Schlüssel (z.B. `llm_api_key`) zum Suchen des LLM-API-Schlüssels im Secret Service.|Nein|
|`ui.theme`|`Option<String>`|`None`|Pfad zu einer benutzerdefinierten Theme-Datei oder Name eines System-Themes.|Nein|
|`logging.level`|`String`|`"info"`|Log-Level (z.B. "trace", "debug", "info", "warn", "error").|Nein|
|`persistence.database_path`|`Option<String>`|`None`|Pfad zur SQLite-Datenbankdatei (falls Persistenz aktiviert).|Nein|
|**|**|**|**|_[Ja/Nein]_|

Diese klare Definition der Konfiguration verbessert die Benutzerfreundlichkeit und Wartbarkeit der Anwendung.

## 8. Datenpersistenz (Falls zutreffend)

### 8.1. Anforderung

Persistente Speicherung wird benötigt für: ****

### 8.2. Datenbanksystem

SQLite wird als Datenbanksystem verwendet.48 Es ist dateibasiert, erfordert keine separate Serverinstallation und eignet sich gut für Desktop-Anwendungen.

### 8.3. ORM/Query Builder

`sqlx` wird als primäre Bibliothek für die Datenbankinteraktion eingesetzt.48 `sqlx` bietet asynchrone Operationen, Compile-Zeit-geprüfte SQL-Abfragen und integriertes Migrationsmanagement.

### 8.4. Schema-Definition & Migrationen

- **Schema:** Das Datenbankschema wird durch SQL-Dateien im Verzeichnis `migrations/` definiert. Jede Datei repräsentiert eine Migration und hat einen Zeitstempel als Präfix (z.B. `20250101120000_create_users_table.sql`).
- **Migrationen zur Laufzeit:** Die Migrationen werden zur Laufzeit beim Anwendungsstart automatisch angewendet. Dies geschieht durch Einbetten der Migrationsdateien mittels des `sqlx::migrate!`-Makros und Ausführen von `.run(&pool).await?` auf dem Migrator-Objekt.51
    
    Rust
    
    ```
    // Example in main application setup
    let pool = sqlx::sqlite::SqlitePoolOptions::new()
       .connect(&database_url).await?;
    sqlx::migrate!("./migrations").run(&pool).await?;
    ```
    
- **Entwicklung:** Während der Entwicklung kann `sqlx-cli migrate run` (nach Installation mit `cargo install sqlx-cli --features sqlite`) verwendet werden, um Migrationen manuell anzuwenden und zu testen.51 Der `DATABASE_URL` muss entsprechend gesetzt sein.

Die Einbettung von Migrationen stellt sicher, dass die Datenbankstruktur immer mit der Version des Anwendungscodes übereinstimmt, was die Bereitstellung vereinfacht.

### 8.5. Datenzugriffsschicht (Data Access Layer)

- **Strukturen:** Rust-Strukturen, die Datenbanktabellen oder Abfrageergebnisse repräsentieren, werden mit `#` annotiert.51
- **Abfragen:** SQL-Abfragen werden mittels der Makros `sqlx::query!("...")` (für Abfragen ohne Rückgabewert oder mit einfachen Typen) oder `sqlx::query_as!(OutputType, "...")` (zum Mappen von Ergebnissen auf `FromRow`-annotierte Strukturen) ausgeführt.51 Diese Makros prüfen die Abfragen zur Compile-Zeit gegen die Datenbank (erfordert gesetzten `DATABASE_URL` während des Builds).
- **Verbindungspooling:** Ein `sqlx::sqlite::SqlitePool` wird mittels `SqlitePoolOptions` konfiguriert und initialisiert, um Datenbankverbindungen effizient zu verwalten.51 Alle Datenbankoperationen werden über den Pool ausgeführt.

Die Compile-Zeit-Prüfung von `sqlx` reduziert das Risiko von Laufzeitfehlern aufgrund syntaktisch falscher oder typ-inkompatibler SQL-Abfragen erheblich.

## 9. Interaktion mit externen Prozessen

### 9.1. Anforderung

Die Anwendung muss mit folgenden externen Kommandozeilen-Tools interagieren: ****.8

### 9.2. Ausführung

Die Ausführung externer Prozesse erfolgt über die `std::process::Command`-API.8

- **Sicherheit:** Es wird **keine** Shell (`sh -c`, `bash -c` etc.) zur Ausführung verwendet, um Command Injection zu verhindern.7 Das auszuführende Programm wird direkt angegeben, und alle Argumente werden einzeln mittels `.arg()` oder `.args()` hinzugefügt.8
    
    Rust
    
    ```
    use std::process::{Command, Stdio};
    let search_term = "config.toml";
    let output = Command::new("/usr/bin/plocate") // Full path or ensure it's in PATH
       .arg("--ignore-case")
       .arg(search_term) // Argument passed directly
       .stdout(Stdio::piped())
       .stderr(Stdio::piped())
       .spawn()?
       .wait_with_output()?;
    ```
    

### 9.3. Ein-/Ausgabebehandlung

- **Standard Streams:** `stdout` und `stderr` werden mittels `Stdio::piped()` umgeleitet, um die Ausgabe des Kindprozesses lesen zu können.8 `stdin` kann ebenfalls mit `Stdio::piped()` umgeleitet werden, um Daten an den Kindprozess zu senden, indem auf den `stdin`-Handle geschrieben wird.8
- **Asynchrone Verarbeitung:** Falls die Ausgabe des Kindprozesses kontinuierlich oder nebenläufig verarbeitet werden muss, wird `tokio::process::Command` verwendet oder die Standard-Handles von `std::process` werden mit Tokio's I/O-Utilities (z.B. `tokio::io::BufReader`) integriert.

### 9.4. Argument-Maskierung

Da keine Shell verwendet wird, ist eine spezielle Maskierung von Argumenten im Allgemeinen nicht notwendig. Die Argumente werden vom Betriebssystem direkt an den Prozess übergeben. Sollte es _zwingende_ Gründe geben, einen Befehlsstring für eine Shell zu konstruieren (stark abgeraten), muss `shlex::quote` verwendet werden (siehe Abschnitt 2.2).7

### 9.5. Fehlerbehandlung

Der `ExitStatus` des beendeten Prozesses wird überprüft (`output.status.success()`).8 Ein nicht erfolgreicher Exit-Code (ungleich Null) wird als Fehler behandelt. Die `stderr`-Ausgabe wird gelesen und geloggt oder zur Fehleranalyse verwendet.8 Mögliche I/O-Fehler beim Lesen/Schreiben der Streams werden ebenfalls behandelt.

## 10. Schlussfolgerung

Diese Spezifikation legt die technischen Grundlagen für die Entwicklung der Anwendung fest, wobei ein starker Fokus auf Sicherheit, Robustheit und Integration in moderne Linux-Desktop-Umgebungen gelegt wird. Die Wahl von Rust und Tokio bildet die Basis für eine performante und nebenläufige Architektur.

Die detaillierte Spezifikation der D-Bus-Schnittstellen (Secret Service, NetworkManager, UPower, logind, Notifications, PolicyKit, GSettings) ermöglicht eine tiefe Integration mit Systemdiensten. Die konsequente Nutzung von `zbus` vereinheitlicht die D-Bus-Kommunikation. Besondere Aufmerksamkeit erfordert die korrekte Handhabung von PolicyKit für privilegierte Aktionen.

Die Integration des Model Context Protocols (MCP) ist ein Kernbestandteil für die LLM-Funktionalität. Die Implementierung muss die Sicherheitsprinzipien von MCP, insbesondere das explizite Einholen der Benutzereinwilligung für Tool-Ausführungen, Ressourcenzugriffe und LLM-Sampling (inklusive Prompt-Review), strikt umsetzen, da der Client hier als kritischer Gatekeeper fungiert.

Die Sicherheitsimplementierung adressiert bekannte Risiken durch Input-Sanitization (HTML mit `ammonia`, Kommandozeilenargumente), rigorose Behandlung von LLM-Ausgaben (Validierung, Bereinigung, Zero-Trust) und Maßnahmen gegen Prompt Injection gemäß OWASP LLM Top 10. Die sichere Speicherung sensibler Daten über den Secret Service ist obligatorisch.

Die Wahl des UI-Frameworks (primär Smithay für eine Compositor/Shell-Komponente, alternativ GTK/Tauri) bestimmt maßgeblich die Implementierung der Benutzeroberfläche und der Wayland-Integration. Bei Verwendung von Smithay ist die korrekte Handhabung von `xdg-shell` und die asynchrone Eingabeverarbeitung mittels `colpetto` entscheidend.

Die Verwendung von `sqlx` für die Datenpersistenz (falls erforderlich) mit Compile-Zeit-geprüften Abfragen und eingebetteten Migrationen erhöht die Zuverlässigkeit der Datenbankinteraktion.

Die Einhaltung dieser Spezifikationen, insbesondere in den Bereichen Sicherheit, Einwilligungsmanagement und Systemintegration, ist entscheidend für den Erfolg und die Vertrauenswürdigkeit des Projekts.