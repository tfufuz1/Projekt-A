1. **Definierte APIs (Traits & öffentliche Funktionen):**
    
    - **Kernschicht:** Stellt ihre Funktionalität über `pub` Funktionen und direkt nutzbare `pub` Typen bereit.
    - **Domänenschicht:** Definiert ihre Service-Schnittstellen primär über `pub trait ...: Send + Sync {}` (oft mit `#[async_trait::async_trait]`). Diese Traits werden von konkreten Service-Strukturen implementiert, die typischerweise mit `Arc<tokio::sync::Mutex/RwLock<InternalState>>` arbeiten, um Zustand zu verwalten.
    - **Systemschicht:** Definiert ebenfalls Service-Schnittstellen über Traits für Funktionen, die von der UI-Schicht aufgerufen werden können (z.B. `SystemPowerControlTrait`). Für interne Operationen oder Callbacks von externen Bibliotheken (z.B. Smithay Handler) werden konkrete `impl` Blöcke für die zentralen Zustandsstrukturen (`DesktopState`) verwendet.
    - **UI-Schicht:** Nutzt die Traits der Domänen- und Systemschicht. Interne UI-Komponenten kommunizieren über GTK-Signale, Rust-Methodenaufrufe und ggf. interne Event-Bus-Mechanismen (z.B. `glib::Sender/Receiver` für thread-übergreifende Kommunikation innerhalb der UI).
2. **Event-System (Nachrichtenbasierte Kommunikation):**
    
    - **Domänenschicht-Events:** Werden über `tokio::sync::broadcast` Kanäle von Domänen-Services publiziert. Subscriber (in Domäne, System oder UI) erhalten Klone der Event-Datenstrukturen. Event-Strukturen sind `#[derive(Debug, Clone, Serialize, Deserialize)]` (Serialize/Deserialize für Logging oder potenzielle IPC).
    - **Systemschicht-Events (intern & extern):**
        - Intern: Der `system::event_bridge` (mit `tokio::sync::broadcast`) verteilt System-interne Ereignisse (z.B. `UPowerEvent`, `AudioEvent`, `InputDeviceHotplugEvent`).
        - Extern (für UI): Die Systemschicht übersetzt relevante Low-Level-Systemereignisse (z.B. Wayland-Events, D-Bus-Signale) in spezifische, UI-konsumierbare Events oder aktualisiert Zustände, die von der UI periodisch abgefragt oder über Callbacks (z.B. `glib::idle_add`) verarbeitet werden. Wayland-Events (wie `xdg_surface.configure`) sind ein primärer Kommunikationsweg vom Compositor zu den Anwendungsfenstern (Clients) und indirekt zur UI-Shell.
    - **UI-Schicht-Events:** GTK4-Signale (`button.connect_clicked(...)`), `glib::Property` Benachrichtigungen, benutzerdefinierte Signale auf Widgets.
3. **Direktionale Abhängigkeiten:**
    
    - Kern → (von Domäne, System, UI genutzt)
    - Domäne → (von System, UI genutzt)
    - System → (von UI genutzt)
    - Keine zyklischen Abhängigkeiten zwischen den Hauptschichten-Crates (`novade-core`, `novade-domain`, `novade-system`, `novade-ui`).
4. **Datenfluss und Transformation:**
    
    - Daten, die zwischen Schichten ausgetauscht werden, sind klar definierte Rust-Structs oder -Enums.
    - Wenn eine Schicht Daten von einer tieferen Schicht empfängt, kann sie diese in ihre eigenen internen Repräsentationen transformieren (z.B. D-Bus-`zvariant::Value` wird in der Systemschicht zu einer Rust-Struktur, die dann ggf. an die Domänenschicht als Domänenobjekt weitergegeben wird).

---

**Schnittstellen im Detail (Ultra-Feinspezifikation):**

---

**1. Schnittstelle: Kernschicht (`novade-core`) zu höheren Schichten**

Diese Schnittstelle ist unidirektional. Die Kernschicht stellt Funktionalität bereit und hat keine Kenntnis von den höheren Schichten.

**1.1. `core::types`**

- **Datentypen (Beispiele mit exakten Definitionen):**
    - `pub struct Point<T: Copy + Debug + PartialEq + Default + Send + Sync + 'static> { pub x: T, pub y: T }`
    - `pub struct Size<T: Copy + Debug + PartialEq + Default + Send + Sync + 'static> { pub width: T, pub height: T }`
    - `pub struct Rect<T: Copy + Debug + PartialEq + Default + Send + Sync + 'static> { pub origin: Point<T>, pub size: Size<T> }`
    - `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)] pub struct RectInt { pub x: i32, pub y: i32, pub width: u32, pub height: u32 }`
    - `#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)] pub struct Color { pub r: f32, pub g: f32, pub b: f32, pub a: f32 }` (Invarianten: 0.0-1.0, Durchsetzung in `new()` und `serde`-Implementierung).
    - `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)] pub enum Orientation { #[default] Horizontal, Vertical }`
    - `pub use uuid::Uuid;`
    - `pub use chrono::{DateTime, Utc};`
- **Nutzung (Ultra-Fein):**
    - **Domäne:**
        - `domain::theming::types::AccentColor::value: core::types::Color`
        - `domain::window_management_policy::types::GapSettings::screen_outer_horizontal: u16` (Primitiver Typ, aber Werte könnten von `core::types::Size<u16>` inspiriert sein).
    - **System:**
        - `system::compositor::core::state::DesktopState::pointer_location: core::types::Point<f64, smithay::utils::Logical>`
        - `system::compositor::surface_management::RenderableElement::WaylandSurface::position: core::types::Point<i32, smithay::utils::Logical>`
        - Wayland-Geometrien (z.B. `xdg_surface.configure(.., width: i32, height: i32, ..)`) verwenden primitive Typen, werden aber oft in `core::types::RectInt` für interne Logik umgewandelt.
    - **UI:**
        - `ui::widgets::PlacedWidgetWidget::position: core::types::Point<i32>` (Hypothetisch)
        - CSS-Farben aus `domain::theming::AppliedThemeState::resolved_tokens` werden von der UI-Schicht geparst (ggf. zurück in `core::types::Color`, wenn nötig).

**1.2. `core::errors`**

- **Fehlertypen (Beispiele mit exakten Definitionen):**
    - `#[derive(Debug, thiserror::Error)] pub enum CoreError { #[error("I/O error accessing path '{path}': {source}")] Io { path: PathBuf, #[source] source: std::io::Error }, ... }`
    - `#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)] pub enum ColorParseError { #[error("Invalid hex color string format for '{0}'")] InvalidHexFormat(String), ... }`
- **Nutzung (Ultra-Fein):**
    - **Domäne:**
        - `domain::theming::errors::ThemingError::TokenFileIoError { path: PathBuf, #[source] source: std::io::Error }` (Könnte `CoreError::Io` wrappen oder direkt `std::io::Error` verwenden und `From<std::io::Error>` implementieren).
        - Wenn `domain::theming::logic::load_raw_tokens_from_file` eine `core::config::ConfigError::FileReadError { path, source }` zurückgibt (falls Dateilesen in `core::config` gekapselt ist), könnte `ThemingError` dies direkt via `#[from]` übernehmen oder spezifischer mappen.
    - **System:**
        - `system::dbus_interfaces::common::errors::DBusInterfaceError::ConnectionFailed(#[from] zbus::Error)` (Wrappt externen Fehler). Wenn `zbus::Error` selbst `std::io::Error` wrappt, könnte die Kette bis `CoreError::Io` reichen.
        - Fehler beim Lesen einer Shader-Datei im `system::compositor::renderer` könnte `CoreError::Io` sein, das in einen `RendererError::ShaderLoadFailed` gewrappt wird.
    - **UI:**
        - Fehler aus der Domänen- oder Systemschicht werden an die UI weitergegeben. Z.B. ein `GlobalSettingsError::PersistenceError { source: CoreError::Io { ... } }` wird von der UI abgefangen. Die UI entscheidet dann, dem Benutzer eine generische "Speichern fehlgeschlagen" Meldung anzuzeigen und loggt den vollständigen Fehler (`error!(error = ?err, "...")`).

**1.3. `core::logging`**

- **Logging-API (Beispiele mit exakten Signaturen):**
    - `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: core::logging::types::LogFormat, writer: impl std::io::Write + Send + Sync + 'static) -> Result<(), core::logging::errors::LoggingError>` (Writer für Flexibilität).
    - Konvention: Alle Module verwenden `tracing::{trace, debug, info, warn, error, instrument};`.
- **Nutzung (Ultra-Fein):**
    - **Anwendungs-Root (`main.rs` in `novade-ui` oder dem Haupt-Binary):**
        
        Rust
        
        ```
        // In main.rs
        fn main() -> Result<(), Box<dyn std::error::Error>> {
            // Konfig laden, um Log-Level und Format zu bestimmen
            // let core_config = novade_core::config::get_global_core_config(); // Annahme: Konfig wurde geladen
            // let log_level = core_config.log_level.into(); // Konvertierung zu tracing::LevelFilter
            // let log_format = core_config.log_format.into(); // Konvertierung zu core::logging::LogFormat
            // novade_core::logging::initialize_logging(log_level, log_format, std::io::stdout())?;
            // ... Rest der Anwendung ...
            Ok(())
        }
        ```
        
    - **Alle Schichten/Module:**
        
        Rust
        
        ```
        // In irgendeiner Funktion
        #[tracing::instrument(skip(sensitive_data))]
        fn process_data(data: &DataType, sensitive_data: &Secret) -> Result<(), MyModuleError> {
            tracing::debug!(input_data_len = data.len(), "Verarbeite Daten.");
            if data.is_empty() {
                tracing::warn!("Leere Daten empfangen.");
                return Err(MyModuleError::EmptyData);
            }
            // ... Logik ...
            tracing::info!(result = "Erfolgreich", "Daten verarbeitet.");
            Ok(())
        }
        ```
        

**1.4. `core::config`**

- **Konfigurations-API (Beispiele mit exakten Signaturen):**
    - **Trait `core::config::ConfigServiceAsync` (Neu, für asynchrones Laden):**
        
        Rust
        
        ```
        #[async_trait::async_trait]
        pub trait ConfigServiceAsync: Send + Sync {
            async fn read_config_file_string(&self, key_or_path: &str) -> Result<String, CoreError>; // CoreError::Io oder CoreError::NotFound
            async fn write_config_file_string(&self, key_or_path: &str, content: String) -> Result<(), CoreError>; // CoreError::Io
        }
        ```
        
        - Eine Implementierung (`FilesystemConfigServiceAsync`) würde `tokio::fs` verwenden.
    - `pub fn load_config_deserialize<T: for<'de> serde::Deserialize<'de>>(content_str: &str, source_description: &str) -> Result<T, CoreError>` (Generische Deserialisierungsfunktion).
    - Globale `CoreConfig` über `pub fn get_global_core_config() -> &'static CoreConfig`. Initialisierung über `pub fn initialize_global_core_config(paths: &[PathBuf], config_service: Arc<dyn ConfigServiceAsync>) -> Result<(), CoreError>`.
- **Nutzung (Ultra-Fein):**
    - **Domäne (`domain::theming::logic`):**
        
        Rust
        
        ```
        // ThemingEngine::internal_load_themes_and_tokens_locked
        async fn load_theme_definition_from_file(
            &self,
            path: &Path,
            config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>,
        ) -> Result<ThemeDefinition, ThemingError> {
            let content = config_service.read_config_file_string(path.to_str().unwrap())
                .await
                .map_err(|core_err| ThemingError::FilesystemError(core_err))?; // Wrapping
            let theme_def: ThemeDefinition = novade_core::config::load_config_deserialize(&content, path.to_string_lossy().as_ref())
                .map_err(|core_err| ThemingError::ThemeFileLoadError { /* ... source: core_err ... */})?;
            Ok(theme_def)
        }
        ```
        
    - **System (`system::mcp_client::connection_manager`):**
        - `McpConnectionManager` könnte `get_global_core_config()` verwenden, um Standardpfade oder Features für MCP-Server zu laden, falls diese in `CoreConfig` definiert sind.


# Kernschicht Implementierungsleitfaden: Modul 1 - Fundamentale Datentypen (core::types)

1. Modulübersicht: core::types
    1. 1.1. Zweck und Verantwortlichkeit Dieses Modul, `core::types`, bildet das Fundament der Kernschicht (core) und somit des gesamten Systems.
        
    2. Seine primäre Verantwortung liegt in der Definition grundlegender, universell einsetzbarer Datentypen, die von allen anderen Schichten und Modulen der Desktop-Umgebung benötigt werden.
        
    3. Dazu gehören geometrische Primitive (wie Punkte, Größen, Rechtecke), Farbdarstellungen und allgemeine Enumerationen (wie Orientierungen).
        
    4. Die in diesem Modul definierten Typen sind bewusst einfach gehalten und repräsentieren reine Datenstrukturen ohne komplexe Geschäftslogik oder Abhängigkeiten zu höheren Schichten oder externen Systemen.
        
    5. Sie dienen als Bausteine für komplexere Operationen und Zustandsrepräsentationen in den Domänen-, System- und Benutzeroberflächenschichten.
        
    6. 1.2. Designphilosophie Das Design von `core::types` folgt den Prinzipien der Modularität, Wiederverwendbarkeit und minimalen Kopplung.
        
    7. Die Typen sind generisch gehalten (wo sinnvoll, z.B. bei geometrischen Primitiven), um Flexibilität für verschiedene numerische Darstellungen (z.B. `i32` für Koordinaten, `f32` für Skalierungsfaktoren) zu ermöglichen.
        
    8. Ein wesentlicher Aspekt ist die klare Trennung von Datenrepräsentation (in `core::types`) und Fehlerbehandlung.
        
    9. Während dieses Modul die Datenstrukturen definiert, werden die spezifischen Fehler, die bei Operationen mit diesen Typen auftreten können (z.B. durch ungültige Werte), in den Modulen definiert, die diese Operationen durchführen (typischerweise in `core::errors` oder modulspezifischen Fehler-Enums höherer Schichten).
        
    10. 1.3. Zusammenspiel mit Fehlerbehandlung Obwohl `core::types` selbst keine Error-Typen definiert, ist das Design der hier enthaltenen Typen entscheidend für eine robuste und konsistente Fehlerbehandlungsstrategie im gesamten Projekt.
        
    11. Die übergeordnete Richtlinie sieht die Verwendung des `thiserror`-Crates vor, um spezifische Fehler-Enums pro Modul zu definieren.
        
    12. Dies ermöglicht eine granulare Fehlerbehandlung, ohne die Komplexität übermäßig zu erhöhen.
        
    13. Die Typen in `core::types` unterstützen diese Strategie, indem sie:
        
        - Standard-Traits implementieren: Alle Typen implementieren grundlegende Traits wie `Debug` und `Display`.
            
        - Dies ist essenziell, damit Instanzen dieser Typen effektiv in Fehlermeldungen und Log-Ausgaben eingebettet werden können, die von höheren Schichten unter Verwendung von `thiserror` generiert werden.
            
        - Eine gute Fehlerdarstellung ist entscheidend für die Fehlersuche und das Verständnis von Problemen im Laufzeitbetrieb.
            
        - Invarianten dokumentieren: Für Typen wie `Rect<T>` existieren logische Invarianten (z.B. nicht-negative Breite und Höhe). Diese Invarianten werden klar dokumentiert.
            
        - Validierung ermöglichen: Wo sinnvoll, werden Methoden zur Überprüfung der Gültigkeit bereitgestellt (z.B. `Rect::is_valid()`).
            
        - Diese Methoden erlauben es aufrufendem Code in höheren Schichten, Zustände zu überprüfen, bevor Operationen ausgeführt werden, die fehlschlagen könnten.
            
        - Keine Panics in Kernfunktionen: Konstruktoren und einfache Zugriffsmethoden in `core::types` lösen keine Panics aus und geben keine `Result`-Typen zurück, um die API auf dieser fundamentalen Ebene einfach und vorhersagbar zu halten.
            
        - Die Verantwortung für die Handhabung potenziell ungültiger Zustände (z.B. ein `Rect` mit negativer Breite, das an eine Rendering-Funktion übergeben wird) liegt bei den konsumierenden Funktionen, die dann die definierten Fehlerpfade (mittels `Result<T, E>` 3 und den `thiserror`-basierten E-Typen) nutzen.
            
    14. Diese Designentscheidungen stellen sicher, dass die fundamentalen Typen nahtlos in das übergeordnete Fehlerbehandlungskonzept integriert werden können, ohne selbst die Komplexität der Fehlerdefinition tragen zu müssen.
        
    15. Die gewählte Fehlerstrategie mit `thiserror` pro Modul wird als ausreichend für die Bedürfnisse der Kernschicht erachtet, auch wenn alternative Ansätze wie `snafu` für komplexere Szenarien existieren, in denen z.B. die Unterscheidung von Fehlern aus derselben Quelle kritisch ist. Für die Kernschicht wird die Einfachheit und Direktheit von `thiserror` bevorzugt.
        
    16. 1.4. Modulabhängigkeiten Dieses Modul ist darauf ausgelegt, minimale externe Abhängigkeiten zu haben, um seine grundlegende Natur und breite Anwendbarkeit zu gewährleisten.
        
    17. Erlaubte Abhängigkeiten:
        
        - `std` (Rust Standardbibliothek)
            
    18. Optionale Abhängigkeiten (derzeit nicht verwendet):
        
        - `num-traits`: Nur hinzufügen, falls generische numerische Operationen benötigt werden, die über `std::ops` hinausgehen.
        - `serde` (mit `derive`-Feature): Nur hinzufügen, wenn Serialisierung/Deserialisierung dieser Basistypen direkt auf dieser Ebene zwingend erforderlich ist (z.B. für Konfigurationsdateien, die diese Typen direkt verwenden).
            
        - Aktuell wird davon ausgegangen, dass Serialisierungslogik in höheren Schichten implementiert wird, um unnötige Abhängigkeiten zu vermeiden.
    19. 1.5. Ziel-Dateistruktur Die Implementierung dieses Moduls erfolgt innerhalb des core-Crates mit folgender Verzeichnisstruktur:
        
        ```
        core/
        └── src/
            ├── Cargo.toml        # (Definiert das 'core' Crate)
            └── src/
                ├── lib.rs          # (Deklariert Kernmodule: pub mod types; pub mod errors; ...)
                └── types/
                    ├── mod.rs       # (Deklariert und re-exportiert Typen: pub mod geometry; pub mod color; ...)
                    ├── geometry.rs # (Enthält Point<T>, Size<T>, Rect<T>)
                    ├── color.rs      # (Enthält Color)
                    └── enums.rs      # (Enthält Orientation, etc.)
        ```
        
2. 2. Spezifikation: Geometrische Primitive (geometry.rs) Diese Datei definiert grundlegende 2D-Geometrietypen, die für Layout, Positionierung und Rendering unerlässlich sind.
    3. 2.1. Struct: `Point<T>`
        1. 2.1.1. Definition und Zweck: Repräsentiert einen Punkt im 2D-Raum mit x- und y-Koordinaten.
            
        2. Generisch über den Typ T.
        3. 2.1.2. Felder:
            - `pub x: T`
            - `pub y: T`
        4. 2.1.3. Assoziierte Konstanten:
            - `pub const ZERO_I32: Point<i32> = Point { x: 0, y: 0 };`
                
            - `pub const ZERO_U32: Point<u32> = Point { x: 0, y: 0 };`
                
            - `pub const ZERO_F32: Point<f32> = Point { x: 0.0, y: 0.0 };`
                
            - `pub const ZERO_F64: Point<f64> = Point { x: 0.0, y: 0.0 };`
                
        5. 2.1.4. Methoden:
            - `pub const fn new(x: T, y: T) -> Self`
                - Erstellt einen neuen Punkt.
                    
            - `pub fn distance_squared(&self, other: &Point<T>) -> T`
                - Berechnet das Quadrat der euklidischen Distanz.
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + std::ops::Mul<Output=T>`
                    
            - `pub fn distance(&self, other: &Point<T>) -> T`
                - Berechnet die euklidische Distanz.
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + std::ops::Mul<Output=T> + num_traits::Float` (Implementierung nur für Float-Typen sinnvoll oder über sqrt-Funktion). Vorerst nur für f32,f64 implementieren.
            - `pub fn manhattan_distance(&self, other: &Point<T>) -> T`
                - Berechnet die Manhattan-Distanz (`|x1 - x2| + |y1 - y2|`).
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + num_traits::Signed` (Benötigt abs()).
        6. 2.1.5. Trait Implementierungen:
            - `impl<T: Copy + Debug + Default> Default for Point<T> { ... }`
                - Bedingung: T muss die jeweiligen Traits ebenfalls implementieren. Default setzt x und y auf T::default().
                    
            - `impl<T: Send + 'static> Send for Point<T> {}`
                
            - `impl<T: Sync + 'static> Sync for Point<T> {}`
                
            - `impl<T: std::ops::Add<Output = T>> std::ops::Add for Point<T>`
                
            - `impl<T: std::ops::Sub<Output = T>> std::ops::Sub for Point<T>`
                
        7. 2.1.6. Generische Constraints (Basis): `T: Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
            
            - Weitere Constraints werden pro Methode spezifiziert.
    4. 2.2. Struct: `Size<T>`
        1. 2.2.1. Definition und Zweck: Repräsentiert eine 2D-Dimension (Breite und Höhe). Generisch über den Typ T.
            
        2. 2.2.2. Felder:
            - `pub width: T`
            - `pub height: T`
        3. 2.2.3. Assoziierte Konstanten:
            - `pub const ZERO_I32: Size<i32> = Size { width: 0, height: 0 };`
                
            - `pub const ZERO_U32: Size<u32> = Size { width: 0, height: 0 };`
                
            - `pub const ZERO_F32: Size<f32> = Size { width: 0.0, height: 0.0 };`
                
            - `pub const ZERO_F64: Size<f64> = Size { width: 0.0, height: 0.0 };`
                
        4. 2.2.4. Methoden:
            - `pub const fn new(width: T, height: T) -> Self`
                - Erstellt eine neue Größe.
                    
            - `pub fn area(&self) -> T`
                - Berechnet die Fläche (`width * height`).
                    
                - Constraints: `T: Copy + std::ops::Mul<Output=T>`
            - `pub fn is_empty(&self) -> bool`
                - Prüft, ob Breite oder Höhe null ist.
                    
                - Constraints: `T: PartialEq + num_traits::Zero`
            - `pub fn is_valid(&self) -> bool`
                - Prüft, ob Breite und Höhe nicht-negativ sind. Nützlich für Typen wie i32.
                    
                - Constraints: `T: PartialOrd + num_traits::Zero`
        5. 2.2.5. Trait Implementierungen:
            - `impl<T: Copy + Debug + Default> Default for Size<T> { ... }`
                - Bedingung: T muss die jeweiligen Traits ebenfalls implementieren. Default setzt width und height auf T::default().
                    
            - `impl<T: Send + 'static> Send for Size<T> {}`
                
            - `impl<T: Sync + 'static> Sync for Size<T> {}`
                
        6. 2.2.6. Generische Constraints (Basis): `T: Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
            
            - Weitere Constraints werden pro Methode spezifiziert. Die Invariante nicht-negativer Dimensionen wird durch `is_valid` prüfbar gemacht, aber nicht durch den Typ erzwungen.
    5. 2.3. Struct: `Rect<T>`
        1. 2.3.1. Definition und Zweck: Repräsentiert ein 2D-Rechteck, definiert durch einen Ursprungspunkt (oben-links) und eine Größe.
            
        2. Generisch über den Typ T.
        3. 2.3.2. Felder:
            - `pub origin: Point<T>`
            - `pub size: Size<T>`
        4. 2.3.3. Assoziierte Konstanten:
            - `pub const ZERO_I32: Rect<i32> = Rect { origin: Point::ZERO_I32, size: Size::ZERO_I32 };`
                
            - `pub const ZERO_U32: Rect<u32> = Rect { origin: Point::ZERO_U32, size: Size::ZERO_U32 };`
                
            - `pub const ZERO_F32: Rect<f32> = Rect { origin: Point::ZERO_F32, size: Size::ZERO_F32 };`
                
            - `pub const ZERO_F64: Rect<f64> = Rect { origin: Point::ZERO_F64, size: Size::ZERO_F64 };`
                
        5. 2.3.4. Methoden:
            - `pub const fn new(origin: Point<T>, size: Size<T>) -> Self`
                
            - `pub fn from_coords(x: T, y: T, width: T, height: T) -> Self`
                - Constraints: T muss die Constraints von `Point::new` und `Size::new` erfüllen.
                    
            - `pub fn x(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn y(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn width(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn height(&self) -> T` (Constraints: `T: Copy`)
                
            - `pub fn top(&self) -> T` (Alias für y, Constraints: `T: Copy`)
                
            - `pub fn left(&self) -> T` (Alias für x, Constraints: `T: Copy`)
                
            - `pub fn bottom(&self) -> T` (y + height, Constraints: `T: Copy + std::ops::Add<Output=T>`)
                
            - `pub fn right(&self) -> T` (x + width, Constraints: `T: Copy + std::ops::Add<Output=T>`)
                
            - `pub fn center(&self) -> Point<T>`
                - Berechnet den Mittelpunkt.
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T> + std::ops::Div<Output=T> + num_traits::FromPrimitive` (Benötigt Division durch 2).
            - `pub fn contains_point(&self, point: &Point<T>) -> bool`
                - Prüft, ob der Punkt innerhalb des Rechtecks liegt (Grenzen inklusiv für top/left, exklusiv für bottom/right).
                    
                - Constraints: `T: Copy + PartialOrd + std::ops::Add<Output=T>`
            - `pub fn intersects(&self, other: &Rect<T>) -> bool`
                - Prüft, ob sich dieses Rechteck mit einem anderen überschneidet.
                    
                - Constraints: `T: Copy + PartialOrd + std::ops::Add<Output=T>`
            - `pub fn intersection(&self, other: &Rect<T>) -> Option<Rect<T>>`
                - Berechnet das Schnittrechteck. Gibt `None` zurück, wenn keine Überschneidung vorliegt.
                    
                - Constraints: `T: Copy + Ord + std::ops::Add<Output=T> + std::ops::Sub<Output=T> + num_traits::Zero`
            - `pub fn union(&self, other: &Rect<T>) -> Rect<T>`
                - Berechnet das umschließende Rechteck beider Rechtecke.
                    
                - Constraints: `T: Copy + Ord + std::ops::Add<Output=T> + std::ops::Sub<Output=T>`
            - `pub fn translated(&self, dx: T, dy: T) -> Rect<T>`
                - Verschiebt das Rechteck um (dx, dy).
                    
                - Constraints: `T: Copy + std::ops::Add<Output=T>`
            - `pub fn scaled(&self, sx: T, sy: T) -> Rect<T>`
                - Skaliert das Rechteck relativ zum Ursprung (0, 0).
                    
                - Beachtet, dass dies Ursprung und Größe skaliert.
                - Constraints: `T: Copy + std::ops::Mul<Output=T>`
            - `pub fn is_valid(&self) -> bool`
                - Prüft, ob `size.is_valid()` wahr ist.
                    
                - Constraints: `T: PartialOrd + num_traits::Zero`
        6. 2.3.5. Trait Implementierungen:
            - `impl<T: Copy + Debug + Default> Default for Rect<T> { ... }`
                - Bedingung: T muss die jeweiligen Traits ebenfalls implementieren. Default verwendet `Point::default()` und `Size::default()`.
                    
            - `impl<T: Send + 'static> Send for Rect<T> {}`
                
            - `impl<T: Sync + 'static> Sync for Rect<T> {}`
                
        7. 2.3.6. Generische Constraints (Basis): `T: Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
            
            - Weitere Constraints werden pro Methode spezifiziert.
        8. 2.3.7. Invarianten und Validierung (Verbindung zur Fehlerbehandlung):
            - Invariante: Logisch sollten width und height der size-Komponente nicht-negativ sein.
                
            - Kontext: Die Verwendung von vorzeichenbehafteten Typen wie i32 für Koordinaten ist üblich, erlaubt aber technisch negative Dimensionen.
                
            - Eine Erzwingung nicht-negativer Dimensionen auf Typebene (z.B. durch u32) wäre zu restriktiv für Koordinatensysteme.
                
            - Konsequenz: Die Flexibilität, `Rect<i32>` zu verwenden, verlagert die Verantwortung für die Validierung auf die Nutzer des Rect-Typs.
                
            - Funktionen in höheren Schichten (z.B. Layout-Algorithmen, Rendering-Engines), die ein `Rect` konsumieren, müssen potenziell ungültige Rechtecke (mit negativer Breite oder Höhe) behandeln.
                
            - Solche Fälle stellen Laufzeitfehler dar, die über das etablierte Fehlerbehandlungssystem (basierend auf `Result<T, E>` und `thiserror`-definierten E-Typen) signalisiert werden müssen.
                
            - Implementierung in `core::types`: Das Modul erzwingt die Invariante nicht zur Compilezeit oder in Konstruktoren.
                
            - Stattdessen wird die Methode `pub fn is_valid(&self) -> bool` bereitgestellt.
                
            - Nutzer von `Rect<T>` (insbesondere mit `T=i32`) sollten diese Methode aufrufen, um die Gültigkeit sicherzustellen, bevor Operationen durchgeführt werden, die eine positive Breite und Höhe voraussetzen.
                
            - Die Dokumentation des Rect-Typs muss explizit auf diese Invariante und die Notwendigkeit der Validierung durch den Aufrufer hinweisen.
                
            - Die Verantwortung für das Melden eines Fehlers bei Verwendung eines ungültigen `Rect` liegt beim Aufrufer, der dafür die Fehlerinfrastruktur (z.B. `core::errors` oder modulspezifische Fehler) nutzt.
                
    6. 2.4. Struct: `RectInt`
        - (aus einer anderen Quelldatei, aber thematisch passend)
        - Repräsentiert ein achsenparalleles Rechteck mit ganzzahligen Koordinaten (`x: i32`, `y: i32`) und Dimensionen (`width: u32`, `height: u32`).
            
            - Methoden u.a. `new(...)`, `from_points(...)`, `top_left()`, `size()`, `right()`, `bottom()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translate(...)`, `inflate(...)`, `is_empty()`
                
            - Verwendet `saturating_add` / `saturating_sub` um Überläufe zu vermeiden.
                
            - Traits: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Default`
                
3. 3. Spezifikation: Farbdarstellung (color.rs) Diese Datei definiert einen Standard-Farbtyp für die Verwendung im gesamten System.
    4. 3.1. Struct: `Color` (RGBA)
        1. 3.1.1. Definition und Zweck: Repräsentiert eine Farbe mit Rot-, Grün-, Blau- und Alpha-Komponenten.
            
        2. Verwendet `f32`-Komponenten im Bereich `[0.0, 1.0]` für hohe Präzision und Flexibilität bei Farboperationen wie Mischen und Transformationen.
            
        3. 3.1.2. Felder:
            - `pub r: f32` (Rotkomponente, 0.0 bis 1.0)
                
            - `pub g: f32` (Grünkomponente, 0.0 bis 1.0)
                
            - `pub b: f32` (Blaukomponente, 0.0 bis 1.0)
                
            - `pub a: f32` (Alphakomponente, 0.0=transparent bis 1.0=opak)
                
        4. 3.1.3. Assoziierte Konstanten:
            - `pub const TRANSPARENT: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };`
                
            - `pub const BLACK: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 };`
                
            - `pub const WHITE: Color = Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };`
                
            - `pub const RED: Color = Color { r: 1.0, g: 0.0, b: 0.0, a: 1.0 };`
                
            - `pub const GREEN: Color = Color { r: 0.0, g: 1.0, b: 0.0, a: 1.0 };`
                
            - `pub const BLUE: Color = Color { r: 0.0, g: 0.0, b: 1.0, a: 1.0 };`
                
            - (Weitere Standardfarben nach Bedarf hinzufügen)
                
        5. 3.1.4. Methoden:
            - `pub const fn new(r: f32, g: f32, b: f32, a: f32) -> Self`
                - Erstellt eine neue Farbe.
                    
                - Werte außerhalb `[0.0, 1.0]` werden nicht automatisch geklemmt, dies liegt in der Verantwortung des Aufrufers oder nachfolgender Operationen. `debug_assert!` kann zur Laufzeitprüfung in Debug-Builds verwendet werden.
                    
            - `pub fn from_rgba8(r: u8, g: u8, b: u8, a: u8) -> Self`
                - Konvertiert von 8-Bit-Ganzzahlkomponenten (0-255) zu f32 (0.0-1.0).
                    
                - `value / 255.0`.
            - `pub fn to_rgba8(&self) -> (u8, u8, u8, u8)`
                - Konvertiert von f32 zu 8-Bit-Ganzzahlkomponenten.
                    
                - Klemmt Werte auf `[0.0, 1.0]` und skaliert dann auf (value.clamp(0.0,1.0)∗255.0).round()asu8.
                    
            - `pub fn with_alpha(&self, alpha: f32) -> Self`
                - Erstellt eine neue Farbe mit dem angegebenen Alpha-Wert, wobei RGB beibehalten wird.
                    
                - Klemmt Alpha auf `[0.0, 1.0]`.
                    
            - `pub fn blend(&self, background: &Color) -> Color`
                - Führt Alpha-Blending ("source-over") dieser Farbe über einer Hintergrundfarbe durch.
                    
                - Formel: `C_out = C_fg * α_fg + C_bg * α_bg * (1 - α_fg)`. `α_out = α_fg + α_bg * (1 - α_fg)`. Annahme: Farben sind nicht vormultipliziert.
                    
            - `pub fn lighten(&self, amount: f32) -> Color`
                - Hellt die Farbe um einen Faktor amount auf (z.B. durch lineare Interpolation zu Weiß).
                    
                - Klemmt das Ergebnis auf gültige Farbwerte. amount im Bereich `[0.0, 1.0]`.
                    
            - `pub fn darken(&self, amount: f32) -> Color`
                - Dunkelt die Farbe um einen Faktor amount ab (z.B. durch lineare Interpolation zu Schwarz).
                    
                - Klemmt das Ergebnis. amount im Bereich `[0.0, 1.0]`.
                    
        6. 3.1.5. Trait Implementierungen:
            - `impl PartialEq for Color { ... }`
                - PartialEq: Verwendet den Standard-Float-Vergleich.
                    
                - Für präzisere Vergleiche könnten benutzerdefinierte Implementierungen mit Epsilon erforderlich sein, dies wird jedoch für die Kernschicht als unnötige Komplexität betrachtet.
                    
            - `impl Default for Color { ... }`
                - Default: Implementiert Default manuell, um `Color::TRANSPARENT` zurückzugeben.
                    
            - `impl Send for Color {}`
                
            - `impl Sync for Color {}`
                
4. 4. Spezifikation: Allgemeine Enumerationen (enums.rs) Diese Datei enthält häufig verwendete, einfache Enumerationen.
        
    5. 4.1. Enum: `Orientation`
        1. 4.1.1. Definition und Zweck: Repräsentiert eine horizontale oder vertikale Ausrichtung, häufig verwendet in UI-Layouts und Widgets.
            
        2. 4.1.2. Varianten:
            - `Horizontal`
                
            - `Vertical`
                
        3. 4.1.3. Methoden:
            - `pub fn toggle(&self) -> Self`
                - Gibt die jeweils andere Orientierung zurück (Horizontal -> Vertical, Vertical -> Horizontal).
                    
        4. 4.1.4. Trait Implementierungen:
            - `impl Default for Orientation { fn default() -> Self { Orientation::Horizontal } }` (Standard ist Horizontal).
                
            - `impl Send for Orientation {}`
                
            - `impl Sync for Orientation {}`
                
5. 5. Zusammenfassung: Standard Trait Implementierungen Die folgende Tabelle gibt einen Überblick über die Implementierung gängiger Standard-Traits für die in diesem Modul definierten Typen. Dies dient als
        

 Quellen
---

**2. Schnittstelle: Domänenschicht (`novade-domain`) zu Systemschicht und UI-Schicht**

**2.1. Service-APIs (Traits) – Ultra-Fein-Definitionen (Beispiele):**

- **`domain::theming::service::ThemingService`** (Umbenannt von `ThemingEngine` für Klarheit als Trait)
    
    Rust
    
    ```
    use crate::core::types::{Color as CoreColor}; // novade-core Typen
    use super::types::{AppliedThemeState, ThemeIdentifier, ColorSchemeType, ThemingConfiguration, ThemeDefinition};
    use super::errors::ThemingError;
    use tokio::sync::broadcast;
    use uuid::Uuid;
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)] // Für Event und Cache
    pub struct ThemeChangedEvent {
        pub event_id: Uuid,
        pub timestamp: DateTime<Utc>,
        pub new_state: AppliedThemeState,
    }
    
    #[async_trait::async_trait]
    pub trait ThemingService: Send + Sync {
        /// Gibt den aktuell angewendeten Theme-Zustand zurück.
        async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>;
    
        /// Gibt eine Liste aller verfügbaren (geladenen) Theme-Definitionen zurück.
        async fn get_available_themes(&self) -> Result<Vec<ThemeDefinition>, ThemingError>;
    
        /// Gibt die aktuell vom Benutzer gewählte Theming-Konfiguration zurück.
        async fn get_current_theming_configuration(&self) -> Result<ThemingConfiguration, ThemingError>;
    
        /// Aktualisiert die Theming-Konfiguration des Benutzers.
        /// Löst eine Neuberechnung des `AppliedThemeState` und ein `ThemeChangedEvent` aus, falls sich der Zustand ändert.
        async fn update_theming_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>;
    
        /// Lädt alle Theme- und Token-Definitionen von den konfigurierten Pfaden neu.
        /// Dies kann z.B. nützlich sein, wenn der Benutzer neue Themes installiert.
        /// Aktualisiert den `AppliedThemeState` basierend auf der aktuellen Konfiguration.
        async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>;
    
        /// Abonniert Änderungen am angewendeten Theme-Zustand.
        fn subscribe_to_theme_changes(&self) -> broadcast::Receiver<ThemeChangedEvent>;
    }
    ```
    
    - **Publisher von `ThemeChangedEvent`**: `DefaultThemingService` (die Implementierung).
    - **Subscriber von `ThemeChangedEvent`**:
        - `ui::theming_gtk::ThemeManagerGtk`: Aktualisiert GTK CSS Provider.
        - Andere UI-Komponenten, die direkt auf Theme-Änderungen reagieren müssen (z.B. benutzerdefinierte Widgets, die Farben nicht über CSS beziehen).
        - Ggf. `system::compositor` wenn serverseitige Dekorationen stark vom Theme abhängen.
- **`domain::global_settings_and_state_management::service::GlobalSettingsService`**
    
    Rust
    
    ```
    use super::types::GlobalDesktopSettings;
    use super::paths::SettingPath;
    use super::errors::GlobalSettingsError;
    use tokio::sync::broadcast;
    use uuid::Uuid;
    use serde_json::Value as JsonValue;
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SettingChangedEvent {
        pub event_id: Uuid,
        pub timestamp: DateTime<Utc>,
        pub path: SettingPath,
        pub old_value: Option<JsonValue>, // Kann None sein, wenn der vorherige Wert nicht verfügbar war
        pub new_value: JsonValue,
    }
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SettingsLoadedEvent { /* ... */ pub settings: GlobalDesktopSettings }
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SettingsSavedEvent { /* ... */ }
    
    
    #[async_trait::async_trait]
    pub trait GlobalSettingsService: Send + Sync {
        /// Lädt die globalen Einstellungen vom Persistenz-Provider.
        /// Löst ein `SettingsLoadedEvent` aus.
        async fn load_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>;
    
        /// Speichert die aktuellen globalen Einstellungen über den Persistenz-Provider.
        /// Löst ein `SettingsSavedEvent` aus.
        async fn save_settings(&self) -> Result<(), GlobalSettingsError>;
    
        /// Gibt einen Klon der aktuell geladenen `GlobalDesktopSettings` zurück.
        async fn get_current_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>;
    
        /// Aktualisiert einen spezifischen Einstellungswert über seinen `SettingPath`.
        /// Validiert den neuen Wert.
        /// Löst ein `SettingChangedEvent` aus und persistiert die Änderungen.
        async fn update_setting(&self, path: SettingPath, new_value: JsonValue) -> Result<(), GlobalSettingsError>;
    
        /// Liest den Wert einer spezifischen Einstellung.
        async fn get_setting_value(&self, path: &SettingPath) -> Result<JsonValue, GlobalSettingsError>;
    
        /// Setzt alle Einstellungen auf ihre Standardwerte zurück.
        /// Löst mehrere `SettingChangedEvent`s aus und persistiert.
        async fn reset_all_settings_to_defaults(&self) -> Result<(), GlobalSettingsError>;
    
        /// Setzt eine spezifische Einstellung auf ihren Standardwert zurück.
        async fn reset_setting_to_default(&self, path: &SettingPath) -> Result<(), GlobalSettingsError>;
    
        /// Abonniert Änderungen an spezifischen Einstellungen oder allen Einstellungen.
        fn subscribe_to_setting_changes(&self) -> broadcast::Receiver<SettingChangedEvent>;
        // fn subscribe_to_settings_loaded_event(...) -> broadcast::Receiver<SettingsLoadedEvent>;
        // fn subscribe_to_settings_saved_event(...) -> broadcast::Receiver<SettingsSavedEvent>;
    }
    ```
    
    - **Publisher von Events**: `DefaultGlobalSettingsService`.
    - **Subscriber von `SettingChangedEvent`**:
        - **Domäne:** `ThemingService` (für Theme-relevante Einstellungen), `WorkspaceManagerService` (für Workspace-bezogene Einstellungen), `NotificationRulesEngine` (für `SettingIsTrue`-Bedingungen), `PowerManagementService` (für Energieeinstellungen).
        - **System:** `system::input` (für Tastatur-Layout, Maus-Sensitivität), `system::compositor::output_management` (für Standard-Auflösung/Skalierung), `system::audio_management` (für Standard-Lautstärke).
        - **UI:** `ui::control_center` (um sich selbst zu aktualisieren), diverse `ui::shell`-Widgets, die Einstellungen direkt darstellen oder verwenden.

**2.2. Nutzung durch die Systemschicht (Ultra-Fein):**

- **`system::compositor::core::state::DesktopState::new(...)`** nimmt `Arc<dyn WindowManagementPolicyService>` und `Arc<dyn WorkspaceManagerService>` als Parameter.
- **`system::compositor::xdg_shell::handlers::XdgShellHandler::new_toplevel()` (für `DesktopState`)**:
    1. Erhält `ToplevelSurface` von Smithay.
    2. Erzeugt eine `DomainWindowIdentifier`.
    3. Ruft `self.workspace_manager_service.get_active_workspace_id().await` (oder eine äquivalente synchrone Methode, wenn im Compositor-Thread).
    4. Ruft `self.window_policy_service.get_initial_window_geometry(domain_id, workspace_id, available_area, ...).await` um die initiale Geometrie und den Zustand zu bestimmen.
    5. Konfiguriert die `ToplevelSurface` entsprechend.
    6. Informiert `self.workspace_manager_service.assign_window_to_workspace(workspace_id, domain_id, ...).await`.
- **`system::dbus_interfaces::notifications_server::FreedesktopNotificationsServer::notify()`**:
    1. Empfängt D-Bus-Parameter.
    2. Konvertiert diese in eine `domain::user_centric_services::notifications_core::types::NotificationInput`-Struktur.
    3. Ruft `self.notification_service_domain_handle.lock().await.post_notification(input).await`.
    4. Konvertiert das Ergebnis (Domain `Uuid`) in eine D-Bus `u32` ID.
- **`system::input::event_dispatcher::process_input_event()` für `InputEvent::GestureSwipeUpdate`**:
    1. Ermittelt die Geste.
    2. Ruft `self.desktop_state.workspace_manager_service.switch_to_next_or_prev_workspace(direction).await`.

**2.3. Nutzung durch die UI-Schicht (Ultra-Fein):**

- **`ui::control_center::appearance_page::AppearancePageModel::new()`**:
    1. Nimmt `Arc<dyn GlobalSettingsService>` und `Arc<dyn ThemingService>` als Parameter.
    2. Abonniert `global_settings_service.subscribe_to_setting_changes()` und `theming_service.subscribe_to_theme_changes()`.
    3. Ruft `global_settings_service.get_current_settings().await` und `theming_service.get_current_theming_configuration().await` sowie `get_available_themes().await`, um den initialen Zustand der UI-Elemente (ComboBoxes für Themes, Switches für Dark Mode etc.) zu füllen.
- **Event-Handler in `AppearancePageModel` für `SettingChangedEvent`**:
    1. Prüft, ob `event.path` für die Appearance-Seite relevant ist.
    2. Aktualisiert das entsprechende UI-Element (z.B. einen `gtk::Switch` für `SettingPath::Appearance(AppearanceSettingPath::PreferDarkTheme)`) mit `event.new_value`.
- **Aktion in `AppearancePageModel` (z.B. Klick auf "Akzentfarbe ändern"):**
    1. Öffnet einen Farbauswahldialog.
    2. Nach Auswahl: `new_color: core::types::Color`.
    3. `current_theming_config = self.theming_service.get_current_theming_configuration().await?;`
    4. `updated_config = current_theming_config.with_new_accent(new_color);`
    5. `self.theming_service.update_theming_configuration(updated_config).await?;` (Löst `ThemeChangedEvent` aus).
- **`ui::shell::workspace_switcher::WorkspaceSwitcherWidget::on_active_workspace_changed_event(event: domain::workspaces::manager::events::ActiveWorkspaceChangedData)`**:
    1. Iteriert über seine `SpaceIconWidget`s.
    2. Setzt den visuellen "aktiv"-Zustand für das Widget, das `event.new_active_id` entspricht.

---

**3. Schnittstelle: Systemschicht (`novade-system`) zu UI-Schicht (`novade-ui`)**

Diese Schnittstelle ist oft ereignisbasiert oder durch von der UI-Schicht gehaltene Handles zu System-Services.

**3.1. Systemereignisse und -zustände (Ultra-Fein):**

- **Fensterinformationen (bereitgestellt durch einen `WindowManagerSystemFacade` Trait, implementiert von einer Struktur, die auf `DesktopState` zugreift):**
    - **Trait `WindowManagerSystemFacade`**:
        
        Rust
        
        ```
        use crate::core::types::RectInt;
        use crate::domain::workspaces::core::types::{WindowIdentifier as DomainWindowIdentifier, WorkspaceId};
        use crate::system::compositor::xdg_shell::types::ManagedWindowPublicState; // Neuer Typ
        
        #[derive(Debug, Clone, Serialize, Deserialize)] // Für UI-Nutzung
        pub struct ManagedWindowPublicState { // Daten, die UI benötigt
            pub domain_id: DomainWindowIdentifier,
            pub app_id: Option<String>,
            pub title: Option<String>,
            pub geometry: RectInt, // Relative Workspace-Koordinaten
            pub workspace_id: Option<WorkspaceId>,
            pub is_mapped: bool,
            pub is_focused: bool, // Bezogen auf den Seat der UI-Shell
            pub is_maximized: bool,
            pub is_fullscreen: bool,
            // Ggf. Icon-Daten oder Name
        }
        
        #[async_trait::async_trait]
        pub trait WindowManagerSystemFacade: Send + Sync {
            /// Gibt eine Liste aller aktuell verwalteten (gemappten) Fenster mit ihren relevanten Zuständen zurück.
            async fn get_all_managed_windows(&self) -> Result<Vec<ManagedWindowPublicState>, SystemFacadeError>;
        
            /// Gibt den Zustand eines spezifischen Fensters zurück.
            async fn get_window_state(&self, id: &DomainWindowIdentifier) -> Result<Option<ManagedWindowPublicState>, SystemFacadeError>;
        
            /// Fordert den Fokus für ein bestimmtes Fenster an.
            async fn request_focus(&self, id: &DomainWindowIdentifier) -> Result<(), SystemFacadeError>;
        
            /// Fordert das Schließen eines Fensters an (sendet Close-Request an Client).
            async fn request_close_window(&self, id: &DomainWindowIdentifier) -> Result<(), SystemFacadeError>;
        
            // Weitere Aktionen: request_minimize, request_maximize, request_move_to_workspace etc.
        
            /// Abonniert Änderungen an Fensterzuständen.
            fn subscribe_to_window_changes(&self) -> tokio::sync::broadcast::Receiver<WindowSystemEvent>;
        }
        
        #[derive(Debug, Clone)] // System-intern oder für UI, Serialize/Deserialize falls nötig
        pub enum WindowSystemEvent {
            WindowCreated(ManagedWindowPublicState),
            WindowClosed(DomainWindowIdentifier),
            WindowUpdated(ManagedWindowPublicState), // Geometrie, Titel, Fokus etc. geändert
            FocusChanged(Option<DomainWindowIdentifier> /* neues Fokusfenster */, Option<DomainWindowIdentifier> /* altes Fokusfenster */),
        }
        // SystemFacadeError definieren
        ```
        
    - **Implementierung:** Eine Struktur in `novade-system` implementiert diesen Trait. Sie greift auf `system::compositor::core::DesktopState` (via `Arc<Mutex<...>>` oder `LoopHandle::insert_idle`) zu, um die Daten der `ManagedWindow`s zu lesen und in `ManagedWindowPublicState` zu transformieren. Sie publiziert `WindowSystemEvent`s über den `SystemEventBridge`.
- **Eingabeereignisse:** Werden nicht direkt als Rust-Strukturen an die UI-Schicht gesendet. Stattdessen:
    - **Wayland-Protokoll:** Der `system::compositor` sendet `wl_keyboard.key`, `wl_pointer.motion`, `wl_touch.down` etc. an die Wayland-Oberflächen der UI-Elemente (GTK-Fenster). GTK4 (`gdk::Display`) empfängt diese Wayland-Events und übersetzt sie in GTK-Events (`GdkEvent`), die dann von Widgets verarbeitet werden.
    - **Spezielle Aktionen:** Globale Hotkeys oder Gesten, die nicht an ein spezifisches Fenster gebunden sind (z.B. `Super+Space` für Command Palette, Workspace-Switch-Gesten), werden vom `system::input` erkannt. Der `system::input` kann dann direkt eine Domänenaktion auslösen (z.B. `domain::command_palette_service::show()`) oder ein spezifisches `SystemLayerEvent` über den `SystemEventBridge` senden, das von der UI-Shell abonniert wird.
- **Status von Systemdiensten:**
    - `system::dbus_interfaces::upower_client::UPowerClientService` publiziert `UPowerEvent`s über den `SystemEventBridge`.
    - Die UI (z.B. `ui::shell::PowerIndicatorWidget`) abonniert `SystemLayerEvent::UPower` vom `SystemEventBridge`.
    - Bei Empfang: `match event { SystemLayerEvent::UPower(UPowerEvent::DeviceChanged(path)) => { let details = block_on(self.upower_client_facade.get_device_details_by_path(path)); /* UI aktualisieren */ } ... }`

**3.2. Ausführung von UI-Befehlen (Ultra-Fein):**

- **UI-Schicht (`ui::shell::window_title_bar::CloseButton::on_clicked`)**:
    1. Ruft `self.window_manager_facade.request_close_window(self.associated_window_id).await;`.
- **Systemschicht (`DefaultWindowManagerSystemFacade::request_close_window`)**:
    1. Sperrt `DesktopState`.
    2. Findet das `ManagedWindow` (als `Arc<smithay::desktop::Window>`) für die `DomainWindowIdentifier`.
    3. Wenn `WindowSurface::Toplevel(toplevel)`: `toplevel.send_close();`.
    4. (Der Client sollte dann unmappen; `XdgShellHandler::unmap_toplevel` wird ausgelöst).
- **UI-Schicht (`ui::control_center::display_page::ApplyButton::on_clicked`)**:
    1. Sammelt neue Monitorkonfiguration (`Vec<MonitorConfigUiData>`).
    2. Konvertiert zu `Vec<system::output_management::types::OutputConfigRequestData>`.
    3. Ruft `self.output_management_facade.apply_output_configuration(requests).await;`.
- **Systemschicht (`DefaultOutputManagementFacade::apply_output_configuration`)**:
    1. Interagiert mit `system::compositor::output_management` (oder `DesktopState`), um `wlr-output-management` Protokoll-Requests zu senden oder direkt DRM-Modi zu setzen.

---

**Zusammenfassende Prinzipien der Schnittstellen (Ultra-Fein):**

1. **Typsicherheit und explizite Datenstrukturen:** Alle über Schnittstellen ausgetauschten Daten (Parameter, Rückgabewerte, Event-Payloads) sind explizit definierte Rust-`struct`s oder `enum`s. Primitive Typen werden verwendet, wo angemessen, aber für komplexere Daten werden spezifische Typen bevorzugt.
2. **Trait-basierte Service-Abstraktion:** Domänen- und Systemdienste, die von höheren Schichten genutzt werden, implementieren `#[async_trait::async_trait]` Traits. Dies ermöglicht Mocking für Tests und Flexibilität bei Implementierungsänderungen. Handles zu diesen Services sind typischerweise `Arc<dyn ServiceTrait>`.
3. **Granulare Events:** Events sind spezifisch und enthalten alle notwendigen Daten, um Subscribern eine sinnvolle Reaktion zu ermöglichen, ohne zusätzliche Abfragen tätigen zu müssen (außer bei Bedarf für sehr große Datenmengen). Jedes Event hat eine eindeutige ID (`Uuid`) und einen Zeitstempel (`DateTime<Utc>`).
4. **Fehler-Wrapping und -Kontext:** Fehler werden über Schichten hinweg mit `#[from]` oder `#[source]` gewrappt, um die ursprüngliche Ursache nachvollziehbar zu halten. Fehlertypen enthalten kontextspezifische Informationen (z.B. Pfade, IDs).
5. **Asynchronität für potenziell blockierende Operationen:** Alle Operationen, die I/O beinhalten oder länger dauern könnten (insbesondere in Domänen- und Systemschicht-APIs), sind `async`. Die UI-Schicht verwendet `tokio::spawn` oder `glib::MainContext::spawn_local` um diese `async` Funktionen aufzurufen, ohne die UI zu blockieren.
6. **Threadsicherheit:** Geteilter Zustand in Service-Implementierungen wird mit `Arc<tokio::sync::Mutex<...>>` oder `Arc<tokio::sync::RwLock<...>>` geschützt.
7. **Kommunikation mit dem Compositor-Thread:** Operationen, die direkten Zugriff auf `DesktopState` (oder andere nicht-`Send` Smithay-Strukturen) benötigen und von `async` Kontexten außerhalb des Compositor-`calloop`-Threads ausgelöst werden, müssen sorgfältig gehandhabt werden:
    - **Option A (Bevorzugt für kurze Operationen):** `LoopHandle::insert_idle()` oder `LoopHandle::send_event()` um eine Funktion/einen Task im `calloop`-Thread auszuführen.
    - **Option B (Für komplexe Interaktionen):** Dedizierte `mpsc` oder `oneshot` Kanäle zwischen `async` Tasks und dem Compositor-Thread.
    - **Option C (Wenn Daten `Send` sind):** `Arc<Mutex<TeilVonDesktopState>>`, wobei der Mutex `parking_lot::Mutex` sein kann für blockierende Operationen aus dem Compositor-Thread und `tokio::sync::Mutex` für `async` Tasks.

Diese ultra-feingranulare Definition der Schnittstellen ist der Schlüssel zu einer disziplinierten Entwicklung. Jede Interaktion ist spezifiziert, was die Integration der Schichten erleichtert und die Testbarkeit verbessert.

**1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten**

- **1.1.1. `core::types` Schnittstelle:**
    - **Exakte Typdefinitionen referenzieren:** Verlinken Sie oder wiederholen Sie die exakten Rust-Definitionen von `Point<T>`, `Size<T>`, `Rect<T>`, `RectInt`, `Color`, `Orientation` aus `A1 Kernschicht.md` / `1. Core-Details.md` / `Infrastruktur ( UI fehlt).md`. Inklusive aller abgeleiteten Traits (`Debug`, `Clone`, `Serialize`, etc.) und implementierten Methoden mit Signaturen.
    - **Nutzungsbeispiele präzisieren:** "Domänenschicht verwendet `Color` für `TokenValue::Color(String)` und `AccentColor.value: CoreColor`."
- **1.1.2. `core::errors` Schnittstelle:**
    - **Exakte Fehlerdefinition referenzieren:** Verlinken oder wiederholen Sie die Definition von `CoreError` und `ColorParseError` aus `A2 Kernschicht.md` / `A3 Kernschicht Fehlerbehandlung.md` / `A4 Kernschicht.md`. Inklusive aller Varianten, `#[error(...)]`-Attribute und `#[source]` / `#[from]`-Annotationen.
    - **Fehler-Wrapping-Regel:** "JEDE höhere Schicht, die eine Funktion aus der Kernschicht aufruft, die `Result<_, CoreError>` (oder einen spezifischeren Kernfehler wie `ConfigError`) zurückgibt, MUSS diesen Fehler entweder:
        - Explizit behandeln (match).
        - Oder in ihren eigenen Fehlertyp wrappen. Diese Wrapper-Variante in den höheren Schichten MUSS `#[from] CoreError` oder `#[source] source: CoreError` verwenden, um die Fehlerkette zu erhalten."
- **1.1.3. `core::logging` Schnittstelle:**
    - **Exakte Signatur:** `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: LogFormat) -> Result<(), LoggingError>` (aus `A4 Kernschicht.md`). Die Enums `LogFormat` und `LoggingError` MÜSSEN hier ebenfalls exakt definiert werden.
    - **Verwendungsrichtlinie:** "Alle Module in allen Schichten MÜSSEN die Makros `tracing::{trace, debug, info, warn, error}` für Logging verwenden. Sensible Daten DÜRFEN NICHT geloggt werden."
- **1.1.4. `core::config` Schnittstelle:**
    - **Exakte Signaturen und Strukturen referenzieren:** `load_core_config(...) -> Result<CoreConfig, ConfigError>`, `get_global_core_config() -> &'static CoreConfig`, `initialize_global_core_config(config: CoreConfig) -> Result<(), ConfigError>` (aus `A4 Kernschicht.md`). Die Struktur `CoreConfig` (und alle ihre Unterstrukturen wie `LogLevelConfig`, `FeatureFlags`) und der `ConfigError`-Enum MÜSSEN hier exakt spezifiziert werden.
    - **Suchreihenfolge für `load_core_config`:** (Wie in meiner vorherigen Analyse vorgeschlagen) "1. `custom_path` (falls `Some`), 2. `$XDG_CONFIG_HOME/novade/core.toml`, 3. `/etc/novade/core.toml`. Wenn keine Datei gefunden wird, wird `ConfigError::NoConfigurationFileFound` zurückgegeben. Die aufrufende Schicht (typischerweise beim Anwendungsstart) MUSS dann `CoreConfig::default()` verwenden und dies loggen."
- **1.1.5. `core::utils` Schnittstelle:**
    - Für JEDE geplante Utility-Funktion: Exakte Signatur, Parameter, Rückgabetyp (`Result<_, UtilityXYError>`), Vor-/Nachbedingungen und eine kurze Beschreibung ihrer Logik. Jede `UtilityXYError` muss definiert sein.

**2. Schnittstelle: Domänenschicht (Domain Layer) zu System- und UI-Schicht**

Hier wird es komplexer, da die Domänenschicht viele Services bereitstellt.

- **Für jeden Domänen-Service-Trait (z.B. `ThemingEngine`, `WorkspaceManagerService`, `AIInteractionLogicService`, `NotificationService`, `GlobalSettingsService`, `WindowManagementPolicyService`):**
    
    - **Exakte Trait-Definition:** Alle Methoden mit exakten Signaturen (`async fn ...`), Parameter-Typen (die bereits in `core::types`, `domain::shared_types` oder den `types.rs` des jeweiligen Domänenmoduls definiert sein müssen) und Rückgabetypen (`Result<OkTyp, DomänenModulFehlerTyp>`).
    - **Datenstrukturen der API:** Alle Structs und Enums, die in den Methodensignaturen als Parameter oder Rückgabewerte verwendet werden (z.B. `AppliedThemeState`, `WorkspaceWindowLayout`, `AIInteractionContext`, `NotificationInput`), MÜSSEN exakt definiert werden (Felder, Typen, Ableitungen). Verweisen Sie auf die Moduldokumente (B1-B4, "2. Domain-Details.md").
    - **Events von diesem Service:**
        - Für jeden Event-Typ (z.B. `ThemeChangedEvent`, `WorkspaceEvent::WorkspaceCreated`, `NotificationEventEnum::NotificationPosted`): Die exakte Payload-Struktur muss definiert sein.
        - **Event-Bus-Spezifikation:** "Jeder Domänen-Service, der Events publiziert, hält einen `tokio::sync::broadcast::Sender<EventType>`. Die `subscribe_to_xxx_events()`-Methode des Services gibt einen `tokio::sync::broadcast::Receiver<EventType>` zurück. Die Kapazität des Broadcast-Kanals wird beim Erstellen des Service festgelegt (z.B. `new(..., broadcast_capacity: usize)`)."
    - **Fehlertypen dieses Services:** Der spezifische Fehler-Enum des Domänenmoduls (z.B. `ThemingError`, `WorkspaceManagerError`) MUSS hier als Teil der Schnittstelle explizit genannt werden.
    - **Beispielhafte Nutzung durch System-/UI-Schicht präzisieren:**
        - "Systemschicht: Der `system::mcp_client::service::DefaultSystemMcpService` ruft `ai_interaction_service.get_consent_status_for_interaction(...)` auf. Der zurückgegebene `AIInteractionError` wird in einen `SystemMcpError::DomainInteractionFailed` gewrappt."
        - "UI-Schicht: Das `ui::shell::PanelWidget` (oder dessen Submodule) abonniert `ThemingEngine::subscribe_to_theme_changes()` und erhält `ThemeChangedEvent`. Bei Empfang wird `ui::theming_gtk::apply_resolved_tokens(event.new_state.resolved_tokens)` aufgerufen."
- **Spezifische Ultra-Feinspezifikation für `domain::user_centric_services::notification_service_impl` und `core::config::loader` (aus Ihrem Plan):**
    
    - Diese Detailtiefe ist exzellent und genau das, was für _alle_ Module und deren öffentliche APIs (und internen, wenn für die Schnittstelle relevant) benötigt wird. Ihr Plan, dies für ausgewählte Module zu tun, ist gut. Dieser Detailgrad muss auf die _Schnittstellenbeschreibung zwischen den Schichten_ erweitert werden.
    - **Inkonsistenz-Beispiel und Lösung im Plan:**
        - `notification_api.rs` definiert `replaces_id: Option<NotificationId>` für `post_notification`.
        - Die D-Bus-Schnittstelle (`notification_dbus_service.rs`) nimmt `replaces_id_dbus: u32`.
        - Die Schnittstellendokumentation muss das **Mapping** spezifizieren: "Der `system::dbus::notification_dbus_service` MUSS `replaces_id_dbus: u32` in `Option<NotificationId>` für den Aufruf von `NotificationService::post_notification` umwandeln. Wenn `replaces_id_dbus == 0`, dann ist das Ergebnis `None`. Andernfalls MUSS der `IdMapper` konsultiert werden, um die `u32` in eine `NotificationId` (Uuid) zu konvertieren. Wenn keine Uuid für die `u32` existiert, ist dies ein `NotificationDBusError::InvalidReplacesId`."
        - Ähnlich für die Rückgabe der neuen `NotificationId` (Uuid) als `u32` D-Bus-ID.

**3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)**

- **Für jede von der Systemschicht bereitgestellte Information/Funktion:**
    - **Exakter API-Aufruf (oft ein Trait, den die Systemschicht implementiert und die UI-Schicht nutzt) oder Event:**
        - **Fensterinformationen:** `system::compositor_facade::CompositorViewService::get_visible_windows_for_space(space_id: WorkspaceId) -> Result<Vec<WindowViewData>, SystemError>`. Die Struktur `WindowViewData { id: DomainWindowIdentifier, title: String, app_id: ApplicationId, rect: RectInt, has_focus: bool, decoration_mode: DecorationMode }` muss definiert sein.
        - **Eingabeereignisse:** "Die UI-Schicht registriert Callback-Handler bei `system::input::InputManager::register_keyboard_event_handler(Box<dyn Fn(KeyEventData) + Send>)`. Die Struktur `KeyEventData { keysym: u32, utf8: Option<String>, modifiers: ModifiersState, state: KeyState }` muss definiert sein." (Alternativ: Systemschicht sendet Events über den `SystemEventBridge`).
        - **Status von Systemdiensten:** Z.B. `system::dbus::upower_client_service::UPowerService::get_current_power_state() -> Result<PowerStateData, SystemError>`.
    - **Fehlertypen:** Jeder Service der Systemschicht, den die UI aufruft, gibt einen spezifischen Systemfehler zurück.
    - **Event-Strukturen und Event-Bus:** Wenn die Systemschicht Events an die UI sendet (z.B. `OutputConfigurationChangedEvent`), müssen diese Events und der Bus spezifiziert werden (wahrscheinlich der `SystemEventBridge`).

**4. Allgemeine Kommunikationsmuster (aus Ihrem Plan)**

Diese sind gut, aber müssen für die KI konkretisiert werden:

- **Synchrone Aufrufe:** Nur innerhalb eines Threads oder wenn der aufgerufene Code garantiert nicht blockiert. Für schichtübergreifende Aufrufe selten, außer für einfache Getter auf bereits gecachte/gehaltene Daten.
- **Asynchrone Operationen:** Alle schichtübergreifenden Aufrufe, die I/O oder potenziell längere Berechnungen beinhalten, MÜSSEN `async` sein und `Result<_, _>` zurückgeben.
- **Event-Broadcasting:** Der `SystemEventBridge` (für System-interne und System-zu-UI Events) und die `tokio::sync::broadcast`-Kanäle in Domänen-Services sind die festgelegten Mechanismen.
    - _Spezifizieren:_ Welche Events werden von welchem Modul über welchen Sender/Kanal gesendet? Wer sind die erwarteten Subscriber?
- **Fehlerpropagation:** Die Regel "Die `source()`-Kette MUSS erhalten bleiben" ist kritisch.

**Inkonsistenzen erkennen und beheben durch diesen detaillierten Plan:**

Indem Sie jede Schnittstelle so detailliert definieren, werden Inkonsistenzen aufgedeckt:

1. **Typ-Mismatch:** Wenn `domain::theming` eine `core::types::Color` erwartet, aber `ui::control_center` versucht, einen `String` zu senden, wird dies beim Definieren der `GlobalSettingsService::update_setting`-Signatur und der `SettingPath`-Logik klar.
2. **Fehlende Fehlerbehandlung:** Wenn eine Funktion `Result` zurückgibt, aber die aufrufende Schicht den `Err`-Fall nicht behandelt oder nicht in ihren eigenen Fehlertyp mapped, wird dies beim Definieren des Fehler-Mappings auffallen.
3. **Semantische Unterschiede:** (Wie beim `replaces_id`-Beispiel oben) Die D-Bus-Spezifikation verwendet `u32`, die Domäne `Option<Uuid>`. Die Schnittstellendefinition muss die Transformation explizit machen.
4. **Fehlende Daten:** Wenn die UI-Schicht eine bestimmte Information zum Darstellen eines Fensters benötigt (z.B. "minimiert"-Status), aber die von `system::compositor` bereitgestellte `WindowViewData`-Struktur dieses Feld nicht enthält, wird die Lücke offensichtlich.
5. **Unklare Verantwortlichkeiten für Zustandsänderungen:** Wenn sowohl die Domäne als auch die Systemschicht versuchen, denselben Zustand zu modifizieren, ohne klare Koordination, wird dies bei der Definition der API-Aufrufe und Event-Flüsse sichtbar.
# Detaillierte Analyse und Implementierungsstrategien für die Systemschicht von NovaDE

Dieser Bericht analysiert die Kernkomponenten der Systemschicht (novade-system) der Linux-Desktop-Umgebung NovaDE. Er fokussiert auf bewährte Verfahren, typische Fallstricke und Lösungen für potenzielle Implementierungsprobleme unter Verwendung der spezifizierten Technologien wie Smithay, libinput, zbus und PipeWire.

## 1. Smithay Compositor-Entwicklung (system::compositor)

Die Entwicklung eines Wayland-Compositors mit Smithay erfordert eine sorgfältige Planung des Zustandsmanagements, der Fensterrepräsentation und der Protokollimplementierungen.

### 1.1. Zustandsmanagement in `DesktopState`

Die `DesktopState`-Struktur ist das Herzstück des Compositors und implementiert eine Vielzahl von Smithay-Handler-Traits (z.B. `CompositorHandler`, `XdgShellHandler`, `ShmHandler`, `SeatHandler`). Dies birgt die Gefahr, dass `DesktopState` zu einem "God Object" mit übermäßiger Komplexität wird.1

**Best Practices zur Strukturierung:**

- **Modularisierung durch Komposition:** Anstatt alle Logik direkt in `DesktopState` zu implementieren, sollten spezialisierte Sub-Strukturen für zusammengehörige Funktionalitäten verwendet werden. Beispielsweise könnte eine `XdgShellState` die Logik für `xdg_shell` kapseln und von `DesktopState` referenziert werden. Smithay selbst fördert diesen Ansatz durch spezifische Zustandsstrukturen für viele Protokolle (z.B. `smithay::wayland::shell::xdg::XdgShellState`, `smithay::wayland::seat::SeatState`).2
- **Trait-basierte Abstraktion:** Für komplexe, wiederverwendbare Logik innerhalb der Handler können eigene Traits definiert und von `DesktopState` oder dessen Sub-Strukturen implementiert werden.
- **Klare Verantwortlichkeiten:** Jeder Handler-Trait sollte primär für die Interaktion mit dem entsprechenden Wayland-Protokoll zuständig sein. Anwendungslogik, die darüber hinausgeht (z.B. spezifische Fensterverwaltungsregeln), sollte in separate Module ausgelagert und von den Handlern aufgerufen werden.

**Strategien zur Verwaltung von `Arc<Mutex/RwLock<...>>`:**

Der Zugriff auf geteilte Zustände innerhalb der asynchronen Handler-Methoden erfordert Synchronisation. `Arc<Mutex<T>>` oder `Arc<RwLock<T>>` sind hierfür gängige Muster in Rust.4

- **Granularität der Locks:** Sperren sollten so feingranular wie möglich gehalten werden, um Contention zu minimieren. Anstatt den gesamten `DesktopState` zu sperren, sollten nur die tatsächlich benötigten Teile des Zustands gesperrt werden.
- **`RwLock` bevorzugen:** Für Zustände, die häufig gelesen und selten geschrieben werden, ist `RwLock` performanter als `Mutex`, da es mehrere gleichzeitige Leser erlaubt.
- **Vermeidung von Deadlocks:** Besondere Vorsicht ist bei verschachtelten Locks oder dem Aufruf von externem Code (z.B. Client-Callbacks) innerhalb eines Locks geboten. Die Reihenfolge der Lock-Akquirierung sollte konsistent sein.
- **Kurze Lock-Dauer:** Locks sollten nur so lange wie unbedingt nötig gehalten werden. Operationen, die außerhalb des kritischen Abschnitts durchgeführt werden können, sollten dies auch tun.

Smithay selbst empfiehlt, einen zentralen, mutablen Zustand über `calloop` an die Callbacks zu übergeben, was die Notwendigkeit von `Arc<Mutex<T>>` für den Hauptzustand reduzieren kann, da Callbacks sequenziell ausgeführt werden.6 Für Zustände, die von nebenläufigen Tasks (z.B. D-Bus-Handler in Tokio) modifiziert werden und vom Compositor-Thread gelesen werden müssen, bleiben `Arc<Mutex/RwLock<T>>` jedoch relevant.

**Beispiel (konzeptionell):**

Rust

```
pub struct DesktopState {
    pub compositor_state: smithay::wayland::compositor::CompositorState,
    pub xdg_shell_state: smithay::wayland::shell::xdg::XdgShellState,
    pub seat_state: smithay::wayland::seat::SeatState<Self>,
    pub space: Arc<Mutex<smithay::desktop::Space<smithay::desktop::Window>>>,
    //... weitere Zustands-Subkomponenten
}

// Implementierung der Handler-Traits für DesktopState,
// die oft auf die Sub-Zustände delegieren.
// smithay::delegate_compositor!(DesktopState);
// smithay::delegate_xdg_shell!(DesktopState);
//...
```

Die `delegate_*!` Makros von Smithay sind essentiell, um die Implementierung der Handler-Traits an die entsprechenden Zustandsstrukturen zu delegieren und Boilerplate-Code zu reduzieren.2

### 1.2. `ManagedWindow` und `smithay::desktop::Space`

`ManagedWindow` ist eine Abstraktion über Wayland-Fenster (XDG Toplevels, Popups) und XWayland-Fenster. Es implementiert das `smithay::desktop::Window`-Trait.

**Korrekte Implementierung des `Window`-Traits:**

Das `smithay::desktop::Window`-Trait 9 erfordert die Implementierung verschiedener Methoden, um die Eigenschaften und das Verhalten eines Fensters zu definieren:

- `bbox()`: Gibt die Bounding Box des Fensters inklusive aller Subsurfaces und Popups zurück.
- `is_wayland()` / `is_x11()`: Unterscheidet zwischen Wayland- und X11-Fenstern.
- `toplevel()`: Gibt eine Referenz auf die zugrundeliegende `ToplevelSurface` (für XDG-Fenster) zurück.
- `send_frame()`: Sendet Frame-Callbacks an die Oberflächen des Fensters.
- `surface_under()`: Findet die Oberfläche unter einem gegebenen Punkt.
- `set_activated()`: Setzt den Aktivierungszustand des Fensters.
- `geometry()`: Gibt die Kerngeometrie des Fensters zurück (ohne Dekorationen).
- `on_commit()`: Wird aufgerufen, wenn die zugrundeliegende Oberfläche einen Commit durchführt.

**Repräsentation von Fenstergeometrien und -zuständen:**

- **Geometrie:** Die Geometrie (`Rectangle<i32, Logical>`) wird typischerweise direkt in der `ManagedWindow`-Struktur gespeichert und bei `configure`-Events vom Client oder durch Aktionen des Compositors aktualisiert. Sie repräsentiert die von der Anwendung gewünschte Größe und Position des Fensterinhalts.
- **Zustände (maximiert, aktiv, etc.):** Diese Zustände sollten ebenfalls in `ManagedWindow` gespeichert werden (z.B. als Booleans oder Enums).
    - Der **maximierte Zustand** wird durch Anfragen des Clients (z.B. `xdg_toplevel::set_maximized`) oder Aktionen des Compositors gesetzt. Die tatsächliche Geometrie wird dann vom Compositor basierend auf dem verfügbaren Platz des Outputs angepasst.
    - Der **aktive Zustand** wird vom Compositor verwaltet (typischerweise im `SeatHandler` in Reaktion auf Benutzereingaben) und an das Fenster propagiert (z.B. über `Window::set_activated(true)`).
- **Dekorationen (CSD/SSD via `xdg-decoration`):**
    - Das `xdg-decoration-unstable-v1`-Protokoll ermöglicht die Aushandlung zwischen Client-Side Decorations (CSD) und Server-Side Decorations (SSD).12
    - `ManagedWindow` (oder eine assoziierte Struktur) muss den ausgehandelten Dekorationsmodus (`zxdg_toplevel_decoration_v1::mode`) speichern.
    - Wenn SSD aktiv ist, ist der Compositor für das Zeichnen der Dekorationen verantwortlich. `ManagedWindow` sollte Informationen bereitstellen, die für das Rendern der SSDs benötigt werden (z.B. Titel, aktive/inaktive Zustände).
    - Wenn CSD aktiv ist, zeichnet der Client die Dekorationen selbst. Der Compositor muss die Geometrie des Fensters entsprechend berücksichtigen.
    - Die `XdgDecorationState` und `XdgDecorationHandler` von Smithay helfen bei der Implementierung dieses Protokolls.15 Die `XdgDecorationHandler::request_mode` und `new_decoration` Methoden sind hierbei zentral. Der Server (Compositor) sendet `configure`-Events an den `zxdg_toplevel_decoration_v1`, um den Modus festzulegen. Der Client antwortet mit `set_mode` oder `unset_mode`.

**Synchronisation mit `XdgToplevelSurfaceData`:**

`XdgToplevelSurfaceData` 3 speichert den Zustand, der spezifisch für eine `xdg_toplevel`-Oberfläche ist (z.B. angeforderte Größe, Zustände wie maximiert, minimiert, fullscreen, App-ID, Titel).

- Wenn der Client Zustandsänderungen anfordert (z.B. `set_title`, `set_maximized`), werden diese im `XdgToplevelSurfaceData` (oft im `pending_state`) gespeichert.
- Bei einem `wl_surface.commit` werden diese Änderungen durch den `XdgShellHandler` verarbeitet.
- Die Logik im `XdgShellHandler` (oder in `ManagedWindow::on_commit`) muss dann den Zustand von `ManagedWindow` mit den Daten aus `XdgToplevelSurfaceData` synchronisieren. Beispielsweise wird ein `xdg_toplevel.set_maximized` im `XdgToplevelSurfaceData` vermerkt, und der Compositor entscheidet dann, ob und wie er das Fenster maximiert und sendet entsprechende `configure`-Events. Die `send_configure`-Methode auf `ToplevelSurface` ist hierbei zentral, um dem Client die neue Konfiguration mitzuteilen.20 Der Client muss diese Konfiguration mit `ack_configure` bestätigen.

**Interaktion mit `Space`:**

Der `smithay::desktop::Space` 9 verwaltet die Anordnung von Fenstern und anderen Elementen im 2D-Raum.

- `Space::map_window(window, location, activate)`: Fügt ein `ManagedWindow` zum `Space` an einer bestimmten `location` hinzu und legt die Stapelreihenfolge fest. `activate` gibt an, ob das Fenster aktiviert werden soll.
- `Space::unmap_window(window)`: Entfernt ein Fenster aus dem `Space`.
- `Space::raise_window(window, activate)`: Bringt ein Fenster in der Stapelreihenfolge nach vorne.
- **Schadensverfolgung (Damage Tracking):**
    - `Space::damage_window(window, new_damage, old_damage)`: Wird verwendet, um dem `Space` mitzuteilen, dass sich Bereiche eines Fensters geändert haben. `new_damage` sind die beschädigten Regionen in Fensterkoordinaten. `old_damage` kann verwendet werden, wenn sich die Position oder Größe des Fensters geändert hat.
    - `Space::damage_output(output, damage)`: Markiert einen Bereich auf einem bestimmten Output als beschädigt.
    - Wenn ein Client einen neuen Puffer committet (`wl_surface.commit`), wird die `SurfaceAttributes.damage`-Region aktualisiert.26 Der Compositor muss diese Information dann an den `Space` weiterleiten, typischerweise über `damage_window`.
    - `render_output` verwendet die akkumulierten Schadensinformationen, um nur die notwendigen Bereiche eines Outputs neu zu zeichnen und so die Performance zu optimieren.9

### 1.3. Wayland Protokoll-Implementierung (spezifisch)

**1.3.1. `wlr-output-management-unstable-v1`** 6

Dieses Protokoll ermöglicht Clients (z.B. Display-Konfigurationstools wie `kanshi` 34 oder `wdisplays` 33) das Abfragen und Ändern der Konfiguration von Ausgabegeräten (Heads).

- **`apply` und `test` Requests auf `zwlr_output_configuration_v1`:**
    - Ein Client erstellt ein `zwlr_output_configuration_v1`-Objekt mit einem bestimmten `serial` (erhalten vom `zwlr_output_manager_v1.done`-Event).
    - Auf diesem Konfigurationsobjekt kann der Client Änderungen für einzelne `zwlr_output_head_v1`-Objekte vornehmen (z.B. Modus, Position, Skalierung, Aktivierungsstatus setzen).
    - **`test` Request:** Der Client sendet einen `test`-Request, um die Konfiguration zu validieren, ohne sie anzuwenden. Der Compositor prüft, ob die Konfiguration prinzipiell möglich ist.
    - **`apply` Request:** Der Client sendet einen `apply`-Request, um die Konfiguration anzuwenden.
    - **Antworten des Compositors:** In beiden Fällen (`test` und `apply`) muss der Compositor mit einem der folgenden Events antworten:
        - `succeeded`: Die Konfiguration wurde erfolgreich getestet/angewendet. Der Client sollte das Konfigurationsobjekt zerstören. Wenn die Konfiguration angewendet wurde und sich der Zustand geändert hat, sendet der Manager `head`-Events und ein `done`-Event mit einem neuen Serial.
        - `failed`: Die Konfiguration konnte nicht getestet/angewendet werden (z.B. ungültiger Modus). Der Compositor sollte alle Änderungen, die durch einen `apply`-Request ausgelöst wurden, zurückrollen. Der Client sollte das Konfigurationsobjekt zerstören.
        - `cancelled`: Die Konfiguration wurde vom Compositor abgebrochen, weil sich der Zustand eines Outputs geändert hat und die Informationen des Clients veraltet sind (z.B. durch Hotplugging). Der Client kann eine neue Konfiguration mit einem neueren Serial erstellen und es erneut versuchen. Der Client sollte das Konfigurationsobjekt zerstören.
- **Atomarität und Serial-Nummern:**
    - Der `serial` spielt eine Schlüsselrolle für die Atomarität. Der `zwlr_output_manager_v1` sendet ein `done`-Event mit einem `serial`, nachdem alle aktuellen Zustandsinformationen gesendet wurden.29
    - Der Client muss diesen `serial` beim Erstellen eines `zwlr_output_configuration_v1`-Objekts verwenden. Dies stellt sicher, dass die Konfigurationsänderungen des Clients auf einem aktuellen Stand des Compositor-Zustands basieren.
    - Wenn der Compositor eine Konfiguration mit einem veralteten `serial` erhält, kann er diese mit `cancelled` ablehnen.
    - Die Änderungen innerhalb eines `apply`-Requests sollten atomar angewendet werden. Das bedeutet, entweder alle Änderungen werden erfolgreich übernommen, oder bei einem Fehler wird der Zustand vor dem `apply`-Request wiederhergestellt (Rollback).31
- **Smithay Integration:**
    - Smithays `Output` und `OutputManagerState` 34 verwalten die Eigenschaften von Outputs (Modi, Skalierung, Transformation, aktivierter Zustand) und können diese über `wl_output` und `xdg_output` an Clients bekannt machen.
    - Zur Implementierung von `wlr-output-management` muss ein `OutputHandler` (oder eine ähnliche Logik) die Anfragen des Clients verarbeiten, die Konfigurationen validieren und anwenden und die entsprechenden `succeeded`, `failed` oder `cancelled` Events senden. Der `OutputManagerState` würde die globalen Objekte bereitstellen und die `OutputHandler`-Implementierung würde die spezifischen Anfragen bearbeiten.
    - Die Atomarität erfordert sorgfältiges Zustandsmanagement im Compositor. Bevor eine Konfiguration angewendet wird, sollte der aktuelle Zustand zwischengespeichert werden, um im Fehlerfall ein Rollback durchführen zu können.

**1.3.2. `wlr-output-power-management-unstable-v1`** 30

Dieses Protokoll ermöglicht Clients (typischerweise Desktop-Shells) die Steuerung der Energieverwaltungsmodi (DPMS) von Ausgabegeräten, die Teil des Compositor-Raums sind.

- **Exklusive Kontrolle pro Output (`get_output_power`):**
    - Der Client fordert über `zwlr_output_power_manager_v1::get_output_power` ein `zwlr_output_power_v1`-Objekt für ein bestimmtes `wl_output` an.
    - Der Compositor kann diesen Request ablehnen (und ein `failed`-Event auf dem `zwlr_output_power_v1`-Objekt senden), wenn z.B. der Output kein Power-Management unterstützt oder ein anderer Client bereits exklusive Kontrolle hat.30 Dies impliziert, dass der Compositor den Besitz von Power-Management-Kontrollen pro Output verfolgen muss.
- **Reaktion auf vom Compositor initiierte DPMS-Änderungen:**
    - Das `zwlr_output_power_v1::mode`-Event wird gesendet, wenn sich der Power-Modus eines Outputs ändert. Dies kann durch einen `set_mode`-Request des Clients oder durch eine Entscheidung des Compositors selbst geschehen (z.B. durch Inaktivitäts-Timer).49
    - Wenn der Compositor den DPMS-Zustand eines Outputs ändert (z.B. über `system::power_management`), muss er das `mode`-Event an alle Clients senden, die ein `zwlr_output_power_v1`-Objekt für diesen Output halten.
- **Smithay Integration:**
    - Die `OutputHandler`-Implementierung 6 müsste erweitert werden, um die Anfragen dieses Protokolls zu verarbeiten.
    - Der `OutputManagerState` 36 würde das globale `zwlr_output_power_manager_v1`-Objekt verwalten.
    - Der Zustand (aktueller Power-Modus, exklusive Kontrolle) müsste pro Output im Compositor-Zustand (`DesktopState` oder einer Substruktur) gespeichert werden.

**1.3.3. `wlr-layer-shell-unstable-v1`** 53

Dieses Protokoll erlaubt es Clients, Oberflächen (Layer Surfaces) zu erstellen, die über, unter oder zwischen normalen Fenstern gerendert werden, typischerweise für Panels, Hintergrundbilder, Benachrichtigungen und Sperrbildschirme.

- **Management von `LayerSurface`-Daten:**
    - Für jede `LayerSurface` müssen Informationen wie die gewünschte Schicht (`zwlr_layer_shell_v1::layer`), Anker (`anchor`), exklusive Zone (`exclusive_zone`), Ränder (`margin`) und Interaktivitätseinstellungen (`keyboard_interactivity`) gespeichert werden. Diese Daten sind oft Teil einer `SurfaceData`-ähnlichen Struktur, die mit der `wl_surface` der `LayerSurface` assoziiert ist.
    - Smithays `WlrLayerShellState` und `WlrLayerShellHandler` 59 sind für die Verwaltung dieser Zustände und die Bearbeitung von Client-Anfragen zuständig.
- **Interaktion mit `PopupManager` für Layer-Popups:**
    - `LayerSurface`s können Popups haben (z.B. ein Kalender-Popup von einem Panel). Das `zwlr_layer_surface_v1::get_popup`-Request wird verwendet, um ein `xdg_popup` einer `LayerSurface` zuzuordnen.54
    - Der `smithay::desktop::PopupManager` 9 sollte so erweitert oder verwendet werden, dass er auch Popups von `LayerSurface`s korrekt verwalten und positionieren kann. Dies bedeutet, dass der `PopupManager` die Hierarchie von Popups relativ zu ihren Eltern-`LayerSurface`s verstehen muss.
- **Korrekte Berechnung von exklusiven Zonen:**
    - Eine `LayerSurface` kann eine exklusive Zone anfordern (`set_exclusive_zone`). Dies ist ein Bereich entlang eines oder mehrerer Ränder des Outputs, den andere Oberflächen (insbesondere maximierte Fenster) nicht verdecken sollten.55
    - Der Compositor muss die exklusiven Zonen aller `LayerSurface`s auf einem Output aggregieren. Dies ist besonders wichtig für das `system::window_mechanics`-Modul, um Fenster korrekt zu positionieren und zu maximieren, ohne über Panels oder andere Layer-Elemente zu ragen.
    - Die Berechnung muss die Schicht (`layer`), den Anker und die Ränder der `LayerSurface` berücksichtigen. Ein Wert von -1 für die exklusive Zone bedeutet, dass die Oberfläche nicht verschoben werden soll, auch wenn sie andere exklusive Zonen überlappt.56
    - Die `smithay::desktop::Space`-Logik muss diese exklusiven Zonen bei der Berechnung des verfügbaren Arbeitsbereichs für normale Fenster berücksichtigen.

### 1.4. Renderer-Abstraktion

Eine robuste Renderer-Abstraktion ist entscheidend für Flexibilität und Wartbarkeit. Die Traits `FrameRenderer` und `RenderableTexture` sind hierfür vorgesehen.

- **Robuste Trait-Definitionen:**
    - **`FrameRenderer`:**
        - Sollte Methoden zum Beginnen und Beenden eines Frames bereitstellen.
        - Methoden zum Rendern von `RenderableTexture`s an bestimmten Positionen mit Transformationen (Skalierung, Rotation), Alpha-Blending und Clipping-Regionen.
        - Methoden zum Löschen des Framebuffers oder Teilen davon.
        - Potenziell Methoden zur Verwaltung von Shader-Programmen oder anderen Renderer-spezifischen Ressourcen.
    - **`RenderableTexture`:**
        - Repräsentiert eine Textur, die vom `FrameRenderer` gezeichnet werden kann.
        - Sollte Methoden zum Abrufen der Dimensionen und des Formats der Textur bereitstellen.
        - Muss die zugrundeliegenden Pufferdaten (SHM oder DMABUF) kapseln.
- **Effiziente Pufferübergabe und Texturverwaltung:**
    - **SHM-Puffer:** Für SHM-Puffer (`wl_shm_buffer`) müssen die Pixeldaten in eine GPU-Textur hochgeladen werden. Dies kann bei jedem Frame oder nur bei Änderungen erfolgen.
    - **DMABUF-Puffer:** DMABUFs können oft direkt von der GPU importiert werden, was den Kopiervorgang CPU -> GPU vermeidet. Smithays `DmabufFeedback` und `ImportDma` 60 sind hier relevant.
    - **Textur-Caching:** Um das wiederholte Hochladen identischer Pufferinhalte zu vermeiden, kann ein Textur-Cache implementiert werden. Texturen können anhand eines Identifikators des Puffers (z.B. `wl_buffer`-Objekt-ID oder ein Hash des Inhalts für SHM) zwischengespeichert werden.
    - **Freigabe:** Wenn ein `wl_buffer` vom Client freigegeben wird (`wl_buffer.release`), sollten auch die zugehörigen Texturen im Cache freigegeben oder als wiederverwendbar markiert werden.
- **Kommunikation von Schadensverfolgung (Damage Tracking):**
    - Der Compositor (speziell `DesktopState` oder `Space`) verfolgt die beschädigten Regionen jeder Oberfläche (`wl_surface.damage_buffer` oder `wl_surface.damage_surface`) und des gesamten Outputs.9
    - Diese Schadensinformation (typischerweise eine Liste von Rechtecken) muss an den `FrameRenderer` übergeben werden.
    - Der `FrameRenderer` sollte diese Information nutzen, um nur die beschädigten Bereiche des Framebuffers neu zu zeichnen (z.B. durch Setzen einer Scissor-Region oder durch differenzielles Rendern).
    - Smithay bietet im Modul `smithay::backend::renderer::damage` Hilfsmittel für das Damage Tracking auf Output-Ebene.60 Die `Frame`-Implementierung des Renderers sollte die akkumulierten Schäden berücksichtigen.

**Beispiel (konzeptionelle Trait-Definitionen):**

Rust

```
use smithay::utils::{Point, Rectangle, Scale, Transform};
use smithay::backend::renderer::Renderer; // Basis-Renderer-Trait von Smithay

pub trait RenderableTexture {
    fn width(&self) -> u32;
    fn height(&self) -> u32;
    // Evtl. Methode, um den zugrundeliegenden Puffer-Typ zu identifizieren (SHM, DMABUF)
    // fn buffer_type(&self) -> BufferType;
    // Evtl. Methode, um die Textur-ID für den spezifischen Renderer zu erhalten
    // fn renderer_id(&self) -> RendererTextureId;
}

pub trait FrameRenderer<T: RenderableTexture, R: Renderer> { // R ist der Backend-Renderer von Smithay
    fn begin_frame(&mut self, output_damage: Option<&>) -> Result<(), R::Error>;
    fn render_texture(
        &mut self,
        texture: &T,
        src_rect: Rectangle<f64, smithay::utils::Buffer>, // Quellrechteck auf der Textur
        dst_rect: Rectangle<i32, smithay::utils::Physical>, // Zielrechteck auf dem Framebuffer
        transform: Transform,
        alpha: f32,
        damage: &, // Schaden relativ zur Textur im Ziel-Framebuffer
    ) -> Result<(), R::Error>;
    fn clear(&mut self, color: [f32; 4], region: &) -> Result<(), R::Error>;
    fn finish_frame(&mut self) -> Result<(), R::Error>; // Beinhaltet Swap-Buffers o.ä.
}
```

Die Integration mit Smithays eigenem `Renderer`-Trait und den `RenderElement`-Strukturen 60 ist hierbei zu beachten. Die `FrameRenderer`-Abstraktion könnte auf Smithays `Frame`-Trait aufbauen oder dieses wrappen.

### 1.5. XWayland-Integration

Die Integration von XWayland ermöglicht die Ausführung von X11-Anwendungen in der Wayland-Umgebung.

- **Herausforderungen und Lösungen:**
    - **Starten und Verwalten des XWayland-Prozesses:**
        - Smithays `smithay::xwayland::XWayland::new()` 61 startet den XWayland-Server als Kindprozess. Der Compositor muss die Wayland- und X11-Sockets bereitstellen, über die XWayland kommuniziert.
        - Die `XWayland`-Struktur muss im `DesktopState` gehalten und bei Beendigung des Compositors ordnungsgemäß beendet werden.
    - **X11 Window Manager (`X11Wm`):**
        - Der Compositor muss als X11 Window Manager für die von XWayland erzeugten X11-Fenster agieren. Smithay stellt das `XwmHandler`-Trait und die `X11Wm`-Struktur bereit.61
        - Der `XwmHandler` muss Callbacks implementieren, um auf X11-Ereignisse wie das Erstellen, Zerstören, Konfigurieren und Verschieben von Fenstern zu reagieren.
        - Die `X11Wm`-Instanz verwaltet die Verbindung zum XWayland-Server und die X11-Fenster.
    - **Darstellung von X11-Fenstern (`X11Surface`) im Wayland-Space:**
        - XWayland erstellt für jedes X11-Top-Level-Fenster eine `wl_surface`. Smithays `X11Surface` 61 repräsentiert ein solches Fenster und ist mit der zugrundeliegenden X11-Fenster-ID und der `wl_surface` verbunden.
        - Diese `X11Surface`-Objekte müssen in das `smithay::desktop::Window`-Trait gewrappt und im `smithay::desktop::Space` verwaltet werden, genau wie native Wayland-Fenster.
        - Die Geometrie, Stapelreihenfolge und der Aktivierungszustand von X11-Fenstern müssen zwischen dem X11-Protokoll (via `X11Wm`) und dem Wayland-Space synchronisiert werden. Beispielsweise muss ein `XConfigureWindow`-Request vom `X11Wm` verarbeitet und die Position des `X11Surface` im `Space` entsprechend angepasst werden.
    - **Input-Routing:** Eingabeereignisse (Tastatur, Maus) für X11-Fenster müssen korrekt an XWayland weitergeleitet werden. Dies geschieht, indem der Fokus auf die `wl_surface` des `X11Surface` gesetzt wird. Der `SeatHandler` spielt hier eine wichtige Rolle.
    - **Synchronisation von Fensterzuständen:** Zustände wie Maximierung oder Aktivierung müssen zwischen dem Wayland-Compositor und dem X11-Zustand des Fensters synchron gehalten werden. Der `X11Wm` ist dafür verantwortlich, entsprechende X11-Properties (z.B. `_NET_WM_STATE`) zu setzen oder zu interpretieren.
- **Referenzimplementierungen:** Die Anvil-Demo-Compositor von Smithay enthält eine XWayland-Integration, die als gutes Beispiel dienen kann.6

## 2. Eingabeverarbeitung (system::input)

Die Eingabeverarbeitung ist eine kritische Komponente für die Benutzerinteraktion. NovaDE setzt hier auf `libinput` und `xkbcommon`.

### 2.1. `libinput` und `calloop`

- **Best Practices für die Integration des `LibinputInputBackend` in die `calloop`-Ereignisschleife:**
    - Der `LibinputInputBackend` wird typischerweise als eine `calloop::EventSource` in die `calloop`-Schleife eingefügt.
    - Die `dispatch`-Methode des Backends verarbeitet die anstehenden `libinput`-Events.
    - Um die Schleife nicht zu blockieren, sollte die Verarbeitung der einzelnen Events (z.B. Übersetzung in Wayland-Events, Fokus-Logik) möglichst effizient sein. Langwierige Operationen sollten vermieden oder in separate Tasks ausgelagert werden (obwohl dies im Input-Pfad selten vorkommt).
    - Smithay bietet in `smithay::backend::input` und `smithay::input` Abstraktionen, die die Integration erleichtern.
- **Effiziente Verarbeitung von `libinput`-Events:**
    - Events sollten so früh wie möglich gefiltert werden, wenn sie nicht relevant sind.
    - Die Übersetzung von `libinput`-Events in Wayland-Protokoll-Events sollte direkt und ohne unnötige Allokationen erfolgen.
    - Zustandsänderungen (z.B. Tastatur-Modifier-Status) sollten effizient aktualisiert werden.

### 2.2. `xkbcommon`

`xkbcommon` ist für die Interpretation von Tastatur-Layouts und die Übersetzung von Keycodes in Keysyms und UTF-8-Strings zuständig.

- **Korrekte Initialisierung und Aktualisierung von `xkb::State` pro Tastatur/Seat:**
    - Für jede Tastatur (oder allgemeiner, für jeden `Seat` mit Tastatur-Capability) muss eine eigene `xkb::Context` und `xkb::Keymap` erstellt werden.
    - Aus der `Keymap` wird dann eine `xkb::State` abgeleitet. Diese `XkbKeyboardData` (mit `xkb::State`) wird im `SeatState` gehalten.
    - **Layout-Wechsel:** Bei einem Layout-Wechsel (z.B. durch den Benutzer oder eine Systemkonfiguration) muss die `xkb::Keymap` neu geladen und eine neue `xkb::State` daraus erstellt und aktualisiert werden. Dies erfordert typischerweise die Interaktion mit Systemdiensten, die Layout-Änderungen signalisieren (z.B. über D-Bus).
- **Zuverlässige Implementierung von Modifikatoren und Tastenwiederholung:**
    - **Modifikatoren:** `xkb::State::update_key()` aktualisiert den Zustand der Modifikatoren (Shift, Ctrl, Alt, etc.) basierend auf den gedrückten/losgelassenen Tasten. Der `SeatHandler` muss diesen Zustand verwenden, um korrekte Keysyms und Modifier-Masken an die Clients zu senden.
    - **Tastenwiederholung (Key Repeat):**
        - `libinput` selbst sendet keine Wiederholungsereignisse. Der Compositor muss dies implementieren.
        - Wenn eine Taste gedrückt wird, für die Wiederholung aktiviert ist (konfigurierbar über `xkb::Keymap::key_repeats()`), startet ein Timer.
        - Der Timer wird in `calloop` verwaltet (z.B. `calloop::timer::Timer`).
        - Nach einer initialen Verzögerung (`repeat_delay`) sendet der Timer periodisch (mit `repeat_rate`) Events, die der Compositor als erneute Tastendrücke interpretiert und an den fokussierten Client weiterleitet.
        - Der Timer muss gestoppt werden, wenn die Taste losgelassen wird oder der Fokus wechselt.
        - Die `XkbKeyboardData` in der Spezifikation deutet darauf hin, dass die Konfiguration für die Tastenwiederholung (Rate, Verzögerung) aus `xkbcommon` bezogen wird.

### 2.3. Fokusmanagement

Das Fokusmanagement ist komplex und erfordert eine enge Koordination zwischen `SeatHandler`, `system::input` und `system::window_mechanics`.

- **Detaillierte Logik für `SeatHandler::focus_changed`:**
    - Diese Methode wird vom `Seat` aufgerufen, wenn sich der Fokus ändert.
    - Sie muss den alten und neuen Fokus-Target (typischerweise eine `WlSurface`) an die entsprechenden Clients kommunizieren (z.B. `wl_keyboard::leave`/`enter`, `wl_pointer::leave`/`enter`).
    - Der `SeatHandler` sollte auch den internen Zustand des Compositors aktualisieren (z.B. welches Fenster gerade aktiv ist).
- **Konsistente Handhabung des Fokus zwischen Tastatur, Zeiger und Touch:**
    - **Tastaturfokus:** Folgt typischerweise dem "aktiven Fenster". Ein Klick auf ein Fenster oder eine explizite Aktivierungsanforderung setzt den Tastaturfokus.
    - **Zeigerfokus ("Pointer Focus"):** Folgt der Mausbewegung. Wenn der Zeiger eine neue Oberfläche betritt, erhält diese den Zeigerfokus. Dies löst `wl_pointer::enter` und `wl_pointer::leave` aus.
    - **Touchfokus:** Ist oft an einen bestimmten Touchpunkt (Slot) gebunden. Wenn ein Touchpunkt auf einer Oberfläche landet, erhält diese Oberfläche den Touchfokus für diesen Slot.
    - Die Konsistenz wird dadurch erreicht, dass der `Seat` den Zustand für alle Eingabemethoden hält und der `SeatHandler` die entsprechenden Wayland-Events basierend auf diesem Zustand sendet.
- **Interaktion mit `system::window_mechanics::set_application_focus`:**
    - `set_application_focus` in `system::window_mechanics` ist für die _technische Umsetzung_ des Fokuswechsels zuständig (z.B. Anfordern der Aktivierung eines XDG-Toplevels, Aktualisieren des internen Zustands im `DesktopState`).
    - Der `SeatHandler` (oder die Logik, die Fokusentscheidungen trifft) ruft `set_application_focus` auf, um einen Fokuswechsel zu initiieren.
    - Um Redundanz oder Konflikte zu vermeiden:
        - `SeatHandler::focus_changed` sollte primär für das Senden der Wayland-Protokoll-Events zuständig sein, nachdem der Fokuswechsel _entschieden und technisch umgesetzt_ wurde.
        - Die Entscheidung, welches Fenster den Fokus erhält (z.B. durch Klick), und die Aktivierung dieses Fensters (über `set_application_focus`) sollten vor dem Aufruf von `focus_changed` erfolgen.
- **Finden der korrekten Oberfläche unter dem Zeiger/Touchpunkt (`find_surface_and_coords_at_global_point`):**
    - Diese Funktion ist entscheidend für das korrekte Routing von Zeiger- und Touch-Events.
    - Sie muss die Fenster im `smithay::desktop::Space` in umgekehrter Stapelreihenfolge (von oben nach unten) durchlaufen.
    - Für jedes Fenster muss geprüft werden, ob der globale Punkt innerhalb seiner Bounding Box liegt.
    - Anschließend muss der Punkt in die Koordinaten der Fensteroberfläche transformiert werden.
    - `smithay::desktop::Window::surface_under()` kann verwendet werden, um die spezifische `WlSurface` (inkl. Subsurfaces und Popups) unter dem lokalen Punkt zu finden.
    - **Eingaberegionen (`wl_surface.set_input_region`):** Die Eingaberegion einer Oberfläche definiert, welche Teile der Oberfläche auf Eingaben reagieren. `surface_under` muss dies berücksichtigen. Nur wenn der Punkt innerhalb der Eingaberegion liegt, gilt die Oberfläche als getroffen.
    - **Stapelreihenfolge:** Die Iteration durch die Fenster im `Space` muss die korrekte z-Ordnung beachten, um sicherzustellen, dass die oberste sichtbare Oberfläche an diesem Punkt ausgewählt wird. `smithay::desktop::Space::elements_under()` kann hierfür nützlich sein.

### 2.4. Gesten

Die Implementierung robuster Gestenerkennung (Pinch, Swipe) auf Basis von `libinput`-Events ist eine fortgeschrittene Aufgabe.

- **Ansätze:**
    - **Direkte Verarbeitung von `libinput`-Gestenereignissen:** `libinput` selbst erkennt bereits einige grundlegende Gesten (z.B. `GesturePinchEvent`, `GestureSwipeEvent`). Diese Events enthalten Informationen wie Skalierungsfaktor, Winkeländerung (Pinch) oder Verschiebungsvektoren (Swipe).
        - Der `LibinputInputBackend` leitet diese Events an den Compositor weiter.
        - Der Compositor muss diese Events interpretieren und in höherwertige Aktionen oder Wayland-Protokoll-Events (z.B. über `zwp_pointer_gestures_v1`) umwandeln.
    - **Eigene Gestenerkennung:** Für komplexere oder benutzerdefinierte Gesten, die `libinput` nicht direkt bereitstellt, müsste der Compositor eine eigene Gestenerkennungslogik implementieren. Dies würde das Sammeln und Analysieren von Folgen von Touch- oder Zeigerereignissen über die Zeit erfordern. Dies ist deutlich aufwendiger.
- **Übersetzung in Domänenaktionen:**
    - Erkannte Gesten (z.B. ein "Pinch-to-Zoom" auf einem Fenster) müssen in Aktionen der Domänenschicht übersetzt werden (z.B. "ZoomFenster", "WechsleWorkspace").
    - Dies erfordert eine klare Schnittstelle zwischen `system::input` und der Domänenschicht, möglicherweise über den `SystemEventBridge`.
- **Smithay-Unterstützung:** Smithay bietet Unterstützung für das `zwp_pointer_gestures_v1`-Protokoll, was die Weiterleitung von Pinch- und Swipe-Gesten an Clients ermöglicht. Der Compositor muss die `libinput`-Events in die entsprechenden Wayland-Events dieses Protokolls übersetzen.
- **Herausforderungen:**
    - **Eindeutigkeit:** Sicherstellen, dass Gesten nicht mit normalen Zeiger- oder Touch-Interaktionen kollidieren.
    - **Konfigurierbarkeit:** Benutzer erwarten oft, Gesten konfigurieren zu können.
    - **Performance:** Die Gestenerkennung darf die Eingabeverarbeitung nicht verlangsamen.

## 3. D-Bus Interaktion (system::dbus_interfaces mit zbus)

Die Kommunikation mit Systemdiensten über D-Bus ist ein integraler Bestandteil moderner Desktop-Umgebungen. `zbus` wird für die asynchrone D-Bus-Kommunikation mit Tokio verwendet.

### 3.1. Proxy-Management

Die Erstellung und Verwaltung von `zbus::Proxy`-Instanzen, insbesondere für dynamische Objektpfade, erfordert sorgfältige Überlegungen zum Lebenszyklus.

- **Best Practices:**
    - **Caching von Proxies:** Für häufig verwendete Proxies zu bekannten Objektpfaden (z.B. `/org/freedesktop/UPower`, `/org/freedesktop/NetworkManager`) ist es sinnvoll, die Proxy-Instanzen nach der ersten Erstellung zwischenzuspeichern (z.B. in einem `OnceLock` oder einem `Arc<Mutex<...>>` Feld im jeweiligen `DBusClientService`). Dies vermeidet den Overhead wiederholter Proxy-Erstellung.
        - Die `DBusConnectionManager` mit `OnceLock` für Session/System-Bus ist ein guter Ansatz für die zugrundeliegende `zbus::Connection`.
    - **Dynamische Objektpfade:** Für Proxies zu dynamischen Objektpfaden (z.B. `UPowerDeviceProxy` für `/org/freedesktop/UPower/devices/display_device`, `LogindSessionProxy` für `/org/freedesktop/login1/session/self`):
        - Diese Proxies sollten bei Bedarf erstellt werden, wenn der spezifische Objektpfad bekannt wird (z.B. durch ein Signal vom Manager-Objekt oder eine Abfrage).
        - Eine Möglichkeit ist, sie nicht langfristig zu cachen, wenn ihre Lebensdauer stark an das zugrundeliegende D-Bus-Objekt gebunden ist und dieses häufig wechseln kann.
        - Alternativ kann ein Cache (z.B. `HashMap<OwnedObjectPath, Arc<MyDeviceProxy>>`) verwendet werden, aber es muss eine Strategie zur Invalidierung geben, falls das D-Bus-Objekt verschwindet. Signale wie `InterfacesRemoved` vom `org.freedesktop.DBus.ObjectManager` können hier helfen, sind aber nicht immer verfügbar.
    - **Lebenszyklusmanagement:**
        - Proxies sind an die Lebensdauer der `zbus::Connection` gebunden. Wenn die Verbindung getrennt wird, werden die Proxies ungültig.
        - Für Dienste, die neu gestartet werden können, muss der Client-Service in der Lage sein, die Verbindung und die Proxies neu zu initialisieren. Das Abonnieren von `NameOwnerChanged`-Signalen auf dem D-Bus kann helfen, Neustarts von Diensten zu erkennen.
- **Beispiel (Caching eines Manager-Proxys):**
    
    Rust
    
    ```
    use zbus::Proxy;
    use tokio::sync::OnceCell;
    use std::sync::Arc;
    
    static UPOWER_PROXY: OnceCell<Arc<UPowerProxy<'static>>> = OnceCell::const_new();
    
    async fn get_upower_proxy(connection: &Arc<zbus::Connection>) -> Result<Arc<UPowerProxy<'static>>, zbus::Error> {
        UPOWER_PROXY.get_or_try_init(|| async {
            let proxy = UPowerProxy::new(connection).await?;
            Ok(Arc::new(proxy))
        }).await.cloned()
    }
    ```
    
    Für dynamische Proxies wäre ein `HashMap` im Service-Struct, geschützt durch einen `Mutex` oder `RwLock`, ein gängiger Ansatz.

### 3.2. Asynchrone Signalbehandlung

Die Verarbeitung von D-Bus-Signalen erfolgt in `tokio::tasks`, die `zbus::SignalStream`s konsumieren.

- **Robuste Implementierung:**
    - Jeder `SignalStream` sollte in einem eigenen `tokio::task` verarbeitet werden, um Blockierungen zu vermeiden.
    - Der Task muss den Stream kontinuierlich pollen (z.B. mit `while let Some(signal) = stream.next().await`).
    - **Fehler im Stream:** `stream.next().await` kann `None` zurückgeben, wenn der Stream beendet wird (z.B. Verbindung verloren, Dienst beendet). Der Task sollte dies erkennen und sich sauber beenden oder versuchen, den Stream neu zu initialisieren (z.B. durch erneutes Abonnieren der Signale nach Wiederherstellung der Verbindung). Fehler während des Stream-Pollings (z.B. `zbus::Error`) sollten geloggt und behandelt werden.
    - **Parsen von Signaldaten:** Die Argumente eines Signals kommen als `zbus::zvariant::Value` oder spezifischere Typen an. Diese müssen sorgfältig in die internen Event-Typen der Systemschicht gemappt werden. Fehler beim Parsen (z.B. unerwarteter Typ) sollten abgefangen und geloggt werden.
    - **Umwandlung in interne Events:** Nach erfolgreichem Parsen werden die Signaldaten in anwendungsspezifische Events (z.B. `UPowerEvent`, `NetworkManagerEvent`) umgewandelt und typischerweise über den `SystemEventBridge` publiziert.
- **Beispiel (konzeptionell):**
    
    Rust
    
    ```
    // In UPowerClientService::initialize()
    // let upower_proxy = self.get_proxy().await?;
    // let mut device_added_stream = upower_proxy.receive_device_added().await?;
    // let event_bridge = global_system_event_bridge();
    
    // tokio::spawn(async move {
    //     while let Some(signal) = device_added_stream.next().await {
    //         match signal.args() {
    //             Ok(args) => {
    //                 let device_path = args.device_path; // Annahme basierend auf Spezifikation
    //                 // Hole Details für device_path, erstelle UPowerEvent::DeviceAdded
    //                 // event_bridge.publish(SystemLayerEvent::UPower(upower_event)).await;
    //             },
    //             Err(e) => {
    //                 // log_error!("Failed to parse UPower DeviceAdded signal args: {:?}", e);
    //             }
    //         }
    //     }
    //     // log_info!("UPower DeviceAdded signal stream ended.");
    // });
    ```
    
- **Referenz:** Die `zbus` Dokumentation zu `SignalStream` und asynchroner Verarbeitung ist hier relevant.

### 3.3. `org.freedesktop.Notifications` Server

Die Implementierung eines D-Bus-Servers für `org.freedesktop.Notifications` 75 erfordert ein Mapping zwischen D-Bus `u32` IDs und den internen `Uuid`s der Domänenschicht sowie das korrekte Emittieren von Signalen.

- **ID-Mapping (`D-Bus u32 <-> Domain Uuid`):**
    - Wenn der Server eine Benachrichtigung über `Notify` empfängt, generiert er eine neue, eindeutige `u32` ID und gibt diese an den Client zurück.
    - Diese `u32` ID muss intern mit der `Uuid` der Domänen-Benachrichtigung (die vom `domain::NotificationService` kommt oder dorthin gesendet wird) assoziiert werden. Ein `HashMap<u32, Uuid>` und ggf. ein `HashMap<Uuid, u32>` (für schnelle Rückwärts-Lookups) im Zustand des `FreedesktopNotificationsServer` sind hierfür geeignet. Diese Maps müssen durch einen `Mutex` oder `RwLock` geschützt werden, da D-Bus-Methodenaufrufe und Domain-Event-Handler potenziell nebenläufig sind.
- **Verwendung von `zbus::SignalContext` zum Emittieren von Signalen:**
    - Wenn ein Domänen-Event (z.B. `DomainNotificationEvent::Closed`) eintritt, das ein D-Bus-Signal auslösen soll (z.B. `NotificationClosed`), muss der Listener dieses Domänen-Events den `FreedesktopNotificationsServer` darüber informieren.
    - Der Server-Task, der die D-Bus-Schnittstelle implementiert, ist derjenige, der Signale emittieren kann.
    - Um ein Signal aus einem anderen Task (dem Domain-Event-Listener) zu emittieren, muss der `SignalContext` des entsprechenden Interfaces verwendet werden.
    - Eine Möglichkeit ist, dass der Domain-Event-Listener eine Nachricht (z.B. über einen `tokio::sync::mpsc::channel`) an den D-Bus-Server-Task sendet. Dieser Task ruft dann die Signal-Emissionsmethode auf seinem Interface-Objekt auf.
    - **Beispiel (konzeptionell für `NotificationClosed`):**
        
        Rust
        
        ```
        // In FreedesktopNotificationsServer (zbus::Interface Implementierung)
        // #[dbus_interface(name = "org.freedesktop.Notifications")]
        // struct NotificationsServerLogic {
        //     //... id_map: Arc<Mutex<HashMap<u32, Uuid>>>,...
        //     // signal_context: Option<SignalContext<'static>> // Wird von zbus bereitgestellt
        // }
        
        // impl NotificationsServerLogic {
        //     #[dbus_interface(signal)]
        //     async fn notification_closed(&self, ctxt: &SignalContext<'_>, id: u32, reason: u32) -> zbus::Result<()>;
        
        //     // Diese Methode wird vom Domain-Event-Listener aufgerufen (z.B. via MPSC-Kanal)
        //     async fn handle_domain_notification_closed(&self, dbus_id: u32, reason: u32) {
        //         if let Some(ctxt) = self.signal_context() { // Korrekten Weg zum SignalContext finden
        //             if let Err(e) = self.notification_closed(ctxt, dbus_id, reason).await {
        //                 // log_error!("Failed to emit NotificationClosed signal: {:?}", e);
        //             }
        //         }
        //     }
        // }
        ```
        
        Die `SwayNotificationCenter` 77 und `mako` 78 sind Beispiele für Notification Daemons, deren D-Bus Implementierung (falls in Rust/zbus oder C/GDBus) als Inspiration dienen kann. Die Freedesktop Notification Specification 75 ist die maßgebliche Quelle.

### 3.4. Fehlerbehandlung

- **Umgang mit `zbus::Error` und `zbus::fdo::Error`:**
    - `zbus::Error` ist der allgemeine Fehlertyp von `zbus`, der I/O-Fehler, Serialisierungsfehler, Verbindungsfehler etc. umfassen kann.79
    - `zbus::fdo::Error` ist ein spezifischer D-Bus-Fehlertyp, der von Methodenaufrufen zurückgegeben werden kann (z.B. `org.freedesktop.DBus.Error.ServiceUnknown`).
    - Diese Fehler müssen in den jeweiligen Client-Services (z.B. `UPowerClientService`) abgefangen werden.
- **Mapping in eigenes `DBusInterfaceError`-Schema unter Beibehaltung des Fehlerkontexts:**
    - Das `DBusInterfaceError`-Enum sollte Varianten für spezifische Fehlerfälle (z.B. `ServiceUnavailable`, `MethodCallFailed`, `SignalStreamError`, `InvalidResponse`) und eine generische Variante für unerwartete `zbus`-Fehler haben.
    - Die `thiserror`-Crate ist hierfür ideal.
    - Die ursprüngliche `zbus::Error` oder `zbus::fdo::Error` sollte als `source` im `DBusInterfaceError` gespeichert werden, um den Kontext nicht zu verlieren.
    - **Beispiel (konzeptionell):**
        
        Rust
        
        ```
        #
        pub enum DBusInterfaceError {
            #
            ServiceUnavailable { service: String, #[source] source: zbus::Error },
        
            #[error("Method call {method:?} on {interface:?} failed")]
            MethodCallFailed {
                interface: String,
                method: String,
                #[source]
                source: zbus::fdo::Error,
            },
        
            #
            MessageSendError(#[from] zbus::Error),
        
            #
            ResponseParseError{ method: String, #[source] source: zbus::zvariant::Error },
            //... weitere Varianten
        }
        
        // In einem Client-Service:
        // match some_proxy.some_method().await {
        //     Ok(reply) => Ok(reply),
        //     Err(zbus::Error::FDO(fdo_error)) => Err(DBusInterfaceError::MethodCallFailed {
        //         interface: P::INTERFACE.to_string(), // P ist der Proxy-Typ
        //         method: "some_method".to_string(),
        //         source: *fdo_error,
        //     }),
        //     Err(e) => Err(DBusInterfaceError::MessageSendError(e)),
        // }
        ```
        
        Die Granularität der Fehlertypen ist ein wichtiger Aspekt. Eine zu feine Aufteilung von `DBusInterfaceError` kann unhandlich werden. Eine gute Balance zwischen spezifischen, für die Domänenschicht relevanten Fehlern und generischen Catch-All-Varianten ist anzustreben. Die Domänenschicht interessiert sich beispielsweise eher dafür, _ob_ ein Dienst nicht verfügbar ist, um ein Feature zu deaktivieren, als für die genaue Art eines I/O-Fehlers auf dem D-Bus-Socket. Das `DBusInterfaceError` sollte diese Abstraktionsebene widerspiegeln. Bei bestimmten Fehlern, wie `ServiceUnavailable` oder temporären Netzwerkproblemen, könnte eine Retry-Logik in den Client-Services implementiert werden, bevor der Fehler an die Domänenschicht weitergegeben wird. Dies erhöht die Robustheit der Systemschicht gegenüber transienten Fehlern.

Tabelle für Sektion 3.1: Proxy-Management-Strategien

Eine durchdachte Strategie für das Management von D-Bus-Proxies ist entscheidend für Performance und Stabilität. Die naive Erstellung eines Proxys bei jedem Methodenaufruf ist ineffizient. Andererseits können langlebige Proxies veralten, wenn der zugrundeliegende Dienst neu startet oder Objekte verschwinden.

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Strategie**|**Beschreibung**|**Vorteile**|**Nachteile**|**zbus-Mechanismen**|**Eignung für NovaDE-Dienste (Beispiele)**|
|**On-Demand Creation**|Proxy wird bei jedem benötigten Aufruf neu erstellt.|Immer aktuell; einfach zu implementieren.|Hoher Overhead bei häufigen Aufrufen.|`Proxy::new(conn).await`|Selten genutzte Dienste oder einmalige Aufrufe.|
|**Cached Static Proxies**|Proxies für bekannte, statische Objektpfade werden einmal erstellt und wiederverwendet.|Geringer Overhead nach Initialisierung.|Proxy kann veralten, wenn Dienst neu startet (Neuerstellung erforderlich).|`OnceCell`, `Arc<Proxy>`|Manager-Proxies: `UPowerProxy`, `LogindManagerProxy`, `NetworkManagerProxy`, `SecretServiceProxy`, `PolicyKitAuthorityProxy`.|
|**Cached Dynamic Proxies**|Proxies für dynamische Objektpfade werden bei Bedarf erstellt und in einem Cache (z.B. `HashMap`) gehalten.|Reduzierter Overhead für häufig zugegriffene dynamische Objekte.|Cache-Invalidierung komplex; Proxy kann veralten.|`Arc<Mutex<HashMap<ObjectPath, Arc<Proxy>>>>`|`UPowerDeviceProxy`, `LogindSessionProxy`, `NMDeviceProxy`, `SecretCollectionProxy`, `SecretItemProxy`. Erfordert Überwachung von Signalen (z.B. `InterfacesRemoved`).|
|**Proxies via Manager Signals**|Proxies für dynamische Objekte werden nur erstellt, wenn ihre Existenz durch Signale des Managers bekannt wird.|Erstellt Proxies nur für tatsächlich existierende Objekte.|Abhängig von der Zuverlässigkeit und Semantik der Manager-Signale.|Signal-Handler, die Proxies erstellen/entfernen.|Wie "Cached Dynamic Proxies", aber die Erstellung/Entfernung wird durch Signale wie `DeviceAdded`/`DeviceRemoved` (UPower) oder `SessionNew`/`SessionRemoved` (Logind) gesteuert.|
|**Server-seitige Objekt-Ref.**|(Für den Notifications-Server) Referenzen auf exportierte Objekte werden von zbus verwaltet.|Lebenszyklus wird von zbus gehandhabt.|Weniger direkte Kontrolle.|`#[dbus_interface]`, `ObjectServer`|`FreedesktopNotificationsServer`.|

## 4. PipeWire Integration (system::audio_management mit `pipewire-rs`)

Die Integration von PipeWire 80 für Audio-Management in NovaDE erfolgt über die `pipewire-rs`-Bibliothek. Dies erfordert die Verwaltung des PipeWire-MainLoops und die Kommunikation zwischen dem asynchronen Service und dem PipeWire-Thread.

### 4.1. `MainLoop` Management

PipeWire benötigt einen laufenden MainLoop. Die `pipewire-rs`-Bibliothek abstrahiert dies.

- **Strategien zur Integration der `pipewire::MainLoop` in eine tokio-basierte Anwendung:**
    
    - **Option 1: Dedizierter Thread für PipeWire `MainLoop`:** Dies ist der gängigste und oft robusteste Ansatz. Ein separater Systemthread wird gestartet, der ausschließlich `pipewire::MainLoop::run()` ausführt.
        - _Vorteile:_ Klare Trennung der Audioverarbeitung vom Rest der Anwendung, blockiert nicht die Tokio-Runtime.
        - _Nachteile:_ Erfordert Inter-Thread-Kommunikation (IPC) für Befehle und Zustandsaktualisierungen.
    - **Option 2: Integration des PipeWire-FDs in eine tokio-kompatible Event-Loop:** Theoretisch könnte, falls `pipewire-rs` einen Dateideskriptor des PipeWire-Mainloops exponiert, dieser in den Tokio-Eventloop integriert werden (ähnlich wie `calloop` FDs integriert). Dies ist jedoch mit `pipewire-rs` **unwahrscheinlich**, da es oft auf GLib im Hintergrund setzt oder einen eigenen Loop managed. Die Dokumentation von `pipewire-rs` ist hier entscheidend.
        - _Vorteile (hypothetisch):_ Potenziell geringerer Threading-Overhead.
        - _Nachteile (hypothetisch):_ Deutlich komplexere Implementierung, falls nicht direkt von `pipewire-rs` unterstützt.
    - **Empfehlung für NovaDE:** Ein dedizierter Thread für den PipeWire `MainLoop` wird empfohlen, da dies ein etabliertes Muster ist und die Komplexität der direkten FD-Integration vermeidet, es sei denn, `pipewire-rs` bietet explizite Unterstützung für eine Tokio-Integration.
- **Sichere Kommunikation zwischen async-Service-Methoden und dem PipeWire-Thread:**
    
    - **Befehle (Tokio-Service -> PipeWire-Thread):** Ein `tokio::sync::mpsc::channel` ist hierfür ideal. Der `PipeWireClientService` (laufend im Tokio-Kontext) sendet Befehle (z.B. `SetVolumeCommand { device_id: String, volume: f32 }`) an den PipeWire-Thread. Der PipeWire-Thread besitzt den `Receiver`-Teil des Kanals und verarbeitet die eintreffenden Befehle synchron innerhalb seines `MainLoop`-Kontexts.
    - **Zustandsupdates und Events (PipeWire-Thread -> Tokio-Service):**
        - Für lesbare Zustände (z.B. aktuelle Geräteliste, Lautstärken): Ein `Arc<RwLock<AudioSystemState>>` kann verwendet werden. Der PipeWire-Thread hat Schreibzugriff und aktualisiert diesen Zustand, wenn sich etwas ändert (z.B. nach einem Befehl oder durch externe PipeWire-Events). Der Tokio-Service hat Lesezugriff.
        - Für Event-Benachrichtigungen (z.B. `DeviceListChanged`, `DefaultDeviceChanged`): Ein `tokio::sync::watch::channel` (für einzelne Werte, die sich ändern) oder ein `tokio::sync::broadcast::channel` (für Ereignisse, die von mehreren Stellen konsumiert werden könnten) kann vom PipeWire-Thread verwendet werden, um Updates an den Tokio-Service zu senden. Der `PipeWireClientService` abonniert diese Kanäle.
        - Alternativ kann der PipeWire-Thread Callbacks verwenden (siehe Abschnitt 4.2), die dann ihrerseits Nachrichten über einen weiteren `mpsc`-Kanal zurück an den Tokio-Thread senden. Dieser kann dann die `AudioEvent`s über den `SystemEventBridge` publizieren.
- **Code-Beispiel (konzeptionell für dedizierten Thread und MPSC):**
    
    Rust
    
    ```
    use pipewire::Loop; // Beispiel, tatsächliche Typen können variieren
    use std::sync::{Arc, RwLock};
    use tokio::sync::mpsc;
    
    enum PipeWireCommand {
        SetVolume(String, f32),
        // Weitere Befehle
    }
    
    struct InternalAudioState {
        //... z.B. Vec<AudioDevice>
    }
    
    pub struct PipeWireClientService {
        command_tx: mpsc::Sender<PipeWireCommand>,
        audio_state: Arc<RwLock<InternalAudioState>>,
        //... event_rx: broadcast::Receiver<AudioEvent>...
    }
    
    impl PipeWireClientService {
        pub fn new(/*... */) -> Self {
            let (command_tx, mut command_rx) = mpsc::channel(32);
            let audio_state = Arc::new(RwLock::new(InternalAudioState { /*... */ }));
            let audio_state_clone = audio_state.clone();
            // Hier fehlt der Event-Sender vom PipeWire-Thread zum SystemEventBridge
    
            std::thread::spawn(move |
    ```
    

| {

// Diese Initialisierung ist stark vereinfacht und dient nur dem Konzept

let main_loop = pipewire::MainLoop::new(None)

.expect("Failed to create PipeWire MainLoop");

let context = pipewire::Context::new(&main_loop)

.expect("Failed to create PipeWire Context");

let core = context.connect(None)

.expect("Failed to connect to PipeWire Core");

let registry = core.get_registry()

.expect("Failed to get PipeWire Registry");

````
            // Hier würden Listener für Core- und Registry-Events registriert (siehe 4.2)
            // Diese Listener würden audio_state_clone aktualisieren und/oder Events senden

            loop {
                // Verarbeite Befehle vom Tokio-Service
                // main_loop.iterate(false) blockiert nicht lange, erlaubt command_rx.try_recv()
                // oder man nutzt einen blocking_recv mit Timeout in einer Schleife,
                // die auch main_loop.iterate() aufruft.
                match command_rx.blocking_recv() { // In einem echten Szenario ggf. non-blocking oder mit Timeout
                    Some(command) => {
                        // PipeWire-Aktionen basierend auf dem Befehl ausführen
                        // z.B. core.set_volume(...)
                        // audio_state_clone.write().unwrap()... aktualisieren
                    }
                    None => break, // Kanal wurde geschlossen
                }

                // PipeWire-Events verarbeiten (non-blocking)
                if main_loop.iterate(false) < 0 {
                    // Fehler in der PipeWire-Schleife
                    break;
                }
            }
        });

        Self { command_tx, audio_state /*,... */ }
    }

    // Async Methoden, die command_tx verwenden
    pub async fn set_device_volume(&self, device_id: String, volume: f32) -> Result<(), AudioManagementError> {
        self.command_tx.send(PipeWireCommand::SetVolume(device_id, volume)).await
           .map_err(|_| AudioManagementError::InternalThreadCommunicationError)?;
        Ok(())
    }
}
```
Die Thread-Sicherheit der von `pipewire-rs` bereitgestellten Objekte ist fundamental. Objekte wie `pipewire::Core` oder `pipewire::Registry` sind oft nicht `Send` oder `Sync`. Das bedeutet, sie dürfen nicht direkt über `Arc<Mutex<T>>` zwischen Threads geteilt und von verschiedenen Threads modifiziert werden. Alle Operationen, die diese Objekte verändern, müssen im Kontext des PipeWire-MainLoops (also im dedizierten PipeWire-Thread) ausgeführt werden. Befehle vom Tokio-Service müssen daher über einen Kanal an diesen Thread gesendet werden.
````

### 4.2. Callback-Management

PipeWire verwendet ein Callback-basiertes System für Events (z.B. über `RegistryListener`, `CoreListener`, `NodeListener`, `StreamListener`).

- **Verwaltung von Listener-Strukturen, die `'static` sein müssen:**
    
    - Wenn `add_listener_local` verwendet wird, erwartet `pipewire-rs` oft, dass der Listener eine `'static` Lebensdauer hat, da der Listener potenziell länger existiert als der Scope, in dem er erstellt wurde.
    - **Problem mit `self`-Referenzen:** Wenn der Listener Methoden des `PipeWireClientService` oder dessen internen Zustands aufrufen muss, wird es schwierig, da `self` nicht einfach in einen `'static` Closure verschoben werden kann, wenn der Listener selbst Teil von `self` ist oder `self` eine kürzere Lebensdauer hat.
    - **Lösungen:**
        1. **`Arc` und schwache Referenzen (`Weak`):** Der Zustand, auf den der Listener zugreifen muss (z.B. der `mpsc::Sender` für Events zurück an Tokio oder der `Arc<RwLock<InternalAudioState>>`), kann in einen `Arc` gepackt werden. Der Listener-Closure erhält einen Klon dieses `Arc`. Wenn der Listener den `PipeWireClientService` selbst referenzieren muss (z.B. um Methoden aufzurufen), kann ein `Weak<PipeWireClientService>` verwendet werden, das vor der Verwendung zu einem `Arc` aufgewertet wird, um Zyklen zu vermeiden.
        2. **Kanalbasierte Kommunikation:** Der Listener-Callback sendet die empfangenen Daten/Events über einen `mpsc::Sender` (der in den Callback geklont wurde) an einen zentralen Verarbeitungspunkt im PipeWire-Thread oder direkt zurück an den Tokio-Thread.
        3. **Globale oder statische Handler (mit Vorsicht):** In seltenen Fällen könnten globale Handler verwendet werden, aber dies erschwert das Zustandsmanagement erheblich und ist meist nicht empfehlenswert.
- **Beenden von Listenern:**
    
    - Die von `add_listener_local` zurückgegebenen `Listener` structs implementieren `Drop`. Wenn der `Listener` aus dem Scope geht, wird der Listener automatisch von PipeWire entfernt.
    - Es ist wichtig, diese `Listener`-Objekte so lange im Speicher zu halten, wie die Callbacks aktiv sein sollen (z.B. als Felder im PipeWire-Thread-Zustand). Wenn sie vorzeitig gedroppt werden, werden keine Callbacks mehr empfangen.
- **Beispiel (konzeptionell für Registry-Listener):**
    
    Rust
    
    ```
    // Im PipeWire-Thread
    // let registry_listener = registry.add_listener_local()
    //    .global({
    //         let audio_state_clone = audio_state.clone(); // Arc<RwLock<InternalAudioState>>
    //         // let event_tx_clone = event_tx.clone(); // mpsc::Sender<AudioEvent>
    //         move |global_obj| {
    //             if let Some(props) = &global_obj.props {
    //                 if props.get(pipewire::keys::OBJECT_TYPE) == Some("PipeWire:Interface:Device") {
    //                     // Neues Audiogerät gefunden
    //                     // audio_state_clone.write().unwrap().add_device(...);
    //                     // event_tx_clone.send(AudioEvent::DeviceAdded(...)).unwrap();
    //                 }
    //             }
    //         }
    //     })
    //     //... weitere Callbacks...
    //    .register();
    // // registry_listener muss am Leben gehalten werden.
    ```
    

### 4.3. SPA Pod Erstellung und Anwendung

SPA (Simple Plugin API) Pods werden verwendet, um Parameter für PipeWire-Objekte (Nodes, Streams) zu setzen, z.B. für Lautstärkeregelung.

- **Detaillierte Beispiele für die Erstellung von `SpaPod`s:**
    - `pipewire-rs` bietet Builder-APIs oder direkte Konstruktionsmethoden für Pods.
    - **Lautstärkeregelung (`Props` mit `channelVolumes`, `mute`):**
        - Ein `Props`-Pod (oft ein `Object`-Pod mit `ParamProps`-Typ) wird erstellt.
        - Dieser enthält Eigenschaften wie `channelVolumes` (ein Array von Floats, z.B. `[0.5, 0.5]` für Stereo bei 50%) und `mute` (ein Boolean).
        - Die genauen Namen der Eigenschaften (`SpaId`) und deren Typen müssen der PipeWire-Spezifikation für Audio-Nodes entsprechen (z.B. `SpaId::from_str("channelVolumes")`).
    - **Routenparameter auf Devices:** Ähnlich können Pods für Routing-Parameter erstellt werden, um z.B. ein Default-Profil für ein Gerät zu setzen.
- **Korrekte Verwendung mit `node.set_param()`:**
    - Die `set_param`-Methode eines `Node`-Objekts (oder `Stream`-Objekts) erwartet die ID des Parameters, der gesetzt werden soll (z.B. `SpaId::EnumParamPortConfig` für Port-Konfiguration, `SpaId::EnumParamProps` für allgemeine Eigenschaften) und den `SpaPod` mit den neuen Werten.
    - **Beispiel (konzeptionell):**
        
        Rust
        
        ```
        // Annahme: node ist ein pipewire::Node
        // use pipewire::spa::pod::{Pod, PodObject, PodBuilder, Value};
        // use pipewire::spa::param::ParamType;
        // use pipewire::spa::utils::SpaTypes; // Für SpaId-Konstanten
        
        // // Lautstärke setzen (vereinfacht)
        // let mut props_builder = PodBuilder::new_object(
        //     SpaTypes::Props, // Builder-Typ
        //     ParamType::Props.as_raw() // Pod-Typ-ID
        // );
        // props_builder.add(
        //     SpaTypes::PropChannelVolumes, // Key-ID
        //     &Value::Array(vec![Value::Float(0.7), Value::Float(0.7)]) // Wert
        // ).unwrap();
        // props_builder.add(
        //     SpaTypes::PropMute,
        //     &Value::Bool(false)
        // ).unwrap();
        // let props_pod = props_builder.end();
        
        // node.set_param(ParamType::Props.as_raw(), 0, &props_pod).unwrap();
        ```
        
        Die genaue API für die Pod-Erstellung in `pipewire-rs` muss der Dokumentation entnommen werden. Die Verwendung von `spa_sys` oder höheren Abstraktionen in `pipewire-rs` ist möglich.

### 4.4. Metadaten-Interface

Das Metadaten-Interface in PipeWire wird verwendet, um systemweite Einstellungen wie Standard-Audio-Geräte zu verwalten.

- **Interaktion mit dem `Metadata`-Objekt:**
    - PipeWire exponiert ein globales `Metadata`-Objekt (oft mit der ID `PIPEWIRE_METADATA_OBJECT_ID_SETTINGS` oder über die Registry auffindbar).
    - Dieses Objekt hat Eigenschaften (Properties), die über `metadata.set_property()` und `metadata.property()` (oder äquivalente Methoden in `pipewire-rs`) gelesen und geschrieben werden können.
- **Setzen und Lesen von Standard-Audio-Geräten (`default.audio.sink/source`):**
    - Die Namen der Properties für Standardgeräte sind typischerweise `"default.audio.sink"` und `"default.audio.source"`.
    - Der Wert dieser Properties ist die ID (oft eine `u32`) des entsprechenden PipeWire-Node-Objekts, das als Standard-Sink oder -Source dienen soll.
    - Um das Standardgerät zu ändern, wird `metadata.set_property("default.audio.sink", "neue_node_id_als_string")` aufgerufen.
    - Um das aktuelle Standardgerät zu lesen, wird `metadata.property("default.audio.sink")` verwendet.
- **Events:** Änderungen an Metadaten (einschließlich Standardgeräten) lösen Events auf dem `Metadata`-Objekt oder der `Registry` aus, die der `PipeWireClientService` abonnieren muss, um `DefaultDeviceChanged`-Events zu generieren.

## 5. MCP Client (system::mcp_client mit `mcp_client_rs`)

Der Model Context Protocol (MCP) Client ermöglicht die Anbindung an KI-Dienste. NovaDE startet lokale MCP-Server-Prozesse und verwaltet die Kommunikation.

### 5.1. Prozessmanagement

Das Starten und Überwachen lokaler MCP-Server-Prozesse erfolgt mit `tokio::process::Command`.

- **Robuste Methoden:**
    
    - **Starten:** `tokio::process::Command::new("path/to/mcp_server_executable")` wird verwendet, um den Prozess zu konfigurieren (Argumente, Umgebungsvariablen). `Command::spawn()` startet den Prozess asynchron.
    - **Überwachen:**
        - Das von `spawn()` zurückgegebene `Child`-Objekt bietet eine `wait()`-Methode (als Future), um auf das Beenden des Prozesses zu warten und den Exit-Status zu erhalten.
        - Regelmäßige Health-Checks (falls vom MCP-Server unterstützt) oder das Überwachen der Stdio-Pipes können ebenfalls zur Überwachung dienen.
        - Bei unerwartetem Beenden des Prozesses sollte ein Fehler geloggt und ggf. ein Neustartversuch unternommen werden (mit Backoff-Strategie).
- **Handhabung von Stdio (`stdin`/`stdout`):**
    
    - `mcp_client_rs::McpClient` kommuniziert typischerweise über `stdin` und `stdout` mit dem Serverprozess.
    - `Command::stdin(Stdio::piped())` und `Command::stdout(Stdio::piped())` müssen gesetzt werden.
    - Die von `child.stdin.take().unwrap()` und `child.stdout.take().unwrap()` zurückgegebenen `ChildStdin` und `ChildStdout` (die `AsyncWrite` bzw. `AsyncRead` implementieren) werden dann an den `McpClient` übergeben (z.B. beim Konstruktor des Clients).
- **Beispiel (konzeptionell):**
    
    Rust
    
    ```
    use tokio::process::Command;
    use std::process::Stdio;
    
    // async fn start_local_mcp_server(config: &McpServerConfig::LocalExecutable) -> Result<mcp_client_rs::McpClient, McpSystemClientError> {
    //     let mut command = Command::new(&config.executable_path);
    //     command.args(&config.args);
    //     command.stdin(Stdio::piped());
    //     command.stdout(Stdio::piped());
    //     // command.stderr(Stdio::piped()); // Für Fehler-Logging
    
    //     let mut child = command.spawn().map_err(McpSystemClientError::ProcessSpawnFailed)?;
    
    //     let stdin = child.stdin.take().ok_or(McpSystemClientError::StdioUnavailable("stdin".into()))?;
    //     let stdout = child.stdout.take().ok_or(McpSystemClientError::StdioUnavailable("stdout".into()))?;
    
    //     let mcp_client = mcp_client_rs::McpClient::new(stdout, stdin); // Annahme einer solchen API
    
    //     // Optional: Task zur Überwachung des Kindprozesses
    //     tokio::spawn(async move {
    //         match child.wait().await {
    //             Ok(status) => { /* log_info!("MCP server exited with status: {}", status); */ },
    //             Err(e) => { /* log_error!("Failed to wait for MCP server: {}", e); */ }
    //         }
    //         // Hier ggf. ServerConnectionStateChanged-Event senden
    //     });
    
    //     Ok(mcp_client)
    // }
    ```
    

### 5.2. Notification Handling

Asynchrone `McpMessage::Notification`-Nachrichten vom Server müssen in einem Hintergrund-Task überwacht werden.

- **Effiziente Überwachung:**
    - Der `mcp_client_rs::McpClient` sollte eine Methode wie `receive_message()` oder `notifications_stream()` bereitstellen, die einen Stream von `McpMessage`s zurückgibt.
    - Dieser Stream wird in einem dedizierten `tokio::task` konsumiert.
    - `while let Some(message) = stream.next().await` wird verwendet, um Nachrichten zu empfangen.
    - Wenn `message` eine `McpMessage::Notification` ist, wird sie in ein `McpClientSystemEvent::NotificationReceived` umgewandelt und über den `SystemEventBridge` publiziert.
- **Beispiel (konzeptionell):**
    
    Rust
    
    ```
    // In McpConnection::new() oder einer ähnlichen Methode
    // let client_clone = self.mcp_client.clone(); // Annahme, McpClient ist Arc-wrapped oder hat eine clone-bare Listener-API
    // let event_bridge = global_system_event_bridge();
    // tokio::spawn(async move {
    //     // Annahme: client_clone.message_stream() liefert einen Stream<Result<McpMessage, _>>
    //     let mut stream = client_clone.message_stream();
    //     while let Some(result) = stream.next().await {
    //         match result {
    //             Ok(McpMessage::Notification(notification)) => {
    //                 event_bridge.publish(SystemLayerEvent::McpClient(
    //                     McpClientSystemEvent::NotificationReceived {
    //                         server_id: self.server_config.id, // Annahme: Server-ID ist verfügbar
    //                         notification,
    //                     }
    //                 )).await;
    //             }
    //             Ok(_) => { /* Andere Nachrichtentypen ignorieren oder behandeln */ }
    //             Err(e) => {
    //                 // log_error!("Error receiving MCP message: {:?}", e);
    //                 // event_bridge.publish(SystemLayerEvent::McpClient(
    //                 //     McpClientSystemEvent::CommunicationError { server_id: self.server_config.id, error: e.into() }
    //                 // )).await;
    //                 break; // Stream beenden bei Fehler
    //             }
    //         }
    //     }
    // });
    ```
    

### 5.3. Request Timeouts

Die Implementierung von Timeouts für `client.send_request_json()` ist wichtig, um auf nicht antwortende Server zu reagieren.

- **`tokio::time::timeout`:** Die `tokio::time::timeout(duration, future)`-Funktion ist hierfür ideal.
    - Sie wrappt den `Future` des `send_request_json()`-Aufrufs.
    - Wenn der `Future` innerhalb der `duration` nicht auflöst, gibt `timeout` ein `Err(Elapsed)` zurück.
    - Anderenfalls gibt es das `Result` des inneren `Future`s zurück.
- **Beispiel:**
    
    Rust
    
    ```
    use tokio::time::{timeout, Duration};
    
    // async fn send_request_with_timeout(
    //     client: &mcp_client_rs::McpClient,
    //     request: McpRequest, // Annahme: MCP-Request-Typ
    //     timeout_duration: Duration,
    // ) -> Result<McpResponse, McpSystemClientError> { // Annahme: MCP-Response-Typ
    //     match timeout(timeout_duration, client.send_request_json(&request)).await {
    //         Ok(Ok(response)) => Ok(response),
    //         Ok(Err(mcp_err)) => Err(McpSystemClientError::RequestFailed(mcp_err)), // Fehler vom McpClient
    //         Err(_elapsed) => Err(McpSystemClientError::Timeout), // Timeout-Fehler
    //     }
    // }
    ```
    
    Dieses Ergebnis wird dann ggf. als `McpClientSystemEvent::RequestFailed` publiziert.

### 5.4. API-Key Management

API-Keys für `RemoteHttp`-Verbindungen werden über den `SecretsServiceClientService` abgerufen und müssen sicher an den `McpClient` übergeben werden.

- **Sichere Übergabe:**
    - Der `McpConnectionManager` oder `DefaultSystemMcpService` fordert den API-Key vom `SecretsServiceClientService` an, wenn eine `RemoteHttp`-Verbindung konfiguriert wird.
    - Der abgerufene Key (typischerweise ein `String` oder `Vec<u8>`) wird dann an den `mcp_client_rs::McpClient` übergeben, wenn dieser für die Remote-Verbindung initialisiert wird.
    - `mcp_client_rs` sollte eine Methode oder Konfigurationsoption bieten, um den API-Key für HTTP-Header (z.B. `Authorization: Bearer <key>`) zu setzen.
    - Der API-Key sollte **niemals** hartcodiert oder unverschlüsselt in Konfigurationsdateien gespeichert werden. Die Verwendung des Secret Service ist hier die korrekte Vorgehensweise.
    - Es ist wichtig sicherzustellen, dass der API-Key nur im Speicher gehalten wird, solange er benötigt wird, und nicht unnötig geloggt oder anderweitig exponiert wird.

## 6. Schichtübergreifende Synchronisation und Fehlerbehandlung

Die Koordination zwischen verschiedenen Event-Loops und eine konsistente Fehlerbehandlung sind für die Stabilität des Gesamtsystems unerlässlich.

### 6.1. Event-Loops (calloop vs. tokio vs. GLib)

NovaDE verwendet `calloop` für Wayland/Compositor-Events und `tokio` für D-Bus, MCP und interne Timer. Eine potenzielle GLib-Main-Loop könnte von der UI-Schicht (nicht Teil der Systemschicht-Spezifikation, aber relevant für die Integration) verwendet werden.

- **Best Practices für Kommunikation und Datenübergabe:**
    - **`calloop` (Compositor-Thread) <-> `tokio` (Service-Threads):**
        - **Von `tokio` zu `calloop`:**
            - Wenn ein Tokio-Task (z.B. D-Bus-Signal-Handler) eine Aktion im Compositor auslösen muss (z.B. Fenster neu zeichnen lassen), kann dies über einen `calloop::channel` geschehen. Der Tokio-Task sendet eine Nachricht, der `calloop`-Eventloop empfängt sie und führt eine entsprechende Aktion im Compositor-Zustand aus.
            - Alternativ kann ein `Arc<Mutex<T>>` für geteilten Zustand verwendet werden, wobei der Tokio-Task den Zustand modifiziert und der Compositor-Thread ihn periodisch prüft oder durch ein Signal (z.B. `calloop::ping`) aufgeweckt wird.
        - **Von `calloop` zu `tokio`:**
            - Wenn eine Aktion im Compositor (z.B. Benutzerinteraktion) einen Tokio-basierten Service aufrufen muss, kann der Compositor-Code einen `tokio::task` spawnen (wenn der `DesktopState` Zugriff auf eine Tokio-Runtime hat) oder eine Nachricht über einen `std::sync::mpsc` (oder `crossbeam_channel`) an einen lauschenden Tokio-Task senden.
            - Der `SystemEventBridge` (basierend auf `tokio::sync::broadcast`) ist der primäre Mechanismus für Events vom Compositor (oder anderen Systemmodulen) zu Tokio-basierten Listenern.
    - **`tokio` (Systemschicht) <-> GLib (UI-Schicht, falls GTK4):**
        - GTK4 ist nicht threadsicher. Alle UI-Operationen müssen im GLib-Main-Thread ausgeführt werden.82
        - **Von `tokio` zu GLib/GTK4:**
            - `glib::MainContext::spawn_local()` oder `glib::idle_add_local()` sind die Standardmechanismen, um Code aus einem Tokio-Thread im GLib-Main-Thread auszuführen.
            - Ein Tokio-Task kann ein Ergebnis berechnen und dann `glib::MainContext::default().spawn_local(...)` verwenden, um einen Closure auszuführen, der die UI aktualisiert.
            - Die `SystemEventBridge`-Events (`tokio::sync::broadcast::Receiver`) müssen im GLib-Main-Thread konsumiert werden. Ein `glib::MainContext::spawn_local` kann einen `async` Block starten, der auf dem `broadcast::Receiver` lauscht und bei neuen Events UI-Updates durchführt.88
                
                Rust
                
                ```
                // In der UI-Schicht (GTK4)
                // let system_event_rx = global_system_event_bridge().subscribe();
                // glib::MainContext::default().spawn_local(async move {
                //     loop {
                //         match system_event_rx.recv().await {
                //             Ok(system_event) => {
                //                 // UI basierend auf system_event aktualisieren
                //             }
                //             Err(broadcast::error::RecvError::Lagged(_)) => { /*... */ }
                //             Err(broadcast::error::RecvError::Closed) => break,
                //         }
                //     }
                // });
                ```
                
        - **Von GLib/GTK4 zu `tokio`:**
            - Ein GTK-Signal-Handler (der im GLib-Main-Thread läuft) kann einen `tokio::task` auf einer globalen Tokio-Runtime spawnen, um eine langlaufende Operation auszuführen.
            - Das Ergebnis kann dann wieder über `glib::MainContext::spawn_local()` an die UI zurückgespielt werden.
- **Wichtige Überlegungen:**
    - **Blockierung vermeiden:** Kein Thread sollte den Event-Loop eines anderen Threads blockieren. Insbesondere dürfen `calloop`-Callbacks und GLib-Main-Loop-Handler keine langwierigen synchronen Operationen ausführen.
    - **Daten-Ownership und Thread-Safety:** `Send` und `Sync` müssen beachtet werden, wenn Daten zwischen Threads übergeben werden. `Arc<Mutex/RwLock<T>>` für geteilten Zustand oder Kanäle für Nachrichten sind üblich.

### 6.2. Fehler-Wrapping

Eine konsistente Strategie zum Wrappen von Fehlern aus unteren Schichten in die spezifischen Fehler-Enums der Systemschicht-Module ist entscheidend für Robustheit und Debugging.

- **Konsistente Strategien:**
    - **`thiserror` verwenden:** Jedes Modul der Systemschicht (`system::compositor`, `system::input`, etc.) sollte sein eigenes Fehler-Enum definieren (z.B. `CompositorCoreError`, `InputError`), das mit `#[derive(thiserror::Error)]` versehen ist.
    - **`#[from]`-Annotation:** Für Fehler, die direkt von einer Abhängigkeits-Crate stammen und 1:1 übernommen werden können oder eine klare Entsprechung haben, kann `#[from]` verwendet werden.
        
        Rust
        
        ```
        // #
        // pub enum McpSystemClientError {
        //     #[error("MCP client internal error: {0}")]
        //     ClientError(#[from] mcp_client_rs::Error),
        //     //...
        // }
        ```
        
    - **`#[source]`-Annotation:** Wenn ein Fehler aus einer unteren Schicht gewrappt und mit zusätzlichem Kontext versehen wird, sollte der ursprüngliche Fehler mit `#[source]` als Ursache beibehalten werden. Dies ist entscheidend für die `source()`-Kette.
        
        Rust
        
        ```
        // #
        // pub enum AudioManagementError {
        //     #[error("PipeWire connection failed")]
        //     ConnectionError(#[source] pipewire::Error), // Annahme: pipewire::Error ist der Fehlertyp
        //     //...
        // }
        ```
        
    - **Spezifische Fehlervarianten:** Erstellen Sie spezifische Fehlervarianten für häufige oder für die Domänenschicht relevante Fehlerfälle. Dies ermöglicht eine präzisere Fehlerbehandlung in höheren Schichten.
    - **Weitergabe an die Domänenschicht:** Die Domänenschicht sollte idealerweise nicht direkt mit den spezifischen Fehlertypen der Systemschicht-Module konfrontiert werden. Eine übergeordnete `SystemLayerError`-Enum, die alle modul-spezifischen Systemfehler wrappt, oder ein generischerer Ansatz (z.B. `anyhow::Error` mit Kontext) kann verwendet werden, um Fehler an die Domänenschicht zu propagieren. Die `source()`-Kette bleibt dabei erhalten und ermöglicht bei Bedarf eine detaillierte Fehleranalyse.
    - **Logging:** Fehler sollten auf der Systemschicht geloggt werden, bevor sie weitergegeben werden, insbesondere wenn sie nicht trivial sind oder wichtige Kontextinformationen enthalten.

## 7. Schlussfolgerungen und Empfehlungen

Die Entwicklung der Systemschicht für NovaDE stellt eine komplexe Aufgabe dar, die ein tiefes Verständnis der zugrundeliegenden Technologien und Protokolle erfordert. Die gewählte Architektur mit einer klaren Trennung in Module und der Verwendung etablierter Bibliotheken wie Smithay, libinput, zbus und pipewire-rs bildet eine solide Grundlage.

**Zentrale Herausforderungen und Lösungsansätze:**

- **Zustandsmanagement im Compositor:** Die Komplexität des `DesktopState` sollte durch Modularisierung und klare Verantwortlichkeiten reduziert werden. Die `delegate_*!`-Makros von Smithay sind hierbei wertvolle Werkzeuge. Geteilter Zustand erfordert sorgfältige Synchronisation mit `Arc<Mutex/RwLock<T>>`, wobei feingranulare Locks und die Vermeidung von Deadlocks essentiell sind.
- **Wayland-Protokollimplementierung:** Die korrekte Implementierung spezifischer Protokolle wie `wlr-output-management` (Atomarität, Serial-Handling), `wlr-output-power-management` (exklusive Kontrolle) und `wlr-layer-shell` (exklusive Zonen) ist entscheidend für die Funktionalität und Stabilität des Desktops. Die Protokoll-Spezifikationen und existierende Implementierungen (z.B. in wlroots-basierten Compositors) dienen als wichtige Referenzen.
- **Asynchronität und Event-Loop-Integration:** Die Koordination zwischen `calloop` (Compositor) und `tokio` (D-Bus, MCP, Timer) erfordert robuste IPC-Mechanismen wie Kanäle (`tokio::sync::mpsc`, `calloop::channel`) und geteilten Zustand (`Arc<Mutex<T>>`). Für die UI-Integration (GLib) sind `glib::MainContext::spawn_local` und `glib::idle_add_local` Schlüsselkomponenten.
- **Fehlerbehandlung:** Eine konsistente Fehler-Wrapping-Strategie mit `thiserror` unter Beibehaltung der `source()`-Kette ist für Diagnose und Robustheit unerlässlich.

**Empfehlungen für die weitere Entwicklung:**

1. **Priorisierung von Tests:** Angesichts der Komplexität, insbesondere bei der Interaktion verschiedener Protokolle und Event-Loops, sollten Unit- und Integrationstests frühzeitig und umfassend implementiert werden.
2. **Dokumentation und Code-Beispiele:** Die interne Dokumentation sollte detailliert sein. Das Studium von Open-Source-Compositors, die ähnliche Technologien verwenden (z.B. Anvil für Smithay, andere Compositors für wlroots-Protokolle), kann wertvolle Einblicke liefern.
3. **Performance-Analyse:** Regelmäßige Performance-Analysen, insbesondere in kritischen Pfaden wie Rendering und Eingabeverarbeitung, sind notwendig, um Engpässe frühzeitig zu erkennen.
4. **Sicherheitsaspekte:** Bei der Interaktion mit externen Diensten (D-Bus, MCP) und der Verarbeitung von Client-Eingaben müssen Sicherheitsaspekte (Input-Validierung, Berechtigungsmanagement via PolicyKit) berücksichtigt werden.
5. **Iterative Entwicklung:** Aufgrund der Komplexität ist ein iterativer Ansatz, bei dem einzelne Module und Protokolle schrittweise implementiert und getestet werden, empfehlenswert.

Durch die konsequente Anwendung von Best Practices und eine sorgfältige Implementierung der spezifizierten Komponenten kann die Systemschicht von NovaDE eine stabile und leistungsfähige Basis für die darüberliegenden Schichten bilden.

# NovaDE Ultra-Feinspezifikation: Domänenschicht & Wayland/Smithay-Integration

Dieses Dokument definiert die detaillierten technischen Spezifikationen für die Domänenschicht des NovaDE-Projekts und deren Integration mit dem Wayland-Compositor, der unter Verwendung des Smithay-Toolkits implementiert wird. Es dient als direkter Implementierungsleitfaden für Entwickler und beschreibt die Kernarchitektur, Datenstrukturen, APIs und Interaktionsmuster.

## 1. Domänenschicht-Spezifikationen

Die Domänenschicht kapselt die Kernlogik und den Zustand der NovaDE-Desktop-Umgebung. Sie ist bewusst unabhängig von UI-Details und systemspezifischen Implementierungen konzipiert, um eine klare Trennung der Verantwortlichkeiten zu gewährleisten und die Wartbarkeit sowie Testbarkeit des Systems zu verbessern. Diese Schicht bildet das Herzstück von NovaDE und definiert die grundlegenden Entitäten, Regeln und Prozesse, die das Verhalten der Desktop-Umgebung bestimmen.

### 1.1. Modul: `domain::theming`

Dieses Modul ist verantwortlich für die Logik des Erscheinungsbilds (Theming), die Verwaltung von Design-Tokens, die Interpretation von Theme-Definitionen und die Ermöglichung dynamischer Theme-Wechsel. Es stellt die Grundlage für ein konsistentes und anpassbares Benutzererlebnis dar.

Referenzierte Dokumente: B1 Domänenschicht.md

#### 1.1.1. Datenstrukturen (`domain::theming::types`)

Die folgenden Datenstrukturen definieren die Kernentitäten für das Theming-System:

- **`TokenIdentifier`**: Ein Wrapper für `String` zur eindeutigen Identifizierung von Design-Tokens (z.B. `"color.background.primary"`).
    
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `PartialOrd`, `Ord`, `Display`, `From<&str>`.
    - Invarianten: Darf nicht leer sein und darf nur ASCII-Alphanumerische Zeichen, Punkte (`.`) und Bindestriche (`-`) enthalten. Diese strikten Invarianten sind entscheidend, um Parsing-Fehler zu vermeiden und eine konsistente Referenzierung von Tokens im gesamten System sicherzustellen, was die Token-Verwaltung vereinfacht und potenzielle Laufzeitprobleme reduziert.
- **`TokenValue`**: Ein Enum zur Repräsentation der verschiedenen Typen von Token-Werten.
    
    - Varianten: `Color(String)`, `Dimension(String)`, `FontSize(String)`, `FontFamily(String)`, `FontWeight(String)`, `LineHeight(String)`, `LetterSpacing(String)`, `Border(String)`, `Shadow(String)`, `Radius(String)`, `Spacing(String)`, `ZIndex(i32)`, `Opacity(f64)` (Wertebereich 0.0-1.0), `Text(String)`, `Reference(TokenIdentifier)`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Die `Opacity`-Werte werden bei der Zuweisung oder Verarbeitung automatisch auf den Bereich [0.0,1.0] geklemmt, um ungültige Zustände zu verhindern. Die `Reference` Variante ermöglicht es, Tokens aufeinander verweisen zu lassen, was eine flexible und wartbare Theme-Struktur unterstützt.
- **`RawToken`**: Eine Struktur zur Repräsentation eines Tokens, wie es typischerweise aus einer Konfigurationsdatei gelesen wird.
    
    - Felder: `id: TokenIdentifier`, `value: TokenValue`, `description: Option<String>`, `group: Option<String>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
- **`TokenSet`**: Ein Typalias für `std::collections::BTreeMap<TokenIdentifier, RawToken>`.
    
    - Die Verwendung von `BTreeMap` stellt sicher, dass Tokens bei der Verarbeitung oder Anzeige konsistent sortiert sind, was die Fehlersuche und das Management erleichtert.
- **`ThemeIdentifier`**: Ein Wrapper für `String` zur eindeutigen Identifizierung von Themes.
    
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `PartialOrd`, `Ord`, `Display`, `From<&str>`.
    - Invarianten: Darf nicht leer sein. Empfohlene Zeichen sind `a-z`, `A-Z`, `0-9`, `.` und `-`, um Kompatibilität über verschiedene Dateisysteme und Kontexte hinweg zu gewährleisten.
- **`ColorSchemeType`**: Ein Enum zur Unterscheidung zwischen hellen und dunklen Farbschemata.
    
    - Varianten: `Light`, `Dark`.
    - Implementiert: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `Default` (standardmäßig `Light`).
- **`AccentColor`**: Eine Struktur zur Repräsentation einer Akzentfarbe innerhalb eines Themes.
    
    - Felder: `name: Option<String>`, `value: novade_core::types::Color`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Für `Eq` und `Hash` auf dem Feld `value` (vom Typ `novade_core::types::Color`) ist möglicherweise eine manuelle Implementierung oder eine Konvertierung in einen kanonischen Hex-String erforderlich, um konsistentes Verhalten in Hash-basierten Sammlungen sicherzustellen.
- **`ThemeVariantDefinition`**: Definiert spezifische Token-Werte für eine bestimmte Theme-Variante (z.B. helles oder dunkles Schema).
    
    - Felder: `applies_to_scheme: ColorSchemeType`, `tokens: TokenSet`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
- **`ThemeDefinition`**: Die vollständige Definition eines Themes, inklusive Basis-Tokens, Varianten und Akzentfarb-Informationen.
    
    - Felder: `id: ThemeIdentifier`, `name: String`, `description: Option<String>`, `author: Option<String>`, `version: Option<String>`, `base_tokens: TokenSet`, `variants: Vec<ThemeVariantDefinition>`, `supported_accent_colors: Option<Vec<AccentColor>>`, `accentable_tokens: Option<HashMap<TokenIdentifier, AccentModificationType>>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Das Feld `accentable_tokens` ermöglicht eine feingranulare Steuerung, wie Akzentfarben auf einzelne Tokens angewendet werden.
- **`AccentModificationType`**: Ein Enum, das beschreibt, wie ein Token durch eine Akzentfarbe modifiziert werden soll.
    
    - Varianten: `DirectReplace`, `Lighten(f32)`, `Darken(f32)`.
    - Die Parameter für `Lighten` und `Darken` (z.B. `f32`) geben den Grad der Aufhellung oder Abdunkelung an.
- **`AppliedThemeState`**: Repräsentiert den aktuell aktiven, vollständig aufgelösten Theme-Zustand, der an die UI-Schicht übergeben wird.
    
    - Felder: `theme_id: ThemeIdentifier`, `color_scheme: ColorSchemeType`, `active_accent_color: Option<AccentColor>`, `resolved_tokens: std::collections::BTreeMap<TokenIdentifier, String>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`.
    - Invarianten: `resolved_tokens` darf keine `TokenValue::Reference` mehr enthalten; alle Werte müssen zu finalen Strings aufgelöst sein. Dies ist kritisch, da die UI-Schicht keine Token-Referenzen interpretieren soll.
- **`ThemingConfiguration`**: Benutzerspezifische Einstellungen für das Theming.
    
    - Felder: `selected_theme_id: ThemeIdentifier`, `preferred_color_scheme: ColorSchemeType`, `selected_accent_color: Option<novade_core::types::Color>`, `custom_user_token_overrides: Option<TokenSet>`.
    - Implementiert: `Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`, `Default`.
    - Die `Default`-Implementierung stellt sicher, dass das System auch ohne explizite Benutzerkonfiguration einen validen Ausgangszustand hat.

#### 1.1.2. Fehlerbehandlung (`domain::theming::errors`)

Das `ThemingError` Enum, definiert mit `thiserror`, kapselt alle potenziellen Fehler, die im Theming-Modul auftreten können. Dies ermöglicht eine präzise und kontextbezogene Fehlerbehandlung.

- **Varianten**:
    - `TokenFileParseError { path: PathBuf, source: serde_json::Error }`: Fehler beim Parsen einer Token-JSON-Datei.
    - `TokenFileIoError { path: PathBuf, source: std::io::Error }`: Fehler beim Lesen/Schreiben einer Token-Datei.
    - `InvalidTokenData { path: PathBuf, message: String }`: Ungültige Datenstruktur in einer Token-Datei.
    - `InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String }`: Ein Token-Wert entspricht nicht dem erwarteten Format oder Typ.
    - `CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> }`: Zyklische Abhängigkeit bei der Token-Referenzierung entdeckt.
    - `ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, source: serde_json::Error }`: Fehler beim Parsen einer Theme-JSON-Datei.
    - `ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, source: std::io::Error }`: Fehler beim Lesen/Schreiben einer Theme-Datei.
    - `InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String }`: Ungültige Datenstruktur in einer Theme-Datei.
    - `ThemeNotFound { theme_id: ThemeIdentifier }`: Das angeforderte Theme konnte nicht gefunden werden.
    - `MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier }`: Ein referenziertes Token existiert nicht.
    - `MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 }`: Die maximale Tiefe für Token-Referenzen wurde überschritten, um Endlosschleifen zu verhindern.
    - `ThemeApplicationError { message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`: Allgemeiner Fehler bei der Anwendung eines Themes.
    - `FallbackThemeLoadError { source: Box<dyn std::error::Error + Send + Sync + 'static>> }`: Fehler beim Laden des Fallback-Themes.
    - `InitialConfigurationError(String)`: Fehler bei der Initialisierung der Theming-Konfiguration.
    - `InternalStateError(String)`: Unerwarteter interner Fehler im Theming-Modul.
    - `EventSubscriptionError(String)`: Fehler bei der Registrierung für Theme-Änderungs-Events.
    - `AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: novade_core::types::Color, details: String }`: Fehler bei der Anwendung einer Akzentfarbe.
    - `TokenResolutionError { token_id: TokenIdentifier, message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`: Fehler während der Auflösung eines spezifischen Tokens.
    - `FilesystemError(#[from] novade_core::errors::CoreError)`: Fehler im Zusammenhang mit Dateisystemoperationen, die von `novade_core` stammen.

#### 1.1.3. Kernlogik (`domain::theming::logic`)

Die Kernlogik des Theming-Moduls umfasst das Laden, Validieren und Auflösen von Themes und Tokens.

- **Konstante**: `MAX_TOKEN_RESOLUTION_DEPTH: u8 = 16`. Dieser Wert begrenzt die Rekursionstiefe bei der Auflösung von Token-Referenzen, um Endlosschleifen und übermäßigen Ressourcenverbrauch zu verhindern. Der Wert 16 stellt einen pragmatischen Kompromiss zwischen Flexibilität und Sicherheit dar.
    
- **Token/Theme Laden & Validieren**:
    
    - `async fn load_raw_tokens_from_file(path: &Path, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Liest eine JSON-Datei vom angegebenen Pfad, parst deren Inhalt zu einem `TokenSet` und validiert auf Duplikate sowie das grundlegende Format der Tokens. Nutzt den `ConfigServiceAsync` für asynchrone Dateioperationen.
    - `async fn load_and_validate_token_files(paths: &, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Lädt Tokens von mehreren Pfaden, führt sie zusammen (wobei Benutzer-Tokens System-Tokens überschreiben) und validiert das Ergebnis auf Zyklen und andere Inkonsistenzen.
    - `async fn load_theme_definition_from_file(path: &Path, theme_id_override: Option<ThemeIdentifier>, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<ThemeDefinition, ThemingError>`: Liest eine JSON-Datei und parst sie zu einer `ThemeDefinition`. Ermöglicht das Überschreiben der Theme-ID, falls diese nicht im Dateinamen enthalten ist oder anders abgeleitet werden muss.
    - `async fn load_and_validate_theme_files(paths: &, available_tokens: &TokenSet, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<Vec<ThemeDefinition>, ThemingError>`: Lädt mehrere Theme-Definitionen von den angegebenen Pfaden und validiert die darin enthaltenen Token-Referenzen gegen den Satz der global verfügbaren Tokens (`available_tokens`).
    - `fn validate_tokenset_for_cycles(tokens: &TokenSet) -> Result<(), ThemingError>`: Verwendet eine Tiefensuche (Depth-First Search, DFS), um zyklische Referenzen innerhalb eines `TokenSet` zu erkennen.
- **Token Resolution Pipeline**:
    
    - `fn resolve_tokens_for_config(config: &ThemingConfiguration, theme_def: &ThemeDefinition, global_tokens: &TokenSet, accentable_tokens_map: &HashMap<TokenIdentifier, AccentModificationType>, max_depth: u8) -> Result<BTreeMap<TokenIdentifier, String>, ThemingError>`: Diese zentrale Funktion ist verantwortlich für die Auflösung aller Tokens zu ihren finalen String-Werten basierend auf der aktuellen Konfiguration.
        
        1. Startet mit einer Basis-Token-Menge, die aus globalen Tokens und den Basis-Tokens des ausgewählten Themes besteht.
        2. Wendet die Tokens der passenden Theme-Variante (hell/dunkel) an, die die Basis-Tokens überschreiben.
        3. Appliziert die ausgewählte Akzentfarbe. Dies geschieht durch Modifikation der Tokens, die im `accentable_tokens_map` des Themes definiert sind, gemäß dem `AccentModificationType`.
        4. Wendet benutzerspezifische Token-Overrides an, die die höchste Priorität haben.
        5. Führt eine rekursive Auflösung für alle Tokens vom Typ `TokenValue::Reference` durch. Dabei wird die Funktion `resolve_single_token_value` (nicht explizit in der API, aber impliziert durch die Logik) verwendet, die eine Zyklenerkennung und eine Begrenzung der Rekursionstiefe (`max_depth`) implementiert.
        6. Konvertiert alle aufgelösten `TokenValue`-Instanzen in ihre finalen String-Repräsentationen (z.B. Farbcodes, Dimensionsangaben).
        
        - Das Ergebnis ist ein `BTreeMap<TokenIdentifier, String>`, das keine Referenzen mehr enthält und direkt von der UI-Schicht verwendet werden kann.
- **Caching**:
    
    - Ein Cache für `AppliedThemeState` wird implementiert, um die wiederholte, potenziell aufwendige Auflösung von Tokens zu vermeiden.
    - Der Cache-Schlüssel (`CacheKey`) wird gebildet aus: `(ThemeIdentifier, ColorSchemeType, Option<String> /* hex von AccentColor */, u64 /* hash von Overrides */)`.
    - Diese Strategie stellt sicher, dass bei relevanten Änderungen der Konfiguration ein neuer Zustand generiert wird, während bei unveränderter Konfiguration auf den gecachten Zustand zurückgegriffen werden kann.
- **Fallback**:
    
    - `fn generate_fallback_applied_state() -> AppliedThemeState`: Generiert einen minimalen, aber funktionsfähigen `AppliedThemeState` aus einkompilierten JSON-Definitionen. Dies stellt sicher, dass das System auch dann ein grundlegendes Erscheinungsbild hat, wenn keine Theme-Dateien geladen werden können oder Konfigurationsfehler auftreten.

#### 1.1.4. API (`domain::theming::service::ThemingEngine`)

Die `ThemingEngine` ist die zentrale Schnittstelle für andere Teile des Systems, um auf Theming-Funktionalitäten zuzugreifen.

- **Struktur `ThemingEngineInternalState`**: Kapselt den internen, veränderlichen Zustand der Engine.
    
    - Felder: `current_config: ThemingConfiguration`, `available_themes: Vec<ThemeDefinition>`, `global_raw_tokens: TokenSet`, `applied_state: AppliedThemeState`, `theme_load_paths: Vec<PathBuf>`, `token_load_paths: Vec<PathBuf>`, `resolved_state_cache: HashMap<CacheKey, AppliedThemeState>`, `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`.
    - Die Verwendung von `Arc` für `config_service` ermöglicht die gemeinsame Nutzung dieses Dienstes.
- **Struktur `ThemingEngine`**: Die öffentliche API-Struktur.
    
    - Felder: `internal_state: Arc<tokio::sync::Mutex<ThemingEngineInternalState>>`, `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`.
    - Die Verwendung von `Arc<tokio::sync::Mutex<...>>` gewährleistet Thread-sicheren Zugriff auf den internen Zustand in einer asynchronen Umgebung.
    - `tokio::sync::broadcast::Sender` wird für die Veröffentlichung von Theme-Änderungs-Events verwendet.
- **Methoden**:
    
    - `async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, broadcast_capacity: usize) -> Result<Self, ThemingError>`: Konstruktor, der die Engine initialisiert, initiale Themes und Tokens lädt und den ersten `AppliedThemeState` generiert.
    - `async fn get_current_theme_state(&self) -> AppliedThemeState`: Gibt den aktuell angewendeten und aufgelösten Theme-Zustand zurück.
    - `async fn get_available_themes(&self) -> Vec<ThemeDefinition>`: Gibt eine Liste aller verfügbaren Theme-Definitionen zurück.
    - `async fn get_current_configuration(&self) -> ThemingConfiguration`: Gibt die aktuelle Benutzerkonfiguration für das Theming zurück.
    - `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`: Aktualisiert die Benutzerkonfiguration, löst die Tokens neu auf, aktualisiert den Cache und publiziert ein `ThemeChangedEvent`.
    - `async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`: Lädt alle Theme- und Token-Dateien von den konfigurierten Pfaden neu, validiert sie, aktualisiert den internen Zustand und den Cache und publiziert ggf. ein `ThemeChangedEvent`.
    - `fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`: Ermöglicht anderen Modulen, auf Änderungen des Themes zu reagieren.

#### 1.1.5. Events (`domain::theming::events`)

- **`ThemeChangedEvent`**: Wird publiziert, wenn sich der angewendete Theme-Zustand ändert.
    - Payload: `new_state: AppliedThemeState`.
    - Dieses Event ist entscheidend für die dynamische Aktualisierung der Benutzeroberfläche, ohne dass Komponenten den `ThemingEngine` ständig pollen müssen.

### 1.2. Modul: `domain::workspaces`

Dieses Modul ist für die Logik und Verwaltung von Arbeitsbereichen (auch "Spaces" oder "virtuelle Desktops" genannt) zuständig. Es definiert, wie Arbeitsbereiche erstellt, modifiziert, gelöscht und wie Fenster ihnen zugewiesen werden.

Referenzierte Dokumente: B2 Domänenschicht.md

#### 1.2.1. Untermodul: `domain::workspaces::core`

Das `core`-Untermodul definiert die grundlegenden Datenstrukturen, Entitäten und Kernfehler für Arbeitsbereiche.

- **Datenstrukturen (`domain::workspaces::core::types`)**:
    
    - `WorkspaceId`: Ein Typalias für `uuid::Uuid`, um Arbeitsbereiche eindeutig zu identifizieren. Die Verwendung von UUIDs stellt globale Eindeutigkeit sicher, was bei der Synchronisation oder bei verteilten Szenarien vorteilhaft sein kann.
    - `WindowIdentifier`: Ein Wrapper für `String` zur Identifizierung von Fenstern.
        - Implementiert `new(id: impl Into<String>) -> Result<Self, WorkspaceCoreError>`. Die Validierung (z.B. nicht leer) erfolgt hier. Dies stellt sicher, dass Fensterbezeichner immer in einem validen Zustand sind.
    - `WorkspaceLayoutType`: Ein Enum zur Definition der verschiedenen Layout-Modi eines Arbeitsbereichs.
        - Varianten: `Floating`, `TilingHorizontal`, `TilingVertical`, `Maximized`.
        - Implementiert `Default` (standardmäßig `Floating`).
- **Entität `Workspace` (`domain::workspaces::core::mod.rs`)**: Die zentrale Entität, die einen Arbeitsbereich repräsentiert.
    
    - Felder:
        - `id: WorkspaceId`: Eindeutiger Identifikator.
        - `name: String`: Vom Benutzer lesbarer Name des Arbeitsbereichs (z.B. "Arbeit", "Web").
        - `persistent_id: Option<String>`: Eine optionale, persistente ID, die über Sitzungen hinweg stabil bleiben kann (z.B. für das Wiederherstellen von Arbeitsbereichs-Setups).
        - `layout_type: WorkspaceLayoutType`: Der aktuelle Layout-Modus.
        - `window_ids: HashSet<WindowIdentifier>`: Eine Menge der IDs der Fenster, die diesem Arbeitsbereich zugeordnet sind.
        - `created_at: DateTime<Utc>`: Zeitstempel der Erstellung.
        - `icon_name: Option<String>`: Optionaler Name eines Icons zur visuellen Repräsentation.
        - `accent_color_hex: Option<String>`: Optionale Akzentfarbe im Hex-Format für den Arbeitsbereich.
    - Methoden:
        - `new(name: String, persistent_id: Option<String>, layout_type: WorkspaceLayoutType, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<Self, WorkspaceCoreError>`: Konstruktor für neue Arbeitsbereiche. Validiert Eingaben wie `name` und `accent_color_hex`.
        - `id() -> WorkspaceId`: Gibt die ID des Arbeitsbereichs zurück.
        - `name() -> &str`: Gibt den Namen des Arbeitsbereichs zurück.
        - `rename(&mut self, new_name: String) -> Result<(), WorkspaceCoreError>`: Ändert den Namen des Arbeitsbereichs. Validiert den neuen Namen.
        - `set_layout_type(&mut self, layout_type: WorkspaceLayoutType)`: Ändert den Layout-Typ.
        - `add_window_id(&mut self, window_id: WindowIdentifier)` (`crate`-intern): Fügt eine Fenster-ID hinzu. Die Sichtbarkeit ist auf `crate` beschränkt, da die Fensterzuweisung über den `assignment`-Service erfolgen soll.
        - `remove_window_id(&mut self, window_id: &WindowIdentifier) -> bool` (`crate`-intern): Entfernt eine Fenster-ID.
        - `set_icon_name(&mut self, icon_name: Option<String>)`: Setzt den Icon-Namen.
        - `set_accent_color_hex(&mut self, accent_color_hex: Option<String>) -> Result<(), WorkspaceCoreError>`: Setzt die Akzentfarbe und validiert das Format.
- **Event-Payloads (`domain::workspaces::core::event_data`)**: Strukturen, die als Daten für die verschiedenen Arbeitsbereichs-Events dienen.
    
    - `WorkspaceRenamedData { new_name: String }`
    - `WorkspaceLayoutChangedData { new_layout: WorkspaceLayoutType }`
    - `WindowAddedToWorkspaceData { window_id: WindowIdentifier }`
    - `WindowRemovedFromWorkspaceData { window_id: WindowIdentifier }`
    - `WorkspacePersistentIdChangedData { new_persistent_id: Option<String> }`
    - `WorkspaceIconChangedData { new_icon_name: Option<String> }`
    - `WorkspaceAccentChangedData { new_accent_color_hex: Option<String> }`
- **Fehlerbehandlung (`domain::workspaces::core::errors`)**:
    
    - `WorkspaceCoreError`: Enum für Fehler, die direkt bei der Manipulation einer `Workspace`-Entität auftreten können.
        - Varianten: `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`, `WindowIdentifierEmpty`, `InvalidAccentColorFormat`.

#### 1.2.2. Untermodul: `domain::workspaces::assignment`

Dieses Untermodul stellt die API für die Zuordnung von Fenstern zu Arbeitsbereichen bereit. Es stellt sicher, dass die Regeln für Fensterzuweisungen eingehalten werden.

- **API (`domain::workspaces::assignment::mod.rs`)**: Funktionen, die auf einer veränderlichen `HashMap<WorkspaceId, Workspace>` operieren. Dieser Ansatz ermöglicht es, die Zuordnungslogik von der Hauptverwaltung der Arbeitsbereiche zu entkoppeln, macht aber eine sorgfältige Zustandsverwaltung erforderlich, um Konsistenz zu gewährleisten.
    
    - `assign_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier, ensure_unique_assignment: bool) -> Result<(), WindowAssignmentError>`: Weist ein Fenster einem spezifischen Arbeitsbereich zu. Der Parameter `ensure_unique_assignment` steuert, ob ein Fenster zuvor von allen anderen Arbeitsbereichen entfernt werden muss.
    - `remove_window_from_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<bool, WindowAssignmentError>`: Entfernt ein Fenster von einem spezifischen Arbeitsbereich. Gibt `true` zurück, wenn das Fenster entfernt wurde.
    - `move_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, window_id: &WindowIdentifier, source_workspace_id: WorkspaceId, target_workspace_id: WorkspaceId) -> Result<(), WindowAssignmentError>`: Verschiebt ein Fenster von einem Quell- zu einem Zielarbeitsbereich.
    - `find_workspace_for_window(workspaces: &HashMap<WorkspaceId, Workspace>, window_id: &WindowIdentifier) -> Option<WorkspaceId>`: Findet den Arbeitsbereich, dem ein bestimmtes Fenster zugewiesen ist.
- **Fehlerbehandlung (`domain::workspaces::assignment::errors`)**:
    
    - `WindowAssignmentError`: Enum für Fehler, die bei der Fensterzuweisung auftreten können.
        - Varianten: `WorkspaceNotFound`, `WindowAlreadyAssigned` (wenn `ensure_unique_assignment` true ist und das Fenster bereits auf dem Ziel-Workspace ist oder auf einem anderen und nicht entfernt werden konnte), `WindowNotAssignedToWorkspace`, `SourceWorkspaceNotFound`, `TargetWorkspaceNotFound`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation` (für zukünftige, komplexere Zuweisungsregeln), `Internal`.

#### 1.2.3. Untermodul: `domain::workspaces::config`

Verantwortlich für die Persistenz und das Laden von Arbeitsbereichs-Konfigurationen.

- **Datenstrukturen (`domain::workspaces::config::mod.rs`)**:
    
    - `WorkspaceSnapshot`: Eine serialisierbare Repräsentation eines Arbeitsbereichs für die Speicherung. Enthält nur persistente Eigenschaften.
        - Felder: `persistent_id: String`, `name: String`, `layout_type: WorkspaceLayoutType`, `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - `WorkspaceSetSnapshot`: Eine serialisierbare Repräsentation eines Sets von Arbeitsbereichen und des aktiven Arbeitsbereichs.
        - Felder: `workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`.
- **API (`domain::workspaces::config::mod.rs`)**:
    
    - Trait `WorkspaceConfigProvider`: Definiert die Schnittstelle für das Laden und Speichern von Arbeitsbereichs-Konfigurationen.
        - `async fn load_workspace_config(&self) -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>`
        - `async fn save_workspace_config(&self, snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>`
    - Struktur `FilesystemConfigProvider`: Eine Implementierung von `WorkspaceConfigProvider`, die `novade_core::config::ConfigServiceAsync` für Dateioperationen verwendet. Dies entkoppelt die Workspace-Logik von den Details der Dateispeicherung.
- **Fehlerbehandlung (`domain::workspaces::config::errors`)**:
    
    - `WorkspaceConfigError`: Enum für Fehler im Zusammenhang mit der Konfigurationspersistenz.
        - Varianten: `LoadError { source: novade_core::errors::CoreError }`, `SaveError { source: novade_core::errors::CoreError }`, `InvalidData { message: String }`, `SerializationError { source: serde_json::Error }`, `DeserializationError { source: serde_json::Error }`, `PersistentIdNotFoundInLoadedSet { persistent_id: String }`, `DuplicatePersistentIdInLoadedSet { persistent_id: String }`.

#### 1.2.4. Untermodul: `domain::workspaces::manager`

Der `WorkspaceManagerService` ist die Hauptschnittstelle zur Verwaltung von Arbeitsbereichen. Er orchestriert die `core`-, `assignment`- und `config`-Logik.

- **API (`domain::workspaces::manager::mod.rs`)**:
    
    - Trait `WorkspaceManagerService`: Definiert die öffentliche API für die Arbeitsbereichsverwaltung.
        - Methoden: `async fn create_workspace(&self, name: String, persistent_id: Option<String>, layout_type: Option<WorkspaceLayoutType>, icon: Option<String>, accent_color: Option<String>) -> Result<Workspace, WorkspaceManagerError>`, `async fn delete_workspace(&self, id: WorkspaceId, fallback_workspace_id: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>`, `async fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>`, `async fn all_workspaces_ordered(&self) -> Vec<Workspace>`, `async fn active_workspace_id(&self) -> Option<WorkspaceId>`, `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`, `async fn assign_window_to_active_workspace(&self, window_id: WindowIdentifier) -> Result<(), WorkspaceManagerError>`, `async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: WindowIdentifier) -> Result<(), WorkspaceManagerError>`, `async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<bool, WorkspaceManagerError>`, `async fn move_window_to_specific_workspace(&self, window_id: &WindowIdentifier, target_workspace_id: WorkspaceId) -> Result<(), WorkspaceManagerError>`, `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`, `async fn set_workspace_layout(&self, id: WorkspaceId, layout: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>`, `async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>`, `async fn set_workspace_accent_color(&self, id: WorkspaceId, accent_color_hex: Option<String>) -> Result<(), WorkspaceManagerError>`, `async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>`, `fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`, `async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>`.
- **Implementierung `DefaultWorkspaceManager`**: Hält einen `Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>`.
    
    - `WorkspaceManagerInternalState`: Kapselt den internen Zustand.
        - Felder: `workspaces: HashMap<WorkspaceId, Workspace>`, `active_workspace_id: Option<WorkspaceId>`, `ordered_workspace_ids: Vec<WorkspaceId>`, `next_workspace_number: u32` (für Standardnamen neuer Workspaces), `config_provider: Arc<dyn WorkspaceConfigProvider>`, `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`, `ensure_unique_window_assignment: bool`.
        - Die Option `ensure_unique_window_assignment` steuert, ob ein Fenster nur einem Arbeitsbereich gleichzeitig zugewiesen sein darf. Dies ist eine wichtige Policy-Entscheidung.
- **Events (`domain::workspaces::manager::events`)**:
    
    - `WorkspaceEvent`: Enum, das alle relevanten Änderungen an Arbeitsbereichen und Fensterzuweisungen repräsentiert.
        - Varianten: `WorkspaceCreated { workspace: Workspace }`, `WorkspaceDeleted { workspace_id: WorkspaceId, windows_moved_to: Option<WorkspaceId> }`, `ActiveWorkspaceChanged { old_id: Option<WorkspaceId>, new_id: WorkspaceId }`, `WorkspaceRenamed { workspace_id: WorkspaceId, data: WorkspaceRenamedData }`, `WorkspaceLayoutChanged { workspace_id: WorkspaceId, data: WorkspaceLayoutChangedData }`, `WindowAddedToWorkspace { workspace_id: WorkspaceId, data: WindowAddedToWorkspaceData }`, `WindowRemovedFromWorkspace { workspace_id: WorkspaceId, data: WindowRemovedFromWorkspaceData }`, `WorkspaceOrderChanged { ordered_ids: Vec<WorkspaceId> }`, `WorkspacesReloaded { new_workspaces: Vec<Workspace>, new_active_id: Option<WorkspaceId> }`, `WorkspacePersistentIdChanged { workspace_id: WorkspaceId, data: WorkspacePersistentIdChangedData }`, `WorkspaceIconChanged { workspace_id: WorkspaceId, data: WorkspaceIconChangedData }`, `WorkspaceAccentChanged { workspace_id: WorkspaceId, data: WorkspaceAccentChangedData }`.
- **Fehlerbehandlung (`domain::workspaces::manager::errors`)**:
    
    - `WorkspaceManagerError`: Enum für Fehler auf der Manager-Ebene.
        - Varianten: `WorkspaceNotFound { id: WorkspaceId }`, `CannotDeleteLastWorkspace`, `DeleteRequiresFallbackForWindows { num_windows: usize }`, `FallbackWorkspaceNotFound { id: WorkspaceId }`, `CoreError(#[from] WorkspaceCoreError)`, `AssignmentError(#[from] WindowAssignmentError)`, `ConfigError(#[from] WorkspaceConfigError)`, `SetActiveWorkspaceNotFound { id: WorkspaceId }`, `NoActiveWorkspace`, `DuplicatePersistentId { id: String }`, `Internal { message: String }`.

### 1.3. Modul: `domain::user_centric_services`

Dieses Modul bündelt Domänenlogik für Dienste, die direkt auf Benutzerinteraktionen und -bedürfnisse ausgerichtet sind, insbesondere KI-Interaktionen und Benachrichtigungen.

Referenzierte Dokumente: B3 Domänenschicht.md, B4 Domänenschicht.md

#### 1.3.1. Untermodul: `domain::user_centric_services::ai_interaction`

Verantwortlich für die Logik rund um KI-gestützte Interaktionen, Einwilligungsmanagement und die Verwaltung von KI-Modellprofilen.

- **Datenstrukturen (`domain::user_centric_services::ai_interaction::types`)**:
    
    - `AIDataCategory`: Enum zur Kategorisierung von Daten, die für KI-Interaktionen verwendet werden (z.B. `UserProfile`, `ApplicationUsage`, `FileSystemRead`).
    - `AIConsentStatus`: Enum für den Einwilligungsstatus (z.B. `Granted`, `Denied`, `PendingUserAction`). Die Variante `NotRequired` ist nützlich für Interaktionen, die keine explizite Einwilligung erfordern.
    - `AttachmentData`: Struktur für Anhänge an KI-Interaktionen (z.B. Dateien, Textauszüge). Die Felder `source_uri`, `content_base64`, `text_content` bieten Flexibilität für verschiedene Anhangstypen.
    - `InteractionParticipant`: Enum zur Kennzeichnung der Teilnehmer einer Interaktion (`User`, `Assistant`, `System`).
    - `InteractionHistoryEntry`: Repräsentiert einen einzelnen Eintrag im Interaktionsverlauf.
    - `AIInteractionContext`: Die zentrale Entität, die den gesamten Kontext einer KI-Interaktion kapselt, inklusive Verlauf, Anhängen und Einwilligungsstatus.
    - `AIConsentScope`: Enum zur Definition des Gültigkeitsbereichs einer Einwilligung (z.B. `SessionOnly`, `PersistentUntilRevoked`).
    - `AIConsent`: Struktur zur Speicherung detaillierter Einwilligungsinformationen.
    - `AIModelCapability`: Enum zur Beschreibung der Fähigkeiten eines KI-Modells (z.B. `TextGeneration`, `ImageAnalysis`).
    - `AIModelProfile`: Struktur zur Definition der Eigenschaften und Fähigkeiten eines KI-Modells. Das Feld `sort_order` ermöglicht eine benutzerdefinierte Sortierung der Modelle in der UI.
- **Fehlerbehandlung (`domain::user_centric_services::ai_interaction::errors`)**:
    
    - `AIInteractionError`: Enum für Fehler im KI-Interaktionsmodul (z.B. `ConsentCheckFailed`, `ApiKeyNotFoundInSecrets`, `ModelEndpointUnreachable`, `NoDefaultModelConfigured`, `CoreConfigError(#[from] novade_core::errors::CoreError)`).
- **Persistenz-Interfaces (`domain::user_centric_services::ai_interaction::persistence_iface`)**:
    
    - Traits `AIConsentProvider` und `AIModelProfileProvider`: Definieren Schnittstellen für das Laden und Speichern von Einwilligungen und Modellprofilen, was eine Entkopplung von der konkreten Speicherimplementierung ermöglicht.
- **API (`domain::user_centric_services::ai_interaction::service::AIInteractionLogicService`)**:
    
    - Trait mit Methoden wie `initiate_interaction`, `get_interaction_context`, `provide_consent`, `load_model_profiles`.
- **Implementierung `DefaultAIInteractionLogicService`**: Konkrete Implementierung des `AIInteractionLogicService`.
    
- **Events (`domain::user_centric_services::ai_interaction::events::AIInteractionEventEnum`)**:
    
    - Events wie `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`, `AIContextUpdatedEvent`, `AIModelProfilesReloadedEvent` zur Benachrichtigung anderer Systemteile über relevante Änderungen.

#### 1.3.2. Untermodul: `domain::user_centric_services::notifications_core`

Verantwortlich für die Kernlogik der Benachrichtigungsverwaltung, inklusive Erstellung, Speicherung, Filterung und Interaktion mit Benachrichtigungen.

- **Datenstrukturen (`domain::user_centric_services::notifications_core::types`)**:
    
    - `NotificationId`: Typalias für `uuid::Uuid`.
    - `NotificationUrgency`: Enum für die Dringlichkeit (`Low`, `Normal`, `Critical`).
    - `NotificationActionType`: Enum für Aktionstypen (`Callback`, `OpenLink`).
    - `NotificationAction`: Struktur für Aktionen, die einer Benachrichtigung zugeordnet sind.
    - `Notification`: Die Hauptentität, die eine Benachrichtigung repräsentiert. Enthält Felder wie `id`, `application_name`, `summary`, `body`, `actions`, `urgency`, `timestamp`, `is_read`, `is_dismissed`, `transient`, `category`, `hints`, `timeout_ms`.
    - `NotificationInput`: Eine Struktur zum Erstellen neuer Benachrichtigungen, ohne laufzeitgenerierte Felder wie `id` oder `timestamp`. Dies vereinfacht die API zum Posten von Benachrichtigungen.
    - `NotificationFilterCriteria`: Ein Enum für komplexe Filterkriterien, das logische UND/ODER/NICHT-Operationen sowie Filter auf Zeitbereiche unterstützt. Dies ermöglicht mächtige Abfragen des Benachrichtigungsverlaufs.
    - `NotificationSortOrder`: Enum für Sortierkriterien.
    - `NotificationStats`: Struktur zur Bereitstellung von Statistiken (z.B. `num_active`, `num_unread`), nützlich für UI-Anzeigen.
    - `DismissReason`: Enum zur Angabe des Grundes für das Schließen einer Benachrichtigung (z.B. `User`, `Timeout`), nützlich für Analysen und intelligente Benachrichtigungslogik.
- **Fehlerbehandlung (`domain::user_centric_services::notifications_core::errors`)**:
    
    - `NotificationError`: Enum für Fehler im Benachrichtigungssystem (z.B. `NotFound`, `InvalidData`, `HistoryFull`).
- **API (`domain::user_centric_services::notifications_core::service::NotificationService`)**:
    
    - Trait mit Methoden wie `post_notification(input: NotificationInput)`, `get_notification`, `mark_as_read`, `dismiss_notification`, `get_active_notifications`, `get_notification_history`, `set_do_not_disturb`, `invoke_action`, `get_stats`.
- **Implementierung `DefaultNotificationService`**: Konkrete Implementierung des `NotificationService`.
    
- **Events (`domain::user_centric_services::notifications_core::events::NotificationEventEnum`)**:
    
    - Events wie `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent` zur Benachrichtigung der UI und anderer Systemteile.

### 1.4. Modul: `domain::notifications_rules`

Ermöglicht eine regelbasierte Verarbeitung von eingehenden Benachrichtigungen, um deren Verhalten (z.B. Unterdrückung, Änderung der Dringlichkeit) basierend auf benutzerdefinierten Kriterien anzupassen.

Referenzierte Dokumente: B4 Domänenschicht.md

#### 1.4.1. Datenstrukturen (`domain::notifications_rules::types`)

- `RuleConditionValue`: Enum für die Werte in Regelbedingungen (z.B. `String(String)`, `Urgency(NotificationUrgency)`).
- `RuleConditionOperator`: Enum für Vergleichsoperatoren (z.B. `Is`, `Contains`, `MatchesRegex`).
- `RuleConditionField`: Enum zur Spezifizierung des Benachrichtigungsfeldes, auf das sich eine Bedingung bezieht (z.B. `ApplicationName`, `Summary`, `HintExists(String)`). Die Varianten `HintExists` und `HintValue` erlauben flexible Bedingungen basierend auf den `hints` einer Benachrichtigung.
- `SimpleRuleCondition`: Eine einfache Bedingung bestehend aus Feld, Operator und Wert.
- `RuleCondition`: Ein Enum, das komplexe, verschachtelte Bedingungen durch logische Operatoren (`And`, `Or`, `Not`) ermöglicht. Die Variante `SettingIsTrue(SettingPath)` erlaubt es, Regeln basierend auf globalen Einstellungen zu definieren, was eine starke Integration mit dem `GlobalSettingsService` ermöglicht.
- `RuleAction`: Enum für Aktionen, die ausgeführt werden, wenn eine Regel zutrifft (z.B. `SuppressNotification`, `SetUrgency`, `PlaySound`). Die Aktion `StopProcessingFurtherRules` bietet eine explizite Kontrolle über den Regelauswertungsfluss.
- `NotificationRule`: Repräsentiert eine einzelne Regel mit ID, Name, Bedingung, Aktionen, Aktivierungsstatus und Priorität. Die `Default`-Implementierung kann für das einfache Erstellen neuer Regeln in einer UI nützlich sein.
- `NotificationRuleSet`: Typalias für `Vec<NotificationRule>`. Die Reihenfolge in diesem Vektor ist relevant für die Regelauswertung, da Regeln typischerweise basierend auf ihrer Priorität und/oder Reihenfolge verarbeitet werden.

#### 1.4.2. Fehlerbehandlung (`domain::notifications_rules::errors`)

- `NotificationRulesError`: Enum für Fehler im Regelmodul (z.B. `InvalidRuleDefinition`, `ConditionEvaluationError`, `SettingsAccessError(#[from] GlobalSettingsError)`, `InvalidRegex`).

#### 1.4.3. API (`domain::notifications_rules::engine::NotificationRulesEngine`)

- Trait `NotificationRulesEngine`:
    - Methoden: `async fn reload_rules(&mut self)`, `async fn process_notification(&self, notification: Notification) -> Result<RuleProcessingResult, NotificationRulesError>`, `async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`, `async fn update_rules(&mut self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`.
- Implementierung `DefaultNotificationRulesEngine`: Hält einen `Arc<tokio::sync::RwLock<NotificationRuleSet>>`, einen `Arc<dyn NotificationRulesProvider>` und einen `Arc<dyn GlobalSettingsService>`. Die Verwendung von `RwLock` ermöglicht konkurrierenden Lesezugriff auf die Regeln, während Schreibzugriffe exklusiv sind.
- Enum `RuleProcessingResult`: Gibt das Ergebnis der Regelverarbeitung an.
    - Varianten: `Allow(Notification)` (die Benachrichtigung darf angezeigt werden, möglicherweise modifiziert), `Suppress { rule_id: Uuid }` (die Benachrichtigung soll unterdrückt werden).

#### 1.4.4. Persistenz (`domain::notifications_rules::persistence_iface`)

- Trait `NotificationRulesProvider`: Definiert die Schnittstelle zum Laden und Speichern von Regelwerken.
    - Methoden: `async fn load_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`, `async fn save_rules(&self, rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`.
- Implementierung `FilesystemNotificationRulesProvider`: Speichert Regeln im Dateisystem, typischerweise als JSON.

### 1.5. Modul: `domain::global_settings_and_state_management`

Verwaltet globale Desktop-Einstellungen und deren Persistenz. Dieses Modul ist zentral für die Konfiguration vieler Aspekte der Desktop-Umgebung.

Referenzierte Dokumente: B3 Domänenschicht.md, B4 Domänenschicht.md

#### 1.5.1. Datenstrukturen (`domain::global_settings_and_state_management::types`)

- `GlobalDesktopSettings`: Die Hauptstruktur, die alle globalen Einstellungen enthält.
    - Felder: `appearance: AppearanceSettings`, `workspace_config: WorkspaceSettings`, `input_behavior: InputBehaviorSettings`, `power_management_policy: PowerManagementPolicySettings`, `default_applications: DefaultApplicationsSettings`.
    - Alle Felder sind mit `#[serde(default)]` annotiert. Dies ist eine wichtige Designentscheidung, die die Robustheit des Systems gegenüber unvollständigen oder fehlerhaften Konfigurationsdateien erhöht, da für fehlende Abschnitte Standardwerte verwendet werden.
- Detaillierte Unterstrukturen (z.B. `AppearanceSettings`, `FontSettings`) und Enums (z.B. `ColorScheme`, `MouseAccelerationProfile`) sind wie in den referenzierten Dokumenten B3 und B4 definiert.
- **Validierung**: Jede Einstellungs-Unterstruktur implementiert eine Methode `fn validate(&self) -> Result<(), String>`. Die `GlobalDesktopSettings`-Struktur verfügt über eine Methode `validate_recursive()`, die die Validierung für alle Unterstrukturen aufruft und so die Datenintegrität sicherstellt.

#### 1.5.2. Pfade (`domain::global_settings_and_state_management::paths`)

- `SettingPath`: Ein hierarchischer Enum zur typsicheren Adressierung einzelner Einstellungen innerhalb der `GlobalDesktopSettings`-Struktur.
    - Implementiert `Display` (zur Konvertierung in einen lesbaren String-Pfad, z.B. für UI oder Logging) und `TryFrom<&str>` (zum Parsen eines String-Pfades zurück in den Enum).
    - Die Verwendung eines typsicheren Pfad-Enums anstelle von reinen Strings reduziert das Risiko von Tippfehlern und Laufzeitfehlern beim Zugriff auf Einstellungen.

#### 1.5.3. Fehlerbehandlung (`domain::global_settings_and_state_management::errors`)

- `GlobalSettingsError`: Enum für Fehler im Einstellungsmodul.
    - Varianten: `PathNotFound { path: SettingPath }`, `InvalidValueType { path: SettingPath, expected: String, found: String }`, `ValidationError { path: SettingPath, reason: String }`, `SerializationError { source: serde_json::Error }`, `DeserializationError { source: serde_json::Error }`, `PersistenceError(#[from] GlobalSettingsPersistenceError)`.
    - Die Verwendung von `SettingPath` in den Fehlervarianten ermöglicht eine präzise Fehlerlokalisierung.

#### 1.5.4. Persistenz-Interface (`domain::global_settings_and_state_management::persistence_iface`)

- Trait `SettingsPersistenceProvider`: Definiert die Schnittstelle zum Laden und Speichern der globalen Einstellungen.
    - Methoden: `async fn load_global_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsPersistenceError>`, `async fn save_global_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsPersistenceError>`.
    - Anmerkung: Die Verwendung eines spezifischen `GlobalSettingsPersistenceError` ermöglicht eine saubere `#[from]`-Konvertierung in `GlobalSettingsError::PersistenceError`.
- Implementierung `FilesystemSettingsProvider`: Nutzt `novade_core::config::ConfigServiceAsync` für Dateioperationen.

#### 1.5.5. API (`domain::global_settings_and_state_management::service::GlobalSettingsService`)

- Trait `GlobalSettingsService`: Die Hauptschnittstelle für den Zugriff auf und die Manipulation von globalen Einstellungen.
    - Methoden: `async fn load_settings(&self) -> Result<(), GlobalSettingsError>`, `async fn save_settings(&self) -> Result<(), GlobalSettingsError>`, `fn get_current_settings(&self) -> Arc<GlobalDesktopSettings>`, `async fn update_setting(&self, path: SettingPath, value: serde_json::Value) -> Result<(), GlobalSettingsError>`, `fn get_setting(&self, path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`, `async fn reset_to_defaults(&self) -> Result<(), GlobalSettingsError>`, `fn subscribe_to_setting_changes(&self) -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`.
- Implementierung `DefaultGlobalSettingsService`: Hält die Einstellungen in einem `Arc<tokio::sync::RwLock<GlobalDesktopSettings>>`, einen `Arc<dyn SettingsPersistenceProvider>` und einen `tokio::sync::broadcast::Sender` für Events.

#### 1.5.6. Events (`domain::global_settings_and_state_management::events`)

- `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`: Wird publiziert, wenn eine Einstellung geändert wird.
- `SettingsLoadedEvent { settings: Arc<GlobalDesktopSettings> }`: Wird publiziert, nachdem die Einstellungen erfolgreich geladen wurden.
- `SettingsSavedEvent`: Wird publiziert, nachdem die Einstellungen erfolgreich gespeichert wurden.

### 1.6. Modul: `domain::window_management_policy`

Dieses Modul definiert High-Level-Regeln und Richtlinien für die Fensterplatzierung, Tiling-Verhalten, Snapping und Fokusmanagement. Es entkoppelt die Policy-Entscheidungen von den Mechanismen der Fensterverwaltung, die im Compositor implementiert sind.

Referenzierte Dokumente: B3 Domänenschicht.md

#### 1.6.1. Datenstrukturen (`domain::window_management_policy::types`)

- `TilingMode`: Enum für verschiedene Tiling-Strategien (z.B. `Manual`, `Columns`, `Rows`, `Spiral`, `MaximizedFocused`).
- `GapSettings`: Definiert Abstände um Bildschirme und zwischen Fenstern.
    - Felder: `screen_outer_horizontal: u16`, `screen_outer_vertical: u16`, `window_inner: u16`.
- `WindowSnappingPolicy`: Konfiguriert das Snapping-Verhalten von Fenstern.
    - Felder: `snap_to_screen_edges: bool`, `snap_to_other_windows: bool`, `snap_to_workspace_gaps: bool`, `snap_distance_px: u16`.
- `WindowGroupingPolicy`: Einstellungen für manuelles Gruppieren von Fenstern.
    - Felder: `enable_manual_grouping: bool`.
- `NewWindowPlacementStrategy`: Enum für die Platzierungsstrategie neuer Fenster (z.B. `Smart`, `Center`, `Cascade`, `UnderMouse`).
- `FocusStealingPreventionLevel`: Enum zur Steuerung, wie aggressiv das System "Focus Stealing" verhindert (`None`, `Moderate`, `Strict`).
- `FocusPolicy`: Umfassende Einstellungen zum Fokusverhalten.
    - Felder: `focus_follows_mouse: bool`, `click_to_focus: bool`, `focus_new_windows_on_creation: bool`, `focus_new_windows_on_workspace_switch: bool`, `focus_stealing_prevention: FocusStealingPreventionLevel`.
- `WindowPolicyOverrides`: Optionale, fensterspezifische Überschreibungen globaler Policies (z.B. `preferred_tiling_mode`, `is_always_floating`).
- `WorkspaceWindowLayout`: Beschreibt das berechnete Layout aller Fenster auf einem Arbeitsbereich.
    - Felder: `window_geometries: HashMap<WindowIdentifier, novade_core::types::RectInt>`, `occupied_area: Option<novade_core::types::RectInt>`, `tiling_mode_applied: TilingMode`.
- `WindowLayoutInfo`: Enthält Informationen von einem Fenster, die für Layout-Berechnungen relevant sind.
    - Felder: `id: WindowIdentifier`, `requested_min_size: Option<novade_core::types::Size<u32>>`, `is_fullscreen_requested: bool`, `is_maximized_requested: bool`.

#### 1.6.2. Fehlerbehandlung (`domain::window_management_policy::errors`)

- `WindowPolicyError`: Enum für Fehler im Policy-Modul.
    - Varianten: `LayoutCalculationError { details: String }`, `InvalidPolicyConfiguration { setting_path: Option<String>, reason: String }`, `WindowNotFoundForPolicy { window_id: WindowIdentifier }`.

#### 1.6.3. API (`domain::window_management_policy::service::WindowManagementPolicyService`)

- Trait `WindowManagementPolicyService`: Definiert die Schnittstelle für Policy-Abfragen und Layout-Berechnungen.
    - Methoden: `async fn calculate_workspace_layout(&self, workspace_id: WorkspaceId, windows_info: Vec<WindowLayoutInfo>, available_area: novade_core::types::RectInt) -> Result<WorkspaceWindowLayout, WindowPolicyError>`, `async fn get_initial_window_geometry(&self, app_id: Option<ApplicationId>, title: Option<String>, requested_size: Option<novade_core::types::Size<u32>>, output_area: novade_core::types::RectInt) -> Result<novade_core::types::RectInt, WindowPolicyError>`, `async fn calculate_snap_target(&self, window_id: WindowIdentifier, current_geometry: novade_core::types::RectInt, workspace_layout: &WorkspaceWindowLayout, output_area: novade_core::types::RectInt) -> Option<novade_core::types::RectInt>`, `async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>`, `async fn get_effective_gap_settings_for_workspace(&self, workspace_id: WorkspaceId) -> Result<GapSettings, WindowPolicyError>`, `async fn get_effective_snapping_policy(&self) -> Result<WindowSnappingPolicy, WindowPolicyError>`, `async fn get_effective_focus_policy(&self) -> Result<FocusPolicy, WindowPolicyError>`, `async fn get_effective_new_window_placement_strategy(&self) -> Result<NewWindowPlacementStrategy, WindowPolicyError>`.
- Implementierung `DefaultWindowManagementPolicyService`: Hält einen `Arc<dyn GlobalSettingsService>`, um auf die globalen Policy-Einstellungen zuzugreifen. Diese Abhängigkeit ermöglicht dynamische Policy-Änderungen. Die Komplexität der `calculate_workspace_layout`-Funktion erfordert sorgfältige Implementierung und gründliche Tests, insbesondere im Hinblick auf verschiedene Tiling-Modi und Fenster-Overrides.

### 1.7. Modul: `domain::common_events`

Definiert Domänen-übergreifende Events, die von verschiedenen Modulen publiziert oder abonniert werden können.

Referenzierte Dokumente: B3 Domänenschicht.md

#### 1.7.1. Datenstrukturen (`domain::common_events::events`)

- `UserActivityType`: Enum zur Klassifizierung von Benutzeraktivitäten.
    - Varianten: `MouseMoved`, `MouseClicked`, `MouseWheelScrolled`, `KeyPressed`, `TouchInteraction`, `WorkspaceSwitched`, `ApplicationFocused`, `WindowOpened`, `WindowClosed`. Die Granularität dieser Typen ist für die Implementierung von Features wie Inaktivitäts-Timer oder Nutzungsstatistiken relevant.
- `UserActivityDetectedEvent`: Event, das bei Erkennung einer Benutzeraktivität ausgelöst wird.
    - Felder: `event_id: Uuid`, `timestamp: DateTime<Utc>`, `activity_type: UserActivityType`, `current_session_state: UserSessionState`, `active_application_id: Option<ApplicationId>`, `active_workspace_id: Option<WorkspaceId>`.
- `ShutdownReason`: Enum, das den Grund für ein Herunterfahren des Systems angibt.
    - Varianten: `UserRequest`, `PowerButtonPress`, `LowBattery`, `SystemUpdate`, `ApplicationRequest`, `OsError`, `Unknown`.
- `SystemShutdownInitiatedEvent`: Event, das ausgelöst wird, wenn ein System-Shutdown initiiert wird.
    - Felder: `event_id: Uuid`, `timestamp: DateTime<Utc>`, `reason: ShutdownReason`, `is_reboot: bool`, `delay_seconds: Option<u32>`, `message: Option<String>`.

### 1.8. Modul: `domain::shared_types`

Stellt wiederverwendbare, domänenspezifische Typen bereit, die in mehreren Domänenmodulen verwendet werden, um Konsistenz zu fördern und Duplizierung zu vermeiden.

Referenzierte Dokumente: B3 Domänenschicht.md

#### 1.8.1. Datenstrukturen (`domain::shared_types::types`)

- `ApplicationId`: Wrapper für `String` zur eindeutigen Identifizierung von Anwendungen.
- `UserSessionState`: Enum zur Repräsentation des Zustands der Benutzersitzung.
    - Varianten: `Active`, `Locked`, `Idle`.
- `ResourceIdentifier`: Eine generische Struktur zur Identifizierung von Ressourcen innerhalb des Systems.
    - Felder: `r#type: String` (z.B. "window", "workspace"), `id: String`, `label: Option<String>`.

Die klare Definition dieser gemeinsam genutzten Typen ist grundlegend für die Interoperabilität und das korrekte Zusammenspiel der verschiedenen Domänenmodule.

**Tabelle 1: Domain Layer Modules Overview**

|   |   |   |
|---|---|---|
|**Modul-Pfad**|**Kernverantwortlichkeit**|**Wichtige Services/Entitäten**|
|`domain::theming`|Verwaltet alle Aspekte des visuellen Stylings, der Theme-Anwendung und der Token-Auflösung.|`ThemingEngine`, `ThemeDefinition`, `AppliedThemeState`, `TokenIdentifier`, `TokenValue`|
|`domain::workspaces`|Logik und Verwaltung von Arbeitsbereichen ("Spaces"), inklusive Fensterzuweisung und Persistenz.|`WorkspaceManagerService`, `Workspace`, `WorkspaceId`, `WindowIdentifier`|
|`domain::user_centric_services::ai_interaction`|Handhabt KI-gestützte Interaktionen, Einwilligungsmanagement und KI-Modellprofile.|`AIInteractionLogicService`, `AIInteractionContext`, `AIConsent`, `AIModelProfile`|
|`domain::user_centric_services::notifications_core`|Kernlogik für das Erstellen, Speichern, Filtern und Interagieren mit Benachrichtigungen.|`NotificationService`, `Notification`, `NotificationInput`, `NotificationFilterCriteria`|
|`domain::notifications_rules`|Ermöglicht regelbasierte Verarbeitung und Modifikation von Benachrichtigungen.|`NotificationRulesEngine`, `NotificationRule`, `RuleCondition`, `RuleAction`|
|`domain::global_settings_and_state_management`|Verwaltung globaler Desktop-Einstellungen, deren Persistenz und Validierung.|`GlobalSettingsService`, `GlobalDesktopSettings`, `SettingPath`|
|`domain::window_management_policy`|Definiert High-Level-Regeln für Fensterplatzierung, Tiling, Snapping und Fokus.|`WindowManagementPolicyService`, `TilingMode`, `FocusPolicy`, `WorkspaceWindowLayout`|
|`domain::common_events`|Definiert Domänen-übergreifende Events wie Benutzeraktivität oder System-Shutdown.|`UserActivityDetectedEvent`, `SystemShutdownInitiatedEvent`|
|`domain::shared_types`|Stellt wiederverwendbare domänenspezifische Typen bereit.|`ApplicationId`, `UserSessionState`, `ResourceIdentifier`|

## 2. Wayland/Smithay-Integration (Systemschicht-Perspektive)

Dieser Abschnitt beschreibt, wie die Systemschicht, insbesondere der Wayland-Compositor, der mit dem Smithay-Toolkit implementiert wird, mit Wayland-Protokollen umgeht und mit der oben definierten Domänenschicht interagiert. Die korrekte Integration ist entscheidend für die Funktionalität und Stabilität des Desktops.

Referenzierte Dokumente: C1 System Implementierungsplan.md bis C4 Systemschicht.md, 3. System-Details.md.

### 2.1. Kern-Compositor-Struktur (`system::compositor::core::state::DesktopState`)

`DesktopState` ist die zentrale Zustandsstruktur des Compositors. Sie implementiert die verschiedenen Handler-Traits von Smithay und hält sowohl Smithay-spezifische Zustände als auch Handles zu den Domänendiensten. Diese Struktur ist das Herzstück der Compositor-Implementierung und agiert als zentraler Dispatcher und State-Manager für Wayland-bezogene Operationen.1 Die Verwendung einer zentralen, veränderbaren Zustandsstruktur, die an Callbacks übergeben wird, ist ein von Smithay empfohlenes Muster, das durch `calloop` ermöglicht wird und die Notwendigkeit komplexer Synchronisationsmechanismen reduziert.2

- **Wichtige Felder** (Auswahl, basierend auf typischer Smithay-Architektur):
    - `display_handle: DisplayHandle`: Das zentrale Handle zur Wayland-Display-Instanz, notwendig für die Erstellung von Globals und die Client-Kommunikation.5
    - `loop_handle: LoopHandle<'static, Self>`: Handle zum `calloop`-Event-Loop, der den Compositor antreibt.
    - `clock: Clock<u64>`: Eine Zeitquelle für den Compositor.
    - `compositor_state: CompositorState`: Verwaltet `wl_compositor`- und `wl_subcompositor`-bezogene Zustände.6
    - `shm_state: ShmState`: Verwaltet `wl_shm`-bezogene Zustände für Shared Memory Buffer.8
    - `xdg_shell_state: XdgShellState`: Verwaltet Zustände für das `xdg_shell`-Protokoll (Fenster, Popups).9
    - `output_manager_state: OutputManagerState`: Verwaltet `wl_output`- und `zxdg_output_v1`-Zustände.16
    - `seat_state: SeatState<Self>`: Verwaltet `wl_seat`-Zustände und Eingabefähigkeiten.9
    - `seat: Seat<Self>`: Die konkrete Seat-Instanz.
    - `data_device_state: DataDeviceState`: Verwaltet Zustände für `wl_data_device` (Clipboard, Drag & Drop).8
    - `space: Space<WindowElement>`: Smithays 2D-Raum zur Verwaltung von Fenstern, deren Stapelreihenfolge und zum Rendern.1 `WindowElement` ist dabei ein Enum, das verschiedene Fenstertypen wie native Wayland-Fenster (`Window`), X11-Fenster (`X11Surface`) und Layer-Shell-Oberflächen (`LayerSurface`) kapselt.
    - `windows: HashMap<DomainWindowIdentifier, Arc<WindowElement>>`: Ein Mapping von den abstrakten `DomainWindowIdentifier` der Domänenschicht zu den konkreten `WindowElement`-Instanzen des Compositors. Dies ist eine entscheidende Brücke zwischen Domänen- und Systemschicht.
    - Domänen-Service-Handles: `Arc<dyn WindowManagementPolicyService>`, `Arc<dyn WorkspaceManagerService>`, `Arc<dyn GlobalSettingsService>`. Diese `Arc`-Handles ermöglichen den Zugriff auf die Domänenlogik aus den Wayland-Handlern heraus. Die Thread-Sicherheit dieser Interaktion muss gewährleistet sein, insbesondere da Domänendienste asynchron sind, während Wayland-Handler typischerweise synchron im `calloop`-Thread ausgeführt werden.33
    - `event_bridge: Arc<SystemEventBridge>`: Ein Mechanismus zur internen Event-Kommunikation innerhalb der Systemschicht und potenziell zur Weiterleitung von Systemereignissen an die Domänenschicht.

Obwohl `DesktopState` viele Verantwortlichkeiten bündelt, was Bedenken hinsichtlich eines "God Object" 29 aufwerfen könnte, ist dieses Muster im Kontext von Smithay und `calloop` üblich und wird durch die Verwendung von Delegate-Makros handhabbar gemacht. Diese Makros leiten die Protokollbehandlung an spezifische Zustands-Subobjekte und deren Handler weiter, anstatt die gesamte Logik in `DesktopState` selbst zu implementieren.1

### 2.2. Wayland-Protokoll-Implementierungen

Die `DesktopState`-Struktur implementiert verschiedene Handler-Traits von Smithay, um die Wayland-Protokolle zu bedienen.

- **`wl_compositor`, `wl_subcompositor`**:
    
    - Gehandhabt durch `CompositorState` und die Implementierung von `CompositorHandler` in `DesktopState`.4
    - `CompositorHandler::commit(surface: &WlSurface)`: Diese Methode wird bei jedem `wl_surface.commit` eines Clients aufgerufen. Sie ist verantwortlich für:
        - Aktualisierung von `SurfaceData` (Puffer, Schadensregionen (Damage)).
        - Benachrichtigung von `domain::window_management_policy` oder `domain::workspaces` bei relevanten Änderungen (z.B. könnte eine neue Puffergröße das Layout beeinflussen). Diese Interaktion ist ein Beispiel für die Kommunikation von der Systemschicht zur Domänenschicht für Policy-Entscheidungen.
        - Markierung der Oberfläche für eine Neuzeichnung durch den Renderer.
- **`wl_shm`**:
    
    - Gehandhabt durch `ShmState` und die Implementierung von `ShmHandler` in `DesktopState`.4
    - `BufferHandler::buffer_destroyed(buffer: &WlBuffer)`: Informiert den Renderer, dass die mit diesem Puffer verbundenen Ressourcen freigegeben werden können. Dies ist wichtig für das Speichermanagement.
- **`xdg_shell` (`xdg_wm_base`, `xdg_surface`, `xdg_toplevel`, `xdg_popup`)**:
    
    - Gehandhabt durch `XdgShellState` und die Implementierung von `XdgShellHandler` in `DesktopState`.4
    - `XdgShellHandler::new_toplevel(surface: ToplevelSurface)`: Ein kritischer Integrationspunkt.
        1. Erstellt ein `WindowElement::Wayland(Window::new(ToplevelKind::Xdg(surface)))`. Das `Window` hier ist eine Smithay-Abstraktion.29
        2. Generiert einen `DomainWindowIdentifier` für die Domänenschicht.
        3. Ruft `domain::window_management_policy::get_initial_window_geometry()` auf, um die initiale Position und Größe des Fensters gemäß den globalen und anwendungsspezifischen Richtlinien zu bestimmen.
        4. Ruft `domain::workspaces::assign_window_to_active_workspace()` auf, um das neue Fenster dem aktuell aktiven Arbeitsbereich zuzuordnen.
        5. Konfiguriert und mappt das Fenster im `Space`.
    - `XdgShellHandler::map_toplevel(surface: &ToplevelSurface)`: Informiert `domain::workspaces`, dass das Fenster nun sichtbar (gemappt) ist.
    - Client-Anfragen wie `set_title`, `set_app_id`, `set_maximized`, `move`, `resize` werden an `domain::window_management_policy` delegiert. Die Domänenschicht entscheidet über die Policy-konforme Reaktion. Das Ergebnis dieser Entscheidung (z.B. neue Geometrie, neuer Zustand) wird dann vom Compositor auf das `ToplevelSurface` angewendet, typischerweise durch Senden eines `configure`-Events an den Client (`toplevel_surface.send_configure(...)`).
    - **Domäne -> System für Layout**: `domain::window_management_policy` gibt eine `WorkspaceWindowLayout`-Struktur zurück. Ein systemseitiger Mechanismus (z.B. `system::window_mechanics::apply_workspace_layout`) iteriert über die `window_geometries` dieser Struktur und ruft `toplevel_surface.send_configure(...)` für jedes betroffene Fenster auf, um die vom Domänenmodul berechneten Größen und Positionen anzuwenden.
    - Die Synchronisation von Zuständen wie "maximiert" oder "aktiv" zwischen `XdgToplevelSurfaceData` und einer internen `ManagedWindow`-Repräsentation erfolgt über den Configure-Ack-Mechanismus.1 Der Compositor sendet einen `configure`-Event mit dem neuen Zustand, und der Client muss diesen mit `ack_configure` bestätigen, bevor der Zustand als angewendet gilt.
- **`wlr-layer-shell-unstable-v1`**:
    
    - Gehandhabt durch `WlrLayerShellState` und die Implementierung von `LayerShellHandler` in `DesktopState`.4
    - `LayerShellHandler::new_layer_surface(surface: LayerSurface,...)`: Erstellt ein `WindowElement::Layer(surface)`. Informiert die Domänenschicht (ggf. ein spezifischer Service für Shell-Elemente wie Panels oder Hintergrundbilder). Die Platzierung im `Space` erfolgt gemäß den Layer-Shell-Regeln (Layer, Anchor, Exclusive Zone). Die Interaktion mit `PopupManager` und die Handhabung von `exclusive_zone` sind hier relevant.53
- **`wl_output` / `xdg-output-unstable-v1`**:
    
    - Gehandhabt durch `OutputManagerState` und die Implementierung von `OutputHandler` in `DesktopState`.2
    - Änderungen an Outputs (Hotplug, Modusänderung) werden vom `OutputHandler` verarbeitet.
    - Diese Änderungen werden an `domain::global_settings_and_state_management` gemeldet (z.B. um Persistenz anzustoßen oder Display-Profile zu aktualisieren) und an `domain::workspaces` (da Änderungen der Output-Konfiguration das Fensterlayout beeinflussen können).
    - Die Implementierung von `zwlr_output_manager_v1` (Teil von `wlr-output-management-unstable-v1` 2) in `system::outputs::output_manager` (oder einer ähnlichen Struktur) würde die `apply`-Methode dieses Protokolls implementieren. Bei einem Aufruf von `apply` wird `Output::change_current_state()` aufgerufen. Die Domänenschicht wird über ein `OutputConfigurationChangedEvent` informiert. Die korrekte Handhabung von Serials ist hierbei entscheidend für die atomare Anwendung von Konfigurationen.61
- **`wl_seat` / Eingabeprotokolle (`wl_keyboard`, `wl_pointer`, `wl_touch`)**:
    
    - Gehandhabt durch `SeatState`, `SeatHandler`, `KeyboardHandle`, `PointerHandle`, `TouchHandle`.4
    - Eingabe-Events von `system::input` (typischerweise `libinput` 81) werden verarbeitet.
    - `SeatHandler::focus_changed(seat: &Seat<Self>, focused: Option<&WlSurface>)`: Identifiziert den `DomainWindowIdentifier` für die fokussierte Oberfläche. Informiert `domain::window_management_policy` oder `domain::workspaces` über die Fokusänderung. Dies ist ein kritischer Punkt für die Fokusverwaltung.84
    - `KeyboardHandle::input(keycode, state,...)`: Sendet `wl_keyboard.key`-Events an den fokussierten Client.
    - `PointerHandle::motion(...)`: Sendet `wl_pointer.motion`, `enter`, `leave`-Events.
    - **Domäne -> System für Fokus**: `domain::window_management_policy` kann einen Fokuswechsel anstoßen (z.B. als Reaktion auf eine Policy oder einen Benutzerbefehl). Ein systemseitiger Mechanismus (z.B. `system::window_mechanics::set_application_focus`) ruft dann `keyboard.set_focus(...)` auf, um den Fokus im Wayland-Seat zu setzen.

### 2.3. Smithay-Typen und ihre Verwendung

Die Integration mit Smithay erfordert die korrekte Verwendung und Erweiterung seiner Kern-Typen.

- **`DisplayHandle`**: Das zentrale Handle zur Wayland-Display-Instanz. Wird für die Erstellung von Globals, Client-Kommunikation etc. verwendet.5
    
- **`CompositorState`**: Verwaltet `wl_compositor` und `wl_subcompositor` Globals und Client-Zustände.6
    
- **`ShmState`**: Verwaltet das `wl_shm` Global und SHM-Puffer.
    
- **`XdgShellState`**: Verwaltet das `xdg_wm_base` Global und XDG-Oberflächen (Toplevels, Popups).9
    
- **`OutputManagerState`**: Verwaltet `wl_output` und `zxdg_output_manager_v1` Globals.16
    
- **`SeatState<DesktopState>` / `Seat<DesktopState>`**: Verwalten `wl_seat` und die Eingabefähigkeiten (Tastatur, Maus, Touch). `SeatHandler` wird von `DesktopState` implementiert.9
    
- **`KeyboardHandle`, `PointerHandle`, `TouchHandle`**: Abstraktionen für die Interaktion mit spezifischen Eingabegeräten des Seats.
    
- **`Space<WindowElement>`**: Smithays 2D-Raum zur Verwaltung von Fenstern, deren Stapelreihenfolge und zum Rendern.1 `WindowElement` muss den `smithay::desktop::Window` Trait implementieren.29
    
- **`SurfaceData`** (aus `smithay::wayland::compositor`): Wird an `WlSurface`-Instanzen angehängt und speichert Pufferinformationen, die zugewiesene Rolle, Schadensregionen (Damage) etc..7 NovaDE wird dies erweitern (z.B. über `UserDataMap` oder eine dedizierte Erweiterungsstruktur wie `SurfaceDataExt`), um anwendungsspezifische Daten wie `DomainWindowIdentifier` und Renderer-spezifische Textur-Handles zu speichern. Die Verwaltung von doppelt gepuffertem Zustand und Commit-Hooks (Pre/Post) ist ein Kernaspekt von `SurfaceData`.4
    
- **`ClientData`** (aus `smithay::reexports::wayland_server::backend`): Wird an `Client`-Instanzen angehängt und kann Client-spezifische Zustände speichern (z.B. `CompositorClientState`, `XdgWmBaseClientData`).
    
- **Änderungen an Smithay-Typen und deren Konsequenzen**:
    
    - Das direkte Ändern von Smithay-Typen ist in der Regel nicht vorgesehen, da sie Teil der Bibliothek sind. Die Erweiterung erfolgt primär durch die Verwendung von `UserDataMap` an Objekten wie `WlSurface` oder `Client` oder durch die Implementierung der von Smithay bereitgestellten Handler-Traits.
    - Wenn Smithay eine neue Version mit geänderten Typen oder Trait-Signaturen veröffentlicht, müssen die Handler-Implementierungen und die Nutzung dieser Typen in NovaDE entsprechend angepasst werden. Dies erfordert sorgfältige Migration und umfassende Tests, um die Kompatibilität und korrekte Funktionalität sicherzustellen.
    - Das `UserDataMap`-Muster ist der primäre Mechanismus, um anwendungsspezifische Daten mit Smithay-Objekten zu assoziieren, ohne die Typen selbst modifizieren zu müssen. Dies ist entscheidend für die Aufrechterhaltung einer sauberen Trennung zwischen der Bibliothekslogik und der anwendungsspezifischen Logik des Compositors.

### 2.4. Kommunikation Domäne <-> Compositor

Die Kommunikation zwischen der Domänenschicht und der Systemschicht (Compositor) ist bidirektional und erfolgt über definierte Schnittstellen, primär Events und Service-Aufrufe.

- **Compositor (System) -> Domäne**:
    
    - **Events**: Der Compositor generiert Systemereignisse, die für die Domänenschicht relevant sind. Diese werden typischerweise über einen `SystemEventBridge` oder einen ähnlichen Mechanismus an die Domänenschicht weitergeleitet.
        - Neues Fenster (z.B. in `XdgShellHandler::new_toplevel`): Sendet ein `WindowCreatedEvent { domain_id, initial_geometry, app_id, title }` an `domain::workspaces::manager` oder einen allgemeinen Event-Bus.
        - Fenster geschlossen (z.B. in `XdgShellHandler::toplevel_destroyed`): Sendet ein `WindowClosedEvent { domain_id }`.
        - Fokusänderung durch Benutzer (z.B. in `SeatHandler::focus_changed`): Sendet ein `FocusChangedEvent { new_focus_domain_id, old_focus_domain_id }`.
        - Benutzereingabe für spezielle Funktionen (z.B. Befehlspalette): Kann ein spezifisches Event senden oder direkt einen Domänendienst aufrufen.
        - Output-Änderung (z.B. in `OutputHandler`): Sendet ein `OutputConfigurationChangedEvent {... }`.
    - **Service-Aufrufe (indirekt)**: Bei bestimmten Aktionen kann der Compositor Domänenlogik benötigen, z.B. um die Standardplatzierung für ein neues Fenster zu erfragen (`domain::window_management_policy::get_initial_window_geometry`).
- **Domäne -> Compositor (System)**:
    
    - **Service-Aufrufe**: Die Domänenschicht kann Aktionen im Compositor auslösen, indem sie Methoden auf Schnittstellen aufruft, die von der Systemschicht bereitgestellt werden.
        - `domain::window_management_policy` gibt eine `WorkspaceWindowLayout`-Struktur an einen systemseitigen Mechanismus (z.B. `system::window_mechanics`).
        - `system::window_mechanics::apply_workspace_layout` ruft dann spezifische Smithay-Funktionen auf, z.B. `toplevel_surface.send_configure(...)` oder `space.map_window(...)`.
        - `domain::workspaces::manager` ruft z.B. `system::window_mechanics::set_application_focus` auf, was intern `keyboard.set_focus(...)` verwendet.
    - Die Systemschicht stellt hierfür klar definierte Traits bereit (z.B. eine `WindowManipulationApi`), die von Domänendiensten genutzt werden können. Diese API-Aufrufe werden dann in spezifische Smithay-Operationen übersetzt, um die gewünschten Aktionen im Compositor auszuführen.

Diese klare Trennung der Kommunikationspfade und -mechanismen ist entscheidend für die Entkopplung der Schichten und die Aufrechterhaltung einer sauberen Architektur.

## 3. Protokoll-Implementierungen (D-Bus, XDG Desktop Portals, MCP)

Die Systemschicht ist verantwortlich für die Implementierung von Clients und Servern für verschiedene externe Protokolle und deren Integration mit der Domänenschicht, um eine umfassende Desktop-Funktionalität zu gewährleisten.

### 3.1. D-Bus (`zbus`)

Die D-Bus-Integration erfolgt über die `zbus`-Bibliothek, die moderne asynchrone D-Bus-Kommunikation in Rust ermöglicht.87 Die Wahl von `zbus` gegenüber älteren Alternativen wie `dbus-rs` ist auf dessen asynchrone Natur und bessere Integration in moderne Rust-Ökosysteme zurückzuführen.

- **Module in `system::dbus_interfaces`**:
    
    - `connection_manager`: Stellt einen `DBusConnectionManager` bereit, der den Zugriff auf den Session-Bus (`session_bus()`) und den System-Bus (`system_bus()`) kapselt und vereinfacht.89
    - **Clients** (z.B. `upower_client`, `logind_client`, `network_manager_client`, `secrets_service_client`, `policykit_client`):
        - Definieren `zbus::proxy`-Strukturen für die jeweiligen D-Bus-Interfaces der externen Dienste (z.B. `org.freedesktop.UPower` 90, `org.freedesktop.NetworkManager` 91).
        - Implementieren einen Service-Wrapper (z.B. `UPowerClientService`), der den Proxy kapselt und eine saubere API für die Domänenschicht bereitstellt.
        - Abonnieren relevante D-Bus-Signale (z.B. `PropertiesChanged` von UPower) und konvertieren diese entweder in interne `SystemLayerEvents` (die über den `SystemEventBridge` publiziert werden) oder rufen direkt Methoden von Domänendiensten auf.
        - Bieten asynchrone Methoden für die Domänenschicht, um D-Bus-Methoden aufzurufen (z.B. `NetworkManager.ActivateConnection`) oder Eigenschaften abzufragen (z.B. `UPower.OnBattery`).
    - **Server** (z.B. `notifications_server`):
        - Implementiert das `org.freedesktop.Notifications`-Interface unter Verwendung des `#[dbus_interface]`-Makros von `zbus`.94
        - Ruft Methoden des `domain::user_centric_services::NotificationService` auf, um Aktionen wie das Anzeigen oder Schließen von Benachrichtigungen auszuführen.
        - Abonniert Domänen-Events (z.B. `NotificationDismissedEvent`, `NotificationActionInvokedEvent` aus `domain::user_centric_services::notifications_core::events`) und sendet entsprechende D-Bus-Signale (`NotificationClosed`, `ActionInvoked`) an D-Bus-Clients.
        - Verwaltet ein ID-Mapping zwischen den `u32`-basierten D-Bus-Benachrichtigungs-IDs und den `Uuid`-basierten internen `NotificationId`s der Domänenschicht.
- **Integration mit der Domäne**:
    
    - Domänendienste (z.B. `PowerManagementPolicy` in `domain::global_settings_and_state_management`) abonnieren die von den D-Bus-Client-Wrappern publizierten `SystemLayerEvents` oder halten direkte Handles zu den Client-Services, um auf Systemänderungen zu reagieren oder Aktionen auszulösen.
    - Domänendienste (z.B. `NotificationService`) werden von den D-Bus-Server-Implementierungen aufgerufen, um Anfragen von externen Anwendungen zu bedienen.

### 3.2. XDG Desktop Portals (`system::portals`)

Implementiert die Backend-Logik für ausgewählte XDG Desktop Portals, um sandboxed Anwendungen den Zugriff auf Systemressourcen auf eine kontrollierte Weise zu ermöglichen. Die `ashpd`-Bibliothek 96 dient hierbei als Referenz oder kann direkt genutzt werden, falls sie Backend-Logik für Portalserver bereitstellt; andernfalls erfolgt eine direkte `zbus`-Implementierung der Portal-D-Bus-Interfaces.

- Definiert einen Trait `SystemPortalInterface` (oder ähnlich benannt), den die D-Bus-Objekte der Portale (die in einem separaten Prozess oder Dienst laufen könnten) aufrufen.
- **`FileChooser` Portal (`org.freedesktop.portal.FileChooser`)** 96:
    - Empfängt `OpenFile`- oder `SaveFile`-Anfragen vom Portal-D-Bus-Objekt. Diese Anfragen enthalten typischerweise einen `WindowIdentifier`, um den Dialog korrekt dem anfragenden Anwendungsfenster zuzuordnen.97
    - Sendet einen Befehl an die UI-Schicht (über den `SystemEventBridge` oder eine dedizierte Schnittstelle), um einen nativen Dateidialog (z.B. mit GTK) anzuzeigen.
    - Empfängt das Ergebnis des Dateidialogs von der UI-Schicht und sendet es über D-Bus an den anfragenden Client zurück.
- **`Screenshot` Portal (`org.freedesktop.portal.Screenshot`)**:
    - Empfängt `Screenshot`- oder `PickColor`-Anfragen.
    - Interagiert mit `system::compositor::screencopy` (für Screenshots) oder einer spezifischen Compositor-Funktion (für die Farbpipette), um die angeforderte Aktion auszuführen.
    - Sendet das Ergebnis (Bilddaten oder Farbwert) über D-Bus zurück.

### 3.3. Model Context Protocol (MCP) (`system::mcp_client`)

Implementiert die Client-Seite des Model Context Protocol für die Interaktion mit KI-Modellen oder -Diensten, die dieses Protokoll verwenden. Die `mcp_client_rs`-Bibliothek 101 wird hierfür als Grundlage genutzt.

- Implementiert den Trait `SystemMcpService` aus der Domänenschicht.
- Nutzt `mcp_client_rs::McpClient` für die eigentliche Protokollkommunikation.
- **`connection_manager`**:
    - Verwaltet Verbindungen zu MCP-Servern, basierend auf `McpServerConfig`-Strukturen.
    - Kann lokale MCP-Server-Prozesse starten und deren `stdin`/`stdout` für die IPC verwalten, typischerweise unter Verwendung von `tokio::process::Command`.104
    - Holt API-Schlüssel für die Authentifizierung bei MCP-Servern über den `secrets_service_client` (siehe D-Bus-Integration).
- **`service::DefaultSystemMcpService`**:
    - Empfängt Anfragen (z.B. `CallToolParams`) vom `domain::user_centric_services::AIInteractionLogicService`.
    - Sendet diese Anfragen über `McpClient::send_request_json` an den entsprechenden MCP-Server.
    - Implementiert Timeout-Mechanismen für MCP-Anfragen.
    - Lauscht auf `McpClient::receive_message()` für Antworten und serverseitige Benachrichtigungen (Notifications).
    - Konvertiert MCP-Antworten und -Notifications in `McpClientSystemEvents` und publiziert diese über den `SystemEventBridge`. Der `AIInteractionLogicService` abonniert diese Events, um auf Ergebnisse oder serverseitige Updates zu reagieren. Die robuste Handhabung des Notification-Streams, inklusive Fehlerbehandlung und Deserialisierung, ist hierbei entscheidend.103

## 4. Implementierbare Lösungen

Dieser Abschnitt skizziert konkrete Implementierungsansätze für ausgewählte Komponenten und Interaktionen, um die Spezifikationen greifbarer zu machen.

### 4.1. Code-Skizzen (Englisch)

Die folgenden Code-Skizzen dienen zur Veranschaulichung der Struktur und Interaktion einiger Kernkomponenten. Sie sind nicht als vollständig kompilierbarer oder fehlerfreier Code gedacht, sondern sollen die in den Spezifikationen definierten Typen und Methoden im Kontext zeigen.

Hinweis zur Verwendung von Arc<Mutex<T>> und block_on in Handlern:

Die direkte Verwendung von Arc<Mutex<DesktopState>> und dessen Weitergabe an tokio::spawn muss sorgfältig auf Thread-Sicherheit und Deadlocks geprüft werden; oft sind spezifische Daten zu extrahieren oder Kanäle für die Kommunikation mit dem Haupt-Compositor-Thread zu verwenden.33 block_on in synchronen Smithay-Handlern zur Ausführung asynchroner Domänenlogik ist generell zu vermeiden. Stattdessen sollten Kommunikationsmuster wie Kanäle zwischen dem synchronen Handler-Thread und einem Tokio-Runtime-Thread verwendet werden, um Ergebnisse asynchroner Operationen zurück an den Handler zu leiten.107

Rust

```
// ==== Domain Layer: domain::workspaces::manager ====
// #[async_trait]
// pub trait WorkspaceManagerService: Send + Sync {
//     async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;
//     //... other methods
// }

// pub struct DefaultWorkspaceManager {
//     internal: Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>,
// }

// impl WorkspaceManagerInternalState {
//     async fn set_active_workspace_impl(&mut self, id: WorkspaceId, current_active: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError> {
//         if!self.workspaces.contains_key(&id) {
//             return Err(WorkspaceManagerError::SetActiveWorkspaceNotFound(id));
//         }
//         if self.active_workspace_id == Some(id) {
//             return Ok(());
//         }
//         let old_id = self.active_workspace_id.take();
//         self.active_workspace_id = Some(id);
//         self.ordered_workspace_ids.retain(|ws_id| *ws_id!= id);
//         self.ordered_workspace_ids.insert(0, id); // Example: move to front
//         let event = WorkspaceEvent::ActiveWorkspaceChanged { old_id, new_id: id };
//         if self.event_publisher.send(event).is_err() {
//             tracing::warn!("No active subscribers for ActiveWorkspaceChanged event.");
//         }
//         // self.save_configuration_internal_locked().await?; // Persist change
//         Ok(())
//     }
// }

// ==== System Layer: system::compositor::core::state::DesktopState ====
// impl SeatHandler for DesktopState {
//     type KeyboardFocus = WlSurface;
//     type PointerFocus = WlSurface;
//     type TouchFocus = WlSurface;

//     fn seat_state(&mut self) -> &mut SeatState<Self> {
//         &mut self.seat_state
//     }

//     fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&WlSurface>) {
//         let new_focus_domain_id = focused.and_then(|s| {
//             // Logic to get DomainWindowIdentifier from WlSurface UserData
//             // Example: s.data_map().get::<SurfaceDataExt>().map(|data_ext| data_ext.domain_id.clone())
//             None // Placeholder
//         });
//         tracing::debug!(seat = %seat.name(), new_focus =?new_focus_domain_id, "Keyboard focus changed (Wayland)");
//         // Notify domain layer (e.g., window_management_policy or workspace_manager)
//         // This might involve sending an event through the SystemEventBridge or calling a domain service
//         // let event = SystemLayerEvent::InputFocusChanged { new_focus_domain_id };
//         // self.event_bridge.publish(event);

//         // For XDG Shell activation (simplified)
//         if let Some(surface_to_activate) = focused {
//             if let Some(toplevel) = self.space.window_for_surface(surface_to_activate, WindowSurfaceType::TOPLEVEL)
//                .and_then(|win_elem| match win_elem.as_ref() { // Assuming WindowElement is Arc<ManagedWindow>
//                     WindowElement::Wayland(w) => w.toplevel().ok(),
//                     _ => None,
//                 }) {
//                 toplevel.send_configure(); // To signal state change (active)
//             }
//         }
//         // Deactivate previously focused window
//         //...
//     }

//     fn cursor_image(&mut self, _seat: &Seat<Self>, image: CursorImageStatus) {
//         // Update self.current_cursor_status for the renderer
//         // *self.current_cursor_status.lock().unwrap() = image;
//         // self.damage_cursor_area(); // Signal renderer to update cursor
//     }
// }

// ==== System Layer: system::dbus_interfaces::upower_client::service ====
// #[async_trait]
// pub trait SystemUPowerClient: Send + Sync {
//    async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError>;
// }

// pub struct UPowerClientService {
//     proxy: UPowerProxy<'static>, // Generated by zbus
//     event_publisher: Arc<SystemEventBridge>,
// }

// impl UPowerClientService {
//     pub async fn new(conn: Arc<Connection>, event_publisher: Arc<SystemEventBridge>) -> Result<Self, DBusInterfaceError> {
//         let proxy = UPowerProxy::new(&conn).await?;
//         let client = Self { proxy, event_publisher };
//         client.start_signal_listeners().await?;
//         Ok(client)
//     }

//     async fn start_signal_listeners(&self) -> Result<(), DBusInterfaceError> {
//         let mut props_changed_stream = self.proxy.receive_properties_changed().await?;
//         let publisher_clone = self.event_publisher.clone();
//         let proxy_clone = self.proxy.clone(); // Proxy is Arc-like or cloneable for tasks

//         tokio::spawn(async move {
//             while let Some(signal) = props_changed_stream.next().await {
//                 if let Ok(args) = signal.args() {
//                     if args.interface_name() == "org.freedesktop.UPower" {
//                         if let Some(Value::Bool(is_on_battery)) = args.changed_properties().get("OnBattery") {
//                             publisher_clone.publish(SystemLayerEvent::UPower(UPowerEvent::OnBatteryChanged(*is_on_battery)));
//                         }
//                         // Handle LidIsClosed, etc.
//                     }
//                 }
//             }
//         });
//         Ok(())
//     }
// }

// #[async_trait]
// impl SystemUPowerClient for UPowerClientService {
//     async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError> {
//         Ok(self.proxy.on_battery().await?)
//     }
// }
```

### 4.2. Algorithmen

- **Token Resolution Pipeline (`domain::theming::logic`)**:
    
    1. **Sammle Basis-Tokens**: Kombiniere globale Tokens (systemweit oder anwendungsweit definiert) mit den Basis-Tokens des aktuell ausgewählten Themes (`theme_def.base_tokens`).
    2. **Varianten-Tokens anwenden**: Basierend auf dem `preferred_color_scheme` (z.B. `Light` oder `Dark`) aus der `ThemingConfiguration`, wähle die entsprechende `ThemeVariantDefinition` aus `theme_def.variants`. Überschreibe die Basis-Tokens mit den Tokens aus dieser Variante.
    3. **Akzentfarbe anwenden**: Falls eine `selected_accent_color` in der `ThemingConfiguration` gesetzt ist und das Theme Akzentfarben unterstützt (`theme_def.accentable_tokens_map`), modifiziere die entsprechenden Tokens. Für jedes Token im `accentable_tokens_map`:
        - Bei `AccentModificationType::DirectReplace`: Ersetze den Token-Wert direkt durch die Akzentfarbe.
        - Bei `AccentModificationType::Lighten(factor)` oder `AccentModificationType::Darken(factor)`: Helle den bestehenden Farbwert des Tokens um den Faktor auf oder dunkle ihn ab, unter Verwendung der Akzentfarbe als Basis oder Modifikator.
    4. **Benutzer-Overrides anwenden**: Überschreibe die bisherigen Token-Werte mit Tokens aus `config.custom_user_token_overrides`, falls vorhanden. Diese haben die höchste Priorität.
    5. **Rekursive Referenzauflösung**: Iteriere durch alle Tokens. Für jedes Token, dessen `value` ein `TokenValue::Reference(target_id)` ist:
        - Rufe `resolve_single_token_value(target_id, &mut visited_path, current_depth + 1, max_depth,...)` auf.
        - `visited_path`: Eine Liste der bisher besuchten `TokenIdentifier` in der aktuellen Auflösungskette, um Zyklen zu erkennen. Wenn `target_id` bereits in `visited_path` enthalten ist, liegt ein Zyklus vor -> `ThemingError::CyclicTokenReference`.
        - `current_depth`: Die aktuelle Rekursionstiefe. Wenn `current_depth > max_depth` (`MAX_TOKEN_RESOLUTION_DEPTH`), dann -> `ThemingError::MaxReferenceDepthExceeded`.
        - Wenn das `target_id` nicht im kombinierten Token-Set gefunden wird -> `ThemingError::MissingTokenReference`.
        - Ersetze das `TokenValue::Reference` durch den aufgelösten Wert des `target_id`.
    6. **Finale Werte konvertieren**: Konvertiere alle `TokenValue`-Varianten (die jetzt keine Referenzen mehr sein sollten) in ihre finalen String-Repräsentationen (z.B. Hex-Farbcodes, Pixelwerte mit "px"-Suffix, Schriftartnamen). Das Ergebnis ist ein `BTreeMap<TokenIdentifier, String>`.
- **Fenster-Layout-Berechnung (Beispiel für `domain::window_management_policy` bei `TilingMode::Columns`)**:
    
    1. Ermittle die verfügbare Breite für Fenster: `available_width = available_area.width - (num_windows - 1) * gap_settings.window_inner - 2 * gap_settings.screen_outer_horizontal`. (Annahme: `num_windows > 0`).
    2. Berechne die Breite pro Fenster: `width_per_window = available_width / num_windows`.
    3. Iteriere über die zu kachelnden Fenster (basierend auf `windows_info`):
        - Setze `window_height = available_area.height - 2 * gap_settings.screen_outer_vertical`.
        - Setze `window_width = width_per_window`.
        - Berücksichtige `WindowLayoutInfo.requested_min_size` und `WindowPolicyOverrides` (z.B. `min_size_override`, `fixed_size`). Passe `window_width` und `window_height` entsprechend an, falls die berechneten Werte die Minima unterschreiten oder feste Größen vorgegeben sind.
        - Positioniere das Fenster: `x_position = gap_settings.screen_outer_horizontal + previous_window_x_plus_width + gap_settings.window_inner`. `y_position = gap_settings.screen_outer_vertical`.
        - Speichere die berechnete Geometrie (`RectInt`) in `WorkspaceWindowLayout.window_geometries`.
    4. Aktualisiere `WorkspaceWindowLayout.occupied_area`.
    5. Setze `WorkspaceWindowLayout.tiling_mode_applied = TilingMode::Columns`.
- **Wayland Event zu Domänen-Event (Beispiel `XdgShellHandler::new_toplevel`)**:
    
    1. Ein Wayland-Client sendet `xdg_wm_base.get_xdg_surface` und anschließend `xdg_surface.get_toplevel`.
    2. Smithay ruft die Methode `XdgShellHandler::new_toplevel(toplevel_surface)` in `DesktopState` auf.
    3. Innerhalb des Handlers in `DesktopState`:
        - Generiere einen neuen, eindeutigen `DomainWindowIdentifier` (z.B. mittels `Uuid::new_v4()`).
        - Extrahiere initiale Client-Hinweise (z.B. `app_id`, `title` vom `toplevel_surface`).
        - Rufe asynchron (ggf. über einen Task und Channel-Kommunikation, um den synchronen Handler nicht zu blockieren) `domain_service.get_initial_window_geometry(domain_id, client_hints)` auf, um die empfohlene Startgeometrie zu erhalten.
        - Rufe asynchron `domain_service.assign_window_to_active_workspace(domain_id)` (oder eine spezifischere Zuweisungsmethode) auf.
        - Erstelle ein `WindowElement` (z.B. `WindowElement::Wayland(Window::new(toplevel_surface))`).
        - Füge das `WindowElement` zu `DesktopState.space` hinzu (z.B. `space.map_window(window_element, initial_position, activate)`).
        - Speichere das Mapping `DomainWindowIdentifier -> Arc<WindowElement>` in `DesktopState.windows`.
        - Sende einen `configure`-Event an das `toplevel_surface` mit der von der Domäne bestimmten Geometrie und Zuständen (z.B. aktiviert/maximiert).
        - Publiziere ein `SystemLayerEvent::WindowCreated { domain_id,... }` über den `SystemEventBridge`, damit die Domänenschicht (z.B. `WorkspaceManagerService`) darauf reagieren kann.

### 4.3. Relevante Rust-Bibliotheken

- **Domänenschicht**:
    - `uuid`: Für eindeutige Identifikatoren (`WorkspaceId`, `NotificationId`, etc.).
    - `chrono`: Für Zeitstempel (`DateTime<Utc>`).
    - `serde`, `serde_json`: Für Serialisierung und Deserialisierung von Datenstrukturen (z.B. Konfigurationen, Events).
    - `thiserror`: Zur einfachen Erstellung von Fehler-Enums.
    - `async-trait`: Für asynchrone Traits in Services.
    - `tokio` (speziell `tokio::sync`): Für Synchronisationsprimitive wie `Mutex`, `RwLock` und `broadcast` Channels für die Event-Verteilung.
- **Systemschicht**:
    - **Compositor**:
        - `smithay`: Das Kern-Toolkit für den Wayland-Compositor.2
        - `wayland-server`, `wayland-protocols`: Für die Wayland-Protokoll-Implementierung.122
        - `calloop`: Der Event-Loop, der von Smithay verwendet wird.36
        - `tracing`, `tracing-subscriber`: Für Logging.
    - **Input**:
        - `libinput` (C-Bibliothek) und `input-rs` (Rust-Bindings, von Smithay genutzt) 81: Für die Verarbeitung von Eingabeereignissen von Geräten.
        - `xkbcommon` (C-Bibliothek) und `xkbcommon-rs` (Rust-Bindings) 126: Für Tastatur-Layout-Management.
    - **D-Bus**:
        - `zbus`: Für die asynchrone D-Bus-Kommunikation.87
    - **Audio**:
        - `pipewire` (C-Bibliothek) und `pipewire-rs` (Rust-Bindings) 137: Für Audio-Management und Interaktion mit dem PipeWire-Server.
    - **MCP**:
        - `mcp_client_rs`: Für die Implementierung des Model Context Protocol Clients.101
    - **XDG Desktop Portals**:
        - `ashpd`: Als Referenz oder zur direkten Nutzung für die Implementierung von Portal-Backends, falls es die serverseitige Logik unterstützt. Andernfalls direkte `zbus`-Implementierung der Portal-D-Bus-Interfaces.96
- **Kernschicht (`novade_core`)**:
    - `thiserror`: Für Fehlerdefinitionen.
    - `tracing`, `serde`, `toml`, `once_cell`, `uuid`, `chrono`: Allgemeine Hilfsbibliotheken.

### 4.4. Annahmen, Einschränkungen, Alternativen

- **Annahme**: Die `novade_core`-Schicht stellt alle in der Domänenschicht referenzierten Typen (z.B. `novade_core::types::RectInt`, `novade_core::types::Color`, `novade_core::errors::CoreError`, `novade_core::config::ConfigServiceAsync`, Logging-Initialisierung) bereit.
- **Annahme**: Ein `SystemEventBridge` (basierend auf `tokio::sync::broadcast`) existiert für die interne Event-Kommunikation in der Systemschicht und als Adapter zur Domänenschicht. Dies ermöglicht eine entkoppelte Kommunikation zwischen Systemkomponenten und der Domäne.
- **Annahme**: Die Domänenschicht-Services sind asynchron implementiert und werden über `Arc<dyn TraitName>`-Handles zugänglich gemacht, um Thread-Sicherheit und flexible Injektion zu ermöglichen.
- **Einschränkung**: Detaillierte Spezifikationen zur GPU-Interaktion und die konkrete Implementierung des Renderers (z.B. spezifische OpenGL/Vulkan-Nutzung) sind in diesem Dokument nicht enthalten und müssen separat definiert werden.4
- **Einschränkung**: Die Komplexität des XWayland-Managements ist nur angedeutet. Eine vollständige XWayland-Integration erfordert eine detaillierte Implementierung eines X11 Window Managers (`X11Wm`) innerhalb des Compositors.4
- **Alternative (D-Bus)**: `dbus-rs` (älter, primär synchron) wurde zugunsten von `zbus` (modern, asynchron-fokussiert) nicht gewählt, um eine bessere Integration in das `tokio`-basierte asynchrone Ökosystem von NovaDE zu gewährleisten.87
- **Alternative (Compositor-Toolkit)**: Die direkte Nutzung von `libweston` (C-Bibliothek) wäre in Rust komplexer zu integrieren und würde weniger idiomatische Rust-APIs bieten als das Smithay-Toolkit. Smithay wurde aufgrund seiner Rust-Nativität und modularen Architektur gewählt.2

## 5. Maximale Detailtiefe

Die vorliegenden Spezifikationen versuchen, für jedes Modul und jede wesentliche Interaktion die folgenden Detailebenen abzudecken, um eine klare und direkte Implementierungsgrundlage zu schaffen:

- **Datenstrukturen**: Alle Felder werden mit exakten Rust-Typen spezifiziert. Sichtbarkeitsmodifikatoren (wo relevant für die Kapselung), abgeleitete Traits (wie `Debug`, `Clone`, `Serialize`, `Deserialize`, `PartialEq`, `Eq`, `Hash`, `Ord`, `Display`, `From`, `Default`) und wichtige Invarianten werden explizit genannt.
- **APIs (Traits und Funktionen)**: Signaturen werden präzise definiert, inklusive Parameternamen, Parametertypen, Rückgabetypen und relevanten Trait-Bounds wie `async`, `Send`, `Sync`. Vor- und Nachbedingungen für kritische Funktionen werden, wo nötig, beschrieben.
- **Events**: Die Struktur des Event-Payloads (alle Felder und deren Typen) wird definiert. Es wird angegeben, welche Komponenten typischerweise Events publizieren und welche sie abonnieren, sowie die Bedingungen, unter denen Events ausgelöst werden.
- **Fehlerbehandlung**: Spezifische Fehler-Enums werden pro Modul unter Verwendung von `thiserror` definiert. Jede Fehlervariante wird mit ihrer Bedeutung erläutert, und gegebenenfalls werden `#[source]`- oder `#[from]`-Attribute zur Fehlerverkettung spezifiziert.
- **Logik/Algorithmen**: Kritische Abläufe und Algorithmen (z.B. Token-Auflösung, Fenster-Layout-Berechnung) werden schrittweise beschrieben, um die Implementierungslogik zu verdeutlichen.
- **Interaktionen**: Die Kommunikation zwischen Modulen und Schichten über APIs und Events wird klar definiert, um das Zusammenspiel der Systemkomponenten nachvollziehbar zu machen.

Diese Detailtiefe zielt darauf ab, Interpretationsspielraum während der Entwicklung zu minimieren und eine konsistente, qualitativ hochwertige Implementierung zu ermöglichen.

## Schlussfolgerungen

Dieses Spezifikationsdokument legt eine solide Grundlage für die Entwicklung der Domänenschicht und deren Integration mit dem Wayland/Smithay-basierten Compositor für das NovaDE-Projekt. Die klare Trennung zwischen Domänenlogik und Systemimplementierungsdetails, die detaillierte Definition von Datenstrukturen, APIs und Fehlerzuständen sowie die Skizzierung von Kernalgorithmen und Interaktionsmustern bieten einen umfassenden Leitfaden für Entwickler.

Die Modularität der Domänenschicht, beispielsweise durch die Aufteilung in `domain::theming`, `domain::workspaces` und `domain::user_centric_services`, fördert die Kapselung und Wiederverwendbarkeit von Code. Die Verwendung von Rusts Typsystem und Features wie `async/await`, `thiserror` und `serde` unterstützt die Entwicklung eines robusten und wartbaren Systems.

Die Integration mit Smithay nutzt dessen Stärken im Bereich der Wayland-Protokollbehandlung und des Zustandsmanagements. Die `DesktopState`-Struktur als zentraler Punkt im Compositor, die verschiedene Handler-Traits implementiert und Smithay-Zustandsobjekte verwaltet, ist ein etabliertes Muster. Die Kommunikation zwischen Dom

## NovaDE Ultra-Feinspezifikation: Domänenschicht & Wayland/Smithay-Integration

Dieses Dokument definiert die detaillierten technischen Spezifikationen für die Domänenschicht des NovaDE-Projekts und deren Integration mit dem Wayland-Compositor, der unter Verwendung des Smithay-Toolkits implementiert wird. Es dient als direkter Implementierungsleitfaden für Entwickler.

### 1. Domänenschicht-Spezifikationen

Die Domänenschicht kapselt die Kernlogik und den Zustand der NovaDE-Desktop-Umgebung. Sie ist unabhängig von UI- und Systemdetails konzipiert.

#### 1.1. Modul: `domain::theming`

Dieses Modul ist verantwortlich für die Logik des Erscheinungsbilds (Theming), die Verwaltung von Design-Tokens, die Interpretation von Theme-Definitionen und die Ermöglichung dynamischer Theme-Wechsel.

- **Referenzierte Dokumente:** `B1 Domänenschicht.md`

##### 1.1.1. Datenstrukturen (`domain::theming::types`)

- **`TokenIdentifier`**: Wrapper für `String` zur Identifizierung von Design-Tokens (z.B. "color.background.primary").
    - Implementiert: `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord, Display, From<&str>`.
    - **Invarianten**: Nicht leer, enthält nur ASCII-Alphanumerisch, Punkte, Bindestriche.
- **`TokenValue`**: Enum zur Repräsentation von Token-Werten.
    - Varianten: `Color(String)`, `Dimension(String)`, `FontSize(String)`, `FontFamily(String)`, `FontWeight(String)`, `LineHeight(String)`, `LetterSpacing(String)`, `Border(String)`, `Shadow(String)`, `Radius(String)`, `Spacing(String)`, `ZIndex(i32)`, `Opacity(f64)` (0.0-1.0), `Text(String)`, `Reference(TokenIdentifier)`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
    - `Opacity`-Werte werden auf 0.0-1.0 geklemmt.
- **`RawToken`**: Struktur zur Repräsentation eines Tokens aus einer Konfigurationsdatei.
    - Felder: `id: TokenIdentifier`, `value: TokenValue`, `description: Option<String>`, `group: Option<String>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **`TokenSet`**: Typalias für `std::collections::BTreeMap<TokenIdentifier, RawToken>`.
- **`ThemeIdentifier`**: Wrapper für `String` zur Identifizierung von Themes.
    - Implementiert: `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord, Display, From<&str>`.
    - **Invarianten**: Nicht leer, empfohlene Zeichen: `a-zA-Z0-9-`.
- **`ColorSchemeType`**: Enum (`Light`, `Dark`).
    - Implementiert: `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.
- **`AccentColor`**: Struktur zur Repräsentation einer Akzentfarbe.
    - Felder: `name: Option<String>`, `value: novade_core::types::Color`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`. (Eq/Hash für `value` ggf. manuell oder über Hex-String).
- **`ThemeVariantDefinition`**: Definition spezifischer Token-Werte für eine Theme-Variante.
    - Felder: `applies_to_scheme: ColorSchemeType`, `tokens: TokenSet`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **`ThemeDefinition`**: Vollständige Definition eines Themes.
    - Felder: `id: ThemeIdentifier`, `name: String`, `description: Option<String>`, `author: Option<String>`, `version: Option<String>`, `base_tokens: TokenSet`, `variants: Vec<ThemeVariantDefinition>`, `supported_accent_colors: Option<Vec<AccentColor>>`, `accentable_tokens: Option<HashMap<TokenIdentifier, AccentModificationType>>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **`AccentModificationType`**: Enum (`DirectReplace`, `Lighten(f32)`, `Darken(f32)`).
- **`AppliedThemeState`**: Repräsentiert den aktuell aktiven, aufgelösten Theme-Zustand.
    - Felder: `theme_id: ThemeIdentifier`, `color_scheme: ColorSchemeType`, `active_accent_color: Option<AccentColor>`, `resolved_tokens: std::collections::BTreeMap<TokenIdentifier, String>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize`.
    - **Invarianten**: `resolved_tokens` enthält keine Referenzen mehr.
- **`ThemingConfiguration`**: Benutzerspezifische Theming-Einstellungen.
    - Felder: `selected_theme_id: ThemeIdentifier`, `preferred_color_scheme: ColorSchemeType`, `selected_accent_color: Option<novade_core::types::Color>`, `custom_user_token_overrides: Option<TokenSet>`.
    - Implementiert: `Debug, Clone, PartialEq, Serialize, Deserialize, Default`.

##### 1.1.2. Fehlerbehandlung (`domain::theming::errors`)

- **`ThemingError`**: Enum (definiert mit `thiserror`).
    - Varianten: `TokenFileParseError { path: PathBuf, source: serde_json::Error }`, `TokenFileIoError { path: PathBuf, source: std::io::Error }`, `InvalidTokenData { path: PathBuf, message: String }`, `InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String }`, `CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> }`, `ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, source: serde_json::Error }`, `ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, source: std::io::Error }`, `InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String }`, `ThemeNotFound { theme_id: ThemeIdentifier }`, `MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier }`, `MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 }`, `ThemeApplicationError { message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`, `FallbackThemeLoadError { source: Box<dyn std::error::Error + Send + Sync + 'static> }`, `InitialConfigurationError(String)`, `InternalStateError(String)`, `EventSubscriptionError(String)`, `AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: novade_core::types::Color, details: String }`, `TokenResolutionError { token_id: TokenIdentifier, message: String, source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`, `FilesystemError(#[from] novade_core::errors::CoreError)`.

##### 1.1.3. Kernlogik (`domain::theming::logic`)

- **Konstante**: `MAX_TOKEN_RESOLUTION_DEPTH: u8 = 16;`
- **Token/Theme Laden & Validieren**:
    - `async fn load_raw_tokens_from_file(path: &Path, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Liest JSON, parst zu `TokenSet`, validiert Duplikate/Basisformat.
    - `async fn load_and_validate_token_files(paths: &[PathBuf], config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`: Lädt von Pfaden, mergt (Benutzer überschreibt System), validiert Zyklen.
    - `async fn load_theme_definition_from_file(...) -> Result<ThemeDefinition, ThemingError>`: Liest JSON, parst zu `ThemeDefinition`.
    - `async fn load_and_validate_theme_files(...) -> Result<Vec<ThemeDefinition>, ThemingError>`: Lädt Themes, validiert Token-Referenzen.
    - `fn validate_tokenset_for_cycles(tokens: &TokenSet) -> Result<(), ThemingError>`: Tiefensuche zur Zyklenerkennung.
- **Token Resolution Pipeline**:
    - `fn resolve_tokens_for_config(config: &ThemingConfiguration, theme_def: &ThemeDefinition, global_tokens: &TokenSet, accentable_tokens_map: &HashMap<TokenIdentifier, AccentModificationType>, max_depth: u8) -> Result<BTreeMap<TokenIdentifier, String>, ThemingError>`:
        1. Start mit globalen Tokens + Theme-Basis-Tokens.
        2. Varianten-Tokens anwenden.
        3. Akzentfarben anwenden (basierend auf `accentable_tokens_map` und `config.selected_accent_color`).
        4. Benutzer-Overrides anwenden.
        5. Rekursive Referenzauflösung (`resolve_single_token_value`) mit Zyklenerkennung und Tiefenbegrenzung.
        6. Finale Werte in Strings konvertieren.
- **Caching**: Cache-Schlüssel `(ThemeIdentifier, ColorSchemeType, Option<String> /* hex von AccentColor */, u64 /* hash von Overrides */)` für `AppliedThemeState`.
- **Fallback**: `fn generate_fallback_applied_state() -> AppliedThemeState` aus einkompilierten JSONs.

##### 1.1.4. API (`domain::theming::service::ThemingEngine`)

- **Struktur `ThemingEngineInternalState`**:
    - Felder: `current_config: ThemingConfiguration`, `available_themes: Vec<ThemeDefinition>`, `global_raw_tokens: TokenSet`, `applied_state: AppliedThemeState`, `theme_load_paths: Vec<PathBuf>`, `token_load_paths: Vec<PathBuf>`, `resolved_state_cache: HashMap<CacheKey, AppliedThemeState>`, `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`.
- **Struktur `ThemingEngine`**:
    - Felder: `internal_state: Arc<tokio::sync::Mutex<ThemingEngineInternalState>>`, `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`.
- **Methoden**:
    - `async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, broadcast_capacity: usize) -> Result<Self, ThemingError>`
    - `async fn get_current_theme_state(&self) -> AppliedThemeState`
    - `async fn get_available_themes(&self) -> Vec<ThemeDefinition>`
    - `async fn get_current_configuration(&self) -> ThemingConfiguration`
    - `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
    - `async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`
    - `fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`

##### 1.1.5. Events (`domain::theming::events`)

- **`ThemeChangedEvent`**:
    - Payload: `new_state: AppliedThemeState`.

#### 1.2. Modul: `domain::workspaces`

Verantwortlich für die Logik und Verwaltung von Arbeitsbereichen ("Spaces").

- **Referenzierte Dokumente:** `B2 Domänenschicht.md`

##### 1.2.1. Untermodul: `domain::workspaces::core`

- **Datenstrukturen (`domain::workspaces::core::types`)**:
    - `WorkspaceId`: Typalias für `uuid::Uuid`.
    - `WindowIdentifier`: Wrapper für `String`. Implementiert `new(id: impl Into<String>) -> Result<Self, WorkspaceCoreError>`.
    - `WorkspaceLayoutType`: Enum (`Floating`, `TilingHorizontal`, `TilingVertical`, `Maximized`). Implementiert `Default`.
- **Entität `Workspace` (`domain::workspaces::core::mod.rs`)**:
    - Felder: `id: WorkspaceId`, `name: String`, `persistent_id: Option<String>`, `layout_type: WorkspaceLayoutType`, `window_ids: HashSet<WindowIdentifier>`, `created_at: DateTime<Utc>`, `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - Methoden: `new(...) -> Result<Self, WorkspaceCoreError>`, `id()`, `name()`, `rename(...)`, `set_layout_type(...)`, `add_window_id(...)` (crate-intern), `remove_window_id(...)` (crate-intern), `set_icon_name(...)`, `set_accent_color_hex(...) -> Result<...>`.
- **Event-Payloads (`domain::workspaces::core::event_data`)**: `WorkspaceRenamedData`, `WorkspaceLayoutChangedData`, `WindowAddedToWorkspaceData`, `WindowRemovedFromWorkspaceData`, `WorkspacePersistentIdChangedData`, `WorkspaceIconChangedData`, `WorkspaceAccentChangedData`.
- **Fehlerbehandlung (`domain::workspaces::core::errors`)**:
    - `WorkspaceCoreError`: `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`, `WindowIdentifierEmpty`, `InvalidAccentColorFormat`.

##### 1.2.2. Untermodul: `domain::workspaces::assignment`

- **API (`domain::workspaces::assignment::mod.rs`)**: Funktionen operieren auf `&mut HashMap<WorkspaceId, Workspace>`.
    - `assign_window_to_workspace(...) -> Result<(), WindowAssignmentError>`
    - `remove_window_from_workspace(...) -> Result<bool, WindowAssignmentError>`
    - `move_window_to_workspace(...) -> Result<(), WindowAssignmentError>`
    - `find_workspace_for_window(...) -> Option<WorkspaceId>`
- **Fehlerbehandlung (`domain::workspaces::assignment::errors`)**:
    - `WindowAssignmentError`: `WorkspaceNotFound`, `WindowAlreadyAssigned`, `WindowNotAssignedToWorkspace`, `SourceWorkspaceNotFound`, `TargetWorkspaceNotFound`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation`, `Internal`.

##### 1.2.3. Untermodul: `domain::workspaces::config`

- **Datenstrukturen (`domain::workspaces::config::mod.rs`)**:
    - `WorkspaceSnapshot`: `persistent_id: String`, `name: String`, `layout_type: WorkspaceLayoutType`, `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - `WorkspaceSetSnapshot`: `workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`.
- **API (`domain::workspaces::config::mod.rs`)**:
    - Trait `WorkspaceConfigProvider`: `async fn load_workspace_config() -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>`, `async fn save_workspace_config(snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>`.
    - Struktur `FilesystemConfigProvider`: Implementiert `WorkspaceConfigProvider`, nutzt `core::config::ConfigServiceAsync`.
- **Fehlerbehandlung (`domain::workspaces::config::errors`)**:
    - `WorkspaceConfigError`: `LoadError`, `SaveError`, `InvalidData`, `SerializationError`, `DeserializationError`, `PersistentIdNotFoundInLoadedSet`, `DuplicatePersistentIdInLoadedSet`.

##### 1.2.4. Untermodul: `domain::workspaces::manager`

- **API (`domain::workspaces::manager::mod.rs`)**: Trait `WorkspaceManagerService`.
    - Methoden: `async create_workspace(...)`, `async delete_workspace(...)`, `get_workspace(...) -> Option<Workspace>`, `all_workspaces_ordered() -> Vec<Workspace>`, `active_workspace_id()`, `async set_active_workspace(...)`, `async assign_window_to_active_workspace(...)`, `async assign_window_to_specific_workspace(...)`, `async remove_window_from_its_workspace(...)`, `async move_window_to_specific_workspace(...)`, `async rename_workspace(...)`, `async set_workspace_layout(...)`, `async set_workspace_icon(...)`, `async set_workspace_accent_color(...)`, `async save_configuration()`, `subscribe_to_workspace_events() -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`, `async reorder_workspace(...)`.
- **Implementierung `DefaultWorkspaceManager`**: Hält `Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>`.
    - `WorkspaceManagerInternalState`: `workspaces: HashMap<WorkspaceId, Workspace>`, `active_workspace_id: Option<WorkspaceId>`, `ordered_workspace_ids: Vec<WorkspaceId>`, `next_workspace_number: u32`, `config_provider: Arc<dyn WorkspaceConfigProvider>`, `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`, `ensure_unique_window_assignment: bool`.
- **Events (`domain::workspaces::manager::events`)**:
    - `WorkspaceEvent`: `WorkspaceCreated`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, `WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WindowAddedToWorkspace`, `WindowRemovedFromWorkspace`, `WorkspaceOrderChanged`, `WorkspacesReloaded`, `WorkspacePersistentIdChanged`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`.
- **Fehlerbehandlung (`domain::workspaces::manager::errors`)**:
    - `WorkspaceManagerError`: `WorkspaceNotFound`, `CannotDeleteLastWorkspace`, `DeleteRequiresFallbackForWindows`, `FallbackWorkspaceNotFound`, `CoreError(#[from] WorkspaceCoreError)`, `AssignmentError(#[from] WindowAssignmentError)`, `ConfigError(#[from] WorkspaceConfigError)`, `SetActiveWorkspaceNotFound`, `NoActiveWorkspace`, `DuplicatePersistentId`, `Internal`.

#### 1.3. Modul: `domain::user_centric_services`

Bündelt Logik für KI-Interaktionen und Benachrichtigungen.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`, `B4 Domänenschicht.md`

##### 1.3.1. Untermodul: `domain::user_centric_services::ai_interaction`

- **Datenstrukturen (`...::types`)**:
    - `AIDataCategory`: Enum (`UserProfile`, `ApplicationUsage`, `FileSystemRead`, `ClipboardAccess`, `LocationData`, `GenericText`, `GenericImage`).
    - `AIConsentStatus`: Enum (`Granted`, `Denied`, `PendingUserAction`, `NotRequired`).
    - `AttachmentData`: Felder `id: Uuid`, `mime_type: String`, `source_uri: Option<String>`, `content_base64: Option<String>`, `text_content: Option<String>`, `description: Option<String>`.
    - `InteractionParticipant`: Enum (`User`, `Assistant`, `System`).
    - `InteractionHistoryEntry`: Felder `entry_id: Uuid`, `timestamp: DateTime<Utc>`, `participant: InteractionParticipant`, `content: String`, `related_attachment_ids: Vec<Uuid>`.
    - `AIInteractionContext`: Felder `id: Uuid`, `creation_timestamp: DateTime<Utc>`, `active_model_id: Option<String>`, `consent_status: AIConsentStatus`, `associated_data_categories: Vec<AIDataCategory>`, `history_entries: Vec<InteractionHistoryEntry>`, `attachments: Vec<AttachmentData>`, `user_prompt_template: Option<String>`, `is_active: bool`.
    - `AIConsentScope`: Enum (`SessionOnly`, `PersistentUntilRevoked`, `SpecificDuration`).
    - `AIConsent`: Felder `id: Uuid`, `user_id: String`, `model_id: String`, `data_category: AIDataCategory`, `granted_timestamp: DateTime<Utc>`, `expiry_timestamp: Option<DateTime<Utc>>`, `is_revoked: bool`, `last_used_timestamp: Option<DateTime<Utc>>`, `consent_scope: AIConsentScope`.
    - `AIModelCapability`: Enum (`TextGeneration`, `CodeGeneration`, `Summarization`, `Translation`, `ImageAnalysis`, `FunctionCalling`).
    - `AIModelProfile`: Felder `model_id: String`, `display_name: String`, `description: String`, `provider: String`, `required_consent_categories: Vec<AIDataCategory>`, `capabilities: Vec<AIModelCapability>`, `supports_streaming: bool`, `endpoint_url: Option<String>`, `api_key_secret_name: Option<String>`, `is_default_model: bool`, `sort_order: i32`.
- **Fehlerbehandlung (`...::errors`)**: `AIInteractionError` (`ConsentCheckFailed`, `ApiKeyNotFoundInSecrets`, `ModelEndpointUnreachable`, `NoDefaultModelConfigured`, `CoreConfigError`).
- **Persistenz-Interfaces (`...::persistence_iface`)**: Traits `AIConsentProvider`, `AIModelProfileProvider`.
- **API (`...::service::AIInteractionLogicService`)**: Trait mit Methoden `initiate_interaction`, `get_interaction_context`, `provide_consent`, `get_consent_status_for_interaction`, `get_default_model`, `update_interaction_history`, `store_consent`, `get_all_user_consents`, `load_model_profiles`.
- **Implementierung `DefaultAIInteractionLogicService`**.
- **Events (`...::events::AIInteractionEventEnum`)**: `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`, `AIContextUpdatedEvent`, `AIModelProfilesReloadedEvent`.

##### 1.3.2. Untermodul: `domain::user_centric_services::notifications_core`

- **Datenstrukturen (`...::types`)**:
    - `NotificationId`: Typalias für `uuid::Uuid`.
    - `NotificationUrgency`: Enum (`Low`, `Normal`, `Critical`).
    - `NotificationActionType`: Enum (`Callback`, `OpenLink`).
    - `NotificationAction`: Felder `key: String`, `label: String`, `action_type: NotificationActionType`.
    - `Notification`: Felder `id: Uuid`, `application_name: String`, `application_icon: Option<String>`, `summary: String`, `body: Option<String>`, `actions: Vec<NotificationAction>`, `urgency: NotificationUrgency`, `timestamp: DateTime<Utc>`, `is_read: bool`, `is_dismissed: bool`, `transient: bool`, `category: Option<String>`, `hints: HashMap<String, serde_json::Value>`, `timeout_ms: Option<u32>`.
    - `NotificationInput`: Struktur für das Erstellen von Notifications (ohne `id`, `timestamp`, `is_read`, `is_dismissed`).
    - `NotificationFilterCriteria`: Enum (mit Varianten `Unread`, `Application`, `Urgency`, `Category`, `HasAction`, `BodyContains`, `SummaryContains`, `IsTransient`, `AndTimeRange`, `And`, `Or`, `Not`).
    - `NotificationSortOrder`: Enum (`TimestampAscending`, `TimestampDescending`, `Urgency`, `ApplicationNameAscending`, `SummaryAscending`).
    - `NotificationStats`: `num_active: usize`, `num_history: usize`, `num_unread: usize`.
    - `DismissReason`: Enum (`User`, `Timeout`, `Replaced`, `AppClosed`, `SystemRequest`).
- **Fehlerbehandlung (`...::errors`)**: `NotificationError` (`NotFound`, `InvalidData`, `HistoryFull`, `ActionNotFound`, `InvalidFilterCriteria`, `ActionInvocationFailed`).
- **API (`...::service::NotificationService`)**: Trait mit Methoden `post_notification(input: NotificationInput)`, `get_notification`, `mark_as_read`, `dismiss_notification`, `get_active_notifications`, `get_notification_history`, `clear_history`, `set_do_not_disturb`, `is_do_not_disturb_enabled`, `invoke_action`, `get_stats`, `clear_all_for_app`.
- **Implementierung `DefaultNotificationService`**.
- **Events (`...::events::NotificationEventEnum`)**: `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `NotificationActionInvokedEvent`, `DoNotDisturbModeChangedEvent`, `NotificationHistoryClearedEvent`, `NotificationPopupExpiredEvent`.

#### 1.4. Modul: `domain::notifications_rules`

Regelbasierte Verarbeitung von Benachrichtigungen.

- **Referenzierte Dokumente:** `B4 Domänenschicht.md`

##### 1.4.1. Datenstrukturen (`domain::notifications_rules::types`)

- `RuleConditionValue`: Enum (`String(String)`, `Integer(i64)`, `Boolean(bool)`, `Urgency(NotificationUrgency)`, `Regex(String)`).
- `RuleConditionOperator`: Enum (`Is`, `IsNot`, `Contains`, `NotContains`, `StartsWith`, `EndsWith`, `MatchesRegex`, `NotMatchesRegex`, `GreaterThan`, `LessThan`, `GreaterThanOrEqual`, `LessThanOrEqual`).
- `RuleConditionField`: Enum (`ApplicationName`, `Summary`, `Body`, `Urgency`, `Category`, `HintExists(String)`, `HintValue(String)`).
- `SimpleRuleCondition`: Felder `field: RuleConditionField`, `operator: RuleConditionOperator`, `value: RuleConditionValue`.
- `RuleCondition`: Enum (`Simple(SimpleRuleCondition)`, `SettingIsTrue(SettingPath)`, `And(Vec<RuleCondition>)`, `Or(Vec<RuleCondition>)`, `Not(Box<RuleCondition>`).
- `RuleAction`: Enum (`SuppressNotification`, `SetUrgency`, `AddActionToNotification`, `SetHint`, `PlaySound`, `MarkAsPersistent`, `SetTimeoutMs`, `SetCategory`, `SetSummary`, `SetBody`, `SetIcon`, `SetAccentColor`, `StopProcessingFurtherRules`, `LogMessage`).
- `NotificationRule`: Felder `id: Uuid`, `name: String`, `condition: RuleCondition`, `actions: Vec<RuleAction>`, `is_enabled: bool`, `priority: i32`. Implementiert `Default`.
- `NotificationRuleSet`: Typalias für `Vec<NotificationRule>`.

##### 1.4.2. Fehlerbehandlung (`domain::notifications_rules::errors`)

- `NotificationRulesError`: `InvalidRuleDefinition`, `ConditionEvaluationError`, `ActionApplicationError`, `SettingsAccessError(#[from] GlobalSettingsError)`, `RulePersistenceError(#[from] novade_core::errors::CoreError)`, `InvalidRegex`.

##### 1.4.3. API (`domain::notifications_rules::engine::NotificationRulesEngine`)

- **Trait `NotificationRulesEngine`**:
    - Methoden: `async reload_rules()`, `async process_notification(notification: Notification) -> Result<RuleProcessingResult, NotificationRulesError>`, `async get_rules() -> Result<NotificationRuleSet, _>`, `async update_rules(new_rules: NotificationRuleSet) -> Result<_,_>`.
- **Implementierung `DefaultNotificationRulesEngine`**: Hält `Arc<tokio::sync::RwLock<NotificationRuleSet>>`, `Arc<dyn NotificationRulesProvider>`, `Arc<dyn GlobalSettingsService>`.
- **Enum `RuleProcessingResult`**: `Allow(Notification)`, `Suppress { rule_id: Uuid }`.

##### 1.4.4. Persistenz (`domain::notifications_rules::persistence_iface`)

- **Trait `NotificationRulesProvider`**: `async fn load_rules() -> Result<NotificationRuleSet, _>`, `async fn save_rules(rules: &NotificationRuleSet) -> Result<_,_>`.
- **Implementierung `FilesystemNotificationRulesProvider`**.

#### 1.5. Modul: `domain::global_settings_and_state_management`

Verwaltung globaler Desktop-Einstellungen.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`, `B4 Domänenschicht.md`

##### 1.5.1. Datenstrukturen (`...::types`)

- `GlobalDesktopSettings`: Hauptstruktur mit Feldern wie `appearance: AppearanceSettings`, `workspace_config: WorkspaceSettings`, `input_behavior: InputBehaviorSettings`, `power_management_policy: PowerManagementPolicySettings`, `default_applications: DefaultApplicationsSettings`. Alle Felder mit `#[serde(default)]`.
- Detaillierte Unterstrukturen (`AppearanceSettings`, `FontSettings`, etc.) und Enums (`ColorScheme`, `MouseAccelerationProfile`, etc.) wie in `B3 Domänenschicht.md` und `B4 Domänenschicht.md` definiert.
- **Validierung**: Jede Einstellungs-Unterstruktur implementiert `fn validate(&self) -> Result<(), String>`. `GlobalDesktopSettings` hat `validate_recursive()`.

##### 1.5.2. Pfade (`...::paths`)

- `SettingPath`: Hierarchischer Enum zur typsicheren Adressierung aller Einstellungen. Implementiert `Display` und `TryFrom<&str>`.

##### 1.5.3. Fehlerbehandlung (`...::errors`)

- `GlobalSettingsError`: `PathNotFound { path: SettingPath }`, `InvalidValueType { path: SettingPath, ... }`, `ValidationError { path: SettingPath, reason: String }`, `SerializationError`, `DeserializationError`, `PersistenceError(#[from] GlobalSettingsPersistenceError)`.

##### 1.5.4. Persistenz-Interface (`...::persistence_iface`)

- **Trait `SettingsPersistenceProvider`**: `async fn load_global_settings() -> Result<GlobalDesktopSettings, GlobalSettingsError>`, `async fn save_global_settings(settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`.
    - **Anmerkung:** Die Fehlerart hier sollte ggf. ein spezifischerer `GlobalSettingsPersistenceError` sein, um `#[from]` in `GlobalSettingsError::PersistenceError` zu ermöglichen.
- **Implementierung `FilesystemSettingsProvider`**.

##### 1.5.5. API (`...::service::GlobalSettingsService`)

- **Trait `GlobalSettingsService`**:
    - Methoden: `async load_settings()`, `async save_settings()`, `get_current_settings() -> GlobalDesktopSettings`, `async update_setting(path: SettingPath, value: serde_json::Value) -> Result<(),_>`, `get_setting(path: &SettingPath) -> Result<serde_json::Value, _>`, `async reset_to_defaults()`, `subscribe_to_setting_changes() -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`.
- **Implementierung `DefaultGlobalSettingsService`**: Hält `settings: Arc<tokio::sync::RwLock<GlobalDesktopSettings>>`, `persistence_provider: Arc<dyn SettingsPersistenceProvider>`, `event_sender`.

##### 1.5.6. Events (`...::events`)

- `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`
- `SettingsLoadedEvent { settings: GlobalDesktopSettings }`
- `SettingsSavedEvent`

#### 1.6. Modul: `domain::window_management_policy`

High-Level-Regeln und Richtlinien für Fensterplatzierung, Tiling, etc.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`

##### 1.6.1. Datenstrukturen (`...::types`)

- `TilingMode`: Enum (`Manual`, `Columns`, `Rows`, `Spiral`, `MaximizedFocused`).
- `GapSettings`: `screen_outer_horizontal: u16`, `screen_outer_vertical: u16`, `window_inner: u16`.
- `WindowSnappingPolicy`: `snap_to_screen_edges: bool`, `snap_to_other_windows: bool`, `snap_to_workspace_gaps: bool`, `snap_distance_px: u16`.
- `WindowGroupingPolicy`: `enable_manual_grouping: bool`.
- `NewWindowPlacementStrategy`: Enum (`Smart`, `Center`, `Cascade`, `UnderMouse`).
- `FocusStealingPreventionLevel`: Enum (`None`, `Moderate`, `Strict`).
- `FocusPolicy`: `focus_follows_mouse: bool`, `click_to_focus: bool`, `focus_new_windows_on_creation: bool`, `focus_new_windows_on_workspace_switch: bool`, `focus_stealing_prevention: FocusStealingPreventionLevel`.
- `WindowPolicyOverrides`: Optionale, fensterspezifische Overrides (`preferred_tiling_mode`, `is_always_floating`, `fixed_size`, `fixed_position`, `prevent_focus_stealing`, `min_size_override`, `max_size_override`).
- `WorkspaceWindowLayout`: `window_geometries: HashMap<WindowIdentifier, novade_core::types::RectInt>`, `occupied_area: Option<RectInt>`, `tiling_mode_applied: TilingMode`.
- `WindowLayoutInfo`: `id: WindowIdentifier`, `requested_min_size: Option<novade_core::types::Size<u32>>`, `is_fullscreen_requested: bool`, `is_maximized_requested: bool`.

##### 1.6.2. Fehlerbehandlung (`...::errors`)

- `WindowPolicyError`: `LayoutCalculationError`, `InvalidPolicyConfiguration`, `WindowNotFoundForPolicy`.

##### 1.6.3. API (`...::service::WindowManagementPolicyService`)

- **Trait `WindowManagementPolicyService`**:
    - Methoden: `async calculate_workspace_layout(...) -> Result<WorkspaceWindowLayout, _>`, `async get_initial_window_geometry(...) -> Result<RectInt, _>`, `async calculate_snap_target(...) -> Option<RectInt>`, `async get_effective_tiling_mode_for_workspace(...) -> Result<TilingMode, _>`, `async get_effective_gap_settings_for_workspace(...) -> Result<GapSettings, _>`, `async get_effective_snapping_policy() -> Result<WindowSnappingPolicy, _>`, `async get_effective_focus_policy() -> Result<FocusPolicy, _>`, `async get_effective_new_window_placement_strategy() -> Result<NewWindowPlacementStrategy, _>`.
- **Implementierung `DefaultWindowManagementPolicyService`**: Hält `Arc<dyn GlobalSettingsService>`.

#### 1.7. Modul: `domain::common_events`

Definition von Domänen-übergreifenden Events.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`

##### 1.7.1. Datenstrukturen (`domain::common_events::events`)

- `UserActivityType`: Enum (`MouseMoved`, `MouseClicked`, `MouseWheelScrolled`, `KeyPressed`, `TouchInteraction`, `WorkspaceSwitched`, `ApplicationFocused`, `WindowOpened`, `WindowClosed`).
- `UserActivityDetectedEvent`: Felder `event_id: Uuid`, `timestamp: DateTime<Utc>`, `activity_type: UserActivityType`, `current_session_state: UserSessionState`, `active_application_id: Option<ApplicationId>`, `active_workspace_id: Option<WorkspaceId>`.
- `ShutdownReason`: Enum (`UserRequest`, `PowerButtonPress`, `LowBattery`, `SystemUpdate`, `ApplicationRequest`, `OsError`, `Unknown`).
- `SystemShutdownInitiatedEvent`: Felder `event_id: Uuid`, `timestamp: DateTime<Utc>`, `reason: ShutdownReason`, `is_reboot: bool`, `delay_seconds: Option<u32>`, `message: Option<String>`.

#### 1.8. Modul: `domain::shared_types`

Wiederverwendbare domänenspezifische Typen.

- **Referenzierte Dokumente:** `B3 Domänenschicht.md`

##### 1.8.1. Datenstrukturen (`domain::shared_types::types`)

- `ApplicationId`: Wrapper für `String`.
- `UserSessionState`: Enum (`Active`, `Locked`, `Idle`).
- `ResourceIdentifier`: Felder `r#type: String`, `id: String`, `label: Option<String>`.

### 2. Wayland/Smithay-Integration (Systemschicht-Perspektive)

Dieser Abschnitt beschreibt, wie die Systemschicht, insbesondere der Compositor, mit Wayland-Protokollen unter Verwendung von Smithay umgeht und mit der Domänenschicht interagiert.

- **Referenzierte Dokumente:** `C1 System Implementierungsplan.md` bis `C4 Systemschicht.md`, `3. System-Details.md`.

#### 2.1. Kern-Compositor-Struktur (`system::compositor::core::state::DesktopState`)

- `DesktopState` ist die zentrale Zustandsstruktur, die Smithay-Handler-Traits implementiert.
- **Wichtige Felder (Auswahl, basierend auf Smithay-Architektur):**
    - `display_handle: DisplayHandle`
    - `loop_handle: LoopHandle<'static, Self>`
    - `clock: Clock<u64>`
    - `compositor_state: CompositorState`
    - `shm_state: ShmState`
    - `xdg_shell_state: XdgShellState`
    - `output_manager_state: OutputManagerState`
    - `seat_state: SeatState<Self>`
    - `seat: Seat<Self>`
    - `data_device_state: DataDeviceState`
    - `space: Space<WindowElement>` (wobei `WindowElement` ein Enum ist, das `Wayland(Window)`, `X11(X11Surface)`, `Layer(LayerSurface)` wrappt)
    - `windows: HashMap<DomainWindowIdentifier, Arc<WindowElement>>` (Mapping von Domänen-IDs zu Compositor-Fenstern)
    - Domänen-Service-Handles: `Arc<dyn WindowManagementPolicyService>`, `Arc<dyn WorkspaceManagerService>`, `Arc<dyn GlobalSettingsService>`.
    - `event_bridge: Arc<SystemEventBridge>`

#### 2.2. Wayland-Protokoll-Implementierungen

- **`wl_compositor`, `wl_subcompositor`**: Gehandhabt durch `CompositorState` und `CompositorHandler` in `DesktopState`.
    - `CompositorHandler::commit(surface: &WlSurface)`:
        1. Aktualisiert `SurfaceData` (Puffer, Schaden).
        2. Informiert `domain::window_management_policy` oder `domain::workspaces` bei relevanten Änderungen (z.B. neue Puffergröße könnte Layout beeinflussen).
        3. Markiert Oberfläche für Neuzeichnung.
- **`wl_shm`**: Gehandhabt durch `ShmState` und `ShmHandler` in `DesktopState`.
    - `BufferHandler::buffer_destroyed(buffer: &WlBuffer)`: Informiert Renderer, Ressourcen freizugeben.
- **`xdg_shell` (`xdg_wm_base`, `xdg_surface`, `xdg_toplevel`, `xdg_popup`)**: Gehandhabt durch `XdgShellState` und `XdgShellHandler` in `DesktopState`.
    - `XdgShellHandler::new_toplevel(surface: ToplevelSurface)`:
        1. Erstellt `WindowElement::Wayland(Window::new(ToplevelKind::Xdg(surface))))`.
        2. Generiert `DomainWindowIdentifier`.
        3. Ruft `domain::window_management_policy::get_initial_window_geometry()` auf, um Position/Größe zu bestimmen.
        4. Ruft `domain::workspaces::assign_window_to_active_workspace()` auf.
        5. Konfiguriert und mappt das Fenster im `Space`.
    - `XdgShellHandler::map_toplevel(surface: &ToplevelSurface)`: Informiert `domain::workspaces`, Fenster als gemappt zu markieren.
    - Anfragen (`set_title`, `set_app_id`, `set_maximized`, `move`, `resize`) werden an `domain::window_management_policy` delegiert, um die Policy-konforme Reaktion zu bestimmen. Das Ergebnis wird dann auf das `ToplevelSurface` angewendet (`send_configure`).
    - **Domäne -> System**: `domain::window_management_policy` gibt `WorkspaceWindowLayout` zurück. `system::window_mechanics::apply_workspace_layout` iteriert über `window_geometries` und ruft `toplevel.send_configure(...)` für jedes Fenster auf.
- **`wlr-layer-shell-unstable-v1`**: Gehandhabt durch `WlrLayerShellState` und `LayerShellHandler`.
    - `LayerShellHandler::new_layer_surface(surface: LayerSurface, ...)`: Erstellt `WindowElement::Layer(surface)`. Informiert Domäne (ggf. spezifischer Service für Shell-Elemente), platziert im `Space` gemäß Layer-Regeln.
- **`wl_output` / `xdg-output-unstable-v1`**: Gehandhabt durch `OutputManagerState`.
    - Änderungen an Outputs (Hotplug, Modusänderung) werden von `OutputHandler` verarbeitet.
    - Meldet Änderungen an `domain::global_settings_and_state_management` (um z.B. Persistenz anzustoßen) und `domain::workspaces` (kann Layout beeinflussen).
    - `system::outputs::output_manager` implementiert `wlr-output-management-unstable-v1`.
        - `apply()`: Ruft `Output::change_current_state()`. Domäne wird über `OutputConfigurationChangedEvent` informiert.
- **`wl_seat` / Eingabeprotokolle**: Gehandhabt durch `SeatState`, `SeatHandler`, `KeyboardHandle`, `PointerHandle`, `TouchHandle`.
    - Eingabe-Events von `system::input` (Libinput) werden verarbeitet.
    - `SeatHandler::focus_changed(seat: &Seat<Self>, focused: Option<&WlSurface>)`:
        1. Identifiziert `DomainWindowIdentifier` für `focused_surface`.
        2. Informiert `domain::window_management_policy` oder `domain::workspaces` über Fokusänderung.
    - `KeyboardHandle::input(keycode, state, ...)`: Sendet `wl_keyboard.key`.
    - `PointerHandle::motion(...)`: Sendet `wl_pointer.motion`, `enter`, `leave`.
    - **Domäne -> System**: `domain::window_management_policy` kann Fokuswechsel anstoßen. `system::window_mechanics::set_application_focus` ruft `keyboard.set_focus(...)`.

#### 2.3. Smithay-Typen und ihre Verwendung

- **`DisplayHandle`**: Zentrales Handle zur Wayland-Display-Instanz. Wird für die Erstellung von Globals, Client-Kommunikation etc. verwendet.
- **`CompositorState`**: Verwaltet `wl_compositor` und `wl_subcompositor` Globals und Client-Zustände.
- **`ShmState`**: Verwaltet `wl_shm` Global und SHM-Puffer.
- **`XdgShellState`**: Verwaltet `xdg_wm_base` Global und XDG-Oberflächen.
- **`OutputManagerState`**: Verwaltet `wl_output` und `zxdg_output_v1` Globals.
- **`SeatState<DesktopState>` / `Seat<DesktopState>`**: Verwalten `wl_seat` und Eingabefähigkeiten. `SeatHandler` wird von `DesktopState` implementiert.
- **`KeyboardHandle`, `PointerHandle`, `TouchHandle`**: Abstraktionen für die Interaktion mit spezifischen Eingabegeräten des Seats.
- **`Space<WindowElement>`**: Smithay's 2D-Raum zur Verwaltung von Fenstern, deren Stapelreihenfolge und zum Rendern. `WindowElement` muss das `smithay::desktop::Window` Trait implementieren.
- **`SurfaceData` (aus `smithay::wayland::compositor`)**: Hängt an `WlSurface` und speichert Puffer, Rolle, Schaden etc. NovaDE wird dies um `novade_system::compositor::surface_management::SurfaceDataExt` (oder ähnliches in `UserDataMap`) erweitern, um anwendungsspezifische Daten wie `DomainWindowIdentifier` und Renderer-Textur-Handles zu speichern.
- **`ClientData` (aus `smithay::reexports::wayland_server::backend`)**: Hängt an `Client` und kann Client-spezifische Zustände speichern (z.B. `CompositorClientState`, `XdgWmBaseClientData`).

**Änderungen an Smithay-Typen und deren Konsequenzen:**

- Das Ändern von Smithay-Typen ist in der Regel nicht vorgesehen, da sie Teil der Bibliothek sind. Man erweitert sie durch UserData oder implementiert Handler-Traits.
- Wenn Smithay eine neue Version mit geänderten Typen veröffentlicht, müssen die Handler-Implementierungen und die Nutzung dieser Typen in NovaDE angepasst werden. Dies erfordert sorgfältige Migration und Tests.
- Das UserData-Muster (`UserDataMap` an `WlSurface`, `Client` etc.) ist der primäre Mechanismus, um anwendungsspezifische Daten mit Smithay-Objekten zu assoziieren, ohne die Typen selbst zu ändern.

#### 2.4. Kommunikation Domäne &lt;-> Compositor

- **Compositor (System) -> Domäne:**
    - **Events**:
        - Neues Fenster (`XdgShellHandler::new_toplevel`): Sendet `WindowCreatedEvent { domain_id, initial_geometry, app_id, title }` an `domain::workspaces::manager` oder einen allgemeinen Event-Bus.
        - Fenster geschlossen (`XdgShellHandler::toplevel_destroyed`): Sendet `WindowClosedEvent { domain_id }`.
        - Fokusänderung durch Benutzer (`SeatHandler::focus_changed`): Sendet `FocusChangedEvent { new_focus_domain_id, old_focus_domain_id }`.
        - Benutzereingabe für Befehlspalette: Sendet spezifisches Event oder ruft Domänen-Service direkt.
        - Output-Änderung (`OutputHandler`): Sendet `OutputConfigurationChangedEvent { ... }`.
    - **Service-Aufrufe (indirekt):** Bei bestimmten Aktionen kann der Compositor Domänenlogik benötigen, z.B. um Standardplatzierung für ein neues Fenster zu erfragen.
- **Domäne -> Compositor (System):**
    - **Service-Aufrufe**:
        - `domain::window_management_policy` gibt `WorkspaceWindowLayout` an `system::window_mechanics`.
        - `system::window_mechanics::apply_workspace_layout` ruft dann z.B. `toplevel_surface.send_configure(...)` oder `space.map_window(...)`.
        - `domain::workspaces::manager` ruft `system::window_mechanics::set_application_focus` auf.
    - Die Systemschicht stellt Traits bereit (z.B. `WindowManipulationApi`), die von Domänendiensten aufgerufen werden können, um Aktionen im Compositor auszulösen. Diese API-Aufrufe werden dann in spezifische Smithay-Operationen übersetzt.

### 3. Protokoll-Implementierungen (D-Bus, XDG Desktop Portals, MCP)

Die Systemschicht implementiert Clients und Server für diese Protokolle und integriert sie mit der Domänenschicht.

#### 3.1. D-Bus (`zbus`)

- **Module in `system::dbus_interfaces`**:
    - **`connection_manager`**: Stellt `DBusConnectionManager` bereit (`session_bus()`, `system_bus()`).
    - **Clients (`upower_client`, `logind_client`, `network_manager_client`, `secrets_service_client`, `policykit_client`)**:
        - Definieren `zbus::proxy` für die D-Bus-Interfaces.
        - Implementieren einen Service (z.B. `UPowerClientService`), der den Proxy nutzt.
        - Abonnieren D-Bus-Signale und konvertieren sie in interne `SystemLayerEvent`s (publiziert über `SystemEventBridge`) oder rufen direkt Domänen-Services auf.
        - Bieten `async` Methoden für die Domänenschicht, um D-Bus-Methoden aufzurufen oder Eigenschaften abzufragen.
    - **Server (`notifications_server`)**:
        - Implementiert das `org.freedesktop.Notifications` Interface mit `#[dbus_interface]`.
        - Ruft Methoden des `domain::user_centric_services::NotificationService`.
        - Abonniert Domänen-Events (`NotificationDismissedEvent`, `NotificationActionInvokedEvent`) und sendet entsprechende D-Bus-Signale (`NotificationClosed`, `ActionInvoked`).
        - Verwaltet ID-Mapping zwischen D-Bus `u32` und Domänen `Uuid`.
- **Integration Domäne**:
    - Domänendienste (z.B. `PowerManagementPolicy`) abonnieren die von D-Bus-Clients publizierten `SystemLayerEvent`s oder haben direkte Handles zu den Client-Services.
    - Domänendienste (z.B. `NotificationService`) werden von D-Bus-Server-Implementierungen aufgerufen.

#### 3.2. XDG Desktop Portals (`system::portals`)

- Implementiert Backend-Logik für ausgewählte Portale (FileChooser, Screenshot).
- Definiert einen Trait `SystemPortalInterface` (o.ä.), den die D-Bus-Objekte der Portale (die in einem separaten Prozess oder Dienst laufen könnten) aufrufen.
- **`FileChooser`**:
    - Empfängt `OpenFile` / `SaveFile` Anfrage von Portal D-Bus Objekt.
    - Sendet Befehl an UI-Schicht (via `SystemEventBridge` oder dedizierter Schnittstelle) zur Anzeige eines GTK-Dateidialogs.
    - Empfängt Ergebnis von UI und sendet es via D-Bus zurück.
- **`Screenshot`**:
    - Empfängt `Screenshot` / `PickColor` Anfrage.
    - Interagiert mit `system::compositor::screencopy` (für Screenshots) oder einer spezifischen Compositor-Funktion (für Farbpipette).
    - Sendet Ergebnis zurück.

#### 3.3. Model Context Protocol (MCP) (`system::mcp_client`)

- Implementiert den `SystemMcpService`-Trait.
- Nutzt `mcp_client_rs::McpClient`.
- **`connection_manager`**: Verwaltet Verbindungen zu MCP-Servern (`McpServerConfig`), startet lokale Prozesse, holt API-Keys via `secrets_service_client`.
- **`service::DefaultSystemMcpService`**:
    - Empfängt Anfragen von `domain::user_centric_services::AIInteractionLogicService` (z.B. `CallToolParams`).
    - Sendet Anfragen via `McpClient::send_request_json`.
    - Handhabt Timeouts.
    - Lauscht auf `McpClient::receive_message()` für Antworten und Notifications.
    - Konvertiert MCP-Antworten/Notifications in `McpClientSystemEvent`s und publiziert sie. `AIInteractionLogicService` abonniert diese Events.

### 4. Implementierbare Lösungen

#### 4.1. Code-Skizzen (Englisch)

Rust

```
// ==== Domain Layer: domain::workspaces::manager ====
// #[async_trait]
// pub trait WorkspaceManagerService: Send + Sync {
//     async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;
//     // ... other methods
// }

// pub struct DefaultWorkspaceManager {
//     internal: Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>,
// }

// impl WorkspaceManagerInternalState {
//     async fn set_active_workspace_impl(&mut self, id: WorkspaceId, current_active: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError> {
//         if !self.workspaces.contains_key(&id) {
//             return Err(WorkspaceManagerError::SetActiveWorkspaceNotFound(id));
//         }
//         if self.active_workspace_id == Some(id) {
//             return Ok(());
//         }
//         let old_id = self.active_workspace_id.take();
//         self.active_workspace_id = Some(id);
//         self.ordered_workspace_ids.retain(|ws_id| *ws_id != id);
//         self.ordered_workspace_ids.insert(0, id); // Example: move to front

//         let event = WorkspaceEvent::ActiveWorkspaceChanged { old_id, new_id: id };
//         if self.event_publisher.send(event).is_err() {
//             tracing::warn!("No active subscribers for ActiveWorkspaceChanged event.");
//         }
//         // self.save_configuration_internal_locked().await?; // Persist change
//         Ok(())
//     }
// }

// ==== System Layer: system::compositor::core::state::DesktopState ====
// impl SeatHandler for DesktopState {
//     type KeyboardFocus = WlSurface;
//     type PointerFocus = WlSurface;
//     type TouchFocus = WlSurface;

//     fn seat_state(&mut self) -> &mut SeatState<Self> {
//         &mut self.seat_state
//     }

//     fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&WlSurface>) {
//         let new_focus_domain_id = focused.and_then(|s| {
//             // Logic to get DomainWindowIdentifier from WlSurface UserData
//             // Example: s.data_map().get::<SurfaceDataExt>().map(|data_ext| data_ext.domain_id.clone())
//             None // Placeholder
//         });
//         tracing::debug!(seat = %seat.name(), new_focus = ?new_focus_domain_id, "Keyboard focus changed (Wayland)");

//         // Notify domain layer (e.g., window_management_policy or workspace_manager)
//         // This might involve sending an event through the SystemEventBridge or calling a domain service
//         // let event = SystemLayerEvent::InputFocusChanged { new_focus_domain_id };
//         // self.event_bridge.publish(event);

//         // For XDG Shell activation (simplified)
//         if let Some(surface_to_activate) = focused {
//             if let Some(toplevel) = self.space.window_for_surface(surface_to_activate, WindowSurfaceType::TOPLEVEL)
//                 .and_then(|win_elem| match win_elem.as_ref() { // Assuming WindowElement is Arc<ManagedWindow>
//                     WindowElement::Wayland(w) => w.toplevel().ok(),
//                     _ => None,
//                 }) {
//                 toplevel.send_configure(); // To signal state change (active)
//             }
//         }
//         // Deactivate previously focused window
//         // ...
//     }

//     fn cursor_image(&mut self, _seat: &Seat<Self>, image: CursorImageStatus) {
//         // Update self.current_cursor_status for the renderer
//         // *self.current_cursor_status.lock().unwrap() = image;
//         // self.damage_cursor_area(); // Signal renderer to update cursor
//     }
// }

// ==== System Layer: system::dbus_interfaces::upower_client::service ====
// #[async_trait]
// pub trait SystemUPowerClient: Send + Sync {
//    async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError>;
// }

// pub struct UPowerClientService {
//     proxy: UPowerProxy<'static>, // Generated by zbus
//     event_publisher: Arc<SystemEventBridge>,
// }

// impl UPowerClientService {
//     pub async fn new(conn: Arc<Connection>, event_publisher: Arc<SystemEventBridge>) -> Result<Self, DBusInterfaceError> {
//         let proxy = UPowerProxy::new(&conn).await?;
//         let client = Self { proxy, event_publisher };
//         client.start_signal_listeners().await?;
//         Ok(client)
//     }

//     async fn start_signal_listeners(&self) -> Result<(), DBusInterfaceError> {
//         let mut props_changed_stream = self.proxy.receive_properties_changed().await?;
//         let publisher_clone = self.event_publisher.clone();
//         let proxy_clone = self.proxy.clone(); // Proxy is Arc-like or cloneable for tasks

//         tokio::spawn(async move {
//             while let Some(signal) = props_changed_stream.next().await {
//                 if let Ok(args) = signal.args() {
//                     if args.interface_name() == "org.freedesktop.UPower" {
//                         if let Some(Value::Bool(is_on_battery)) = args.changed_properties().get("OnBattery") {
//                             publisher_clone.publish(SystemLayerEvent::UPower(UPowerEvent::OnBatteryChanged(*is_on_battery)));
//                         }
//                         // Handle LidIsClosed, etc.
//                     }
//                 }
//             }
//         });
//         Ok(())
//     }
// }

// #[async_trait]
// impl SystemUPowerClient for UPowerClientService {
//     async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError> {
//         Ok(self.proxy.on_battery().await?)
//     }
// }
```

#### 4.2. Algorithmen

- **Token Resolution Pipeline (`domain::theming::logic`)**:
    1. Sammle Basis-Tokens (globale + Theme-Basis).
    2. Überschreibe mit Varianten-Tokens (Hell/Dunkel).
    3. Wende Akzentfarbe an (ersetze definierte Akzent-Token-IDs).
    4. Überschreibe mit Benutzer-Overrides.
    5. Löse rekursiv `TokenValue::Reference` auf:
        - Verfolge besuchten Pfad zur Zyklenerkennung.
        - Prüfe maximale Rekursionstiefe.
        - Bei fehlender Referenz: Fehler.
    6. Konvertiere alle Werte in finale CSS-Strings.
- **Fenster-Layout-Berechnung (`domain::window_management_policy`)**:
    - Für `TilingMode::Columns`:
        1. Ermittle verfügbare Breite (`available_area.width` - Summe der `gap_settings.window_inner` - `2 * gap_settings.screen_outer_horizontal`).
        2. Teile verfügbare Breite durch Anzahl der zu kachelnden Fenster (`width_per_window`).
        3. Iteriere über Fenster, setze `width = width_per_window`, `height = available_area.height - 2 * gap_settings.screen_outer_vertical`. Positioniere sequentiell mit `gap_settings.window_inner`.
        4. Berücksichtige `WindowLayoutInfo.requested_min_size` und `WindowPolicyOverrides`.
- **Wayland Event zu Domänen-Event (`system::compositor` Handler)**:
    - Beispiel `XdgShellHandler::new_toplevel`:
        1. Wayland-Client sendet `xdg_wm_base.get_xdg_surface` und `xdg_surface.get_toplevel`.
        2. Smithay ruft `XdgShellHandler::new_toplevel(toplevel_surface)`.
        3. Handler in `DesktopState`:
            - Generiert `DomainWindowIdentifier`.
            - Ruft `domain_service.get_initial_window_geometry(domain_id, client_hints)`.
            - Ruft `domain_service.assign_window_to_active_workspace(domain_id)`.
            - Erstellt `WindowElement`, fügt zu `DesktopState.space` und `DesktopState.windows` hinzu.
            - Sendet `configure` Event an `toplevel_surface` mit der von der Domäne bestimmten Geometrie.
            - Publiziert `SystemLayerEvent::WindowCreated` über `SystemEventBridge`.

#### 4.3. Relevante Rust-Bibliotheken

- **Domänenschicht**: `uuid`, `chrono`, `serde`, `serde_json`, `thiserror`, `async-trait`, `tokio` (für `sync`-Primitive wie `Mutex`, `RwLock`, `broadcast`).
- **Systemschicht**:
    - Compositor: `smithay`, `wayland-server`, `wayland-protocols`, `calloop`, `tracing`.
    - Input: `libinput` (C-Lib), `input-rs` (Rust-Bindings für libinput, wird von Smithay genutzt), `xkbcommon` (C-Lib), `xkbcommon-rs` (Rust-Bindings).
    - D-Bus: `zbus`.
    - Audio: `pipewire` (C-Lib), `pipewire-rs` (Rust-Bindings).
    - MCP: `mcp_client_rs`.
    - XDG Portals: `ashpd` (als Referenz oder Nutzung, wenn es Backend-Logik für Portalserver bereitstellt, sonst direkte `zbus`-Implementierung der Portal-D-Bus-Interfaces).
- **Kernschicht**: `thiserror`, `tracing`, `tracing-subscriber`, `serde`, `toml`, `once_cell`, `uuid`, `chrono`.

#### 4.4. Annahmen, Einschränkungen, Alternativen

- **Annahme**: Die `novade-core` Schicht stellt alle spezifizierten Typen (`RectInt`, `Color`, `CoreError`, `ConfigError`, Logging-Init) bereit.
- **Annahme**: Ein `SystemEventBridge` (basierend auf `tokio::sync::broadcast`) existiert für die interne Event-Kommunikation in der Systemschicht und als Adapter zur Domänenschicht.
- **Annahme**: Die Domänenschicht-Services sind `async` und hinter `Arc<dyn TraitName>` zugänglich.
- **Einschränkung**: Detaillierte GPU-Interaktion und Renderer-Implementierung sind noch nicht spezifiziert.
- **Einschränkung**: Komplexität des XWayland-Managements ist nur angedeutet.
- **Alternative (D-Bus)**: `dbus-rs` (älter, synchron) vs. `zbus` (modern, async). `zbus` wird bevorzugt.
- **Alternative (Compositor)**: Direkte Nutzung von `libweston` (C) wäre komplexer in Rust zu integrieren als Smithay.

### 5. Maximale Detailtiefe

Die Spezifikationen versuchen, für jedes Modul und jede Interaktion die folgenden Details abzudecken:

- **Datenstrukturen**: Alle Felder mit exakten Rust-Typen, Sichtbarkeitsmodifikatoren, abgeleitete Traits (`Debug`, `Clone`, `Serialize`, etc.), Invarianten.
- **APIs (Traits/Funktionen)**: Exakte Signaturen (Parameter mit Name und Typ, Rückgabetyp, `async`, `Send`, `Sync`). Vor- und Nachbedingungen.
- **Events**: Struktur des Event-Payloads (alle Felder und Typen). Wer publiziert, wer abonniert (typischerweise). Auslösebedingungen.
- **Fehler**: Spezifische Fehler-Enums pro Modul (`thiserror`), jede Variante mit Bedeutung und ggf. `#[source]` oder `#[from]`.
- **Logik/Algorithmen**: Schritt-für-Schritt-Beschreibung kritischer Abläufe.
- **Interaktionen**: Klare Definition, wie Module und Schichten über APIs und Events kommunizieren.

Diese Detailtiefe zielt darauf ab, Interpretationsspielraum zu minimieren und eine direkte, konsistente Implementierung zu ermöglichen.

---

**Anmerkung zu den bereitgestellten Code-Skizzen:** Die Code-Skizzen sind zur Veranschaulichung und nicht als vollständig kompilierbarer oder fehlerfreier Code gedacht. Sie dienen dazu, die Struktur, Typen und Interaktionen gemäß der Spezifikation aufzuzeigen. Die tatsächliche Implementierung erfordert weitere Details, Fehlerbehandlung und Tests. `block_on` in Smithay-Handlern ist zu vermeiden; stattdessen sollten synchrone Domänenaufrufe oder eine Umstrukturierung für `async` erfolgen. Die Verwendung von `Arc<Mutex<DesktopState>>` und dessen Weitergabe an `tokio::spawn` muss sorgfältig auf Thread-Sicherheit und Deadlocks geprüft werden; oft sind spezifische Daten zu extrahieren oder Kanäle für die Kommunikation mit dem Haupt-Compositor-Thread zu verwenden.


## Technische Spezifikation der Domänenschicht

Basierend auf den bereitgestellten Dokumenten ("Domänenschicht: Theming-Engine – Ultra-Feinspezifikation (Teil 1/4)", "Domänenschicht: Implementierungsleitfaden Teil 2/4 – Workspaces (domain::workspaces)", "Domänenschicht: Detaillierte Spezifikation – Teil 3/4: Benutzerzentrierte Dienste und Globale Einstellungsverwaltung" und "Domänenschicht (Domain Layer) – Teil 4/4: Einstellungs- und Benachrichtigungs-Subsysteme" ) wird hiermit eine eigenständige, konkrete und ausführliche technische Spezifikation für die Entwicklung der Domänenschicht erstellt. Diese Spezifikation beinhaltet allgemeine Entwicklungsrichtlinien sowie spezifische Details zu den einzelnen Modulen der Domänenschicht.

### 1. Allgemeine Prinzipien und Entwicklungsrichtlinien der Domänenschicht

Die Domänenschicht ist das Herzstück der Anwendungslogik und repräsentiert die Geschäftsregeln und -konzepte der Desktop-Umgebung. Sie ist UI-unabhängig und entkoppelt von spezifischen Systemdetails oder Infrastrukturbelangen.

**Entwicklungsrichtlinien:**

- **Sprache und Tooling:** Rust wird als primäre Programmiersprache verwendet.
    - **Fehlerbehandlung:** `thiserror` wird für die Definition spezifischer, benutzerdefinierter Fehler-Enums pro Modul verwendet. Dies ermöglicht eine klare Kommunikation von Fehlerzuständen. Fehler werden über `Result<T, E>` zurückgegeben; `unwrap()` und `expect()` sind zu vermeiden, außer in absoluten Ausnahmefällen. Die `source()`-Kette von Fehlern soll durch korrekte Verwendung von `#[source]` und `#[from]` erhalten bleiben.
        
    - **Serialisierung/Deserialisierung:** `serde` (mit `serde_json` für JSON) wird für das Laden und Speichern von Konfigurationen und Datenstrukturen verwendet. Attribute wie `#[serde(rename_all = "kebab-case")]`, `#[serde(default)]` und `#[serde(skip_serializing_if = "Option::is_none")]` sollen konsistent genutzt werden.
        
    - **Asynchronität:** Wo Operationen potenziell blockierend sind (z.B. I/O beim Laden von Konfigurationen, Kommunikation mit externen Diensten), werden `async/await` und `async_trait` verwendet. Für nebenläufigen Zugriff auf geteilte Zustände sind `tokio::sync` Mechanismen wie `RwLock` und `Mutex` einzusetzen.
        
    - **Eindeutige IDs:** `uuid` (Version 4) wird zur Generierung eindeutiger Identifikatoren für Entitäten verwendet.
        
    - **Zeitstempel:** `chrono::DateTime<Utc>` wird für Zeitstempel verwendet, um Konsistenz zu gewährleisten.
        
    - **Event-Handling:** `tokio::sync::broadcast` wird für ein entkoppeltes, internes Event-System genutzt, um Änderungen an andere Systemteile zu kommunizieren.
        
- **Modularität und Kohäsion:** Die Domänenschicht ist in klar abgegrenzte Module unterteilt, die jeweils spezifische Verantwortlichkeiten haben (z.B. `domain::theming`, `domain::workspaces`, `domain::user_centric_services`, `domain::global_settings_and_state_management`, `domain::notifications_core`, `domain::notifications_rules`). Jedes Modul sollte eine hohe Kohäsion aufweisen und lose mit anderen Modulen gekoppelt sein.
    
- **Typsicherheit:** Newtypes und spezifische Enums werden verwendet, um die Typsicherheit zu erhöhen und die Semantik von Daten klarer zu gestalten (z.B. `TokenIdentifier`, `WorkspaceId`, `SettingKey` ).
    
- **Abstraktion und Schnittstellen:** Öffentliche APIs von Modulen werden oft durch Traits definiert, um Implementierungsdetails zu kapseln und Testbarkeit durch Mocking zu ermöglichen (z.B. `AIInteractionLogicService`, `NotificationService`, `GlobalSettingsService`, `SettingsProvider` ).
    
- **Zustandsverwaltung:** Veränderliche Zustände innerhalb von Services werden typischerweise mit `Arc<Mutex<...>>` oder `Arc<RwLock<...>>` gekapselt, um Thread-Sicherheit zu gewährleisten.
    
- **Validierung:** Eingabedaten und Einstellungsänderungen werden aktiv validiert, um die Konsistenz und Integrität der Domänendaten sicherzustellen.
    
- **Logging:** Das `tracing`-Framework soll für strukturiertes Logging und Debugging verwendet werden.
    
- **Dokumentation:** Öffentliche Typen, Methoden und Felder müssen umfassend mit `rustdoc`-Kommentaren dokumentiert werden, inklusive Vor- und Nachbedingungen, Fehler und Beispiele.
    
- **Testbarkeit:** Unit-Tests sind parallel zur Implementierung zu erstellen und sollen eine hohe Codeabdeckung anstreben. Mocking von Abhängigkeiten (insbesondere von Schnittstellen zur Kern- oder Systemschicht) ist entscheidend.
    

### 2. Struktur und Kernkomponenten der Domänenschicht

Die Domänenschicht besteht aus mehreren Kernmodulen, die spezifische Aufgabenbereiche abdecken:

#### 2.1. Modul: `domain::theming`

- **Verantwortlichkeit:** Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel (Farbschema, Akzentfarben).
    
- **Datenstrukturen:**
    - `TokenIdentifier` (String-Wrapper für hierarchische Token-IDs wie "color.background.primary").
        
    - `TokenValue` (Enum für Token-Wertetypen: Color, Dimension, FontSize, FontFamily, FontWeight, LineHeight, LetterSpacing, Border, Shadow, Radius, Spacing, ZIndex, Opacity, Text, Reference zu anderem Token).
        
    - `RawToken` (Struct: id, value, optionale description, group).
        
    - `TokenSet` (Typalias für `HashMap<TokenIdentifier, RawToken>`).
        
    - `ThemeIdentifier` (String-Wrapper für Theme-IDs).
        
    - `ColorSchemeType` (Enum: Light, Dark).
        
    - `AccentColor` (Struct: optionaler name, value als CSS-Farbwert).
        
    - `ThemeVariantDefinition` (Struct: applies_to_scheme, tokens als TokenSet für Überschreibungen).
        
    - `ThemeDefinition` (Struct: id, name, description, author, version, base_tokens, variants, supported_accent_colors).
        
    - `AppliedThemeState` (Struct: theme_id, color_scheme, active_accent_color, resolved_tokens als `HashMap<TokenIdentifier, String>`).
        
    - `ThemingConfiguration` (Struct: selected_theme_id, preferred_color_scheme, selected_accent_color, custom_user_token_overrides).
        
- **Kernlogik (`ThemingEngine` Service):**
    
    - Laden, Parsen und Validieren von Token- (_.tokens.json) und Theme-Definitionen (_.theme.json) von standardisierten Pfaden (System- und Benutzer-spezifisch). Validierung beinhaltet Eindeutigkeit von Token-IDs und Erkennung zyklischer Referenzen.
        
    - Token Resolution Pipeline: Auflösung von Token-Referenzen und Anwendung von Überschreibungen (Theme-Basis, Variante, Akzentfarbe, Benutzer-Overrides) in definierter Reihenfolge. Ergebnis ist der `AppliedThemeState`.
        
    - Dynamische Theme-Wechsel basierend auf Änderungen in `ThemingConfiguration`.
        
    - Caching von aufgelösten `AppliedThemeState`s.
        
- **Öffentliche API (`ThemingEngine`):**
    - `new(initial_config, theme_load_paths, token_load_paths)`: Konstruktor.
        
    - `get_current_theme_state()`: Gibt aktuellen `AppliedThemeState` zurück.
        
    - `get_available_themes()`: Gibt `Vec<ThemeDefinition>` zurück.
        
    - `get_current_configuration()`: Gibt aktuelle `ThemingConfiguration` zurück.
        
    - `update_configuration(new_config)`: Aktualisiert Konfiguration und löst Neuberechnung aus.
        
    - `reload_themes_and_tokens()`: Lädt alle Definitionen neu.
        
    - `subscribe_to_theme_changes()`: Gibt einen `mpsc::Receiver<ThemeChangedEvent>` zurück.
        
- **Events:** `ThemeChangedEvent { new_state: AppliedThemeState }`.
    
- **Fehlerbehandlung:** `ThemingError` Enum (z.B. `TokenFileParseError`, `CyclicTokenReference`, `ThemeNotFound`, `MissingTokenReference`).
    
- **Dateistruktur:** `domain/theming/{mod.rs, types.rs, errors.rs, logic.rs, default_themes/}`.
    

#### 2.2. Modul: `domain::workspaces`

Verantwortlich für die Logik und Verwaltung von Arbeitsbereichen ("Spaces" oder virtuelle Desktops). Unterteilt in `core`, `assignment`, `manager`, und `config`.

- **`workspaces::core`**: Fundamentale Workspace-Definition.
    
    - **Datenstrukturen:**
        - `WorkspaceId` (Typalias für `uuid::Uuid`).
            
        - `WindowIdentifier` (Newtype für `String`, repräsentiert Fenster-IDs).
            
        - `WorkspaceLayoutType` (Enum: Floating, TilingHorizontal, TilingVertical, Maximized; Default: Floating).
            
        - `Workspace` (Struct: id, name, persistent_id, layout_type, window_ids: `HashSet<WindowIdentifier>`, created_at). Validierungen für `name` (nicht leer, Maximallänge) und `persistent_id`.
            
    - **API (`impl Workspace`):** `new()`, `id()`, `name()`, `rename()`, `layout_type()`, `set_layout_type()`, `add_window_id()` (crate-intern), `remove_window_id()` (crate-intern), `window_ids()`, `persistent_id()`, `set_persistent_id()`, `created_at()`.
        
    - **Event-Payloads (Definiert in `core::event_data`):** `WorkspaceRenamedData`, `WorkspaceLayoutChangedData`, `WindowAddedToWorkspaceData`, `WindowRemovedFromWorkspaceData`, `WorkspacePersistentIdChangedData`.
        
    - **Fehlerbehandlung:** `WorkspaceCoreError` (z.B. `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`).
        
- **`workspaces::assignment`**: Logik zur Fensterzuweisung.
    
    - **API (Freistehende Funktionen):**
        - `assign_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, target_workspace_id, window_id, ensure_unique_assignment: bool)`
            
        - `remove_window_from_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id, window_id)`
            
        - `move_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id, target_workspace_id, window_id)`
            
        - `find_workspace_for_window(workspaces: &HashMap<WorkspaceId, Workspace>, window_id) -> Option<WorkspaceId>`
            
    - **Fehlerbehandlung:** `WindowAssignmentError` (z.B. `WorkspaceNotFound`, `WindowAlreadyAssigned`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation`).
        
- **`workspaces::manager`**: Orchestrierung und übergeordnete Verwaltung.
    
    - **Zustand (`WorkspaceManager` Struct):** `workspaces: HashMap<WorkspaceId, Workspace>`, `active_workspace_id: Option<WorkspaceId>`, `ordered_workspace_ids: Vec<WorkspaceId>`, `next_workspace_number`, `config_provider: Arc<dyn WorkspaceConfigProvider>`, `event_publisher: Arc<dyn EventPublisher<WorkspaceEvent>>`, `ensure_unique_window_assignment: bool`.
        
    - **API (`impl WorkspaceManager`):** `new()`, `create_workspace()`, `delete_workspace()`, `get_workspace()`, `get_workspace_mut()`, `all_workspaces_ordered()`, `active_workspace_id()`, `set_active_workspace()`, `assign_window_to_active_workspace()`, `assign_window_to_specific_workspace()`, `remove_window_from_its_workspace()`, `move_window_to_specific_workspace()`, `rename_workspace()`, `set_workspace_layout()`, `save_configuration()`.
        
    - **Events (`WorkspaceEvent` Enum):** `WorkspaceCreated`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, `WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WindowAddedToWorkspace`, `WindowRemovedFromWorkspace`, `WorkspaceOrderChanged`, `WorkspacesReloaded`, `WorkspacePersistentIdChanged`.
        
    - **Fehlerbehandlung:** `WorkspaceManagerError` (z.B. `WorkspaceNotFound`, `CannotDeleteLastWorkspace`, `NoActiveWorkspace`, Wraps: `WorkspaceCoreError`, `WindowAssignmentError`, `WorkspaceConfigError`).
        
- **`workspaces::config`**: Konfigurations- und Persistenzlogik.
    
    - **Datenstrukturen (Snapshots für Persistenz):**
        - `WorkspaceSnapshot` (Struct: persistent_id, name, layout_type).
            
        - `WorkspaceSetSnapshot` (Struct: workspaces: `Vec<WorkspaceSnapshot>`, active_workspace_persistent_id).
            
    - **Schnittstelle (`WorkspaceConfigProvider` Trait):**
        - `load_workspace_config() -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>`
            
        - `save_workspace_config(config_snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>`
            
    - **Beispielimplementierung:** `FilesystemConfigProvider` (nutzt `core::config::ConfigService`).
        
    - **Fehlerbehandlung:** `WorkspaceConfigError` (z.B. `LoadError`, `SaveError`, `InvalidData`, `SerializationError`, `DeserializationError`, `PersistentIdNotFound`, `DuplicatePersistentId`).
        

#### 2.3. Modul: `domain::user_centric_services`

Bündelt Logik für KI-Interaktionen (inkl. Einwilligungsmanagement) und ein umfassendes Benachrichtigungssystem.

- **KI-Interaktionsmanagement:**
    - **Datenstrukturen:**
        - `AIInteractionContext` (Struct: id: Uuid, creation_timestamp, active_model_id, consent_status: `AIConsentStatus`, associated_data_categories: `Vec<AIDataCategory>`, interaction_history, attachments: `Vec<AttachmentData>`).
            
        - `AIConsent` (Struct: id: Uuid, user_id, model_id, data_categories: `Vec<AIDataCategory>`, granted_timestamp, expiry_timestamp, is_revoked).
            
        - `AIModelProfile` (Struct: model_id, display_name, description, provider, required_consent_categories: `Vec<AIDataCategory>`, capabilities).
            
        - `AttachmentData` (Struct: id: Uuid, mime_type, source_uri, content, description).
            
        - `AIConsentStatus` (Enum: Granted, Denied, PendingUserAction, NotRequired).
            
        - `AIDataCategory` (Enum: UserProfile, ApplicationUsage, FileSystemRead, ClipboardAccess, LocationData, GenericText, GenericImage).
            
    - **API (`AIInteractionLogicService` Trait):** `initiate_interaction()`, `get_interaction_context()`, `provide_consent()`, `get_consent_for_model()`, `add_attachment_to_context()`, `list_available_models()`, `store_consent()`, `get_all_user_consents()`, `load_model_profiles()`.
        
    - **Events:** `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`.
        
    - **Fehlerbehandlung:** `AIInteractionError` (z.B. `ContextNotFound`, `ConsentRequired`, `ModelNotFound`, `ConsentStorageError`, `ModelProfileLoadError`).
        
- **Benachrichtigungsmanagement:**
    - **Datenstrukturen:**
        - `Notification` (Struct: id: Uuid, application_name, application_icon, summary, body, actions: `Vec<NotificationAction>`, urgency: `NotificationUrgency`, timestamp, is_read, is_dismissed, transient).
            
        - `NotificationAction` (Struct: key, label, action_type: `NotificationActionType`).
            
        - `NotificationUrgency` (Enum: Low, Normal, Critical).
            
        - `NotificationActionType` (Enum: Callback, OpenLink).
            
        - `NotificationFilterCriteria` (Enum: Unread, Application(String), Urgency(NotificationUrgency)).
            
        - `NotificationSortOrder` (Enum: TimestampAscending, TimestampDescending, Urgency).
            
    - **API (`NotificationService` Trait):** `post_notification()`, `get_notification()`, `mark_as_read()`, `dismiss_notification()`, `get_active_notifications()`, `get_notification_history()`, `clear_history()`, `set_do_not_disturb()`, `is_do_not_disturb_enabled()`, `invoke_action()`.
        
    - **Events:** `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent`.
        
    - **Fehlerbehandlung:** `NotificationError` (z.B. `NotFound`, `InvalidData`, `HistoryFull`, `ActionNotFound`).
        
- **Dateistruktur:** `domain/user_centric_services/{mod.rs, ai_interaction_service.rs, notification_service.rs, types.rs, errors.rs}`.
    

#### 2.4. Modul: `domain::global_settings_and_state_management` (auch `domain::settings_core` + `domain::settings_persistence_iface`)

Verantwortlich für die Repräsentation, Verwaltung und Konsistenz globaler Desktop-Einstellungen.

- **`domain::settings_core`**: Kernlogik der Einstellungsverwaltung.
    
    - **Datenstrukturen:**
        - `SettingKey` (Newtype für `String`, für Einstellungsschlüssel wie "appearance.theme.name").
            
        - `SettingValue` (Enum: Boolean, Integer, Float, String, Color, FilePath, List, Map).
            
        - `SettingMetadata` (Struct: description, default_value, value_type_hint, possible_values, validation_regex, min_value, max_value, is_sensitive, requires_restart).
            
        - `Setting` (Struct: id: Uuid, key, current_value, metadata, last_modified, is_dirty).
            
        - `GlobalDesktopSettings` (Hauptstruktur, die alle globalen Einstellungen kategorisiert, z.B. `AppearanceSettings`, `WorkspaceSettings`, `InputBehaviorSettings`, `PowerManagementPolicySettings`, `DefaultApplicationsSettings`). Jede Unterstruktur enthält spezifische Einstellungsfelder.
            
        - `SettingPath` (Enum-Hierarchie zur typsicheren Adressierung von Einstellungen, z.B. `SettingPath::Appearance(AppearanceSettingPath::FontSettings(FontSettingPath::DefaultFontSize))`).
            
    - **API (`SettingsCoreManager` oder `GlobalSettingsService` Trait):**
        - `new(provider, initial_metadata, event_channel_capacity)` / `load_settings()`
            
        - `save_settings()`
            
        - `get_current_settings()` / `get_setting_value(key)` / `get_setting(path)`
            
        - `set_setting_value(key, value)` / `update_setting(path, value: JsonValue)`
            
        - `reset_setting_to_default(key)` / `reset_to_defaults()`
            
        - `register_setting_metadata(key, metadata)`
            
        - `get_all_settings_with_metadata()`
            
        - `subscribe_to_changes()` / `subscribe_to_setting_changes()`
            
    - **Events:** `SettingChangedEvent { key/path, new_value }`, `SettingsLoadedEvent { settings }`, `SettingsSavedEvent`.
        
    - **Fehlerbehandlung:** `SettingsCoreError` / `GlobalSettingsError` (z.B. `SettingNotFound`, `ValidationError`, `PersistenceError`, `PathNotFound`, `InvalidValueType`).
        
- **`domain::settings_persistence_iface`**: Persistenzabstraktion.
    
    - **Schnittstelle (`SettingsProvider` Trait):**
        - `load_setting(key) -> Result<Option<SettingValue>, SettingsPersistenceError>`
            
        - `save_setting(key, value) -> Result<(), SettingsPersistenceError>`
            
        - `load_all_settings() -> Result<Vec<(SettingKey, SettingValue)>, SettingsPersistenceError>`
            
        - `delete_setting(key) -> Result<(), SettingsPersistenceError>`
            
        - `setting_exists(key) -> Result<bool, SettingsPersistenceError>`
            
    - **Fehlerbehandlung:** `SettingsPersistenceError` (z.B. `BackendUnavailable`, `StorageAccessError`, `SerializationError`, `DeserializationError`, `IoError`).
        
- **Dateistruktur (Global Settings):** `domain/global_settings_management/{mod.rs, service.rs, types.rs, paths.rs, errors.rs}`.
    
- **Dateistruktur (Settings Core & Persistence Interface):** `domain/src/settings_core/{mod.rs, types.rs, error.rs}`, `domain/src/settings_persistence_iface/{mod.rs, error.rs}`.
    

#### 2.5. Modul: `domain::notifications_rules`

Implementiert die Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln.

- **Verantwortlichkeit:** Definition von Benachrichtigungsregeln (`NotificationRule`), deren Bedingungen (`RuleCondition`) und Aktionen (`RuleAction`); Bereitstellung einer Engine (`NotificationRulesEngine`) zur Regelauswertung und -anwendung.
    
- **Datenstrukturen:**
    - `RuleCondition` (Enum: AppNameIs, AppNameMatches (Regex), SummaryContains, UrgencyIs, CategoryIs, HintExists, HintValueIs, SettingIsTrue, LogicalAnd, LogicalOr, LogicalNot etc.).
        
    - `RuleAction` (Enum: SuppressNotification, SetUrgency, AddAction, SetHint, PlaySound, MarkAsPersistent, SetExpiration, LogMessage etc.).
        
    - `NotificationRule` (Struct: id, description, conditions: `RuleCondition`, actions: `Vec<RuleAction>`, is_enabled, priority, stop_after).
        
- **Kernlogik (`NotificationRulesEngine` Service):**
    - Lädt und verwaltet Regeldefinitionen (sortiert nach Priorität).
        
    - `process_notification(notification)`: Wertet Regeln gegen eine eingehende Benachrichtigung aus.
        
        - Gibt `RuleProcessingResult` zurück: `Allow(modified_notification)` oder `Suppress(rule_id)`.
            
    - `evaluate_condition(condition, notification, rule)`: Rekursive Auswertung von Regelbedingungen. Interagiert mit `SettingsCoreManager` für `Setting*`-Bedingungen.
        
    - `apply_action(action, notification, rule)`: Anwendung von Regelaktionen auf eine Benachrichtigung.
        
    - Reagiert auf `SettingChangedEvent` (optional, zur Cache-Invalidierung oder Neubewertung).
        
- **Öffentliche API (`NotificationRulesEngine`):**
    - `new(settings_manager, initial_rules, settings_event_receiver)`
        
    - `load_rules(new_rules)`
        
    - `process_notification(notification) -> Result<RuleProcessingResult, NotificationRulesError>`
        
    - `handle_setting_changed(event)` (intern aufgerufen).
        
- **Fehlerbehandlung:** `NotificationRulesError` (z.B. `InvalidRuleDefinition`, `ConditionEvaluationError`, `ActionApplicationError`, `SettingsAccessError`).
    
- **Dateistruktur:** `domain/src/notifications_rules/{mod.rs, types.rs, error.rs}`.

### 3. Interaktionen und Abhängigkeiten

- **Domänenmodule untereinander:**
    - `NotificationCoreManager` nutzt `NotificationRulesEngine` zur Verarbeitung von Benachrichtigungen.
        
    - `NotificationRulesEngine` nutzt `SettingsCoreManager` (oder `GlobalSettingsService`), um regelbedingte Einstellungen abzufragen.
        
    - `ThemingEngine` reagiert auf `SettingChangedEvent` von `SettingsCoreManager` für themenrelevante Einstellungen.
        
    - Services aus `domain::user_centric_services` und `domain::workspaces` können globale Einstellungen von `GlobalSettingsService` lesen.
        
- **Abhängigkeiten zur Kernschicht (`core::*`):**
    - `core::config`: Wird von `domain::settings_persistence_iface`-Implementierungen und `domain::workspaces::config` für das Lesen/Schreiben von Konfigurationsdateien genutzt.
        
    - `core::errors`: Basisfehlertypen können in Domänenfehler gewrappt werden.
        
    - `core::types`: Fundamentale Typen wie `Uuid`, `DateTime<Utc>`.
        
    - `core::logging` (`tracing`): Wird für Logging verwendet.
        
- **Schnittstellen zu höheren Schichten (System- und UI-Schicht):**
    - Die Domänenschicht stellt ihre Funktionalität über öffentliche APIs (oft Traits) ihrer Service-Komponenten bereit.
        
    - Die UI-Schicht (z.B. `ui::control_center`, `ui::shell` ) konsumiert diese APIs und reagiert auf Events aus der Domänenschicht.
        
    - Die Systemschicht (z.B. MCP-Client, D-Bus Handler, Compositor ) interagiert ebenfalls mit den Domänendiensten und leitet Systemereignisse an diese weiter oder setzt deren Anweisungen um.
        

### 4. Zusammenfassende Betrachtungen

Die Domänenschicht ist als eine Sammlung modularer, voneinander entkoppelter Komponenten konzipiert, die jeweils klar definierte Verantwortlichkeiten besitzen. Durch die konsequente Anwendung von Prinzipien wie Typsicherheit, expliziter Fehlerbehandlung, Event-basierter Kommunikation und der Abstraktion von Persistenz- und UI-Belangen wird eine robuste, wartbare und erweiterbare Grundlage für die Desktop-Umgebung geschaffen. Die detaillierten Spezifikationen der einzelnen Module, ihrer Datenstrukturen, APIs und Fehlerfälle dienen als direkter Leitfaden für die Implementierung.

## Technische Spezifikation und Entwicklungsrichtlinien: Systemschicht

Die Systemschicht bildet das Fundament der Desktop-Umgebung und ist verantwortlich für die Kernfunktionalitäten, die Interaktion mit der Hardware und die Bereitstellung grundlegender Dienste für höhere Schichten. Sie implementiert die "Mechanik" der Desktop-Umgebung, indem sie übergeordnete Richtlinien und Benutzerinteraktionen in konkrete Systemaktionen übersetzt. Dies erfordert eine präzise und robuste Interaktion mit Wayland-Protokollen, D-Bus-Systemdiensten und potenziell direkter Hardware-Interaktion (z.B. DRM). Die Stabilität und Reaktionsfähigkeit der gesamten Umgebung hängt maßgeblich von der Zuverlässigkeit dieser Schicht ab. Daher sind Resilienz, asynchrone Operationen, umfassendes Fehlermanagement und sorgfältige Zustandssynchronisation zentrale Entwurfsprinzipien.

### 1. Entwicklungsrichtlinien

Die Entwicklung aller Komponenten der Systemschicht muss strengen Richtlinien folgen, um Konsistenz, Qualität und Wartbarkeit zu gewährleisten.

- **Programmiersprache:** Rust ist die primäre Programmiersprache.
    
- **Coding Style & Formatierung:** Verbindliche Nutzung von `rustfmt` mit Standardkonfiguration. Einhaltung der Rust API Guidelines ist erforderlich.
    
- **API-Design:** Befolgung der Rust API Guidelines Checklist für konsistente und idiomatische Schnittstellen.
    
- **Fehlerbehandlung:** Konsequente Verwendung des `thiserror`-Crates zur Definition spezifischer Fehler-Enums pro Modul (z.B. `CompositorCoreError`, `ShmError`, `XdgShellError`, `DBusError`, `OutputError`, `AudioError`, `McpError`, `PortalsError`). Alle öffentlichen Funktionen in den Modulen sollten `Result<T, SpecificError>` zurückgeben.
    
- **Logging & Tracing:** Einsatz des `tracing`-Crate-Frameworks (`tracing::{info, debug, error}`) für strukturiertes, kontextbezogenes Logging und Tracing von Operationen.
    
- **Dokumentkonventionen:** Eine Tabelle mit definierten Begriffen und Konventionen (z.B. `DesktopState`, `WlFoo`, `XdgFoo`) wird verwendet, um Klarheit und Konsistenz in der Terminologie sicherzustellen.
    
- **Asynchronität:** Asynchrone Operationen sind für alle potenziell blockierenden E/A-Vorgänge zu verwenden, insbesondere bei D-Bus-Aufrufen (mittels `zbus`) und Wayland-Ereignisverarbeitung.
    
- **Strikte Einhaltung der Gesamtspezifikation:** Die hier beschriebenen Spezifikationen sind eine detaillierte Erweiterung der "Technischen Gesamtspezifikation und Entwicklungsrichtlinien". Deren Einhaltung ist bindend.
    

### 2. Modul: `system::compositor` (Smithay-basierter Wayland Compositor)

Dieses Modul implementiert die Kernlogik des Wayland-Compositors unter Verwendung des Smithay-Toolkits. Es ist verantwortlich für die Verwaltung von Wayland-Client-Verbindungen, Oberflächen, Pufferbehandlung und die Integration mit Shell-Protokollen. Die Designphilosophie von Smithay erfordert ein signifikantes Zustandsmanagement innerhalb der zentralen `DesktopState`-Struktur.

#### 2.1. Submodul: `system::compositor::core`

Dieses Submodul etabliert die grundlegenden Elemente für die Verwaltung von Wayland-Oberflächen und die Kernoperationen des Compositors.

**Dateien:**

- `compositor_state.rs`:
    - **Zweck:** Definiert und verwaltet den primären Zustand für die Globals `wl_compositor` und `wl_subcompositor` und handhabt den Client-spezifischen Compositor-Zustand.
        
    - **Struktur `CompositorCoreError`:** Definiert Fehler spezifisch für Kernoperationen des Compositors mittels `thiserror`. Varianten umfassen `GlobalCreationFailed`, `RoleError`, `ClientDataMissing`, `SurfaceDataMissing`, `InvalidSurfaceState`.
        
    - **Struktur `DesktopState` (teilweise):** Kapselt den zentralen Zustand. Enthält `compositor_state: CompositorState`, `display_handle: DisplayHandle`, `loop_handle: LoopHandle<Self>`. Ein Konstruktor `new(display_handle, loop_handle)` initialisiert diese Felder.
        
    - **Struktur `ClientCompositorData`:** Speichert `CompositorClientState` pro Client.
        
    - **Implementierung `CompositorHandler` für `DesktopState`:** Delegiert Compositor-Ereignisse an die Anwendungslogik.
        
        - `compositor_state()`: Gibt `&mut self.compositor_state` zurück.
            
        - `client_compositor_state()`: Ruft `ClientCompositorData` aus `Client::get_data()` ab und gibt `&compositor_state` daraus zurück. Loggt Fehler und panicked bei fehlenden Daten.
            
        - `commit()`: Greift auf `SurfaceData` zu, prüft auf neue Puffer, aktualisiert Schadensverfolgung, löst rollenspezifische Logik aus und markiert die Oberfläche für Neuzeichnung. Verwendet `smithay::wayland::compositor::with_states`.
            
        - `new_surface()`: Initialisiert `SurfaceData` für die neue `WlSurface` und speichert sie in deren `data_map`. Fügt einen Zerstörungs-Hook hinzu.
            
        - `new_subsurface()`: Aktualisiert `SurfaceData` der neuen und der Eltern-Oberfläche, um die Eltern-Kind-Beziehung herzustellen.
            
        - `destroyed()`: Die primäre Bereinigung wird von Smithay gehandhabt. Externe Referenzen müssen hier oder über Zerstörungs-Hooks bereinigt werden.
            
    - **Implementierung `GlobalDispatch<WlCompositor, ()>` für `DesktopState`:**
        - `bind()`: Protokolliert die Bind-Anfrage, initialisiert bei Bedarf `ClientCompositorData` für den Client und initialisiert die Ressource mit `data_init.init()`. `CompositorState::new()` erstellt das Global.
            
    - **Implementierung `GlobalDispatch<WlSubcompositor, ()>` für `DesktopState`:**
        - `bind()`: Protokolliert die Bind-Anfrage und initialisiert die Ressource. `CompositorState::new()` erstellt das Global.
            
- `surface_management.rs`:
    - **Zweck:** Definiert `SurfaceData` und zugehörige Hilfsfunktionen.
        
    - **Struktur `SurfaceData`:** Gespeichert in der `UserDataMap` jeder `WlSurface`. Enthält Felder wie `id: uuid::Uuid`, `role: Option<String>`, `client_id`, `current_buffer`, `pending_buffer`, `texture_id` (als `Option<Box<dyn RenderableTexture>>`), `last_commit_serial`, `damage_regions_buffer_coords`, `opaque_region`, `input_region`, `user_data_ext`, `parent`, `children`, `pre_commit_hooks`, `post_commit_hooks`, `destruction_hooks`. `RenderableTexture` muss `Send + Sync` sein.
        
    - **Methoden für `SurfaceData`:** `new()`, `set_role()`, `get_role()`, `attach_buffer()`, `commit_buffer()`, `add_damage_buffer_coords()`, `take_damage_buffer_coords()`.
        
    - **Enum `SurfaceRoleError`:** Variante `RoleAlreadySet`.
        
    - **Funktionen:** `get_surface_data()`, `with_surface_data()` (kapselt Mutex-Locking), `give_surface_role()` (verwendet `smithay::wayland::compositor::give_role`), `get_surface_role()` (verwendet `smithay::wayland::compositor::get_role`).
        
- `global_objects.rs`:
    - **Zweck:** Zentralisiert die Erstellung der Kern-Wayland-Globals.
        
    - **Funktion `create_core_compositor_globals()`:** Erstellt `CompositorState` und speichert es in `DesktopState`. Dies registriert intern `wl_compositor` (Version 6) und `wl_subcompositor` (Version 1).
        

#### 2.2. Submodul: `system::compositor::shm` (SHM-Pufferbehandlung)

Dieses Submodul implementiert die Unterstützung für `wl_shm`, wodurch Clients Shared-Memory-Puffer mit dem Compositor teilen können.

**Dateien:**

- `shm_state.rs`:
    - **Zweck:** Verwaltet das `wl_shm`-Global und handhabt die Erstellung und den Zugriff auf SHM-Puffer.
        
    - **Struktur `ShmError`:** Definiert Fehler für SHM-Operationen (z.B. `PoolCreationFailed`, `BufferCreationFailed`, `InvalidFormat`, `AccessError`).
        
    - **`DesktopState` (teilweise):** Enthält `shm_state: ShmState` und `shm_global: GlobalId`.
        
    - **Implementierung `ShmHandler` für `DesktopState`:**
        - `shm_state()`: Gibt `&self.shm_state` zurück.
            
    - **Implementierung `BufferHandler` für `DesktopState`:** (Gilt für alle `wl_buffer`, nicht nur SHM)
        
        - `buffer_destroyed()`: Protokolliert, benachrichtigt das Rendering-Backend zur Ressourcenfreigabe und entfernt Puffer-Referenzen aus `SurfaceData`-Instanzen.
            
    - **Implementierung `GlobalDispatch<WlShm, ()>` für `DesktopState`:**
        - `bind()`: Protokolliert die Bindung und initialisiert die Ressource. `ShmState` sendet `format`-Ereignisse.
            
    - **Funktion `create_shm_global()`:** Definiert unterstützte SHM-Formate (Standard: ARGB8888, XRGB8888), erstellt `ShmState`, speichert `shm_state` und `shm_global` (zurückgegeben von `shm_state.global().clone()`) in `DesktopState`.
        
- `shm_buffer_access.rs`:
    - **Zweck:** Bietet sicheren Zugriff auf Inhalte von SHM-Puffern.
        
    - **Funktion `with_shm_buffer_contents()`:** Verwendet intern `smithay::wayland::shm::with_buffer_contents`, um einen Callback mit Zeiger und Länge der Pufferdaten aufzurufen. Kapselt die Unsicherheit der Zeiger-Dereferenzierung.
        

#### 2.3. Submodul: `system::compositor::xdg_shell` (XDG-Shell-Integration)

Implementiert das `xdg_shell`-Protokoll zur Verwaltung moderner Desktop-Fenster (Toplevels und Popups). Das Protokoll ist komplex und erfordert signifikante Logik in den Handler-Methoden, um Oberflächenzustände, Interaktionen mit der Fenstermanagement-Richtlinie und das Senden korrekter Wayland-Ereignisse zu verwalten. Eine robuste Fehlerbehandlung und Zustandsvalidierung sind entscheidend.

**Dateien:**

- `xdg_shell_state.rs`:
    - **Zweck:** Verwaltet das `xdg_wm_base`-Global und die zugehörigen XDG-Oberflächenzustände.
        
    - **Struktur `XdgShellError`:** Definiert Fehler wie `InvalidSurfaceRole`, `WindowHandlingError`, `PopupPositioningError`, `InvalidAckConfigureSerial`, `ToplevelNotFound`, `PopupNotFound`.
        
    - **`DesktopState` (teilweise):** Enthält `xdg_shell_state: XdgShellState`, `xdg_shell_global: GlobalId`, `toplevels: HashMap<WlSurface, Arc<Mutex<ManagedToplevel>>>`, `popups: HashMap<WlSurface, Arc<Mutex<ManagedPopup>>>`.
        
    - **Implementierung `XdgShellHandler` für `DesktopState`:** Die Implementierung der Methoden wird in `xdg_handlers.rs` detailliert. `xdg_shell_state()` gibt `&mut self.xdg_shell_state` zurück.
        
    - **Implementierung `GlobalDispatch<XdgWmBase, GlobalId>` für `DesktopState`:**
        - `bind()`: Protokolliert, ruft `state.xdg_shell_state.new_client()` auf, um `ShellClientUserData` zu erhalten, und initialisiert die Ressource damit. `XdgShellState` handhabt das Ping/Pong-Verhalten.
            
    - **Funktion `create_xdg_shell_global()`:** Erstellt `XdgShellState`, ruft dessen `global()`-Methode auf und speichert beides in `DesktopState`.
        
- `toplevel_management.rs`:
    - **Zweck:** Definiert Datenstrukturen und Logik spezifisch für XDG-Toplevel-Fenster.
        
    - **Struktur `ManagedToplevel`:** Kapselt `ToplevelSurface` von Smithay und fügt anwendungsspezifische Zustände hinzu. Felder umfassen `id: uuid::Uuid`, `surface_handle: ToplevelSurface`, `wl_surface: WlSurface`, `app_id`, `title`, `current_state: ToplevelWindowState`, `pending_state: ToplevelWindowState`, `window_geometry`, `min_size`, `max_size`, `parent` (für transiente Fenster), `client_provides_decorations`, `last_configure_serial`, `acked_configure_serial`. Methoden: `new()`, `send_configure()` (sendet `xdg_toplevel.configure` und `xdg_surface.configure`), `ack_configure()`.
        
    - **Struktur `ToplevelWindowState`:** Felder: `size`, `maximized`, `fullscreen`, `resizing`, `activated`, `suspended`, `decorations`.
        
    - **Struktur `ToplevelSurfaceUserData`:** In `WlSurface::data_map()` gespeichert, enthält `managed_toplevel_id`.
        
- `popup_management.rs`:
    - **Zweck:** Definiert Datenstrukturen und Logik spezifisch für XDG-Popup-Fenster.
        
    - **Struktur `ManagedPopup`:** Kapselt `PopupSurface` von Smithay. Felder: `id: uuid::Uuid`, `surface_handle: PopupSurface`, `wl_surface: WlSurface`, `parent_wl_surface`, `positioner_state: PositionerState`, `current_geometry`, `last_configure_serial`, `acked_configure_serial`. Methoden: `new()`, `send_configure()`, `ack_configure()`, `calculate_geometry()`.
        
    - **Struktur `PopupSurfaceUserData`:** In `WlSurface::data_map()` gespeichert, enthält `managed_popup_id`.
        
- `xdg_handlers.rs`:
    - **Zweck:** Detaillierte Implementierung der `XdgShellHandler`-Methoden für `DesktopState`.
        
    - `new_toplevel()`: Erstellt `ManagedToplevel`, speichert es in `state.toplevels` und dessen ID in `ToplevelSurfaceUserData` der `WlSurface`. Sendet initiale Konfiguration.
        
    - `new_popup()`: Erstellt `ManagedPopup`, speichert es in `state.popups` und dessen ID in `PopupSurfaceUserData`. Sendet initiale Konfiguration.
        
    - `map_toplevel()`: Führt Logik für das Mapping des Toplevels aus (Sichtbarkeit, initiale Position/Größe), ruft ggf. `send_configure()` auf.
        
    - `ack_configure()`: Verarbeitet `ack_configure` vom Client für Toplevels oder Popups, ruft `ack_configure()` auf der `ManagedEntity` auf.
        
    - `toplevel_request_set_title()`: Aktualisiert `title` im `ManagedToplevel` und benachrichtigt die UI-Schicht.
        
    - Weitere Handler (z.B. für `set_app_id`, `set_maximized`, `move`, `resize`) werden analog implementiert, aktualisieren den Zustand von `ManagedToplevel`/`ManagedPopup` und lösen ggf. neue `configure`-Zyklen aus oder interagieren mit dem Input-System.
        

#### 2.4. Submodul: `system::compositor::display_loop` (Display und Ereignisschleife)

Verantwortlich für die Einrichtung des Wayland-Display-Kernobjekts und dessen Integration in die `calloop`-Ereignisschleife. Die `calloop`-Ereignisschleife ist zentral für Smithay. Langlaufende Operationen in Callbacks müssen vermieden werden.

**Dateien:**

- `display_setup.rs`:
    - **Zweck:** Initialisiert das Wayland Display und `DisplayHandle`.
        
    - **Struktur `ClientData`:** Assoziiert mit `wayland_server::Client`. Enthält `id: uuid::Uuid`, `client_name: Option<String>`, `user_data: UserDataMap`.
        
    - **Funktion `init_wayland_display_and_loop()` (konzeptionell):** Erstellt `EventLoop<DesktopState>` und `Display<DesktopState>`. `DisplayHandle` und `LoopHandle` werden in `DesktopState` gespeichert.
        
    - **Enum `InitError`:** Varianten `WaylandDisplayCreationFailed`, `EventLoopCreationFailed`.
        
- `event_loop_integration.rs`:
    - **Zweck:** Integriert die Wayland-Anzeige in die `calloop`-Ereignisschleife.
        
    - **Funktion `register_wayland_source()`:** Ruft den Dateideskriptor der Wayland-Anzeige ab. Erstellt eine `calloop::generic::Generic<FileDescriptor>`-Ereignisquelle. Fügt die Quelle in die Ereignisschleife ein (`loop_handle.insert_source()`). Der Callback ruft `shared_data.display_handle.dispatch_clients(shared_data)` auf und bei Erfolg `shared_data.display_handle.flush_clients()`. `display_handle.flush_clients()` muss regelmäßig aufgerufen werden.
        

#### 2.5. Submodul: `system::compositor::renderer_interface` (Renderer-Schnittstelle)

Definiert abstrakte Schnittstellen für Rendering-Operationen, um die Kernlogik des Compositors von spezifischen Rendering-Backends zu entkoppeln (z.B. DRM/GBM, Winit/EGL). Schadensverfolgung ist für effizientes Rendering unerlässlich und muss integriert werden.

**Dateien:**

- `abstraction.rs`:
    - **Zweck:** Definiert Traits für Rendering-Operationen.
        
    - **Trait `FrameRenderer`:**
        - Methoden: `new()`, `render_frame()` (nimmt `RenderElement`), `present_frame()`, `create_texture_from_shm()`, `create_texture_from_dmabuf()` (für spätere Teile), `screen_size()`.
            
    - **Trait `RenderableTexture` (`Send + Sync + Debug`):**
        - Methoden: `id() -> uuid::Uuid`, `bind()`, `width_px()`, `height_px()`, `format()`.
            
    - **Enum `RenderElement` (konzeptionell, analog zu Smithays `Element`):** Varianten `Surface` (mit `texture: Arc<dyn RenderableTexture>`), `SolidColor`, `Cursor`.
        
    - **Struktur `Color`:** Felder `r, g, b, a` als `f32`.
        
    - **Enum `RendererError`:** Varianten `ContextCreationFailed`, `ShaderCompilationFailed`, `TextureUploadFailed`, `BufferSwapFailed`, `InvalidBufferType`, `DrmError`, `EglError`, `Generic`.
        

### 3. Modul: `system::input` (Libinput-basierte Eingabeverarbeitung)

Verantwortlich für die gesamte Verarbeitung von Benutzereingaben von Geräten wie Tastaturen, Mäusen und Touchpads. Nutzt `libinput` für Rohdaten und Smithay-Abstraktionen (`LibinputInputBackend`, `SeatState`, `SeatHandler`) für Seat- und Fokusmanagement. Latenz oder fehlerhafte Verarbeitung hier beeinträchtigen die UX erheblich. Die Transformation von `libinput`-Ereignissen in Wayland-Ereignisse, inklusive Koordinatentransformationen und Fokuslogik, muss präzise sein. Erweiterte Eingabefunktionen wie Gesten müssen berücksichtigt werden. `xkbcommon` ist fundamental für die korrekte Interpretation von Tastatureingaben.

#### 3.1. Submodul: `system::input::seat_manager`

Definiert und verwaltet `SeatState` und `SeatHandler` für Eingabefokus und die Bekanntmachung von Fähigkeiten.

**Dateien:**

- `seat_state.rs`:
    - **Struktur `InputError`:** Definiert Fehler wie `SeatCreationFailed`, `CapabilityAdditionFailed`, `XkbConfigError`, `LibinputError`, `SeatNotFound`, `KeyboardHandleNotFound`, etc..
        
    - **`DesktopState` (teilweise):** Enthält `seat_state: SeatState<Self>`, `seats: HashMap<String, Seat<Self>>`, `active_seat_name: Option<String>`, `keyboards: HashMap<String, XkbKeyboardData>`.
        
    - **Implementierung `SeatHandler` für `DesktopState`:**
        - `KeyboardFocus = WlSurface`, `PointerFocus = WlSurface`, `TouchFocus = WlSurface`.
            
        - `seat_state()`: Gibt `&mut self.seat_state` zurück.
            
        - `focus_changed()`: Protokolliert Fokusänderung. Ruft `KeyboardHandle::leave()` für alten Fokus und `KeyboardHandle::enter()` für neuen Fokus auf (mit aktuellen Tasten und Modifikatoren). Aktualisiert interne Fenstermanagement-Zustände.
            
        - `cursor_image()`: Handhabt `CursorImageStatus::Hidden`, `CursorImageStatus::Surface` (prüft Rolle "cursor", ruft Puffer/Hotspot ab) und `CursorImageStatus::Named` (verwendet Cursor-Theming-Bibliothek). Weist Renderer an, den Cursor zu zeichnen/aktualisieren.
            
    - **Funktion `create_seat()`:** Ruft `state.seat_state.new_wl_seat()` auf. Fügt Fähigkeiten hinzu (`seat.add_keyboard()`, `seat.add_pointer()`, `seat.add_touch()`). Speichert `Seat`-Objekt und `XkbKeyboardData`. Setzt ggf. `active_seat_name`.
        

#### 3.2. Submodul: `system::input::libinput_handler`

Initialisiert und konfiguriert das `LibinputInputBackend` und verarbeitet dessen Ereignisse.

**Dateien:**

- `backend_config.rs`:
    - **Struktur `LibinputSessionInterface`:** Wrapper für `input::LibinputInterface` zum Öffnen/Schließen von Geräten über ein Session-Objekt (z.B. `DirectSession`, `LogindSession`).
        
    - **Funktion `init_libinput_backend()`:** Erstellt `libinput::Libinput`-Kontext mit `Libinput::new_from_path(session_interface)`. Weist dem Kontext einen Seat zu (`udev_assign_seat("seat0")`). Erstellt und gibt `LibinputInputBackend` zurück.
        
- `event_dispatcher.rs`:
    - **Zweck:** Verarbeitet `InputEvent<LibinputInputBackend>` und leitet an spezifische Handler weiter.
        
    - **Funktion `process_input_event()`:** Wird vom `calloop`-Callback aufgerufen. Ruft den aktiven Seat ab. Verarbeitet verschiedene `InputEvent`-Varianten (`Keyboard`, `PointerMotion`, `PointerButton`, `PointerAxis`, `TouchDown`, `TouchUp`, `TouchMotion`, `TouchFrame`, `TouchCancel`, `Gesture*`, `DeviceAdded`, `DeviceRemoved`) durch Aufruf entsprechender Handler-Funktionen in den jeweiligen Submodulen (`keyboard::key_event_translator`, `pointer::pointer_event_translator`, `touch::touch_event_translator`). Gestenereignisse werden initial nur protokolliert. Bei `DeviceAdded`/`DeviceRemoved` werden Seat-Fähigkeiten ggf. aktualisiert.
        

#### 3.3. Submodul: `system::input::keyboard`

Verwaltet XKB-Keymap und -Status für Tastaturen, übersetzt `KeyboardKeyEvent` und handhabt Tastaturfokus.

**Dateien:**

- `xkb_config.rs`:
    - **Struktur `XkbKeyboardData`:** Enthält `context: xkbcommon::xkb::Context`, `keymap: xkbcommon::xkb::Keymap`, `state: xkbcommon::xkb::State`, `repeat_timer: Option<calloop::TimerHandle>`, `repeat_info`, `focused_surface_on_seat`, `repeat_key_serial`.
        
    - **Funktion `new_xkb_keyboard_data()`:** Erstellt `xkbcommon::xkb::Context`, `xkbcommon::xkb::RuleNames` (aus `XkbConfig`), `xkbcommon::xkb::Keymap` und `xkbcommon::xkb::State`.
        
    - **Funktion `update_xkb_state_from_modifiers()`:** Ruft `xkb_state.update_mask()` auf.
        
- `key_event_translator.rs`:
    - **Funktion `handle_keyboard_key_event()`:** Ruft Keyboard-Handle und `XkbKeyboardData` ab. Aktualisiert `xkb_data.state` mit `update_key()`. Ruft `ModifiersState` von `xkb_data.state` ab und informiert `KeyboardHandle`. Sendet `keyboard_handle.input()` mit Keysym und UTF-8 (für `KeyState::Pressed`). Richtet Tastenwiederholung mittels `calloop::Timer` ein/bricht sie ab, basierend auf `keyboard_handle.repeat_info()`.
        
- `focus_handler_keyboard.rs`:
    - **Funktion `set_keyboard_focus()`:** Ruft Seat und Keyboard-Handle ab. Ermittelt alten Fokus. Sendet `keyboard_handle.leave()` für alten Fokus und `keyboard_handle.enter()` (mit gedrückten Tasten/Modifikatoren) für neuen Fokus. Aktualisiert `xkb_data.focused_surface_on_seat`. Ruft `keyboard_handle.set_focus()` auf.
        

#### 3.4. Submodul: `system::input::pointer`

Verarbeitet Zeigerereignisse, handhabt Zeigerfokus und Cursor-Aktualisierungen.

**Dateien:**

- `pointer_event_translator.rs`:
    - **Funktion `handle_pointer_motion_event()`:** Ruft Pointer-Handle ab. Aktualisiert globale Cursorposition. Bestimmt neuen Zeigerfokus basierend auf globaler Position und sichtbaren Toplevel-Oberflächen/Eingaberegionen (`find_surface_at_global_coords()`). Ruft `update_pointer_focus_and_send_motion()` auf. Aktualisiert Renderer-Cursorposition.
        
    - **Funktion `handle_pointer_motion_absolute_event()`:** Ähnlich wie Motion, aber verwendet absolute Koordinaten (`event.x_transformed()`, `event.y_transformed()`).
        
    - **Funktion `handle_pointer_button_event()`:** Ruft Pointer-Handle ab. Sendet `pointer_handle.button()`. Ändert ggf. Tastaturfokus (Click-to-Focus) und behandelt Fenstermanagement-Interaktionen (z.B. Start von Move/Resize-Grab).
        
    - **Funktion `handle_pointer_axis_event()`:** Ruft Pointer-Handle ab. Bestimmt Achsenquelle. Sendet `pointer_handle.axis()` für vertikales/horizontales Scrollen mit diskreten und kontinuierlichen Werten.
        
- `focus_handler_pointer.rs`:
    - **Funktion `update_pointer_focus_and_send_motion()`:** Ruft aktuellen Fokus vom Pointer-Handle ab. Sendet `pointer_handle.leave()` für alten Fokus und `pointer_handle.enter()` für neuen Fokus. Sendet `pointer_handle.motion()`, wenn neuer Fokus existiert.
        
- `cursor_updater.rs`:
    - **Zweck:** Enthält Logik von `SeatHandler::cursor_image`, ggf. Hilfsfunktionen für Cursor-Themen.
        

#### 3.5. Submodul: `system::input::touch`

Verarbeitet Touch-Ereignisse und handhabt Touch-Fokus. Fokus ist implizit im Oberflächenargument für `down`/`motion`. Zustand, welche Oberfläche von welchem Slot berührt wird, muss in `DesktopState` oder assoziierten Strukturen verwaltet werden.

**Dateien:**

- `touch_event_translator.rs`:
    - **Funktion `handle_touch_down_event()`:** Ruft Touch-Handle ab. Bestimmt fokussierte Oberfläche unter dem Touchpunkt. Sendet `touch_handle.down()`.
        
    - **Funktion `handle_touch_up_event()`:** Ruft Touch-Handle ab. Sendet `touch_handle.up()`.
        
    - **Funktion `handle_touch_motion_event()`:** Ruft Touch-Handle ab. Ruft fokussierte Oberfläche für den Touch-Slot ab. Transformiert Koordinaten. Sendet `touch_handle.motion()`.
        
    - **Funktion `handle_touch_frame_event()`:** Ruft Touch-Handle ab. Sendet `touch_handle.frame()`.
        
    - **Funktion `handle_touch_cancel_event()`:** Ruft Touch-Handle ab. Sendet `touch_handle.cancel()`.
        
- `focus_handler_touch.rs`:
    - **Zweck:** Verwaltet Touch-Fokus, ähnlich wie Zeigerfokus, aber pro Touchpunkt/Slot.
        

### 4. Modul: `system::dbus` (Interaktion mit System-D-Bus-Diensten)

Verantwortlich für die Kommunikation mit Standard-D-Bus-Diensten wie UPower, systemd-logind, NetworkManager, Freedesktop Secret Service und PolicyKit unter Verwendung der `zbus`-Bibliothek.

#### 4.1. Submodul: `system::dbus::error`

Definiert spezifische Fehlertypen für D-Bus-Interaktionen mittels `thiserror`.

**Datei:** `system/dbus/error.rs`

- **Enum `DBusError`:** Varianten wie `ConnectionFailed`, `MethodCallFailed`, `ProxyCreationFailed`, `SignalSubscriptionFailed`, `InvalidResponse`, `DataDeserializationError`, `PropertyAccessFailed`, `NameTaken`, `Timeout`.
    
- **Enum `BusType`:** `Session`, `System`.
    

#### 4.2. Submodul: `system::dbus::connection`

Stellt einen zentralen Manager für D-Bus-Verbindungen bereit.

**Datei:** `system/dbus/connection.rs`

- **Struktur `DBusConnectionManager`:**
    - Felder: `session_bus: tokio::sync::OnceCell<Arc<zbus::Connection>>`, `system_bus: tokio::sync::OnceCell<Arc<zbus::Connection>>` für verzögerte Initialisierung und Wiederverwendung.
        
    - Methoden: `new()`, `get_session_bus()` (verwendet `zbus::Connection::session().await`), `get_system_bus()` (verwendet `zbus::Connection::system().await`).
        

#### 4.3. Submodul: `system::dbus::upower_client` (oder `upower_interface`)

Interagiert mit `org.freedesktop.UPower` für Energieinformationen.

**Dateien:** `system/dbus/upower_client.rs` (oder `upower_interface/client.rs`), `system/dbus/upower_types.rs` (oder `upower_interface/types.rs`)

- **`upower_types.rs`:**
    - Enums: `PowerDeviceType`, `PowerState`, `PowerWarningLevel`, `PowerDeviceTechnology`. `TryFrom<u32>` für Enums implementieren.
        
    - Strukturen: `PowerDeviceDetails` (enthält Felder wie `object_path`, `vendor`, `model`, `device_type`, `state`, `percentage`, `time_to_empty`, `time_to_full`, etc.), `UPowerProperties` (oder `UPowerManagerProperties`) (`on_battery`, `lid_is_closed`, `lid_is_present`, `daemon_version`).
        
    - Internes Enum `UPowerEvent`: `DeviceAdded`, `DeviceRemoved`, `DeviceUpdated`, `ManagerPropertiesChanged`.
        
- **`upower_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**:
        - `UPowerManagerProxy` für `org.freedesktop.UPower`: Methoden `enumerate_devices`, `get_display_device`, `get_critical_action`; Properties `on_battery`, `lid_is_closed`, `lid_is_present`, `daemon_version`; Signale `device_added`, `device_removed`, `properties_changed`.
            
        - `UPowerDeviceProxy` für `org.freedesktop.UPower.Device`: Properties wie `type_`, `state`, `percentage`, `time_to_empty`, `time_to_full`, `is_present`, `icon_name`, etc.; Signal `properties_changed`.
            
    - **Struktur `UPowerClient`:**
        - Felder: `connection_manager: Arc<DBusConnectionManager>` (oder `connection: zbus::Connection`), `manager_proxy: Arc<UPowerManagerProxy>`, `devices: Arc<Mutex<HashMap<ObjectPath<'static>, PowerDeviceDetails>>>`, `display_device_path: Arc<Mutex<Option<ObjectPath<'static>>>>`, `manager_properties: Arc<Mutex<UPowerManagerProperties>>`, `internal_event_sender: tokio::sync::broadcast::Sender<UPowerEvent>`.
            
        - Methoden: `new()` (oder `connect_and_initialize()`), `get_manager_proxy()`, `get_device_proxy()`, `get_properties()` (für Manager), `enumerate_devices()`, `get_display_device_path()`, `get_device_details()`, `on_battery()`, `subscribe_device_added()`, `subscribe_device_removed()`, `subscribe_upower_properties_changed()` (Manager), `subscribe_device_properties_changed()`.
            
    - **Signalbehandlung:** Asynchrone Tasks (`tokio::spawn`) für Manager-Signale (`DeviceAdded`, `DeviceRemoved`, `PropertiesChanged`) und Geräte-Signale (`PropertiesChanged`). Aktualisiert interne Zustände (`devices`, `manager_properties`) und sendet `UPowerEvent` über den Broadcast-Kanal. PropertiesChanged-Signale sollten detailliert ausgewertet werden, um nur betroffene Felder zu aktualisieren.
        

#### 4.4. Submodul: `system::dbus::logind_client` (oder `logind_interface`)

Interagiert mit `org.freedesktop.login1` für Sitzungsmanagement und Systemereignisse.

**Dateien:** `system/dbus/logind_client.rs` (oder `logind_interface/client.rs`), `system/dbus/logind_types.rs` (oder `logind_interface/types.rs`)

- **`logind_types.rs`:**
    - Strukturen: `SessionInfo` (`id`, `user_id`, `user_name`, `seat_id`, `object_path`, `is_active`, `is_locked_hint`), `UserInfo`.
        
    - Enums: `SessionState`, `LogindEvent` (`PrepareForSleep { starting: bool }`, `ActiveSessionLocked`, `ActiveSessionUnlocked`, `ActiveSessionChanged`, `SessionListChanged`).
        
- **`logind_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**:
        - `LogindManagerProxy` für `org.freedesktop.login1.Manager`: Methoden `get_session`, `get_session_by_pid`, `get_user`, `list_sessions`, `lock_session`, `unlock_session`, `lock_sessions`, `unlock_sessions`, `inhibit`; Signale `session_new`, `session_removed`, `prepare_for_sleep`.
            
        - `LogindSessionProxy` für `org.freedesktop.login1.Session`: Properties `active`, `locked_hint`, `id`, `user`, `seat`; Signale `Lock`, `Unlock`, `PropertyChanged`.
            
    - **Struktur `LogindClient`:**
        - Felder: `connection: zbus::Connection`, `manager_proxy: Arc<LogindManagerProxy>`, `active_session_id: Arc<Mutex<Option<String>>>`, `active_session_path`, `active_session_proxy`, `sleep_inhibitor_lock: Arc<Mutex<Option<zbus::zvariant::OwnedFd>>>`, `internal_event_sender: tokio::sync::broadcast::Sender<LogindEvent>`.
            
        - Methoden: `new()` (oder `connect_and_initialize()`), `get_manager_proxy()`, `get_session_proxy()`, `list_sessions()` (konvertiert zu `Vec<SessionInfo>`), `get_session_details()`, `lock_session()`, `unlock_session()`, `lock_all_sessions()`, `unlock_all_sessions()`, `subscribe_session_new()`, `subscribe_session_removed()`, `subscribe_prepare_for_sleep()`, `subscribe_session_lock()`, `subscribe_session_unlock()`, `request_lock_active_session()`, `request_unlock_active_session()`, `subscribe_events()`, `release_sleep_inhibitor()`.
            
    - **Initialisierung:** Identifiziert die aktive Sitzung durch `ListSessions` und Prüfung der `Active`-Eigenschaft jeder Session.
        
    - **Signalbehandlung (`PrepareForSleep`):** Bei `start == true`, `inhibit()` aufrufen und FD speichern. `LogindEvent::PrepareForSleep { starting: true }` senden. Bei `start == false`, Inhibit-Lock freigeben (`drop(fd)`) und `LogindEvent::PrepareForSleep { starting: false }` senden. Die korrekte Freigabe des Inhibit-Locks ist kritisch.
        
    - **Signalbehandlung (`SessionNew`/`SessionRemoved`):** Aktualisiert interne Sitzungsliste, prüft auf Änderung der aktiven Sitzung und sendet `LogindEvent`.
        
    - **Signalbehandlung (`Lock`/`Unlock` oder `LockedHint` der aktiven Session):** Sendet `LogindEvent::ActiveSessionLocked/Unlocked`. Die DE ist i.d.R. selbst für den Sperrbildschirm zuständig; dieses Modul kann `LockedHint` überwachen.
        

#### 4.5. Submodul: `system::dbus::networkmanager_client`

Interagiert mit `org.freedesktop.NetworkManager` für Netzwerkinformationen.

**Dateien:** `system/dbus/networkmanager_client.rs`, `system/dbus/networkmanager_types.rs`

- **`networkmanager_types.rs`:**
    - Enums: `NetworkManagerState`, `NetworkDeviceType`, `NetworkConnectivityState`.
        
    - Strukturen: `NetworkDevice`, `ActiveConnection`, `NetworkManagerProperties`.
        
- **`networkmanager_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**: `NetworkManagerProxy`, `NMDeviceProxy`, `NMActiveConnectionProxy` mit relevanten Methoden, Properties und Signalen (z.B. `GetDevices`, `GetActiveConnections`, `StateChanged`, `DeviceAdded`, `DeviceRemoved`).
        
    - **Struktur `NetworkManagerClient`:** Enthält `connection_manager`, `manager_proxy_path`. Methoden `new()`, `get_manager_proxy()`, `get_device_proxy()`, `get_active_connection_proxy()`, `get_properties()`, `get_devices()` (ruft Details für jeden Pfad ab), `get_active_connections()`, `subscribe_state_changed()`, `subscribe_device_added()` (ruft Details für neuen Pfad ab), `subscribe_device_removed()`.
        
    - Reaktive Aktualisierung bei Signalempfang ist wichtig.
        

#### 4.6. Submodul: `system::dbus::secrets_client`

Interagiert mit `org.freedesktop.secrets` zum Speichern/Abrufen sensibler Daten (z.B. API-Schlüssel).

**Dateien:** `system/dbus/secrets_client.rs`, `system/dbus/secrets_types.rs`

- **`secrets_types.rs`:**
    - Strukturen: `Secret`, `SecretItemInfo`, `SecretCollectionInfo`.
        
    - Enum: `PromptCompletedResult`.
        
- **`secrets_client.rs`:**
    - **Proxy-Definitionen (`#[zbus::proxy]`)**: `SecretServiceProxy`, `SecretCollectionProxy`, `SecretItemProxy`, `SecretPromptProxy` mit relevanten Methoden, Properties und Signalen (z.B. `OpenSession`, `CreateCollection`, `SearchItems`, `Unlock`, `GetSecrets`, `CreateItem`, `GetSecret`, `Prompt`, `Completed`).
        
    - **Struktur `SecretsClient`:** Enthält `connection_manager`, `service_proxy_path`. Methoden `new()`, Proxies abrufen, `open_session()`, `get_default_collection()`, `store_secret()` (behandelt Prompt), `retrieve_secret()` (behandelt Unlock/Prompt), `search_items()`, `handle_prompt_if_needed()` (ruft `PromptProxy::Prompt()` mit `window_id` von UI-Schicht und wartet auf `Completed`-Signal).
        

#### 4.7. Submodul: `system::dbus::policykit_client`

Interagiert mit `org.freedesktop.PolicyKit1.Authority` zur Berechtigungsprüfung.

**Dateien:** `system/dbus/policykit_client.rs`, `system/dbus/policykit_types.rs`

- **`policykit_types.rs`:**
    - Bitflags-Struktur `PolicyKitCheckAuthFlags` (`AllowUserInteraction`, etc.).
        
    - Strukturen: `PolicyKitSubject` (`kind`, `details`), `PolicyKitAuthorizationResult` (`is_authorized`, `is_challenge`, `details`).
        
- **`policykit_client.rs`:**
    - **Proxy-Definition (`#[zbus::proxy]`)**: `PolicyKitAuthorityProxy` für `org.freedesktop.PolicyKit1.Authority`. Methode `CheckAuthorization`.
        
    - **Struktur `PolicyKitClient`:** Enthält `connection_manager`, `authority_proxy_path`. Methoden `new()`, `get_authority_proxy()`, `check_authorization()` (erstellt `PolicyKitSubject` mit PID des aktuellen Prozesses oder übergebenem PID, setzt Flags, ruft Proxy-Methode auf). Die korrekte Definition des `subject` ist sicherheitskritisch.
        

### 5. Modul: `system::outputs` (Verwaltung der Anzeigeausgänge)

Verantwortlich für Erkennung, Konfiguration und Verwaltung von Anzeigeausgängen (Monitoren). Implementiert serverseitige Logik für Wayland-Protokolle (`wl_output`, `xdg-output-unstable-v1`, `wlr-output-management-unstable-v1`, `wlr-output-power-management-unstable-v1`) unter Verwendung von Smithay-Abstraktionen.

#### 5.1. Submodul: `system::outputs::error`

Definiert spezifische Fehlertypen für Output-Operationen.

**Datei:** `system/outputs/error.rs`

- **Enum `OutputError`:** Varianten `DeviceAccessFailed`, `ProtocolError`, `ConfigurationConflict`, `ResourceCreationFailed`, `SmithayOutputError`, `OutputNotFound`, `ModeNotSupported`.
    

#### 5.2. Submodul: `system::outputs::output_device`

Kapselt Zustand und Logik eines einzelnen physischen Anzeigeausgangs.

**Datei:** `system/outputs/output_device.rs`

- **Struktur `OutputDevice`:**
    - Felder: `name: String`, `smithay_output: smithay::output::Output`, `wl_output_global: Option<GlobalId>`, `xdg_output_global: Option<GlobalId>`, `wlr_head_global: Option<GlobalId>`, `wlr_power_global: Option<GlobalId>`, `enabled: bool`, `current_dpms_state: DpmsState`, `pending_config_serial: Option<u32>` (für wlr-output-management).
        
    - Methoden: `new()` (initialisiert `smithay::output::Output`, fügt Modi hinzu, setzt initialen Zustand), `name()`, `smithay_output()`, `current_mode()`, `current_transform()`, `current_scale()`, `current_position()`, `is_enabled()`, `apply_state()` (ruft `smithay_output.change_current_state()`), `set_dpms_state()` (interagiert mit DRM, aktualisiert `current_dpms_state`), `supported_modes()`, `physical_properties()`, `add_mode()`, `set_preferred_mode()`, Methoden zum Setzen/Abrufen von Global-IDs, `destroy_globals()`.
        
- **Struktur `OutputDevicePendingState` (für wlr-output-management):** Felder `mode`, `position`, `transform`, `scale`, `enabled`, `adaptive_sync_enabled`.
    
- **Enum `DpmsState`:** `On`, `Standby`, `Suspend`, `Off`.
    

#### 5.3. Submodul: `system::outputs::manager` (oder `output_manager` für wlr-output-management)

Verwaltet eine Liste aller `OutputDevice`-Instanzen und behandelt Hotplug-Events.

**Datei:** `system/outputs/manager.rs` (oder `output_manager/manager_global.rs` und andere für wlr-output-management)

- **Struktur `OutputManager` (oder `OutputManagerModuleState` / `WlrOutputManagementState`):**
    - Felder: `outputs: HashMap<String, Arc<Mutex<OutputDevice>>>`, `udev_event_source_token: Option<RegistrationToken>`, `output_manager_global` (für wlr), `active_configurations` (für wlr), `compositor_output_serial` (für wlr) / `global_serial`.
        
    - Methoden: `new()`, `add_output()`, `remove_output()` (zerstört Globals), `find_output_by_name()`, `all_outputs()`, `handle_hotplug_event()` (erstellt/entfernt `OutputDevice`, ruft `output_device_created/removed_notifications` auf).
        
    - Hilfsmethoden `output_device_created_notifications()` und `output_device_removed_notifications()`: Erstellen/Zerstören Globals (`wl_output`, `zxdg_output_v1`, `zwlr_output_head_v1`) und benachrichtigen relevante Handler (WlrOutputManagementState, WlrOutputPowerManagementState).
        
- **Enum `HotplugEvent`:** `DeviceAdded` (mit Name, Pfad, Eigenschaften, Modi, etc.), `DeviceRemoved`.
    
- **Struktur `OutputConfigurationRequest` (für wlr-output-management):** `serial`, `client`, `pending_changes: HashMap<String, HeadChangeRequest>`, `config_resource`.
    
- **Struktur `HeadChangeRequest` (für wlr-output-management):** `mode`, `position`, `transform`, `scale`, `enabled`, `adaptive_sync_enabled`.
    
- **`wlr-output-management` spezifische UserData-Strukturen:** `WlrOutputManagerGlobalData`, `WlrOutputHeadGlobalData`, `WlrOutputModeGlobalData`, `WlrOutputConfigurationUserData`, `WlrOutputConfigurationHeadUserData`.
    

#### 5.4. Submodul: `system::outputs::wl_output_handler`

Handhabung des `wl_output`-Protokolls, meist durch Smithay's `Output`-Typ und `OutputHandler`-Trait.

**Datei:** Integration in globalen Compositor-Zustand und `system::outputs::manager.rs`.

- **Smithay Integration:** Globaler Compositor-Zustand implementiert `smithay::wayland::output::OutputHandler`. `smithay::delegate_output!` wird deklariert. Beim Hinzufügen eines Outputs wird `output_dev.smithay_output().create_global()` aufgerufen; `GlobalId` wird in `OutputDevice::wl_output_global` gespeichert.
    
- **Implementierung `OutputHandler`:**
    - `output_state()`: Gibt Referenz zum `OutputManagerState` des Compositors zurück.
        
    - `new_output()`: Kann Client-spezifischen Zustand initialisieren.
        
    - `output_destroyed()`: Wird bei Zerstörung eines `wl_output`-Globals aufgerufen.
        
    - Smithay sendet `geometry`, `mode`, `scale`, `done` Events automatisch bei `Output::change_current_state()`.
        

#### 5.5. Submodul: `system::outputs::wlr_output_management_handler` (oder in `system::outputs::output_manager`)

Implementiert `wlr-output-management-unstable-v1`.

**Dateien:** `system/outputs/wlr_output_management/*` oder integriert.

- **Zustandsstrukturen:** `WlrOutputManagementState` (enthält `OutputManager`-Referenz, `configurations`, `global_serial`). `OutputConfigurationRequest` (enthält `serial`, `client`, `pending_changes`, `config_resource`). `HeadChangeRequest` (enthält `mode`, `position`, etc.).
    
- **Smithay Integration:** Globaler Compositor-Zustand implementiert `GlobalDispatch` und `Dispatch` für `ZwlrOutputManagerV1`, `ZwlrOutputHeadV1`, `ZwlrOutputModeV1`, `ZwlrOutputConfigurationV1`, `ZwlrOutputConfigurationHeadV1`.
    
- **Initialisierung:** `WlrOutputManagementState` erstellen, `zwlr_output_manager_v1`-Global registrieren.
    
- **Anfragebehandlung `zwlr_output_manager_v1`:**
    - `bind`: Sendet aktuellen Zustand aller Outputs (Heads, Modi) und `done(serial)`.
        
    - `create_configuration()`: Erstellt `OutputConfigurationRequest`, speichert es. Sendet aktuellen Output-Zustand an das neue `config_resource`.
        
    - `stop()`: Zerstört das Manager-Global, sendet `finished`.
        
- **Anfragebehandlung `zwlr_output_configuration_head_v1`:** `enable()`, `disable()`, `set_mode()`, `set_custom_mode()`, `set_position()`, `set_transform()`, `set_scale()`, `set_adaptive_sync()` aktualisieren `HeadChangeRequest` im `OutputConfigurationRequest`. Prüfen auf `is_applied_or_tested`.
    
- **Anfragebehandlung `zwlr_output_configuration_v1`:**
    - `destroy()`: Verwirft Anfrage.
        
    - `apply()`: Prüft `serial` gegen `compositor_output_serial` (bei Mismatch -> `cancelled`). Validiert Änderungen. Versucht, Konfiguration auf `OutputDevice` anzuwenden (via `OutputManager` und `output.change_current_state()`). Bei Erfolg: `succeeded`, `compositor_output_serial` inkrementieren, alle Manager-Clients benachrichtigen. Bei Fehler: `failed`, ggf. Rollback.
        
    - `test()`: Validiert Konfiguration. Sendet `succeeded` oder `failed`.
        
- **Event-Generierung:** Bei Änderungen des Output-Zustands (Hotplug, erfolgreiches `apply`) müssen `head`, `mode`, `done(new_serial)` an alle Manager gesendet werden.
    
- **Fehlerbehandlung (`OutputManagerError`):** Varianten wie `InvalidWlOutput`, `AlreadyProcessed`, `SerialMismatch`, `UnknownOutput`, `TestFailed`, `ApplyFailed`, `Cancelled`, `ProtocolError`.
    

#### 5.6. Submodul: `system::outputs::wlr_output_power_management_handler` (oder `system::outputs::power_manager`)

Implementiert `wlr-output-power-management-unstable-v1` für Energiezustand von Monitoren.

**Dateien:** `system/outputs/wlr_output_power_management/*` oder integriert.

- **Zustandsstrukturen:** `WlrOutputPowerManagementState` (enthält `OutputManager`-Referenz, `active_controllers: HashMap<String, Resource<ZwlrOutputPowerV1>>`). `OutputPowerControlState` (enthält `wl_output_resource`, `compositor_output_name`, `current_mode: InternalPowerMode`).
    
- **Enum `InternalPowerMode`**: `On`, `Off`.
    
- **UserData-Strukturen:** `WlrOutputPowerManagerGlobalData`, `WlrOutputPowerControlUserData`.
    
- **Smithay Integration:** Globaler Compositor-Zustand implementiert `GlobalDispatch` und `Dispatch` für `ZwlrOutputPowerManagerV1`, `ZwlrOutputPowerV1`.
    
- **Initialisierung:** `WlrOutputPowerManagementState` erstellen, `zwlr_output_power_manager_v1`-Global registrieren.
    
- **Anfragebehandlung `zwlr_output_power_manager_v1`:**
    - `get_output_power()`: Ermittelt `OutputDevice`. Prüft auf exklusive Kontrolle (nur ein Controller pro Output). Speichert `ZwlrOutputPowerV1`-Ressource in `active_controllers`. Sendet initiales `mode`-Event an Ressource.
        
    - `destroy()`: Zerstört Manager-Global.
        
- **Anfragebehandlung `zwlr_output_power_v1`:**
    - `destroy()`: Entfernt Controller aus `active_controllers`.
        
    - `set_mode()`: Ermittelt `OutputDevice`. Konvertiert `mode` in `DpmsState`. Ruft `output_device.set_dpms_state()`. Sendet `mode(mode)` oder `failed`.
        
- **Event-Generierung:** Bei externer Änderung des DPMS-Zustands oder Entfernung eines Outputs, `mode` oder `failed` an aktive Controller senden.
    
- **Fehlerbehandlung (`OutputPowerError`):** Varianten `OutputDoesNotSupportPowerManagement`, `BackendSetModeFailed`, `OutputVanished`, `ExclusiveControlConflict`, `InvalidWlOutput`, `ProtocolError`.
    

#### 5.7. Submodul: `system::outputs::xdg_output_handler`

Implementiert `xdg-output-unstable-v1` für detaillierte logische Geometrieinformationen.

**Datei:** `system/outputs/xdg_output_handler.rs` oder integriert.

- **Smithay Integration:** Globaler Compositor-Zustand implementiert `GlobalDispatch` und `Dispatch` für `ZxdgOutputManagerV1`, `ZxdgOutputV1`. `XdgOutputManagerGlobalData`, `XdgOutputGlobalData` als UserData. Erstellung von Globals kann über `OutputManagerState::new_with_xdg_output()` oder manuell erfolgen.
    
- **Anfragebehandlung `zxdg_output_manager_v1`:**
    - `get_xdg_output()`: Ermittelt `OutputDevice`. Initialisiert `ZxdgOutputV1`-Ressource mit logischen Daten (`logical_position`, `logical_size`, `name`, `description`), sendet diese und `done`.
        
- **Event-Generierung:** Bei Änderungen an logischer Position, Größe, Name, Beschreibung eines `OutputDevice` müssen entsprechende Events an gebundene `zxdg_output_v1`-Instanzen gesendet werden, gefolgt von `done`. Dies wird i.d.R. von Smithay bei `Output::change_current_state()` gehandhabt.
    

### 6. Modul: `system::audio` (PipeWire Client-Integration)

Verantwortlich für alle audiobezogenen Operationen mittels PipeWire und `pipewire-rs`. Zentralisiert PipeWire-Interaktionslogik, ereignisgesteuerte Architektur. Eigene PipeWire MainLoop in dediziertem Thread, Kommunikation über asynchrone Kanäle (`tokio::sync::mpsc`, `tokio::sync::broadcast`). Unterscheidet Master-Lautstärke (Device-Routen) und Anwendungs-Stream-Lautstärke (Node-Props).

#### 6.1. Submodul: `system::audio::client`

Verwaltet Low-Level-Verbindung zu PipeWire, startet und unterhält PipeWire-MainLoop-Thread, leitet Befehle weiter und verteilt Ereignisse.

**Datei:** `system/audio/client.rs`

- **Struktur `PipeWireClient`:**
    - Felder: `core: Arc<pipewire::Core>`, `mainloop_thread_handle: Option<std::thread::JoinHandle<()>>`, `command_sender: tokio::sync::mpsc::Sender<AudioCommand>`, `internal_event_sender: tokio::sync::mpsc::Sender<InternalAudioEvent>`.
        
    - Methode `new()`: Initialisiert PipeWire (`pipewire::init()`), erstellt MPSC-Kanäle, startet `run_pipewire_loop` in neuem OS-Thread, wartet auf Initialisierungssignal vom Thread, speichert Handles und Sender.
        
    - Methode `get_command_sender()`: Gibt Klon des `command_sender` zurück.
        
- **Struktur `PipeWireLoopData` (für internen Thread-Zustand):** `core`, `registry: Arc<pipewire::Registry>`, `audio_event_broadcaster: tokio::sync::broadcast::Sender<AudioEvent>`, `command_receiver`, `internal_event_receiver`, `active_devices: HashMap<u32, MonitoredDevice>`, `active_streams: HashMap<u32, MonitoredStream>`, `default_sink_id`, `default_source_id`, `pipewire_mainloop`, `pipewire_context`, `metadata_proxy`, `metadata_listener_hook`.
    
- **Struktur `MonitoredDevice`:** `proxy: Arc<dyn ProxyT>`, `proxy_id`, `global_id`, `properties`, `param_listener_hook`, `info: AudioDevice`.
    
- **Struktur `MonitoredStream`:** `proxy: Arc<pipewire::node::Node>`, `proxy_id`, `global_id`, `properties`, `param_listener_hook`, `info: StreamInfo`.
    
- **Enum `InternalAudioEvent`:** `PwGlobalAdded`, `PwGlobalRemoved`, `PwNodeParamChanged`, `PwDeviceParamChanged`, `PwMetadataPropsChanged`.
    
- **Private Funktion `run_pipewire_loop()`:** Initialisiert `MainLoop`, `Context`, `Core`, `Registry`. Registriert Listener auf Registry (`global`, `global_remove` Callbacks senden `InternalAudioEvent`). Startet Timer, der `process_external_messages` aufruft. Ruft `mainloop.run()`.
    
    - `process_external_messages()`: Verarbeitet `AudioCommand` (ruft Control-Funktionen) und `InternalAudioEvent` (ruft Manager-Funktionen).
        

#### 6.2. Submodul: `system::audio::manager`

Verarbeitet PipeWire-Registry-Ereignisse, verwaltet `AudioDevice`/`StreamInfo`, behandelt Eigenschaftsänderungen.

**Datei:** `system/audio/manager.rs`

- **Funktion `handle_pipewire_global_added()`:** Loggt. Abhängig von `global.type_`:
    - `ObjectType::Node`: Extrahiert Properties. Unterscheidet Gerät (Sink/Source) von Anwendungsstream. Bindet `pipewire::node::Node`-Proxy. Ruft initiale Parameter ab (Lautstärke/Mute aus `SPA_PARAM_Props`). Erstellt `AudioDevice` oder `StreamInfo`. Registriert `param_changed`-Listener (sendet `InternalAudioEvent::PwNodeParamChanged`). Speichert in `active_devices` oder `active_streams`. Sendet `AudioEvent::DeviceAdded` oder `StreamAdded`.
        
    - `ObjectType::Device`: Extrahiert Properties. Bindet `pipewire::device::Device`-Proxy. Ruft initiale `SPA_PARAM_Route`-Parameter ab. Erstellt `AudioDevice`. Registriert `param_changed`-Listener (sendet `InternalAudioEvent::PwDeviceParamChanged`). Speichert in `active_devices`. Sendet `AudioEvent::DeviceAdded`.
        
    - `ObjectType::Metadata`: Wenn `metadata.name == "default"`. Bindet `pipewire::metadata::Metadata`-Proxy. Speichert Proxy. Parst Standardgeräte-IDs aus Properties. Registriert `props`-Listener (sendet `InternalAudioEvent::PwMetadataPropsChanged`). Sendet `AudioEvent::DefaultSink/SourceChanged`.
        
- **Funktion `handle_pipewire_global_removed()`:** Loggt. Entfernt `MonitoredDevice` oder `MonitoredStream` aus `active_devices`/`active_streams`. Listener werden automatisch entfernt. Sendet `AudioEvent::DeviceRemoved` oder `StreamRemoved`. Behandelt Entfernung des Metadata-Proxy.
    
- **Funktion `handle_node_param_changed()`:** Loggt. Sucht `MonitoredDevice`/`Stream`. Wenn `SPA_PARAM_Props` geändert: Parst Lautstärke/Mute aus Pod. Aktualisiert `AudioDevice`/`StreamInfo`. Sendet `AudioEvent::Device/StreamVolumeChanged/MuteChanged`.
    
- **Funktion `handle_device_param_changed()`:** Loggt. Sucht `MonitoredDevice`. Wenn `SPA_PARAM_Route` geändert: Parst Lautstärke/Mute der aktiven Route. Aktualisiert `AudioDevice`. Sendet `AudioEvent::DeviceVolumeChanged/MuteChanged`.
    
- **Funktion `handle_metadata_props_changed()`:** Loggt. Extrahiert neue Standard-Sink/Source-IDs aus Properties. Aktualisiert `is_default`-Flags der betroffenen `AudioDevice`-Instanzen und sendet `AudioEvent::DeviceUpdated`. Aktualisiert `default_sink_id`/`default_source_id`. Sendet `AudioEvent::DefaultSink/SourceChanged`.
    

#### 6.3. Submodul: `system::audio::control`

Implementiert Logik zum Senden von Steuerbefehlen an PipeWire.

**Datei:** `system/audio/control.rs`

- **Funktion `set_node_volume()`:** Sucht `MonitoredDevice`/`Stream`. Passt `volume.channel_volumes` gemäß `VolumeCurve` an. Erstellt `SPA_PARAM_Props`-Pod mit `channelVolumes` (via `spa_pod_utils`). Ruft `node_proxy.set_param()`.
    
- **Funktion `set_node_mute()`:** Sucht `MonitoredDevice`/`Stream`. Erstellt `SPA_PARAM_Props`-Pod mit `mute`. Ruft `node_proxy.set_param()`.
    
- **Funktion `set_device_volume()`:** Sucht `MonitoredDevice` (Device-Proxy). Passt `volume.channel_volumes` an. Ermittelt aktive Route. Erstellt `SPA_PARAM_Route`-Pod mit `channelVolumes` für die Route. Ruft `device_proxy.set_param()`.
    
- **Funktion `set_device_mute()`:** Sucht `MonitoredDevice`. Ermittelt aktive Route. Erstellt `SPA_PARAM_Route`-Pod mit `mute` für die Route. Ruft `device_proxy.set_param()`.
    
- **Funktion `set_default_device()`:** Prüft `metadata_proxy`. Bestimmt Property-Namen (`default.audio.sink/source`). Ruft `metadata_proxy.set_property()` mit globaler ID als String.
    

#### 6.4. Submodul: `system::audio::types`

Definiert primäre Datenstrukturen für das Audio-Modul.

**Datei:** `system/audio/types.rs`

- **Enums:** `AudioDeviceType` (`Sink`, `Source`, `Unknown`), `VolumeCurve` (`Linear`, `Cubic`), `AudioCommand` (siehe Tabelle), `AudioEvent` (siehe Tabelle).
    
- **Strukturen:**
    - `Volume`: Enthält `channel_volumes: Vec<f32>` (0.0-1.0).
        
    - `AudioDevice`: Enthält `id` (globale PW ID), `proxy_id`, `name`, `description`, `device_type`, `volume`, `is_muted`, `is_default`, `ports` (optional), `properties_spa` (optional), `is_hardware_device`, `api_name`.
        
    - `StreamInfo`: Enthält `id` (globale PW ID), `name`, `application_name`, `process_id`, `volume`, `is_muted`, `media_class`, `node_id_pw` (interne PW Node ID).
        

#### 6.5. Submodul: `system::audio::spa_pod_utils`

Hilfsfunktionen zur Erstellung von `pipewire::spa::Pod`-Objekten.

**Datei:** `system/audio/spa_pod_utils.rs`

- `build_volume_props_pod()`: Erstellt Pod für `SPA_PARAM_Props` mit `SPA_PROP_channelVolumes`.
    
- `build_mute_props_pod()`: Erstellt Pod für `SPA_PARAM_Props` mit `SPA_PROP_mute`.
    
- `build_route_volume_pod()`: Erstellt Pod für `SPA_PARAM_Route` mit `SPA_PARAM_ROUTE_index`, `SPA_PARAM_ROUTE_device` und verschachtelten `SPA_PARAM_ROUTE_props` (mit `SPA_PROP_channelVolumes`).
    
- `build_route_mute_pod()`: Analog für `SPA_PROP_mute` in Route-Props.
    
- `parse_props_volume_mute()`: Extrahiert `Volume` und `mute` aus `SPA_PARAM_Props`-Pod.
    
- `parse_route_props_volume_mute()`: Extrahiert `Volume` und `mute` aus `SPA_PARAM_ROUTE`-Pod (via dessen `SPA_PARAM_ROUTE_props`).
    

#### 6.6. Submodul: `system::audio::error`

Definiert `AudioError` mittels `thiserror`.

**Datei:** `system/audio/error.rs`

- **Enum `AudioError`:** Varianten wie `PipeWireInitFailed`, `MainLoopCreationFailed`, `ContextCreationFailed`, `CoreConnectionFailed`, `RegistryCreationFailed`, `PipeWireThreadPanicked`, `ProxyBindFailed`, `ParameterEnumerationFailed`, `SpaPodParseFailed`, `SpaPodBuildFailed`, `PipeWireCommandFailed`, `DeviceOrStreamNotFound`, `NoActiveRouteFound`, `MetadataProxyNotAvailable`, `InternalChannelSendError`, `InternalBroadcastSendError`.
    

### 7. Modul: `system::mcp` (Model Context Protocol Client)

Implementiert einen Client für das Model Context Protocol (MCP) zur Kommunikation mit lokalen oder Cloud-basierten MCP-Servern für KI-gestützte Funktionen. Kommunikation typischerweise über Stdio mit JSON-RPC. Verwendet `mcp_client_rs` Crate.

#### 7.1. Submodul: `system::mcp::client`

Kernlogik für Interaktion mit MCP-Server: Starten des Serverprozesses, Senden von Anfragen, Verarbeiten von Antworten/Benachrichtigungen.

**Datei:** `system/mcp/client.rs`

- **Struktur `McpClient`:**
    - Felder: `client_handle: Option<mcp_client_rs::client::Client>`, `server_process: Option<tokio::process::Child>`, `command_sender: tokio::sync::mpsc::Sender<McpCommand>`, `notification_broadcaster: tokio::sync::broadcast::Sender<McpNotification>`, `status_broadcaster: tokio::sync::broadcast::Sender<McpClientStatus>`, `request_id_counter: Arc<AtomicU64>`, `pending_requests: Arc<Mutex<HashMap<String, tokio::sync::oneshot::Sender<Result<serde_json::Value, McpError>>>>>`, `listen_task_handle: Option<tokio::task::JoinHandle<()>>`.
        
    - Methode `new()`: Erstellt MPSC-Kanal für `McpCommand`. Startet MCP-Serverprozess (`tokio::process::Command`) mit Pipes für Stdin/Stdout/Stderr. Erstellt `mcp_client_rs::transport::stdio::StdioTransport` und `mcp_client_rs::client::Client`. Startet `listen_task`. Sendet `Initialize`-Befehl und wartet auf Antwort. Sendet `McpClientStatus`-Updates.
        
    - Private Methode `listen_task()`: Lauscht auf `StdioTransportReceiver`. Deserialisiert Nachrichten. Bei Antwort: Sendet an passenden `oneshot::Sender` aus `pending_requests`. Bei Benachrichtigung: Sendet an `notification_broadcaster`. Behandelt Fehler und Verbindungsabbruch, sendet `McpClientStatus`.
        
    - Private Methode `send_request_generic()`: Generiert `request_id`. Speichert `oneshot::Sender` in `pending_requests`. Sendet JSON-RPC-Anfrage über `client_handle` (intern via `mcp_client_rs`). Wartet auf Antwort.
        
    - Öffentliche Methoden für MCP-Requests (`list_resources`, `read_resource`, `call_tool`): Rufen `send_request_generic` auf.
        
    - Methode `shutdown()`: Sendet Shutdown-Anfrage (falls unterstützt). Bricht `listen_task` ab. Beendet Serverprozess (`child.kill()`). Sendet `McpClientStatus::Disconnected`.
        
    - Methode `get_command_sender()`: Gibt Klon des `command_sender` zurück.
        
- **Struktur `McpServerConfig`:** `command`, `args`, `working_directory`.
    
- **Enums:** `McpClientStatus` (`Disconnected`, `Connecting`, `Connected`, `Error`), `McpCommand` (z.B. `Initialize`, `ListResources`, `ReadResource`, `CallTool`, `Shutdown`).
    

#### 7.2. Submodul: `system::mcp::transport`

Abstraktionsebene für Kommunikationstransport. Meist durch `mcp_client_rs::transport::stdio::StdioTransport` abgedeckt.

#### 7.3. Submodul: `system::mcp::types`

Definitionen für MCP-Anfragen, -Antworten, -Benachrichtigungen. Meist Re-Exporte oder dünne Wrapper um `mcp_client_rs::protocol` und `mcp_client_rs::types`.

**Datei:** `system/mcp/types.rs`

- **Struktur `McpNotification`:** `method: String`, `params: Option<serde_json::Value>`.
    

#### 7.4. Submodul: `system::mcp::error`

Definiert `McpError` mittels `thiserror`.

**Datei:** `system/mcp/error.rs`

- **Enum `McpError`:** Varianten `ServerSpawnFailed`, `TransportError` (aus `mcp_client_rs::Error`), `NotConnected`, `InitializationFailed`, `SerializationFailed` (aus `serde_json::Error`), `RequestTimeout`, `ServerReturnedError` (mit `code`, `message`, `data`), `UnexpectedResponse`, `ResponseChannelDropped`, `CommandSendError`.
    

### 8. Modul: `system::portals` (XDG Desktop Portals Backend)

Implementiert Backend-Logik für XDG Desktop Portals (`org.freedesktop.portal.FileChooser`, `org.freedesktop.portal.Screenshot`). Agiert als D-Bus-Dienst, der Anfragen von Client-Anwendungen bearbeitet. Nutzt `zbus` für D-Bus-Implementierung.

#### 8.1. Submodul: `system::portals::file_chooser`

Implementiert `org.freedesktop.portal.FileChooser` D-Bus-Interface.

**Datei:** `system/portals/file_chooser.rs`

- **Struktur `FileChooserPortal`:** Enthält `connection: Arc<zbus::Connection>`, `ui_event_sender: tokio::sync::mpsc::Sender<UiPortalCommand>` (zur Kommunikation mit UI-Schicht für Dialoganzeige).
    
- **D-Bus Interface Implementierung (`#[zbus::interface(name = "org.freedesktop.portal.FileChooser")]`)**:
    - `OpenFile()`: Extrahiert Optionen. Sendet Befehl an UI-Schicht, um Dateiauswahldialog anzuzeigen. Wartet auf Antwort (ausgewählte URIs). Gibt `Ok((0, {"uris": Value::from(vec!["file:///..."])})` oder Fehlercode/D-Bus-Fehler zurück.
        
    - `SaveFile()`: Ähnlich `OpenFile`, UI zeigt "Speichern"-Dialog. Gibt einzelnen URI zurück.
        
    - `SaveFiles()`: UI zeigt Ordnerauswahldialog. Backend konstruiert vollständige URIs aus ausgewähltem Ordner und übergebenen Dateinamen (`options["files"]`).
        
    - Antworten erfolgen direkt, nicht über separates Request-Objekt für einfache Fälle.
        

#### 8.2. Submodul: `system::portals::screenshot`

Implementiert `org.freedesktop.portal.Screenshot` D-Bus-Interface.

**Datei:** `system/portals/screenshot.rs`

- **Struktur `ScreenshotPortal`:** Enthält `connection: Arc<zbus::Connection>`, `compositor_command_sender: tokio::sync::mpsc::Sender<CompositorScreenshotCommand>` (zur Kommunikation mit Compositor).
    
- **D-Bus Interface Implementierung (`#[zbus::interface(name = "org.freedesktop.portal.Screenshot")]`)**:
    - `Screenshot()`: Extrahiert `interactive`. Sendet Befehl an Compositor, Screenshot zu erstellen (interaktiv oder gesamter Bildschirm). Compositor speichert temporär, gibt Pfad zurück. Konvertiert Pfad zu URI. Gibt `Ok((0, {"uri": Value::from(screenshot_uri)}))` zurück.
        
    - `PickColor()`: Sendet Befehl an Compositor, Farbauswahlmodus zu starten. Compositor meldet RGB-Werte. Gibt `Ok((0, {"color": Value::from((r,g,b))}))` zurück.
        
    - Property `version()`: Gibt implementierte Portal-Version zurück (z.B. 2).
        

#### 8.3. Submodul: `system::portals::common`

Gemeinsame Hilfsmittel und D-Bus-Handhabung.

**Datei:** `system/portals/common.rs`

- **Funktion `run_portal_service()`:**
    - Erstellt D-Bus-Verbindung zum Session-Bus. Registriert Dienstnamen `org.freedesktop.portal.Desktop`.
        
    - Erstellt Instanzen der Portal-Implementierungen (z.B. `FileChooserPortal`, `ScreenshotPortal`).
        
    - Registriert eine einzelne `DesktopPortal`-Struktur (die alle Portal-Interfaces implementiert oder delegiert) unter Pfad `/org/freedesktop/portal/desktop` beim `ObjectServer`.
        
    - Hält Dienst am Laufen.
        
- **Funktion `generate_request_handle()`:** Erzeugt eindeutigen Handle-String für Portal-Anfragen.
    
- **Hilfsstrukturen/Enums für UI/Compositor-Kommunikation:** `UiPortalCommand` (mit `OpenFileOptions`, `SaveFileOptions`), `PortalUiError`, `CompositorScreenshotCommand`.
    

#### 8.4. Submodul: `system::portals::error`

Definiert `PortalsError` mittels `thiserror`.

**Datei:** `system/portals/error.rs`

- **Enum `PortalsError`:** Varianten `DBusConnectionFailed` (aus `zbus::Error`), `DBusNameAcquisitionFailed`, `DBusInterfaceRegistrationFailed`, `UiCommandSendError`, `CompositorCommandSendError`, `UiInteractionFailed`, `CompositorInteractionFailed`, `InvalidOptions`.
    

### Schlussfolgerung

Diese detaillierte technische Spezifikation für die Systemschicht, basierend auf den bereitgestellten Dokumenten, deckt die Kernmodule Compositor, Input, D-Bus-Interaktion, Output-Management, Audio-Integration, MCP-Client und XDG-Desktop-Portal-Backends ab. Die konsequente Anwendung der Entwicklungsrichtlinien und die Nutzung moderner Technologien wie Rust, Smithay, PipeWire und D-Bus sollen eine robuste, performante und wartbare Systemschicht gewährleisten, die als solide Grundlage für die gesamte Desktop-Umgebung dient.

## Technische Spezifikation und Entwicklungsrichtlinien: Kernschicht

Diese Spezifikation beschreibt die fundamentalen Komponenten und Richtlinien für die Entwicklung der Kernschicht der Desktop-Umgebung. Die Kernschicht bildet das Fundament für alle darüberliegenden Schichten und umfasst Module für grundlegende Datentypen (`core::types`), Fehlerbehandlung (`core::errors`), Logging (`core::logging`), Konfigurationsmanagement (`core::config`) und allgemeine Hilfsfunktionen (`core::utils`).

### 1. Modul: `core::types` (Fundamentale Datentypen)

**1.1. Zweck und Verantwortlichkeit** Das Modul `core::types` definiert grundlegende, universell einsetzbare Datentypen, die von allen anderen Schichten und Modulen benötigt werden. Dazu gehören geometrische Primitive, Farbdarstellungen und allgemeine Enumerationen. Diese Typen sind reine Datenstrukturen ohne komplexe Geschäftslogik oder Abhängigkeiten zu höheren Schichten.

**1.2. Designphilosophie** Das Design folgt den Prinzipien der Modularität, Wiederverwendbarkeit und minimalen Kopplung. Typen sind generisch gehalten, wo sinnvoll (z.B. `Point<T>`, `Size<T>`, `Rect<T>`), um Flexibilität für verschiedene numerische Darstellungen zu ermöglichen (z.B. `i32` für Koordinaten, `f32` für Skalierungsfaktoren). Es besteht eine klare Trennung von Datenrepräsentation und Fehlerbehandlung.

**1.3. Ziel-Dateistruktur**

```
core/
└── src/
    ├── lib.rs         # Deklariert Kernmodule: pub mod types; pub mod errors; ...
    └── types/
        ├── mod.rs     # Deklariert und re-exportiert Typen aus geometry.rs, color.rs, etc.
        ├── geometry.rs # Enthält Point<T>, Size<T>, Rect<T>
        ├── color.rs    # Enthält Color
        └── enums.rs    # Enthält Orientation, etc.
```

**1.4. Spezifikation: Geometrische Primitive (`geometry.rs`)**

- **`Point<T>`**: Repräsentiert einen Punkt im 2D-Raum mit `x: T` und `y: T`.
    
    - Konstanten wie `ZERO_I32`, `ZERO_F32` etc..
        
    - Methoden: `new(x: T, y: T)`, `distance_squared(...)`, `distance(...)` (für Float-Typen), `manhattan_distance(...)`.
        
    - Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
        
- **`Size<T>`**: Repräsentiert eine 2D-Dimension mit `width: T` und `height: T`.
    
    - Konstanten wie `ZERO_I32`, `ZERO_F32` etc..
        
    - Methoden: `new(width: T, height: T)`, `area()`, `is_empty()`, `is_valid()` (für nicht-negative Dimensionen).
        
    - Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`. Die Invariante nicht-negativer Dimensionen wird durch `is_valid()` prüfbar gemacht, aber nicht durch den Typ erzwungen.
        
- **`Rect<T>`**: Repräsentiert ein 2D-Rechteck, definiert durch `origin: Point<T>` und `size: Size<T>`.
    
    - Konstanten wie `ZERO_I32`, `ZERO_F32` etc..
        
    - Methoden: `new(origin, size)`, `from_coords(x,y,width,height)`, Zugriffsmethoden (`x()`, `y()`, `width()`, `height()`, `top()`, `left()`, `bottom()`, `right()`), `center()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translated(...)`, `scaled(...)`, `is_valid()`.
        
    - Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`.
        
    - **Invariante**: Logisch sollten `width` und `height` nicht-negativ sein. Die Methode `is_valid()` wird bereitgestellt; Nutzer (besonders mit `T=i32`) sollten diese aufrufen. Die Verantwortung für das Melden eines Fehlers bei Verwendung eines ungültigen `Rect` liegt beim Aufrufer.
        
- **`RectInt`**: (aus einer anderen Quelldatei, aber thematisch passend) Repräsentiert ein achsenparalleles Rechteck mit ganzzahligen Koordinaten (`x: i32`, `y: i32`) und Dimensionen (`width: u32`, `height: u32`).
    
    - Methoden u.a. `new(...)`, `from_points(...)`, `top_left()`, `size()`, `right()`, `bottom()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translate(...)`, `inflate(...)`, `is_empty()`.
        
    - Verwendet `saturating_add` / `saturating_sub` um Überläufe zu vermeiden.
        
    - Traits: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Default`.
        

**1.5. Spezifikation: Farbdarstellung (`color.rs`)**

- **`Color` (RGBA)**: Repräsentiert eine Farbe mit `r: f32`, `g: f32`, `b: f32`, `a: f32` Komponenten im Bereich `[0.0, 1.0]`.
    
    - Konstanten: `TRANSPARENT`, `BLACK`, `WHITE`, `RED`, `GREEN`, `BLUE` etc..
        
    - Methoden: `new(r,g,b,a)` (klemmt Werte nicht automatisch, Aufruferverantwortung), `from_rgba8(r,g,b,a)`, `to_rgba8()`, `with_alpha(alpha)` (klemmt Alpha), `blend(background)`, `lighten(amount)`, `darken(amount)`.
        
    - `Default` wird manuell implementiert, um `Color::TRANSPARENT` zurückzugeben.
        
    - Soll `Serialize` und `Deserialize` implementieren, um als Hex-String (z.B. "#RRGGBBAA") in Konfigurationsdateien dargestellt zu werden. Dies erfordert eine `ColorParseError`-Behandlung.
        

**1.6. Spezifikation: Allgemeine Enumerationen (`enums.rs`)**

- **`Orientation`**: Repräsentiert eine horizontale oder vertikale Ausrichtung.
    
    - Varianten: `Horizontal`, `Vertical`.
        
    - Methoden: `toggle()`.
        
    - `Default` ist `Orientation::Horizontal`.
        

**1.7. Standard Trait Implementierungen** Alle Typen sollen grundlegende Traits wie `Debug`, `Clone`, `Copy` (wo anwendbar und `T` es unterstützt), `PartialEq`, `Default` (sinnvoll definiert), `Send` und `Sync` implementieren. `Eq` und `Hash` sind für Fließkommazahlen generell nicht geeignet.

**1.8. Modulabhängigkeiten** Minimale externe Abhängigkeiten: `std`. Optional `num-traits` (für erweiterte numerische Operationen) und `serde` (mit `derive`-Feature, falls Serialisierung direkt hier benötigt wird, aktuell aber eher in höheren Schichten vorgesehen).

### 2. Modul: `core::errors` (Fehlerbehandlung)

**2.1. Zweck und Geltungsbereich** Spezifiziert die verbindliche Strategie und Implementierung der Fehlerbehandlung innerhalb der Kernschicht. Ziel ist eine lückenlose, präzise Spezifikation für Entwickler.

**2.2. Grundlagen und Prinzipien**

- **Verwendung von `thiserror`**: Obligatorisch für die Definition von benutzerdefinierten Fehlertypen. `thiserror` reduziert Boilerplate-Code für `std::error::Error` und `std::fmt::Display`. Alle benutzerdefinierten Fehler-Enums in der Kernschicht müssen `thiserror::Error` ableiten.
    
- **`Result<T, E>` vs. `panic!`**: Strikte Trennung.
    
    - `Result<T, E>`: Standard für erwartete, potenziell behebbare Fehlerzustände (z.B. I/O-Fehler, ungültige Eingaben). Funktionen müssen `Result<T, E>` zurückgeben, wobei `E` typischerweise `CoreError` oder ein spezifischerer Modul-Fehler ist.
        
    - `panic!`: Ausschließlich für nicht behebbare Programmierfehler (Bugs), Verletzung von Vorbedingungen oder logisch unmögliche interne Zustände.
        
- **Umgang mit `.unwrap()` und `.expect()`**: In produktivem Code der Kernschicht strengstens zu vermeiden, da sie die strukturierte Fehlerbehandlung umgehen.
    
    - Ausnahme für `expect()`: Nur wenn ein `Err`- oder `None`-Zustand nachweislich einen Bug darstellt (interne Invariante verletzt). Die Nachricht muss dem "expect as precondition"-Stil folgen und erklären, _warum_ ein `Ok`- oder `Some`-Wert erwartet wurde.
        
- **Anforderungen an Fehlermeldungen (`#[error("...")]`)**:
    - Klarheit und Präzision, eindeutige Problembeschreibung.
        
    - Kontextinformationen durch eingebettete Feldwerte (`{field_name}`).
        
    - Zielgruppe: Entwickler (für Logging/Debugging).
        
    - Format: Knappe, klein geschriebene Sätze ohne abschließende Satzzeichen (Rust API Guidelines).
        
- **Keine sensiblen Daten in Fehlermeldungen**: Niemals Passwörter, API-Schlüssel, private Benutzerdaten etc. in Fehlermeldungen oder Kontextfeldern. Daten müssen maskiert, entfernt oder durch Platzhalter ersetzt werden.
    

**2.3. Strategie: Ein Fehler-Enum pro Modul** Jedes signifikante Modul innerhalb der Kernschicht (und höheren Schichten) definiert sein eigenes, spezifisches Fehler-Enum mit `thiserror`. Dies vermeidet Überladung des zentralen `CoreError` und adressiert `thiserror`-Einschränkungen bezüglich mehrdeutiger `#[from]`-Konvertierungen desselben Quelltyps.

**2.4. Definition des Basis-Fehlertyps: `CoreError`** Ein zentrales, öffentliches Enum `CoreError` in `core::errors` dient als primäre Schnittstelle für Fehler, die von öffentlichen Funktionen der Kernschicht propagiert werden. Es aggregiert allgemeine Fehlerarten und spezifischere Fehler aus Untermodulen (via `#[from]`).

- **Spezifikation `CoreError`** (Beispielvarianten):
    
    - `Io { path: PathBuf, #[source] source: std::io::Error }`
        
    - `Configuration(#[from] ConfigError)`
        
    - `Serialization { description: String }`
        
    - `InvalidId { invalid_id: String }`
        
    - `NotFound { resource_description: String }`
        
    - `Internal(String)` (sollte vermieden und durch spezifischere Varianten ersetzt werden)
        
    - `InitializationFailed { component: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
        
- **Ableitungen**: Mindestens `Debug` und `thiserror::Error`.
    
- **Fehlerverkettung (`source()`)**: Wird von `thiserror` automatisch für `#[source]` und `#[from]` annotierte Felder implementiert, um die Ursache zurückzuverfolgen.
    

**2.5. Modul-spezifische Fehler und Integration** Module definieren eigene Fehler-Enums (z.B. `ConfigError`, `UtilsError`) die `thiserror::Error` ableiten.

- **Integrationsmechanismus**: Eine dedizierte Variante in `CoreError`, die den Modul-Fehler kapselt und `#[from]` verwendet, ist der bevorzugte Weg. Beispiel: `Configuration(#[from] ConfigError)` in `CoreError`.
    
- Dies etabliert eine zweistufige Fehlerhierarchie.
    

**2.6. Fehlerkontext und Diagnose** Fehlervarianten sollen relevante Kontextinformationen als Felder enthalten (Dateipfade, ungültige Werte etc.).

**2.7. Implementierungsleitfaden für Entwickler (Fehlerdefinition und -behandlung)**

- **Neue Variante zu `CoreError` hinzufügen**: Prüfen, ob der Fehlerfall allgemeine Bedeutung hat oder besser in einem Modul-Fehler aufgehoben ist. Variante, `#[error]`-Meldung und Kontextfelder definieren. `#[source]` oder `#[from]` für Kapselung verwenden.
    
- **Neuen Modul-Fehler erstellen**: `errors.rs` im Modulverzeichnis anlegen. Enum definieren, `thiserror::Error` ableiten, Varianten und Meldungen spezifizieren. In `CoreError` über eine `#[from]`-Variante integrieren.
    
- **Verwendung des `?`-Operators**: Standard für Fehlerpropagation. Funktioniert nahtlos bei identischen Fehlertypen oder existierender `From`-Implementierung.
    
- **Fehler-Matching (`match`)**: Für spezifische Behandlung (Standardwerte, alternative Pfade, Anreicherung).
    
- **Umgang mit externen Crates**: Fehler von externen Bibliotheken müssen in einen Kernschicht-Fehlertyp (`CoreError` oder Modul-Fehler) gekapselt werden. Bevorzugt mit `#[from]` oder `#[source]` (manuelle Erzeugung via `.map_err()`).
    

### 3. Modul: `core::logging` (Logging-Infrastruktur)

**3.1. Grundlagen und Wahl von `tracing`** Die Desktop-Umgebung verwendet das `tracing`-Crate für strukturiertes Logging. `core::logging` stellt Initialisierungsroutinen bereit.

**3.2. `tracing` Framework Integrationsdetails**

- **Initialisierung**: Eine Funktion `initialize_logging(level_filter: tracing::LevelFilter, format: LogFormatEnum) -> Result<(), LoggingError>` wird früh im Anwendungsstart aufgerufen. `LogFormatEnum` könnte `PlainTextDevelopment`, `JsonProduction` definieren. `LoggingError` ist ein `thiserror`-Enum in `core::logging`.
    
- **Subscriber-Konfiguration**:
    - Entwicklung: `tracing_subscriber::fmt()` mit menschenlesbarer Ausgabe (`with_ansi(true)`, `with_target(true)`, `with_file(true)`, `with_line_number(true)`).
        
    - Release: Strukturiertes JSON-Format für Log-Aggregation und maschinelle Analyse (`tracing_subscriber::fmt::json()` oder `tracing-bunyan-formatter`).
        
- **Dynamische Log-Level-Änderungen**: Für zukünftige Erweiterungen berücksichtigen (z.B. via `tracing_subscriber::filter::EnvFilter` oder `RUST_LOG`).
    

**3.3. Standardisierte Log-Makros und `tracing::instrument` Verwendung**

- **Standard-Makros**: Direkte Verwendung von `trace!`, `debug!`, `info!`, `warn!`, `error!` ist verbindlich.
    
- **Log-Nachrichtenstruktur**: Prägnant und beschreibend. Schlüssel-Wert-Paare für strukturierte Daten: `tracing::info!(user_id = %user.id, " Nachricht")` (% für Display, ? für Debug). Fehler mit `error = ?err` loggen, um die Debug-Repräsentation (inkl. `source`-Kette) zu erfassen.
    
- **`#[tracing::instrument]` Verwendung**: Erzeugt Spans für Funktionen/Codeblöcke, gruppiert Log-Ereignisse.
    
    - Anwendung auf öffentliche API-Funktionen, I/O-Operationen, komplexe Berechnungen, abgeschlossene operative Einheiten.
        
    - `skip(...)` / `skip_all` für sensible/ausführliche Argumente.
        
    - `fields(...)` für spezifischen Kontext im Span.
        
    - `err` zur automatischen Fehlerprotokollierung bei `Result::Err`.
        
    - `level` zur Steuerung des Span-Levels.
        

**3.4. Logging von Fehlern** Jeder Fehler (`Result::Err`) sollte an seiner Ursprungsstelle oder einer geeigneten übergeordneten Stelle mit ausreichend Kontext geloggt werden, mindestens auf `ERROR`-Level (`tracing::error!`). Dies sollte typischerweise _vor_ der Propagation geschehen. Den Fehler selbst als strukturiertes Feld mitgeben: `error!(error = %core_err, "Nachricht")`.

**3.5. Log-Daten Sensibilität** Absolutes Verbot, sensible Daten (Passwörter, API-Schlüssel, PII etc.) im Klartext zu loggen. Daten redigieren oder auslassen. Vorsicht bei `Debug`-Implementierungen für Strukturen mit sensiblen Daten; ggf. manuelle Redaktion in `Debug` oder `skip_all` in `#[tracing::instrument]` verwenden.

### 4. Modul: `core::config` (Konfigurationsprimitive)

**4.1. Zweck** Definiert, wie grundlegende Konfigurationseinstellungen geladen, geparst und zugegriffen werden. Fokus auf Einfachheit, Robustheit.

**4.2. Konfigurationsdateiformat und Parsing-Logik**

- **Format**: TOML (Tom's Obvious, Minimal Language) wegen Lesbarkeit und einfacher Verarbeitung.
    
- **Parsing-Bibliothek**: `serde` in Verbindung mit `toml`-Crate (`serde_toml`).
    
- **Ladelogik**:
    - Definition von Standard-Konfigurationspfaden (z.B. systemweit, Entwicklungstests). XDG-Pfade für benutzerspezifische Konfigurationen in höheren Schichten berücksichtigen.
        
    - Eine Funktion wie `load_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError>` implementiert eine Suchreihenfolge, liest und deserialisiert die TOML-Datei.
        
    - Fehlerbehandlung mit `core::config::ConfigError` (definiert mit `thiserror`), Varianten wie `FileReadError`, `DeserializationError`, `NoConfigurationFileFound`.
        

**4.3. Konfigurationsdatenstrukturen (Ultra-Fein)**

- **`CoreConfig`-Struktur**: Eine primäre Struktur (z.B. `CoreConfig`) hält alle spezifischen Konfigurationen der Kernschicht.
    
    - Felder mit explizit definierten Typen.
        
    - Muss `serde::Deserialize` ableiten.
        
    - `#[serde(default = "path")]` oder `#[serde(default)]` umfassend verwenden für Standardwerte bei fehlenden Feldern.
        
    - `#[serde(deny_unknown_fields)]` erzwingen, um Tippfehler oder unbekannte Felder in Konfigurationsdateien zu verhindern.
        
- **Validierung**: Grundlegende Validierung durch Typen. Komplexere Validierungen nach Deserialisierung (z.B. via `TryFrom` Muster oder `validate()`-Methode). Für Kernschicht kann initiale Validierung auf `serde`-Fähigkeiten beschränkt sein.
    

**4.4. Konfigurationszugriffs-API**

- **Globaler Zugriff**: Geladene `CoreConfig`-Instanz threadsicher speichern, typischerweise mittels `once_cell::sync::OnceCell`.
    
    - `initialize_core_config(config: CoreConfig) -> Result<(), CoreConfig>` zum einmaligen Setzen.
        
    - `get_core_config() -> &'static CoreConfig` für den Zugriff; paniert, wenn nicht initialisiert (Programmierfehler).
        
- **Immutabilität**: Global zugängliche Konfiguration sollte nach Initialisierung unveränderlich sein. `CoreConfig` sollte `Clone` ableiten für Momentaufnahmen oder Tests.
    

### 5. Modul: `core::utils` (Allgemeine Hilfsfunktionen)

**5.1. Zweck** Beherbergt allgemeine Hilfsfunktionen und kleine, in sich geschlossene Utilities, die nicht in spezifischere Module passen, aber breit verwendet werden.

**5.2. Allgemeine Richtlinien**

- **Geltungsbereich**: Nur wirklich allgemeine Utilities.
- **Einfachheit**: Einfache Funktionen bevorzugen.
- **Reinheit**: Reine Funktionen (Ausgabe hängt nur von Eingabe ab, keine Seiteneffekte) bevorzugen.
- **Fehlerbehandlung**: Jede fehleranfällige Utility-Funktion gibt `Result<T, YourUtilError>` zurück, wobei `YourUtilError` mit `thiserror` im Utility-Submodul definiert wird.
- **Dokumentation**: Umfassende `rustdoc`-Kommentare mit Beispielen.
- **Tests**: Gründliche Unit-Tests.

### 6. Allgemeine Entwicklungsrichtlinien (Kernschicht)

**6.1. Dokumentation (`rustdoc`)** Alle öffentlichen Elemente (Module, Structs, Enums, Felder, Konstanten, Methoden) müssen `///`-Dokumentationskommentare haben.

- Modul-Level: Zweck des Moduls.
- Typ-Level: Zweck und Invarianten.
- Feld-Level: Bedeutung des Feldes.
- Methoden-Level: Was die Methode tut, Parameter, Rückgabewerte, mögliche Panics (idealerweise keine außer in Tests), Vor-/Nachbedingungen, Algorithmen.
- `# Examples`-Abschnitte verwenden.
- Strikte Einhaltung der Rust API Guidelines.
- `cargo doc --open` zur Überprüfung.

**6.2. Unit-Testing**

- Ein `#[cfg(test)]`-Modul innerhalb jeder Implementierungsdatei.
- Tests für Konstruktoren, Konstanten, Methodenlogik, Grenzfälle, Trait-Implementierungen, Invariantenprüfungen.
- Anstreben einer hohen Testabdeckung.

**6.3. Immutabilität und Stabilität** Die API der Kernschicht sollte nach Stabilisierung als äußerst stabil behandelt werden. Änderungen haben weitreichende Auswirkungen. Komponenten sind so konzipiert, dass sie `Send + Sync` sind, wo sinnvoll, für Multithreading.

**6.4. Schichtübergreifende Integrationsrichtlinien**

- **Fehlerbehandlung**: Höhere Schichten definieren eigene `thiserror`-Enums. Fehler aus der Kernschicht werden behandelt oder via `?` propagiert (ggf. mit `#[from]` in eigene Fehlertypen konvertiert), Fehlerkette (`source()`) muss erhalten bleiben.
- **Logging**: Alle Schichten nutzen `tracing`-Makros. `core::logging::initialize_logging()` wird vom Hauptbinary aufgerufen. Einhaltung von Log-Leveln und Datensensibilität ist zwingend.
- **Konfiguration**: Höhere Schichten können eigene Konfigs definieren. Zugriff auf Kern-Konfig via `core::config::get_core_config()`. Kern-Konfig nicht zur Laufzeit modifizieren.
- **Typen und Utilities**: Kerndatentypen und -utilities direkt verwenden. Bei Spezialisierung Komposition oder Newtype-Wrapper um Kerntypen in Betracht ziehen.

Diese Spezifikation legt den Grundstein für eine robuste, wartbare und performante Kernschicht. Die disziplinierte Einhaltung dieser Richtlinien ist für den Erfolg des Projekts entscheidend.
## Spezifikation und Implementierungsanleitung für die NovaDE-Systemschicht

**Ziel:** Erstellung einer robusten, performanten und modularen Systemschicht für die Nova Desktop Environment (NovaDE) in Rust. Diese Schicht interagiert mit dem Betriebssystem, der Hardware und externen Diensten und setzt die Richtlinien der Domänenschicht technisch um. Sie stellt die Grundlage für die Benutzeroberflächenschicht dar.

**Kernmodule und ihre Hauptverantwortlichkeiten:**

1. **`system::compositor`**: Smithay-basierter Wayland-Compositor; Fenster-Lebenszyklus, Protokoll-Implementierung (XDG-Shell, Layer-Shell etc.), Renderer-Abstraktion, XWayland.
2. **`system::input`**: `libinput`-basierte Eingabeverarbeitung; Seat-Management, `xkbcommon`-Integration, Event-Übersetzung für Tastatur, Zeiger, Touch, Gesten.
3. **`system::dbus_interfaces`**: `zbus`-basierte Clients für Systemdienste (NetworkManager, UPower, logind, Secrets, PolicyKit) und Server für `org.freedesktop.Notifications`.
4. **`system::audio_management`**: `pipewire-rs`-basierte PipeWire-Integration; Geräte- und Stream-Management, Lautstärkeregelung.
5. **`system::mcp_client`**: `mcp_client_rs`-basierter Client für das Model Context Protocol; sichere KI-Modell-Kommunikation.
6. **`system::window_mechanics`**: Technische Umsetzung der Fenster-Policies aus der Domänenschicht (Positionierung, Tiling, Fokus).
7. **`system::power_management`**: DPMS-Steuerung, Reaktion auf Inaktivität und logind-Ereignisse.
8. **`system::event_bridge`**: Zentraler Hub für systeminterne Events via `tokio::sync::broadcast`.

**Technologie-Stack (Auszug für Systemschicht):** Rust, Smithay, `libinput`, `xkbcommon`, `zbus`, `pipewire-rs`, `mcp_client_rs`, `calloop`, `tokio`.

**Entwicklungsrichtlinien:** Modulare Fehlerbehandlung (`thiserror`), strukturiertes Logging (`tracing`), `async/await` für nebenläufige Operationen.

**Folgend nun die detaillierten, feingranularen Schnittstellenspezifikationen pro Modul, die als direkte Implementierungsanweisung für eine KI-gestützte Entwicklung dienen.**

---

## Ultra-Feingranulare Schnittstellenspezifikation: NovaDE Systemschicht (`novade-system`)

Dieser Implementierungsleitfaden ist so konzipiert, dass er von einem autonomen KI-Entwicklungsagenten (z.B. Manus AI) direkt zur Codegenerierung verwendet werden kann. Jede Komponente, Datenstruktur, Methode und Interaktion ist explizit definiert, um Interpretationsspielraum zu minimieren.

### Modul 0: Vorbemerkungen und Globale Systemschicht-Konventionen

- **Crate-Name:** `novade-system`
- **Abhängigkeiten (exemplarisch, in `Cargo.toml` zu definieren):**
    - `novade-core = { path = "../novade-core" }`
    - `novade-domain = { path = "../novade-domain" }`
    - `smithay = "0.10.0"` (Version prüfen und Features nach Bedarf: `renderer_gl`, `backend_libinput`, `backend_session`, `backend_udev`, `backend_drm`, `desktop`, `xwayland`)
    - `wayland-server = "0.30"` (Smithay-kompatible Version)
    - `wayland-protocols = { version = "0.30", features = ["server", "unstable_protocols"] }`
    - `calloop = "0.12"`
    - `libinput = "0.9"`
    - `xkbcommon = "0.7"`
    - `zbus = { version = "3.15", default-features = false, features = ["tokio"] }` (Version prüfen)
    - `pipewire = "0.8"` (Version prüfen, ggf. `libspa`)
    - `mcp_client_rs = "0.2.0"` (Version prüfen)
    - `tokio = { version = "1.37", features = ["full"] }`
    - `async-trait = "0.1"`
    - `thiserror = "1.0"`
    - `tracing = "0.1"`
    - `uuid = { version = "1.8", features = ["v4"] }`
    - `serde = { version = "1.0", features = ["derive"] }`
    - `serde_json = "1.0"`
- **Fehlerbehandlung:** Jedes Submodul definiert ein eigenes `Error`-Enum mit `#[derive(Debug, thiserror::Error)]`. Fehler aus Bibliotheken werden mit `#[source]` oder `#[from]` gewrappt.
- **Logging:** `tracing::{trace, debug, info, warn, error}` Makros verwenden.
- **Asynchronität:** `async fn` für Operationen, die blockieren könnten. `calloop` für die Compositor-Hauptschleife, `tokio` für D-Bus, MCP und andere nebenläufige Tasks.

### Modul 1: `system::compositor`

Zweck: Implementierung des Wayland-Compositors.

#### 1.1. Submodul: `system::compositor::errors`

Datei: `src/compositor/errors.rs`

- **Enum `CompositorError`**:
    - Varianten (mit `#[error("...")]` und ggf. `#[source]` / `#[from]`):
        - `GlobalCreationFailed { name: String, details: String }`
        - `SurfaceRoleError(#[from] smithay::wayland::compositor::SurfaceRoleError)`
        - `ClientDataMissing { client_id_str: String }` (ClientId zu String für `Display`)
        - `SurfaceDataMissing { surface_id_str: String }` (WlSurface Debug zu String)
        - `InvalidSurfaceState { surface_id_str: String, reason: String }`
        - `RendererInitializationFailed(String)`
        - `DisplayOrLoopCreationFailed(String)`
        - `XWaylandInitializationFailed(String)`
        - `DrmBackendError { details: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
        - `LibinputBackendError(String)`
        - `SessionError(String)`
        - `XdgShellError(#[from] crate::compositor::xdg_shell::errors::XdgShellError)` (aus eigenem Submodul)
        - `LayerShellError(#[from] crate::compositor::layer_shell::errors::LayerShellError)` (aus eigenem Submodul)
        - `OutputManagementError(#[from] crate::compositor::output_management::errors::OutputManagementError)` (aus eigenem Submodul)

#### 1.2. Submodul: `system::compositor::types` (oder direkt in `core::state` und `surface_management`)

Datei: `src/compositor/types.rs` (oder aufgeteilt)

- **Struct `ClientCompositorData`** (für `Client::data_map`):
    - `compositor_state: smithay::wayland::compositor::CompositorClientState`
    - `xdg_shell_client_data: smithay::wayland::shell::xdg::XdgWmBaseClientData` (oder `XdgShellClientData` je nach Smithay Version)
- **Struct `SurfaceData`** (für `WlSurface::data_map`):
    - `id: uuid::Uuid`
    - `client_id_str: String`
    - `role: std::sync::Mutex<Option<String>>`
    - `current_buffer_info: std::sync::Mutex<Option<AttachedBufferInfo>>`
    - `texture_handle: std::sync::Mutex<Option<Box<dyn crate::compositor::renderer_interface::RenderableTexture>>>`
    - `damage_buffer_coords: std::sync::Mutex<Vec<smithay::utils::Rectangle<i32, smithay::utils::Buffer>>>`
    - `opaque_region_surface_local: std::sync::Mutex<Option<smithay::utils::Region<smithay::utils::Logical>>>`
    - `input_region_surface_local: std::sync::Mutex<Option<smithay::utils::Region<smithay::utils::Logical>>>`
    - `parent: std::sync::Mutex<Option<wayland_server::Weak<wayland_server::protocol::wl_surface::WlSurface>>>`
    - `children: std::sync::Mutex<Vec<wayland_server::Weak<wayland_server::protocol::wl_surface::WlSurface>>>`
    - `surface_viewporter_state: std::sync::Mutex<smithay::wayland::viewporter::SurfaceState>`
    - `surface_presentation_state: std::sync::Mutex<smithay::wayland::presentation::SurfaceState>`
    - `user_data_map: smithay::reexports::wayland_server::backend::UserDataMap` (für Shell-spezifische Daten)
    - **Methoden:** `new(client_id_str: String) -> Self`, `set_role(&self, role: &str) -> Result<(), CompositorError>`, `get_role(&self) -> Option<String>`.
- **Struct `AttachedBufferInfo`**:
    - `buffer: wayland_server::protocol::wl_buffer::WlBuffer`
    - `scale: i32`
    - `transform: smithay::utils::Transform`
    - `dimensions: smithay::utils::Size<i32, smithay::utils::Buffer>`

#### 1.3. Submodul: `system::compositor::core`

Datei: `src/compositor/core/state.rs`

- **Struct `DesktopState`** (zentraler Zustand, Details aus Gesamtspezifikation und System-Details):
    - **Felder (Auswahl):**
        - `display_handle: smithay::reexports::wayland_server::DisplayHandle`
        - `loop_handle: smithay::reexports::calloop::LoopHandle<'static, Self>`
        - `clock: smithay::utils::Clock<u64>`
        - `compositor_state: smithay::wayland::compositor::CompositorState`
        - `shm_state: smithay::wayland::shm::ShmState`
        - `presentation_state: smithay::wayland::presentation::PresentationState`
        - `viewporter_state: smithay::wayland::viewporter::ViewporterState`
        - `xdg_shell_state: smithay::wayland::shell::xdg::XdgShellState`
        - `xdg_activation_state: smithay::wayland::xdg_activation::XdgActivationState`
        - `layer_shell_state: smithay::wayland::shell::wlr_layer::WlrLayerShellState`
        - `decoration_state: smithay::wayland::shell::xdg::decoration::XdgDecorationState`
        - `space: std::sync::Arc<std::sync::Mutex<smithay::desktop::Space<ManagedWindow>>>`
        - `windows: std::sync::Arc<std::sync::Mutex<std::collections::HashMap<crate::domain::workspaces::core::types::WindowIdentifier, Arc<ManagedWindow>>>>`
        - `seat_state: smithay::input::SeatState<Self>`
        - `seat: smithay::input::Seat<Self>`
        - `seat_name: String`
        - `input_method_manager_state: smithay::wayland::input_method::InputMethodManagerState`
        - `keyboard_data_map: std::sync::Arc<std::sync::Mutex<std::collections::HashMap<String, crate::input::keyboard::xkb_config::XkbKeyboardData>>>`
        - `current_cursor_status: std::sync::Arc<std::sync::Mutex<smithay::input::pointer::CursorImageStatus>>`
        - `pointer_location: std::sync::Arc<std::sync::Mutex<smithay::utils::Point<f64, smithay::utils::Logical>>>`
        - `output_manager_state: smithay::wayland::output::OutputManagerState`
        - `wlr_output_manager_v1_state: smithay::wayland::output_manager::OutputManagerState` (für wlr-output-management)
        - `wlr_output_power_manager_v1_state: smithay::wayland::output_power_manager::OutputPowerManagerState` (für wlr-output-power-management)
        - `data_device_state: smithay::wayland::selection::data_device::DataDeviceState`
        - `renderer: Option<Box<dyn crate::compositor::renderer_interface::FrameRenderer>>` (wird nach Backend-Init gesetzt)
        - `domain_services: Arc<crate::domain::DomainServices>` (Sammelstruktur für Domänen-Service-Handles)
        - `system_event_bridge: Arc<crate::event_bridge::SystemEventBridge>`
        - `active_backend_data: std::sync::Mutex<Option<ActiveBackendData>>` (Enum für DRM, Winit etc. Daten)
        - `wayland_globals: Option<NovaDEWaylandGlobals>` (Struct, das `GlobalId`s hält)
    - **Konstruktor:** `pub fn new(loop_handle, display_handle, domain_services, system_event_bridge) -> Self` (initialisiert alle Smithay-States).
    - **Methoden:** `pub fn create_all_wayland_globals(&mut self) -> Result<(), CompositorError>` (registriert alle Globals).
- **Implementierung von `smithay::wayland::compositor::CompositorHandler` für `DesktopState`**:
    - `compositor_state(&mut self) -> &mut CompositorState`: `&mut self.compositor_state`
    - `client_compositor_state<'a>(&self, client: &'a Client) -> &'a CompositorClientState`: `&client.get_data::<ClientCompositorData>().unwrap().compositor_state`
    - `commit(&mut self, surface: &WlSurface)`: Logik wie in spezifiziert (Puffer-Handling, Schaden, Rollen-Dispatch, Sync-Subsurfaces). Verwendet `with_surface_data_mut` für Zugriff auf `SurfaceData`.
    - `new_surface(&mut self, surface: &WlSurface)`: `surface.data_map().insert_if_missing_threadsafe(|| Arc::new(SurfaceData::new(...))); add_destruction_hook(...)`.
    - `new_subsurface(&mut self, surface: &WlSurface, parent: &WlSurface)`: Verlinkt Parent/Child in `SurfaceData`.
    - `destroyed(&mut self, surface: &WlSurface)`: Hauptsächlich für Logging und ggf. explizite Benachrichtigung anderer Teile von `DesktopState`, die `WlSurface` direkt referenzieren (obwohl `destruction_hook` bevorzugt wird).
- **Implementierung von `smithay::wayland::shm::ShmHandler` und `smithay::wayland::buffer::BufferHandler` für `DesktopState`**:
    - `shm_state(&self) -> &ShmState`: `&self.shm_state`
    - `buffer_destroyed(&mut self, buffer: &WlBuffer)`: Benachrichtigt Renderer zur Freigabe von Texturen, die mit diesem `buffer` assoziiert sind (Identifikation über `SurfaceData`).

#### 1.4. Submodul: `system::compositor::xdg_shell`

Datei: `src/compositor/xdg_shell/errors.rs`, `types.rs`, `handlers.rs`

- **Enum `XdgShellError`**: (Wie in spezifiziert)
- **Struct `ManagedWindow`** (Implementiert `smithay::desktop::Window`):
    - **Felder:** `id: uuid::Uuid`, `domain_id: crate::domain::workspaces::core::types::WindowIdentifier`, `xdg_surface: smithay::desktop::WindowSurface` (hält `ToplevelSurface` oder `PopupSurface`), `current_geometry: smithay::utils::Rectangle<i32, smithay::utils::Logical>`, `is_mapped: bool`, `requested_size`, `min_size`, `max_size`, `parent_window_domain_id: Option<DomainWindowIdentifier>`.
    - **Methoden:** `new_toplevel(...)`, `new_popup(...)`, `wl_surface()`, Methoden des `Window`-Traits (send_configure, set_activated, etc. – rufen Methoden auf `self.xdg_surface` auf).
- **Implementierung `smithay::wayland::shell::xdg::XdgShellHandler` für `DesktopState`**:
    - `xdg_shell_state(&mut self) -> &mut XdgShellState`: `&mut self.xdg_shell_state`
    - `new_toplevel(&mut self, surface: ToplevelSurface)`: Erstellt `ManagedWindow`, fordert initiale Geometrie von `domain::window_management_policy_service` an, sendet initiales `configure`, fügt zu `self.space` und `self.windows` hinzu.
    - `new_popup(&mut self, surface: PopupSurface, positioner: PositionerState)`: Erstellt `ManagedWindow` (als Popup), berechnet Geometrie basierend auf `positioner` und Parent, sendet `configure`, fügt zu `self.windows` hinzu.
    - `map_toplevel(&mut self, surface: &ToplevelSurface)`: Setzt `managed_window.is_mapped = true`, benachrichtigt Domäne (`workspace_manager_service.assign_window_to_active_workspace`), fordert Re-Layout.
    - `unmap_toplevel(&mut self, surface: &ToplevelSurface)`: Setzt `is_mapped = false`, benachrichtigt Domäne, entfernt aus `space`.
    - `ack_configure(&mut self, surface: WlSurface, configure_data: XdgSurfaceConfigureUserData)`: Verarbeitet Client-Bestätigung.
    - **Request-Handler** (`toplevel_request_set_title`, `toplevel_request_set_maximized`, `move_request`, `resize_request`, etc.):
        1. Findet `ManagedWindow` für das `ToplevelSurface`/`PopupSurface`.
        2. Aktualisiert den Zustand im `ManagedWindow` und/oder dessen Smithay `XdgToplevelSurfaceData`/`XdgPopupSurfaceData`.
        3. Interagiert mit `self.domain_services.window_policy_service` für Validierung oder Policy-Anpassungen.
        4. Sendet bei Bedarf neue `configure`-Events an den Client.
        5. Für `move` und `resize`: Startet einen interaktiven Grab über `self.seat.start_pointer_grab(...)` mit einer spezifischen Grab-Handler-Implementierung (siehe `system::window_mechanics`).
    - `toplevel_destroyed(&mut self, toplevel: ToplevelSurface)` / `popup_destroyed(&mut self, popup: PopupSurface)`: Entfernt `ManagedWindow` aus `self.space` und `self.windows`, benachrichtigt Domäne.

#### 1.5. Submodul: `system::compositor::layer_shell`

Datei: `src/compositor/layer_shell/errors.rs`, `types.rs`, `handlers.rs`

- **Enum `LayerShellError`**: `InvalidLayerSurfaceState`, `NamespaceAlreadyTaken`.
- **Struct `ManagedLayerSurface`** (Implementiert `smithay::desktop::LayerSurface`):
    - **Felder:** `id: uuid::Uuid`, `domain_id: crate::domain::workspaces::core::types::WindowIdentifier` (für Panel/Dock-Identifikation), `layer_surface: smithay::wayland::shell::wlr_layer::LayerSurface`, `current_geometry`, `is_mapped`.
- **Implementierung `smithay::wayland::shell::wlr_layer::LayerShellHandler` für `DesktopState`**:
    - `layer_shell_state(&mut self) -> &mut WlrLayerShellState`: `&mut self.layer_shell_state`
    - `new_layer_surface(&mut self, surface: LayerSurface, output: Option<Output>, layer: Layer, namespace: String)`: Erstellt `ManagedLayerSurface`, validiert Namespace, konfiguriert Layer und Anker, sendet initiales `configure`. Fügt zu `smithay::desktop::layer_map_for_output(output).map_layer(&layer_surface)`.
    - `layer_surface_commit(&mut self, surface: &LayerSurface)`: Reagiert auf Puffer-Commits, aktualisiert ggf. Geometrie basierend auf Client-Requests.
    - `layer_surface_destroyed(&mut self, surface: &LayerSurface)`: Entfernt aus Layer Map.

#### 1.6. Weitere `system::compositor` Submodule (Struktur analog)

- **`decoration`**: `XdgDecorationHandler` für `xdg-decoration-unstable-v1`. Verwaltet `XdgDecorationState`.
- **`output_management`**: Implementierung von `smithay::wayland::output::OutputHandler`, `smithay::wayland::output_manager::OutputManagerHandler` (für `wlr-output-management-unstable-v1`) und `smithay::wayland::xdg_output::XdgOutputHandler` (für `xdg-output-unstable-v1`). `DesktopState` hält `OutputManagerState`.
- **`input_method`**: `InputMethodHandler`, `TextInputHandler`. `DesktopState` hält `InputMethodManagerState`, `TextInputManagerState`.
- **`screencopy`**: Implementierung von `wlr-screencopy-unstable-v1` (benötigt Zugriff auf Renderer).
- **`data_device`**: `DataDeviceHandler`, `PrimarySelectionHandler`. `DesktopState` hält `DataDeviceState`, `PrimarySelectionState`.
- **`xwayland`**: `XWayland`, `X11Wm`, `XwmHandler`. Starten und Verwalten des XWayland-Servers.
- **`renderer_interface`**:
    - Trait `RenderableTexture: Send + Sync + std::fmt::Debug { fn id(&self) -> uuid::Uuid; fn bind(&self, slot: u32) -> Result<()>; fn width_px(&self) -> u32; ... }`
    - Trait `FrameRenderer: Send + Sync { fn new(...) -> Result<Self>; fn render_frame(...); fn present_frame(...); fn create_texture_from_shm(...); ... }`
    - Enum `RenderElement { Surface { texture, geometry, damage, ... }, Cursor { ... } }`
- **`drm_gbm_renderer` / `winit_renderer`**: Konkrete Implementierungen von `FrameRenderer`.

### Modul 2: `system::input`

Zweck: Eingabeverarbeitung.

#### 2.1. Submodul: `system::input::errors`

Datei: `src/input/errors.rs`

- **Enum `InputError`**: (Wie in spezifiziert) `SeatCreationFailed`, `CapabilityAdditionFailed`, `XkbConfigError`, `LibinputError`, `LibinputSessionError`, `SeatNotFound`, `KeyboardHandleNotFound`, etc.

#### 2.2. Submodul: `system::input::types` (oder in `keyboard`, `pointer` etc.)

Datei: `src/input/types.rs`

- **Struct `XkbConfig`** (aus `smithay::input::keyboard::KeyboardConfig`)
- **Struct `XkbKeyboardData`**:
    - `context: xkbcommon::xkb::Context`
    - `keymap: xkbcommon::xkb::Keymap`
    - `state: xkbcommon::xkb::State`
    - `repeat_timer: Option<calloop::TimerHandle>`
    - `repeat_info: Option<(u32 /* libinput keycode */, xkbcommon::xkb::Keycode /* xkb keycode */, SmithayModifiersState, std::time::Duration, std::time::Duration)>`
    - `focused_surface_on_seat: Option<wayland_server::Weak<WlSurface>>`
    - `repeat_key_serial: Option<smithay::utils::Serial>`
    - **Methoden:** `new(config: &XkbConfig) -> Result<Self, InputError>`, `update_xkb_state_from_modifiers(...)`.
- **Event `InputDeviceHotplugEvent`** (für `system::event_bridge`):
    - `device_name: String`
    - `device_type: String` (z.B. "keyboard", "pointer", "touch")
    - `event_type: HotplugType (Added | Removed)`

#### 2.3. Submodul: `system::input::seat_manager`

Datei: `src/input/seat_manager.rs`

- **`DesktopState` Implementierung von `smithay::input::SeatHandler`**:
    - `seat_state(&mut self) -> &mut SeatState<Self>`: `&mut self.seat_state`
    - `focus_changed(&mut self, seat: &Seat<Self>, focused_surface: Option<&WlSurface>)`: Aktualisiert internen Fokus-Cache (`self.active_input_surface`), benachrichtigt Domänenschicht (`domain::window_management_policy` oder `workspace_manager`) über Fokuswechsel. _Wichtig:_ `KeyboardHandle::set_focus` löst dies aus; hier nicht erneut `set_focus` rufen.
    - `cursor_image(&mut self, seat: &Seat<Self>, image: CursorImageStatus)`: Aktualisiert `self.current_cursor_status`, benachrichtigt Renderer zur Neudarstellung des Cursors. Bei `Named(name)`: Logik zum Laden von Cursorthemes (ggf. `libwayland-cursor` oder eigene Implementierung).
- **Funktion `pub fn create_seat(state: &mut DesktopState, display_handle: &DisplayHandle, seat_name: String) -> Result<(), InputError>`**:
    1. `seat = state.seat_state.new_wl_seat(display_handle, seat_name.clone(), ...);`
    2. `state.seats.insert(seat_name.clone(), seat.clone());` (Oder `state.seat = seat.clone()` für primären Seat).
    3. Initialisiere `XkbKeyboardData` für diesen Seat in `state.keyboard_data_map`.
    4. Fähigkeiten (Keyboard, Pointer, Touch) werden später hinzugefügt, wenn `LibinputInputBackend` Geräte meldet.

#### 2.4. Submodul: `system::input::libinput_handler`

Datei: `src/input/libinput_handler/mod.rs` (und ggf. `session_interface.rs`)

- **Struct `LibinputSessionInterface`** (implementiert `smithay::backend::input::LibinputInterface`): Kapselt `smithay::backend::session::Session` (z.B. `LogindSession` oder `DirectSession`). Methoden `open_restricted`, `close_restricted`.
- **Funktion `pub fn init_libinput_backend<S: Session + 'static>(session_interface: Rc<RefCell<S>>) -> Result<LibinputInputBackend, InputError>`**: Erstellt `LibinputInputBackend`.
- **Funktion `pub fn register_libinput_event_source(loop_handle: &LoopHandle<DesktopState>, backend: LibinputInputBackend, seat_name_for_callback: String) -> Result<calloop::Source<LibinputInputBackend>, InputError>`**: Fügt Backend zur `calloop`-Schleife hinzu. Callback ruft `process_input_event`.
- **Funktion `pub fn process_input_event(desktop_state: &mut DesktopState, event: InputEvent<LibinputInputBackend>, seat_name: &str)`**:
    1. Holt `Seat<DesktopState>` für `seat_name`.
    2. `match event`:
        - `DeviceAdded { device }`: `tracing::info!(...)`. Prüft `device.capabilities()`. Wenn z.B. `Keyboard` und Seat noch keine Tastatur hat: `seat.add_keyboard(XkbConfig::default(), 200, 25)?`. Analog für Pointer, Touch. Sendet `InputDeviceHotplugEvent`.
        - `DeviceRemoved { device }`: `tracing::info!(...)`. Entfernt Capabilities vom Seat. Sendet `InputDeviceHotplugEvent`.
        - `Keyboard { event }`: Ruft `crate::input::keyboard::key_event_translator::handle_keyboard_event(...)`.
        - `PointerMotion { event }`: Ruft `crate::input::pointer::pointer_event_translator::handle_pointer_motion_event(...)`.
        - (Analog für `PointerMotionAbsolute`, `PointerButton`, `PointerAxis`, `TouchDown`, `TouchUp`, `TouchMotion`, `TouchFrame`, `TouchCancel`, `Gesture*`).

#### 2.5. Submodule: `system::input::keyboard`, `system::input::pointer`, `system::input::touch`, `system::input::gestures`

- **`keyboard::key_event_translator::handle_keyboard_event(...)`**:
    1. Holt `KeyboardHandle<DesktopState>` und `XkbKeyboardData`.
    2. Konvertiert `libinput keycode` zu `xkbcommon keycode` (`+8`).
    3. `xkb_data.state.update_key(...)`.
    4. Holt `SmithayModifiersState` von `xkb_data.state`.
    5. `keyboard_handle.modifiers(serial, mods_state, ...)`
    6. Wenn `KeyState::Pressed`: `keyboard_handle.key(serial, time, xkb_keycode, KeyState::Pressed, ...)`. Tastenwiederholung einrichten/aktualisieren (via `calloop::TimerHandle` in `XkbKeyboardData`, Callback sendet erneut `key` Event mit neuem Serial).
    7. Wenn `KeyState::Released`: `keyboard_handle.key(...)`. Tastenwiederholung abbrechen.
- **`keyboard::focus::set_keyboard_focus(...)`**:
    1. Holt `KeyboardHandle<DesktopState>` und `XkbKeyboardData`.
    2. `keyboard_handle.set_focus(target_surface_option, serial, ...)` (Smithay sendet `enter`/`leave`).
    3. Aktualisiert `xkb_data.focused_surface_on_seat`.
    4. Benachrichtigt Domäne (via `desktop_state.domain_services...` oder `SystemEventBridge`).
- **`pointer::pointer_event_translator::handle_pointer_motion_event(...)`**:
    1. Holt `PointerHandle<DesktopState>`.
    2. Aktualisiert `desktop_state.pointer_location` basierend auf `event.delta()`.
    3. `let (new_focus_surface, surface_local_coords) = find_surface_and_coords_at_global_point(desktop_state, desktop_state.pointer_location)`.
    4. `pointer_handle.motion(time, new_focus_surface.as_ref(), serial, desktop_state.pointer_location, surface_local_coords, ...)` (Smithay sendet `enter`/`leave`/`motion`).
    5. Aktualisiert `desktop_state.active_input_surface`.
- **`find_surface_and_coords_at_global_point(...)`**: Iteriert `desktop_state.space.elements_under(global_pos)`, prüft `input_region` von `SurfaceData`.
- (Analog für andere Zeiger- und Touch-Events, die entsprechende `PointerHandle`- und `TouchHandle`-Methoden aufrufen).

---

(Die Spezifikationen für die Module `system::dbus_interfaces`, `system::audio_management`, `system::mcp_client`, `system::window_mechanics`, `system::power_management` und `system::event_bridge` würden mit derselben Detailtiefe folgen, basierend auf den vorherigen Antworten und den Quelldokumenten.)

**Dieser ultra-feingranulare Implementierungsleitfaden für die Systemschicht, beginnend mit dem Compositor und der Eingabeverarbeitung, legt eine präzise Basis für die Entwicklung. Die konsequente Anwendung der definierten Strukturen, Methoden, Fehler und Events durch einen KI-Agenten soll zu einer robusten und korrekten Implementierung führen.**

Ultra-Feinspezifikation und Implementierungsleitfaden der internen Schnittstellen der Linux Desktop-Umgebung "NovaDE"EinleitungDieses Dokument dient als erweiterte technische Spezifikation und detaillierter Implementierungsleitfaden für die internen Schnittstellen zwischen den vier Hauptarchitekturschichten der Linux Desktop-Umgebung "NovaDE": Kernschicht (Core Layer), Domänenschicht (Domain Layer), Systemschicht (System Layer) und Benutzeroberflächenschicht (UI Layer). Die Kommunikation zwischen diesen Schichten erfolgt primär über wohldefinierte öffentliche APIs, die häufig als Rust-Traits implementiert sind, sowie über ein robustes Event-System zur Signalisierung von Zustandsänderungen. Ziel dieses Dokuments ist es, eine lückenlose Ultra-Feinspezifikation bereitzustellen, die Entwicklern eine direkte Implementierung ohne eigene Entwurfsentscheidungen ermöglicht. Alle relevanten Aspekte wurden recherchiert, entschieden und präzise spezifiziert, um Klarheit und Konsistenz über das gesamte System hinweg zu gewährleisten.Die hier dargelegten Spezifikationen sind entscheidend, um die kohärente Zusammenarbeit der verschiedenen Schichten sicherzustellen und die übergeordneten Projektziele – Performance, Intuition, Modernität, Modularität, Anpassbarkeit, sichere KI-Integration und Stabilität – zu erreichen.1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten (Domäne, System, UI)Die Kernschicht stellt fundamentale Bausteine und Dienste bereit, die von allen darüberliegenden Schichten genutzt werden. Diese Dienste sind so konzipiert, dass sie maximale Wiederverwendbarkeit und minimale Abhängigkeiten für die höheren Schichten gewährleisten.1.1. Bereitgestellte Funktionalität1.1.1. core::typesDefiniert grundlegende, universell einsetzbare Datentypen.
Schnittstelle: Direkte Verwendung von Typen wie Point<T>, Size<T>, Rect<T>, RectInt, Color, Orientation sowie uuid::Uuid und chrono::DateTime<Utc> durch die höheren Schichten.
Beispielhafte Nutzung: Die Domänenschicht verwendet Color für Theming-Definitionen, die Systemschicht RectInt für Fenstergeometrien, und die UI-Schicht Point<T> für die Positionierung von Elementen.
1.1.2. core::errorsStellt eine Basis-Fehlerbehandlungsstrategie und den CoreError-Typ bereit.
Schnittstelle: Höhere Schichten können CoreError oder spezifischere Fehler aus Kernmodulen mittels #[from] oder #[source] in ihre eigenen Fehlertypen wrappen. Die Fehlerursachenkette (source()) wird dabei beibehalten.1
Beispielhafte Nutzung: Ein ConfigError in domain::workspaces::config kann einen CoreError::Io wrappen, der beim Lesen einer Datei in core::config aufgetreten ist.
1.1.3. core::loggingDefiniert die Logging-Infrastruktur basierend auf tracing.
Schnittstelle: Alle höheren Schichten verwenden die tracing-Makros (trace!, info!, etc.) für ihre Logging-Ausgaben. Die Funktion core::logging::initialize_logging() wird typischerweise einmalig von der Anwendung (z.B. UI-Schicht) beim Start aufgerufen.
1.1.4. core::configStellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit.
Schnittstelle: Funktionen wie load_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError> und get_core_config() -> &'static CoreConfig für den globalen Zugriff. Die CoreConfig-Struktur selbst ist Teil der Schnittstelle.
Beispielhafte Nutzung: domain::settings_persistence_iface (oder eine konkrete Implementierung wie FilesystemConfigProvider) nutzt diese API, um Basiskonfigurationen zu lesen, die dann von der Domänenschicht weiterverarbeitet werden.
1.1.5. core::utilsBietet allgemeine Hilfsfunktionen.
Schnittstelle: Direkte Nutzung der öffentlichen Funktionen durch alle höheren Schichten.
1.2. Ultra-Feinspezifikation: Modul core::config::loaderDieses interne Modul ist für das Laden und Parsen von Konfigurationsdateien für das öffentliche core::config API zuständig.1.2.1. Modulübersicht
Zweck: Implementiert die Logik zum Auffinden, Lesen und Deserialisieren der Kernkonfigurationsdatei (core.json oder ein anderes gewähltes Format).
Interne Abhängigkeiten: core::types (für PathBuf), core::errors::CoreError, super::types::CoreConfig (die öffentliche Konfigurationsstruktur), super::errors::ConfigError.
Externe Abhängigkeiten: serde, serde_json (oder toml, etc.), std::fs, std::path, std::io.
1.2.2. Interne Datenstrukturen
struct RawCoreConfig

Datei: nova_de/core/src/config/raw_types.rs
Zweck: Dient der direkten Deserialisierung der Konfigurationsdatei. Dies ermöglicht Flexibilität bei der Versionierung und Validierung der Konfiguration, bevor sie in die öffentliche CoreConfig-Struktur überführt wird. Felder sind typischerweise Option<T>, um fehlende Werte abzufangen und Defaults anzuwenden.
Attribute: Spiegeln die Felder von CoreConfig, jedoch als Option<String>, Option<bool>, etc. Beispiel:
Rust// nova_de/core/src/config/raw_types.rs
use serde::Deserialize;

#
pub(super) struct RawCoreConfig {
    pub(super) log_level: Option<String>,
    pub(super) default_theme_name: Option<String>,
    pub(super) enable_experimental_features: Option<bool>,
    // Weitere Felder entsprechend CoreConfig
}


Sichtbarkeit: pub(super) innerhalb des core::config Moduls.


1.2.3. Fehlerbehandlung: ConfigError
Datei: nova_de/core/src/config/errors.rs (oder in core::errors integriert)
Definition:
Rust// nova_de/core/src/config/errors.rs
use std::io;
use std::path::PathBuf;
use thiserror::Error;

#
pub enum ConfigError {
    #
    NotFound { searched_paths: Vec<PathBuf> },

    #[error("I/O error accessing config file at {path:?}")]
    Io {
        path: PathBuf,
        #[source]
        source: io::Error,
    },

    #[error("Failed to parse config file at {path:?}")]
    ParseError {
        path: PathBuf,
        #[source]
        source: serde_json::Error, // Oder anderer Deserialisierungsfehler
        content_snippet: String, // Ein kurzer Ausschnitt des fehlerhaften Inhalts
    },

    #[error("Invalid configuration value for key '{key}': {message}")]
    InvalidValue { key: String, message: String },

    #[error("Could not determine home directory")]
    HomeDirectoryNotFound,
}

Die Verwendung von thiserror ermöglicht eine klare Fehlerdefinition und -verkettung.1
1.2.4. Interne Funktionen

fn resolve_config_path(custom_path: Option<&PathBuf>) -> Result<PathBuf, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Bestimmt den zu ladenden Konfigurationspfad gemäß der XDG Base Directory Specification und optionalen benutzerdefinierten Pfaden.
Parameter:

custom_path: Option<&PathBuf> (const): Ein optional vom Benutzer bereitgestellter Pfad.


Rückgabe: Result<PathBuf, ConfigError> - Der aufgelöste Pfad oder ein ConfigError::NotFound.
Implementierungsschritte:

Wenn custom_path Some(path) ist:

Prüfen, ob path existiert. Wenn ja, Ok(path.clone()) zurückgeben.
Wenn nicht, Err(ConfigError::NotFound { searched_paths: vec![path.clone()] }) zurückgeben (oder spezifischerer Fehler).


Andernfalls XDG-Pfade prüfen:

xdg_config_home = std::env::var("XDG_CONFIG_HOME").map(PathBuf::from).or_else(|_| dirs::home_dir().map(|h| h.join(".config"))).ok_or(ConfigError::HomeDirectoryNotFound)?;
user_path = xdg_config_home.join("novade/core.json");
Wenn user_path existiert, Ok(user_path) zurückgeben.


Systemweite XDG-Pfade prüfen:

xdg_config_dirs = std::env::var("XDG_CONFIG_DIRS").map(|dirs| dirs.split(':').map(PathBuf::from).collect::<Vec<_>>()).unwrap_or_else(|_| vec!);
Für jeden dir in xdg_config_dirs:

system_path = dir.join("novade/core.json");
Wenn system_path existiert, Ok(system_path) zurückgeben.




Fallback-Systempfad prüfen:

fallback_path = PathBuf::from("/etc/novade/core.json");
Wenn fallback_path existiert, Ok(fallback_path) zurückgeben.


Wenn keine Datei gefunden wurde, Err(ConfigError::NotFound { searched_paths:... }) mit allen geprüften Pfaden zurückgeben.


Vorbedingungen: Keine.
Nachbedingungen: Gibt einen validen, existierenden Pfad zurück oder einen Fehler.



fn read_config_file(path: &Path) -> Result<String, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Liest den Inhalt der Konfigurationsdatei.
Parameter:

path: &Path (const): Pfad zur Konfigurationsdatei.


Rückgabe: Result<String, ConfigError> - Dateiinhalt als String oder ein ConfigError::Io.
Implementierungsschritte:

std::fs::read_to_string(path).map_err(|e| ConfigError::Io { path: path.to_path_buf(), source: e })


Vorbedingungen: path ist ein valider Pfad.
Nachbedingungen: Gibt den Dateiinhalt zurück oder einen I/O-Fehler.



fn parse_raw_config(content: &str, path: &Path) -> Result<RawCoreConfig, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Parst den String-Inhalt in die RawCoreConfig-Struktur.
Parameter:

content: &str (const): Der zu parsende String-Inhalt.
path: &Path (const): Der Pfad der Konfigurationsdatei (für Fehlerberichte).


Rückgabe: Result<RawCoreConfig, ConfigError> - Die geparste Rohkonfiguration oder ein ConfigError::ParseError.
Implementierungsschritte:

serde_json::from_str(content).map_err(|e| ConfigError::ParseError { path: path.to_path_buf(), source: e, content_snippet: content.chars().take(100).collect() })


Vorbedingungen: content ist ein valider String.
Nachbedingungen: Gibt die geparste Rohkonfiguration zurück oder einen Parse-Fehler.



fn convert_raw_to_core_config(raw_config: RawCoreConfig, config_path: &Path) -> Result<CoreConfig, ConfigError>

Datei: nova_de/core/src/config/loader.rs
Zweck: Konvertiert RawCoreConfig in CoreConfig, wendet Standardwerte an und validiert Werte.
Parameter:

raw_config: RawCoreConfig: Die geparste Rohkonfiguration.
config_path: &Path: Pfad zur Konfigurationsdatei für Fehlerberichte und Kontext.


Rückgabe: Result<CoreConfig, ConfigError> - Die validierte CoreConfig oder ein ConfigError::InvalidValue.
Implementierungsschrite:

Erstelle eine CoreConfig-Instanz.
Für jedes Feld in RawCoreConfig:

Wenn Some(value), validiere value. Bei Ungültigkeit, Err(ConfigError::InvalidValue { key: "...", message: "..." }) zurückgeben.
Wenn None, verwende einen hartcodierten Standardwert für CoreConfig.
Beispiel: log_level = raw_config.log_level.unwrap_or_else(|| "info".to_string());
Validierung für log_level: Muss einer der unterstützten Werte sein (z.B. "trace", "debug", "info", "warn", "error").


Ok(core_config) zurückgeben.


Vorbedingungen: raw_config ist vorhanden.
Nachbedingungen: Gibt eine valide CoreConfig zurück oder einen Fehler bei ungültigen Werten.


1.2.5. Öffentliche Funktion (innerhalb core::config)
pub(super) fn load_and_parse_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError>

Datei: nova_de/core/src/config/mod.rs (ruft Funktionen aus loader.rs auf)
Zweck: Orchestriert den gesamten Lade- und Parse-Vorgang. Dies ist die Hauptfunktion, die von der öffentlichen API load_core_config genutzt wird.
Parameter:

custom_path: Option<PathBuf>: Optionaler benutzerdefinierter Pfad.


Rückgabe: Result<CoreConfig, ConfigError>.
Implementierungsschritte:

let resolved_path = loader::resolve_config_path(custom_path.as_ref())?;
let content = loader::read_config_file(&resolved_path)?;
let raw_config = loader::parse_raw_config(&content, &resolved_path)?;
loader::convert_raw_to_core_config(raw_config, &resolved_path)


Vorbedingungen: Keine.
Nachbedingungen: Gibt eine geladene und validierte CoreConfig zurück oder einen entsprechenden ConfigError.


Die Trennung von RawCoreConfig und CoreConfig ist eine bewährte Methode, um die API stabil zu halten, während interne Repräsentationen oder Konfigurationsdateiformate versioniert oder migriert werden können. Dies erhöht die Robustheit und Wartbarkeit des Konfigurationssystems.1.3. Ultra-Feinspezifikation: Modul core::types_moduleDieses Modul ist das Fundament für viele Datenaustauschoperationen innerhalb von NovaDE.1.3.1. Modulübersicht
Zweck: Definition und Implementierung fundamentaler, wiederverwendbarer Datentypen wie geometrische Primitiven (Point, Size, Rect), Color und Orientation. Stellt auch uuid::Uuid und chrono::DateTime<Utc> für das gesamte System bereit.
Dateistruktur:

nova_de/core/src/types/mod.rs: Hauptmoduldatei, exportiert alle Typen.
nova_de/core/src/types/point.rs: Definition von Point<T>.
nova_de/core/src/types/size.rs: Definition von Size<T>.
nova_de/core/src/types/rect.rs: Definition von Rect<T> und RectInt.
nova_de/core/src/types/color.rs: Definition von Color und ColorParseError.
nova_de/core/src/types/orientation.rs: Definition von Orientation.


Abhängigkeiten: uuid (mit Features "serde", "v4"), chrono (mit Feature "serde").5
1.3.2. Datentyp-SpezifikationenPoint<T>
Datei: nova_de/core/src/types/point.rs
Definition:
Rust#
#
pub struct Point<T> {
    pub x: T,
    pub y: T,
}


Attribute:

x: T - Sichtbarkeit: pub. X-Koordinate.
y: T - Sichtbarkeit: pub. Y-Koordinate.


Methoden:

pub const fn new(x: T, y: T) -> Self: Erzeugt einen neuen Punkt.
pub fn map<U, F>(&self, f: F) -> Point<U> where F: Fn(T) -> U, T: Copy: Mappt die Koordinaten zu einem neuen Typ.
Für T: std::ops::Add<Output = T> + Copy:

pub fn offset(&self, dx: T, dy: T) -> Self: Verschiebt den Punkt um (dx, dy).


Für T: std::ops::Sub<Output = T> + Copy:

pub fn vector_to(&self, other: &Point<T>) -> Point<T>: Erzeugt einen Vektor (als Punkt) von self zu other.




Invarianten: Keine über die Typ-Constraints von T hinaus.
Size<T>
Datei: nova_de/core/src/types/size.rs
Definition:
Rust#
#
pub struct Size<T> {
    pub w: T, // width
    pub h: T, // height
}


Attribute:

w: T - Sichtbarkeit: pub. Breite.
h: T - Sichtbarkeit: pub. Höhe.


Methoden:

pub const fn new(w: T, h: T) -> Self: Erzeugt eine neue Größe.
pub fn map<U, F>(&self, f: F) -> Size<U> where F: Fn(T) -> U, T: Copy: Mappt Breite und Höhe zu einem neuen Typ.
Für T: std::ops::Mul<Output = T> + Copy:

pub fn area(&self) -> T: Berechnet die Fläche.


Für T: PartialOrd + Default:

pub fn is_empty(&self) -> bool where T: Default + PartialEq: Prüft, ob Breite oder Höhe null sind (abhängig von T::default()).




Invarianten: Wenn T ein numerischer Typ ist, sollten w und h typischerweise nicht-negativ sein. Dies wird jedoch nicht aktiv erzwungen, außer durch Nutzungskonventionen oder spezifische Konstruktoren in höheren Schichten.
Rect<T>
Datei: nova_de/core/src/types/rect.rs
Definition:
Rustuse super::{Point, Size}; // Import Point und Size aus dem gleichen Modul

#
#
pub struct Rect<T> {
    pub origin: Point<T>,
    pub size: Size<T>,
}

pub type RectInt = Rect<i32>;


Attribute:

origin: Point<T> - Sichtbarkeit: pub. Ursprungspunkt (typischerweise linke obere Ecke).
size: Size<T> - Sichtbarkeit: pub. Ausmaße des Rechtecks.


Methoden (Beispiele für T: Copy + PartialOrd + std::ops::Add<Output = T> + std::ops::Sub<Output = T>):

pub const fn new(x: T, y: T, w: T, h: T) -> Self: Erzeugt ein neues Rechteck.
pub fn from_points(p1: Point<T>, p2: Point<T>) -> Self: Erzeugt ein Rechteck aus zwei gegenüberliegenden Punkten (normalisiert).
pub fn x(&self) -> T: Gibt self.origin.x zurück.
pub fn y(&self) -> T: Gibt self.origin.y zurück.
pub fn width(&self) -> T: Gibt self.size.w zurück.
pub fn height(&self) -> T: Gibt self.size.h zurück.
pub fn right(&self) -> T: Gibt self.origin.x + self.size.w zurück.
pub fn bottom(&self) -> T: Gibt self.origin.y + self.size.h zurück.
pub fn contains_point(&self, point: &Point<T>) -> bool: Prüft, ob ein Punkt innerhalb des Rechtecks liegt.
pub fn intersects(&self, other: &Rect<T>) -> bool: Prüft, ob sich dieses Rechteck mit einem anderen überschneidet.
pub fn intersection(&self, other: &Rect<T>) -> Option<Rect<T>>: Berechnet die Schnittmenge mit einem anderen Rechteck.
pub fn union(&self, other: &Rect<T>) -> Rect<T>: Berechnet die Vereinigungsmenge mit einem anderen Rechteck.
pub fn translated(&self, dx: T, dy: T) -> Self: Erzeugt ein verschobenes Rechteck.
pub fn inflated(&self, dw: T, dh: T) -> Self: Erzeugt ein Rechteck, dessen Größe um dw und dh geändert wurde (Zentrum bleibt gleich).


Invarianten: Analog zu Size<T>, sollten size.w und size.h typischerweise nicht-negativ sein.
Color
Datei: nova_de/core/src/types/color.rs
Definition:
Rustuse thiserror::Error;

#
#
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

#
pub enum ColorParseError {
    #
    InvalidFormat(String),
    #[error("Invalid hex digit in string '{input}' at component '{component}'.")]
    InvalidHexDigit { input: String, component: String },
    #[error("Hex string '{0}' has incorrect length.")]
    InvalidLength(String),
}

impl Color {
    pub const fn new(r: u8, g: u8, b: u8, a: u8) -> Self {
        Color { r, g, b, a }
    }

    pub fn from_hex(hex_string: &str) -> Result<Self, ColorParseError> {
        let s = hex_string.trim_start_matches('#');
        if!(s.len() == 6 |


| s.len() == 8) {return Err(ColorParseError::InvalidLength(hex_string.to_string()));}if!s.chars().all(|c| c.is_ascii_hexdigit()) {return Err(ColorParseError::InvalidFormat(hex_string.to_string()));}        let r = u8::from_str_radix(&s[0..2], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "R".to_string()})?;
        let g = u8::from_str_radix(&s[2..4], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "G".to_string()})?;
        let b = u8::from_str_radix(&s[4..6], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "B".to_string()})?;
        let a = if s.len() == 8 {
            u8::from_str_radix(&s[6..8], 16).map_err(|_| ColorParseError::InvalidHexDigit{ input: hex_string.to_string(), component: "A".to_string()})?
        } else {
            255 // Default alpha to fully opaque
        };
        Ok(Color { r, g, b, a })
    }

    pub fn to_hex(&self, include_alpha: bool) -> String {
        if include_alpha {
            format!("#{:02X}{:02X}{:02X}{:02X}", self.r, self.g, self.b, self.a)
        } else {
            format!("#{:02X}{:02X}{:02X}", self.r, self.g, self.b)
        }
    }
}
```

Attribute: r, g, b, a: u8 - Sichtbarkeit: pub. Rot-, Grün-, Blau- und Alpha-Komponenten.
Methoden: Siehe Definition.
Invarianten: Keine.
Orientation
Datei: nova_de/core/src/types/orientation.rs
Definition:
Rust#
#
pub enum Orientation {
    Horizontal,
    Vertical,
}


Varianten: Horizontal, Vertical.
Re-exportierte Typen
Datei: nova_de/core/src/types/mod.rs
Rust//... imports für Point, Size, Rect, Color, Orientation...
pub use uuid::Uuid;
pub use chrono::{DateTime, Utc};

pub type NotificationId = Uuid;
// Weitere Typ-Aliase können hier definiert werden.

Die Verwendung von uuid::Uuid für NotificationId 5 und chrono::DateTime<Utc> für Zeitstempel 6 ist eine robuste Wahl, die Standardbibliotheken für diese Zwecke nutzt. Die Aktivierung der "serde" und "v4" Features für uuid ist wichtig für die Serialisierung und die Generierung von Typ-4-UUIDs.
Diese grundlegenden Typen bilden eine solide Basis für geometrische Berechnungen, Farbdarstellungen und eindeutige Identifikatoren im gesamten NovaDE-System. Ihre konsequente Verwendung über alle Schichten hinweg fördert die Interoperabilität und reduziert Konvertierungsaufwand.2. Schnittstelle: Domänenschicht (Domain Layer) zu Systemschicht und BenutzeroberflächenschichtDie Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung. Sie stellt ihre Funktionalität über klar definierte Service-APIs (oft als Rust-Traits), Datenstrukturen und Events bereit.2.1. Bereitgestellte Funktionalität
Service-APIs (Traits): Öffentliche Schnittstellen werden primär durch Rust-Traits definiert, die von Service-Strukturen innerhalb der Domänenmodule implementiert werden.

domain::theming::ThemingEngine: Methoden wie get_current_theme_state(), update_configuration().
domain::workspaces::WorkspaceManager: Methoden wie create_workspace(), set_active_workspace().
domain::user_centric_services::AIInteractionLogicService: Methoden wie initiate_interaction(), provide_consent().
domain::user_centric_services::NotificationService: Methoden wie post_notification(), get_active_notifications().
domain::global_settings_and_state_management::GlobalSettingsService: Methoden wie load_settings(), update_setting().


Datenstrukturen: Öffentliche Datenstrukturen, die Zustände oder Konfigurationen repräsentieren (z.B. AppliedThemeState, Workspace, Notification, GlobalDesktopSettings).
Events: Domänenspezifische Events, die Zustandsänderungen signalisieren.

Beispiele: ThemeChangedEvent, WorkspaceEvent (z.B. ActiveWorkspaceChanged), NotificationPostedEvent, SettingChangedEvent.


Fehlertypen: Modulspezifische Fehler-Enums (z.B. ThemingError, WorkspaceManagerError, AIInteractionError, GlobalSettingsError).
2.2. Nutzung durch die Systemschicht
Die Systemschicht konsumiert die Service-APIs der Domänenschicht, um Geschäftsregeln anzuwenden und Zustände abzufragen.

Der system::compositor nutzt domain::window_management_policy für Fensterplatzierungsrichtlinien.
Der system::mcp Client interagiert mit AIInteractionLogicService für Einwilligungsprüfungen und Kontextinformationen.
system::dbus (für Benachrichtigungen) interagiert mit NotificationService.


Die Systemschicht kann auf Domänen-Events reagieren, um ihr Verhalten anzupassen (z.B. Umschalten der sichtbaren Surfaces im Compositor bei ActiveWorkspaceChanged).
Fehler aus der Domänenschicht werden in der Systemschicht behandelt oder weitergeleitet.
2.3. Nutzung durch die Benutzeroberflächenschicht
Die UI-Schicht nutzt die Service-APIs der Domänenschicht, um Daten für die Darstellung abzurufen und Benutzeraktionen in Domänenlogik umzusetzen.

ui::control_center verwendet GlobalSettingsService zum Anzeigen und Ändern von Einstellungen.
ui::shell interagiert mit WorkspaceManager für die Workspace-Darstellung und -Navigation.
ui::theming_gtk reagiert auf ThemeChangedEvent und wendet Stile an.


Die UI-Schicht abonniert Domänen-Events, um ihre Ansichten dynamisch zu aktualisieren.
Fehler aus der Domänenschicht werden von der UI-Schicht behandelt und dem Benutzer ggf. in verständlicher Form präsentiert.
2.4. Ultra-Feinspezifikation: Modul domain::user_centric_services::notification_service_implDieses Modul enthält die konkrete Implementierung des NotificationService-Traits.2.4.1. Modulübersicht
Zweck: Verwaltung des Lebenszyklus von Benachrichtigungen, einschließlich Erstellung, Speicherung, Abruf aktiver Benachrichtigungen, Schließen und Auslösen von Aktionen. Veröffentlicht Domänenereignisse im Zusammenhang mit Benachrichtigungen.
Dateistruktur:

nova_de/domain/src/user_centric_services/notification_api.rs: Definiert das Trait NotificationService und zugehörige öffentliche Typen wie Notification, NotificationAction, NotificationUrgency, NotificationId, CloseReason und NotificationError.
nova_de/domain/src/user_centric_services/notification_service_impl.rs: Enthält die Struktur NotificationServiceImpl und deren Implementierung des NotificationService-Traits.
nova_de/domain/src/events.rs: Definiert das DomainEvent-Enum, das NotificationPosted und NotificationClosed enthält.


Abhängigkeiten:

Extern: uuid (für NotificationId), chrono (für Zeitstempel).
Intern: crate::core::types::{NotificationId,...} (falls dort definiert, sonst lokal), crate::core::errors::DomainError (oder spezifischer NotificationError), crate::event_bus::{EventPublisher, DomainEvent} (abstrahiert den Event-Bus).


2.4.2. Öffentliche Datentypen (definiert in notification_api.rs)

pub type NotificationId = uuid::Uuid; 5

Verwendet Uuid::new_v4() zur Generierung.



##pub struct NotificationAction {pub key: String,pub label: String,}

key: Eindeutiger Bezeichner für die Aktion innerhalb der Benachrichtigung.
label: Für den Benutzer sichtbarer Text der Aktion.



##pub enum NotificationUrgency { Low, Normal, Critical }


##pub struct Notification {pub id: NotificationId,pub app_name: String,pub app_icon: Option<String>,pub summary: String,pub body: Option<String>,pub actions: Vec<NotificationAction>,pub hints: std::collections::HashMap<String, serde_json::Value>, // Flexibel für diverse Hintspub expire_timeout: i32, // Millisekunden. -1: Server-Default, 0: Niepub urgency: NotificationUrgency,pub created_at: chrono::DateTime<chrono::Utc>,}

Attribute wie in der Freedesktop Notification Specification definiert.9
hints: Verwendet serde_json::Value für Flexibilität bei D-Bus-Varianten.



##pub enum CloseReason { Expired, DismissedByUser, ClosedByApp, Replaced }


#pub enum NotificationError {#NotFound(NotificationId),#[error("Invalid parameter for notification: {field}: {message}")]InvalidParameter { field: String, message: String },#ActionNotFound { notification_id: NotificationId, action_key: String },#[error("Internal storage error for notifications")]StorageError(#[source] Box<dyn std::error::Error + Send + Sync + 'static>),}

2.4.3. Interne Datenstrukturen (notification_service_impl.rs)

struct NotificationInternal {public_data: Notification,// Ggf. Felder für Timer-Handles für expire_timeout// Ggf. Persistenz-Status}


pub struct NotificationServiceImpl {active_notifications: std::sync::Mutex<std::collections::HashMap<NotificationId, NotificationInternal>>,event_publisher: std::sync::Arc<dyn crate::event_bus::EventPublisher<crate::events::DomainEvent> + Send + Sync>,// Ggf. ein Tokio Runtime Handle für Timer, falls expire_timeout serverseitig gehandhabt wird}

2.4.4. Implementierung des NotificationService-Traits (notification_service_impl.rs)Rustuse async_trait::async_trait;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use uuid::Uuid;
use chrono::Utc;
use crate::event_bus::{EventPublisher, DomainEvent}; // Annahme: DomainEvent ist hier definiert
use super::notification_api::*; // Importiert Traits und öffentliche Typen

impl NotificationServiceImpl {
    pub fn new(event_publisher: Arc<dyn EventPublisher<DomainEvent> + Send + Sync>) -> Self {
        NotificationServiceImpl {
            active_notifications: Mutex::new(HashMap::new()),
            event_publisher,
        }
    }

    // Interne Hilfsfunktion zum Schließen und Benachrichtigen
    fn internal_close_notification(
        &self,
        id: NotificationId,
        reason: CloseReason,
        notifications_guard: &mut std::sync::MutexGuard<HashMap<NotificationId, NotificationInternal>>,
    ) -> Result<Notification, NotificationError> {
        if let Some(removed_notification_internal) = notifications_guard.remove(&id) {
            let event = DomainEvent::NotificationClosed {
                id,
                reason,
                app_name: removed_notification_internal.public_data.app_name.clone(), // Für Kontext im Event
            };
            if self.event_publisher.publish(&event).is_err() {
                // Fehler beim Publishen loggen, aber nicht unbedingt den Vorgang abbrechen
                tracing::error!("Failed to publish NotificationClosed event for ID: {}", id);
            }
            Ok(removed_notification_internal.public_data)
        } else {
            Err(NotificationError::NotFound(id))
        }
    }
}

#[async_trait]
impl NotificationService for NotificationServiceImpl {
    async fn post_notification(
        &self, // &self statt &mut self, da Mutex interne Mutabilität ermöglicht
        app_name: String,
        replaces_id: Option<NotificationId>, // Verwende direkt NotificationId
        app_icon: Option<String>,
        summary: String,
        body: Option<String>,
        actions: Vec<NotificationAction>,
        hints: HashMap<String, serde_json::Value>,
        expire_timeout: i32,
        urgency: NotificationUrgency,
    ) -> Result<NotificationId, NotificationError> {
        let mut notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;

        let new_id = if let Some(id_to_replace) = replaces_id {
            // Versuche, die alte Benachrichtigung zu entfernen und zu benachrichtigen
            let _ = self.internal_close_notification(id_to_replace, CloseReason::Replaced, &mut notifications_guard);
            id_to_replace // Verwende die ID der ersetzten Benachrichtigung
        } else {
            Uuid::new_v4() // Generiere eine neue ID [5]
        };

        let notification_data = Notification {
            id: new_id,
            app_name,
            app_icon,
            summary,
            body,
            actions,
            hints,
            expire_timeout,
            urgency,
            created_at: Utc::now(),
        };

        let internal_notification = NotificationInternal {
            public_data: notification_data.clone(),
        };

        notifications_guard.insert(new_id, internal_notification);
        
        // TODO: Wenn expire_timeout > 0, hier Timer-Logik implementieren,
        // die self.close_notification(new_id, CloseReason::Expired) aufruft.
        // Dies erfordert typischerweise einen Tokio-Task oder ähnliches.

        let event = DomainEvent::NotificationPosted(notification_data);
        if self.event_publisher.publish(&event).is_err() {
            tracing::error!("Failed to publish NotificationPosted event for ID: {}", new_id);
            // Hier könnte man entscheiden, ob der Fehler an den Aufrufer weitergegeben wird.
            // Fürs Erste wird der Fehler nur geloggt.
        }

        Ok(new_id)
    }

    async fn get_active_notifications(&self) -> Result<Vec<Notification>, NotificationError> {
        let notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;
        Ok(notifications_guard.values().map(|internal| internal.public_data.clone()).collect())
    }

    async fn close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError> {
        let mut notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;
        
        self.internal_close_notification(id, reason, &mut notifications_guard)?;
        Ok(())
    }

    async fn invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError> {
        let notifications_guard = self.active_notifications.lock().map_err(|_| {
            NotificationError::StorageError(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Mutex poisoned",
            )))
        })?;

        match notifications_guard.get(&id) {
            Some(notification_internal) => {
                if notification_internal.public_data.actions.iter().any(|act| act.key == action_key) {
                    // Aktion existiert
                    let event = DomainEvent::NotificationActionInvoked {
                        id,
                        action_key: action_key.clone(),
                        app_name: notification_internal.public_data.app_name.clone(),
                    };
                    if self.event_publisher.publish(&event).is_err() {
                         tracing::error!("Failed to publish NotificationActionInvoked event for ID: {}", id);
                    }
                    // Die D-Bus Spezifikation sagt nicht explizit, dass eine Benachrichtigung nach ActionInvoked geschlossen werden muss.
                    // Das überlassen wir der UI-Schicht oder spezifischen Hints.
                    Ok(())
                } else {
                    Err(NotificationError::ActionNotFound { notification_id: id, action_key })
                }
            }
            None => Err(NotificationError::NotFound(id)),
        }
    }
}
2.4.5. Domänenereignisse (events.rs)
#
pub enum DomainEvent {
NotificationPosted(Notification),
NotificationClosed { id: NotificationId, reason: CloseReason, app_name: String },
NotificationActionInvoked { id: NotificationId, action_key: String, app_name: String },
//... andere Domänenereignisse
}
Publisher: NotificationServiceImpl.
Typische Subscriber:

system::dbus::notification_dbus_service: Um D-Bus Signale zu emittieren.
ui::notifications_frontend: Um die Benutzeroberfläche zu aktualisieren.


Die Implementierung des NotificationService stellt sicher, dass die Kernlogik der Benachrichtigungsverwaltung von externen Schnittstellendetails (wie D-Bus) entkoppelt ist. Die Verwendung eines internen Event-Bus ermöglicht es anderen Systemteilen, reaktiv auf Benachrichtigungsänderungen zu reagieren.3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um.3.1. Bereitgestellte Funktionalität
Systemereignisse und -zustände:

Fensterinformationen: Geometrie, Titel, AppID, Fokusstatus von Fenstern (aus system::compositor und system::xdg_shell).
Eingabeereignisse: Verarbeitete Tastatur-, Maus-, Touch- und Gestenereignisse (aus system::input).
Output-Informationen: Verfügbare Monitore, Auflösungen, Skalierungsfaktoren (aus system::outputs).
Status von Systemdiensten: Netzwerkverbindungen (system::dbus::networkmanager_client), Energiestatus (system::dbus::upower_client), Audiostatus (system::audio).
Sitzungsereignisse: Sperren, Abmelden (von system::dbus::logind_client).


Ausführung von UI-Befehlen:

Fenstermanipulationen (Verschieben, Größe ändern, Fokus setzen), initiiert durch die UI, werden vom system::compositor und system::window_mechanics umgesetzt.
Workspace-Wechsel.
Anpassung von Systemeinstellungen (z.B. Bildschirmhelligkeit, Lautstärke), die von system::outputs bzw. system::audio ausgeführt werden.


Fehlertypen: Modulspezifische Fehler-Enums (z.B. CompositorCoreError, InputError).
3.2. Nutzung durch die Benutzeroberflächenschicht
Darstellung von Systeminformationen: Die UI visualisiert die von der Systemschicht bereitgestellten Zustände.

Fensterlisten, Titelleisten, Fokus-Hervorhebungen basieren auf Daten von system::compositor.
Netzwerk-, Batterie-, Audio-Indikatoren in ui::shell zeigen Daten von system::dbus und system::audio.


Reaktion auf Eingabeereignisse: UI-Elemente reagieren auf verarbeitete Eingabeereignisse, um Aktionen auszulösen.
Initiierung von Systemaktionen: Benutzerinteraktionen in der UI führen zu Befehlsaufrufen an die Systemschicht.

Klick auf "Lauter"-Button in ui::shell ruft eine Funktion in system::audio auf.
Auswahl eines anderen Monitorsetups in ui::control_center sendet Befehl an system::outputs.


Dialoge über XDG Portals: ui::shell oder ui::components interagieren mit system::portals für Datei-Auswahl- oder Screenshot-Dialoge.
Die UI-Schicht behandelt Fehler von der Systemschicht und informiert ggf. den Benutzer.
Die UI-Schicht reagiert auf Systemereignisse (z.B. ActiveWorkspaceChanged indirekt über Änderungen der sichtbaren Fenster, DeviceAdded für Eingabegeräte), um ihre Darstellung anzupassen.
3.3. Ultra-Feinspezifikation: Modul system::dbus::notification_dbus_serviceDieses Modul implementiert den org.freedesktop.Notifications D-Bus Standard und dient als Brücke zur Domänenschicht (NotificationService).3.3.1. Modulübersicht
Zweck: Bereitstellung der org.freedesktop.Notifications D-Bus-Schnittstelle. Nimmt D-Bus-Methodenaufrufe entgegen, leitet sie an den NotificationService der Domänenschicht weiter und emittiert D-Bus-Signale basierend auf Domänenereignissen.
Dateistruktur: nova_de/system/src/dbus/notification_dbus_service.rs
Abhängigkeiten:

Extern: zbus (für D-Bus-Interaktion) 10, async-trait.
Intern: Arc<dyn domain::user_centric_services::NotificationService>, domain::events::DomainEvent, crate::event_bus::{EventSubscriber, DomainEvent}.


3.3.2. Datenstrukturen

struct NotificationDBusService {notification_service: Arc<dyn NotificationService>,connection: Arc<zbus::Connection>,// Für die Konvertierung von NotificationId (UUID) zu u32 (D-Bus ID) und umgekehrt:id_map: Arc<Mutex<IdMapper>>,}


struct IdMapper {next_dbus_id: u32,uuid_to_dbus: HashMap<NotificationId, u32>,dbus_to_uuid: HashMap<u32, NotificationId>,}

IdMapper ist notwendig, da die D-Bus-Spezifikation UINT32 für Benachrichtigungs-IDs verwendet, während intern uuid::Uuid für NotificationId genutzt wird, um globale Eindeutigkeit zu gewährleisten.


3.3.3. D-Bus SchnittstellenimplementierungDie Implementierung erfolgt mittels des #[dbus_interface] Makros von zbus.12Rust// nova_de/system/src/dbus/notification_dbus_service.rs
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use zbus::{dbus_interface, fdo, zvariant::Value, SignalContext};
use crate::domain::user_centric_services::notification_api::{
    NotificationService, NotificationId, NotificationAction, NotificationUrgency, CloseReason, NotificationError
};
use crate::event_bus::{DomainEvent, EventSubscriber}; // Angenommen, EventSubscriber ist definiert

// Hilfsstruktur für die ID-Konvertierung
struct IdMapper {
    next_dbus_id: u32,
    uuid_to_dbus: HashMap<NotificationId, u32>,
    dbus_to_uuid: HashMap<u32, NotificationId>,
}

impl IdMapper {
    fn new() -> Self {
        IdMapper {
            next_dbus_id: 1, // D-Bus IDs sind > 0
            uuid_to_dbus: HashMap::new(),
            dbus_to_uuid: HashMap::new(),
        }
    }

    fn get_or_create_dbus_id(&mut self, uuid: NotificationId) -> u32 {
        if let Some(dbus_id) = self.uuid_to_dbus.get(&uuid) {
            *dbus_id
        } else {
            let dbus_id = self.next_dbus_id;
            self.next_dbus_id += 1;
            self.uuid_to_dbus.insert(uuid, dbus_id);
            self.dbus_to_uuid.insert(dbus_id, uuid);
            dbus_id
        }
    }

    fn get_uuid(&self, dbus_id: u32) -> Option<NotificationId> {
        self.dbus_to_uuid.get(&dbus_id).copied()
    }

    fn remove_mapping_by_uuid(&mut self, uuid: &NotificationId) {
        if let Some(dbus_id) = self.uuid_to_dbus.remove(uuid) {
            self.dbus_to_uuid.remove(&dbus_id);
        }
    }
    
    fn remove_mapping_by_dbus_id(&mut self, dbus_id: u32) {
        if let Some(uuid) = self.dbus_to_uuid.remove(&dbus_id) {
            self.uuid_to_dbus.remove(&uuid);
        }
    }
}

pub struct NotificationDBusService {
    notification_service: Arc<dyn NotificationService + Send + Sync>,
    connection: Arc<zbus::Connection>,
    id_map: Arc<Mutex<IdMapper>>,
}

impl NotificationDBusService {
    pub async fn new(
        notification_service: Arc<dyn NotificationService + Send + Sync>,
        connection: Arc<zbus::Connection>,
        event_subscriber: Arc<dyn EventSubscriber<DomainEvent> + Send + Sync>, // Für das Abonnieren von DomainEvents
    ) -> Result<Self, zbus::Error> {
        let service = Self {
            notification_service,
            connection: connection.clone(),
            id_map: Arc::new(Mutex::new(IdMapper::new())),
        };

        // Task zum Abonnieren von DomainEvents und Emittieren von D-Bus Signalen
        let id_map_clone = service.id_map.clone();
        let conn_clone = connection.clone();
        tokio::spawn(async move {
            let mut stream = event_subscriber.subscribe();
            while let Some(event_result) = stream.recv().await { // Angenommen, subscribe() gibt einen Stream/Channel
                if let Ok(event) = event_result {
                    match event {
                        DomainEvent::NotificationClosed { id, reason, app_name: _ } => {
                            let dbus_id = {
                                let mut map = id_map_clone.lock().unwrap();
                                let id_val = map.get_uuid_to_dbus_id(id); // Hilfsfunktion in IdMapper
                                if id_val.is_some() { map.remove_mapping_by_uuid(&id); }
                                id_val
                            };
                            if let Some(valid_dbus_id) = dbus_id {
                                let dbus_reason = match reason {
                                    CloseReason::Expired => 1,
                                    CloseReason::DismissedByUser => 2,
                                    CloseReason::ClosedByApp => 3,
                                    CloseReason::Replaced => 3, // Oder eine spezifische D-Bus Reason, falls vorhanden
                                };
                                if let Err(e) = NotificationDBusService::emit_notification_closed(&conn_clone, valid_dbus_id, dbus_reason).await {
                                    tracing::error!("Failed to emit NotificationClosed D-Bus signal: {}", e);
                                }
                            }
                        }
                        DomainEvent::NotificationActionInvoked { id, action_key, app_name: _ } => {
                             let dbus_id = {
                                let map = id_map_clone.lock().unwrap();
                                map.get_uuid_to_dbus_id(id) // Hilfsfunktion in IdMapper
                            };
                            if let Some(valid_dbus_id) = dbus_id {
                                if let Err(e) = NotificationDBusService::emit_action_invoked(&conn_clone, valid_dbus_id, &action_key).await {
                                    tracing::error!("Failed to emit ActionInvoked D-Bus signal: {}", e);
                                }
                            }
                        }
                        _ => {} // Andere DomainEvents ignorieren
                    }
                }
            }
        });
        
        Ok(service)
    }

    // Hilfsfunktionen zum Emittieren von Signalen
    async fn emit_notification_closed(connection: &Arc<zbus::Connection>, id: u32, reason: u32) -> zbus::Result<()> {
        let ctxt = SignalContext::new(connection, "/org/freedesktop/Notifications")?;
        NotificationDBusService::notification_closed(&ctxt, id, reason).await
    }

    async fn emit_action_invoked(connection: &Arc<zbus::Connection>, id: u32, action_key: &str) -> zbus::Result<()> {
        let ctxt = SignalContext::new(connection, "/org/freedesktop/Notifications")?;
        NotificationDBusService::action_invoked(&ctxt, id, action_key).await
    }
}


#[dbus_interface(name = "org.freedesktop.Notifications")]
impl NotificationDBusService {
    async fn Notify(
        &self,
        app_name: String,
        replaces_id_dbus: u32,
        app_icon: String,
        summary: String,
        body: String,
        actions_dbus: Vec<String>,
        hints: HashMap<String, Value<'_>>, // zbus::zvariant::Value
        expire_timeout: i32,
    ) -> fdo::Result<u32> {
        tracing::debug!(
            "D-Bus Notify called: app_name={}, replaces_id={}, summary={}",
            app_name, replaces_id_dbus, summary
        );

        let replaces_id_uuid: Option<NotificationId> = if replaces_id_dbus == 0 {
            None
        } else {
            self.id_map.lock().unwrap().get_uuid(replaces_id_dbus)
        };

        let mut parsed_actions = Vec::new();
        for i in (0..actions_dbus.len()).step_by(2) {
            if i + 1 < actions_dbus.len() {
                parsed_actions.push(NotificationAction {
                    key: actions_dbus[i].clone(),
                    label: actions_dbus[i + 1].clone(),
                });
            }
        }
        
        // Konvertiere hints von zbus::zvariant::Value zu serde_json::Value
        let mut converted_hints = HashMap::new();
        for (k, v_ref) in hints.iter() {
            // Direkte Konvertierung ist möglicherweise nicht trivial.
            // Eine einfache Variante ist, wenn die Value-Typen kompatibel sind oder eine Serialisierung/Deserialisierung erfolgt.
            // Hier wird angenommen, dass die Struktur von Value serialisierbar zu JSON ist.
            // In einer echten Implementierung wäre hier robustere Konvertierungslogik nötig.
            match serde_json::to_value(v_ref) {
                Ok(json_val) => { converted_hints.insert(k.clone(), json_val); },
                Err(e) => {
                    tracing::warn!("Could not convert hint '{}' to JSON: {}", k, e);
                    // Optional: Fehler zurückgeben oder Hint ignorieren
                    // return Err(fdo::Error::InvalidArgs("Invalid hint format".into()));
                }
            }
        }


        // TODO: Urgency aus hints extrahieren, falls vorhanden (z.B. "urgency" byte)
        let urgency = NotificationUrgency::Normal; // Default, oder aus Hints bestimmen

        match self.notification_service.post_notification(
            app_name,
            replaces_id_uuid,
            if app_icon.is_empty() { None } else { Some(app_icon) },
            summary,
            if body.is_empty() { None } else { Some(body) },
            parsed_actions,
            converted_hints,
            expire_timeout,
            urgency,
        ).await {
            Ok(new_uuid) => {
                let dbus_id = self.id_map.lock().unwrap().get_or_create_dbus_id(new_uuid);
                Ok(dbus_id)
            }
            Err(e) => {
                tracing::error!("Error posting notification via service: {:?}", e);
                Err(fdo::Error::Failed(format!("Internal error: {}", e)))
            }
        }
    }

    async fn CloseNotification(&self, id: u32) -> fdo::Result<()> {
        tracing::debug!("D-Bus CloseNotification called for ID: {}", id);
        let uuid_to_close = match self.id_map.lock().unwrap().get_uuid(id) {
            Some(uuid) => uuid,
            None => {
                // Gemäß Spezifikation: "If the notification no longer exists, an empty D-BUS Error message is sent back."
                // Ein leerer fdo::Error::Failed("") ist nicht ideal, aber zbus erfordert einen Error-Namen.
                // org.freedesktop.DBus.Error.UnknownMethod ist nicht passend.
                // Ein benutzerdefinierter Fehler oder ein stillschweigendes Ok(()) könnte hier besser sein,
                // aber die Spezifikation verlangt einen Fehler.
                // Wir verwenden hier Failed, da kein spezifischerer Fehlercode für "existiert nicht mehr" vorgesehen ist.
                return Err(fdo::Error::Failed("Notification not found.".into()));
            }
        };

        match self.notification_service.close_notification(uuid_to_close, CloseReason::ClosedByApp).await {
            Ok(()) => {
                self.id_map.lock().unwrap().remove_mapping_by_dbus_id(id); // Mapping entfernen
                Ok(())
            }
            Err(NotificationError::NotFound(_)) => {
                 self.id_map.lock().unwrap().remove_mapping_by_dbus_id(id); // Sicherstellen, dass das Mapping entfernt ist
                 Err(fdo::Error::Failed("Notification not found by service.".into())) // Gemäß Spezifikation
            }
            Err(e) => {
                tracing::error!("Error closing notification via service: {:?}", e);
                Err(fdo::Error::Failed(format!("Internal error: {}", e)))
            }
        }
    }

    async fn GetCapabilities(&self) -> fdo::Result<Vec<String>> {
        tracing::debug!("D-Bus GetCapabilities called");
        Ok(vec!)
    }

    async fn GetServerInformation(&self) -> fdo::Result<(String, String, String, String)> {
        tracing::debug!("D-Bus GetServerInformation called");
        Ok((
            "NovaDE".to_string(),
            "NovaDE Project".to_string(),
            env!("CARGO_PKG_VERSION").to_string(), // Version aus Cargo.toml
            "1.2".to_string(), // Implementierte Spezifikationsversion
        ))
    }

    // Definition der Signale
    #[dbus_interface(signal)]
    async fn NotificationClosed(ctxt: &SignalContext<'_>, id: u32, reason: u32) -> zbus::Result<()>;

    #[dbus_interface(signal)]
    async fn ActionInvoked(ctxt: &SignalContext<'_>, id: u32, action_key: &str) -> zbus::Result<()>;
}
Hinweise zur Implementierung:
ID Mapping: Eine IdMapper-Struktur (oder ein ähnlicher Mechanismus) ist entscheidend, um zwischen den internen uuid::Uuid-basierten NotificationIds und den u32-basierten IDs der D-Bus-Schnittstelle zu übersetzen. replaces_id = 0 bedeutet eine neue Benachrichtigung. Zurückgegebene IDs müssen eindeutig sein.
Action Parsing: Die actions-Parameterliste im Notify-Aufruf ist ein flaches Array von Strings (as), wobei gerade Indizes Aktionsschlüssel und ungerade Indizes die zugehörigen Labels sind.9 Dies muss in die interne Vec<NotificationAction>-Struktur geparst werden.
Hints: hints ist ein a{sv} (Dictionary String to Variant). zbus::zvariant::Value muss in den internen Typ für Hint-Werte konvertiert werden (hier serde_json::Value als Beispiel). Die urgency (Dringlichkeit) und expire_timeout können auch über Hints gesteuert werden.
Signal Emission: Die D-Bus-Signale NotificationClosed und ActionInvoked müssen emittiert werden, wenn die entsprechenden DomainEvents (NotificationClosed, NotificationActionInvoked) vom NotificationService empfangen werden. Dies erfordert, dass NotificationDBusService den internen Event-Bus abonniert und in einem separaten Task auf diese Events lauscht.
Fehlerbehandlung: Interne NotificationError-Typen müssen in zbus::fdo::Error umgewandelt werden. Die D-Bus-Spezifikation gibt vor, dass bei CloseNotification für eine nicht existierende ID ein leerer D-Bus-Fehler zurückgegeben wird.
Asynchronität: Alle D-Bus-Methoden sind async. Die Interaktion mit dem NotificationService (der ebenfalls async sein kann) erfolgt über await.
Diese Implementierung stellt sicher, dass NovaDE sich standardkonform über D-Bus für Benachrichtigungen verhält und gleichzeitig die interne Logik in der Domänenschicht sauber gekapselt bleibt.3.3.4. Tabelle: org.freedesktop.Notifications D-Bus API zu NotificationService MappingD-Bus MemberTyp (Methode/Signal)NovaDE NotificationService Methode/DomänenEventSchlüsselparameter-/Payload-Mapping (D-Bus -> Intern)AnmerkungenNotifyMethodeasync post_notification(...)app_name -> app_name, replaces_id_dbus (u32) -> replaces_id (Option<NotificationId>), app_icon -> app_icon, summary -> summary, body -> body, actions_dbus (Vec<String>) -> actions (Vec<NotificationAction>), hints (HashMap<String, zbus::zvariant::Value>) -> hints (HashMap<String, serde_json::Value>), expire_timeout -> expire_timeout, urgency (aus Hints oder Default) -> urgencyID-Mapping für replaces_id und Rückgabewert erforderlich. Parsing der Aktionsliste. Hint-Konvertierung.CloseNotificationMethodeasync close_notification(...)id (u32) -> id (NotificationId)ID-Mapping. reason wird intern als CloseReason::ClosedByApp gesetzt.GetCapabilitiesMethodeN/A (Direkt in D-Bus Modul implementiert)N/AGibt statische Liste der Server-Fähigkeiten zurück (z.B. "body", "actions").GetServerInformationMethodeN/A (Direkt in D-Bus Modul implementiert)N/AGibt statische Serverinformationen zurück (Name, Vendor, Version, Spec-Version).NotificationClosedSignalDomainEvent::NotificationClosedid (NotificationId) -> id (u32), reason (CloseReason) -> reason (u32)ID-Mapping. Enum-Mapping für reason. Emittiert, wenn internes Event empfangen wird.ActionInvokedSignalDomainEvent::NotificationActionInvoked (löst async invoke_action(...) aus, welches dieses Event publiziert)id (NotificationId) -> id (u32), action_key (String) -> action_key (String)ID-Mapping. Emittiert, wenn internes Event empfangen wird.Diese Tabelle verdeutlicht die Kopplungspunkte und notwendigen Transformationen zwischen der standardisierten D-Bus-Schnittstelle und der internen Implementierung des Benachrichtigungsdienstes in NovaDE.4. Schnittstelle: Benutzeroberflächenschicht (UI Layer) zu Domänenschicht und SystemschichtDie UI-Schicht initiiert Aktionen in den unteren Schichten basierend auf Benutzerinteraktionen und stellt Informationen aus diesen Schichten dar.4.1. Gesendete Befehle/Daten an die Domänenschicht
Theming: ThemingEngine::update_configuration(new_config: ThemingConfiguration) durch ui::control_center oder ui::theming_gtk.
Workspaces: WorkspaceManager::create_workspace(name: Option<String>), set_active_workspace(id: WorkspaceId), pin_application_to_space(space_id: WorkspaceId, app_id: ApplicationIdentifier) durch ui::shell (Workspace-Switcher, SmartTabBar) oder ui::window_manager_frontend (Übersichtsmodus).
AI: AIInteractionLogicService::initiate_interaction(context_data: AIInteractionContextData), provide_consent(consent: AIConsent) durch ui::command_palette oder spezifische KI-Widgets.
Notifications: NotificationService::dismiss_notification(id: NotificationId), invoke_action(id: NotificationId, action_key: String) durch ui::notifications_frontend oder ui::shell (NotificationCenter).
Settings: GlobalSettingsService::update_setting(path: SettingPath, value: SettingValue) durch ui::control_center oder Quick-Settings.
4.2. Gesendete Befehle/Daten an die Systemschicht
Fenstermanagement: An system::window_mechanics oder direkt an system::compositor (über eine Fassade):

request_focus(window_id: DomainWindowIdentifier)
request_close_window(window_id: DomainWindowIdentifier)
request_move_window(window_id: DomainWindowIdentifier, new_pos: Point<i32, Logical>) (oder Start eines interaktiven Moves)
request_resize_window(window_id: DomainWindowIdentifier, new_size: Size<i32, Logical>) (oder Start eines interaktiven Resizes)
request_set_window_state(window_id: DomainWindowIdentifier, state: WindowState (Maximized, Minimized, Fullscreen))


Output-Konfiguration: An system::outputs (via wlr-output-management oder eine interne API):

apply_output_configuration(config: Vec<OutputConfigChange>) durch ui::control_center.


Audio-Steuerung: An system::audio::PipeWireClientService:

set_sink_volume(device_id, volume_percent), set_sink_mute(device_id, mute) durch ui::shell (Quick-Settings) oder ui::control_center.


Systemaktionen: An system::dbus Clients:

logind_client.lock_current_session() durch ui::shell (Lock-Button).
network_manager_client.activate_connection(connection_path, device_path) durch ui::shell (Quick-Settings) oder ui::control_center.


MCP-Anfragen: An system::mcp::SystemMcpService:

call_tool(server_id, tool_name, params, interaction_id) durch ui::command_palette oder KI-Widgets.


4.3. Ultra-Feinspezifikation: Modul ui::portals::file_chooser_portal_clientDieses Modul in der UI-Schicht ist verantwortlich für die Interaktion mit dem XDG Desktop Portal für Dateiauswahldialoge. Es agiert als Client für die D-Bus-Schnittstelle org.freedesktop.portal.FileChooser.4.3.1. Modulübersicht
Zweck: Kapselt die Logik zur Kommunikation mit dem XDG FileChooser-Portal, um native Dateiauswahldialoge zu öffnen und die Ergebnisse zu verarbeiten.
Dateistruktur: nova_de/ui/src/portals/file_chooser_portal_client.rs
Abhängigkeiten:

Extern: zbus (für D-Bus-Client-Interaktion) 10, tokio (für asynchrone Operationen).
Intern: core::errors::UIError (oder spezifischer PortalError), core::types.


4.3.2. Interne Datenstrukturen und Typen

struct FileChooserPortalClient { connection: Arc<zbus::Connection> }

Hält die D-Bus-Verbindung.



pub struct OpenFileOptions {pub parent_window_id: Option<String>, // XDG Window Identifierpub title: String,pub accept_label: Option<String>,pub modal: bool,pub multiple: bool,pub directory: bool,pub filters: Vec<FileFilter>,pub current_filter: Option<FileFilter>,pub current_folder: Option<PathBuf>,}

Spiegelt die Optionen des OpenFile-D-Bus-Aufrufs.15



pub struct FileFilter {pub name: String,pub patterns: Vec<FilterPattern>, // (u32 type, String pattern)}

FilterPattern: pub enum FilterPattern { Glob(String), MimeType(String) }



pub struct SaveFileOptions {... } (analog zu OpenFileOptions)


pub enum FileChooserResponse {SelectedFiles(Vec<url::Url>),SelectedFolder(url::Url),Cancelled,Error(PortalError),}


#pub enum PortalError {#DBusConnection(#[from] zbus::Error),#DBusCall(#[from] zbus::fdo::Error),#[error("Portal request failed with code {code}: {message}")]RequestFailed { code: u32, message: String },#InvalidUri(String),#[error("Portal response malformed: {0}")]ResponseMalformed(String),}

4.3.3. D-Bus Proxy Definition (intern)Mittels zbus::proxy wird ein Proxy für org.freedesktop.portal.FileChooser erstellt.10Rust// Innerhalb von file_chooser_portal_client.rs oder einem Hilfsmodul
use zbus::{proxy, zvariant::{Value, ObjectPath, OwnedValue, Dict, Array}};
use std::collections::HashMap;

#
trait FileChooser {
    async fn OpenFile(
        &self,
        parent_window: &str, // Window identifier, "" if none
        title: &str,
        options: HashMap<&str, Value<'_>>,
    ) -> zbus::fdo::Result<ObjectPath<'static>>; // Request handle

    async fn SaveFile(
        &self,
        parent_window: &str,
        title: &str,
        options: HashMap<&str, Value<'_>>,
    ) -> zbus::fdo::Result<ObjectPath<'static>>;

    // SaveFiles nicht im Detail hier, aber analog
}

// Proxy für org.freedesktop.portal.Request, um die Antwort zu empfangen
#
trait PortalRequest {
    #[zbus(signal)]
    async fn Response(&self, response_code: u32, results: Dict<'_, String, OwnedValue>) -> zbus::Result<()>;
    // Methode zum Schließen des Requests, falls benötigt
    // async fn Close(&self) -> zbus::fdo::Result<()>;
}
4.3.4. Implementierung von FileChooserPortalClientRust// nova_de/ui/src/portals/file_chooser_portal_client.rs
use zbus::{Connection, zvariant::{Value, Dict, Array, ObjectPath, Str, Type}, fdo::Error as ZbusFdoError};
use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;
use url::Url;
use futures_util::stream::StreamExt; // Für das Lauschen auf Signale

//... (Proxy-Definitionen von oben)...
//... (OpenFileOptions, FileFilter, FileChooserResponse, PortalError Definitionen)...

impl FileChooserPortalClient {
    pub fn new(connection: Arc<Connection>) -> Self {
        Self { connection }
    }

    fn build_open_file_options_dict<'a>(
        &self,
        options: &'a OpenFileOptions,
        handle_token: &'a str
    ) -> HashMap<&'a str, Value<'a>> {
        let mut dict = HashMap::<&str, Value<'_>>::new();
        dict.insert("handle_token", Value::from(handle_token));
        if let Some(label) = &options.accept_label {
            dict.insert("accept_label", Value::from(label.as_str()));
        }
        dict.insert("modal", Value::from(options.modal));
        dict.insert("multiple", Value::from(options.multiple));
        dict.insert("directory", Value::from(options.directory)); // Version 3+ [15]

        if!options.filters.is_empty() {
            let mut filters_array = Array::new(Type::Tuple(Arc::new())))])));
            for filter in &options.filters {
                let mut patterns_array = Array::new(Type::Tuple(Arc::new()));
                for pattern_enum in &filter.patterns {
                    match pattern_enum {
                        FilterPattern::Glob(p) => patterns_array.append(Value::from((0u32, p.as_str()))).unwrap(),
                        FilterPattern::MimeType(m) => patterns_array.append(Value::from((1u32, m.as_str()))).unwrap(),
                    }
                }
                filters_array.append(Value::from((Str::from(filter.name.as_str()), patterns_array))).unwrap();
            }
            dict.insert("filters", Value::from(filters_array));
        }
        
        if let Some(current_filter) = &options.current_filter {
            let mut patterns_array = Array::new(Type::Tuple(Arc::new()));
            for pattern_enum in &current_filter.patterns {
                 match pattern_enum {
                    FilterPattern::Glob(p) => patterns_array.append(Value::from((0u32, p.as_str()))).unwrap(),
                    FilterPattern::MimeType(m) => patterns_array.append(Value::from((1u32, m.as_str()))).unwrap(),
                }
            }
            dict.insert("current_filter", Value::from((Str::from(current_filter.name.as_str()), patterns_array)));
        }

        if let Some(folder) = &options.current_folder {
            if let Some(folder_str) = folder.to_str() {
                 // Pfad muss als Array von Bytes (ay) gesendet werden, null-terminiert
                 let mut path_bytes: Vec<u8> = folder_str.as_bytes().to_vec();
                 path_bytes.push(0); // Null-Terminierung
                 dict.insert("current_folder", Value::from(path_bytes));
            }
        }
        dict
    }

    pub async fn open_file_dialog(
        &self,
        options: OpenFileOptions,
    ) -> Result<FileChooserResponse, PortalError> {
        let portal_proxy = FileChooserProxy::new(&self.connection).await?;
        let handle_token = format!("novade_open_{}", uuid::Uuid::new_v4().to_simple()); // Eindeutiger Token [15]

        let options_dict = self.build_open_file_options_dict(&options, &handle_token);
        
        let parent_window_str = options.parent_window_id.as_deref().unwrap_or("");

        let request_path: ObjectPath<'_> = portal_proxy
           .OpenFile(parent_window_str, &options.title, options_dict)
           .await?;
        
        tracing::debug!("OpenFile request sent. Handle: {}", request_path.as_str());

        // Auf das Response-Signal warten
        let request_proxy = PortalRequestProxy::builder(&self.connection)
           .path(request_path.to_owned())? //.to_owned() um Lifetime-Probleme zu vermeiden
           .build()
           .await?;
            
        let mut response_stream = request_proxy.receive_Response().await?;

        if let Some(signal_args) = response_stream.next().await {
            let response_code = signal_args.args()?.response_code;
            let results_dict = signal_args.args()?.results;
            tracing::debug!("Portal Response received: code={}, results={:?}", response_code, results_dict);

            if response_code == 0 { // Erfolg
                if let Some(Value::Array(uris_array)) = results_dict.get("uris") {
                    let mut uris = Vec::new();
                    for val in uris_array.get() {
                        if let Value::Str(s) = val {
                            match Url::parse(s.as_str()) {
                                Ok(url) => uris.push(url),
                                Err(_) => return Err(PortalError::InvalidUri(s.as_str().to_string())),
                            }
                        }
                    }
                    if options.directory {
                        if let Some(first_uri) = uris.into_iter().next() {
                             return Ok(FileChooserResponse::SelectedFolder(first_uri));
                        } else {
                            return Err(PortalError::ResponseMalformed("No URI returned for directory selection".into()));
                        }
                    } else {
                        return Ok(FileChooserResponse::SelectedFiles(uris));
                    }
                } else {
                    return Err(PortalError::ResponseMalformed("Missing 'uris' in results".into()));
                }
            } else if response_code == 1 { // Abgebrochen durch Benutzer
                return Ok(FileChooserResponse::Cancelled);
            } else { // Anderer Fehler
                let message = results_dict.get("message")
                               .and_then(|v| if let Value::Str(s) = v { Some(s.to_string()) } else { None })
                               .unwrap_or_else(|| "Unknown portal error".to_string());
                return Err(PortalError::RequestFailed { code: response_code, message });
            }
        }
        // Timeout oder anderer Fehler beim Warten auf das Signal
        Err(PortalError::ResponseMalformed("No response signal received".into()))
    }

    // pub async fn save_file_dialog(...) -> Result<FileChooserResponse, PortalError> {... }
    // Ähnliche Implementierung wie open_file_dialog, aber mit SaveFile-Methode und Optionen.
}
Implementierungsdetails:
Window Identifier: Der parent_window-Parameter für Portalaufrufe ist ein String. Für Wayland-Oberflächen wird dies typischerweise als wayland:WAYLAND_SURFACE_HANDLE formatiert, wobei der Handle die Objekt-ID der Wayland-Oberfläche ist. Die UI-Schicht muss diesen Bezeichner bereitstellen.
Optionen-Dictionary: Die options für OpenFile und SaveFile werden als HashMap<&str, zbus::zvariant::Value<'_>> konstruiert. Die Schlüssel und Werttypen müssen der XDG Portal Spezifikation entsprechen.15

filters: a(sa(us)) - Array von Tupeln (String, Array von Tupeln (Uint32, String)).
current_folder: ay - Byte-Array (null-terminierter Pfad).


Antwortverarbeitung: Die Antwort des Portals kommt asynchron über das Response-Signal auf dem Request-Objekt. Der Client muss dieses Signal abonnieren und die Ergebnisse (uris, choices) parsen.
Fehlerbehandlung: PortalError kapselt D-Bus-Fehler und spezifische Portal-Fehlercodes.
Asynchronität: Alle D-Bus-Aufrufe und Signal-Listener sind async.
Die Verwendung von XDG Desktop Portals ermöglicht es NovaDE-Anwendungen, die in einer Sandbox laufen könnten, auf sichere Weise mit dem Host-System zu interagieren, z.B. um Dateien zu öffnen oder zu speichern, ohne direkten Dateisystemzugriff zu benötigen. Dies ist ein wichtiger Aspekt moderner Desktop-Sicherheit.5. Zusammenfassende Prinzipien der Schnittstellen
Klare Verantwortlichkeiten: Jede Schicht hat definierte Aufgaben, und die Schnittstellen spiegeln diese wider.
Lose Kopplung: Kommunikation erfolgt über APIs (Traits) und Events, um direkte Abhängigkeiten von Implementierungsdetails zu minimieren.
Hohe Kohäsion: Module innerhalb einer Schicht arbeiten eng zusammen, aber die Schicht als Ganzes hat eine klar definierte externe Schnittstelle.
Einheitliche Fehlerbehandlung: Die thiserror-basierte Strategie wird über alle Schichten hinweg verwendet, wobei Fehler weitergeleitet oder spezifisch behandelt werden. Die source()-Kette ist wichtig.1
Event-gesteuerte Updates: Viele Zustandsänderungen werden über Events kommuniziert, was eine reaktive und entkoppelte Architektur fördert. Die UI-Schicht ist ein primärer Konsument von Events aus der Domänen- und Systemschicht, um ihre Darstellung aktuell zu halten.
Asynchronität: Schnittstellen, die potenziell blockierende Operationen beinhalten (I/O, IPC), sind als async deklariert und nutzen Rusts async/await-Syntax.
6. SchlussfolgerungenDie detaillierte Spezifikation der internen Schnittstellen und die Ultra-Feinspezifikation ausgewählter Module bilden das Rückgrat für die Entwicklung der NovaDE. Durch die klare Definition von Verantwortlichkeiten, Datenstrukturen, Methoden, Events und Fehlerbehandlung wird eine solide Grundlage für parallele Entwicklung und zukünftige Erweiterbarkeit geschaffen.Die konsequente Anwendung von Rusts Typ- und Fehlersystem, kombiniert mit etablierten Mustern wie der Trennung von API (Traits) und Implementierung sowie einem zentralen Event-Bus, trägt maßgeblich zur Robustheit und Wartbarkeit des Systems bei. Die detaillierte Ausarbeitung der Schnittstellen zu Standard-Desktop-Diensten wie org.freedesktop.Notifications und XDG Desktop Portals gewährleistet eine gute Integration in das Linux-Ökosystem.Dieser Implementierungsleitfaden ist so konzipiert, dass Entwickler die einzelnen Module mit einem hohen Grad an Sicherheit und Klarheit implementieren können, wodurch Integrationsrisiken minimiert und die Gesamtqualität der NovaDE maximiert wird. Die durchgängige Verwendung von async/await für potenziell blockierende Operationen stellt sicher, dass die Desktop-Umgebung reaktionsschnell bleibt. Die sorgfältige Definition von Fehlerketten mittels thiserror wird die Fehlersuche und -behebung im gesamten System erheblich vereinfachen.


# NovaDE Interner Schnittstellen-Implementierungsleitfaden

Dieser Implementierungsleitfaden definiert die ultrafeinen Spezifikationen und hochdetaillierten Implementierungspläne für jede Schicht der Linux-Desktop-Umgebung "NovaDE". Er ist so detailliert konzipiert, dass Entwickler ihn direkt zur Implementierung verwenden können, ohne eigene Entscheidungen treffen oder Logiken/Algorithmen entwerfen zu müssen.

---

## 1. Schicht: Kernschicht (Core Layer)

Die Kernschicht (Core Layer) bildet das Fundament von NovaDE und stellt grundlegende, universell einsetzbare Bausteine und Dienste bereit, die von allen darüberliegenden Schichten – der Domänenschicht, der Systemschicht und der Benutzeroberflächenschicht (UI-Schicht) – genutzt werden. Die Kommunikation mit höheren Schichten erfolgt durch die direkte Verwendung der hier definierten Typen und Funktionen.

### 1.1. Modul: `core::types`

Dieses Modul definiert grundlegende Datentypen, die systemweit für geometrische Berechnungen, Farbdarstellungen und andere fundamentale Konzepte verwendet werden.

- **Verzeichnis:** `core/src/types/`

#### 1.1.1. `Point<T>` Struktur

Stellt einen Punkt im 2D-Raum dar.

- Datei: `core/src/types/point.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Point<T, U> {
        pub x: T,
        pub y: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Point<T, U> {
        fn default() -> Self {
            Point { x: Default::default(), y: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    // U kann z.B. Logical, Physical, BufferCoords sein
    pub struct Logical;
    pub struct Physical;
    pub struct BufferCoords;
    
    impl<T, U> Point<T, U> {
        pub const fn new(x: T, y: T) -> Self {
            Point { x, y, _unit: std::marker::PhantomData }
        }
    }
    
    // Weitere Methoden wie Add, Sub, etc. können implementiert werden.
    ```
    
- Verwendung: Positionierung von UI-Elementen, Fensterkoordinaten.

#### 1.1.2. `Size<T>` Struktur

Stellt die Dimensionen (Breite und Höhe) eines 2D-Objekts dar.

- Datei: `core/src/types/size.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Size<T, U> {
        pub w: T,
        pub h: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Size<T, U> {
        fn default() -> Self {
            Size { w: Default::default(), h: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    impl<T, U> Size<T, U> {
        pub const fn new(w: T, h: T) -> Self {
            Size { w, h, _unit: std.marker::PhantomData }
        }
    }
    ```
    
- Verwendung: Fenstergrößen, UI-Element-Dimensionen.

#### 1.1.3. `Rect<T>` und `RectInt` Strukturen

Stellt ein Rechteck im 2D-Raum dar, definiert durch Position und Größe.

- Datei: `core/src/types/rect.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Rect<T, U> {
        pub loc: Point<T, U>,
        pub size: Size<T, U>,
    }
    
    impl<T: Default, U> Default for Rect<T, U> {
        fn default() -> Self {
            Rect { loc: Default::default(), size: Default::default() }
        }
    }
    
    impl<T, U> Rect<T, U> {
        pub const fn new(loc: Point<T, U>, size: Size<T, U>) -> Self {
            Rect { loc, size }
        }
        // Methoden wie contains_point, intersection, etc.
    }
    
    pub type RectInt = Rect<i32, Logical>; // Beispiel für einen häufigen Typ
    ```
    
- Verwendung: Fenstergeometrien, Auswahlbereiche.

#### 1.1.4. `Color` Struktur

Repräsentiert eine Farbe im RGBA-Format.

- Datei: `core/src/types/color.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Color {
        pub r: f32, // Range 0.0 to 1.0
        pub g: f32, // Range 0.0 to 1.0
        pub b: f32, // Range 0.0 to 1.0
        pub a: f32, // Range 0.0 to 1.0 (alpha)
    }
    
    impl Color {
        pub const fn new(r: f32, g: f32, b: f32, a: f32) -> Self {
            Color { r, g, b, a }
        }
    
        pub fn to_hex_rgb(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8
            )
        }
    
        pub fn to_hex_rgba(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8,
                (self.a * 255.0) as u8
            )
        }
        // Ggf. From-Implementierungen für gängige Formate (z.B. String "#RRGGBB")
    }
    ```
    
- Verwendung: Theming, UI-Elementfarben.

#### 1.1.5. `Orientation` Enum

Definiert die Ausrichtung von UI-Elementen oder Layouts.

- Datei: `core/src/types/orientation.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub enum Orientation {
        Horizontal,
        Vertical,
    }
    ```
    
- Verwendung: Layout-Manager, Ausrichtung von Bedienelementen.

#### 1.1.6. `uuid::Uuid` Integration

Universell eindeutige Identifikatoren.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use uuid::Uuid;`
- Abhängigkeit in `core/Cargo.toml`: `uuid = { version = "1.0", features = ["v4", "serde"] }`
    - Die Features `v4` und `serde` sind essenziell. `v4` ermöglicht die Generierung zufälliger UUIDs, die für die eindeutige Identifizierung von Entitäten wie Fenstern, Workspaces oder Benachrichtigungen unerlässlich sind. `serde` wird benötigt, falls diese IDs in Konfigurationsdateien persistiert oder über IPC-Schnittstellen serialisiert werden müssen, was in einer Desktop-Umgebung sehr wahrscheinlich ist.1
- Verwendung: Eindeutige Identifizierung von Ressourcen systemweit.

#### 1.1.7. `chrono::DateTime<Utc>` Integration

Zeitstempel mit UTC-Zeitzone.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use chrono::{DateTime, Utc};`
- Abhängigkeit in `core/Cargo.toml`: `chrono = { version = "0.4", features = ["serde"] }`
    - `chrono` ist der De-facto-Standard für Datums- und Zeitmanipulationen in Rust. Die Verwendung von `DateTime<Utc>` stellt zeitzonenagnostische Zeitstempel sicher, was für interne Repräsentationen als Best Practice gilt, um Komplexitäten bei der Zeitzonenbehandlung zu vermeiden. Das `serde`-Feature ist notwendig, wenn Zeitstempel persistiert (z.B. in Logdateien oder Konfigurationen) oder serialisiert werden sollen.3
- Verwendung: Zeitstempel für Logging, Events, "zuletzt geändert"-Informationen.

#### 1.1.8. Implementierungsschritte für `core::types`

1. Erstellen Sie das Verzeichnis `core/src/types/`.
2. Implementieren Sie `point.rs`, `size.rs`, `rect.rs`, `color.rs`, und `orientation.rs` gemäß den obigen Spezifikationen.
3. Fügen Sie `uuid` (mit Features "v4", "serde") und `chrono` (mit Feature "serde") zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
4. Fügen Sie die Re-Exports für `Uuid` und `DateTime<Utc>` in `core/src/types/mod.rs` hinzu. Alle lokalen Typen (Point, Size, etc.) sollten ebenfalls von `mod.rs` re-exportiert werden.
    
    Rust
    
    ```
    // core/src/types/mod.rs
    mod color;
    mod orientation;
    mod point;
    mod rect;
    mod size;
    
    pub use chrono::{DateTime, Utc};
    pub use color::Color;
    pub use orientation::Orientation;
    pub use point::{BufferCoords, Logical, Physical, Point};
    pub use rect::{Rect, RectInt};
    pub use size::Size;
    pub use uuid::Uuid;
    ```
    

### 1.2. Modul: `core::errors`

Dieses Modul stellt eine Basis-Fehlerbehandlungsstrategie und den `CoreError`-Typ bereit. Höhere Schichten können `CoreError` oder spezifischere Fehler aus Kernmodulen mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen wrappen, wobei die Fehlerursachenkette (`source()`) beibehalten wird.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/errors.rs`

#### 1.2.1. `CoreError` Enum

- Definition unter Verwendung von `thiserror`:
    
    Rust
    
    ```
    #
    pub enum CoreError {
        #[error("I/O error: {source}")]
        Io {
            #[from]
            source: std::io::Error,
            // Optional: context: String, // Um zusätzlichen Kontext zur IO-Operation zu geben
        },
    
        #[error("Configuration parsing error from '{path:?}': {message}")]
        ConfigParse {
            path: Option<std::path::PathBuf>,
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Serialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Deserialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Invalid path: {path:?}")]
        InvalidPath { path: std::path::PathBuf },
    
        #[error("Initialization failed for module: {module_name}")]
        InitializationFailed {
            module_name: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Feature not implemented: {feature_name}")]
        NotImplemented { feature_name: String },
    
        #[error("Internal error: {message}")]
        Internal { message: String },
    
        #[error("Operation timed out: {operation}")]
        Timeout { operation: String },
    
        #[error("Permission denied for operation: {operation}")]
        PermissionDenied { operation: String },
    }
    ```
    
    Die Verwendung von `thiserror` 5 ist entscheidend für die Erstellung ergonomischer und informativer Fehlertypen. Das Attribut `#[from]` ermöglicht eine einfache Konvertierung von Standardbibliotheksfehlern wie `std::io::Error`. Das Attribut `#[source]` (implizit von `thiserror` verwendet, wenn ein Feld `#[from]` oder explizit `#[source]` ist) ist entscheidend für die Beibehaltung der Fehlerursachenkette, wie in der Spezifikation hervorgehoben. Eine robuste Fehlerbehandlungsstrategie ist fundamental. `thiserror` vereinfacht die Erstellung benutzerdefinierter Fehlertypen, die gut mit dem `Error`-Trait von Rust integriert sind. Die Beibehaltung der `source()`-Kette ist für das Debugging unerlässlich, da sie es Entwicklern ermöglicht, einen Fehler bis zu seinem Ursprung zurückzuverfolgen, selbst wenn er von verschiedenen Schichten mehrfach umgebrochen wird.

#### 1.2.2. Fehlerpropagierungsstrategie

Alle Funktionen in der Kernschicht, die fehlschlagen können, MÜSSEN `Result<T, CoreError>` oder `Result<T, SpecificCoreSubError>` zurückgeben, wobei `SpecificCoreSubError` via `#[from]` in `CoreError` konvertierbar sein sollte. Höhere Schichten definieren ihre eigenen Fehler-Enums (z.B. `DomainError`, `SystemError`, `UIError`) und verwenden `#[from] CoreError` oder `#[source] CoreError`, um Fehler aus dem Kern zu wrappen.

#### 1.2.3. Implementierungsschritte für `core::errors`

1. Fügen Sie `thiserror = "1.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/errors.rs` mit dem `CoreError`-Enum wie oben spezifiziert.
3. Stellen Sie sicher, dass alle Module der Kernschicht `CoreError` für ihre Fehlerberichterstattung verwenden.

### 1.3. Modul: `core::logging`

Dieses Modul definiert die Logging-Infrastruktur basierend auf dem `tracing`-Crate. Alle höheren Schichten verwenden die `tracing`-Makros für ihre Logging-Ausgaben.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/logging.rs`

#### 1.3.1. `initialize_logging()` Funktion

- Signatur:
    
    Rust
    
    ```
    pub fn initialize_logging(
        level_filter: tracing::Level,
        use_json: bool,
        custom_writer: Option<Box<dyn Fn() -> Box<dyn std::io::Write + Send + Sync + 'static> + Send + Sync + 'static>>
    ) -> Result<(), CoreError>
    ```
    
    - `level_filter`: Der minimale Log-Level, der aufgezeichnet werden soll (z.B. `tracing::Level::INFO`, `tracing::Level::DEBUG`).
    - `use_json`: Wenn `true`, werden Logs im JSON-Format ausgegeben, andernfalls in einem menschenlesbaren Format.
    - `custom_writer`: Eine optionale Funktion, die einen Writer für die Log-Ausgabe zurückgibt (z.B. in eine Datei, einen Netzwerk-Socket oder `std::io::stderr`). Standardmäßig wird `std::io::stderr` verwendet. Die Funktion wird verwendet, um den Writer bei Bedarf neu erstellen zu können (z.B. bei Log-Rotation).
- Implementierung:
    1. Verwendet `tracing_subscriber::fmt()` für die formatierte Protokollierung.
    2. Ermöglicht die Konfiguration des Formats (JSON oder "pretty") und des Writers.
        - Für JSON: `tracing_subscriber::fmt().json().with_writer(writer_closure).init();`
        - Für Pretty: `tracing_subscriber::fmt().pretty().with_writer(writer_closure).init();`
    3. Konfiguriert den `EnvFilter` basierend auf `level_filter` oder einer Umgebungsvariable (z.B. `RUST_LOG`).
    4. Richtet einen globalen Standard-Subscriber ein mittels `tracing::subscriber::set_global_default`.
    5. Gibt `Result<(), CoreError>` zurück, um Initialisierungsfehler zu signalisieren (z.B. wenn das Setzen des globalen Subscribers fehlschlägt).
- Die Standardisierung auf `tracing` ermöglicht eine strukturierte Protokollierung über alle Schichten hinweg, was für das Debugging und die Überwachung eines komplexen Systems wie einer Desktop-Umgebung von unschätzbarem Wert ist. Die Möglichkeit, zwischen menschenlesbaren und JSON-Formaten zu wechseln, ist gut für Entwicklung versus Produktion/Log-Aggregation. `tracing` bietet ein leistungsfähigeres und flexibleres Logging-Framework als das ältere `log`-Crate, insbesondere durch sein Konzept von Spans für kontextbezogene Protokollierung. Dies ist in einem mehrschichtigen, ereignisgesteuerten System von großem Vorteil.

#### 1.3.2. Verwendung von `tracing`-Makros

Alle Schichten verwenden die Makros `trace!`, `debug!`, `info!`, `warn!`, `error!` aus dem `tracing`-Crate. Spans (`span!`, `info_span!`, etc.) sollten verwendet werden, um kontextuelle Informationen für zusammengehörige Log-Meldungen bereitzustellen.

- Beispiel: `info!(target: "core::config", path = %file_path.display(), "Lade Kernkonfiguration.");`
- Beispiel mit Span:
    
    Rust
    
    ```
    let workspace_span = info_span!("workspace_operation", id = %workspace_id);
    let _enter = workspace_span.enter();
    //... Operationen innerhalb des Spans...
    info!("Operation abgeschlossen");
    ```
    

#### 1.3.3. Implementierungsschritte für `core::logging`

1. Fügen Sie `tracing = "0.1"` und `tracing_subscriber = { version = "0.3", features = ["fmt", "json", "env-filter"] }` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/logging.rs` mit der Funktion `initialize_logging()` wie oben spezifiziert.

### 1.4. Modul: `core::config`

Dieses Modul stellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit. Es definiert die Struktur `CoreConfig` und Funktionen für deren Verwaltung.

- **Verzeichnis:** `core/src/config/`

#### 1.4.1. `CoreConfig` Struktur

Definiert die Kernkonfigurationseinstellungen.

- Datei: `core/src/config/types.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct CoreConfig {
        pub log_level: String, // z.B. "info", "debug", "trace"
        pub log_format: LogFormat,
        pub default_theme_name: Option<String>,
        pub enable_xwayland: bool,
        // Weitere kernspezifische Konfigurationen, z.B. Pfade, Feature-Flags
    }
    
    #
    #[serde(rename_all = "lowercase")]
    pub enum LogFormat {
        Json,
        Pretty,
    }
    
    impl Default for CoreConfig {
        fn default() -> Self {
            CoreConfig {
                log_level: "info".to_string(),
                log_format: LogFormat::Pretty,
                default_theme_name: Some("NovaDark".to_string()),
                enable_xwayland: true,
            }
        }
    }
    ```
    

#### 1.4.2. `ConfigError` Enum

Spezifische Fehler für das Laden und Verarbeiten von Konfigurationen.

- Datei: `core/src/config/error.rs`
- Definition:
    
    Rust
    
    ```
    use crate::core::errors::CoreError; // Assuming CoreError is in crate::core
    
    #
    pub enum ConfigError {
        #[error("Failed to determine config directory: {0}")]
        DirectoryResolutionError(String),
    
        #[error("Config file not found at {path:?}")]
        FileNotFound { path: std::path::PathBuf },
    
        #[error("Failed to read config file {path:?}")]
        FileReadError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        TomlParseError {
            path: std::path::PathBuf,
            message: String,
            #[source]
            source: Option<toml::de::Error>,
        },
        // Ggf. JsonParseError, falls JSON auch unterstützt wird
    
        #[error("Configuration not loaded or initialization failed.")]
        NotLoaded,
    
        #[error("Invalid configuration value for key '{key}': {message}")]
        InvalidValue { key: String, message: String },
    
        #[error("Failed to write default config to {path:?}")]
        DefaultConfigWriteError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        DefaultConfigTomlError(#[from] toml::ser::Error),
    
        #[error(transparent)]
        Core(#[from] CoreError), // Um CoreError wrappen zu können
    }
    ```
    

#### 1.4.3. Globale Konfigurationsvariable

Verwendet `once_cell` für eine thread-sichere, einmalig initialisierte globale Konfiguration.

- Datei: `core/src/config/mod.rs` (oder `core/src/config/global.rs`)
    
    Rust
    
    ```
    use once_cell::sync::OnceCell;
    use std::sync::RwLock;
    use super::types::CoreConfig; // Pfad anpassen
    use super::error::ConfigError; // Pfad anpassen
    
    static CORE_CONFIG: OnceCell<RwLock<CoreConfig>> = OnceCell::new();
    ```
    

#### 1.4.4. `load_core_config()` Funktion

Lädt die Kernkonfiguration aus einer Datei.

- Datei: `core/src/config/loader.rs`
- Signatur: `pub fn load_core_config(custom_path: Option<std::path::PathBuf>) -> Result<(), ConfigError>`
- Implementierung:
    
    1. Bestimme den Konfigurationsdateipfad:
        - Verwende `custom_path`, falls angegeben.
        - Andernfalls suche im XDG-Standardverzeichnis (z.B. `$XDG_CONFIG_HOME/nova-de/core.toml`) mittels `directories_next::ProjectDirs`.
        - Falls kein XDG-Verzeichnis gefunden wird, verwende einen Fallback-Pfad (z.B. `~/.config/nova-de/core.toml`).
    2. Wenn die Datei nicht existiert, erstelle eine Standardkonfiguration (`CoreConfig::default()`) und speichere sie unter dem ermittelten Pfad. Logge diesen Vorgang.
    3. Lese den Dateiinhalt. Bei Fehler `ConfigError::FileReadError`.
    4. Parse den Inhalt (z.B. TOML) in eine `CoreConfig`-Instanz. Bei Fehler `ConfigError::TomlParseError`.
    5. Initialisiere die globale `CORE_CONFIG` Variable mit der geladenen Konfiguration: `CORE_CONFIG.set(RwLock::new(loaded_config)).map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für den Fall, dass `set` fehlschlägt, was nur passiert, wenn bereits initialisiert).
    6. Gibt `Ok(())` bei Erfolg zurück.
    
    - Eine globale, statisch zugängliche Konfiguration ist üblich, erfordert aber eine sorgfältige Verwaltung, insbesondere bei der Initialisierung. `once_cell` für die Lazy-Initialisierung und `RwLock` für den threadsicheren Zugriff sind ein gutes Muster. Die Konfiguration muss früh im Anwendungslebenszyklus verfügbar sein und von verschiedenen Teilen des Systems zugänglich sein. `once_cell` stellt sicher, dass das Laden nur einmal erfolgt.

#### 1.4.5. `get_core_config()` Funktion

Bietet globalen Lesezugriff auf die geladene `CoreConfig`.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn get_core_config() -> Result<std::sync::RwLockReadGuard<'static, CoreConfig>, ConfigError>`
- Implementierung:
    1. Versuche, einen Read-Lock auf `CORE_CONFIG` zu erhalten: `CORE_CONFIG.get().ok_or(ConfigError::NotLoaded)?.read().map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für Poisoned Lock).
    2. Gibt den `RwLockReadGuard` bei Erfolg zurück.

#### 1.4.6. `update_core_config()` Funktion (Optional)

Ermöglicht die dynamische Aktualisierung der Kernkonfiguration zur Laufzeit.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn update_core_config(new_config: CoreConfig) -> Result<(), ConfigError>`
- Implementierung:
    1. Versuche, einen Write-Lock auf `CORE_CONFIG` zu erhalten.
    2. Aktualisiere die Konfiguration.
    3. Persistiert die neue Konfiguration in die Datei.
    4. **Wichtig:** Benachrichtige relevante Systemteile über die Konfigurationsänderung (z.B. über ein Event). Dies erfordert sorgfältige Überlegungen zur Thread-Sicherheit und wie Komponenten auf dynamische Änderungen reagieren.

#### 1.4.7. Implementierungsschritte für `core::config`

1. Fügen Sie `serde = { version = "1.0", features = ["derive"] }`, `toml = "0.8"`, `once_cell = "1.19"`, `directories-next = "2.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Erstellen Sie die Verzeichnisstruktur `core/src/config/`.
3. Definieren Sie `CoreConfig` und `LogFormat` in `core/src/config/types.rs`.
4. Definieren Sie `ConfigError` in `core/src/config/error.rs`.
5. Implementieren Sie `loader.rs` (mit `load_core_config`) und `access.rs` (mit `get_core_config` und optional `update_core_config`).
6. Fügen Sie die globale `CORE_CONFIG`-Variable in `core/src/config/mod.rs` oder einer dedizierten `global.rs` ein und exportieren Sie die öffentlichen Funktionen.

### 1.5. Modul: `core::utils`

Dieses Modul bietet allgemeine Hilfsfunktionen, die von allen höheren Schichten genutzt werden können.

- **Verzeichnis:** `core/src/utils/`
- **Struktur:** Das Modul sollte in thematische Untermodule aufgeteilt werden, um die Übersichtlichkeit zu wahren.

#### 1.5.1. Untermodul: `core::utils::file_utils`

- Datei: `core/src/utils/file_utils.rs`
- Funktionen:
    - `pub fn read_file_to_string(path: &std::path::Path) -> Result<String, CoreError>`
        - Implementierung: Verwendet `std::fs::read_to_string`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn ensure_dir_exists(path: &std::path::Path) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::create_dir_all`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn write_string_to_file(path: &std::path::Path, content: &str) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::write`. Mappt `std::io::Error` auf `CoreError::Io`.

#### 1.5.2. Untermodul: `core::utils::string_utils`

- Datei: `core/src/utils/string_utils.rs`
- Funktionen:
    - `pub fn sanitize_filename(name: &str) -> String`
        - Implementierung: Ersetzt ungültige Zeichen für Dateinamen (z.B. `/`, `\`, `:`, `*`, `?`, `"`, `<`, `>`, `|`) durch Unterstriche oder entfernt sie.
    - `pub fn truncate_string_with_ellipsis(s: &str, max_len: usize) -> String`
        - Implementierung: Kürzt den String auf `max_len` Zeichen und fügt "..." hinzu, falls er gekürzt wurde. Achtet auf Grapheme Cluster, um Unicode-Zeichen nicht zu zerschneiden.
            
            Rust
            
            ```
            use unicode_segmentation::UnicodeSegmentation;
            //...
            // if s.graphemes(true).count() > max_len {
            //     s.graphemes(true).take(max_len - 3).collect::<String>() + "..."
            // } else {
            //     s.to_string()
            // }
            ```
            
            - Abhängigkeit: `unicode-segmentation = "1.10"`

#### 1.5.3. Untermodul: `core::utils::async_utils` (falls benötigt)

- Datei: `core/src/utils/async_utils.rs`
- Mögliche Funktionen:
    - Wrapper für `tokio::spawn` mit standardisierter Fehlerbehandlung oder Logging.
    - Hilfsfunktionen für Timeout-Management bei asynchronen Operationen.

#### 1.5.4. Implementierungsschritte für `core::utils`

1. Erstellen Sie das Verzeichnis `core/src/utils/`.
2. Erstellen Sie `core/src/utils/mod.rs` und deklarieren Sie die Untermodule:
    
    Rust
    
    ```
    pub mod file_utils;
    pub mod string_utils;
    // pub mod async_utils;
    ```
    
3. Implementieren Sie die Funktionen in den jeweiligen Untermodul-Dateien.
4. Fügen Sie ggf. Abhängigkeiten wie `unicode-segmentation` zu `core/Cargo.toml` hinzu.
5. Das `utils`-Modul kann leicht zu einer Ansammlung unzusammenhängender Funktionen werden. Es ist wichtig, die Organisation beizubehalten und sicherzustellen, dass die Funktionen eine breite Anwendbarkeit haben. Wenn eine Hilfsfunktion sehr spezifisch für eine einzelne Domäne oder ein Systemanliegen ist, sollte sie stattdessen im Hilfsmodul dieser Schicht angesiedelt sein. Eine klare Abgrenzung ist notwendig, um die Kohäsion der Module zu wahren und unnötige Kopplungen zu vermeiden.

---

## 2. Schicht: Domänenschicht (Domain Layer)

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung NovaDE. Sie definiert die zentralen Konzepte, Regeln und Verhaltensweisen des Systems, unabhängig von technischen Implementierungsdetails der System- oder UI-Schicht. Die Kommunikation mit höheren Schichten (System- und UI-Schicht) erfolgt primär über wohldefinierte Service-APIs (als Rust-Traits implementiert) und durch domänenspezifische Events, die Zustandsänderungen signalisieren.

Die Domänenschicht ist zentral für die Funktionalität von NovaDE. Die Verwendung von Rust-Traits für Service-APIs fördert lose Kopplung und Testbarkeit. Ereignisse sind der Schlüssel zur reaktiven Propagierung von Zustandsänderungen. Fehlertypen sollten für jedes Domänenmodul spezifisch sein, um klaren Kontext zu bieten.

### 2.1. Service APIs (Traits)

Öffentliche Schnittstellen der Domänenschicht werden primär durch Rust-Traits definiert. Diese Traits werden von Service-Strukturen innerhalb der Domänenmodule implementiert. Methoden sind typischerweise `async`, wenn sie I/O-Operationen oder potenziell langlaufende Prozesse beinhalten, und geben `Result<T, SpecificDomainError>` zurück.

#### 2.1.1. `domain::theming::ThemingEngine` Trait

Verantwortlich für die Verwaltung und Anwendung von Themes.

- **Datei:** `domain/src/theming/engine.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`ThemingConfiguration` Struct (Wertobjekt):**
    
    - Definiert die vom Benutzer oder System gewählten Theme-Einstellungen.
    - **Datei:** `domain/src/theming/config.rs`
    - **Felder:**
        - `icon_theme_name: String` (z.B. "Adwaita", "Papirus")
        - `gtk_theme_name: String` (z.B. "Adwaita-dark")
        - `cursor_theme_name: String` (z.B. "Adwaita")
        - `font_name: String` (z.B. "Cantarell 11")
        - `wallpaper_path: Option<std::path::PathBuf>`
        - `color_scheme: ColorScheme` (Enum: `Light`, `Dark`, `SystemPreference`)
        - `accent_color: core::types::Color`
    - **Invarianten:** `font_name` darf nicht leer sein, wenn gesetzt.
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`ColorScheme` Enum (Wertobjekt):**
    
    - Definiert die möglichen Farbschemata.
    - **Datei:** `domain/src/theming/config.rs` (oder `types.rs` im Theming-Modul)
    - **Varianten:** `Light`, `Dark`, `SystemPreference`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AppliedThemeState` Struct (Wertobjekt):**
    
    - Repräsentiert den aktuell angewandten Theme-Zustand, inklusive aufgelöster Werte.
    - **Datei:** `domain/src/theming/state.rs`
    - **Felder:**
        - `current_config: ThemingConfiguration`
        - `resolved_wallpaper_path: Option<std::path::PathBuf>` (absoluter Pfad zum tatsächlich genutzten Hintergrundbild)
        - `font_config_details: String` (z.B. eine Pango-Font-Beschreibung oder Fontconfig-Pattern)
        - `effective_color_scheme: EffectiveColorScheme` (Enum: `Light`, `Dark`)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`EffectiveColorScheme` Enum (Wertobjekt):**
    
    - Repräsentiert das tatsächlich aktive Farbschema (aufgelöst aus `SystemPreference`).
    - **Datei:** `domain/src/theming/state.rs`
    - **Varianten:** `Light`, `Dark`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`ThemingError` Enum (Fehlertyp):**
    
    - Spezifische Fehler für das Theming-Subsystem.
    - **Datei:** `domain/src/theming/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum ThemingError {
            #[error("Invalid theming configuration: {0}")]
            InvalidConfiguration(String),
        
            #[error("Wallpaper not found at path: {0:?}")]
            WallpaperNotFound(std::path::PathBuf),
        
            #[error("Failed to apply theme '{theme_name}': {details}")]
            ThemeApplyFailed {
                theme_name: String,
                details: String,
                #[source]
                source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
            },
        
            #[error("Persistence error during theming operation")]
            PersistenceError(#[from] crate::core::errors::CoreError), // Assuming CoreError is accessible
        
            #[error("Underlying system service error for theming: {0}")]
            SystemServiceError(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuell im System angewandten und zwischengespeicherten Theme-Zustand ab.
    - **Vorbedingungen:** Keine.
    - **Nachbedingungen:** Gibt den `AppliedThemeState` zurück oder einen `ThemingError`.
- `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert die Theme-Konfiguration, persistiert sie und stößt die Anwendung des neuen Themes an.
    - **Vorbedingungen:** `new_config` muss valide sein (ggf. interne Validierung).
    - **Nachbedingungen:** Bei Erfolg wird das `ThemeChangedEvent` publiziert. Die Konfiguration wird persistiert (z.B. über `GlobalSettingsService` oder ein dediziertes Persistenz-Interface). Das System-Theme wird (versucht) anzuwenden.
    - **Geschäftsregeln:** Validiert die `new_config`. Löst das Hintergrundbild auf.
- `async fn apply_theme_to_system(&self, theme_state: &AppliedThemeState) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** (Potenziell intern, aufgerufen von `update_configuration`, oder als separate Methode für fortgeschrittene Nutzung) Wendet den gegebenen `AppliedThemeState` auf die Systemkomponenten an (z.B. Setzen von GTK-Theme, Icons, Cursor über Systemmechanismen).
    - **Vorbedingungen:** `theme_state` ist valide.
    - **Nachbedingungen:** Theme-Änderungen sind im System (versucht) aktiv.

##### Publizierte Events:

- **`ThemeChangedEvent`:**
    - **Datei:** `domain/src/theming/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct ThemeChangedEvent {
            pub new_state: AppliedThemeState,
            pub old_state: Option<AppliedThemeState>, // Optional, falls der vorherige Zustand bekannt ist
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::theming::ThemeChangedEvent`
    - **Typische Publisher:** Die Implementierung von `ThemingEngine`.
    - **Typische Subscriber:** `ui::theming_gtk` (UI-Schicht), `system::compositor` (Systemschicht, falls relevant für Darstellung).

#### 2.1.2. `domain::workspaces::WorkspaceManager` Trait

Verwaltet Workspaces (virtuelle Desktops).

- **Datei:** `domain/src/workspaces/manager.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`WorkspaceId` Typalias:**
    
    - **Datei:** `domain/src/workspaces/types.rs` (oder direkt in `manager.rs`)
    - **Definition:** `pub type WorkspaceId = core::types::Uuid;`
- **`ApplicationIdentifier` Struct (Wertobjekt):**
    
    - Identifiziert eine Anwendung eindeutig.
    - **Datei:** `domain/src/workspaces/app_id.rs`
    - **Felder:**
        - `id_type: ApplicationIdType` (Enum: `DesktopFile`, `WaylandAppId`, `X11WindowClass`)
        - `identifier_str: String` (z.B. "firefox.desktop", "org.gnome.Nautilus", "Firefox")
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`Workspace` Struct (Entität):**
    
    - Repräsentiert einen einzelnen Workspace.
    - **Datei:** `domain/src/workspaces/workspace.rs`
    - **Felder:**
        - `id: WorkspaceId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `name: String` (Sichtbarkeit: `pub`)
        - `output_name: Option<String>` (Name des Monitors, dem der Workspace primär zugeordnet ist, Sichtbarkeit: `pub`)
        - `layout_policy: WorkspaceLayoutPolicy` (Enum: `Tiling`, `Floating`, `Hybrid`, Sichtbarkeit: `pub`)
        - `pinned_applications: std::collections::HashSet<ApplicationIdentifier>` (Sichtbarkeit: `pub(crate)`, Zugriff über Methoden)
        - `creation_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `last_accessed_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
    - **Initialwerte:** `id` wird bei Erstellung generiert, `name` z.B. "Workspace 1", `output_name` ist `None`, `layout_policy` wird aus globalen Einstellungen übernommen oder ist Standard (`Floating`), `pinned_applications` ist leer, `creation_timestamp` und `last_accessed_timestamp` sind Zeitpunkte der Erstellung.
    - **Invarianten:** `name` darf nicht leer sein. `id` ist unveränderlich nach Erstellung.
    - **Methoden (Beispiele):**
        - `pub fn new(name: String, layout_policy: WorkspaceLayoutPolicy) -> Self`
        - `pub fn id(&self) -> WorkspaceId`
        - `pub fn add_pinned_app(&mut self, app_id: ApplicationIdentifier) -> bool`
        - `pub fn remove_pinned_app(&mut self, app_id: &ApplicationIdentifier) -> bool`
        - `pub fn is_app_pinned(&self, app_id: &ApplicationIdentifier) -> bool`
        - `pub(crate) fn set_last_accessed(&mut self)`
    - **Beziehungen:** Keine direkten Entitätsbeziehungen in dieser Struktur, aber `pinned_applications` verweist auf `ApplicationIdentifier`.
- **`WorkspaceLayoutPolicy` Enum (Wertobjekt):**
    
    - **Datei:** `domain/src/workspaces/types.rs`
    - **Varianten:** `Tiling`, `Floating`, `Hybrid`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`WorkspaceManagerError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/workspaces/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum WorkspaceManagerError {
            #
            WorkspaceNotFound(super::types::WorkspaceId), // super::types::WorkspaceId
        
            #[error("Workspace with name '{0}' already exists")]
            DuplicateWorkspaceName(String),
        
            #[error("Maximum number of workspaces reached ({0})")]
            MaxWorkspacesReached(usize),
        
            #[error("Cannot delete the last workspace")]
            CannotDeleteLastWorkspace,
        
            #[error("Cannot delete active workspace; switch to another first")]
            CannotDeleteActiveWorkspace,
        
            #[error("Persistence error during workspace operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Invalid application identifier: {0}")]
            InvalidApplicationId(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn create_workspace(&self, name: Option<String>) -> Result<Workspace, WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Erstellt einen neuen Workspace. Wenn `name` `None` ist, wird ein Standardname generiert (z.B. "Workspace N").
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Created` publiziert. Der neue Workspace wird persistiert.
    - **Geschäftsregeln:** Prüft auf Namenskonflikte und maximale Anzahl von Workspaces.
- `async fn delete_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löscht den Workspace mit der gegebenen ID.
    - **Vorbedingungen:** Workspace darf nicht der letzte verbleibende sein. Workspace darf nicht der aktive sein (oder es muss eine Logik zum Wechsel des aktiven Workspaces implementiert sein).
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Deleted` publiziert. Änderungen werden persistiert.
- `async fn get_workspace_by_id(&self, id: WorkspaceId) -> Result<Option<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn get_all_workspaces(&self) -> Result<Vec<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** Der Workspace mit `id` muss existieren.
    - **Nachbedingungen:** `WorkspaceEvent::ActiveChanged` wird publiziert. Der `last_accessed_timestamp` des neuen und ggf. des alten aktiven Workspaces wird aktualisiert.
- `async fn get_active_workspace_id(&self) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** `new_name` darf nicht leer sein und nicht mit einem existierenden Workspace-Namen (außer dem eigenen) kollidieren.
    - **Nachbedingungen:** `WorkspaceEvent::Renamed` wird publiziert. Änderung wird persistiert.
- `async fn pin_application_to_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppPinned` wird publiziert. Änderung wird persistiert.
- `async fn unpin_application_from_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppUnpinned` wird publiziert. Änderung wird persistiert.
- `async fn move_window_to_workspace(&self, window_identifier: String /* Eindeutiger Fenster-Identifikator, z.B. Wayland Surface ID als String */, target_workspace_id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Fordert an, ein Fenster zum Ziel-Workspace zu verschieben. Die eigentliche Fensterverschiebung erfolgt in der Systemschicht.
    - **Nachbedingungen:** `WorkspaceEvent::WindowMoved` wird publiziert.

##### Publizierte Events:

- **`WorkspaceEvent` Enum:**
    - **Datei:** `domain/src/workspaces/events.rs`
    - **Varianten (Beispiele):**
        - `Created { workspace: Workspace }`
        - `Deleted { workspace_id: WorkspaceId, new_active_workspace_id: Option<WorkspaceId> }`
        - `ActiveChanged { old_id: Option<WorkspaceId>, new_id: WorkspaceId }`
        - `Renamed { workspace_id: WorkspaceId, new_name: String }`
        - `AppPinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `AppUnpinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `LayoutPolicyChanged { workspace_id: WorkspaceId, new_policy: WorkspaceLayoutPolicy }`
        - `WindowMoved { window_identifier: String, source_workspace_id: Option<WorkspaceId>, target_workspace_id: WorkspaceId }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::workspaces::WorkspaceEvent`
    - **Typische Publisher:** Die Implementierung von `WorkspaceManager`.
    - **Typische Subscriber:** `ui::shell` (UI-Schicht), `system::compositor` (Systemschicht).

#### 2.1.3. `domain::user_centric_services::AIInteractionLogicService` Trait

Steuert die Logik für Benutzerinteraktionen mit KI-Diensten, inklusive Einwilligungsmanagement.

- **Datei:** `domain/src/user_centric_services/ai_logic.rs`
- Diese Service-Schnittstelle ist entscheidend für die sichere und transparente Integration von KI-Funktionen. Die Trennung der Einwilligungslogik von der reinen MCP-Kommunikation (die in der Systemschicht angesiedelt ist) ist ein wichtiger Aspekt für Datenschutz und Benutzerkontrolle.

##### Zugehörige Datenstrukturen und Typen:

- **`AIInteractionContextData` Struct (Wertobjekt):**
    
    - Sammelt Kontextinformationen für eine KI-Anfrage.
    - **Datei:** `domain/src/user_centric_services/ai_context.rs`
    - **Felder:**
        - `active_window_title: Option<String>`
        - `active_app_id: Option<super::workspaces::app_id::ApplicationIdentifier>` // Pfad anpassen
        - `current_workspace_id: Option<super::workspaces::types::WorkspaceId>` // Pfad anpassen
        - `selected_text: Option<String>`
        - `clipboard_content_preview: Option<String>` (Vorschau, nicht der volle Inhalt)
        - `screenshot_data_uri: Option<String>` (Data-URI eines Screenshots, falls relevant)
        - `user_query: String` (Die eigentliche Anfrage des Benutzers)
        - `interaction_id: core::types::Uuid` (Eindeutige ID für diese Interaktion)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIConsent` Enum (Wertobjekt):**
    
    - Repräsentiert den Einwilligungsstatus des Benutzers für KI-Interaktionen.
    - **Datei:** `domain/src/user_centric_services/ai_consent.rs`
    - **Varianten:**
        - `Granted { for_session: bool, timestamp: core::types::DateTime<core::types::Utc> }` (Einwilligung für die aktuelle Sitzung oder dauerhaft)
        - `Denied { timestamp: core::types::DateTime<core::types::Utc> }`
        - `NotSet`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionResponse` Struct (Wertobjekt):**
    
    - Repräsentiert die Antwort von einem KI-Dienst.
    - **Datei:** `domain/src/user_centric_services/ai_response.rs`
    - **Felder:**
        - `interaction_id: core::types::Uuid`
        - `response_text: Option<String>`
        - `suggested_actions: Vec<String>`
        - `tool_call_id: Option<String>` (Falls ein Tool vom MCP-Server aufgerufen wurde)
        - `tool_call_result: Option<serde_json::Value>` (Ergebnis des Tool-Aufrufs)
        - `error_message: Option<String>`
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/ai_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum AIInteractionError {
            #[error("User consent not given for AI interaction")]
            ConsentNotGiven,
        
            #[error("MCP client error: {0}")]
            MCPError(String), // Wird von SystemMcpService kommen
        
            #[error("Failed to prepare context for AI interaction: {0}")]
            ContextPreparationFailed(String),
        
            #[error("AI service returned an error: {0}")]
            AIServiceError(String),
        
            #[error("Persistence error during AI consent operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #
            InteractionNotFoundOrTimedOut(crate::core::types::Uuid),
        }
        ```
        

##### Methoden des Traits:

- `async fn initiate_interaction(&self, context_data: AIInteractionContextData) -> Result<core::types::Uuid /* interaction_id */, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Startet eine neue KI-Interaktion. Prüft die Einwilligung und leitet die Anfrage ggf. an den `SystemMcpService` weiter. Gibt eine `interaction_id` zurück, um die Antwort später zu korrelieren.
    - **Vorbedingungen:** `get_consent_status()` darf nicht `Denied` sein. Wenn `NotSet`, wird die Interaktion ggf. pausiert und ein `AIConsentRequestEvent` ausgelöst.
    - **Nachbedingungen:** `AIInteractionStartedEvent` wird publiziert.
    - **Geschäftsregeln:** Die Logik hier muss entscheiden, ob basierend auf `context_data` und `AIConsent` die Interaktion fortgesetzt, abgelehnt oder eine erneute Einwilligung angefordert wird.
- `async fn provide_consent(&self, consent: AIConsent) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Speichert die Benutzereinwilligung.
    - **Nachbedingungen:** `AIConsentChangedEvent` wird publiziert. Der Einwilligungsstatus wird persistiert.
- `async fn get_consent_status(&self) -> Result<AIConsent, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuellen Einwilligungsstatus ab.
- `async fn process_mcp_response(&self, interaction_id: core::types::Uuid, response: Result<serde_json::Value, String> /* MCP Tool Call Result oder Fehler */) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Verarbeitet eine asynchrone Antwort vom `SystemMcpService` (typischerweise ein Tool-Aufruf-Ergebnis).
    - **Nachbedingungen:** `AIInteractionCompletedEvent` oder `AIInteractionFailedEvent` wird publiziert.

##### Publizierte Events:

- **`AIConsentChangedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct AIConsentChangedEvent { pub new_status: AIConsent; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentChangedEvent`
- **`AIInteractionStartedEvent`:**
    - **Struktur:** `pub struct AIInteractionStartedEvent { pub interaction_id: core::types::Uuid, pub context: AIInteractionContextData; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionStartedEvent`
- **`AIInteractionCompletedEvent`:**
    - **Struktur:** `pub struct AIInteractionCompletedEvent { pub response: AIInteractionResponse; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionCompletedEvent`
- **`AIInteractionFailedEvent`:**
    - **Struktur:** `pub struct AIInteractionFailedEvent { pub interaction_id: core::types::Uuid, pub error: AIInteractionError; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionFailedEvent`
- **`AIConsentRequestEvent`:** (Falls die UI den Benutzer zur Einwilligung auffordern soll)
    - **Struktur:** `pub struct AIConsentRequestEvent { pub interaction_id: core::types::Uuid, pub for_context: AIInteractionContextData }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentRequestEvent`
- **Typische Publisher:** Die Implementierung von `AIInteractionLogicService`.
- **Typische Subscriber:** `ui::command_palette` oder KI-Widgets (UI-Schicht), `system::mcp::SystemMcpService` (Systemschicht, für Antworten).

#### 2.1.4. `domain::user_centric_services::NotificationService` Trait

Verwaltet das Anzeigen und Interagieren mit Desktop-Benachrichtigungen.

- **Datei:** `domain/src/user_centric_services/notification_service.rs`
- Die Parameter für `post_notification` spiegeln eng die D-Bus-Methode `org.freedesktop.Notifications.Notify` wider.9 Dieser Dienst fungiert als Abstraktion über potenzielle D-Bus-Implementierungen in der Systemschicht. Die Domänenschicht definiert das _Konzept_ einer Benachrichtigung innerhalb von NovaDE. Die Systemschicht wäre dann dafür verantwortlich, diese Benachrichtigung tatsächlich über D-Bus zu senden, wenn NovaDE als Benachrichtigungsserver fungiert, oder auf D-Bus-Benachrichtigungen zu lauschen, wenn es diese konsumiert. Die Verwendung von `zvariant::OwnedValue` für `hints` deutet auf eine direkte Abbildung auf D-Bus-Varianten hin.

##### Zugehörige Datenstrukturen und Typen:

- **`NotificationId` Typalias:**
    
    - **Datei:** `domain/src/user_centric_services/types.rs` (oder direkt in `notification_service.rs`)
    - **Definition:** `pub type NotificationId = core::types::Uuid;`
- **`NotificationAction` Struct (Wertobjekt):**
    
    - Definiert eine Aktion, die mit einer Benachrichtigung verbunden ist.
    - **Datei:** `domain/src/user_centric_services/notification_action.rs`
    - **Felder:**
        - `key: String` (Eindeutiger Schlüssel für die Aktion, z.B. "default", "reply")
        - `label: String` (Anzeigetext für den Button)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationUrgency` Enum (Wertobjekt):**
    
    - Definiert die Dringlichkeitsstufe einer Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Low`, `Normal`, `Critical`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`Notification` Struct (Entität):**
    
    - Repräsentiert eine einzelne Desktop-Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/notification.rs`
    - **Felder:**
        - `id: NotificationId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `app_name: String` (Sichtbarkeit: `pub`)
        - `replaces_id: Option<NotificationId>` (Sichtbarkeit: `pub`)
        - `app_icon: Option<String>` (Pfad oder Name des Icons, Sichtbarkeit: `pub`)
        - `summary: String` (Kurze Zusammenfassung, Sichtbarkeit: `pub`)
        - `body: Option<String>` (Detaillierter Text, Sichtbarkeit: `pub`)
        - `actions: Vec<NotificationAction>` (Sichtbarkeit: `pub`)
        - `hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>` (Spezifische Hinweise für den Notification-Server, Sichtbarkeit: `pub`)
        - `expire_timeout_ms: i32` (-1 für Server-Default, 0 für nie, >0 für Millisekunden, Sichtbarkeit: `pub`)
        - `urgency: NotificationUrgency` (Sichtbarkeit: `pub`)
        - `timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `is_displayed: std::sync::atomic::AtomicBool` (Interner Status, ob die Benachrichtigung aktuell angezeigt wird)
    - **Initialwerte:** `id` wird generiert, `timestamp` ist aktuell, `is_displayed` ist `false`.
    - **Invarianten:** `summary` darf nicht leer sein. `id` ist unveränderlich.
    - **Methoden (Beispiele):**
        - `pub fn id(&self) -> NotificationId`
        - `pub(crate) fn mark_as_displayed(&self)`
        - `pub(crate) fn mark_as_closed(&self)`
- **`CloseReason` Enum (Wertobjekt):**
    
    - Gibt den Grund an, warum eine Benachrichtigung geschlossen wurde.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Expired`, `DismissedByUser`, `ClosedByApp`, `ServiceShutdown`, `Unknown`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/notification_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum NotificationError {
            #
            NotificationNotFound(super::types::NotificationId), // Pfad anpassen
        
            #[error("Invalid notification format or content: {0}")]
            InvalidNotificationFormat(String),
        
            #[error("Failed to invoke action '{action_key}' for notification {notification_id}: {reason}")]
            ActionInvokeFailed {
                notification_id: super::types::NotificationId, // Pfad anpassen
                action_key: String,
                reason: String,
            },
        
            #[error("Notification service is unavailable or failed: {0}")]
            ServiceUnavailable(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn post_notification(&self, app_name: String, replaces_id: Option<NotificationId>, app_icon: Option<String>, summary: String, body: Option<String>, actions: Vec<NotificationAction>, hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>, expire_timeout_ms: i32, urgency: NotificationUrgency) -> Result<NotificationId, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Sendet eine neue Benachrichtigung oder aktualisiert eine existierende.
    - **Nachbedingungen:** Bei Erfolg wird `NotificationPostedEvent` publiziert. Die Benachrichtigung wird (versucht) dem Benutzer angezeigt.
- `async fn get_active_notifications(&self) -> Result<Vec<Notification>, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Liste aller aktuell aktiven (angezeigten) Benachrichtigungen ab.
- `async fn close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Schließt eine spezifische Benachrichtigung.
    - **Vorbedingungen:** Benachrichtigung mit `id` muss existieren und aktiv sein.
    - **Nachbedingungen:** `NotificationClosedEvent` wird publiziert.
- `async fn invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löst eine mit einer Benachrichtigung verbundene Aktion aus.
    - **Vorbedingungen:** Benachrichtigung mit `id` und Aktion mit `action_key` müssen existieren.
    - **Nachbedingungen:** `NotificationActionInvokedEvent` wird publiziert.

##### Publizierte Events:

- **`NotificationPostedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct NotificationPostedEvent { pub notification: Notification; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationPostedEvent`
- **`NotificationClosedEvent`:**
    - **Struktur:** `pub struct NotificationClosedEvent { pub id: NotificationId, pub reason: CloseReason; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationClosedEvent`
- **`NotificationActionInvokedEvent`:**
    - **Struktur:** `pub struct NotificationActionInvokedEvent { pub id: NotificationId, pub action_key: String; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationActionInvokedEvent`
- **Typische Publisher:** Die Implementierung von `NotificationService`.
- **Typische Subscriber:** `ui::notifications_frontend` oder `ui::shell` (UI-Schicht), `system::dbus::notification_server` (Systemschicht, falls NovaDE als Server agiert und die Events intern weiterleitet).

#### 2.1.5. `domain::global_settings_and_state_management::GlobalSettingsService` Trait

Verwaltet globale Desktop-Einstellungen und deren Persistenz.

- **Datei:** `domain/src/global_settings/service.rs`
- Dieser Dienst bietet eine strukturierte Methode zur Verwaltung einer Vielzahl von Desktop-Einstellungen. Der Persistenzmechanismus (z.B. eine Implementierung von `domain::settings_persistence_iface`, wie in der Kernschichtspezifikation erwähnt) ist hier von entscheidender Bedeutung.

##### Zugehörige Datenstrukturen und Typen:

- **`SettingPath` Typalias:**
    
    - **Datei:** `domain/src/global_settings/types.rs`
    - **Definition:** `pub type SettingPath = String;` (z.B. "desktop.background.color", "keyboard.layouts.0.name")
- **`SettingValue` Enum (Wertobjekt):**
    
    - Repräsentiert den Wert einer Einstellung. Kann verschiedene primitive Typen und verschachtelte Strukturen annehmen.
    - **Datei:** `domain/src/global_settings/value.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        #[serde(untagged)] // Für flexible (De-)Serialisierung
        pub enum SettingValue {
            String(String),
            Integer(i64),
            Float(f64),
            Boolean(bool),
            List(Vec<SettingValue>),
            Map(std::collections::HashMap<String, SettingValue>),
            Null, // Um das Fehlen eines Wertes explizit darzustellen
        }
        // Implement From<T> for SettingValue für gängige Typen
        ```
        
    - Die Verwendung von `serde_json::Value` wäre eine Alternative für maximale Flexibilität, aber ein eigenes Enum bietet mehr Typsicherheit innerhalb der Domäne.
- **`GlobalDesktopSettings` Struct (Entität):**
    
    - Repräsentiert die Gesamtheit aller verwalteten Einstellungen.
    - **Datei:** `domain/src/global_settings/settings_struct.rs`
    - **Felder:**
        - `settings: std::collections::BTreeMap<SettingPath, SettingValue>` (BTreeMap für geordnete Iteration/Serialisierung, falls gewünscht)
    - **Sichtbarkeit:** `pub(crate)` für `settings`, Zugriff über Methoden.
    - **Methoden (Beispiele):**
        - `pub fn get(&self, path: &SettingPath) -> Option<&SettingValue>`
        - `pub fn set(&mut self, path: SettingPath, value: SettingValue) -> Option<SettingValue>` (gibt alten Wert zurück)
        - `pub fn remove(&mut self, path: &SettingPath) -> Option<SettingValue>`
- **`GlobalSettingsError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/global_settings/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum GlobalSettingsError {
            #
            SettingNotFound(super::types::SettingPath), // Pfad anpassen
        
            #
            TypeMismatch {
                path: super::types::SettingPath, // Pfad anpassen
                expected_type: String,
                found_type: String,
            },
        
            #[error("Persistence error during settings operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Validation error for setting '{path}': {message}")]
            ValidationError {
                path: super::types::SettingPath, // Pfad anpassen
                message: String,
            },
        
            #[error("Invalid setting path format: {0}")]
            InvalidPathFormat(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn load_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Lädt alle Einstellungen aus der Persistenzschicht.
    - **Nachbedingungen:** Gibt die geladenen `GlobalDesktopSettings` zurück oder einen Fehler.
- `async fn save_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Persistiert den gesamten Einstellungsbaum.
- `async fn get_setting(&self, path: &SettingPath) -> Result<Option<SettingValue>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den Wert einer spezifischen Einstellung ab.
- `async fn update_setting(&self, path: SettingPath, value: SettingValue) -> Result<Option<SettingValue /* old_value */>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert eine spezifische Einstellung und persistiert die Änderung. Gibt den alten Wert zurück, falls vorhanden.
    - **Vorbedingungen:** `path` und `value` müssen validen Formaten entsprechen. Ggf. Validierung gegen ein Schema.
    - **Nachbedingungen:** Bei Erfolg wird `SettingChangedEvent` publiziert. Die Einstellung wird persistiert.
- `async fn get_all_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Kopie aller aktuellen Einstellungen ab.

##### Publizierte Events:

- **`SettingChangedEvent`:**
    - **Datei:** `domain/src/global_settings/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct SettingChangedEvent {
            pub path: SettingPath,
            pub old_value: Option<SettingValue>,
            pub new_value: SettingValue,
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::global_settings::SettingChangedEvent`
- **Typische Publisher:** Die Implementierung von `GlobalSettingsService`.
- **Typische Subscriber:** `ui::control_center` (UI-Schicht), verschiedene Systemkomponenten, die auf Einstellungsänderungen reagieren müssen.

### 2.2. Datenstrukturen (Öffentlich)

Zusätzlich zu den direkt mit Service-APIs assoziierten Strukturen können weitere öffentliche Datenstrukturen existieren, die Zustände oder Konfigurationen repräsentieren und von mehreren Modulen oder Schichten verwendet werden.

- **Beispiele:** Viele der oben bereits definierten Strukturen fallen in diese Kategorie, z.B. `AppliedThemeState`, `Workspace`, `Notification`, `GlobalDesktopSettings`, `ThemingConfiguration`, `ApplicationIdentifier`, `AIInteractionContextData`, `AIConsent`, `SettingValue`.
- **Implementierungsrichtlinien:**
    - Jede Struktur/Enum in einer eigenen Datei innerhalb des relevanten Domänenmoduls (z.B. `domain/src/theming/state.rs`).
    - Ableitung von `Debug`, `Clone`, `PartialEq` ist Standard.
    - Ableitung von `serde::Serialize`, `serde::Deserialize` falls Persistenz oder IPC-Übertragung erforderlich ist.
    - Felder sollten `pub` sein, wenn sie direkt von extern gelesen werden sollen, oder `pub(crate)` mit öffentlichen Gettern/Settern für kontrollierten Zugriff.
    - Invarianten sollten durch Konstruktoren und Methoden sichergestellt werden.
    - Beziehungen zu anderen Entitäten/Wertobjekten sollten klar definiert sein (z.B. durch Komposition oder IDs).

### 2.3. Events (Domänenspezifisch)

Domänenspezifische Events signalisieren wichtige Zustandsänderungen innerhalb der Domänenschicht. Sie sind entscheidend für eine reaktive Architektur und lose Kopplung.

- **Beispiele:** Die bereits bei den Services definierten Events (`ThemeChangedEvent`, `WorkspaceEvent`, `NotificationPostedEvent`, `SettingChangedEvent`, `AIConsentChangedEvent`, etc.).
- **Struktur:**
    - Jedes Event sollte als eigene Struktur oder als Variante eines umfassenderen Event-Enums (pro Modul) definiert werden.
    - Die Event-Struktur enthält alle relevanten Daten zur Zustandsänderung.
    - Beispiel: `pub struct ActiveWorkspaceChanged { pub old_id: Option<WorkspaceId>, pub new_id: WorkspaceId }`
- **Eindeutiger Event-Name/Typ:** Eine klare Namenskonvention ist wichtig, z.B. `nova_de::domain::module::EventName`.
- **Publisher:** Die jeweilige Service-Implementierung, die die Zustandsänderung verursacht.
- **Subscriber:** Komponenten in der System- und UI-Schicht, die auf diese Änderungen reagieren müssen.
    - Beispiel: `ui::theming_gtk` abonniert `ThemeChangedEvent`.
    - Beispiel: `system::compositor` abonniert `ActiveWorkspaceChanged`.
- **Datei-Struktur:** Events können in einer `events.rs`-Datei innerhalb jedes Domänenmoduls definiert werden (z.B. `domain/src/theming/events.rs`).
- **Serialisierung:** Wenn Events über IPC-Grenzen (z.B. D-Bus) gesendet werden sollen, müssen sie `serde::Serialize` und `serde::Deserialize` implementieren.

### 2.4. Fehlertypen (Modulspezifisch)

Jedes Hauptmodul innerhalb der Domänenschicht sollte seine eigenen spezifischen Fehler-Enums definieren, um präzise Fehlerinformationen zu liefern.

- **Beispiele:** Die bereits bei den Services definierten Fehler (`ThemingError`, `WorkspaceManagerError`, `AIInteractionError`, `NotificationError`, `GlobalSettingsError`).
- **Implementierungsrichtlinien:**
    - Verwendung des `thiserror`-Crates für eine ergonomische Definition.
    - Jeder Fehlertyp in einer eigenen Datei (z.B. `domain/src/theming/error.rs`).
    - Fehlervarianten sollten klare und spezifische Fehlerzustände des Moduls beschreiben.
    - Wo sinnvoll, sollten Quellfehler (`#[source]`) oder Konvertierungen (`#[from]`) für Fehler aus der Kernschicht oder anderen Abhängigkeiten bereitgestellt werden, um die Fehlerkette zu erhalten.
- **Verwendung:** Domänenservices geben diese spezifischen Fehler in ihren `Result`-Typen zurück. Die System- und UI-Schicht behandeln diese Fehler oder leiten sie ggf. weiter, eventuell gewrappt in ihre eigenen, allgemeineren Fehlertypen.

---

## 3. Schicht: Systemschicht (System Layer)

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um. Sie interagiert direkt mit dem Betriebssystem, der Hardware (über Abstraktionen wie DRM/GBM, libinput), Systemdiensten (via D-Bus, PipeWire) und dem Wayland-Compositor-Backend (Smithay). Sie konsumiert APIs der Domänenschicht, um Geschäftslogik anzuwenden und Zustände abzufragen.

Diese Schicht ist die Brücke zwischen der abstrakten Domänenlogik von NovaDE und den konkreten Realitäten des Betriebssystems und der Hardware. Hier finden viele der FFI-Aufrufe, IPC-Kommunikation und Interaktionen auf niedriger Ebene statt. Smithay wird intensiv für Wayland-bezogene Komponenten genutzt. Eine robuste Fehlerbehandlung ist entscheidend, um Fehler von niedriger Ebene in abstraktere `SystemError`-Typen oder spezifische Unterfehler zu übersetzen. Die asynchrone Natur vieler Operationen (IPC, Hardwareinteraktion) ist hier kritisch.

### 3.1. Modul: `system::compositor` (Smithay-basierter Wayland Compositor Kern)

Dieses Modul ist das Herzstück der grafischen Darstellung und Fensterverwaltung in NovaDE. Es basiert auf der Smithay-Bibliothek und implementiert die Kernfunktionalitäten eines Wayland-Compositors.

- **Abhängigkeiten:** `smithay`, `wayland-server`, `wayland-protocols`, `calloop`, `input` (libinput-rs), `drm-rs`, `gbm-rs`, `libloading` (für EGL).
- **Verzeichnis:** `system/src/compositor/`

#### 3.1.1. `NovaDeSystemState` Struktur (Hauptzustand für Smithay Handler)

Diese Struktur dient als zentraler Datenhalter für den Event-Loop und implementiert die verschiedenen Handler-Traits von Smithay.

- **Datei:** `system/src/state.rs` (oder `system/src/compositor/state.rs`, je nach Gesamtstruktur)
- **Felder (Beispiele, basierend auf typischer Smithay-Nutzung und NovaDE-Anforderungen):**
    
    Rust
    
    ```
    use smithay::{
        backend::{
            allocator::dmabuf::DmabufState, // [50]
            drm::DrmDeviceFd, // [19, 24, 56, 62, 69, 93, 305, 388]
            egl::{EGLContext, EGLDisplay}, // [16, 26, 62, 65, 94, 97]
            renderer::{
                gles::GlesRenderer, // [16, 40, 62, 94, 97]
                multigpu::{gbm::GbmGlesBackend, GpuManager}, // [24, 28, 40, 62, 97, 145, 222]
            },
            libinput::LibinputInputBackend, // [23, 75, 382]
            udev::{UdevBackend, UdevEvent}, // [37]
            session::{Session, Signal as SessionSignal, logind::LogindSession}, // [362, 391]
            input::Seat,
        },
        desktop::{Space, Window, PopupManager, layer_map_for_output, LayerSurface}, // [67]
        input::{SeatState, SeatHandler, pointer::PointerHandle, keyboard::KeyboardHandle, touch::TouchHandle, SeatName},
        output::Output,
        reexports::{
            calloop::{EventLoop, LoopHandle, LoopSignal},
            wayland_server::{Display, DisplayHandle, Client,backend::GlobalId},
            wayland_protocols::xdg::shell::server::xdg_wm_base,
        },
        utils::{Clock, Logical, Point, Rectangle, Serial, Transform, SERIAL_COUNTER},
        wayland::{
            buffer::BufferHandler, // [353]
            compositor::{CompositorState, CompositorHandler, CompositorClientState, SurfaceData}, // [17, 87, 99]
            dmabuf::DmabufHandler, // [50]
            output::{OutputHandler, OutputManagerState}, // [49, 147, 280, 370, 372, 392]
            presentation::PresentationState, // [274]
            seat::WaylandSeatData,
            shell::{
                xdg::{XdgShellState, XdgShellHandler, XdgShellSurfaceUserData, XdgWmBaseUserData, decoration::XdgDecorationState}, // [13, 31, 54, 81, 167, 176, 191, 195, 199, 204, 207, 208, 215, 223, 224, 225, 227, 317, 323, 336, 349, 350, 393, 394, 395, 396, 397, 398, 399, 400]
                wlr_layer::{WlrLayerShellState, LayerShellHandler, LayerSurfaceData}, // [11, 19, 20, 41, 48, 57, 66, 67, 71, 91, 92, 95, 160, 192, 254, 292, 307, 318, 347, 401, 402]
            },
            shm::{ShmState, ShmHandler}, // [141, 165]
            selection::{
                data_device::{DataDeviceState, DataDeviceHandler}, // [11, 12, 19, 35, 44, 45, 73, 80, 141, 216, 403, 404, 405, 406]
                primary_selection::{PrimarySelectionState, PrimarySelectionHandler}, // [30, 120]
            },
            input_method::{InputMethodManagerState, InputMethodHandler, InputMethodKeyboardUserData}, // [11, 34, 35, 117, 253, 264, 268, 407, 408, 409, 410, 411]
            text_input::{TextInputManagerState, TextInputHandler, TextInputUserData}, // [86, 112, 328, 412, 413, 414]
            viewporter::ViewporterState, // [371]
            xdg_activation::XdgActivationState, // [303]
            foreign_toplevel::ForeignToplevelState, // [335]
            idle_notify::IdleNotifierState, // [58]
            explicit_synchronization::ExplicitSyncState, // [415]
            drm_lease::DrmLeaseState, // [107]
            server_decoration::ServerDecorationManagerState, // [297]
        },
        xwayland::{XWayland, XWaylandEvent, XWaylandClientData, xwm::{X11Wm, XwmHandler, X11Surface}}, // [11, 14, 19, 21, 32, 35, 36, 41, 43, 52, 60, 76, 78, 85, 117, 141, 219, 270, 310, 329, 339, 361, 363, 377, 416, 417]
    };
    use std::{collections::HashMap, sync::{Arc, Mutex}};
    use crate::system::dbus::DBusConnectionManager; // Für D-Bus Interaktionen
    use crate::system::audio::PipeWireClientService; // Für PipeWire
    use crate::domain::services::DomainLayerServices; // Wrapper für Domain-Service-Handles
    
    pub struct NovaDeSystemState {
        pub display_handle: DisplayHandle,
        pub event_loop_handle: LoopHandle<'static, Self>,
        pub loop_signal: LoopSignal,
        pub clock: Clock, // Für Timings, Animationen
    
        // Core Wayland protocol states
        pub compositor_state: Arc<Mutex<CompositorState>>,
        pub shm_state: Arc<Mutex<ShmState>>,
        pub output_manager_state: Arc<Mutex<OutputManagerState>>,
        pub seat_state: Arc<Mutex<SeatState<Self>>>,
        pub data_device_state: Arc<Mutex<DataDeviceState>>,
        pub primary_selection_state: Arc<Mutex<PrimarySelectionState>>,
    
        // Shells
        pub xdg_shell_state: Arc<Mutex<XdgShellState>>,
        pub layer_shell_state: Arc<Mutex<WlrLayerShellState>>,
        pub xdg_decoration_state: Arc<Mutex<XdgDecorationState>>,
        // Optional: xwayland_shell_state if using Smithay's xwayland shell helpers
    
        // Input related
        pub text_input_manager_state: Arc<Mutex<TextInputManagerState>>,
        pub input_method_manager_state: Arc<Mutex<InputMethodManagerState>>,
    
        // Optional Wayland protocol states
        pub presentation_time_state: Option<Arc<Mutex<PresentationState>>>,
        pub viewporter_state: Option<Arc<Mutex<ViewporterState>>>,
        pub xdg_activation_state: Option<Arc<Mutex<XdgActivationState>>>,
        pub foreign_toplevel_state: Option<Arc<Mutex<ForeignToplevelState>>>,
        pub idle_notifier_state: Option<Arc<Mutex<IdleNotifierState<Self>>>>,
        pub explicit_sync_state: Option<Arc<Mutex<ExplicitSyncState>>>,
        pub drm_lease_state: Option<Arc<Mutex<DrmLeaseState>>>,
        pub server_decoration_manager_state: Option<Arc<Mutex<ServerDecorationManagerState>>>,
    
        // Backend specific states
        pub udev_backend_data: Option<UdevBackendData>, // If using udev backend
        pub winit_data: Option<WinitData>, // If using winit backend
        pub x11_data: Option<X11BackendData>, // If using X11 backend (as a client)
    
        // XWayland
        pub xwayland: Option<XWayland>,
        pub xwm: Option<Arc<Mutex<X11Wm>>>, // X11 Window Manager for XWayland
        pub xwayland_client_data_id: Option<u32>, // To identify XWayland's client
    
        // Desktop management
        pub space: Arc<Mutex<Space<WindowElement>>>, // Manages windows and outputs
        pub popup_manager: Arc<Mutex<PopupManager>>,
    
        // Input devices
        pub seat_name: String,
        pub seat: Seat<Self>,
        pub pointer: PointerHandle<Self>,
        pub keyboard: KeyboardHandle<Self>,
        pub touch: Option<TouchHandle<Self>>, // Touch ist optional
    
        // Domain Layer Access
        pub domain_services: Arc<DomainLayerServices>,
    
        // System Services Clients
        pub dbus_conn_manager: Arc<DBusConnectionManager>,
        pub pipewire_service: Arc<PipeWireClientService>,
    
        // Internal state
        pub running: std::sync::atomic::AtomicBool,
        pub active_workspace_id: Option<crate::domain::workspaces::WorkspaceId>,
        // Weitere anwendungsspezifische Zustände
    }
    
    // Hilfsstrukturen für Backend-spezifische Daten
    pub struct UdevBackendData {
        pub session: LogindSession, // Oder eine andere Session-Implementierung
        pub gpus: GpuManager<GbmGlesBackend<GlesRenderer, DrmDeviceFd>>,
        pub primary_gpu: DrmDeviceFd,
        pub udev_backend: UdevBackend,
        // Weitere DRM/GBM/EGL spezifische Zustände
    }
    pub struct WinitData { /*... relevante Winit-Felder... */ }
    pub struct X11BackendData { /*... relevante X11-Backend-Felder... */ }
    
    // WindowElement (Beispiel, muss an NovaDE angepasst werden)
    #
    pub enum WindowElement {
        Wayland(Window), // Smithay's Window für XDG Toplevels
        X11(X11Surface), // Smithay's X11Surface
        Layer(LayerSurface), // Smithay's LayerSurface
    }
    // Implementiere notwendige Traits für WindowElement (z.B. RenderElement, SpaceElement)
    ```
    
    - Der Compositor ist das komplexeste Element der Systemschicht. Smithay 8 stellt Bausteine bereit, aber die eigentliche Fensterverwaltungslogik (Tiling, Stacking, Fokusrichtlinien basierend auf Domänenregeln) muss hier implementiert werden. Die `AnvilState` aus Smithays Anvil-Compositor dient als gute Referenz für die Strukturierung von `NovaDeSystemState` und die Integration verschiedener Smithay-Handler.

#### 3.1.2. Initialisierung (`system::compositor::initialize_compositor`)

- **Datei:** `system/src/compositor/init.rs`
- **Signatur:** `pub async fn initialize_compositor(domain_services: Arc<DomainLayerServices>, event_loop_handle: LoopHandle<'static, NovaDeSystemState>, loop_signal: LoopSignal) -> Result<NovaDeSystemState, SystemError>`
- **Schritte:**
    1. Erstelle `DisplayHandle` aus dem globalen `Display` Objekt (Annahme: `Display` wird im `main` erstellt und `DisplayHandle` wird hierher übergeben oder `NovaDeSystemState` wird direkt im `main` erstellt).
    2. Initialisiere Smithay-Backends (z.B. `LibinputInputBackend` 23, `UdevBackend` 37, DRM/GBM/EGL 16). Die Wahl des Backends (DRM/libseat für Bare-Metal, Winit/X11 für verschachtelte Entwicklung) ist eine wichtige architektonische Entscheidung. Die Implementierung sollte dies abstrahieren.
    3. Initialisiere alle relevanten Wayland-Globale unter Verwendung ihrer

---

# NovaDE Interner Schnittstellen-Implementierungsleitfaden

Dieser Implementierungsleitfaden definiert die ultrafeinen Spezifikationen und hochdetaillierten Implementierungspläne für jede Schicht der Linux-Desktop-Umgebung "NovaDE". Er ist so detailliert konzipiert, dass Entwickler ihn direkt zur Implementierung verwenden können, ohne eigene Entscheidungen treffen oder Logiken/Algorithmen entwerfen zu müssen.

---

## 1. Schicht: Kernschicht (Core Layer)

Die Kernschicht (Core Layer) bildet das Fundament von NovaDE und stellt grundlegende, universell einsetzbare Bausteine und Dienste bereit, die von allen darüberliegenden Schichten – der Domänenschicht, der Systemschicht und der Benutzeroberflächenschicht (UI-Schicht) – genutzt werden. Die Kommunikation mit höheren Schichten erfolgt durch die direkte Verwendung der hier definierten Typen und Funktionen.

### 1.1. Modul: `core::types`

Dieses Modul definiert grundlegende Datentypen, die systemweit für geometrische Berechnungen, Farbdarstellungen und andere fundamentale Konzepte verwendet werden.

- **Verzeichnis:** `core/src/types/`

#### 1.1.1. `Point<T>` Struktur

Stellt einen Punkt im 2D-Raum dar.

- Datei: `core/src/types/point.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Point<T, U> {
        pub x: T,
        pub y: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Point<T, U> {
        fn default() -> Self {
            Point { x: Default::default(), y: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    // U kann z.B. Logical, Physical, BufferCoords sein
    pub struct Logical;
    pub struct Physical;
    pub struct BufferCoords;
    
    impl<T, U> Point<T, U> {
        pub const fn new(x: T, y: T) -> Self {
            Point { x, y, _unit: std::marker::PhantomData }
        }
    }
    
    // Weitere Methoden wie Add, Sub, etc. können implementiert werden.
    ```
    
- Verwendung: Positionierung von UI-Elementen, Fensterkoordinaten.

#### 1.1.2. `Size<T>` Struktur

Stellt die Dimensionen (Breite und Höhe) eines 2D-Objekts dar.

- Datei: `core/src/types/size.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Size<T, U> {
        pub w: T,
        pub h: T,
        _unit: std::marker::PhantomData<U>,
    }
    
    impl<T: Default, U> Default for Size<T, U> {
        fn default() -> Self {
            Size { w: Default::default(), h: Default::default(), _unit: std::marker::PhantomData }
        }
    }
    
    impl<T, U> Size<T, U> {
        pub const fn new(w: T, h: T) -> Self {
            Size { w, h, _unit: std.marker::PhantomData }
        }
    }
    ```
    
- Verwendung: Fenstergrößen, UI-Element-Dimensionen.

#### 1.1.3. `Rect<T>` und `RectInt` Strukturen

Stellt ein Rechteck im 2D-Raum dar, definiert durch Position und Größe.

- Datei: `core/src/types/rect.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Rect<T, U> {
        pub loc: Point<T, U>,
        pub size: Size<T, U>,
    }
    
    impl<T: Default, U> Default for Rect<T, U> {
        fn default() -> Self {
            Rect { loc: Default::default(), size: Default::default() }
        }
    }
    
    impl<T, U> Rect<T, U> {
        pub const fn new(loc: Point<T, U>, size: Size<T, U>) -> Self {
            Rect { loc, size }
        }
        // Methoden wie contains_point, intersection, etc.
    }
    
    pub type RectInt = Rect<i32, Logical>; // Beispiel für einen häufigen Typ
    ```
    
- Verwendung: Fenstergeometrien, Auswahlbereiche.

#### 1.1.4. `Color` Struktur

Repräsentiert eine Farbe im RGBA-Format.

- Datei: `core/src/types/color.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct Color {
        pub r: f32, // Range 0.0 to 1.0
        pub g: f32, // Range 0.0 to 1.0
        pub b: f32, // Range 0.0 to 1.0
        pub a: f32, // Range 0.0 to 1.0 (alpha)
    }
    
    impl Color {
        pub const fn new(r: f32, g: f32, b: f32, a: f32) -> Self {
            Color { r, g, b, a }
        }
    
        pub fn to_hex_rgb(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8
            )
        }
    
        pub fn to_hex_rgba(&self) -> String {
            format!(
                "#{:02x}{:02x}{:02x}{:02x}",
                (self.r * 255.0) as u8,
                (self.g * 255.0) as u8,
                (self.b * 255.0) as u8,
                (self.a * 255.0) as u8
            )
        }
        // Ggf. From-Implementierungen für gängige Formate (z.B. String "#RRGGBB")
    }
    ```
    
- Verwendung: Theming, UI-Elementfarben.

#### 1.1.5. `Orientation` Enum

Definiert die Ausrichtung von UI-Elementen oder Layouts.

- Datei: `core/src/types/orientation.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub enum Orientation {
        Horizontal,
        Vertical,
    }
    ```
    
- Verwendung: Layout-Manager, Ausrichtung von Bedienelementen.

#### 1.1.6. `uuid::Uuid` Integration

Universell eindeutige Identifikatoren.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use uuid::Uuid;`
- Abhängigkeit in `core/Cargo.toml`: `uuid = { version = "1.0", features = ["v4", "serde"] }`
    - Die Features `v4` und `serde` sind essenziell. `v4` ermöglicht die Generierung zufälliger UUIDs, die für die eindeutige Identifizierung von Entitäten wie Fenstern, Workspaces oder Benachrichtigungen unerlässlich sind. `serde` wird benötigt, falls diese IDs in Konfigurationsdateien persistiert oder über IPC-Schnittstellen serialisiert werden müssen, was in einer Desktop-Umgebung sehr wahrscheinlich ist.1
- Verwendung: Eindeutige Identifizierung von Ressourcen systemweit.

#### 1.1.7. `chrono::DateTime<Utc>` Integration

Zeitstempel mit UTC-Zeitzone.

- Datei: `core/src/types/mod.rs` (als Re-Export)
- Re-Export: `pub use chrono::{DateTime, Utc};`
- Abhängigkeit in `core/Cargo.toml`: `chrono = { version = "0.4", features = ["serde"] }`
    - `chrono` ist der De-facto-Standard für Datums- und Zeitmanipulationen in Rust. Die Verwendung von `DateTime<Utc>` stellt zeitzonenagnostische Zeitstempel sicher, was für interne Repräsentationen als Best Practice gilt, um Komplexitäten bei der Zeitzonenbehandlung zu vermeiden. Das `serde`-Feature ist notwendig, wenn Zeitstempel persistiert (z.B. in Logdateien oder Konfigurationen) oder serialisiert werden sollen.3
- Verwendung: Zeitstempel für Logging, Events, "zuletzt geändert"-Informationen.

#### 1.1.8. Implementierungsschritte für `core::types`

1. Erstellen Sie das Verzeichnis `core/src/types/`.
2. Implementieren Sie `point.rs`, `size.rs`, `rect.rs`, `color.rs`, und `orientation.rs` gemäß den obigen Spezifikationen.
3. Fügen Sie `uuid` (mit Features "v4", "serde") und `chrono` (mit Feature "serde") zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
4. Fügen Sie die Re-Exports für `Uuid` und `DateTime<Utc>` in `core/src/types/mod.rs` hinzu. Alle lokalen Typen (Point, Size, etc.) sollten ebenfalls von `mod.rs` re-exportiert werden.
    
    Rust
    
    ```
    // core/src/types/mod.rs
    mod color;
    mod orientation;
    mod point;
    mod rect;
    mod size;
    
    pub use chrono::{DateTime, Utc};
    pub use color::Color;
    pub use orientation::Orientation;
    pub use point::{BufferCoords, Logical, Physical, Point};
    pub use rect::{Rect, RectInt};
    pub use size::Size;
    pub use uuid::Uuid;
    ```
    

### 1.2. Modul: `core::errors`

Dieses Modul stellt eine Basis-Fehlerbehandlungsstrategie und den `CoreError`-Typ bereit. Höhere Schichten können `CoreError` oder spezifischere Fehler aus Kernmodulen mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen wrappen, wobei die Fehlerursachenkette (`source()`) beibehalten wird.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/errors.rs`

#### 1.2.1. `CoreError` Enum

- Definition unter Verwendung von `thiserror`:
    
    Rust
    
    ```
    #
    pub enum CoreError {
        #[error("I/O error: {source}")]
        Io {
            #[from]
            source: std::io::Error,
            // Optional: context: String, // Um zusätzlichen Kontext zur IO-Operation zu geben
        },
    
        #[error("Configuration parsing error from '{path:?}': {message}")]
        ConfigParse {
            path: Option<std::path::PathBuf>,
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Serialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #
        Deserialization {
            message: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Invalid path: {path:?}")]
        InvalidPath { path: std::path::PathBuf },
    
        #[error("Initialization failed for module: {module_name}")]
        InitializationFailed {
            module_name: String,
            #[source]
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
    
        #[error("Feature not implemented: {feature_name}")]
        NotImplemented { feature_name: String },
    
        #[error("Internal error: {message}")]
        Internal { message: String },
    
        #[error("Operation timed out: {operation}")]
        Timeout { operation: String },
    
        #[error("Permission denied for operation: {operation}")]
        PermissionDenied { operation: String },
    }
    ```
    
    Die Verwendung von `thiserror` 5 ist entscheidend für die Erstellung ergonomischer und informativer Fehlertypen. Das Attribut `#[from]` ermöglicht eine einfache Konvertierung von Standardbibliotheksfehlern wie `std::io::Error`. Das Attribut `#[source]` (implizit von `thiserror` verwendet, wenn ein Feld `#[from]` oder explizit `#[source]` ist) ist entscheidend für die Beibehaltung der Fehlerursachenkette, wie in der Spezifikation hervorgehoben. Eine robuste Fehlerbehandlungsstrategie ist fundamental. `thiserror` vereinfacht die Erstellung benutzerdefinierter Fehlertypen, die gut mit dem `Error`-Trait von Rust integriert sind. Die Beibehaltung der `source()`-Kette ist für das Debugging unerlässlich, da sie es Entwicklern ermöglicht, einen Fehler bis zu seinem Ursprung zurückzuverfolgen, selbst wenn er von verschiedenen Schichten mehrfach umgebrochen wird.

#### 1.2.2. Fehlerpropagierungsstrategie

Alle Funktionen in der Kernschicht, die fehlschlagen können, MÜSSEN `Result<T, CoreError>` oder `Result<T, SpecificCoreSubError>` zurückgeben, wobei `SpecificCoreSubError` via `#[from]` in `CoreError` konvertierbar sein sollte. Höhere Schichten definieren ihre eigenen Fehler-Enums (z.B. `DomainError`, `SystemError`, `UIError`) und verwenden `#[from] CoreError` oder `#[source] CoreError`, um Fehler aus dem Kern zu wrappen.

#### 1.2.3. Implementierungsschritte für `core::errors`

1. Fügen Sie `thiserror = "1.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/errors.rs` mit dem `CoreError`-Enum wie oben spezifiziert.
3. Stellen Sie sicher, dass alle Module der Kernschicht `CoreError` für ihre Fehlerberichterstattung verwenden.

### 1.3. Modul: `core::logging`

Dieses Modul definiert die Logging-Infrastruktur basierend auf dem `tracing`-Crate. Alle höheren Schichten verwenden die `tracing`-Makros für ihre Logging-Ausgaben.

- **Verzeichnis:** `core/src/`
- Datei: `core/src/logging.rs`

#### 1.3.1. `initialize_logging()` Funktion

- Signatur:
    
    Rust
    
    ```
    pub fn initialize_logging(
        level_filter: tracing::Level,
        use_json: bool,
        custom_writer: Option<Box<dyn Fn() -> Box<dyn std::io::Write + Send + Sync + 'static> + Send + Sync + 'static>>
    ) -> Result<(), CoreError>
    ```
    
    - `level_filter`: Der minimale Log-Level, der aufgezeichnet werden soll (z.B. `tracing::Level::INFO`, `tracing::Level::DEBUG`).
    - `use_json`: Wenn `true`, werden Logs im JSON-Format ausgegeben, andernfalls in einem menschenlesbaren Format.
    - `custom_writer`: Eine optionale Funktion, die einen Writer für die Log-Ausgabe zurückgibt (z.B. in eine Datei, einen Netzwerk-Socket oder `std::io::stderr`). Standardmäßig wird `std::io::stderr` verwendet. Die Funktion wird verwendet, um den Writer bei Bedarf neu erstellen zu können (z.B. bei Log-Rotation).
- Implementierung:
    1. Verwendet `tracing_subscriber::fmt()` für die formatierte Protokollierung.
    2. Ermöglicht die Konfiguration des Formats (JSON oder "pretty") und des Writers.
        - Für JSON: `tracing_subscriber::fmt().json().with_writer(writer_closure).init();`
        - Für Pretty: `tracing_subscriber::fmt().pretty().with_writer(writer_closure).init();`
    3. Konfiguriert den `EnvFilter` basierend auf `level_filter` oder einer Umgebungsvariable (z.B. `RUST_LOG`).
    4. Richtet einen globalen Standard-Subscriber ein mittels `tracing::subscriber::set_global_default`.
    5. Gibt `Result<(), CoreError>` zurück, um Initialisierungsfehler zu signalisieren (z.B. wenn das Setzen des globalen Subscribers fehlschlägt).
- Die Standardisierung auf `tracing` ermöglicht eine strukturierte Protokollierung über alle Schichten hinweg, was für das Debugging und die Überwachung eines komplexen Systems wie einer Desktop-Umgebung von unschätzbarem Wert ist. Die Möglichkeit, zwischen menschenlesbaren und JSON-Formaten zu wechseln, ist gut für Entwicklung versus Produktion/Log-Aggregation. `tracing` bietet ein leistungsfähigeres und flexibleres Logging-Framework als das ältere `log`-Crate, insbesondere durch sein Konzept von Spans für kontextbezogene Protokollierung. Dies ist in einem mehrschichtigen, ereignisgesteuerten System von großem Vorteil.

#### 1.3.2. Verwendung von `tracing`-Makros

Alle Schichten verwenden die Makros `trace!`, `debug!`, `info!`, `warn!`, `error!` aus dem `tracing`-Crate. Spans (`span!`, `info_span!`, etc.) sollten verwendet werden, um kontextuelle Informationen für zusammengehörige Log-Meldungen bereitzustellen.

- Beispiel: `info!(target: "core::config", path = %file_path.display(), "Lade Kernkonfiguration.");`
- Beispiel mit Span:
    
    Rust
    
    ```
    let workspace_span = info_span!("workspace_operation", id = %workspace_id);
    let _enter = workspace_span.enter();
    //... Operationen innerhalb des Spans...
    info!("Operation abgeschlossen");
    ```
    

#### 1.3.3. Implementierungsschritte für `core::logging`

1. Fügen Sie `tracing = "0.1"` und `tracing_subscriber = { version = "0.3", features = ["fmt", "json", "env-filter"] }` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Implementieren Sie `core/src/logging.rs` mit der Funktion `initialize_logging()` wie oben spezifiziert.

### 1.4. Modul: `core::config`

Dieses Modul stellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit. Es definiert die Struktur `CoreConfig` und Funktionen für deren Verwaltung.

- **Verzeichnis:** `core/src/config/`

#### 1.4.1. `CoreConfig` Struktur

Definiert die Kernkonfigurationseinstellungen.

- Datei: `core/src/config/types.rs`
- Definition:
    
    Rust
    
    ```
    #
    pub struct CoreConfig {
        pub log_level: String, // z.B. "info", "debug", "trace"
        pub log_format: LogFormat,
        pub default_theme_name: Option<String>,
        pub enable_xwayland: bool,
        // Weitere kernspezifische Konfigurationen, z.B. Pfade, Feature-Flags
    }
    
    #
    #[serde(rename_all = "lowercase")]
    pub enum LogFormat {
        Json,
        Pretty,
    }
    
    impl Default for CoreConfig {
        fn default() -> Self {
            CoreConfig {
                log_level: "info".to_string(),
                log_format: LogFormat::Pretty,
                default_theme_name: Some("NovaDark".to_string()),
                enable_xwayland: true,
            }
        }
    }
    ```
    

#### 1.4.2. `ConfigError` Enum

Spezifische Fehler für das Laden und Verarbeiten von Konfigurationen.

- Datei: `core/src/config/error.rs`
- Definition:
    
    Rust
    
    ```
    use crate::core::errors::CoreError; // Assuming CoreError is in crate::core
    
    #
    pub enum ConfigError {
        #[error("Failed to determine config directory: {0}")]
        DirectoryResolutionError(String),
    
        #[error("Config file not found at {path:?}")]
        FileNotFound { path: std::path::PathBuf },
    
        #[error("Failed to read config file {path:?}")]
        FileReadError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        TomlParseError {
            path: std::path::PathBuf,
            message: String,
            #[source]
            source: Option<toml::de::Error>,
        },
        // Ggf. JsonParseError, falls JSON auch unterstützt wird
    
        #[error("Configuration not loaded or initialization failed.")]
        NotLoaded,
    
        #[error("Invalid configuration value for key '{key}': {message}")]
        InvalidValue { key: String, message: String },
    
        #[error("Failed to write default config to {path:?}")]
        DefaultConfigWriteError {
            path: std::path::PathBuf,
            #[source]
            source: std::io::Error,
        },
    
        #
        DefaultConfigTomlError(#[from] toml::ser::Error),
    
        #[error(transparent)]
        Core(#[from] CoreError), // Um CoreError wrappen zu können
    }
    ```
    

#### 1.4.3. Globale Konfigurationsvariable

Verwendet `once_cell` für eine thread-sichere, einmalig initialisierte globale Konfiguration.

- Datei: `core/src/config/mod.rs` (oder `core/src/config/global.rs`)
    
    Rust
    
    ```
    use once_cell::sync::OnceCell;
    use std::sync::RwLock;
    use super::types::CoreConfig; // Pfad anpassen
    use super::error::ConfigError; // Pfad anpassen
    
    static CORE_CONFIG: OnceCell<RwLock<CoreConfig>> = OnceCell::new();
    ```
    

#### 1.4.4. `load_core_config()` Funktion

Lädt die Kernkonfiguration aus einer Datei.

- Datei: `core/src/config/loader.rs`
- Signatur: `pub fn load_core_config(custom_path: Option<std::path::PathBuf>) -> Result<(), ConfigError>`
- Implementierung:
    
    1. Bestimme den Konfigurationsdateipfad:
        - Verwende `custom_path`, falls angegeben.
        - Andernfalls suche im XDG-Standardverzeichnis (z.B. `$XDG_CONFIG_HOME/nova-de/core.toml`) mittels `directories_next::ProjectDirs`.
        - Falls kein XDG-Verzeichnis gefunden wird, verwende einen Fallback-Pfad (z.B. `~/.config/nova-de/core.toml`).
    2. Wenn die Datei nicht existiert, erstelle eine Standardkonfiguration (`CoreConfig::default()`) und speichere sie unter dem ermittelten Pfad. Logge diesen Vorgang.
    3. Lese den Dateiinhalt. Bei Fehler `ConfigError::FileReadError`.
    4. Parse den Inhalt (z.B. TOML) in eine `CoreConfig`-Instanz. Bei Fehler `ConfigError::TomlParseError`.
    5. Initialisiere die globale `CORE_CONFIG` Variable mit der geladenen Konfiguration: `CORE_CONFIG.set(RwLock::new(loaded_config)).map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für den Fall, dass `set` fehlschlägt, was nur passiert, wenn bereits initialisiert).
    6. Gibt `Ok(())` bei Erfolg zurück.
    
    - Eine globale, statisch zugängliche Konfiguration ist üblich, erfordert aber eine sorgfältige Verwaltung, insbesondere bei der Initialisierung. `once_cell` für die Lazy-Initialisierung und `RwLock` für den threadsicheren Zugriff sind ein gutes Muster. Die Konfiguration muss früh im Anwendungslebenszyklus verfügbar sein und von verschiedenen Teilen des Systems zugänglich sein. `once_cell` stellt sicher, dass das Laden nur einmal erfolgt.

#### 1.4.5. `get_core_config()` Funktion

Bietet globalen Lesezugriff auf die geladene `CoreConfig`.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn get_core_config() -> Result<std::sync::RwLockReadGuard<'static, CoreConfig>, ConfigError>`
- Implementierung:
    1. Versuche, einen Read-Lock auf `CORE_CONFIG` zu erhalten: `CORE_CONFIG.get().ok_or(ConfigError::NotLoaded)?.read().map_err(|_| ConfigError::NotLoaded)` (Fehlerbehandlung für Poisoned Lock).
    2. Gibt den `RwLockReadGuard` bei Erfolg zurück.

#### 1.4.6. `update_core_config()` Funktion (Optional)

Ermöglicht die dynamische Aktualisierung der Kernkonfiguration zur Laufzeit.

- Datei: `core/src/config/access.rs`
- Signatur: `pub fn update_core_config(new_config: CoreConfig) -> Result<(), ConfigError>`
- Implementierung:
    1. Versuche, einen Write-Lock auf `CORE_CONFIG` zu erhalten.
    2. Aktualisiere die Konfiguration.
    3. Persistiert die neue Konfiguration in die Datei.
    4. **Wichtig:** Benachrichtige relevante Systemteile über die Konfigurationsänderung (z.B. über ein Event). Dies erfordert sorgfältige Überlegungen zur Thread-Sicherheit und wie Komponenten auf dynamische Änderungen reagieren.

#### 1.4.7. Implementierungsschritte für `core::config`

1. Fügen Sie `serde = { version = "1.0", features = ["derive"] }`, `toml = "0.8"`, `once_cell = "1.19"`, `directories-next = "2.0"` zu den Abhängigkeiten in `core/Cargo.toml` hinzu.
2. Erstellen Sie die Verzeichnisstruktur `core/src/config/`.
3. Definieren Sie `CoreConfig` und `LogFormat` in `core/src/config/types.rs`.
4. Definieren Sie `ConfigError` in `core/src/config/error.rs`.
5. Implementieren Sie `loader.rs` (mit `load_core_config`) und `access.rs` (mit `get_core_config` und optional `update_core_config`).
6. Fügen Sie die globale `CORE_CONFIG`-Variable in `core/src/config/mod.rs` oder einer dedizierten `global.rs` ein und exportieren Sie die öffentlichen Funktionen.

### 1.5. Modul: `core::utils`

Dieses Modul bietet allgemeine Hilfsfunktionen, die von allen höheren Schichten genutzt werden können.

- **Verzeichnis:** `core/src/utils/`
- **Struktur:** Das Modul sollte in thematische Untermodule aufgeteilt werden, um die Übersichtlichkeit zu wahren.

#### 1.5.1. Untermodul: `core::utils::file_utils`

- Datei: `core/src/utils/file_utils.rs`
- Funktionen:
    - `pub fn read_file_to_string(path: &std::path::Path) -> Result<String, CoreError>`
        - Implementierung: Verwendet `std::fs::read_to_string`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn ensure_dir_exists(path: &std::path::Path) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::create_dir_all`. Mappt `std::io::Error` auf `CoreError::Io`.
    - `pub fn write_string_to_file(path: &std::path::Path, content: &str) -> Result<(), CoreError>`
        - Implementierung: Verwendet `std::fs::write`. Mappt `std::io::Error` auf `CoreError::Io`.

#### 1.5.2. Untermodul: `core::utils::string_utils`

- Datei: `core/src/utils/string_utils.rs`
- Funktionen:
    - `pub fn sanitize_filename(name: &str) -> String`
        - Implementierung: Ersetzt ungültige Zeichen für Dateinamen (z.B. `/`, `\`, `:`, `*`, `?`, `"`, `<`, `>`, `|`) durch Unterstriche oder entfernt sie.
    - `pub fn truncate_string_with_ellipsis(s: &str, max_len: usize) -> String`
        - Implementierung: Kürzt den String auf `max_len` Zeichen und fügt "..." hinzu, falls er gekürzt wurde. Achtet auf Grapheme Cluster, um Unicode-Zeichen nicht zu zerschneiden.
            
            Rust
            
            ```
            use unicode_segmentation::UnicodeSegmentation;
            //...
            // if s.graphemes(true).count() > max_len {
            //     s.graphemes(true).take(max_len - 3).collect::<String>() + "..."
            // } else {
            //     s.to_string()
            // }
            ```
            
            - Abhängigkeit: `unicode-segmentation = "1.10"`

#### 1.5.3. Untermodul: `core::utils::async_utils` (falls benötigt)

- Datei: `core/src/utils/async_utils.rs`
- Mögliche Funktionen:
    - Wrapper für `tokio::spawn` mit standardisierter Fehlerbehandlung oder Logging.
    - Hilfsfunktionen für Timeout-Management bei asynchronen Operationen.

#### 1.5.4. Implementierungsschritte für `core::utils`

1. Erstellen Sie das Verzeichnis `core/src/utils/`.
2. Erstellen Sie `core/src/utils/mod.rs` und deklarieren Sie die Untermodule:
    
    Rust
    
    ```
    pub mod file_utils;
    pub mod string_utils;
    // pub mod async_utils;
    ```
    
3. Implementieren Sie die Funktionen in den jeweiligen Untermodul-Dateien.
4. Fügen Sie ggf. Abhängigkeiten wie `unicode-segmentation` zu `core/Cargo.toml` hinzu.
5. Das `utils`-Modul kann leicht zu einer Ansammlung unzusammenhängender Funktionen werden. Es ist wichtig, die Organisation beizubehalten und sicherzustellen, dass die Funktionen eine breite Anwendbarkeit haben. Wenn eine Hilfsfunktion sehr spezifisch für eine einzelne Domäne oder ein Systemanliegen ist, sollte sie stattdessen im Hilfsmodul dieser Schicht angesiedelt sein. Eine klare Abgrenzung ist notwendig, um die Kohäsion der Module zu wahren und unnötige Kopplungen zu vermeiden.

---

## 2. Schicht: Domänenschicht (Domain Layer)

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung NovaDE. Sie definiert die zentralen Konzepte, Regeln und Verhaltensweisen des Systems, unabhängig von technischen Implementierungsdetails der System- oder UI-Schicht. Die Kommunikation mit höheren Schichten (System- und UI-Schicht) erfolgt primär über wohldefinierte Service-APIs (als Rust-Traits implementiert) und durch domänenspezifische Events, die Zustandsänderungen signalisieren.

Die Domänenschicht ist zentral für die Funktionalität von NovaDE. Die Verwendung von Rust-Traits für Service-APIs fördert lose Kopplung und Testbarkeit. Ereignisse sind der Schlüssel zur reaktiven Propagierung von Zustandsänderungen. Fehlertypen sollten für jedes Domänenmodul spezifisch sein, um klaren Kontext zu bieten.

### 2.1. Service APIs (Traits)

Öffentliche Schnittstellen der Domänenschicht werden primär durch Rust-Traits definiert. Diese Traits werden von Service-Strukturen innerhalb der Domänenmodule implementiert. Methoden sind typischerweise `async`, wenn sie I/O-Operationen oder potenziell langlaufende Prozesse beinhalten, und geben `Result<T, SpecificDomainError>` zurück.

#### 2.1.1. `domain::theming::ThemingEngine` Trait

Verantwortlich für die Verwaltung und Anwendung von Themes.

- **Datei:** `domain/src/theming/engine.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`ThemingConfiguration` Struct (Wertobjekt):**
    
    - Definiert die vom Benutzer oder System gewählten Theme-Einstellungen.
    - **Datei:** `domain/src/theming/config.rs`
    - **Felder:**
        - `icon_theme_name: String` (z.B. "Adwaita", "Papirus")
        - `gtk_theme_name: String` (z.B. "Adwaita-dark")
        - `cursor_theme_name: String` (z.B. "Adwaita")
        - `font_name: String` (z.B. "Cantarell 11")
        - `wallpaper_path: Option<std::path::PathBuf>`
        - `color_scheme: ColorScheme` (Enum: `Light`, `Dark`, `SystemPreference`)
        - `accent_color: core::types::Color`
    - **Invarianten:** `font_name` darf nicht leer sein, wenn gesetzt.
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`ColorScheme` Enum (Wertobjekt):**
    
    - Definiert die möglichen Farbschemata.
    - **Datei:** `domain/src/theming/config.rs` (oder `types.rs` im Theming-Modul)
    - **Varianten:** `Light`, `Dark`, `SystemPreference`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AppliedThemeState` Struct (Wertobjekt):**
    
    - Repräsentiert den aktuell angewandten Theme-Zustand, inklusive aufgelöster Werte.
    - **Datei:** `domain/src/theming/state.rs`
    - **Felder:**
        - `current_config: ThemingConfiguration`
        - `resolved_wallpaper_path: Option<std::path::PathBuf>` (absoluter Pfad zum tatsächlich genutzten Hintergrundbild)
        - `font_config_details: String` (z.B. eine Pango-Font-Beschreibung oder Fontconfig-Pattern)
        - `effective_color_scheme: EffectiveColorScheme` (Enum: `Light`, `Dark`)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`EffectiveColorScheme` Enum (Wertobjekt):**
    
    - Repräsentiert das tatsächlich aktive Farbschema (aufgelöst aus `SystemPreference`).
    - **Datei:** `domain/src/theming/state.rs`
    - **Varianten:** `Light`, `Dark`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`ThemingError` Enum (Fehlertyp):**
    
    - Spezifische Fehler für das Theming-Subsystem.
    - **Datei:** `domain/src/theming/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum ThemingError {
            #[error("Invalid theming configuration: {0}")]
            InvalidConfiguration(String),
        
            #[error("Wallpaper not found at path: {0:?}")]
            WallpaperNotFound(std::path::PathBuf),
        
            #[error("Failed to apply theme '{theme_name}': {details}")]
            ThemeApplyFailed {
                theme_name: String,
                details: String,
                #[source]
                source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
            },
        
            #[error("Persistence error during theming operation")]
            PersistenceError(#[from] crate::core::errors::CoreError), // Assuming CoreError is accessible
        
            #[error("Underlying system service error for theming: {0}")]
            SystemServiceError(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuell im System angewandten und zwischengespeicherten Theme-Zustand ab.
    - **Vorbedingungen:** Keine.
    - **Nachbedingungen:** Gibt den `AppliedThemeState` zurück oder einen `ThemingError`.
- `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert die Theme-Konfiguration, persistiert sie und stößt die Anwendung des neuen Themes an.
    - **Vorbedingungen:** `new_config` muss valide sein (ggf. interne Validierung).
    - **Nachbedingungen:** Bei Erfolg wird das `ThemeChangedEvent` publiziert. Die Konfiguration wird persistiert (z.B. über `GlobalSettingsService` oder ein dediziertes Persistenz-Interface). Das System-Theme wird (versucht) anzuwenden.
    - **Geschäftsregeln:** Validiert die `new_config`. Löst das Hintergrundbild auf.
- `async fn apply_theme_to_system(&self, theme_state: &AppliedThemeState) -> Result<(), ThemingError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** (Potenziell intern, aufgerufen von `update_configuration`, oder als separate Methode für fortgeschrittene Nutzung) Wendet den gegebenen `AppliedThemeState` auf die Systemkomponenten an (z.B. Setzen von GTK-Theme, Icons, Cursor über Systemmechanismen).
    - **Vorbedingungen:** `theme_state` ist valide.
    - **Nachbedingungen:** Theme-Änderungen sind im System (versucht) aktiv.

##### Publizierte Events:

- **`ThemeChangedEvent`:**
    - **Datei:** `domain/src/theming/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct ThemeChangedEvent {
            pub new_state: AppliedThemeState,
            pub old_state: Option<AppliedThemeState>, // Optional, falls der vorherige Zustand bekannt ist
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::theming::ThemeChangedEvent`
    - **Typische Publisher:** Die Implementierung von `ThemingEngine`.
    - **Typische Subscriber:** `ui::theming_gtk` (UI-Schicht), `system::compositor` (Systemschicht, falls relevant für Darstellung).

#### 2.1.2. `domain::workspaces::WorkspaceManager` Trait

Verwaltet Workspaces (virtuelle Desktops).

- **Datei:** `domain/src/workspaces/manager.rs`

##### Zugehörige Datenstrukturen und Typen:

- **`WorkspaceId` Typalias:**
    
    - **Datei:** `domain/src/workspaces/types.rs` (oder direkt in `manager.rs`)
    - **Definition:** `pub type WorkspaceId = core::types::Uuid;`
- **`ApplicationIdentifier` Struct (Wertobjekt):**
    
    - Identifiziert eine Anwendung eindeutig.
    - **Datei:** `domain/src/workspaces/app_id.rs`
    - **Felder:**
        - `id_type: ApplicationIdType` (Enum: `DesktopFile`, `WaylandAppId`, `X11WindowClass`)
        - `identifier_str: String` (z.B. "firefox.desktop", "org.gnome.Nautilus", "Firefox")
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`Workspace` Struct (Entität):**
    
    - Repräsentiert einen einzelnen Workspace.
    - **Datei:** `domain/src/workspaces/workspace.rs`
    - **Felder:**
        - `id: WorkspaceId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `name: String` (Sichtbarkeit: `pub`)
        - `output_name: Option<String>` (Name des Monitors, dem der Workspace primär zugeordnet ist, Sichtbarkeit: `pub`)
        - `layout_policy: WorkspaceLayoutPolicy` (Enum: `Tiling`, `Floating`, `Hybrid`, Sichtbarkeit: `pub`)
        - `pinned_applications: std::collections::HashSet<ApplicationIdentifier>` (Sichtbarkeit: `pub(crate)`, Zugriff über Methoden)
        - `creation_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `last_accessed_timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
    - **Initialwerte:** `id` wird bei Erstellung generiert, `name` z.B. "Workspace 1", `output_name` ist `None`, `layout_policy` wird aus globalen Einstellungen übernommen oder ist Standard (`Floating`), `pinned_applications` ist leer, `creation_timestamp` und `last_accessed_timestamp` sind Zeitpunkte der Erstellung.
    - **Invarianten:** `name` darf nicht leer sein. `id` ist unveränderlich nach Erstellung.
    - **Methoden (Beispiele):**
        - `pub fn new(name: String, layout_policy: WorkspaceLayoutPolicy) -> Self`
        - `pub fn id(&self) -> WorkspaceId`
        - `pub fn add_pinned_app(&mut self, app_id: ApplicationIdentifier) -> bool`
        - `pub fn remove_pinned_app(&mut self, app_id: &ApplicationIdentifier) -> bool`
        - `pub fn is_app_pinned(&self, app_id: &ApplicationIdentifier) -> bool`
        - `pub(crate) fn set_last_accessed(&mut self)`
    - **Beziehungen:** Keine direkten Entitätsbeziehungen in dieser Struktur, aber `pinned_applications` verweist auf `ApplicationIdentifier`.
- **`WorkspaceLayoutPolicy` Enum (Wertobjekt):**
    
    - **Datei:** `domain/src/workspaces/types.rs`
    - **Varianten:** `Tiling`, `Floating`, `Hybrid`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`WorkspaceManagerError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/workspaces/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum WorkspaceManagerError {
            #
            WorkspaceNotFound(super::types::WorkspaceId), // super::types::WorkspaceId
        
            #[error("Workspace with name '{0}' already exists")]
            DuplicateWorkspaceName(String),
        
            #[error("Maximum number of workspaces reached ({0})")]
            MaxWorkspacesReached(usize),
        
            #[error("Cannot delete the last workspace")]
            CannotDeleteLastWorkspace,
        
            #[error("Cannot delete active workspace; switch to another first")]
            CannotDeleteActiveWorkspace,
        
            #[error("Persistence error during workspace operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Invalid application identifier: {0}")]
            InvalidApplicationId(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn create_workspace(&self, name: Option<String>) -> Result<Workspace, WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Erstellt einen neuen Workspace. Wenn `name` `None` ist, wird ein Standardname generiert (z.B. "Workspace N").
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Created` publiziert. Der neue Workspace wird persistiert.
    - **Geschäftsregeln:** Prüft auf Namenskonflikte und maximale Anzahl von Workspaces.
- `async fn delete_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löscht den Workspace mit der gegebenen ID.
    - **Vorbedingungen:** Workspace darf nicht der letzte verbleibende sein. Workspace darf nicht der aktive sein (oder es muss eine Logik zum Wechsel des aktiven Workspaces implementiert sein).
    - **Nachbedingungen:** Bei Erfolg wird `WorkspaceEvent::Deleted` publiziert. Änderungen werden persistiert.
- `async fn get_workspace_by_id(&self, id: WorkspaceId) -> Result<Option<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn get_all_workspaces(&self) -> Result<Vec<Workspace>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** Der Workspace mit `id` muss existieren.
    - **Nachbedingungen:** `WorkspaceEvent::ActiveChanged` wird publiziert. Der `last_accessed_timestamp` des neuen und ggf. des alten aktiven Workspaces wird aktualisiert.
- `async fn get_active_workspace_id(&self) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
    - **`noexcept`**: `false`
- `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Vorbedingungen:** `new_name` darf nicht leer sein und nicht mit einem existierenden Workspace-Namen (außer dem eigenen) kollidieren.
    - **Nachbedingungen:** `WorkspaceEvent::Renamed` wird publiziert. Änderung wird persistiert.
- `async fn pin_application_to_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppPinned` wird publiziert. Änderung wird persistiert.
- `async fn unpin_application_from_space(&self, space_id: WorkspaceId, app_id: ApplicationIdentifier) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Nachbedingungen:** `WorkspaceEvent::AppUnpinned` wird publiziert. Änderung wird persistiert.
- `async fn move_window_to_workspace(&self, window_identifier: String /* Eindeutiger Fenster-Identifikator, z.B. Wayland Surface ID als String */, target_workspace_id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Fordert an, ein Fenster zum Ziel-Workspace zu verschieben. Die eigentliche Fensterverschiebung erfolgt in der Systemschicht.
    - **Nachbedingungen:** `WorkspaceEvent::WindowMoved` wird publiziert.

##### Publizierte Events:

- **`WorkspaceEvent` Enum:**
    - **Datei:** `domain/src/workspaces/events.rs`
    - **Varianten (Beispiele):**
        - `Created { workspace: Workspace }`
        - `Deleted { workspace_id: WorkspaceId, new_active_workspace_id: Option<WorkspaceId> }`
        - `ActiveChanged { old_id: Option<WorkspaceId>, new_id: WorkspaceId }`
        - `Renamed { workspace_id: WorkspaceId, new_name: String }`
        - `AppPinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `AppUnpinned { space_id: WorkspaceId, app_id: ApplicationIdentifier }`
        - `LayoutPolicyChanged { workspace_id: WorkspaceId, new_policy: WorkspaceLayoutPolicy }`
        - `WindowMoved { window_identifier: String, source_workspace_id: Option<WorkspaceId>, target_workspace_id: WorkspaceId }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::workspaces::WorkspaceEvent`
    - **Typische Publisher:** Die Implementierung von `WorkspaceManager`.
    - **Typische Subscriber:** `ui::shell` (UI-Schicht), `system::compositor` (Systemschicht).

#### 2.1.3. `domain::user_centric_services::AIInteractionLogicService` Trait

Steuert die Logik für Benutzerinteraktionen mit KI-Diensten, inklusive Einwilligungsmanagement.

- **Datei:** `domain/src/user_centric_services/ai_logic.rs`
- Diese Service-Schnittstelle ist entscheidend für die sichere und transparente Integration von KI-Funktionen. Die Trennung der Einwilligungslogik von der reinen MCP-Kommunikation (die in der Systemschicht angesiedelt ist) ist ein wichtiger Aspekt für Datenschutz und Benutzerkontrolle.

##### Zugehörige Datenstrukturen und Typen:

- **`AIInteractionContextData` Struct (Wertobjekt):**
    
    - Sammelt Kontextinformationen für eine KI-Anfrage.
    - **Datei:** `domain/src/user_centric_services/ai_context.rs`
    - **Felder:**
        - `active_window_title: Option<String>`
        - `active_app_id: Option<super::workspaces::app_id::ApplicationIdentifier>` // Pfad anpassen
        - `current_workspace_id: Option<super::workspaces::types::WorkspaceId>` // Pfad anpassen
        - `selected_text: Option<String>`
        - `clipboard_content_preview: Option<String>` (Vorschau, nicht der volle Inhalt)
        - `screenshot_data_uri: Option<String>` (Data-URI eines Screenshots, falls relevant)
        - `user_query: String` (Die eigentliche Anfrage des Benutzers)
        - `interaction_id: core::types::Uuid` (Eindeutige ID für diese Interaktion)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIConsent` Enum (Wertobjekt):**
    
    - Repräsentiert den Einwilligungsstatus des Benutzers für KI-Interaktionen.
    - **Datei:** `domain/src/user_centric_services/ai_consent.rs`
    - **Varianten:**
        - `Granted { for_session: bool, timestamp: core::types::DateTime<core::types::Utc> }` (Einwilligung für die aktuelle Sitzung oder dauerhaft)
        - `Denied { timestamp: core::types::DateTime<core::types::Utc> }`
        - `NotSet`
    - **Sichtbarkeit:** `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionResponse` Struct (Wertobjekt):**
    
    - Repräsentiert die Antwort von einem KI-Dienst.
    - **Datei:** `domain/src/user_centric_services/ai_response.rs`
    - **Felder:**
        - `interaction_id: core::types::Uuid`
        - `response_text: Option<String>`
        - `suggested_actions: Vec<String>`
        - `tool_call_id: Option<String>` (Falls ein Tool vom MCP-Server aufgerufen wurde)
        - `tool_call_result: Option<serde_json::Value>` (Ergebnis des Tool-Aufrufs)
        - `error_message: Option<String>`
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `serde::Serialize`, `serde::Deserialize`.
- **`AIInteractionError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/ai_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum AIInteractionError {
            #[error("User consent not given for AI interaction")]
            ConsentNotGiven,
        
            #[error("MCP client error: {0}")]
            MCPError(String), // Wird von SystemMcpService kommen
        
            #[error("Failed to prepare context for AI interaction: {0}")]
            ContextPreparationFailed(String),
        
            #[error("AI service returned an error: {0}")]
            AIServiceError(String),
        
            #[error("Persistence error during AI consent operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #
            InteractionNotFoundOrTimedOut(crate::core::types::Uuid),
        }
        ```
        

##### Methoden des Traits:

- `async fn initiate_interaction(&self, context_data: AIInteractionContextData) -> Result<core::types::Uuid /* interaction_id */, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Startet eine neue KI-Interaktion. Prüft die Einwilligung und leitet die Anfrage ggf. an den `SystemMcpService` weiter. Gibt eine `interaction_id` zurück, um die Antwort später zu korrelieren.
    - **Vorbedingungen:** `get_consent_status()` darf nicht `Denied` sein. Wenn `NotSet`, wird die Interaktion ggf. pausiert und ein `AIConsentRequestEvent` ausgelöst.
    - **Nachbedingungen:** `AIInteractionStartedEvent` wird publiziert.
    - **Geschäftsregeln:** Die Logik hier muss entscheiden, ob basierend auf `context_data` und `AIConsent` die Interaktion fortgesetzt, abgelehnt oder eine erneute Einwilligung angefordert wird.
- `async fn provide_consent(&self, consent: AIConsent) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Speichert die Benutzereinwilligung.
    - **Nachbedingungen:** `AIConsentChangedEvent` wird publiziert. Der Einwilligungsstatus wird persistiert.
- `async fn get_consent_status(&self) -> Result<AIConsent, AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den aktuellen Einwilligungsstatus ab.
- `async fn process_mcp_response(&self, interaction_id: core::types::Uuid, response: Result<serde_json::Value, String> /* MCP Tool Call Result oder Fehler */) -> Result<(), AIInteractionError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Verarbeitet eine asynchrone Antwort vom `SystemMcpService` (typischerweise ein Tool-Aufruf-Ergebnis).
    - **Nachbedingungen:** `AIInteractionCompletedEvent` oder `AIInteractionFailedEvent` wird publiziert.

##### Publizierte Events:

- **`AIConsentChangedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct AIConsentChangedEvent { pub new_status: AIConsent; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentChangedEvent`
- **`AIInteractionStartedEvent`:**
    - **Struktur:** `pub struct AIInteractionStartedEvent { pub interaction_id: core::types::Uuid, pub context: AIInteractionContextData; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionStartedEvent`
- **`AIInteractionCompletedEvent`:**
    - **Struktur:** `pub struct AIInteractionCompletedEvent { pub response: AIInteractionResponse; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionCompletedEvent`
- **`AIInteractionFailedEvent`:**
    - **Struktur:** `pub struct AIInteractionFailedEvent { pub interaction_id: core::types::Uuid, pub error: AIInteractionError; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIInteractionFailedEvent`
- **`AIConsentRequestEvent`:** (Falls die UI den Benutzer zur Einwilligung auffordern soll)
    - **Struktur:** `pub struct AIConsentRequestEvent { pub interaction_id: core::types::Uuid, pub for_context: AIInteractionContextData }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::AIConsentRequestEvent`
- **Typische Publisher:** Die Implementierung von `AIInteractionLogicService`.
- **Typische Subscriber:** `ui::command_palette` oder KI-Widgets (UI-Schicht), `system::mcp::SystemMcpService` (Systemschicht, für Antworten).

#### 2.1.4. `domain::user_centric_services::NotificationService` Trait

Verwaltet das Anzeigen und Interagieren mit Desktop-Benachrichtigungen.

- **Datei:** `domain/src/user_centric_services/notification_service.rs`
- Die Parameter für `post_notification` spiegeln eng die D-Bus-Methode `org.freedesktop.Notifications.Notify` wider.9 Dieser Dienst fungiert als Abstraktion über potenzielle D-Bus-Implementierungen in der Systemschicht. Die Domänenschicht definiert das _Konzept_ einer Benachrichtigung innerhalb von NovaDE. Die Systemschicht wäre dann dafür verantwortlich, diese Benachrichtigung tatsächlich über D-Bus zu senden, wenn NovaDE als Benachrichtigungsserver fungiert, oder auf D-Bus-Benachrichtigungen zu lauschen, wenn es diese konsumiert. Die Verwendung von `zvariant::OwnedValue` für `hints` deutet auf eine direkte Abbildung auf D-Bus-Varianten hin.

##### Zugehörige Datenstrukturen und Typen:

- **`NotificationId` Typalias:**
    
    - **Datei:** `domain/src/user_centric_services/types.rs` (oder direkt in `notification_service.rs`)
    - **Definition:** `pub type NotificationId = core::types::Uuid;`
- **`NotificationAction` Struct (Wertobjekt):**
    
    - Definiert eine Aktion, die mit einer Benachrichtigung verbunden ist.
    - **Datei:** `domain/src/user_centric_services/notification_action.rs`
    - **Felder:**
        - `key: String` (Eindeutiger Schlüssel für die Aktion, z.B. "default", "reply")
        - `label: String` (Anzeigetext für den Button)
    - **Sichtbarkeit:** Alle Felder `pub`.
    - **Ableitungen:** `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationUrgency` Enum (Wertobjekt):**
    
    - Definiert die Dringlichkeitsstufe einer Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Low`, `Normal`, `Critical`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`Notification` Struct (Entität):**
    
    - Repräsentiert eine einzelne Desktop-Benachrichtigung.
    - **Datei:** `domain/src/user_centric_services/notification.rs`
    - **Felder:**
        - `id: NotificationId` (Sichtbarkeit: `pub(crate)`, Zugriff über Getter)
        - `app_name: String` (Sichtbarkeit: `pub`)
        - `replaces_id: Option<NotificationId>` (Sichtbarkeit: `pub`)
        - `app_icon: Option<String>` (Pfad oder Name des Icons, Sichtbarkeit: `pub`)
        - `summary: String` (Kurze Zusammenfassung, Sichtbarkeit: `pub`)
        - `body: Option<String>` (Detaillierter Text, Sichtbarkeit: `pub`)
        - `actions: Vec<NotificationAction>` (Sichtbarkeit: `pub`)
        - `hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>` (Spezifische Hinweise für den Notification-Server, Sichtbarkeit: `pub`)
        - `expire_timeout_ms: i32` (-1 für Server-Default, 0 für nie, >0 für Millisekunden, Sichtbarkeit: `pub`)
        - `urgency: NotificationUrgency` (Sichtbarkeit: `pub`)
        - `timestamp: core::types::DateTime<core::types::Utc>` (Sichtbarkeit: `pub(crate)`)
        - `is_displayed: std::sync::atomic::AtomicBool` (Interner Status, ob die Benachrichtigung aktuell angezeigt wird)
    - **Initialwerte:** `id` wird generiert, `timestamp` ist aktuell, `is_displayed` ist `false`.
    - **Invarianten:** `summary` darf nicht leer sein. `id` ist unveränderlich.
    - **Methoden (Beispiele):**
        - `pub fn id(&self) -> NotificationId`
        - `pub(crate) fn mark_as_displayed(&self)`
        - `pub(crate) fn mark_as_closed(&self)`
- **`CloseReason` Enum (Wertobjekt):**
    
    - Gibt den Grund an, warum eine Benachrichtigung geschlossen wurde.
    - **Datei:** `domain/src/user_centric_services/types.rs`
    - **Varianten:** `Expired`, `DismissedByUser`, `ClosedByApp`, `ServiceShutdown`, `Unknown`
    - **Ableitungen:** `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `serde::Serialize`, `serde::Deserialize`.
- **`NotificationError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/user_centric_services/notification_error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum NotificationError {
            #
            NotificationNotFound(super::types::NotificationId), // Pfad anpassen
        
            #[error("Invalid notification format or content: {0}")]
            InvalidNotificationFormat(String),
        
            #[error("Failed to invoke action '{action_key}' for notification {notification_id}: {reason}")]
            ActionInvokeFailed {
                notification_id: super::types::NotificationId, // Pfad anpassen
                action_key: String,
                reason: String,
            },
        
            #[error("Notification service is unavailable or failed: {0}")]
            ServiceUnavailable(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn post_notification(&self, app_name: String, replaces_id: Option<NotificationId>, app_icon: Option<String>, summary: String, body: Option<String>, actions: Vec<NotificationAction>, hints: std::collections::HashMap<String, zbus::zvariant::OwnedValue>, expire_timeout_ms: i32, urgency: NotificationUrgency) -> Result<NotificationId, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Sendet eine neue Benachrichtigung oder aktualisiert eine existierende.
    - **Nachbedingungen:** Bei Erfolg wird `NotificationPostedEvent` publiziert. Die Benachrichtigung wird (versucht) dem Benutzer angezeigt.
- `async fn get_active_notifications(&self) -> Result<Vec<Notification>, NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Liste aller aktuell aktiven (angezeigten) Benachrichtigungen ab.
- `async fn close_notification(&self, id: NotificationId, reason: CloseReason) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Schließt eine spezifische Benachrichtigung.
    - **Vorbedingungen:** Benachrichtigung mit `id` muss existieren und aktiv sein.
    - **Nachbedingungen:** `NotificationClosedEvent` wird publiziert.
- `async fn invoke_action(&self, id: NotificationId, action_key: String) -> Result<(), NotificationError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Löst eine mit einer Benachrichtigung verbundene Aktion aus.
    - **Vorbedingungen:** Benachrichtigung mit `id` und Aktion mit `action_key` müssen existieren.
    - **Nachbedingungen:** `NotificationActionInvokedEvent` wird publiziert.

##### Publizierte Events:

- **`NotificationPostedEvent`:**
    - **Datei:** `domain/src/user_centric_services/events.rs`
    - **Struktur:** `pub struct NotificationPostedEvent { pub notification: Notification; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationPostedEvent`
- **`NotificationClosedEvent`:**
    - **Struktur:** `pub struct NotificationClosedEvent { pub id: NotificationId, pub reason: CloseReason; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationClosedEvent`
- **`NotificationActionInvokedEvent`:**
    - **Struktur:** `pub struct NotificationActionInvokedEvent { pub id: NotificationId, pub action_key: String; }`
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::user_centric_services::NotificationActionInvokedEvent`
- **Typische Publisher:** Die Implementierung von `NotificationService`.
- **Typische Subscriber:** `ui::notifications_frontend` oder `ui::shell` (UI-Schicht), `system::dbus::notification_server` (Systemschicht, falls NovaDE als Server agiert und die Events intern weiterleitet).

#### 2.1.5. `domain::global_settings_and_state_management::GlobalSettingsService` Trait

Verwaltet globale Desktop-Einstellungen und deren Persistenz.

- **Datei:** `domain/src/global_settings/service.rs`
- Dieser Dienst bietet eine strukturierte Methode zur Verwaltung einer Vielzahl von Desktop-Einstellungen. Der Persistenzmechanismus (z.B. eine Implementierung von `domain::settings_persistence_iface`, wie in der Kernschichtspezifikation erwähnt) ist hier von entscheidender Bedeutung.

##### Zugehörige Datenstrukturen und Typen:

- **`SettingPath` Typalias:**
    
    - **Datei:** `domain/src/global_settings/types.rs`
    - **Definition:** `pub type SettingPath = String;` (z.B. "desktop.background.color", "keyboard.layouts.0.name")
- **`SettingValue` Enum (Wertobjekt):**
    
    - Repräsentiert den Wert einer Einstellung. Kann verschiedene primitive Typen und verschachtelte Strukturen annehmen.
    - **Datei:** `domain/src/global_settings/value.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        #[serde(untagged)] // Für flexible (De-)Serialisierung
        pub enum SettingValue {
            String(String),
            Integer(i64),
            Float(f64),
            Boolean(bool),
            List(Vec<SettingValue>),
            Map(std::collections::HashMap<String, SettingValue>),
            Null, // Um das Fehlen eines Wertes explizit darzustellen
        }
        // Implement From<T> for SettingValue für gängige Typen
        ```
        
    - Die Verwendung von `serde_json::Value` wäre eine Alternative für maximale Flexibilität, aber ein eigenes Enum bietet mehr Typsicherheit innerhalb der Domäne.
- **`GlobalDesktopSettings` Struct (Entität):**
    
    - Repräsentiert die Gesamtheit aller verwalteten Einstellungen.
    - **Datei:** `domain/src/global_settings/settings_struct.rs`
    - **Felder:**
        - `settings: std::collections::BTreeMap<SettingPath, SettingValue>` (BTreeMap für geordnete Iteration/Serialisierung, falls gewünscht)
    - **Sichtbarkeit:** `pub(crate)` für `settings`, Zugriff über Methoden.
    - **Methoden (Beispiele):**
        - `pub fn get(&self, path: &SettingPath) -> Option<&SettingValue>`
        - `pub fn set(&mut self, path: SettingPath, value: SettingValue) -> Option<SettingValue>` (gibt alten Wert zurück)
        - `pub fn remove(&mut self, path: &SettingPath) -> Option<SettingValue>`
- **`GlobalSettingsError` Enum (Fehlertyp):**
    
    - **Datei:** `domain/src/global_settings/error.rs`
    - **Definition:**
        
        Rust
        
        ```
        #
        pub enum GlobalSettingsError {
            #
            SettingNotFound(super::types::SettingPath), // Pfad anpassen
        
            #
            TypeMismatch {
                path: super::types::SettingPath, // Pfad anpassen
                expected_type: String,
                found_type: String,
            },
        
            #[error("Persistence error during settings operation")]
            PersistenceError(#[from] crate::core::errors::CoreError),
        
            #[error("Validation error for setting '{path}': {message}")]
            ValidationError {
                path: super::types::SettingPath, // Pfad anpassen
                message: String,
            },
        
            #[error("Invalid setting path format: {0}")]
            InvalidPathFormat(String),
        }
        ```
        

##### Methoden des Traits:

- `async fn load_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Lädt alle Einstellungen aus der Persistenzschicht.
    - **Nachbedingungen:** Gibt die geladenen `GlobalDesktopSettings` zurück oder einen Fehler.
- `async fn save_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Persistiert den gesamten Einstellungsbaum.
- `async fn get_setting(&self, path: &SettingPath) -> Result<Option<SettingValue>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft den Wert einer spezifischen Einstellung ab.
- `async fn update_setting(&self, path: SettingPath, value: SettingValue) -> Result<Option<SettingValue /* old_value */>, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Aktualisiert eine spezifische Einstellung und persistiert die Änderung. Gibt den alten Wert zurück, falls vorhanden.
    - **Vorbedingungen:** `path` und `value` müssen validen Formaten entsprechen. Ggf. Validierung gegen ein Schema.
    - **Nachbedingungen:** Bei Erfolg wird `SettingChangedEvent` publiziert. Die Einstellung wird persistiert.
- `async fn get_all_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - **`noexcept`**: `false`
    - **Beschreibung:** Ruft eine Kopie aller aktuellen Einstellungen ab.

##### Publizierte Events:

- **`SettingChangedEvent`:**
    - **Datei:** `domain/src/global_settings/events.rs`
    - **Struktur:**
        
        Rust
        
        ```
        #
        pub struct SettingChangedEvent {
            pub path: SettingPath,
            pub old_value: Option<SettingValue>,
            pub new_value: SettingValue,
        }
        ```
        
    - **Eindeutiger Event-Name/Typ:** `nova_de::domain::global_settings::SettingChangedEvent`
- **Typische Publisher:** Die Implementierung von `GlobalSettingsService`.
- **Typische Subscriber:** `ui::control_center` (UI-Schicht), verschiedene Systemkomponenten, die auf Einstellungsänderungen reagieren müssen.

### 2.2. Datenstrukturen (Öffentlich)

Zusätzlich zu den direkt mit Service-APIs assoziierten Strukturen können weitere öffentliche Datenstrukturen existieren, die Zustände oder Konfigurationen repräsentieren und von mehreren Modulen oder Schichten verwendet werden.

- **Beispiele:** Viele der oben bereits definierten Strukturen fallen in diese Kategorie, z.B. `AppliedThemeState`, `Workspace`, `Notification`, `GlobalDesktopSettings`, `ThemingConfiguration`, `ApplicationIdentifier`, `AIInteractionContextData`, `AIConsent`, `SettingValue`.
- **Implementierungsrichtlinien:**
    - Jede Struktur/Enum in einer eigenen Datei innerhalb des relevanten Domänenmoduls (z.B. `domain/src/theming/state.rs`).
    - Ableitung von `Debug`, `Clone`, `PartialEq` ist Standard.
    - Ableitung von `serde::Serialize`, `serde::Deserialize` falls Persistenz oder IPC-Übertragung erforderlich ist.
    - Felder sollten `pub` sein, wenn sie direkt von extern gelesen werden sollen, oder `pub(crate)` mit öffentlichen Gettern/Settern für kontrollierten Zugriff.
    - Invarianten sollten durch Konstruktoren und Methoden sichergestellt werden.
    - Beziehungen zu anderen Entitäten/Wertobjekten sollten klar definiert sein (z.B. durch Komposition oder IDs).

### 2.3. Events (Domänenspezifisch)

Domänenspezifische Events signalisieren wichtige Zustandsänderungen innerhalb der Domänenschicht. Sie sind entscheidend für eine reaktive Architektur und lose Kopplung.

- **Beispiele:** Die bereits bei den Services definierten Events (`ThemeChangedEvent`, `WorkspaceEvent`, `NotificationPostedEvent`, `SettingChangedEvent`, `AIConsentChangedEvent`, etc.).
- **Struktur:**
    - Jedes Event sollte als eigene Struktur oder als Variante eines umfassenderen Event-Enums (pro Modul) definiert werden.
    - Die Event-Struktur enthält alle relevanten Daten zur Zustandsänderung.
    - Beispiel: `pub struct ActiveWorkspaceChanged { pub old_id: Option<WorkspaceId>, pub new_id: WorkspaceId }`
- **Eindeutiger Event-Name/Typ:** Eine klare Namenskonvention ist wichtig, z.B. `nova_de::domain::module::EventName`.
- **Publisher:** Die jeweilige Service-Implementierung, die die Zustandsänderung verursacht.
- **Subscriber:** Komponenten in der System- und UI-Schicht, die auf diese Änderungen reagieren müssen.
    - Beispiel: `ui::theming_gtk` abonniert `ThemeChangedEvent`.
    - Beispiel: `system::compositor` abonniert `ActiveWorkspaceChanged`.
- **Datei-Struktur:** Events können in einer `events.rs`-Datei innerhalb jedes Domänenmoduls definiert werden (z.B. `domain/src/theming/events.rs`).
- **Serialisierung:** Wenn Events über IPC-Grenzen (z.B. D-Bus) gesendet werden sollen, müssen sie `serde::Serialize` und `serde::Deserialize` implementieren.

### 2.4. Fehlertypen (Modulspezifisch)

Jedes Hauptmodul innerhalb der Domänenschicht sollte seine eigenen spezifischen Fehler-Enums definieren, um präzise Fehlerinformationen zu liefern.

- **Beispiele:** Die bereits bei den Services definierten Fehler (`ThemingError`, `WorkspaceManagerError`, `AIInteractionError`, `NotificationError`, `GlobalSettingsError`).
- **Implementierungsrichtlinien:**
    - Verwendung des `thiserror`-Crates für eine ergonomische Definition.
    - Jeder Fehlertyp in einer eigenen Datei (z.B. `domain/src/theming/error.rs`).
    - Fehlervarianten sollten klare und spezifische Fehlerzustände des Moduls beschreiben.
    - Wo sinnvoll, sollten Quellfehler (`#[source]`) oder Konvertierungen (`#[from]`) für Fehler aus der Kernschicht oder anderen Abhängigkeiten bereitgestellt werden, um die Fehlerkette zu erhalten.
- **Verwendung:** Domänenservices geben diese spezifischen Fehler in ihren `Result`-Typen zurück. Die System- und UI-Schicht behandeln diese Fehler oder leiten sie ggf. weiter, eventuell gewrappt in ihre eigenen, allgemeineren Fehlertypen.

---

## 3. Schicht: Systemschicht (System Layer)

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um. Sie interagiert direkt mit dem Betriebssystem, der Hardware (über Abstraktionen wie DRM/GBM, libinput), Systemdiensten (via D-Bus, PipeWire) und dem Wayland-Compositor-Backend (Smithay). Sie konsumiert APIs der Domänenschicht, um Geschäftslogik anzuwenden und Zustände abzufragen.

Diese Schicht ist die Brücke zwischen der abstrakten Domänenlogik von NovaDE und den konkreten Realitäten des Betriebssystems und der Hardware. Hier finden viele der FFI-Aufrufe, IPC-Kommunikation und Interaktionen auf niedriger Ebene statt. Smithay wird intensiv für Wayland-bezogene Komponenten genutzt. Eine robuste Fehlerbehandlung ist entscheidend, um Fehler von niedriger Ebene in abstraktere `SystemError`-Typen oder spezifische Unterfehler zu übersetzen. Die asynchrone Natur vieler Operationen (IPC, Hardwareinteraktion) ist hier kritisch.

### 3.1. Modul: `system::compositor` (Smithay-basierter Wayland Compositor Kern)

Dieses Modul ist das Herzstück der grafischen Darstellung und Fensterverwaltung in NovaDE. Es basiert auf der Smithay-Bibliothek und implementiert die Kernfunktionalitäten eines Wayland-Compositors.

- **Abhängigkeiten:** `smithay`, `wayland-server`, `wayland-protocols`, `calloop`, `input` (libinput-rs), `drm-rs`, `gbm-rs`, `libloading` (für EGL).
- **Verzeichnis:** `system/src/compositor/`

#### 3.1.1. `NovaDeSystemState` Struktur (Hauptzustand für Smithay Handler)

Diese Struktur dient als zentraler Datenhalter für den Event-Loop und implementiert die verschiedenen Handler-Traits von Smithay.

- **Datei:** `system/src/state.rs` (oder `system/src/compositor/state.rs`, je nach Gesamtstruktur)
- **Felder (Beispiele, basierend auf typischer Smithay-Nutzung und NovaDE-Anforderungen):**
    
    Rust
    
    ```
    use smithay::{
        backend::{
            allocator::dmabuf::DmabufState, // [50]
            drm::DrmDeviceFd, // [19, 24, 56, 62, 69, 93, 305, 388]
            egl::{EGLContext, EGLDisplay}, // [16, 26, 62, 65, 94, 97]
            renderer::{
                gles::GlesRenderer, // [16, 40, 62, 94, 97]
                multigpu::{gbm::GbmGlesBackend, GpuManager}, // [24, 28, 40, 62, 97, 145, 222]
            },
            libinput::LibinputInputBackend, // [23, 75, 382]
            udev::{UdevBackend, UdevEvent}, // [37]
            session::{Session, Signal as SessionSignal, logind::LogindSession}, // [362, 391]
            input::Seat,
        },
        desktop::{Space, Window, PopupManager, layer_map_for_output, LayerSurface}, // [67]
        input::{SeatState, SeatHandler, pointer::PointerHandle, keyboard::KeyboardHandle, touch::TouchHandle, SeatName},
        output::Output,
        reexports::{
            calloop::{EventLoop, LoopHandle, LoopSignal},
            wayland_server::{Display, DisplayHandle, Client,backend::GlobalId},
            wayland_protocols::xdg::shell::server::xdg_wm_base,
        },
        utils::{Clock, Logical, Point, Rectangle, Serial, Transform, SERIAL_COUNTER},
        wayland::{
            buffer::BufferHandler, // [353]
            compositor::{CompositorState, CompositorHandler, CompositorClientState, SurfaceData}, // [17, 87, 99]
            dmabuf::DmabufHandler, // [50]
            output::{OutputHandler, OutputManagerState}, // [49, 147, 280, 370, 372, 392]
            presentation::PresentationState, // [274]
            seat::WaylandSeatData,
            shell::{
                xdg::{XdgShellState, XdgShellHandler, XdgShellSurfaceUserData, XdgWmBaseUserData, decoration::XdgDecorationState}, // [13, 31, 54, 81, 167, 176, 191, 195, 199, 204, 207, 208, 215, 223, 224, 225, 227, 317, 323, 336, 349, 350, 393, 394, 395, 396, 397, 398, 399, 400]
                wlr_layer::{WlrLayerShellState, LayerShellHandler, LayerSurfaceData}, // [11, 19, 20, 41, 48, 57, 66, 67, 71, 91, 92, 95, 160, 192, 254, 292, 307, 318, 347, 401, 402]
            },
            shm::{ShmState, ShmHandler}, // [141, 165]
            selection::{
                data_device::{DataDeviceState, DataDeviceHandler}, // [11, 12, 19, 35, 44, 45, 73, 80, 141, 216, 403, 404, 405, 406]
                primary_selection::{PrimarySelectionState, PrimarySelectionHandler}, // [30, 120]
            },
            input_method::{InputMethodManagerState, InputMethodHandler, InputMethodKeyboardUserData}, // [11, 34, 35, 117, 253, 264, 268, 407, 408, 409, 410, 411]
            text_input::{TextInputManagerState, TextInputHandler, TextInputUserData}, // [86, 112, 328, 412, 413, 414]
            viewporter::ViewporterState, // [371]
            xdg_activation::XdgActivationState, // [303]
            foreign_toplevel::ForeignToplevelState, // [335]
            idle_notify::IdleNotifierState, // [58]
            explicit_synchronization::ExplicitSyncState, // [415]
            drm_lease::DrmLeaseState, // [107]
            server_decoration::ServerDecorationManagerState, // [297]
        },
        xwayland::{XWayland, XWaylandEvent, XWaylandClientData, xwm::{X11Wm, XwmHandler, X11Surface}}, // [11, 14, 19, 21, 32, 35, 36, 41, 43, 52, 60, 76, 78, 85, 117, 141, 219, 270, 310, 329, 339, 361, 363, 377, 416, 417]
    };
    use std::{collections::HashMap, sync::{Arc, Mutex}};
    use crate::system::dbus::DBusConnectionManager; // Für D-Bus Interaktionen
    use crate::system::audio::PipeWireClientService; // Für PipeWire
    use crate::domain::services::DomainLayerServices; // Wrapper für Domain-Service-Handles
    
    pub struct NovaDeSystemState {
        pub display_handle: DisplayHandle,
        pub event_loop_handle: LoopHandle<'static, Self>,
        pub loop_signal: LoopSignal,
        pub clock: Clock, // Für Timings, Animationen
    
        // Core Wayland protocol states
        pub compositor_state: Arc<Mutex<CompositorState>>,
        pub shm_state: Arc<Mutex<ShmState>>,
        pub output_manager_state: Arc<Mutex<OutputManagerState>>,
        pub seat_state: Arc<Mutex<SeatState<Self>>>,
        pub data_device_state: Arc<Mutex<DataDeviceState>>,
        pub primary_selection_state: Arc<Mutex<PrimarySelectionState>>,
    
        // Shells
        pub xdg_shell_state: Arc<Mutex<XdgShellState>>,
        pub layer_shell_state: Arc<Mutex<WlrLayerShellState>>,
        pub xdg_decoration_state: Arc<Mutex<XdgDecorationState>>,
        // Optional: xwayland_shell_state if using Smithay's xwayland shell helpers
    
        // Input related
        pub text_input_manager_state: Arc<Mutex<TextInputManagerState>>,
        pub input_method_manager_state: Arc<Mutex<InputMethodManagerState>>,
    
        // Optional Wayland protocol states
        pub presentation_time_state: Option<Arc<Mutex<PresentationState>>>,
        pub viewporter_state: Option<Arc<Mutex<ViewporterState>>>,
        pub xdg_activation_state: Option<Arc<Mutex<XdgActivationState>>>,
        pub foreign_toplevel_state: Option<Arc<Mutex<ForeignToplevelState>>>,
        pub idle_notifier_state: Option<Arc<Mutex<IdleNotifierState<Self>>>>,
        pub explicit_sync_state: Option<Arc<Mutex<ExplicitSyncState>>>,
        pub drm_lease_state: Option<Arc<Mutex<DrmLeaseState>>>,
        pub server_decoration_manager_state: Option<Arc<Mutex<ServerDecorationManagerState>>>,
    
        // Backend specific states
        pub udev_backend_data: Option<UdevBackendData>, // If using udev backend
        pub winit_data: Option<WinitData>, // If using winit backend
        pub x11_data: Option<X11BackendData>, // If using X11 backend (as a client)
    
        // XWayland
        pub xwayland: Option<XWayland>,
        pub xwm: Option<Arc<Mutex<X11Wm>>>, // X11 Window Manager for XWayland
        pub xwayland_client_data_id: Option<u32>, // To identify XWayland's client
    
        // Desktop management
        pub space: Arc<Mutex<Space<WindowElement>>>, // Manages windows and outputs
        pub popup_manager: Arc<Mutex<PopupManager>>,
    
        // Input devices
        pub seat_name: String,
        pub seat: Seat<Self>,
        pub pointer: PointerHandle<Self>,
        pub keyboard: KeyboardHandle<Self>,
        pub touch: Option<TouchHandle<Self>>, // Touch ist optional
    
        // Domain Layer Access
        pub domain_services: Arc<DomainLayerServices>,
    
        // System Services Clients
        pub dbus_conn_manager: Arc<DBusConnectionManager>,
        pub pipewire_service: Arc<PipeWireClientService>,
    
        // Internal state
        pub running: std::sync::atomic::AtomicBool,
        pub active_workspace_id: Option<crate::domain::workspaces::WorkspaceId>,
        // Weitere anwendungsspezifische Zustände
    }
    
    // Hilfsstrukturen für Backend-spezifische Daten
    pub struct UdevBackendData {
        pub session: LogindSession, // Oder eine andere Session-Implementierung
        pub gpus: GpuManager<GbmGlesBackend<GlesRenderer, DrmDeviceFd>>,
        pub primary_gpu: DrmDeviceFd,
        pub udev_backend: UdevBackend,
        // Weitere DRM/GBM/EGL spezifische Zustände
    }
    pub struct WinitData { /*... relevante Winit-Felder... */ }
    pub struct X11BackendData { /*... relevante X11-Backend-Felder... */ }
    
    // WindowElement (Beispiel, muss an NovaDE angepasst werden)
    #
    pub enum WindowElement {
        Wayland(Window), // Smithay's Window für XDG Toplevels
        X11(X11Surface), // Smithay's X11Surface
        Layer(LayerSurface), // Smithay's LayerSurface
    }
    // Implementiere notwendige Traits für WindowElement (z.B. RenderElement, SpaceElement)
    ```
    
    - Der Compositor ist das komplexeste Element der Systemschicht. Smithay 8 stellt Bausteine bereit, aber die eigentliche Fensterverwaltungslogik (Tiling, Stacking, Fokusrichtlinien basierend auf Domänenregeln) muss hier implementiert werden. Die `AnvilState` aus Smithays Anvil-Compositor dient als gute Referenz für die Strukturierung von `NovaDeSystemState` und die Integration verschiedener Smithay-Handler.

#### 3.1.2. Initialisierung (`system::compositor::initialize_compositor`)

- **Datei:** `system/src/compositor/init.rs`
- **Signatur:** `pub async fn initialize_compositor(domain_services: Arc<DomainLayerServices>, event_loop_handle: LoopHandle<'static, NovaDeSystemState>, loop_signal: LoopSignal) -> Result<NovaDeSystemState, SystemError>`
- **Schritte:**
    1. Erstelle `DisplayHandle` aus dem globalen `Display` Objekt (Annahme: `Display` wird im `main` erstellt und `DisplayHandle` wird hierher übergeben oder `NovaDeSystemState` wird direkt im `main` erstellt).
    2. Initialisiere Smithay-Backends (z.B. `LibinputInputBackend` 23, `UdevBackend` 37, DRM/GBM/EGL 16). Die Wahl des Backends (DRM/libseat für Bare-Metal, Winit/X11 für verschachtelte Entwicklung) ist eine wichtige architektonische Entscheidung. Die Implementierung sollte dies abstrahieren.
    3. Initialisiere alle relevanten Wayland-Globale unter Verwendung ihrer

# **UI-Schicht: Ultra-Feinspezifikation und Implementierungsleitfaden**

## **Modul: ui::shell::PanelWidget (Haupt-Panel-Implementierung)**

### **1. Modul-Identifikation und Zweck**

- **Modul-ID:** `ui::shell::PanelWidget`
- **Abhängigkeiten:**
    - `novade-core` (insbesondere `core::types` für geometrische Primitive und Farben, `core::errors` als Basis)
    - `novade-domain` (insbesondere `domain::theming` für Design-Tokens, `domain::global_settings_and_state_management` für Konfigurationen)
    - `gtk4-rs` (GTK4 Rust Bindings)
    - `gtk4-layer-shell` (für Wayland Layer Shell Integration)
    - `cairo-rs` (für benutzerdefiniertes Zeichnen, falls CSS nicht ausreicht)
    - `zbus` (für D-Bus-Kommunikation, falls das Panel direkt mit Systemdiensten interagiert, was aber eher von Submodulen gehandhabt wird)
    - `once_cell` (für statische Initialisierungen)
    - `thiserror` (für Fehlerdefinitionen innerhalb dieses Moduls, falls spezifisch)
    - `tracing` (für Logging)
- **Zweck:** Das `PanelWidget` ist die zentrale Komponente der `ui::shell`, die als primäre(s) Kontroll- und Systemleiste(n) der NovaDE dient. Es ist verantwortlich für die Bereitstellung einer oder mehrerer horizontaler Leisten am Bildschirmrand, die Aufnahme, Anordnung und Verwaltung verschiedener modularer Panel-Elemente (Submodule), die Implementierung grundlegender Panel-Eigenschaften (Höhe, Transparenz, visueller "Leuchtakzent") und die korrekte Integration in Wayland-Compositors mittels des `gtk4-layer-shell`-Protokolls.

### **2. Visuelles Design und Theming (Spezifikation für Manus AI)**

- **Positionierung:**
    - Kann am oberen (`Top`) oder unteren (`Bottom`) Bildschirmrand verankert werden.
    - Die Positionierung wird durch die Eigenschaft `position` (Typ: `PanelPosition`, siehe unten) gesteuert.
    - Standardwert: `PanelPosition::Top`.
- **Abmessungen:**
    - **Höhe (`panel-height`):** Konfigurierbare Höhe in Pixeln.
        - Datentyp: `i32`.
        - Gültiger Bereich: Minimum 24px, Maximum 128px.
        - Standardwert: 36px.
        - Die Höhe wird über die GObject-Eigenschaft `panel-height` gesetzt und beeinflusst die `default-height` des zugrundeliegenden `gtk::ApplicationWindow` sowie die `height-request` der internen `main_box`.
    - **Breite:** Das Panel erstreckt sich standardmäßig über die gesamte Breite des zugewiesenen Monitors/Outputs. Dies wird durch die Ankerung über `gtk4-layer-shell` erreicht (`Edge::Left` und `Edge::Right` auf `true` setzen).
- **Erscheinungsbild:**
    - **Hintergrund:**
        - Farbe und Stil werden primär über CSS gesteuert.
        - Das Panel kann optional einen transluzenten Hintergrund haben.
        - Die Eigenschaft `transparency-enabled` (Typ: `bool`, Standard: `false`) steuert dies.
        - Implementierung der Transparenz:
            1. Das GDK Visual des `PanelWidget` (als `gtk::Window`) muss auf ein RGBA-Visual gesetzt werden, falls Transparenz aktiviert ist: `self.set_visual(self.display().rgba_visual().as_ref())`.
            2. Der CSS-Hintergrund muss eine RGBA-Farbe verwenden (z.B. `background-color: rgba(0, 0, 0, 0.5);`).
            3. Für Wayland-Compositors, die transparente Oberflächen unterstützen, muss die `gtk4-layer-shell`-Integration sicherstellen, dass der Compositor die Transparenz korrekt handhabt. Das Setzen von `surface.set_opaque_region(None)` kann notwendig sein.
    - **"Leuchtakzent"-Effekt:**
        - Ein subtiler Leuchteffekt entlang einer Kante des Panels (typischerweise die dem Bildschirmzentrum zugewandte Kante).
        - Gesteuert durch Eigenschaften:
            - `leuchtakzent-color` (Typ: `Option<gdk::RGBA>`, Standard: `None`). Farbe des Akzents.
            - `leuchtakzent-intensity` (Typ: `f64`, Bereich: 0.0 bis 1.0, Standard: 0.5). Intensität/Opazität des Akzents.
        - **Implementierung (priorisierte Reihenfolge):**
            1. **CSS `box-shadow`:** Versuche, den Effekt mit CSS `box-shadow` zu erzielen (z.B. `box-shadow: 0px 2px 5px 0px var(--leuchtakzent-color);` angepasst für die Kante). Die Farbe `--leuchtakzent-color` wird dynamisch über einen `CssProvider` basierend auf `leuchtakzent-color` und `leuchtakzent-intensity` gesetzt.
            2. **Benutzerdefiniertes Zeichnen (Cairo auf `gtk::DrawingArea`):** Falls CSS nicht ausreicht oder Performance-Probleme verursacht:
                - Eine `gtk::DrawingArea` wird als unterste Ebene im `PanelWidget` platziert (oder das `PanelWidget` zeichnet seinen Hintergrund selbst, was komplexer ist).
                - Im `draw`-Signal-Handler der `DrawingArea`:
                    - Hintergrund des Panels zeichnen (unter Berücksichtigung von `transparency-enabled`).
                    - Den Leuchtakzent-Pfad definieren (Linie oder schmales Rechteck entlang der relevanten Kante).
                    - Akzentfarbe und -intensität aus den GObject-Eigenschaften abrufen.
                    - `cr.set_source_rgba()` mit der `leuchtakzent-color` (modifiziert durch `leuchtakzent-intensity` für die Alpha-Komponente) verwenden.
                    - Für einen weichen Effekt: `cairo::LinearGradient` verwenden, der von der Akzentfarbe zu einer transparenten Version derselben Farbe oder zur Hintergrundfarbe übergeht.
                    - `self.queue_draw()` aufrufen, wenn sich `leuchtakzent-color` oder `leuchtakzent-intensity` ändern.
- **CSS-Styling:**
    - **CSS-Knotenname:** Das `PanelWidget` (als `GtkApplicationWindow`) hat standardmäßig den CSS-Knoten `window`. Das interne Haupt-Layout-Widget (z.B. `main_box` vom Typ `gtk::Box`) hat den Knoten `box`.
    - Dem `PanelWidget` wird der CSS-Name "panelwidget" zugewiesen (`klass.set_css_name("panelwidget");`).
    - **CSS-Klassen (dynamisch und statisch):**
        - `.nova-panel` (statisch): Allgemeine Klasse für das Panel.
        - `.panel-top` / `.panel-bottom` (dynamisch): Je nach Wert der `position`-Eigenschaft.
        - `.transparent-panel` (dynamisch): Wenn `transparency-enabled` `true` ist.
        - Diese Klassen werden dem `PanelWidget` über `gtk::Widget::add_css_class()` / `gtk::Widget::remove_css_class()` zugewiesen, wenn sich die entsprechenden Eigenschaften ändern.
    - **CSS-Provider:** Die Anwendung von CSS erfolgt über einen globalen `gtk::CssProvider`, der durch ein übergeordnetes Theming-Modul (z.B. `ui::theming_gtk`) verwaltet wird. Das `PanelWidget` reagiert auf `ThemeChangedEvents` (siehe Abschnitt 2.6 Signale), um Stiländerungen zu übernehmen.

### **3. Datenstrukturen, Eigenschaften und Zustand (Spezifikation für Manus AI)**

Das `PanelWidget` wird als benutzerdefiniertes GObject-Widget implementiert, das von `gtk::ApplicationWindow` erbt.

#### **3.1. Datei: `src/ui/shell/panel_widget/mod.rs` (Öffentliche API)**

Rust

```
use gtk::glib;
use gtk::subclass::prelude::*;
use gtk::{gio, ApplicationWindow, Widget}; // Hinzugefügt für @extends und @implements
use std::cell::{Cell, RefCell}; // Für interne Veränderlichkeit in imp.rs benötigt, hier nicht direkt

mod imp; // Private Implementierung

glib::wrapper! {
    pub struct PanelWidget(ObjectSubclass<imp::PanelWidget>)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl PanelWidget {
    pub fn new(app: &gtk::Application) -> Self {
        glib::Object::builder::<Self>()
            .property("application", app)
            .build()
    }

    // ### Öffentliche Methoden zur Modulverwaltung ###

    /// Fügt ein Widget-Modul dem Panel hinzu.
    ///
    /// # Parameter
    /// * `module`: Das Widget, das als Modul hinzugefügt werden soll.
    /// * `position`: Die Position im Panel (Start, Center, End).
    /// * `order`: Die Reihenfolge des Moduls innerhalb seiner Position (kleinere Werte zuerst).
    ///
    /// `noexcept` (nicht direkt in Rust, aber Methode soll nicht paniken)
    pub fn add_module(&self, module: &impl glib::IsA<gtk::Widget>, position: imp::ModulePosition, order: i32) {
        self.imp().add_module_ordered(module, position, order);
    }

    /// Entfernt ein zuvor hinzugefügtes Modul aus dem Panel.
    ///
    /// # Parameter
    /// * `module`: Das zu entfernende Widget-Modul.
    ///
    /// `noexcept`
    pub fn remove_module(&self, module: &impl glib::IsA<gtk::Widget>) {
        self.imp().remove_module_internal(module);
    }

    // ### Öffentliche Methoden für Eigenschaften (optional, wenn GObject Properties bevorzugt) ###
    // Beispiel, falls direkte Methodenaufrufe gewünscht sind, ansonsten über Properties

    pub fn set_panel_position(&self, position: imp::PanelPosition) {
        self.set_property("position", position.to_value());
    }

    pub fn get_panel_position(&self) -> imp::PanelPosition {
        self.property("position")
    }

    pub fn set_panel_height(&self, height: i32) {
        self.set_property("panel-height", height);
    }

    pub fn get_panel_height(&self) -> i32 {
        self.property("panel-height")
    }

    pub fn set_transparency_enabled(&self, enabled: bool) {
        self.set_property("transparency-enabled", enabled);
    }

    pub fn is_transparency_enabled(&self) -> bool {
        self.property("transparency-enabled")
    }
}

// Enum Definitionen müssen hier oder in einem gemeinsamen Typmodul sein,
// damit sie in der öffentlichen API verwendet werden können.
// Für dieses Beispiel werden sie im imp-Modul deklariert und hier re-exportiert,
// oder sie sind in einem ui::shell::panel_widget::types Modul.
// pub use imp::{PanelPosition, ModulePosition}; // Falls sie in imp definiert sind

```

#### **3.2. Datei: `src/ui/shell/panel_widget/imp.rs` (Private GObject-Implementierung)**

Rust

```
use gtk::glib::{self, Properties, ParamSpec, Value, subclass::Signal};
use gtk::subclass::prelude::*;
use gtk::{CompositeTemplate, Align, Orientation as GtkOrientation, Box as GtkBox, ApplicationWindow, Widget}; // Widget hinzugefügt
use gdk::RGBA; // Für leuchtakzent-color
use std::cell::{Cell, RefCell};
use std::collections::{BTreeMap, HashMap}; // BTreeMap für geordnete Module
use once_cell::sync::Lazy;

// ### Enums für Panel-Konfiguration ###

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, glib::Enum)]
#[enum_type(name = "NovaDEPanelPosition")]
pub enum PanelPosition {
    #[default]
    Top,
    Bottom,
}

// Benötigt `glib:: القيمه` für Properties
impl From<PanelPosition> for Value {
    fn from(position: PanelPosition) -> Self {
        position.to_value()
    }
}
impl From<Value> for PanelPosition {
    fn from(value: Value) -> Self {
        glib::EnumClass::new(PanelPosition::static_type())
            .expect("PanelPosition EnumClass not found")
            .value(value.get_enum().expect("Value is not an enum"))
            .expect("Invalid PanelPosition enum value")
            .downcast::<PanelPosition>()
            .expect("Failed to downcast to PanelPosition")
            .get()
    }
}


#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, glib::Enum)]
#[enum_type(name = "NovaDEModulePosition")]
pub enum ModulePosition {
    #[default]
    Start,
    Center,
    End,
}

// Hilfsstruktur für geordnete Module
#[derive(Debug, Clone)]
struct OrderedModule {
    widget: Widget,
    order: i32,
}

// ### GObject Properties Definition ###
static PANEL_PROPERTIES: Lazy<Vec<ParamSpec>> = Lazy::new(|| {
    vec![
        ParamSpec::new_enum(
            "position",
            "Position",
            "Bildschirmkante, an der das Panel verankert ist (Oben, Unten).",
            PanelPosition::static_type(),
            PanelPosition::default() as i32, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_int(
            "panel-height",
            "Panel Height",
            "Höhe des Panels in Pixeln (Min: 24, Max: 128).",
            24, // Min
            128, // Max
            36, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_boolean(
            "transparency-enabled",
            "Transparency Enabled",
            "Gibt an, ob Transparenzeffekte für das Panel aktiv sind.",
            false, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_boxed(
            "leuchtakzent-color",
            "Leuchtakzent Color",
            "Farbe des Leuchtakzents (gdk::RGBA). Wird typischerweise vom Theming-System aktualisiert.",
            RGBA::static_type(), // Typ gdk::RGBA
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_double(
            "leuchtakzent-intensity",
            "Leuchtakzent Intensity",
            "Intensität/Opazität des Leuchtakzents (Bereich: 0.0 bis 1.0).",
            0.0, // Min
            1.0, // Max
            0.5, // Standardwert
            glib::ParamFlags::READWRITE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
    ]
});

// ### GObject Signale Definition ###
static PANEL_SIGNALS: Lazy<HashMap<String, Signal>> = Lazy::new(|| {
    let mut signals = HashMap::new();
    signals.insert(
        "module-layout-changed".to_string(),
        Signal::builder("module-layout-changed")
            .action() // Kein Rückgabewert, keine Parameter für dieses Signal
            .build(),
    );
    signals
});


#[derive(CompositeTemplate, Default)]
#[template(resource = "/org/nova_de/ui/shell/panel_widget.ui")] // Pfad zur UI-Datei
pub struct PanelWidget {
    #[template_child]
    pub main_box: TemplateChild<GtkBox>,
    #[template_child]
    pub start_box: TemplateChild<GtkBox>,
    #[template_child]
    pub center_box: TemplateChild<GtkBox>,
    #[template_child]
    pub end_box: TemplateChild<GtkBox>,

    // GObject Properties (als Felder in der Imp-Struktur)
    #[property(get, set, explicit_notify)]
    position: RefCell<PanelPosition>,
    #[property(get, set, explicit_notify)]
    panel_height: Cell<i32>,
    #[property(get, set, explicit_notify)]
    transparency_enabled: Cell<bool>,
    #[property(get, set, explicit_notify)]
    leuchtakzent_color: RefCell<Option<RGBA>>,
    #[property(get, set, explicit_notify)]
    leuchtakzent_intensity: Cell<f64>,

    // Interner Zustand für Modulverwaltung
    // Verwendet BTreeMap, um Module nach `order` und dann nach Einfügezeit (als Fallback für gleiche Order)
    // sortiert zu halten. Der innere Vec ist für den Fall, dass mehrere Widgets exakt dieselbe Order haben.
    modules_start: RefCell<BTreeMap<i32, Vec<Widget>>>,
    modules_center: RefCell<BTreeMap<i32, Vec<Widget>>>,
    modules_end: RefCell<BTreeMap<i32, Vec<Widget>>>,

    // Für benutzerdefiniertes Zeichnen des Leuchtakzents, falls CSS nicht ausreicht.
    // Wird im `constructed` initialisiert, falls benötigt.
    drawing_area_for_accent: RefCell<Option<gtk::DrawingArea>>,
}

#[glib::object_subclass]
impl ObjectSubclass for PanelWidget {
    const NAME: &'static str = "NovaDEPanelWidget";
    type Type = super::PanelWidget; // Der öffentliche Wrapper-Typ
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &mut Self::Class) {
        klass.bind_template();
        klass.install_properties(&PANEL_PROPERTIES);
        klass.install_signals(&PANEL_SIGNALS);
        klass.set_css_name("panelwidget"); // CSS-Name für das Widget
    }

    fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
        obj.init_template();
    }
}

#[glib::derived_properties]
impl ObjectImpl for PanelWidget {
    fn constructed(&self) {
        self.parent_constructed();
        let obj = self.obj(); // Der öffentliche Wrapper `super::PanelWidget`

        // Standardwerte für Properties setzen, falls nicht explizit beim Bauen angegeben
        // Diese Werte werden von den ParamSpec Defaults überschrieben, falls `glib::Object::builder()` verwendet wird.
        // Wenn direkt `PanelWidget::new()` aufgerufen wird, sind die Zell-Defaults (z.B. 0 für i32) aktiv.
        // Die ParamSpec Defaults sollten hier bevorzugt werden.
        // Die Initialisierung der RefCell/Cell-Felder mit den Property-Standardwerten erfolgt
        // implizit durch das GObject-Property-System, wenn das Objekt gebaut wird.
        // Manuelle Defaults hier sind nur nötig, wenn kein Property-System genutzt würde.

        // gtk4-layer-shell initialisieren
        obj.setup_layer_shell_internal();
        obj.update_module_layout_internal(); // Erstes Layout anwenden

        // CSS-Klassen basierend auf initialen Properties setzen
        self.update_css_classes();

        // Eventuell DrawingArea für Leuchtakzent initialisieren und verbinden, falls nötig
        // self.setup_drawing_area_for_accent();
    }

    // Implementierung der Properties Getters und Setters (automatisch durch #[property] und #[glib::derived_properties])
    // Die Logik für Property-Änderungen (z.B. LayerShell neu konfigurieren) kommt in die `set_property` Methode.

    fn set_property(&self, _id: usize, value: &Value, pspec: &ParamSpec) {
        match pspec.name() {
            "position" => {
                let new_position = value.get::<PanelPosition>().expect("Value must be PanelPosition");
                self.position.replace(new_position);
                self.obj().setup_layer_shell_internal(); // Layer Shell neu konfigurieren
                self.update_css_classes();
                self.obj().notify_position(); // Benachrichtigung für diese Eigenschaft
            }
            "panel-height" => {
                let new_height = value.get::<i32>().expect("Value must be i32");
                // Validierung gegen Min/Max aus ParamSpec (automatisch durch GObject, aber man könnte hier zusätzlich prüfen)
                self.panel_height.set(new_height);
                self.obj().set_default_height(new_height); // Fensterhöhe anpassen
                self.main_box.set_height_request(new_height);
                // Ggf. DrawingArea Höhe anpassen
                self.obj().queue_draw(); // Neuzeichnen anfordern
                self.obj().notify_panel_height();
            }
            "transparency-enabled" => {
                let enabled = value.get::<bool>().expect("Value must be bool");
                self.transparency_enabled.set(enabled);
                self.update_transparency_visual_internal();
                self.update_css_classes();
                self.obj().notify_transparency_enabled();
            }
            "leuchtakzent-color" => {
                // Option<RGBA> muss vorsichtig gehandhabt werden
                let color_opt = value.get::<Option<RGBA>>().expect("Value must be Option<RGBA> or None");
                self.leuchtakzent_color.replace(color_opt);
                self.obj().queue_draw(); // Neuzeichnen für Akzent
                self.obj().notify_leuchtakzent_color();
            }
            "leuchtakzent-intensity" => {
                let intensity = value.get::<f64>().expect("Value must be f64");
                self.leuchtakzent_intensity.set(intensity.clamp(0.0, 1.0)); // Sicherstellen, dass im Bereich
                self.obj().queue_draw();
                self.obj().notify_leuchtakzent_intensity();
            }
            _ => unimplemented!(),
        }
    }
}

impl WidgetImpl for PanelWidget {
    fn map(&self) {
        self.parent_map();
        // Sicherstellen, dass Layer Shell korrekt initialisiert ist, bevor das Fenster angezeigt wird
        self.obj().setup_layer_shell_internal();
    }

    fn size_allocate(&self, width: i32, height: i32, baseline: i32) {
        self.parent_size_allocate(width, height, baseline);
        // Ggf. Layout der internen Boxen hier anpassen oder DrawingArea Größe
        // Dies ist wichtig, wenn sich die Panel-Breite ändert (z.B. Multi-Monitor-Setup Wechsel)
    }

    // Falls benutzerdefiniertes Zeichnen für Akzent via DrawingArea:
    // fn snapshot(&self, snapshot: &gtk::Snapshot) {
    //     self.parent_snapshot(snapshot);
    //     // Hier könnte man den Akzent zeichnen, wenn er nicht Teil eines Kind-Widgets ist.
    // }
}

impl WindowImpl for PanelWidget {
    // Fenster-spezifische Implementierungen, z.B. Schließen-Verhalten
}

impl ApplicationWindowImpl for PanelWidget {}

// ### Interne Implementierungsmethoden für PanelWidget ###
impl PanelWidget {
    fn update_css_classes(&self) {
        let obj = self.obj();
        if *self.position.borrow() == PanelPosition::Top {
            obj.remove_css_class("panel-bottom");
            obj.add_css_class("panel-top");
        } else {
            obj.remove_css_class("panel-top");
            obj.add_css_class("panel-bottom");
        }

        if self.transparency_enabled.get() {
            obj.add_css_class("transparent-panel");
        } else {
            obj.remove_css_class("transparent-panel");
        }
    }

    fn update_transparency_visual_internal(&self) {
        let obj = self.obj();
        let visual = if self.transparency_enabled.get() {
            obj.display().rgba_visual()
        } else {
            // Zurück zum System-Standard-Visual (oder None, wenn das Fenster sowieso opak sein soll)
            obj.display().default_visual(&obj.surface().unwrap_or_else(|| obj.create_surface(obj.width(), obj.height(), None)))
        };
        obj.set_visual(visual.as_ref());
        obj.queue_draw(); // Neuzeichnen anfordern, da sich das Visual geändert hat
    }

    // Wird vom öffentlichen add_module aufgerufen
    pub(super) fn add_module_ordered(&self, module: &impl glib::IsA<gtk::Widget>, position: ModulePosition, order: i32) {
        let module_widget = module.clone().upcast::<Widget>();
        let modules_map = match position {
            ModulePosition::Start => &self.modules_start,
            ModulePosition::Center => &self.modules_center,
            ModulePosition::End => &self.modules_end,
        };

        let mut map_guard = modules_map.borrow_mut();
        map_guard.entry(order).or_default().push(module_widget);

        self.obj().update_module_layout_internal();
        self.obj().emit_by_name::<()>("module-layout-changed", &[]);
    }

    // Wird vom öffentlichen remove_module aufgerufen
    pub(super) fn remove_module_internal(&self, module_to_remove: &impl glib::IsA<gtk::Widget>) {
        let widget_ptr_to_remove = module_to_remove.as_ref().to_glib_none().0;
        let mut changed = false;

        for modules_map_refcell in [&self.modules_start, &self.modules_center, &self.modules_end] {
            let mut map_guard = modules_map_refcell.borrow_mut();
            for (_order, widgets_in_order) in map_guard.iter_mut() {
                let initial_len = widgets_in_order.len();
                widgets_in_order.retain(|m| m.to_glib_none().0 != widget_ptr_to_remove);
                if widgets_in_order.len() < initial_len {
                    changed = true;
                    break; // Modul gefunden und entfernt
                }
            }
            if changed { break; }
        }

        if changed {
            // Physisches Entfernen aus den GtkBox-Containern
            if let Some(parent_box) = module_to_remove.as_ref().parent().and_then(|p| p.downcast::<GtkBox>().ok()){
                parent_box.remove(module_to_remove.as_ref());
            }
            self.obj().update_module_layout_internal();
            self.obj().emit_by_name::<()>("module-layout-changed", &[]);
        }
    }
}

// ### Öffentliche Methoden, die von der `imp`-Struktur für den Wrapper bereitgestellt werden ###
// Diese sind jetzt im `PanelWidget`-Block in `mod.rs` implementiert oder werden
// durch GObject-Properties gehandhabt. Die `setup_layer_shell_internal` und
// `update_module_layout_internal` sind die Kernmethoden, die der Wrapper aufruft.
impl super::PanelWidget { // Bezieht sich auf den öffentlichen Wrapper
    fn setup_layer_shell_internal(&self) {
        let imp = self.imp();
        gtk_layer_shell::init_for_window(self);
        gtk_layer_shell::set_layer(self, gtk_layer_shell::Layer::Top);
        // Panels benötigen i.d.R. keinen direkten Fokus, außer ihre Kindelemente
        gtk_layer_shell::set_keyboard_mode(self, gtk_layer_shell::KeyboardMode::OnDemand); // Oder None, wenn Module Fokus explizit anfordern
        gtk_layer_shell::auto_exclusive_zone_enable(self); // Platz reservieren
        gtk_layer_shell::set_namespace(self, "NovaDEPanel");

        let position_val = *imp.position.borrow();
        match position_val {
            PanelPosition::Top => {
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Top, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Left, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Right, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Bottom, false);
            }
            PanelPosition::Bottom => {
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Bottom, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Left, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Right, true);
                gtk_layer_shell::set_anchor(self, gtk_layer_shell::Edge::Top, false);
            }
        }
        self.set_default_height(imp.panel_height.get());
        // Margins könnten hier auch gesetzt werden, falls gewünscht, z.B. um das Panel leicht vom Rand abzusetzen
        // gtk_layer_shell::set_margin(self, gtk_layer_shell::Edge::Top, 5);
        // gtk_layer_shell::set_margin(self, gtk_layer_shell::Edge::Left, 5);
        // gtk_layer_shell::set_margin(self, gtk_layer_shell::Edge::Right, 5);
    }

    fn update_module_layout_internal(&self) {
        let imp = self.imp();

        // Helferfunktion zum Leeren und Befüllen einer Box
        let repopulate_box = |target_box: &GtkBox, modules_map_refcell: &RefCell<BTreeMap<i32, Vec<Widget>>>| {
            while let Some(child) = target_box.first_child() {
                target_box.remove(&child);
            }
            let map_guard = modules_map_refcell.borrow();
            for (_order, widgets_in_order) in map_guard.iter() { // BTreeMap iteriert über Schlüssel (order) sortiert
                for widget in widgets_in_order {
                    target_box.append(widget);
                }
            }
        };

        repopulate_box(&imp.start_box, &imp.modules_start);
        repopulate_box(&imp.center_box, &imp.modules_center);
        repopulate_box(&imp.end_box, &imp.modules_end);
    }
}
```

#### **3.3. UI-Definitionsdatei: `resources/ui/shell/panel_widget.ui`**

XML

```
<?xml version="1.0" encoding="UTF-8"?>
<interface>
  <requires lib="gtk" version="4.0"/>
  <template class="NovaDEPanelWidget" parent="GtkApplicationWindow">
    <property name="title" translatable="yes">NovaDE Panel</property>
    <property name="decorated">false</property>
    <child>
      <object class="GtkBox" id="main_box">
        <property name="orientation">horizontal</property>
        <property name="halign">fill</property>
        <property name="valign">fill</property> <property name="spacing">6</property> <style>
          <class name="nova-panel-main-box"/>
        </style>
        <child>
          <object class="GtkBox" id="start_box">
            <property name="orientation">horizontal</property>
            <property name="halign">start</property>
            <property name="valign">center</property>
            <property name="spacing">6</property> <style>
              <class name="nova-panel-start-box"/>
            </style>
            </object>
        </child>
        <child>
          <object class="GtkBox" id="center_box">
            <property name="orientation">horizontal</property>
            <property name="halign">center</property>
            <property name="valign">center</property>
            <property name="hexpand">true</property> <property name="spacing">6</property>
            <style>
              <class name="nova-panel-center-box"/>
            </style>
            </object>
        </child>
        <child>
          <object class="GtkBox" id="end_box">
            <property name="orientation">horizontal</property>
            <property name="halign">end</property>
            <property name="valign">center</property>
            <property name="spacing">6</property>
            <style>
              <class name="nova-panel-end-box"/>
            </style>
            </object>
        </child>
      </object>
    </child>
  </template>
</interface>
```

#### **3.4. GObject-Eigenschaften (Zusammenfassung)**

|Eigenschaftsname|Rust-Feld (Imp)|Typ (Rust / GLib)|Zugriff|Standardwert|Beschreibung|
|:--|:--|:--|:--|:--|:--|
|`application`|(Parent-Eigenschaft)|`gtk::Application`|R/W/C|N/A|Die `gtk::Application`, zu der das Fenster gehört.|
|`position`|`position`|`PanelPosition` / Enum|R/W|`Top`|Bildschirmkante für das Panel (Oben, Unten).|
|`panel-height`|`panel_height`|`i32` / GINT|R/W|36|Höhe des Panels in Pixeln (Min: 24, Max: 128).|
|`transparency-enabled`|`transparency_enabled`|`bool` / GBOOLEAN|R/W|`false`|Aktiviert/Deaktiviert Transparenzeffekte.|
|`leuchtakzent-color`|`leuchtakzent_color`|`Option<gdk::RGBA>` / GBoxed|R/W|`None`|Farbe des Leuchtakzents.|
|`leuchtakzent-intensity`|`leuchtakzent_intensity`|`f64` / GDOUBLE|R/W|0.5|Intensität des Leuchtakzents (0.0-1.0).|

In Google Sheets exportieren

_R=Read, W=Write, C=Construct-Only_

#### **3.5. Interner Zustand (Felder in `PanelWidgetImp`)**

- `main_box: TemplateChild<GtkBox>`: Hauptcontainer für die drei Modulbereiche.
- `start_box: TemplateChild<GtkBox>`: Container für Module am Anfang (links bei LTR-Layout).
- `center_box: TemplateChild<GtkBox>`: Container für Module in der Mitte. `hexpand = true`.
- `end_box: TemplateChild<GtkBox>`: Container für Module am Ende (rechts bei LTR-Layout).
- `position: RefCell<PanelPosition>`: Speichert die aktuelle Panel-Position.
- `panel_height: Cell<i32>`: Speichert die aktuelle Panel-Höhe.
- `transparency_enabled: Cell<bool>`: Speichert den Transparenzstatus.
- `leuchtakzent_color: RefCell<Option<RGBA>>`: Speichert die Akzentfarbe.
- `leuchtakzent_intensity: Cell<f64>`: Speichert die Akzentintensität.
- `modules_start: RefCell<BTreeMap<i32, Vec<Widget>>>`: Geordnete Map von Modulen für den Startbereich. Schlüssel ist `order`.
- `modules_center: RefCell<BTreeMap<i32, Vec<Widget>>>`: Geordnete Map von Modulen für den Mittelbereich.
- `modules_end: RefCell<BTreeMap<i32, Vec<Widget>>>`: Geordnete Map von Modulen für den Endbereich.
- `drawing_area_for_accent: RefCell<Option<gtk::DrawingArea>>`: (Optional) Für benutzerdefiniertes Zeichnen des Akzents.

### **4. GTK-Widget-Implementierungsstrategie (Spezifikation für Manus AI)**

- **Basis-Widget:** Das `PanelWidget` erbt von `gtk::ApplicationWindow`. Diese Wahl ist entscheidend für die Integration mit `gtk4-layer-shell`, da dessen Funktionen (`init_for_window`, `set_layer`, `set_anchor`, `auto_exclusive_zone_enable` etc.) auf einem `gtk::Window` operieren.
- **Initialisierung von `gtk4-layer-shell`:**
    - `gtk_layer_shell::init_for_window(self_wrapper)`: Muss im `constructed`-Handler oder vor dem ersten `map`-Ereignis des Fensters aufgerufen werden.
    - `gtk_layer_shell::set_layer(self_wrapper, gtk_layer_shell::Layer::Top)`: Positioniert das Panel über normalen Anwendungsfenstern.
    - `gtk_layer_shell::set_keyboard_mode(self_wrapper, gtk_layer_shell::KeyboardMode::OnDemand)`: Erlaubt dem Panel oder seinen Kindern, Tastaturfokus zu erhalten, wenn sie ihn anfordern. `None` wäre auch eine Option, wenn Module den Fokus nicht benötigen oder ihn selbst über andere Mechanismen (wie Popovers) handhaben.
    - `gtk_layer_shell::auto_exclusive_zone_enable(self_wrapper)`: Sorgt dafür, dass das Panel Platz auf dem Bildschirm reserviert und andere maximierte Fenster nicht verdeckt.
    - `gtk_layer_shell::set_namespace(self_wrapper, "NovaDEPanel")`: Setzt einen eindeutigen Namespace für das Panel.
    - **Ankerpunkte (`set_anchor`):** Basierend auf der `position`-Eigenschaft werden die Anker gesetzt:
        - `PanelPosition::Top`: `Top=true, Left=true, Right=true, Bottom=false`.
        - `PanelPosition::Bottom`: `Bottom=true, Left=true, Right=true, Top=false`.
- **Internes Layout (Composite Template):**
    - Die interne Struktur des `PanelWidget` wird über eine UI-Datei (`panel_widget.ui`) definiert und als `CompositeTemplate` geladen.
    - **`main_box` (`GtkBox`, Orientation: Horizontal):** Dient als Hauptcontainer. Erstreckt sich über die gesamte Breite und Höhe des Panel-Fensters.
    - **`start_box` (`GtkBox`, Orientation: Horizontal):** Nimmt Module auf, die am Anfang (links) des Panels positioniert sind. `halign = GtkAlign::Start`.
    - **`center_box` (`GtkBox`, Orientation: Horizontal):** Nimmt Module auf, die in der Mitte des Panels positioniert sind. `halign = GtkAlign::Center`, `hexpand = true` (damit dieser Bereich den verfügbaren Platz ausfüllt).
    - **`end_box` (`GtkBox`, Orientation: Horizontal):** Nimmt Module auf, die am Ende (rechts) des Panels positioniert sind. `halign = GtkAlign::End`.
    - Alle drei Boxen (`start_box`, `center_box`, `end_box`) haben `valign = GtkAlign::Center`, um die Module vertikal zu zentrieren.
    - Ein Abstand (`spacing`) zwischen den Boxen und zwischen den Modulen innerhalb der Boxen kann in der `.ui`-Datei oder programmatisch gesetzt werden.
- **Benutzerdefiniertes Zeichnen:** Implementierung erfolgt wie unter Abschnitt 2 beschrieben, falls notwendig.

### **5. Methoden und Funktionssignaturen (Interne und Wrapper-Logik)**

#### **5.1. Interne Methoden (in `PanelWidgetImp`)**

- `fn update_css_classes(&self)`: Aktualisiert die CSS-Klassen des Wrapper-Widgets basierend auf den aktuellen Werten von `position` und `transparency_enabled`.
- `fn update_transparency_visual_internal(&self)`: Stellt das `GdkVisual` des Fensters um, um Transparenz zu aktivieren/deaktivieren.
- `pub(super) fn add_module_ordered(&self, module: &impl glib::IsA<gtk::Widget>, position: ModulePosition, order: i32)`:
    1. Fügt das `module` der entsprechenden internen `BTreeMap` (`modules_start`, `modules_center`, `modules_end`) unter dem Schlüssel `order` hinzu. Wenn bereits Module mit derselben `order` existieren, wird das neue Modul an die `Vec<Widget>` für diese `order` angehängt.
    2. Ruft `self.obj().update_module_layout_internal()` auf.
    3. Emittiert das `module-layout-changed`-Signal.
- `pub(super) fn remove_module_internal(&self, module_to_remove: &impl glib::IsA<gtk::Widget>)`:
    1. Durchsucht alle drei Modul-Maps (`modules_start`, `modules_center`, `modules_end`).
    2. Entfernt das `module_to_remove` (Vergleich über Widget-Zeiger oder eine eindeutige ID, falls Module IDs haben) aus der entsprechenden `BTreeMap` und der zugehörigen `Vec<Widget>`.
    3. Wenn das Modul entfernt wurde:
        - Entfernt das Widget physisch aus dem Eltern-`GtkBox`-Container (`start_box`, `center_box` oder `end_box`).
        - Ruft `self.obj().update_module_layout_internal()` auf.
        - Emittiert das `module-layout-changed`-Signal.

#### **5.2. Methoden des öffentlichen Wrappers (`super::PanelWidget`)**

- `fn setup_layer_shell_internal(&self)`: Führt die Konfiguration von `gtk4-layer-shell` durch, wie in Abschnitt 4 beschrieben. Wird bei der Initialisierung und bei Änderungen der `position`-Eigenschaft aufgerufen.
- `fn update_module_layout_internal(&self)`:
    1. Leert alle drei `GtkBox`-Container (`start_box`, `center_box`, `end_box`), indem alle existierenden Kinder entfernt werden.
    2. Iteriert über die sortierten Module in `imp.modules_start.borrow()` (BTreeMap iteriert Schlüssel sortiert). Für jede `order`, iteriere über die `Vec<Widget>` und füge jedes Widget der `imp.start_box` hinzu (`append`).
    3. Wiederholt Schritt 2 für `imp.modules_center` und `imp.center_box`.
    4. Wiederholt Schritt 2 für `imp.modules_end` und `imp.end_box`.

### **6. Signale (Spezifikation für Manus AI)**

#### **6.1. Emittierte Signale**

- **Signal: `module-layout-changed`**
    - **GObject Signal Name:** `module-layout-changed`
    - **Parameter:** Keine.
    - **Signal-Flags:** `glib::SignalFlags::ACTION` (oder `RUN_FIRST`/`RUN_LAST` je nach Bedarf).
    - **Beschreibung:** Wird emittiert, nachdem Module dem Panel hinzugefügt, daraus entfernt oder ihre Anordnung (durch `update_module_layout_internal`) geändert wurde.
    - **Zweck:** Ermöglicht anderen UI-Komponenten oder Logikmodulen, auf Änderungen im Panel-Layout zu reagieren, z.B. um Größen neu zu berechnen oder Fokus-Reihenfolgen anzupassen.
    - **Auslöser:** Aufruf von `add_module_ordered` oder `remove_module_internal` nach erfolgreicher Modifikation und Layout-Aktualisierung.

#### **6.2. Verbundene Signale (Reaktionen auf externe Events)**

- **Event:** `ThemeChangedEvent` (aus `domain::theming::ThemingEngine`)
    - **Handler-Aktion im `PanelWidget`:**
        1. Die neuen Design-Tokens aus dem `ThemeChangedEvent.new_state.resolved_tokens` extrahieren, die für das Panel relevant sind (insbesondere die Werte für `--leuchtakzent-color-rgba` und `--leuchtakzent-intensity-css`).
        2. Die GObject-Eigenschaften `leuchtakzent-color` und `leuchtakzent-intensity` des `PanelWidget` entsprechend aktualisieren (z.B. `self.set_leuchtakzent_color(Some(parsed_rgba_from_token))`).
        3. `self.queue_draw()` aufrufen, um ein Neuzeichnen des Panels (und des Akzents) zu erzwingen.
- **Signale von `gtk::Settings::default()`:**
    - `notify::gtk-theme-name`:
        - **Handler-Aktion:** Kann verwendet werden, um panel-spezifisches CSS neu zu laden oder Stile anzupassen, falls das Panel-Design stark vom System-GTK-Theme abhängt und nicht vollständig durch das NovaDE-Theming-System abgedeckt wird. Für NovaDE wird primär das eigene Theming-System verwendet, daher ist dies eher ein Fallback.
    - `notify::gtk-application-prefer-dark-theme`:
        - **Handler-Aktion:** Ähnlich wie bei `gtk-theme-name`. Wenn das NovaDE-Theming-System die Light/Dark-Modi nicht vollständig über `ThemeChangedEvent` steuert, kann hierauf reagiert werden, um z.B. CSS-Klassen für Dark Mode zu setzen/entfernen.

### **7. Ereignisbehandlung (Benutzerinteraktion)**

- Das `PanelWidget` selbst ist primär ein Container und reagiert nicht direkt auf komplexe Maus- oder Tastaturereignisse.
- Mausereignisse wie `enter-notify-event` und `leave-notify-event` könnten theoretisch für Tooltips auf dem Panel selbst verwendet werden, aber Tooltips sind eher für die einzelnen Module relevant.
- Der Tastaturfokus wird von den fokussierbaren Modulen innerhalb des Panels verwaltet, nicht vom Panel selbst.

### **8. Interaktionen mit anderen Komponenten/Modulen**

- **`domain::global_settings_and_state_management` (GlobalSettingsService):**
    - Das `PanelWidget` liest beim Start (oder bei Änderungen) seine Konfiguration (z.B. Standardposition, Standardhöhe, initiale Transparenz, welche Module standardmäßig geladen werden sollen) vom `GlobalSettingsService`.
    - Änderungen an diesen Einstellungen im `GlobalSettingsService` (z.B. durch `ui::control_center`) sollten ein `SettingChangedEvent` auslösen, auf das das `PanelWidget` reagiert, um seine GObject-Properties dynamisch anzupassen.
- **`system::compositor` (indirekt über `gtk4-layer-shell`):**
    - Die primäre Interaktion erfolgt über die `gtk4-layer-shell`-Bibliothek, um das Panel als Layer-Oberfläche im Wayland-Compositor zu positionieren und zu verwalten.
- **`domain::theming::ThemingEngine`:**
    - Das `PanelWidget` abonniert das `ThemeChangedEvent` der `ThemingEngine`, um Design-Tokens (insbesondere für `leuchtakzent-color` und Hintergrundstile) zu erhalten und anzuwenden.

### **9. Ausnahmebehandlung (Fehlerdefinitionen)**

Für das `PanelWidget`-Modul selbst werden spezifische Fehler mittels `thiserror` definiert, falls Operationen fehlschlagen können, die nicht durch GTK-interne Fehler abgedeckt sind.

- **Datei:** `src/ui/shell/panel_widget/error.rs`
    
- **Enum `PanelWidgetError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use gtk::glib; // Für glib::Error
    
    #[derive(Debug, Error)]
    pub enum PanelWidgetError {
        #[error("Fehler bei der Initialisierung der gtk-layer-shell: {0}")]
        LayerShellInitializationFailed(String), // Enthält Details des Fehlers
    
        #[error("Fehler beim Laden des UI-Templates für PanelWidget: {source}")]
        TemplateLoadError { #[from] source: glib::Error },
    
        #[error("Ungültige Modulposition angegeben: {position:?}")]
        InvalidModulePosition { position: super::imp::ModulePosition }, // super::imp verweist auf PanelWidgetImp
    
        #[error("Modul konnte nicht zum Panel hinzugefügt werden: {reason}")]
        ModuleAddFailed { reason: String },
    
        #[error("Modul konnte nicht vom Panel entfernt werden: {reason}")]
        ModuleRemoveFailed { reason: String },
    }
    ```
    
- **Verwendung:** Methoden wie `add_module_ordered` oder `remove_module_internal` könnten `Result<(), PanelWidgetError>` zurückgeben, obwohl in der GTK-Welt Fehler oft durch Signale oder Logging behandelt werden, anstatt Result-Typen in Widget-APIs zu verwenden. Für kritische Setup-Fehler ist `Result` jedoch angemessen. `gtk_layer_shell`-Funktionen geben keine direkten `Result`-Typen zurück, Fehler hier würden eher zu Panics oder visuellen Problemen führen; `LayerShellInitializationFailed` wäre also ein interner Fehler, der geloggt wird, falls die Initialisierung visuell fehlschlägt.
    

### **10. Auflösung "Untersuchungsbedarf" (aus dem Quelldokument)**

Der "Untersuchungsbedarf" bezüglich `gtk4-layer-shell`-Integration und Implementierung des "Leuchtakzents" wurde in den Abschnitten 2, 4 und 8 dieser Spezifikation adressiert.

- **Best Practices `gtk4-layer-shell`:** Initialisierung vor dem `map`-Ereignis, korrekte Wahl des `KeyboardMode`, Setzen eines Namespace, Ankerung für Positionierung und `auto_exclusive_zone_enable` sind spezifiziert. Multi-Monitor-Szenarien erfordern separate `PanelWidget`-Instanzen pro Monitor, die über Änderungen in der Monitorkonfiguration (`gdk::Display` Signale) verwaltet werden.
- **Implementierung "Leuchtakzent":** Präferenz für CSS `box-shadow`. Falls unzureichend, benutzerdefiniertes Zeichnen mit Cairo auf einer `gtk::DrawingArea` oder direkt im Panel-Fenster (unter Verwendung von `set_draw_func` für Widgets oder Snapshot-Funktion für komplexere Fälle). Details zur Verwendung von `gdk::RGBA`, `cairo::LinearGradient` und Transparenz sind spezifiziert.

### **11. Dateistruktur (Zusammenfassung)**

- `src/ui/shell/panel_widget/mod.rs` (Öffentliche API, GObject Wrapper)
- `src/ui/shell/panel_widget/imp.rs` (Private GObject Implementierung, Logik)
- `src/ui/shell/panel_widget/error.rs` (Spezifische Fehlerdefinitionen)
- `resources/ui/shell/panel_widget.ui` (XML-Definition für Composite Template)

Diese Struktur fördert Modularität und Trennung von Belangen.

**Nächster Schritt:** Detaillierte Spezifikation für `ui::shell::panel_widget::AppMenuButton`.

# **UI-Schicht: Ultra-Feinspezifikation und Implementierungsleitfaden**

## **Modul: ui::shell::panel_widget::AppMenuButton (Anwendungsmenü-Button)**

### **1. Modul-Identifikation und Zweck**

- **Modul-ID:** `ui::shell::panel_widget::AppMenuButton`
- **Übergeordnetes Modul:** `ui::shell::PanelWidget`
- **Abhängigkeiten:**
    - `novade-core`
    - `novade-domain` (potenziell für das Abrufen von Anwendungsmetadaten, falls nicht direkt über Systemschicht)
    - `novade-system` (insbesondere `system::compositor` für Informationen zum aktiven Fenster/AppID und `system::dbus` für die `org.gtk.Menus`-Schnittstelle)
    - `gtk4-rs` (GTK4 Rust Bindings)
    - `zbus` (für direkte D-Bus-Kommunikation, falls nicht vollständig von `novade-system` abstrahiert)
    - `once_cell`
    - `thiserror`
    - `tracing`
- **Zweck:** Das `AppMenuButton` ist ein spezialisiertes Panel-Modul, das als `gtk::MenuButton` (oder eine benutzerdefinierte Ableitung) implementiert wird. Seine Hauptverantwortung ist die Darstellung des globalen Anwendungsmenüs (typischerweise `GMenuModel`) der aktuell fokussierten Applikation. Es muss die aktive Anwendung identifizieren, deren Menümodell über D-Bus abrufen und dieses in einem `gtk::PopoverMenu` darstellen. Das Aussehen des Buttons (Icon, Name) wird dynamisch an die aktive Anwendung angepasst.

### **2. Visuelles Design und Theming (Spezifikation für Manus AI)**

- **Darstellung als Button:**
    - Standardmäßig wird das Icon der aktiven Anwendung angezeigt (`gtk::Image` im `gtk::MenuButton`).
    - **Fallback-Icon:** Wenn kein Anwendungsicon verfügbar ist oder keine Anwendung ein Menü bereitstellt, wird ein generisches "Anwendungsmenü"-Icon angezeigt (z.B. `application-menu-symbolic`).
    - **Beschriftung (Label):** Optional kann der Name der aktiven Anwendung (`gtk::Label`) neben dem Icon angezeigt werden. Dies ist konfigurierbar (z.B. über eine globale Einstellung) und hängt vom verfügbaren Platz im Panel ab. Standardmäßig wird nur das Icon angezeigt, um Platz zu sparen.
- **Tooltip:** Der Tooltip des `AppMenuButton` zeigt immer den Namen der aktiven Anwendung an, auch wenn dieser nicht als Label sichtbar ist (`gtk::Widget::set_tooltip_text()`).
- **PopoverMenu:** Beim Klick auf den Button wird ein `gtk::PopoverMenu` angezeigt, das die Menüeinträge des `GMenuModel` der aktiven Anwendung enthält. Das Styling dieses Popovers folgt dem globalen Theme.
- **Styling (CSS):**
    - **CSS-Knotenname:** `menubutton` (wenn von `gtk::MenuButton` geerbt) oder `button` (wenn eine benutzerdefinierte Schaltfläche mit manuellem Popover verwendet wird). Das Widget selbst bekommt den CSS-Namen `appmenubutton` (`klass.set_css_name("appmenubutton");`).
    - **CSS-Klassen (dynamisch):**
        - `.app-menu-button` (statisch): Allgemeine Klasse für spezifisches Styling.
        - `.active-app-menu` (dynamisch): Wird gesetzt, wenn ein Anwendungsmenü erfolgreich geladen und an den Button gebunden wurde.
        - `.no-app-menu` (dynamisch): Wird gesetzt, wenn kein Menü für die aktive Anwendung verfügbar ist, keine Anwendung fokussiert ist oder ein Fehler beim Laden des Menüs aufgetreten ist.
        - `.loading-app-menu` (dynamisch): Wird gesetzt, während das Menü aktiv geladen wird. Dies kann für ein visuelles Feedback (z.B. Spinner-ähnliche Zustandsänderung) genutzt werden.
- **Zustandsabhängiges Aussehen:**
    - **Kein Menü / Fehler:** Button könnte leicht ausgegraut oder mit einem speziellen Indikator versehen sein.
    - **Laden:** Ein subtiler Ladeindikator könnte angezeigt werden (z.B. pulsierendes Icon).

### **3. Datenstrukturen, Eigenschaften und Zustand (Spezifikation für Manus AI)**

Das `AppMenuButton` wird als benutzerdefiniertes GObject-Widget implementiert, das von `gtk::MenuButton` erbt.

#### **3.1. Datei: `src/ui/shell/panel_widget/app_menu_button/mod.rs` (Öffentliche API)**

Rust

```
use gtk::glib;
use gtk::subclass::prelude::*;
use gtk::{gio, MenuButton, Widget}; // Widget für IsA

mod imp;

glib::wrapper! {
    pub struct AppMenuButton(ObjectSubclass<imp::AppMenuButton>)
        @extends gtk::MenuButton, gtk::Button, gtk::Widget, // gtk::Button hinzugefügt
        @implements gtk::Accessible, gtk::Actionable, gtk::Buildable, gtk::ConstraintTarget;
}

impl AppMenuButton {
    pub fn new() -> Self {
        glib::Object::builder::<Self>().build()
    }

    /// Aktualisiert die Informationen über das aktive Fenster und löst ggf. eine Menüaktualisierung aus.
    /// Diese Methode wird typischerweise von einem übergeordneten Shell-Dienst aufgerufen,
    /// der Änderungen des Fensterfokus überwacht.
    ///
    /// # Parameter
    /// * `app_id`: Optionale ID der aktiven Anwendung (z.B. "org.gnome.TextEditor").
    /// * `app_name`: Optionaler Anzeigename der aktiven Anwendung.
    /// * `icon_name`: Optionaler Icon-Name der aktiven Anwendung.
    ///
    /// `noexcept`
    pub fn update_active_window_info(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>) {
        self.imp().update_active_window_info_internal(app_id, app_name, icon_name);
    }

    // Methode, um das Menü explizit neu zu laden (z.B. bei manueller Aktion oder Fehlerwiederholung)
    pub fn refresh_menu(&self) {
        self.imp().trigger_menu_update_for_current_app_internal();
    }
}

impl Default for AppMenuButton {
    fn default() -> Self {
        Self::new()
    }
}
```

#### **3.2. Datei: `src/ui/shell/panel_widget/app_menu_button/imp.rs` (Private GObject-Implementierung)**

Rust

```
use gtk::glib::{self, Properties, ParamSpec, Value, subclass::Signal, Bytes};
use gtk::subclass::prelude::*;
use gtk::{gio, MenuButton, Button, Widget, Image, Label, Box as GtkBox, Orientation, PopoverMenu, Align};
use std::cell::{Cell, RefCell};
use std::sync::Arc; // Für zbus Connection
use once_cell::sync::Lazy;
use zbus::Connection; // Für D-Bus Kommunikation
use tracing;

use crate::ui::shell::panel_widget::app_menu_button::error::AppMenuButtonError; // Error-Typ

// ### Enums für internen Zustand ###
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub enum MenuFetchStatus {
    #[default]
    Idle, // Noch kein Versuch unternommen oder zurückgesetzt
    Loading, // Menü wird gerade über D-Bus geladen
    Success, // Menü erfolgreich geladen
    NoMenuAvailable, // Anwendung hat kein Menü oder D-Bus-Dienst nicht gefunden
    Error(AppMenuButtonError), // Ein spezifischer Fehler ist aufgetreten
}

// Notwendig für Speicherung in GObject Property, falls der Status als Property verfügbar gemacht wird
// impl ToValue for MenuFetchStatus { ... }
// impl FromValue for MenuFetchStatus { ... }

// ### GObject Properties Definition ###
static APP_MENU_BUTTON_PROPERTIES: Lazy<Vec<ParamSpec>> = Lazy::new(|| {
    vec![
        ParamSpec::new_string(
            "active-app-name",
            "Active Application Name",
            "Name der Anwendung, deren Menü angezeigt wird oder angezielt ist.",
            None, // Kein Default-Wert, da dynamisch
            glib::ParamFlags::READABLE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_string(
            "active-app-icon-name",
            "Active Application Icon Name",
            "Icon-Name der Anwendung, deren Menü angezielt ist.",
            None,
            glib::ParamFlags::READABLE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        ParamSpec::new_boolean(
            "has-menu",
            "Has Menu",
            "true, wenn ein Menü für die aktive Anwendung verfügbar und geladen ist.",
            false, // Default
            glib::ParamFlags::READABLE | glib::ParamFlags::EXPLICIT_NOTIFY,
        ),
        // Potenziell eine Property für MenuFetchStatus, aber String oder Int Enum wäre einfacher für GObject
    ]
});

#[derive(Default)]
pub struct AppMenuButton {
    // UI-Elemente (falls nicht über CompositeTemplate)
    // Stattdessen als Teil des MenuButton-Parents oder im Popover
    button_content_box: RefCell<Option<GtkBox>>, // Box für Icon und Label
    app_icon_widget: RefCell<Option<Image>>,
    app_name_widget: RefCell<Option<Label>>,
    popover_menu: RefCell<Option<PopoverMenu>>,

    // GObject Properties
    #[property(get, explicit_notify)]
    active_app_name: RefCell<Option<String>>,
    #[property(get, explicit_notify)]
    active_app_icon_name: RefCell<Option<String>>,
    #[property(get, explicit_notify)]
    has_menu: Cell<bool>,

    // Interner Zustand
    active_app_id_internal: RefCell<Option<String>>, // Unterscheidung zum Property für interne Nutzung
    menu_fetch_status_internal: RefCell<MenuFetchStatus>,
    current_menu_model_internal: RefCell<Option<gio::MenuModel>>,
    dbus_connection: RefCell<Option<Arc<Connection>>>, // Arc für Teilen mit async Tasks

    // Service-Abhängigkeit (von ui::shell oder Systemschicht)
    // Annahme: Ein Dienst liefert aktive Fensterinformationen und D-Bus-Verbindung
    // active_window_monitor: RefCell<Option<Arc<dyn ActiveWindowMonitoringService>>>,
    // Wird hier vereinfacht durch direkte D-Bus-Nutzung und Aufruf von update_active_window_info
}

#[glib::object_subclass]
impl ObjectSubclass for AppMenuButton {
    const NAME: &'static str = "NovaDEAppMenuButton";
    type Type = super::AppMenuButton; // Der öffentliche Wrapper
    type ParentType = gtk::MenuButton;

    fn class_init(klass: &mut Self::Class) {
        klass.install_properties(&APP_MENU_BUTTON_PROPERTIES);
        klass.set_css_name("appmenubutton");
    }
}

#[glib::derived_properties]
impl ObjectImpl for AppMenuButton {
    fn constructed(&self) {
        self.parent_constructed();
        let obj = self.obj(); // Der öffentliche Wrapper `super::AppMenuButton`

        // Standard-Icon und Popover setzen
        let icon = Image::from_icon_name("application-menu-symbolic");
        let label = Label::new(None);
        label.set_visible(false); // Standardmäßig kein Label
        let content_box = GtkBox::new(GtkOrientation::Horizontal, 6);
        content_box.append(&icon);
        content_box.append(&label);
        obj.set_child(Some(&content_box));

        self.button_content_box.replace(Some(content_box));
        self.app_icon_widget.replace(Some(icon));
        self.app_name_widget.replace(Some(label));

        let popover = PopoverMenu::new_from_model(None::<&gio::MenuModel>); // Initial leer
        obj.set_popover(Some(&popover));
        self.popover_menu.replace(Some(popover));

        // Initialisiere D-Bus Verbindung asynchron
        let widget_clone = obj.clone();
        glib::MainContext::default().spawn_local(async move {
            match Connection::session().await {
                Ok(conn) => {
                    widget_clone.imp().dbus_connection.replace(Some(Arc::new(conn)));
                    tracing::info!("AppMenuButton: D-Bus Session-Verbindung hergestellt.");
                    // Initiales Update versuchen, falls schon eine App fokussiert ist (Info müsste von außen kommen)
                }
                Err(e) => {
                    tracing::error!("AppMenuButton: Fehler beim Verbinden zum D-Bus Session-Bus: {}", e);
                    widget_clone.imp().menu_fetch_status_internal.replace(MenuFetchStatus::Error(AppMenuButtonError::DBusConnectionError(e.to_string())));
                    widget_clone.imp().update_button_appearance_and_state_internal();
                }
            }
        });
        self.update_button_appearance_and_state_internal(); // Initiales Aussehen setzen
    }
}

impl WidgetImpl for AppMenuButton {}
impl ButtonImpl for AppMenuButton {} // Notwendig, da gtk::MenuButton von gtk::Button erbt
impl MenuButtonImpl for AppMenuButton {}

// ### Interne Implementierungsmethoden für AppMenuButtonImp ###
impl AppMenuButton {
    pub(super) fn update_active_window_info_internal(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>) {
        tracing::debug!("AppMenuButton: update_active_window_info: app_id={:?}, name={:?}, icon={:?}", app_id, app_name, icon_name);
        let current_app_id = self.active_app_id_internal.borrow().clone();

        // Nur neu laden, wenn sich die app_id geändert hat oder vorher None war
        let needs_menu_update = current_app_id != app_id || (current_app_id.is_none() && app_id.is_some());

        self.active_app_id_internal.replace(app_id.clone());
        // Die Properties direkt über den Wrapper setzen, um Notify auszulösen
        self.obj().set_property("active-app-name", app_name.to_value());
        self.obj().set_property("active-app-icon-name", icon_name.to_value());
        // self.active_app_name.replace(app_name); // Direktes Setzen ohne Notify
        // self.active_app_icon_name.replace(icon_name); // Direktes Setzen ohne Notify

        if needs_menu_update {
            if app_id.is_some() {
                self.trigger_menu_update_for_current_app_internal();
            } else {
                // Keine aktive App, Menü zurücksetzen
                self.current_menu_model_internal.replace(None);
                self.obj().set_menu_model(None::<&gio::MenuModel>);
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Idle);
                self.obj().set_property("has-menu", false);
            }
        }
        self.update_button_appearance_and_state_internal();
    }

    pub(super) fn trigger_menu_update_for_current_app_internal(&self) {
        let app_id_opt = self.active_app_id_internal.borrow().clone();
        let dbus_conn_opt = self.dbus_connection.borrow().clone();

        if let (Some(app_id), Some(dbus_conn)) = (app_id_opt, dbus_conn_opt) {
            if app_id.is_empty() {
                tracing::warn!("AppMenuButton: Leere AppID erhalten, Menü-Update übersprungen.");
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Error(AppMenuButtonError::MenuNotFound("Leere AppID".to_string())));
                self.update_button_appearance_and_state_internal();
                return;
            }

            tracing::info!("AppMenuButton: Starte Menü-Update für AppID: {}", app_id);
            self.menu_fetch_status_internal.replace(MenuFetchStatus::Loading);
            self.update_button_appearance_and_state_internal(); // Ladezustand anzeigen

            let widget_clone = self.obj().clone(); // Klon des Wrappers
            glib::MainContext::default().spawn_local(async move {
                let result = Self::fetch_menu_for_app_async(dbus_conn, app_id.clone()).await;
                widget_clone.imp().handle_menu_fetch_result_internal(result, &app_id);
            });
        } else {
            tracing::debug!("AppMenuButton: Keine AppID oder D-Bus-Verbindung für Menü-Update vorhanden.");
            self.menu_fetch_status_internal.replace(MenuFetchStatus::Idle);
            if app_id_opt.is_none() { // Explizit kein Menü, wenn keine AppID
                 self.obj().set_menu_model(None::<&gio::MenuModel>);
                 self.obj().set_property("has-menu", false);
            }
            self.update_button_appearance_and_state_internal();
        }
    }

    async fn fetch_menu_for_app_async(dbus_conn: Arc<Connection>, app_id: String) -> Result<gio::MenuModel, AppMenuButtonError> {
        // Primärer Mechanismus: org.gtk.Menus auf dem Bus-Namen der Anwendung
        // Standardpfade sind /org/gtk/menus/menubar oder /org/gtk/menus/appmenu
        // oder ein von GApplication festgelegter Pfad.
        // Hier wird versucht, gängige Pfade zu prüfen.
        let common_paths = [
            "/org/gtk/menus/menubar",
            "/org/gtk/menus/appmenu",
            &format!("/{}", app_id.replace('.', "/")), // z.B. /org/gnome/TextEditor
            "/", // Manchmal exportieren Apps Menüs direkt am Root-Pfad ihres Bus-Namens
        ];

        for path_str in common_paths.iter() {
            // Zuerst versuchen, direkt ein DBusMenuModel zu erstellen,
            // was die org.gtk.Menus Schnittstelle verwendet.
            match gio::DBusMenuModel::new(&dbus_conn, Some(app_id.as_str()), path_str) {
                Ok(menu_model) => {
                    // Prüfen, ob das Menü tatsächlich Items hat, da ein leeres Modell nicht nützlich ist.
                    // DBusMenuModel ist ein Live-Objekt, Änderungen werden reflektiert.
                    // Ein einfacher Check hier ist schwierig, da n_items() nicht direkt auf MenuModel existiert.
                    // Wir vertrauen darauf, dass ein erfolgreich erstelltes Modell gültig ist.
                    tracing::info!("AppMenuButton: GMenuModel für '{}' an Pfad '{}' erfolgreich via org.gtk.Menus bezogen.", app_id, path_str);
                    return Ok(menu_model.upcast::<gio::MenuModel>());
                }
                Err(e) => {
                    tracing::debug!("AppMenuButton: Kein GMenuModel für '{}' an Pfad '{}' via org.gtk.Menus gefunden: {}", app_id, path_str, e);
                }
            }
        }
        
        // Fallback: com.canonical.AppMenu.Registrar (veraltet und X11-lastig, hier nur als Referenz)
        // Für eine reine Wayland-Umgebung ist dies weniger relevant, es sei denn, XWayland-Apps nutzen es.
        // Diese Logik wird hier nicht vollständig implementiert, da sie komplex ist und oft nicht funktioniert.
        // tracing::warn!("AppMenuButton: Fallback zu com.canonical.AppMenu.Registrar nicht implementiert.");

        tracing::warn!("AppMenuButton: Kein Menü für AppID '{}' auf bekannten Pfaden gefunden.", app_id);
        Err(AppMenuButtonError::MenuNotFound(app_id))
    }

    fn handle_menu_fetch_result_internal(&self, result: Result<gio::MenuModel, AppMenuButtonError>, app_id_for_result: &str) {
        // Sicherstellen, dass das Ergebnis noch für die aktuell aktive App relevant ist.
        // Wenn der Benutzer schnell die App gewechselt hat, könnte dieses Ergebnis veraltet sein.
        let current_app_id = self.active_app_id_internal.borrow();
        if current_app_id.as_deref() != Some(app_id_for_result) {
            tracing::info!("AppMenuButton: Menü-Ergebnis für '{}' ist veraltet, aktuelle App ist '{:?}'. Ignoriere.", app_id_for_result, current_app_id);
            // Status nicht ändern, da ein neuer Ladevorgang ggf. läuft
            return;
        }

        match result {
            Ok(menu_model) => {
                tracing::info!("AppMenuButton: Menü für '{}' erfolgreich geladen.", app_id_for_result);
                self.current_menu_model_internal.replace(Some(menu_model.clone()));
                self.obj().set_menu_model(Some(&menu_model));
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Success);
                self.obj().set_property("has-menu", true);
            }
            Err(e) => {
                tracing::warn!("AppMenuButton: Fehler beim Laden des Menüs für '{}': {:?}", app_id_for_result, e);
                self.current_menu_model_internal.replace(None);
                self.obj().set_menu_model(None::<&gio::MenuModel>);
                self.menu_fetch_status_internal.replace(MenuFetchStatus::Error(e.clone())); // Klonen des Fehlers
                 if matches!(e, AppMenuButtonError::MenuNotFound(_)) {
                    self.menu_fetch_status_internal.replace(MenuFetchStatus::NoMenuAvailable);
                }
                self.obj().set_property("has-menu", false);
            }
        }
        self.update_button_appearance_and_state_internal();
    }

    fn update_button_appearance_and_state_internal(&self) {
        let obj = self.obj();
        let status = *self.menu_fetch_status_internal.borrow();
        let has_actual_menu = self.current_menu_model_internal.borrow().is_some() && status == MenuFetchStatus::Success;

        // CSS-Klassen aktualisieren
        obj.remove_css_class("no-app-menu");
        obj.remove_css_class("active-app-menu");
        obj.remove_css_class("loading-app-menu");

        if has_actual_menu {
            obj.add_css_class("active-app-menu");
        } else if status == MenuFetchStatus::NoMenuAvailable || matches!(status, MenuFetchStatus::Error(_)) || self.active_app_id_internal.borrow().is_none() {
            obj.add_css_class("no-app-menu");
        } else if status == MenuFetchStatus::Loading {
            obj.add_css_class("loading-app-menu");
        }

        // Sensitivität des Buttons
        obj.set_sensitive(has_actual_menu || status == MenuFetchStatus::Loading); // Aktiv während Laden, um Klick auf leeres Popover zu verhindern

        // Icon und Label (Label wird hier nicht primär verwendet)
        let icon_widget_opt = self.app_icon_widget.borrow();
        if let Some(icon_widget) = icon_widget_opt.as_ref() {
            let icon_name_prop = self.obj().property::<Option<String>>("active-app-icon-name");
            if let Some(icon_name_str) = icon_name_prop.as_ref().filter(|s| !s.is_empty()) {
                icon_widget.set_from_icon_name(Some(icon_name_str));
            } else {
                icon_widget.set_from_icon_name(Some("application-menu-symbolic")); // Fallback
            }
        }
        
        // Tooltip aktualisieren
        let app_name_prop = self.obj().property::<Option<String>>("active-app-name");
        if let Some(name_str) = app_name_prop.as_ref().filter(|s| !s.is_empty()) {
            obj.set_tooltip_text(Some(name_str));
        } else {
            obj.set_tooltip_text(Some("Anwendungsmenü")); // Fallback-Tooltip
        }
    }
}

```

#### **3.3. GObject-Eigenschaften (Zusammenfassung)**

|Eigenschaftsname|Rust-Feld (Imp)|Typ (Rust / GLib)|Zugriff|Standardwert|Beschreibung|
|:--|:--|:--|:--|:--|:--|
|`active-app-name`|`active_app_name`|`Option<String>` / G_TYPE_STRING|R|`None`|Name der Anwendung, deren Menü angezeigt wird oder angezielt ist.|
|`active-app-icon-name`|`active_app_icon_name`|`Option<String>` / G_TYPE_STRING|R|`None`|Icon-Name der Anwendung.|
|`has-menu`|`has_menu`|`bool` / G_TYPE_BOOLEAN|R|`false`|`true`, wenn ein Menü für die aktive Anwendung verfügbar und geladen ist.|
|(Parent `menu-model`)|N/A (Parent-Eigenschaft)|`Option<gio::MenuModel>` / G_TYPE_OBJECT|R/W|`None`|Das Menümodell, das im Popover angezeigt wird. Wird von dieser Logik gesetzt.|
|(Parent `icon-name`)|N/A (Parent-Eigenschaft)|`Option<String>`|R/W|`None`|Das Icon des MenuButtons selbst. Diese Logik setzt das Icon eines Kind-Widgets.|
|(Parent `label`)|N/A (Parent-Eigenschaft)|`Option<String>`|R/W|`None`|Das Label des MenuButtons selbst. Diese Logik setzt das Label eines Kind-Widgets.|

In Google Sheets exportieren

#### **3.4. Interner Zustand (Felder in `AppMenuButtonImp`)**

- `button_content_box: RefCell<Option<GtkBox>>`: Container für Icon und optionales Label im Button.
- `app_icon_widget: RefCell<Option<Image>>`: Das `gtk::Image`-Widget für das Anwendungsicon.
- `app_name_widget: RefCell<Option<Label>>`: Das `gtk::Label`-Widget für den Anwendungsnamen (standardmäßig unsichtbar).
- `popover_menu: RefCell<Option<PopoverMenu>>`: Das `gtk::PopoverMenu`, das an den `gtk::MenuButton` gebunden ist.
- `active_app_id_internal: RefCell<Option<String>>`: Speichert die ID der aktuell fokussierten Anwendung. Dient als Trigger für Menü-Updates.
- `menu_fetch_status_internal: RefCell<MenuFetchStatus>`: Verfolgt den Zustand des Menüabrufs (Idle, Loading, Success, Error, NoMenuAvailable).
- `current_menu_model_internal: RefCell<Option<gio::MenuModel>>`: Hält das aktuell geladene `GMenuModel`.
- `dbus_connection: RefCell<Option<Arc<Connection>>>`: Die D-Bus-Verbindung für Abfragen. `Arc` wird verwendet, um die Verbindung sicher mit asynchronen Tasks zu teilen, die das Menü laden.

### **4. GTK-Widget-Implementierungsstrategie (Spezifikation für Manus AI)**

- **Basis-Widget:** Das `AppMenuButton` erbt von `gtk::MenuButton`. Diese Klasse bietet bereits die Funktionalität, ein Popover beim Klick anzuzeigen.
- **Button-Inhalt:**
    - Das `AppMenuButton` verwendet intern ein `GtkBox` (horizontal orientiert) als Kind-Widget, um ein `gtk::Image` (für das Icon) und optional ein `gtk::Label` (für den Anwendungsnamen) aufzunehmen. Standardmäßig ist nur das Icon sichtbar.
    - Das Icon wird basierend auf `active_app_icon_name` aktualisiert.
- **Popover und Menümodell:**
    - Ein `gtk::PopoverMenu` wird erstellt und als Popover für den `gtk::MenuButton` gesetzt (`obj.set_popover(Some(&popover))`).
    - Die Eigenschaft `menu-model` des `gtk::MenuButton` (oder direkt des `gtk::PopoverMenu`) wird dynamisch mit dem über D-Bus abgerufenen `gio::MenuModel` aktualisiert: `obj.set_menu_model(Some(&menu_model))`.
    - Wenn kein Menü verfügbar ist oder ein Fehler auftritt, wird `obj.set_menu_model(None::<&gio::MenuModel>)` gesetzt.

### **5. Methoden und Funktionssignaturen (Interne und Wrapper-Logik)**

#### **5.1. Interne Methoden (in `AppMenuButtonImp`)**

- `fn update_active_window_info_internal(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>)`:
    1. Aktualisiert die internen Felder `active_app_id_internal`.
    2. Setzt die GObject-Properties `active-app-name` und `active-app-icon-name` des Wrapper-Objekts, um `notify`-Signale auszulösen.
    3. Wenn sich die `app_id` geändert hat oder von `None` zu `Some` wurde:
        - Wenn `app_id` `Some` ist und nicht leer: Ruft `trigger_menu_update_for_current_app_internal()` auf.
        - Wenn `app_id` `None` ist: Setzt `current_menu_model_internal` auf `None`, ruft `obj.set_menu_model(None)` auf, setzt `menu_fetch_status_internal` auf `Idle` und `has-menu` Property auf `false`.
    4. Ruft `update_button_appearance_and_state_internal()` auf.
- `fn trigger_menu_update_for_current_app_internal(&self)`:
    1. Holt `active_app_id_internal` und `dbus_connection`.
    2. Wenn beide `Some` sind und `app_id` nicht leer ist:
        - Setzt `menu_fetch_status_internal` auf `Loading`.
        - Ruft `update_button_appearance_and_state_internal()` auf, um Ladezustand anzuzeigen.
        - Startet eine asynchrone Task (`glib::MainContext::default().spawn_local`) die `Self::fetch_menu_for_app_async(dbus_conn_arc, app_id_str).await` aufruft.
        - Der Callback dieser Task ruft `self.handle_menu_fetch_result_internal(result, &original_app_id_str)` auf.
    3. Wenn keine `app_id` oder keine D-Bus-Verbindung: Setzt Status auf `Idle`, `set_menu_model(None)`, `set_property("has-menu", false)` und aktualisiert Aussehen.
- `async fn fetch_menu_for_app_async(dbus_conn: Arc<Connection>, app_id: String) -> Result<gio::MenuModel, AppMenuButtonError>`:
    1. Versucht, ein `gio::DBusMenuModel` für die gegebene `app_id` und gängige D-Bus-Objektpfade (z.B. `/org/gtk/menus/menubar`, `/org/gtk/menus/appmenu`, `/{app_id_als_pfad}`, `/`) über die `org.gtk.Menus`-Schnittstelle zu erstellen.
        - Nutzt `gio::DBusMenuModel::new(&dbus_conn, Some(app_id.as_str()), path_str)`.
    2. Wenn erfolgreich für einen Pfad: Gibt `Ok(menu_model.upcast())` zurück.
    3. Wenn alle Versuche fehlschlagen: Gibt `Err(AppMenuButtonError::MenuNotFound(app_id))` zurück.
    4. D-Bus-Verbindungsfehler werden als `AppMenuButtonError::DBusError` behandelt.
- `fn handle_menu_fetch_result_internal(&self, result: Result<gio::MenuModel, AppMenuButtonError>, app_id_for_result: &str)`:
    1. Prüft, ob das Ergebnis noch für die aktuell in `active_app_id_internal` gespeicherte App relevant ist. Wenn nicht, ignoriere das Ergebnis (Logge Warnung).
    2. Bei `Ok(menu_model)`:
        - Setzt `current_menu_model_internal` auf `Some(menu_model.clone())`.
        - Ruft `self.obj().set_menu_model(Some(&menu_model))`.
        - Setzt `menu_fetch_status_internal` auf `Success`.
        - Setzt die `has-menu` Property auf `true`.
    3. Bei `Err(e)`:
        - Setzt `current_menu_model_internal` auf `None`.
        - Ruft `self.obj().set_menu_model(None)`.
        - Setzt `menu_fetch_status_internal` auf `Error(e.clone())` oder `NoMenuAvailable` (wenn `e` ein `MenuNotFound` Fehler ist).
        - Setzt die `has-menu` Property auf `false`.
    4. Ruft `update_button_appearance_and_state_internal()` auf.
- `fn update_button_appearance_and_state_internal(&self)`:
    1. Aktualisiert CSS-Klassen (`active-app-menu`, `no-app-menu`, `loading-app-menu`) basierend auf `menu_fetch_status_internal` und ob `current_menu_model_internal` `Some` ist.
    2. Setzt die Sensitivität des Buttons (`gtk::Widget::set_sensitive()`). Der Button ist sensitiv, wenn ein Menü erfolgreich geladen wurde oder gerade geladen wird (um das Popover zu öffnen, das dann ggf. leer ist oder eine Ladeanzeige hat – hier wird es sensitiv, wenn `has_actual_menu` oder `status == Loading`).
    3. Aktualisiert das Icon im `app_icon_widget` basierend auf der `active-app-icon-name` Property (oder Fallback-Icon).
    4. Aktualisiert das Label im `app_name_widget` (falls sichtbar) basierend auf der `active-app-name` Property.
    5. Aktualisiert den Tooltip des Wrapper-Buttons (`obj.set_tooltip_text()`) mit dem Wert der `active-app-name` Property oder einem Fallback-Text.

#### **5.2. Methoden des öffentlichen Wrappers (`super::AppMenuButton`)**

- `pub fn new() -> Self`: Erstellt die Instanz.
- `pub fn update_active_window_info(&self, app_id: Option<String>, app_name: Option<String>, icon_name: Option<String>)`: Ruft die interne `update_active_window_info_internal` auf.
- `pub fn refresh_menu(&self)`: Ruft die interne `trigger_menu_update_for_current_app_internal` auf.

### **6. Signale**

- **Emittierte Signale:** Keine spezifischen benutzerdefinierten Signale für diese Komponente vorgesehen. Erbt und nutzt Signale von `gtk::MenuButton` (z.B. `clicked`, `activate` für Aktionen im Menü) und GObject-Properties (`notify::property-name`).
- **Verbundene Signale:**
    - Keine direkten Verbindungen zu externen Signalen in dieser Komponente. Es wird erwartet, dass ein übergeordneter Dienst (z.B. in `ui::shell` oder der Systemschicht) Änderungen des aktiven Fensters überwacht (z.B. mittels Wayland-Protokollen wie `wlr-foreign-toplevel-management`) und dann `AppMenuButton::update_active_window_info()` aufruft.

### **7. Interaktionen mit anderen Komponenten/Modulen**

- **`ui::shell`-Dienst (oder äquivalenter Systemdienst):**
    - Verantwortlich für die Überwachung des globalen Fensterfokus.
    - Ruft `AppMenuButton::update_active_window_info()` auf, wenn sich das aktive Anwendungsfenster ändert, und übergibt `app_id` (z.B. aus `zwlr_foreign_toplevel_handle_v1.app_id`), `app_name` (aus Fenstertitel oder App-Metadaten) und `icon_name`.
- **D-Bus (direkt oder via `novade-system`):**
    - Das `AppMenuButton` (bzw. seine `imp`-Logik) stellt direkt D-Bus-Anfragen über `zbus`, um das `GMenuModel` von Anwendungen abzurufen, die die `org.gtk.Menus`-Schnittstelle auf ihrem Anwendungs-Bus-Namen bereitstellen.
- **`domain::global_settings_and_state_management`:**
    - Könnte verwendet werden, um Konfigurationsoptionen für das `AppMenuButton` zu speichern (z.B. ob der Anwendungsname neben dem Icon angezeigt werden soll).

### **8. Ausnahmebehandlung (Fehlerdefinitionen)**

- **Datei:** `src/ui/shell/panel_widget/app_menu_button/error.rs`
    
- **Enum `AppMenuButtonError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    
    #[derive(Debug, Clone, Error, PartialEq, Eq)] // Clone, PartialEq, Eq für MenuFetchStatus::Error
    pub enum AppMenuButtonError {
        #[error("D-Bus connection error: {0}")]
        DBusConnectionError(String), // Enthält zbus::Error::to_string()
    
        #[error("D-Bus call failed for app '{app_id}': {dbus_error_name} - {dbus_error_message}")]
        DBusCallFailed {
            app_id: String,
            dbus_error_name: String,
            dbus_error_message: String,
        },
    
        #[error("Menu model not found for application '{0}'.")]
        MenuNotFound(String), // app_id
    
        #[error("Failed to parse menu model for application '{app_id}': {details}")]
        MenuModelParseError { app_id: String, details: String },
    
        #[error("Active window information (app_id) is missing or invalid.")]
        MissingWindowInfo,
    
        #[error("An internal error occurred in AppMenuButton: {0}")]
        InternalError(String),
    }
    ```
    
- Fehler werden im `MenuFetchStatus::Error(AppMenuButtonError)` gespeichert und beeinflussen das Aussehen und die Sensitivität des Buttons. Fehlerdetails werden via `tracing` geloggt.
    

### **9. Auflösung "Untersuchungsbedarf" (aus dem Quelldokument)**

- **Zuverlässige Methode zur Ermittlung des aktiven Fensters/app_id unter Wayland:**
    - Dies ist _nicht_ die direkte Verantwortung des `AppMenuButton`. Ein übergeordneter Dienst (Teil von `ui::shell` oder `novade-system`) muss diese Information bereitstellen.
    - Dieser Dienst verwendet Protokolle wie `wlr-foreign-toplevel-management-unstable-v1` oder `ext-foreign-toplevel-list-v1`.
    - Das `activated`-Ereignis von `zwlr_foreign_toplevel_handle_v1` signalisiert das fokussierte Fenster. Dessen `app_id` wird dann an `AppMenuButton::update_active_window_info()` übergeben.
- **Ermittlung und Konsumierung von `GMenuModel` via D-Bus:**
    - Die Methode `Workspace_menu_for_app_async` implementiert dies.
    - **Primärer Pfad:** `gio::DBusMenuModel::new()` wird verwendet, um das Menü von `bus_name = app_id` und gängigen Objektpfaden (`/org/gtk/menus/menubar`, `/org/gtk/menus/appmenu`, anwendungsspezifischer Pfad) zu beziehen. Dies nutzt die `org.gtk.Menus`-Schnittstelle.
    - **Fallbacks (StatusNotifierItem, AppMenuRegistrar):** Sind für eine moderne Wayland-Umgebung weniger relevant. `StatusNotifierItem.Menu` (D-Bus-Pfad zu `com.canonical.dbusmenu`) könnte ein seltener Fall sein. `AppMenuRegistrar` ist X11-lastig und wird hier nicht priorisiert. Die Spezifikation fokussiert sich auf `org.gtk.Menus`.

### **10. Dateistruktur (Zusammenfassung)**

- `src/ui/shell/panel_widget/app_menu_button/mod.rs` (Öffentliche API, GObject Wrapper)
- `src/ui/shell/panel_widget/app_menu_button/imp.rs` (Private GObject Implementierung, Logik)
- `src/ui/shell/panel_widget/app_menu_button/error.rs` (Spezifische Fehlerdefinitionen)

Diese detaillierte Spezifikation für das `AppMenuButton`-Modul sollte eine klare Grundlage für die Implementierung bieten. Die Aspekte der Fensterfokus-Überwachung sind ausgelagert, was die Komplexität dieses Widgets reduziert und es auf seine Kernaufgabe – das Abrufen und Anzeigen des Anwendungsmenüs – fokussiert.

**Grundlegende Kommunikationsprinzipien**

Die Architektur von NovaDE basiert auf fundamentalen Kommunikations- und Strukturprinzipien, die ein robustes, modulares und wartbares System gewährleisten sollen.

1. **API-basierte Interaktion:** Die Kommunikation zwischen den Schichten – Kern (Core), Domäne (Domain), System und Benutzeroberfläche (UI) – erfolgt primär über klar definierte öffentliche Programmierschnittstellen (APIs). Diese APIs werden in der Regel als Rust-Traits spezifiziert und von Service-Strukturen innerhalb der jeweiligen Schicht implementiert. Dies fördert ein vertragsbasiertes Interaktionsmodell.
2. **Ereignisgesteuertes System:** Ein robustes, ereignisgesteuertes System dient der Benachrichtigung über Zustandsänderungen und ermöglicht entkoppelte Interaktionen. Komponenten können auf relevante Ereignisse reagieren, ohne direkte Abhängigkeiten zu den Ereigniserzeugern aufzubauen. Dies ist besonders für die UI-Schicht wichtig, um reaktive Updates zu ermöglichen. Für die Event-Kommunikation wird `tokio::sync::broadcast` als bevorzugter Mechanismus für die Verteilung von Events spezifiziert.
3. **Strikte Schichtenhierarchie:** Höhere Schichten dürfen typischerweise nur von unmittelbar tieferliegenden Schichten abhängen, um zirkuläre Abhängigkeiten und unkontrollierte Interaktionen zu verhindern.
4. **Fehlerbehandlung:** Eine konsistente Fehlerbehandlungsstrategie wird über alle Schichten hinweg angewendet. Die `thiserror`-Bibliothek wird für die Definition von spezifischen, benutzerdefinierten Fehlertypen genutzt. `core::errors::CoreError` dient als fundamentaler Basistyp. Fehlerketten (`source()`) müssen bei der Weitergabe oder beim Wrappen von Fehlern erhalten bleiben. Panics sind strikt zu vermeiden.

## 1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten (Domäne, System, UI)

Die Kernschicht stellt fundamentale Bausteine und Dienste bereit, die von allen darüberliegenden Schichten genutzt werden.

### 1.1. Bereitgestellte Funktionalität durch die Kernschicht

Die Kernschicht exportiert die folgenden Module und deren öffentliche APIs:

#### 1.1.1. `core::types`

- **Schnittstelle**: Direkte Verwendung von Typen durch die höheren Schichten.
- **Definierte Typen (Ultra-Fein)**:
    - `Point<T>`: Repräsentiert einen Punkt im 2D-Raum.
        - Felder: `pub x: T`, `pub y: T`.
        - Methoden: `new(x: T, y: T) -> Self`, `distance_squared(...)`, `distance(...)` (für Float-Typen), `manhattan_distance(...)`.
        - Assoziierte Konstanten: `ZERO_I32`, `ZERO_F32`, etc..
        - Generische Parameter: `T` (Basis-Constraints: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`).
    - `Size<T>`: Repräsentiert eine 2D-Dimension.
        - Felder: `pub width: T`, `pub height: T`.
        - Methoden: `new(width: T, height: T) -> Self`, `area()`, `is_empty()`, `is_valid()`.
        - Assoziierte Konstanten: `ZERO_I32`, `ZERO_F32`, etc..
    - `Rect<T>`: Repräsentiert ein 2D-Rechteck.
        - Felder: `pub origin: Point<T>`, `pub size: Size<T>`.
        - Methoden: `new(...)`, `from_coords(...)`, Getter (`x`, `y`, `width`, `height`, `top`, `left`, `bottom`, `right`), `center()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translated(...)`, `scaled(...)`, `is_valid()`.
    - `RectInt`: Typalias für `Rect<i32>` oder spezifische Struktur mit `x: i32, y: i32, width: u32, height: u32`. Bietet Methoden wie `inflate`, `translate`. Verwendet `saturating_add/sub` für Robustheit.
    - `Color`: Repräsentiert eine RGBA-Farbe.
        - Felder: `pub r: f32`, `pub g: f32`, `pub b: f32`, `pub a: f32` (Wertebereich `[0.0, 1.0]`).
        - Methoden: `new(r,g,b,a)` (klemmt Werte), `from_rgba8(...)`, `to_rgba8()`, `with_alpha(...)`, `blend(...)`, `lighten(...)`, `darken(...)`, `interpolate(...)`, `from_hex(...) -> Result<Self, ColorParseError>`, `to_hex_string(...)`.
        - Implementiert `Default` (z.B. `Color::TRANSPARENT`) und `Serialize`/`Deserialize` als Hex-String.
    - `Orientation`: Enum (`Horizontal`, `Vertical`) mit `toggle()` Methode und `Default` (Horizontal).
    - `uuid::Uuid`: Re-exportiert für eindeutige Identifikatoren.
    - `chrono::DateTime<Utc>`: Re-exportiert für Zeitstempel.
- **Nutzung**: Diese Typen werden direkt in den öffentlichen APIs und internen Logiken der höheren Schichten verwendet.

#### 1.1.2. `core::errors`

- **Schnittstelle**: Höhere Schichten wrappen Fehler aus der Kernschicht (z.B. `CoreError` oder spezifischere Modul-Fehler wie `ColorParseError`) mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen. Die Fehlerkette (`source()`) wird beibehalten.
- **Definierte Typen (Ultra-Fein)**:
    - `CoreError`: Basis-Fehlertyp der Kernschicht.
        - Varianten: `InitializationFailed { component: String, source: Option<Box<dyn std::error::Error>> }`, `Io { path: PathBuf, source: std::io::Error }`, `Serialization { description: String, source: Option<Box<dyn std::error::Error>> }`, `Deserialization { ... }`, `InvalidId { invalid_id: String }`, `NotFound { resource_description: String }`, `CoreConfigError { message: String, source: Option<Box<dyn std::error::Error>> }`, `InternalError(String)`.
    - `ColorParseError`: Fehler beim Parsen von Hex-Farbcodes.
        - Varianten: `InvalidHexFormat(String)`, `InvalidHexDigit(String, source: std::num::ParseIntError)`, `InvalidHexLength(String)`.
- **Nutzung**: Jedes Modul, auch in höheren Schichten, definiert sein eigenes Fehler-Enum mit `thiserror` und integriert Fehler aus tieferen Schichten oder Bibliotheken.

#### 1.1.3. `core::logging`

- **Schnittstelle**:
    - `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: LogFormat) -> Result<(), LoggingError>`: Einmaliger Aufruf beim Anwendungsstart.
        - `LogFormat`: Enum (`PlainTextDevelopment`, `JsonProduction`).
        - `LoggingError`: Enum (`SetGlobalDefaultError(String)`, `InitializationError(String)`).
    - Verwendung der `tracing`-Makros (`trace!`, `info!`, `warn!`, `error!`, `#[tracing::instrument]`) durch alle höheren Schichten.
- **Nutzung**: Alle Schichten nutzen `tracing`-Makros. Sensible Daten dürfen nicht geloggt werden.

#### 1.1.4. `core::config`

- **Schnittstelle**:
    - `pub fn load_core_config(config_paths: &[PathBuf]) -> Result<CoreConfig, ConfigError>`: Lädt Konfiguration aus TOML-Dateien in der angegebenen Reihenfolge.
    - `pub fn initialize_global_core_config(config: CoreConfig) -> Result<(), ConfigError>`: Initialisiert die globale Konfiguration einmalig.
    - `pub fn get_global_core_config() -> &'static CoreConfig`: Globaler, schreibgeschützter Zugriff auf die geladene `CoreConfig` (via `once_cell`).
- **Definierte Typen (Ultra-Fein)**:
    - `CoreConfig`: Struktur, die alle Kernschicht-spezifischen Einstellungen hält (z.B. `log_level: LogLevelConfig`, `feature_flags: FeatureFlags`). Implementiert `Deserialize`, `Default`. Verwendet `#[serde(default = "path")]` und `#[serde(deny_unknown_fields)]`.
    - `ConfigError`: Fehler beim Laden/Parsen der Konfiguration.
        - Varianten: `FileReadError { path: PathBuf, source: std::io::Error }`, `DeserializationError { path: PathBuf, source: toml::de::Error }`, `NoConfigurationFileFound { checked_paths: Vec<PathBuf> }`, `AlreadyInitializedError`, `NotInitializedError`.
- **Nutzung**: Domänenschicht (z.B. `domain::settings_persistence_iface`) kann Kernschicht-Dienste zum Lesen/Schreiben von Konfigurationsdateien nutzen, aber die `CoreConfig` selbst wird nach Initialisierung als unveränderlich betrachtet.

#### 1.1.5. `core::utils`

- **Schnittstelle**: Direkte Nutzung der öffentlichen, zustandslosen Hilfsfunktionen durch alle höheren Schichten.
- **Beispielhafte Utilities**:
    - `path_utils::normalize_path_robustly(...)`
    - `string_utils::sanitize_filename(...)`, `truncate_string_with_ellipsis(...)`
    - Fehlerbehandlung: Jede fehleranfällige Utility-Funktion gibt `Result<T, YourUtilError>` zurück.

## 2. Schnittstelle: Domänenschicht (Domain Layer) zu Systemschicht und Benutzeroberflächenschicht

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand von NovaDE. Sie interagiert nicht direkt mit Hardware oder OS-Details.

### 2.1. Bereitgestellte Funktionalität durch die Domänenschicht

Die Domänenschicht stellt ihre Logik und Zustandsinformationen über öffentliche APIs ihrer Service-Komponenten (Rust-Traits) und durch domänenspezifische Events bereit.

#### 2.1.1. Traits für Service-APIs (asynchron via `async_trait`)

- **`domain::theming::ThemingEngine` Trait**
    - Methoden:
        - `async fn get_current_theme_state(&self) -> Result<AppliedThemeState, ThemingError>`
        - `async fn get_available_themes(&self) -> Result<Vec<ThemeDefinition>, ThemingError>`
        - `async fn get_current_configuration(&self) -> Result<ThemingConfiguration, ThemingError>`
        - `async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
        - `async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`
        - `fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`
- **`domain::workspaces::WorkspaceManagerService` Trait**
    - Methoden:
        - `async fn create_workspace(&self, name: Option<String>, persistent_id: Option<String>, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<WorkspaceId, WorkspaceManagerError>`
        - `async fn delete_workspace(&self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>`
        - `fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>` (gibt Klon)
        - `fn all_workspaces_ordered(&self) -> Vec<Workspace>` (gibt Klone)
        - `fn active_workspace_id(&self) -> Option<WorkspaceId>`
        - `async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
        - `async fn assign_window_to_active_workspace(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
        - `async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
        - `async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
        - `async fn move_window_to_specific_workspace(&self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
        - `async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
        - `async fn set_workspace_layout(&self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>`
        - `async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>`
        - `async fn set_workspace_accent_color(&self, id: WorkspaceId, color_hex: Option<String>) -> Result<(), WorkspaceManagerError>`
        - `async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>`
        - `fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`
        - `async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>`
- **`domain::user_centric_services::ai_interaction::AIInteractionLogicService` Trait**
    - Methoden:
        - `async fn initiate_interaction(&mut self, relevant_categories: Vec<AIDataCategory>, initial_attachments: Option<Vec<AttachmentData>>) -> Result<Uuid, AIInteractionError>`
        - `async fn get_interaction_context(&self, context_id: Uuid) -> Result<AIInteractionContext, AIInteractionError>`
        - `async fn provide_consent(&mut self, context_id: Uuid, model_id: String, granted_categories: Vec<AIDataCategory>, consent_decision: bool) -> Result<(), AIInteractionError>`
        - `async fn get_consent_status_for_interaction(&self, context_id: Uuid, model_id: &str, required_categories: &[AIDataCategory]) -> Result<AIConsentStatus, AIInteractionError>`
        - `async fn add_attachment_to_context(&mut self, context_id: Uuid, attachment: AttachmentData) -> Result<(), AIInteractionError>`
        - `async fn list_available_models(&self) -> Result<Vec<AIModelProfile>, AIInteractionError>`
        - `async fn get_default_model(&self) -> Result<Option<AIModelProfile>, AIInteractionError>`
        - `async fn update_interaction_history(&mut self, context_id: Uuid, entry: InteractionHistoryEntry) -> Result<(), AIInteractionError>`
        - (Persistenz-bezogene Methoden wie `store_consent`, `get_all_user_consents`, `load_model_profiles` werden über separate Provider-Traits abgewickelt: `AIConsentProvider`, `AIModelProfileProvider`)
- **`domain::user_centric_services::notifications_core::NotificationService` Trait**
    - Methoden:
        - `async fn post_notification(&mut self, notification_data: NotificationInput) -> Result<Uuid, NotificationError>`
        - `async fn get_active_notification(&self, notification_id: Uuid) -> Result<Option<Notification>, NotificationError>`
        - `async fn mark_as_read(&mut self, notification_id: Uuid) -> Result<(), NotificationError>`
        - `async fn dismiss_notification(&mut self, notification_id: Uuid, reason: DismissReason) -> Result<(), NotificationError>`
        - `async fn get_active_notifications(&self, filter: Option<NotificationFilterCriteria>, sort_order: Option<NotificationSortOrder>) -> Result<Vec<Notification>, NotificationError>`
        - `async fn get_notification_history(&self, limit: Option<usize>, filter: Option<NotificationFilterCriteria>, sort_order: Option<NotificationSortOrder>) -> Result<Vec<Notification>, NotificationError>`
        - `async fn clear_history(&mut self) -> Result<(), NotificationError>`
        - `async fn clear_all_for_app(&mut self, app_id: &ApplicationId) -> Result<usize, NotificationError>`
        - `async fn set_do_not_disturb(&mut self, enabled: bool) -> Result<(), NotificationError>`
        - `async fn is_do_not_disturb_enabled(&self) -> Result<bool, NotificationError>`
        - `async fn invoke_action(&mut self, notification_id: Uuid, action_key: &str) -> Result<(), NotificationError>`
        - `async fn get_stats(&self) -> Result<NotificationStats, NotificationError>`
- **`domain::global_settings_and_state_management::GlobalSettingsService` Trait**
    - Methoden:
        - `async fn load_settings(&mut self) -> Result<(), GlobalSettingsError>`
        - `async fn save_settings(&self) -> Result<(), GlobalSettingsError>`
        - `fn get_current_settings(&self) -> GlobalDesktopSettings`
        - `async fn update_setting(&mut self, path: SettingPath, value: serde_json::Value) -> Result<(), GlobalSettingsError>`
        - `fn get_setting(&self, path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`
        - `async fn reset_to_defaults(&mut self) -> Result<(), GlobalSettingsError>`
        - `fn subscribe_to_setting_changes(&self) -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`
- **`domain::notifications_rules::NotificationRulesEngine` Trait**
    - Methoden:
        - `async fn reload_rules(&self) -> Result<(), NotificationRulesError>`
        - `async fn process_notification(&self, notification: Notification) -> Result<RuleProcessingResult, NotificationRulesError>`
        - `async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>`
        - `async fn update_rules(&self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>`
- **`domain::window_management_policy::WindowManagementPolicyService` Trait**
    - Methoden:
        - `async fn calculate_workspace_layout(&self, workspace_id: WorkspaceId, windows_to_layout: &[WindowLayoutInfo], available_area: RectInt, workspace_current_tiling_mode: TilingMode, focused_window_id: Option<&WindowIdentifier>, window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>) -> Result<WorkspaceWindowLayout, WindowPolicyError>`
        - `async fn get_initial_window_geometry(&self, window_info: &WindowLayoutInfo, is_transient_for: Option<&WindowIdentifier>, parent_geometry: Option<RectInt>, workspace_id: WorkspaceId, active_layout_on_workspace: &WorkspaceWindowLayout, available_area: RectInt, window_specific_overrides: &Option<WindowPolicyOverrides>) -> Result<RectInt, WindowPolicyError>`
        - `async fn calculate_snap_target(&self, moving_window_id: &WindowIdentifier, current_geometry: RectInt, other_windows_on_workspace: &[(&WindowIdentifier, &RectInt)], workspace_area: RectInt, snapping_policy: &WindowSnappingPolicy, gap_settings: &GapSettings) -> Option<RectInt>`
        - `async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>`
        - `async fn get_effective_gap_settings_for_workspace(&self, workspace_id: WorkspaceId) -> Result<GapSettings, WindowPolicyError>`
        - (Weitere Methoden zum Abruf von Teil-Policies)

#### 2.1.2. Datenstrukturen (Öffentlich exportierte Typen aus der Domänenschicht)

- **`domain::theming::types`**: `AppliedThemeState`, `ThemeDefinition`, `ThemingConfiguration`, `TokenIdentifier`, `ThemeIdentifier`, `ColorSchemeType`, `AccentColor` (mit `novade_core::types::Color`).
- **`domain::workspaces::core::types`**: `WorkspaceId`, `WindowIdentifier`, `WorkspaceLayoutType`.
- **`domain::workspaces::core`**: `Workspace` (mit `icon_name`, `accent_color_hex`).
- **`domain::user_centric_services::ai_interaction::types`**: `AIInteractionContext` (mit `InteractionHistoryEntry`), `AIConsent` (mit `AIConsentScope`), `AIModelProfile` (mit `AIModelCapability`), `AttachmentData`, `AIConsentStatus`, `AIDataCategory`.
- **`domain::user_centric_services::notifications_core::types`**: `Notification` (mit `category`, `hints`, `timeout_ms`), `NotificationAction`, `NotificationUrgency`, `NotificationActionType`, `NotificationInput`, `NotificationFilterCriteria`, `NotificationSortOrder`, `DismissReason`.
- **`domain::global_settings_and_state_management::types`**: `GlobalDesktopSettings` (und alle untergeordneten Einstellungs-Structs wie `AppearanceSettings`, `InputBehaviorSettings`), `SettingPath`-Enum-Hierarchie.
- **`domain::notifications_rules::types`**: `RuleConditionValue`, `RuleConditionOperator`, `RuleConditionField`, `SimpleRuleCondition`, `RuleCondition`, `RuleAction`, `NotificationRule`, `NotificationRuleSet`, `RuleProcessingResult`.
- **`domain::window_management_policy::types`**: `TilingMode`, `GapSettings`, `WindowSnappingPolicy`, `WindowGroupingPolicy`, `NewWindowPlacementStrategy`, `FocusStealingPreventionLevel`, `FocusPolicy`, `WindowPolicyOverrides`, `WorkspaceWindowLayout`, `WindowLayoutInfo`.
- **`domain::shared_types`**: `ApplicationId`, `UserSessionState`, `ResourceIdentifier`.

#### 2.1.3. Events (Domänenspezifisch, via `tokio::sync::broadcast`)

- **`domain::theming`**: `ThemeChangedEvent { new_state: AppliedThemeState }`.
- **`domain::workspaces::manager::events`**: `WorkspaceEvent` Enum (z.B. `WorkspaceCreated { descriptor }`, `ActiveWorkspaceChanged { old_id, new_id, new_descriptor }`, `WindowAssignedToWorkspace { ... }`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`, `WorkspaceOrderChanged`).
- **`domain::user_centric_services::events`**: Wrapper-Enums `AIInteractionEventEnum` und `NotificationEventEnum`.
    - `AIInteractionEventEnum`: `AIInteractionInitiatedEvent { context }`, `AIConsentUpdatedEvent { ... }`, `AIContextUpdatedEvent { ... }`, `AIModelProfilesReloadedEvent { ... }`.
    - `NotificationEventEnum`: `NotificationPostedEvent { notification, suppressed_by_dnd }`, `NotificationDismissedEvent { notification_id, reason }`, `NotificationReadEvent { ... }`, `DoNotDisturbModeChangedEvent { ... }`, `NotificationActionInvokedEvent { ... }`, `NotificationHistoryClearedEvent`, `NotificationPopupExpiredEvent { ... }`.
- **`domain::global_settings_and_state_management`**: `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`, `SettingsLoadedEvent { settings: GlobalDesktopSettings }`, `SettingsSavedEvent`.
- **`domain::common_events`**: `UserActivityDetectedEvent { timestamp, activity_type, ... }`, `SystemShutdownInitiatedEvent { reason, is_reboot, ... }`.

#### 2.1.4. Fehlertypen (Modulspezifisch via `thiserror`)

- `domain::theming::errors::ThemingError`.
- `domain::workspaces::core::errors::WorkspaceCoreError`, `assignment::errors::WindowAssignmentError`, `manager::errors::WorkspaceManagerError`, `config::errors::WorkspaceConfigError`.
- `domain::user_centric_services::ai_interaction::errors::AIInteractionError`, `notifications_core::errors::NotificationError`.
- `domain::global_settings_and_state_management::errors::GlobalSettingsError`.
- `domain::notifications_rules::errors::NotificationRulesError`.
- `domain::window_management_policy::errors::WindowPolicyError`.

### 2.2. Nutzung durch die Systemschicht

- **Anwendung von Domänenregeln**: Die Systemschicht setzt Domänenrichtlinien technisch um.
    - `system::window_mechanics` nutzt `WindowManagementPolicyService::calculate_workspace_layout()` und andere Methoden, um Fenstergeometrien und -verhalten zu bestimmen und anzuwenden.
    - Der `system::compositor` und seine Submodule (z.B. für XDG-Shell, Layer-Shell) interagieren mit `WindowManagementPolicyService` und `WorkspaceManagerService` für Platzierung, Stapelreihenfolge und Sichtbarkeit von Fenstern/Surfaces.
- **Abfrage von Zuständen und Konfigurationen**:
    - `system::mcp_client` interagiert mit `AIInteractionLogicService` für Einwilligungsprüfungen, Modellprofile und Kontextmanagement.
    - `system::dbus::notifications_server` (D-Bus Implementierung von `org.freedesktop.Notifications`) leitet Anfragen an den `NotificationService` weiter und reagiert auf dessen Events, um D-Bus Signale zu senden.
    - Systemkomponenten wie `system::power_management` oder `system::audio_management` können relevante Einstellungen vom `GlobalSettingsService` beziehen.
- **Event-Konsum und -Weiterleitung**: Die Systemschicht kann auf Domänen-Events reagieren (z.B. `ActiveWorkspaceChanged`, `SettingChangedEvent` für themenrelevante Einstellungen) und diese ggf. in systemnahe Aktionen übersetzen oder an die UI-Schicht weiterleiten, wenn sie systemweite Auswirkungen haben (z.B. über den `SystemEventBridge`).
- **Fehlerbehandlung**: Fehler aus der Domänenschicht werden von der Systemschicht gefangen, ggf. in systemspezifische Fehler gewrappt und an die UI-Schicht oder interne Logging-Mechanismen weitergeleitet.

### 2.3. Nutzung durch die Benutzeroberflächenschicht (UI Layer)

- **Zustandsdarstellung**: Die UI-Schicht visualisiert Zustände und Daten aus der Domänenschicht.
    - `ui::theming_gtk` verwendet `ThemingEngine::get_current_theme_state()` und abonniert `ThemeChangedEvent`, um CSS-Stile anzuwenden.
    - `ui::shell` (z.B. Workspace-Switcher, Panel-Elemente) und `ui::control_center` nutzen `WorkspaceManagerService` und `GlobalSettingsService` intensiv zur Anzeige und Modifikation.
    - UI-Elemente für KI-Interaktionen (Befehlspalette, Assistenz-Widgets) nutzen `AIInteractionLogicService`.
    - Das `ui::notifications_frontend` (Popups, Notification-Center) nutzt `NotificationService` und reagiert auf dessen Events.
- **Auslösen von Geschäftslogik**: Benutzerinteraktionen in der UI werden in Aufrufe an Domänen-Service-Methoden übersetzt.
- **Event-Konsum**: Die UI-Schicht ist ein primärer Konsument von Domänen-Events, um sich dynamisch zu aktualisieren.
- **Fehlerbehandlung**: Fehler von Domänendiensten werden von der UI gefangen und in benutzerfreundliche Nachrichten oder Aktionen übersetzt.

## 3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren UI-initiierte Befehle technisch um.

### 3.1. Bereitgestellte Funktionalität durch die Systemschicht

#### 3.1.1. Traits für Service-APIs (asynchron via `async_trait`)

- **`system::compositor::CompositorInterface` (Beispielhafter Trait-Name)**
    - Methoden (Beispiele):
        - `fn request_focus(&self, window_id: novade_core::types::WindowId) -> Result<(), CompositorError>`
        - `fn configure_window(&self, window_id: novade_core::types::WindowId, config: WindowConfigurationRequest) -> Result<(), CompositorError>`
        - `fn get_window_info(&self, window_id: novade_core::types::WindowId) -> Result<Option<WindowInfo>, CompositorError>`
        - `fn list_managed_windows(&self) -> Result<Vec<WindowInfo>, CompositorError>`
        - `fn list_outputs(&self) -> Result<Vec<OutputInfo>, CompositorError>`
        - `fn subscribe_to_compositor_events(&self) -> tokio::sync::broadcast::Receiver<CompositorEvent>`
- **`system::input::InputInterface` (Beispielhafter Trait-Name)**
    - Methoden (Beispiele):
        - `fn set_cursor_theme(&self, theme_name: String, size: u32) -> Result<(), InputError>`
        - `fn get_current_keyboard_layout(&self) -> Result<String, InputError>`
        - `fn subscribe_to_input_events(&self) -> tokio::sync::broadcast::Receiver<InputEventEnum>`
- **`system::dbus` (Wrapper für spezifische D-Bus Clients wie UPower, Logind, NetworkManager)**: Exponiert vereinfachte Methoden und Events.
    - Beispiel `UPowerClientInterface`: `async fn get_display_device_details() -> Result<PowerDeviceDetails, DBusInterfaceError>`, `fn subscribe() -> Receiver<UPowerEvent>`.
- **`system::audio_management::AudioServiceInterface` (Beispielhafter Trait-Name)**
    - Methoden: `async fn list_audio_devices(...)`, `async fn set_device_volume(...)`, `fn subscribe() -> Receiver<AudioEvent>`.
- **`system::mcp_client::SystemMcpService` Trait**
    - Methoden: `async fn configure_servers(...)`, `async fn initialize_server(...)`, `async fn list_resources(...)`, `async fn call_tool(...)`, `fn subscribe_to_mcp_events() -> Receiver<McpClientSystemEvent>`.
- **`system::portals::PortalsInterface` (Beispielhafter Trait-Name für XDG Portal Interaktionen)**
    - Methoden: `async fn open_file_dialog(...) -> Result<Vec<PathBuf>, PortalError>`, `async fn save_file_dialog(...)`, `async fn take_screenshot(...)`.

#### 3.1.2. Datenstrukturen (Öffentlich exportierte Typen aus der Systemschicht für die UI)

- **`system::compositor`**: `WindowInfo` (mit `id`, `title`, `app_id`, `geometry`, Fokus-Status, Workspace-Zuordnung etc.), `OutputInfo` (mit ID, Name, Geometrie, Auflösungen, Skalierung), `CompositorWindowState` (Enum).
- **`system::input`**: `KeyboardEvent`, `PointerEvent` (Button, Motion, Axis), `TouchEvent`, `GestureEvent`, `InputEventEnum` (Wrapper).
- **`system::dbus` Clients**: Spezifische Structs für Gerätedetails, Verbindungsstatus etc. (z.B. `UPowerDeviceDetails` [aus `upower_client::types` aber ggf. hier vereinfacht für UI], `NetworkDeviceDetails`, `AccessPointInfo` [aus `network_manager_client::types`]).
- **`system::audio_management::types`**: `AudioDevice` (vereinfacht für UI), `AudioStream` (vereinfacht für UI).
- **`system::mcp_client::types`**: `McpClientSystemEvent` (für Benachrichtigungen an UI), `AICompletionResponse` (oder vereinfachte Version).
- **`system::portals`**: `OpenFileOptions`, `SaveFileOptions`, `FileFilter` für Dialoge. `WindowIdentifier` für Portal-Fenster-Handles.

#### 3.1.3. Events (System-Level Events, via `system::event_bridge` oder spezifische `broadcast::Sender`)

- **`system::compositor`**: `CompositorEvent` Enum (z.B. `WindowCreated { info }`, `WindowFocused { window_id }`, `OutputConfigurationChanged { info }`).
- **`system::input`**: `InputEventEnum` (Wrapper für spezifische Eingabe-Events).
- **`system::dbus` Clients**: Events wie `UPowerSystemEvent::DeviceChanged`, `LogindSystemEvent::SessionLocked`, `NetworkManagerSystemEvent::ConnectivityChanged`.
- **`system::audio_management`**: `AudioSystemEvent::DeviceVolumeChanged`, `AudioSystemEvent::DefaultDeviceChanged`.
- **`system::mcp_client`**: `McpClientSystemEvent::McpNotificationReceived`, `McpClientSystemEvent::McpToolCallSuccessful`.
- **`system::event_bridge::SystemLayerEvent`**: Ein übergreifendes Enum, das spezifische Events aus den Systemmodulen wrappen kann, um ein zentrales Abonnement zu ermöglichen.

#### 3.1.4. Fehlertypen (Modulspezifisch via `thiserror`)

- `system::compositor::errors::CompositorError` (z.B. `WindowNotFound`, `WaylandError`).
- `system::input::errors::InputError` (z.B. `SeatError`, `LibinputError`).
- `system::dbus_interfaces::common::errors::DBusInterfaceError` (z.B. `ConnectionFailed`, `MethodCallFailed`).
- `system::audio_management::errors::AudioManagementError` (z.B. `ConnectionFailed`, `ObjectNotFound`).
- `system::mcp_client::errors::McpSystemClientError` (z.B. `ServerConfigNotFound`, `RequestTimeout`).
- `system::portals` (z.B. `PortalError` mit `UserCancelled`, `PortalNotAvailable`).
- `system::window_mechanics::errors::WindowMechanicsError`.
- `system::power_management::errors::PowerManagementError`.

### 3.2. Nutzung durch die Benutzeroberflächenschicht (UI Layer)

- **Darstellung von Systeminformationen**: Die UI visualisiert die von der Systemschicht bereitgestellten Zustände (Fensterlisten, Fokus, Netzwerk-/Batterie-/Audio-Indikatoren etc.).
- **Reaktion auf Eingabeereignisse**: UI-Elemente (Buttons, Textfelder) reagieren auf verarbeitete Eingabeereignisse von `system::input`.
- **Initiierung von Systemaktionen**: Benutzerinteraktionen in der UI führen zu Befehlsaufrufen an die Systemschicht-APIs (Fenster schließen, Lautstärke ändern, Netzwerk verbinden, Datei öffnen via Portal).
- **Dialogmanagement**: UI-Komponenten (z.B. `ui::shell` oder spezifische Einstellungsdialoge) rufen Methoden von `system::portals::PortalsInterface` auf, um native Dialoge anzuzeigen. Die UI stellt dabei einen `WindowIdentifier` für das Elternfenster bereit.
- **Fehlerbehandlung**: Die UI fängt Fehler von der Systemschicht ab und präsentiert dem Benutzer verständliche Meldungen oder Wiederherstellungsoptionen.
- **Event-Konsum**: Die UI abonniert System-Events (z.B. `CompositorEvent::WindowCreated`, `InputEventEnum`, `UPowerSystemEvent`, etc.), um ihre Ansichten reaktiv zu aktualisieren.

## 4. Allgemeine Kommunikationsmuster (Wiederholung und Verfeinerung)

- **Synchrone vs. Asynchrone Aufrufe**:
    - Methoden, die schnell antworten und keine blockierenden Operationen ausführen (z.B. Abfrage eines bereits im Speicher befindlichen Zustands), können synchron sein.
    - Methoden, die I/O, IPC oder potenziell langlaufende Operationen beinhalten, **müssen** `async` sein (z.B. `save_settings()`, `call_tool()`, die meisten D-Bus-Aufrufe).
- **Event-Broadcasting**:
    - `tokio::sync::broadcast` wird als primärer Mechanismus für Events innerhalb einer Schicht und zwischen Schichten verwendet.
    - Services, die Events publizieren, halten einen `broadcast::Sender<EventType>`.
    - Services oder UI-Komponenten, die Events konsumieren, erhalten einen `broadcast::Receiver<EventType>` über eine `subscribe_to_..._events()` Methode.
- **Fehlerpropagation**:
    - Die konsequente Nutzung von `Result<T, E>` und dem `?`-Operator ist verbindlich.
    - Fehler werden mit `thiserror` definiert und sollten die `source()`-Kette erhalten, um die Ursachenanalyse zu ermöglichen.
    - Schichten wrappen Fehler aus tieferen Schichten in ihre eigenen, kontextspezifischeren Fehlertypen unter Beibehaltung der `source`.
- **Thread-Sicherheit für geteilten Zustand**:
    - Zustand, der von mehreren `async` Tasks oder über Thread-Grenzen hinweg geteilt wird, muss mit `Arc<tokio::sync::Mutex<...>>` oder `Arc<tokio::sync::RwLock<...>>` geschützt werden.
    - Der UI-Thread (GTK-Hauptschleife) erfordert spezielle Behandlung: Daten von Worker-Threads müssen über `glib::MainContext::spawn_local` oder geeignete Kanäle sicher an den UI-Thread übergeben werden, um UI-Aktualisierungen durchzuführen.

Diese detaillierte Schnittstellenspezifikation dient als Grundlage für die Implementierung der einzelnen Module und die Sicherstellung einer kohärenten und robusten Kommunikation zwischen den Architekturschichten von NovaDE.

**Grundprinzip der Kommunikation:**

Die Kommunikation zwischen den Schichten erfolgt primär über wohldefinierte öffentliche APIs (oft Rust-Traits, die von Service-Strukturen implementiert werden) und durch ein Event-System. Direkte Abhängigkeiten existieren typischerweise nur von einer höheren zu einer unmittelbar tieferen Schicht.

**Schnittstellen im Detail:**

**1. Kernschicht (Core Layer) zu allen höheren Schichten (Domäne, System, UI)**

- **Bereitgestellte Funktionalität durch die Kernschicht:**
    - **`core::types`**:
        - **Datentypen**: Stellt fundamentale Datentypen wie `Point<T>`, `Size<T>`, `Rect<T>`, `RectInt`, `Color`, `Orientation`, `Uuid` und `DateTime<Utc>` bereit.
        - **Nutzung**: Diese Typen werden direkt in den höheren Schichten für Geometrieberechnungen, Farbangaben, Identifikatoren und Zeitstempel verwendet.
    - **`core::errors`**:
        - **Fehlertypen**: Definiert den Basis-Fehlertyp `CoreError` und die Strategie für Modul-spezifische Fehler mit `thiserror`.
        - **Nutzung**: Höhere Schichten wrappen Fehler aus der Kernschicht oft in ihre eigenen spezifischeren Fehlertypen mittels `#[from]` oder `#[source]` auf `CoreError` oder spezifischen Kernschicht-Modulfehlern. Die Fehlerkette (`source()`) bleibt dabei erhalten.
    - **`core::logging`**:
        - **Logging-API**: Stellt Initialisierungsroutinen (`initialize_logging`) und die Konvention zur Verwendung von `tracing`-Makros (`trace!`, `debug!`, `info!`, `warn!`, `error!`) bereit.
        - **Nutzung**: Alle höheren Schichten verwenden die `tracing`-Makros für strukturiertes Logging. `initialize_logging` wird typischerweise vom Hauptanwendungsbinary (UI-Schicht oder Anwendungs-Root) aufgerufen.
    - **`core::config`**:
        - **Konfigurations-API**: Stellt Funktionen zum Laden (`load_core_config`) und globalen Zugriff (`get_core_config`) auf Kernkonfigurationen (`CoreConfig` ) bereit. Definiert `ConfigError`.
        - **Nutzung**:
            - **Domänenschicht**: Module wie `domain::settings_persistence_iface` (z.B. `FilesystemConfigProvider` ) und `domain::workspaces::config` nutzen Kernschicht-Dienste zum Lesen/Schreiben von Konfigurationsdateien.
            - **Andere Schichten**: Können `get_core_config()` für den Zugriff auf Kern-spezifische Einstellungen verwenden. Die Kernkonfiguration wird nach der Initialisierung als unveränderlich betrachtet.
    - **`core::utils`**:
        - **Hilfsfunktionen**: Stellt allgemeine, zustandslose Hilfsfunktionen bereit.
        - **Nutzung**: Direkte Verwendung durch alle höheren Schichten nach Bedarf.

**2. Domänenschicht (Domain Layer) zu Systemschicht (System Layer) und Benutzeroberflächenschicht (User Interface Layer)**

- **Bereitgestellte Funktionalität durch die Domänenschicht:**
    - **Logik und Zustand**: Die Domänenschicht stellt ihre Geschäftslogik und Zustandsinformationen über öffentliche APIs ihrer Service-Komponenten (oft als Traits definiert) und durch das Aussenden von domänenspezifischen Events bereit.
    - **Fehlertypen**: Jedes Domänenmodul definiert eigene `thiserror`-basierte Fehler-Enums (z.B. `ThemingError`, `WorkspaceCoreError`, `WindowAssignmentError`, `WorkspaceManagerError`, `WorkspaceConfigError`, `AIInteractionError`, `NotificationError`, `GlobalSettingsError` ).
    - **Events**: Domänenspezifische Events werden ausgelöst, um andere Schichten über Zustandsänderungen zu informieren (z.B. `ThemeChangedEvent`, `WorkspaceEvent`, `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`, `NotificationPostedEvent`, `SettingChangedEvent` ).
- **Nutzung durch die Systemschicht:**
    - **Domänenregeln anwenden**: Die Systemschicht wendet die von der Domänenschicht definierten Richtlinien technisch an.
        - `system::compositor` interagiert mit `domain::window_management` für Platzierungsrichtlinien.
        - `system::window_mechanics` setzt die Policy aus `domain::window_management_policy` technisch um.
    - **Zustände abfragen**: Liest Zustände und Konfigurationen aus der Domänenschicht.
        - MCP-Client (`system::mcp`) interagiert mit `AIInteractionLogicService` für Einwilligungen und Kontext.
        - D-Bus Handler (`system::dbus`) für Benachrichtigungen nutzt `NotificationService`.
    - **Fehlerbehandlung**: Fehler aus der Domänenschicht werden von der Systemschicht behandelt oder weiterpropagiert (ggf. gewrappt).
    - **Event-Konsum**: Die Systemschicht kann auf Domänen-Events reagieren (z.B. Compositor passt Sichtbarkeit bei `ActiveWorkspaceChanged` an ).
- **Nutzung durch die Benutzeroberflächenschicht (UI Layer):**
    - **Zustandsdarstellung**: Visualisiert Zustände und Daten aus der Domänenschicht.
        - `ui::theming_gtk` konsumiert `AppliedThemeState` von `ThemingEngine`.
        - `ui::shell` und `ui::control_center` nutzen `GlobalSettingsService` und `WorkspaceManager`.
    - **Geschäftslogik auslösen**: Löst Aktionen und Zustandsänderungen in der Domänenschicht basierend auf Benutzerinteraktionen aus.
    - **Fehlerbehandlung**: Behandelt Fehler aus der Domänenschicht und stellt sie ggf. benutzerfreundlich dar.
    - **Event-Konsum**: Abonniert Domänen-Events, um sich dynamisch zu aktualisieren.

**Spezifische Domänen-Service-Schnittstellen (Beispiele):**

- **`ThemingEngine` API**:
    - Methoden: `new()`, `get_current_theme_state()`, `get_available_themes()`, `get_current_configuration()`, `update_configuration()`, `reload_themes_and_tokens()`, `subscribe_to_theme_changes()`.
    - Events: `ThemeChangedEvent`.
- **`WorkspaceManager` API**:
    - Methoden: `new()`, `create_workspace()`, `delete_workspace()`, `set_active_workspace()`, `assign_window_to_active_workspace()`, `save_configuration()`, etc.
    - Events: `WorkspaceCreated`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, etc.
- **`AIInteractionLogicService` Trait API**:
    - Methoden: `initiate_interaction()`, `get_interaction_context()`, `provide_consent()`, `get_consent_for_model()`, `store_consent()`, `load_model_profiles()`, etc.
    - Events: `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`.
- **`NotificationService` Trait API**:
    - Methoden: `post_notification()`, `get_notification()`, `mark_as_read()`, `dismiss_notification()`, `set_do_not_disturb()`, etc.
    - Events: `NotificationPostedEvent`, `NotificationDismissedEvent`, etc.
- **`GlobalSettingsService` Trait API**:
    - Methoden: `load_settings()`, `save_settings()`, `get_current_settings()`, `update_setting()`, `get_setting()`, `reset_to_defaults()`, etc.
    - Events: `SettingChangedEvent`, `SettingsLoadedEvent`, `SettingsSavedEvent`.

**3. Systemschicht (System Layer) zu Benutzeroberflächenschicht (User Interface Layer)**

- **Bereitgestellte Funktionalität durch die Systemschicht:**
    - **Systemnahe Dienste und Ereignisse**: Stellt der UI-Schicht Informationen und Ereignisse bereit, die direkt vom Betriebssystem oder der Hardware stammen.
        - Fenstergeometrie, Fokusänderungen, neue Fenster
        - Eingabeereignisse (Tastatur, Maus, Touch, Gesten)
        - Statusänderungen von Systemdiensten (Netzwerk, Energie, Audio)
        - Monitor-/Output-Änderungen
    - **Technische Umsetzung von UI-Befehlen**: Empfängt Befehle von der UI-Schicht (z.B. Fenster verschieben, Space wechseln, Fokus anfordern) und setzt diese technisch um.
    - **Renderer-Schnittstelle**: Obwohl nicht direkt von der UI-Schicht konsumiert, stellt `system::compositor::renderer_interface` eine Abstraktion für das Rendering bereit, die vom Compositor genutzt wird, um die UI-Elemente darzustellen.
    - **Fehlertypen**: Jedes Systemschicht-Modul definiert eigene `thiserror`-basierte Fehler-Enums (z.B. `CompositorCoreError`, `ShmError`, `XdgShellError`, `InputError`, `RendererError` ).
- **Nutzung durch die Benutzeroberflächenschicht (UI Layer):**
    - **Empfang von Eingabeereignissen**: Die UI-Schicht empfängt verarbeitete Eingabeereignisse von der Systemschicht, um darauf zu reagieren (z.B. Klicks auf Buttons, Tastatureingaben in Textfeldern).
    - **Visualisierung von Systemzuständen**: Stellt Informationen dar, die von der Systemschicht bereitgestellt werden (z.B. aktive Fenster, Netzwerkstatus, Batterieladung, Audio-Lautstärke).
        - `ui::shell` und `ui::window_manager_frontend` interagieren mit `system::compositor` und `system::input` für Fenster- und Fokusinformationen.
        - UI-Indikatoren reagieren auf Events von `system::dbus` (UPower, NetworkManager) und `system::audio` (PipeWire).
    - **Auslösen von Systemaktionen**: Sendet Befehle an die Systemschicht basierend auf Benutzerinteraktionen (z.B. Klick auf "Fenster schließen", Auswahl eines anderen Netzwerks).
    - **Fehlerbehandlung**: Behandelt Fehler von der Systemschicht oder leitet sie an den Benutzer weiter.
    - **Event-Konsum**: Abonniert System-Events, um die UI dynamisch zu aktualisieren (z.B. Fokusänderung, neues Fenster, Output-Änderung).

**Spezifische Systemschicht-Schnittstellen (Beispiele für Interaktion mit UI):**

- **Compositor (`system::compositor`)**:
    - Stellt `WlSurface`-Informationen und Fensterstruktur bereit. Meldet Fensterzustände (Titel, AppID, Geometrie) an `ui::shell` und `ui::window_manager_frontend`.
    - Empfängt Befehle zur Fokusänderung von der UI.
- **Eingabeverarbeitung (`system::input`)**:
    - Sendet Fokusänderungs-Events und Cursor-Informationen an `ui::shell`.
    - Empfängt Befehle zur Fokusänderung von der UI.
- **D-Bus Clients (`system::dbus`)**:
    - `upower_client` sendet `UPowerEvent` (Batteriestatus) an UI.
    - `logind_client` sendet `LogindEvent` (Suspend, Sitzungssperre) an UI, kann `LockSession` von UI empfangen.
    - `networkmanager_client` sendet Netzwerkstatus-Events an UI.
    - `secrets_client` interagiert mit UI für Prompts.
- **Output-Management (`system::outputs`)**:
    - Meldet Output-Änderungen an `ui::shell` und `ui::control_center`.
    - Empfängt Konfigurationsbefehle (Auflösung, Skalierung) von `ui::control_center`.
- **Audio-Management (`system::audio`)**:
    - Sendet `AudioEvent` (Geräte-/Stream-Änderungen, Lautstärke) an UI.
    - Empfängt `AudioCommand` (Lautstärke ändern) von UI.
- **MCP-Client (`system::mcp`)**:
    - Stellt KI-Funktionen für UI-Elemente wie die Befehlspalette bereit.
    - Empfängt Anfragen von der UI.
- **XDG Desktop Portals (`system::portals`)**:
    - Interagiert mit `ui::shell`/`ui::components` zur Anzeige von Dialogen (FileChooser, Screenshot).

**Zusammenfassende Prinzipien der Schnittstellen:**

1. **Klare Verantwortlichkeiten**: Jede Schicht hat definierte Aufgaben, und die Schnittstellen spiegeln diese wider.
2. **Lose Kopplung**: Kommunikation erfolgt über APIs und Events, um direkte Abhängigkeiten von Implementierungsdetails zu minimieren.
3. **Hohe Kohäsion**: Module innerhalb einer Schicht arbeiten eng zusammen, aber die Schicht als Ganzes hat eine klar definierte externe Schnittstelle.
4. **Einheitliche Fehlerbehandlung**: Die `thiserror`-basierte Strategie wird über alle Schichten hinweg verwendet, wobei Fehler weitergeleitet oder spezifisch behandelt werden. Die `source()`-Kette ist wichtig.
5. **Event-gesteuerte Updates**: Viele Zustandsänderungen werden über Events kommuniziert, was eine reaktive und entkoppelte Architektur fördert.

Diese Spezifikation der internen Schnittstellen ist entscheidend, um sicherzustellen, dass die verschiedenen Schichten der NovaDE kohärent zusammenarbeiten und die Gesamtziele des Projekts – Performance, Intuition, Modernität, Modularität, Anpassbarkeit, sichere KI-Integration und Stabilität – erreicht werden können.**Technische Spezifikation der internen Schnittstellen zwischen den Schichten der Linux Desktop-Umgebung "NovaDE"**

Diese Spezifikation beschreibt die Art und Weise, wie die vier Hauptarchitekturschichten von NovaDE – Kernschicht, Domänenschicht, Systemschicht und Benutzeroberflächenschicht – miteinander interagieren. Die Kommunikation erfolgt primär über wohldefinierte öffentliche APIs, die oft als Rust-Traits implementiert sind, sowie über ein Event-System zur Signalisierung von Zustandsänderungen.

**1. Schnittstelle: Kernschicht (Core Layer) zu höheren Schichten (Domäne, System, UI)**

Die Kernschicht stellt fundamentale Bausteine und Dienste bereit, die von allen darüberliegenden Schichten genutzt werden.

- **Bereitgestellte Funktionalität:**
    - **`core::types`**: Definiert grundlegende, universell einsetzbare Datentypen.
        - **Schnittstelle**: Direkte Verwendung von Typen wie `Point<T>`, `Size<T>`, `Rect<T>`, `RectInt`, `Color`, `Orientation` sowie `uuid::Uuid` und `chrono::DateTime<Utc>` durch die höheren Schichten.
        - **Beispielhafte Nutzung**: Die Domänenschicht verwendet `Color` für Theming-Definitionen, die Systemschicht `RectInt` für Fenstergeometrien, und die UI-Schicht `Point<T>` für die Positionierung von Elementen.
    - **`core::errors`**: Stellt eine Basis-Fehlerbehandlungsstrategie und den `CoreError`-Typ bereit.
        - **Schnittstelle**: Höhere Schichten können `CoreError` oder spezifischere Fehler aus Kernmodulen mittels `#[from]` oder `#[source]` in ihre eigenen Fehlertypen wrappen. Die Fehlerursachenkette (`source()`) wird dabei beibehalten.
        - **Beispielhafte Nutzung**: Ein `ConfigError` in `domain::workspaces::config` kann einen `CoreError::Io` wrappen, der beim Lesen einer Datei in `core::config` aufgetreten ist.
    - **`core::logging`**: Definiert die Logging-Infrastruktur basierend auf `tracing`.
        - **Schnittstelle**: Alle höheren Schichten verwenden die `tracing`-Makros (`trace!`, `info!`, etc.) für ihre Logging-Ausgaben. Die Funktion `core::logging::initialize_logging()` wird typischerweise einmalig von der Anwendung (z.B. UI-Schicht) beim Start aufgerufen.
    - **`core::config`**: Stellt Primitive zum Laden, Parsen und Zugreifen auf Kernkonfigurationen bereit.
        - **Schnittstelle**: Funktionen wie `load_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError>` und `get_core_config() -> &'static CoreConfig` für den globalen Zugriff. Die `CoreConfig`-Struktur selbst ist Teil der Schnittstelle.
        - **Beispielhafte Nutzung**: `domain::settings_persistence_iface` (oder eine konkrete Implementierung wie `FilesystemConfigProvider` ) nutzt diese API, um Basiskonfigurationen zu lesen, die dann von der Domänenschicht weiterverarbeitet werden.
    - **`core::utils`**: Bietet allgemeine Hilfsfunktionen.
        - **Schnittstelle**: Direkte Nutzung der öffentlichen Funktionen durch alle höheren Schichten.

**2. Schnittstelle: Domänenschicht (Domain Layer) zu Systemschicht und Benutzeroberflächenschicht**

Die Domänenschicht kapselt die Geschäftslogik und den Kernzustand der Desktop-Umgebung.

- **Bereitgestellte Funktionalität:**
    
    - **Service-APIs (Traits)**: Öffentliche Schnittstellen werden primär durch Rust-Traits definiert, die von Service-Strukturen innerhalb der Domänenmodule implementiert werden.
        - `domain::theming::ThemingEngine`: Methoden wie `get_current_theme_state()`, `update_configuration()`.
        - `domain::workspaces::WorkspaceManager`: Methoden wie `create_workspace()`, `set_active_workspace()`.
        - `domain::user_centric_services::AIInteractionLogicService`: Methoden wie `initiate_interaction()`, `provide_consent()`.
        - `domain::user_centric_services::NotificationService`: Methoden wie `post_notification()`, `get_active_notifications()`.
        - `domain::global_settings_and_state_management::GlobalSettingsService`: Methoden wie `load_settings()`, `update_setting()`.
    - **Datenstrukturen**: Öffentliche Datenstrukturen, die Zustände oder Konfigurationen repräsentieren (z.B. `AppliedThemeState`, `Workspace`, `Notification`, `GlobalDesktopSettings` ).
    - **Events**: Domänenspezifische Events, die Zustandsänderungen signalisieren.
        - Beispiele: `ThemeChangedEvent`, `WorkspaceEvent` (z.B. `ActiveWorkspaceChanged` ), `NotificationPostedEvent`, `SettingChangedEvent`.
    - **Fehlertypen**: Modulspezifische Fehler-Enums (z.B. `ThemingError`, `WorkspaceManagerError`, `AIInteractionError`, `GlobalSettingsError` ).
- **Nutzung durch die Systemschicht:**
    
    - Die Systemschicht konsumiert die Service-APIs der Domänenschicht, um Geschäftsregeln anzuwenden und Zustände abzufragen.
        - Der `system::compositor` nutzt `domain::window_management_policy` für Fensterplatzierungsrichtlinien.
        - Der `system::mcp` Client interagiert mit `AIInteractionLogicService` für Einwilligungsprüfungen und Kontextinformationen.
        - `system::dbus` (für Benachrichtigungen) interagiert mit `NotificationService`.
    - Die Systemschicht kann auf Domänen-Events reagieren, um ihr Verhalten anzupassen (z.B. Umschalten der sichtbaren Surfaces im Compositor bei `ActiveWorkspaceChanged` ).
    - Fehler aus der Domänenschicht werden in der Systemschicht behandelt oder weitergeleitet.
- **Nutzung durch die Benutzeroberflächenschicht:**
    
    - Die UI-Schicht nutzt die Service-APIs der Domänenschicht, um Daten für die Darstellung abzurufen und Benutzeraktionen in Domänenlogik umzusetzen.
        - `ui::control_center` verwendet `GlobalSettingsService` zum Anzeigen und Ändern von Einstellungen.
        - `ui::shell` interagiert mit `WorkspaceManager` für die Workspace-Darstellung und -Navigation.
        - `ui::theming_gtk` reagiert auf `ThemeChangedEvent` und wendet Stile an.
    - Die UI-Schicht abonniert Domänen-Events, um ihre Ansichten dynamisch zu aktualisieren.
    - Fehler aus der Domänenschicht werden von der UI-Schicht behandelt und dem Benutzer ggf. in verständlicher Form präsentiert.

**3. Schnittstelle: Systemschicht (System Layer) zu Benutzeroberflächenschicht (UI Layer)**

Die Systemschicht stellt der UI-Schicht systemnahe Dienste und Ereignisse zur Verfügung und setzt deren Befehle technisch um.

- **Bereitgestellte Funktionalität:**
    
    - **Systemereignisse und -zustände**:
        - **Fensterinformationen**: Geometrie, Titel, AppID, Fokusstatus von Fenstern (aus `system::compositor` und `system::xdg_shell`).
        - **Eingabeereignisse**: Verarbeitete Tastatur-, Maus-, Touch- und Gestenereignisse (aus `system::input`).
        - **Output-Informationen**: Verfügbare Monitore, Auflösungen, Skalierungsfaktoren (aus `system::outputs`).
        - **Status von Systemdiensten**: Netzwerkverbindungen (`system::dbus::networkmanager_client` ), Energiestatus (`system::dbus::upower_client` ), Audiostatus (`system::audio` ).
        - **Sitzungsereignisse**: Sperren, Abmelden (von `system::dbus::logind_client` ).
    - **Ausführung von UI-Befehlen**:
        - Fenstermanipulationen (Verschieben, Größe ändern, Fokus setzen), initiiert durch die UI, werden vom `system::compositor` und `system::window_mechanics` umgesetzt.
        - Workspace-Wechsel.
        - Anpassung von Systemeinstellungen (z.B. Bildschirmhelligkeit, Lautstärke), die von `system::outputs` bzw. `system::audio` ausgeführt werden.
    - **Fehlertypen**: Modulspezifische Fehler-Enums (z.B. `CompositorCoreError`, `InputError` ).
- **Nutzung durch die Benutzeroberflächenschicht:**
    
    - **Darstellung von Systeminformationen**: Die UI visualisiert die von der Systemschicht bereitgestellten Zustände.
        - Fensterlisten, Titelleisten, Fokus-Hervorhebungen basieren auf Daten von `system::compositor`.
        - Netzwerk-, Batterie-, Audio-Indikatoren in `ui::shell` zeigen Daten von `system::dbus` und `system::audio`.
    - **Reaktion auf Eingabeereignisse**: UI-Elemente reagieren auf verarbeitete Eingabeereignisse, um Aktionen auszulösen.
    - **Initiierung von Systemaktionen**: Benutzerinteraktionen in der UI führen zu Befehlsaufrufen an die Systemschicht.
        - Klick auf "Lauter"-Button in `ui::shell` ruft eine Funktion in `system::audio` auf.
        - Auswahl eines anderen Monitorsetups in `ui::control_center` sendet Befehl an `system::outputs`.
    - **Dialoge über XDG Portals**: `ui::shell` oder `ui::components` interagieren mit `system::portals` für Datei-Auswahl- oder Screenshot-Dialoge.
    - Die UI-Schicht behandelt Fehler von der Systemschicht und informiert ggf. den Benutzer.
    - Die UI-Schicht reagiert auf Systemereignisse (z.B. `ActiveWorkspaceChanged` indirekt über Änderungen der sichtbaren Fenster, `DeviceAdded` für Eingabegeräte), um ihre Darstellung anzupassen.

**4. Allgemeine Kommunikationsmuster**

- **Synchrone Aufrufe**: Direkte Methodenaufrufe an Services oder Funktionen der tieferen Schicht für Anfragen, die eine sofortige Antwort erfordern oder direkte Zustandsmanipulationen durchführen.
- **Asynchrone Operationen**: Wo sinnvoll (z.B. I/O-gebundene Operationen in der Systemschicht oder langlaufende Prozesse in der Domänenschicht), werden `async/await` und entsprechende Runtimes (Tokio, GLib-Kontext) verwendet.
- **Event-Broadcasting**: Für entkoppelte Benachrichtigungen über Zustandsänderungen. Oft mittels `tokio::sync::broadcast` oder ähnlichen Mechanismen.
- **Fehlerpropagation**: Konsequente Nutzung von `Result<T, E>` und dem `?`-Operator. Fehler werden entweder behandelt oder an die aufrufende Schicht weitergegeben, wobei die `source()`-Kette erhalten bleibt.

Diese detaillierte Spezifikation der internen Schnittstellen dient als Grundlage für eine modulare, wartbare und robuste Entwicklung der NovaDE. Die klare Trennung der Verantwortlichkeiten und die wohldefinierten Kommunikationswege sind entscheidend für den Erfolg des Projekts.

# Infrastruktur
## 1. Kernschicht
Diese Spezifikation beschreibt die fundamentalen Komponenten und Richtlinien für die Entwicklung der Kernschicht der Desktop-Umgebung. Die Kernschicht bildet das Fundament für alle darüberliegenden Schichten und umfasst Module für grundlegende Datentypen (`core::types`), Fehlerbehandlung (`core::errors`), Logging (`core::logging`), Konfigurationsmanagement (`core::config`) und allgemeine Hilfsfunktionen (`core::utils`).

### 1\. Modul: `core::types` (Fundamentale Datentypen)

**1.1. Zweck und Verantwortlichkeit**
Das Modul `core::types` definiert grundlegende, universell einsetzbare Datentypen, die von allen anderen Schichten und Modulen benötigt werden[cite: 3]. Dazu gehören geometrische Primitive, Farbdarstellungen und allgemeine Enumerationen[cite: 4]. Diese Typen sind reine Datenstrukturen ohne komplexe Geschäftslogik oder Abhängigkeiten zu höheren Schichten[cite: 5].

**1.2. Designphilosophie**
Das Design folgt den Prinzipien der Modularität, Wiederverwendbarkeit und minimalen Kopplung[cite: 7]. Typen sind generisch gehalten, wo sinnvoll (z.B. `Point<T>`, `Size<T>`, `Rect<T>`), um Flexibilität für verschiedene numerische Darstellungen zu ermöglichen (z.B. `i32` für Koordinaten, `f32` für Skalierungsfaktoren)[cite: 8]. Es besteht eine klare Trennung von Datenrepräsentation und Fehlerbehandlung[cite: 9].

**1.3. Ziel-Dateistruktur** [cite: 29, 30]

```
core/
└── src/
    ├── lib.rs         # Deklariert Kernmodule: pub mod types; pub mod errors; ...
    └── types/
        ├── mod.rs     # Deklariert und re-exportiert Typen aus geometry.rs, color.rs, etc.
        ├── geometry.rs # Enthält Point<T>, Size<T>, Rect<T>
        ├── color.rs    # Enthält Color
        └── enums.rs    # Enthält Orientation, etc.
```

**1.4. Spezifikation: Geometrische Primitive (`geometry.rs`)**

  * **`Point<T>`**: Repräsentiert einen Punkt im 2D-Raum mit `x: T` und `y: T`[cite: 31, 32].

      * Konstanten wie `ZERO_I32`, `ZERO_F32` etc.[cite: 33, 34, 35, 36].
      * Methoden: `new(x: T, y: T)`, `distance_squared(...)`, `distance(...)` (für Float-Typen), `manhattan_distance(...)`[cite: 37, 38, 40, 41].
      * Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`[cite: 44].

  * **`Size<T>`**: Repräsentiert eine 2D-Dimension mit `width: T` und `height: T`[cite: 45].

      * Konstanten wie `ZERO_I32`, `ZERO_F32` etc.[cite: 46, 47, 48, 49].
      * Methoden: `new(width: T, height: T)`, `area()`, `is_empty()`, `is_valid()` (für nicht-negative Dimensionen)[cite: 50, 51, 52, 53].
      * Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`[cite: 55]. Die Invariante nicht-negativer Dimensionen wird durch `is_valid()` prüfbar gemacht, aber nicht durch den Typ erzwungen[cite: 55].

  * **`Rect<T>`**: Repräsentiert ein 2D-Rechteck, definiert durch `origin: Point<T>` und `size: Size<T>`[cite: 56, 57].

      * Konstanten wie `ZERO_I32`, `ZERO_F32` etc.[cite: 58, 59, 60, 61].
      * Methoden: `new(origin, size)`, `from_coords(x,y,width,height)`, Zugriffsmethoden (`x()`, `y()`, `width()`, `height()`, `top()`, `left()`, `bottom()`, `right()`), `center()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translated(...)`, `scaled(...)`, `is_valid()`[cite: 62, 63, 64, 65, 66, 67, 68, 69, 70, 71].
      * Basis-Constraints für `T`: `Copy + Debug + PartialEq + Default + Send + Sync + 'static`[cite: 73].
      * **Invariante**: Logisch sollten `width` und `height` nicht-negativ sein[cite: 73]. Die Methode `is_valid()` wird bereitgestellt; Nutzer (besonders mit `T=i32`) sollten diese aufrufen[cite: 80, 81]. Die Verantwortung für das Melden eines Fehlers bei Verwendung eines ungültigen `Rect` liegt beim Aufrufer[cite: 83].

  * **`RectInt`**: (aus einer anderen Quelldatei, aber thematisch passend) Repräsentiert ein achsenparalleles Rechteck mit ganzzahligen Koordinaten (`x: i32`, `y: i32`) und Dimensionen (`width: u32`, `height: u32`)[cite: 566, 567, 572].

      * Methoden u.a. `new(...)`, `from_points(...)`, `top_left()`, `size()`, `right()`, `bottom()`, `contains_point(...)`, `intersects(...)`, `intersection(...)`, `union(...)`, `translate(...)`, `inflate(...)`, `is_empty()`[cite: 572, 573, 576, 577, 578, 580, 581, 583, 585, 588, 591, 593, 596].
      * Verwendet `saturating_add` / `saturating_sub` um Überläufe zu vermeiden[cite: 578, 580, 592, 594].
      * Traits: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Default`[cite: 599].

**1.5. Spezifikation: Farbdarstellung (`color.rs`)**

  * **`Color` (RGBA)**: Repräsentiert eine Farbe mit `r: f32`, `g: f32`, `b: f32`, `a: f32` Komponenten im Bereich `[0.0, 1.0]`[cite: 85, 86, 87].
      * Konstanten: `TRANSPARENT`, `BLACK`, `WHITE`, `RED`, `GREEN`, `BLUE` etc.[cite: 88, 89, 90, 91, 92, 93].
      * Methoden: `new(r,g,b,a)` (klemmt Werte nicht automatisch, Aufruferverantwortung)[cite: 95], `from_rgba8(r,g,b,a)`, `to_rgba8()`, `with_alpha(alpha)` (klemmt Alpha), `blend(background)`, `lighten(amount)`, `darken(amount)`[cite: 96, 97, 99, 100, 101, 102, 103].
      * `Default` wird manuell implementiert, um `Color::TRANSPARENT` zurückzugeben[cite: 106, 113].
      * Soll `Serialize` und `Deserialize` implementieren, um als Hex-String (z.B. "\#RRGGBBAA") in Konfigurationsdateien dargestellt zu werden[cite: 603, 610, 622, 623]. Dies erfordert eine `ColorParseError`-Behandlung[cite: 603, 610, 628].

**1.6. Spezifikation: Allgemeine Enumerationen (`enums.rs`)**

  * **`Orientation`**: Repräsentiert eine horizontale oder vertikale Ausrichtung[cite: 107].
      * Varianten: `Horizontal`, `Vertical`[cite: 108].
      * Methoden: `toggle()`[cite: 108].
      * `Default` ist `Orientation::Horizontal`[cite: 109, 113].

**1.7. Standard Trait Implementierungen**
Alle Typen sollen grundlegende Traits wie `Debug`, `Clone`, `Copy` (wo anwendbar und `T` es unterstützt), `PartialEq`, `Default` (sinnvoll definiert), `Send` und `Sync` implementieren[cite: 14, 42, 44, 54, 55, 72, 73, 105, 106, 109, 110, 111, 112]. `Eq` und `Hash` sind für Fließkommazahlen generell nicht geeignet[cite: 113].

**1.8. Modulabhängigkeiten**
Minimale externe Abhängigkeiten: `std`[cite: 25, 26]. Optional `num-traits` (für erweiterte numerische Operationen) und `serde` (mit `derive`-Feature, falls Serialisierung direkt hier benötigt wird, aktuell aber eher in höheren Schichten vorgesehen)[cite: 26, 27, 28].

### 2\. Modul: `core::errors` (Fehlerbehandlung)

**2.1. Zweck und Geltungsbereich**
Spezifiziert die verbindliche Strategie und Implementierung der Fehlerbehandlung innerhalb der Kernschicht[cite: 146]. Ziel ist eine lückenlose, präzise Spezifikation für Entwickler[cite: 149].

**2.2. Grundlagen und Prinzipien**

  * **Verwendung von `thiserror`**: Obligatorisch für die Definition von benutzerdefinierten Fehlertypen[cite: 150, 156, 397]. `thiserror` reduziert Boilerplate-Code für `std::error::Error` und `std::fmt::Display`[cite: 151, 157, 399]. Alle benutzerdefinierten Fehler-Enums in der Kernschicht müssen `thiserror::Error` ableiten[cite: 157].
  * **`Result<T, E>` vs. `panic!`**: Strikte Trennung[cite: 158].
      * `Result<T, E>`: Standard für erwartete, potenziell behebbare Fehlerzustände (z.B. I/O-Fehler, ungültige Eingaben)[cite: 158, 159]. Funktionen müssen `Result<T, E>` zurückgeben, wobei `E` typischerweise `CoreError` oder ein spezifischerer Modul-Fehler ist[cite: 160].
      * `panic!`: Ausschließlich für nicht behebbare Programmierfehler (Bugs), Verletzung von Vorbedingungen oder logisch unmögliche interne Zustände[cite: 161, 361].
  * **Umgang mit `.unwrap()` und `.expect()`**: In produktivem Code der Kernschicht strengstens zu vermeiden, da sie die strukturierte Fehlerbehandlung umgehen[cite: 164, 362, 364].
      * Ausnahme für `expect()`: Nur wenn ein `Err`- oder `None`-Zustand nachweislich einen Bug darstellt (interne Invariante verletzt)[cite: 164, 368]. Die Nachricht muss dem "expect as precondition"-Stil folgen und erklären, *warum* ein `Ok`- oder `Some`-Wert erwartet wurde[cite: 165, 371, 373, 450].
  * **Anforderungen an Fehlermeldungen (`#[error("...")]`)**:
      * Klarheit und Präzision, eindeutige Problembeschreibung[cite: 169, 299, 413].
      * Kontextinformationen durch eingebettete Feldwerte (`{field_name}`)[cite: 170, 300, 414].
      * Zielgruppe: Entwickler (für Logging/Debugging)[cite: 170, 415].
      * Format: Knappe, klein geschriebene Sätze ohne abschließende Satzzeichen (Rust API Guidelines)[cite: 172, 298, 415].
  * **Keine sensiblen Daten in Fehlermeldungen**: Niemals Passwörter, API-Schlüssel, private Benutzerdaten etc. in Fehlermeldungen oder Kontextfeldern[cite: 222, 223, 441]. Daten müssen maskiert, entfernt oder durch Platzhalter ersetzt werden[cite: 224].

**2.3. Strategie: Ein Fehler-Enum pro Modul**
Jedes signifikante Modul innerhalb der Kernschicht (und höheren Schichten) definiert sein eigenes, spezifisches Fehler-Enum mit `thiserror`[cite: 200, 201, 337, 402]. Dies vermeidet Überladung des zentralen `CoreError` und adressiert `thiserror`-Einschränkungen bezüglich mehrdeutiger `#[from]`-Konvertierungen desselben Quelltyps[cite: 173, 175, 202, 205, 403].

**2.4. Definition des Basis-Fehlertyps: `CoreError`**
Ein zentrales, öffentliches Enum `CoreError` in `core::errors` dient als primäre Schnittstelle für Fehler, die von öffentlichen Funktionen der Kernschicht propagiert werden[cite: 178, 179, 290]. Es aggregiert allgemeine Fehlerarten und spezifischere Fehler aus Untermodulen (via `#[from]`)[cite: 180, 184].

  * **Spezifikation `CoreError`** (Beispielvarianten)[cite: 182, 183, 184, 187, 188, 191, 293, 294, 295, 296]:
      * `Io { path: PathBuf, #[source] source: std::io::Error }` [cite: 183, 197, 295]
      * `Configuration(#[from] ConfigError)` [cite: 184, 197]
      * `Serialization { description: String }` [cite: 186, 197]
      * `InvalidId { invalid_id: String }` [cite: 187, 197]
      * `NotFound { resource_description: String }` [cite: 188, 197]
      * `Internal(String)` (sollte vermieden und durch spezifischere Varianten ersetzt werden) [cite: 191, 197]
      * `InitializationFailed { component: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }` [cite: 293, 309]
  * **Ableitungen**: Mindestens `Debug` und `thiserror::Error`[cite: 193, 194].
  * **Fehlerverkettung (`source()`)**: Wird von `thiserror` automatisch für `#[source]` und `#[from]` annotierte Felder implementiert, um die Ursache zurückzuverfolgen[cite: 194, 195, 303, 326, 431].

**2.5. Modul-spezifische Fehler und Integration**
Module definieren eigene Fehler-Enums (z.B. `ConfigError`, `UtilsError`) die `thiserror::Error` ableiten[cite: 200, 201, 338].

  * **Integrationsmechanismus**: Eine dedizierte Variante in `CoreError`, die den Modul-Fehler kapselt und `#[from]` verwendet, ist der bevorzugte Weg[cite: 206, 209, 239, 349]. Beispiel: `Configuration(#[from] ConfigError)` in `CoreError`.
  * Dies etabliert eine zweistufige Fehlerhierarchie[cite: 209, 210].

**2.6. Fehlerkontext und Diagnose**
Fehlervarianten sollen relevante Kontextinformationen als Felder enthalten (Dateipfade, ungültige Werte etc.)[cite: 215, 216, 421].

**2.7. Implementierungsleitfaden für Entwickler (Fehlerdefinition und -behandlung)**

  * **Neue Variante zu `CoreError` hinzufügen**: Prüfen, ob der Fehlerfall allgemeine Bedeutung hat oder besser in einem Modul-Fehler aufgehoben ist[cite: 225]. Variante, `#[error]`-Meldung und Kontextfelder definieren[cite: 226, 228, 229]. `#[source]` oder `#[from]` für Kapselung verwenden[cite: 230, 231, 232].
  * **Neuen Modul-Fehler erstellen**: `errors.rs` im Modulverzeichnis anlegen[cite: 234]. Enum definieren, `thiserror::Error` ableiten, Varianten und Meldungen spezifizieren[cite: 235, 236]. In `CoreError` über eine `#[from]`-Variante integrieren[cite: 237, 238, 239].
  * **Verwendung des `?`-Operators**: Standard für Fehlerpropagation[cite: 240, 243, 428]. Funktioniert nahtlos bei identischen Fehlertypen oder existierender `From`-Implementierung[cite: 243].
  * **Fehler-Matching (`match`)**: Für spezifische Behandlung (Standardwerte, alternative Pfade, Anreicherung)[cite: 244].
  * **Umgang mit externen Crates**: Fehler von externen Bibliotheken müssen in einen Kernschicht-Fehlertyp (`CoreError` oder Modul-Fehler) gekapselt werden[cite: 253]. Bevorzugt mit `#[from]` oder `#[source]` (manuelle Erzeugung via `.map_err()`)[cite: 254, 255, 256, 257].

### 3\. Modul: `core::logging` (Logging-Infrastruktur)

**3.1. Grundlagen und Wahl von `tracing`**
Die Desktop-Umgebung verwendet das `tracing`-Crate für strukturiertes Logging[cite: 390, 456]. `core::logging` stellt Initialisierungsroutinen bereit[cite: 457].

**3.2. `tracing` Framework Integrationsdetails**

  * **Initialisierung**: Eine Funktion `initialize_logging(level_filter: tracing::LevelFilter, format: LogFormatEnum) -> Result<(), LoggingError>` wird früh im Anwendungsstart aufgerufen[cite: 458, 459]. `LogFormatEnum` könnte `PlainTextDevelopment`, `JsonProduction` definieren[cite: 460]. `LoggingError` ist ein `thiserror`-Enum in `core::logging`[cite: 460].
  * **Subscriber-Konfiguration**:
      * Entwicklung: `tracing_subscriber::fmt()` mit menschenlesbarer Ausgabe (`with_ansi(true)`, `with_target(true)`, `with_file(true)`, `with_line_number(true)`)[cite: 461, 462].
      * Release: Strukturiertes JSON-Format für Log-Aggregation und maschinelle Analyse (`tracing_subscriber::fmt::json()` oder `tracing-bunyan-formatter`)[cite: 462].
  * **Dynamische Log-Level-Änderungen**: Für zukünftige Erweiterungen berücksichtigen (z.B. via `tracing_subscriber::filter::EnvFilter` oder `RUST_LOG`)[cite: 464, 465].

**3.3. Standardisierte Log-Makros und `tracing::instrument` Verwendung**

  * **Standard-Makros**: Direkte Verwendung von `trace!`, `debug!`, `info!`, `warn!`, `error!` ist verbindlich[cite: 466].
  * **Log-Nachrichtenstruktur**: Prägnant und beschreibend[cite: 467]. Schlüssel-Wert-Paare für strukturierte Daten: `tracing::info!(user_id = %user.id, " Nachricht")` (% für Display, ? für Debug)[cite: 467]. Fehler mit `error = ?err` loggen, um die Debug-Repräsentation (inkl. `source`-Kette) zu erfassen[cite: 468, 469].
  * **`#[tracing::instrument]` Verwendung**: Erzeugt Spans für Funktionen/Codeblöcke, gruppiert Log-Ereignisse[cite: 470].
      * Anwendung auf öffentliche API-Funktionen, I/O-Operationen, komplexe Berechnungen, abgeschlossene operative Einheiten[cite: 471, 472].
      * `skip(...)` / `skip_all` für sensible/ausführliche Argumente[cite: 473, 488].
      * `fields(...)` für spezifischen Kontext im Span[cite: 474].
      * `err` zur automatischen Fehlerprotokollierung bei `Result::Err`[cite: 475].
      * `level` zur Steuerung des Span-Levels[cite: 476].

**3.4. Logging von Fehlern**
Jeder Fehler (`Result::Err`) sollte an seiner Ursprungsstelle oder einer geeigneten übergeordneten Stelle mit ausreichend Kontext geloggt werden, mindestens auf `ERROR`-Level (`tracing::error!`)[cite: 261, 262]. Dies sollte typischerweise *vor* der Propagation geschehen[cite: 263, 264]. Den Fehler selbst als strukturiertes Feld mitgeben: `error!(error = %core_err, "Nachricht")`[cite: 266, 270, 271].

**3.5. Log-Daten Sensibilität**
Absolutes Verbot, sensible Daten (Passwörter, API-Schlüssel, PII etc.) im Klartext zu loggen[cite: 441, 483]. Daten redigieren oder auslassen[cite: 484]. Vorsicht bei `Debug`-Implementierungen für Strukturen mit sensiblen Daten; ggf. manuelle Redaktion in `Debug` oder `skip_all` in `#[tracing::instrument]` verwenden[cite: 485, 486, 487, 488].

### 4\. Modul: `core::config` (Konfigurationsprimitive)

**4.1. Zweck**
Definiert, wie grundlegende Konfigurationseinstellungen geladen, geparst und zugegriffen werden[cite: 391, 495]. Fokus auf Einfachheit, Robustheit[cite: 496].

**4.2. Konfigurationsdateiformat und Parsing-Logik**

  * **Format**: TOML (Tom's Obvious, Minimal Language) wegen Lesbarkeit und einfacher Verarbeitung[cite: 497].
  * **Parsing-Bibliothek**: `serde` in Verbindung mit `toml`-Crate (`serde_toml`)[cite: 498].
  * **Ladelogik**:
      * Definition von Standard-Konfigurationspfaden (z.B. systemweit, Entwicklungstests)[cite: 499]. XDG-Pfade für benutzerspezifische Konfigurationen in höheren Schichten berücksichtigen[cite: 500].
      * Eine Funktion wie `load_core_config(custom_path: Option<PathBuf>) -> Result<CoreConfig, ConfigError>` implementiert eine Suchreihenfolge, liest und deserialisiert die TOML-Datei[cite: 501, 502, 503, 504].
      * Fehlerbehandlung mit `core::config::ConfigError` (definiert mit `thiserror`), Varianten wie `FileReadError`, `DeserializationError`, `NoConfigurationFileFound`[cite: 504, 505, 506, 507, 508].

**4.3. Konfigurationsdatenstrukturen (Ultra-Fein)**

  * **`CoreConfig`-Struktur**: Eine primäre Struktur (z.B. `CoreConfig`) hält alle spezifischen Konfigurationen der Kernschicht[cite: 509, 510, 511, 512, 513, 514].
      * Felder mit explizit definierten Typen[cite: 514].
      * Muss `serde::Deserialize` ableiten[cite: 515].
      * `#[serde(default = "path")]` oder `#[serde(default)]` umfassend verwenden für Standardwerte bei fehlenden Feldern[cite: 511, 512, 513, 516, 517].
      * `#[serde(deny_unknown_fields)]` erzwingen, um Tippfehler oder unbekannte Felder in Konfigurationsdateien zu verhindern[cite: 512, 513, 518].
  * **Validierung**: Grundlegende Validierung durch Typen[cite: 519]. Komplexere Validierungen nach Deserialisierung (z.B. via `TryFrom` Muster oder `validate()`-Methode)[cite: 520, 521]. Für Kernschicht kann initiale Validierung auf `serde`-Fähigkeiten beschränkt sein[cite: 522].

**4.4. Konfigurationszugriffs-API**

  * **Globaler Zugriff**: Geladene `CoreConfig`-Instanz threadsicher speichern, typischerweise mittels `once_cell::sync::OnceCell`[cite: 530, 531, 532].
      * `initialize_core_config(config: CoreConfig) -> Result<(), CoreConfig>` zum einmaligen Setzen[cite: 532, 533, 534].
      * `get_core_config() -> &'static CoreConfig` für den Zugriff; paniert, wenn nicht initialisiert (Programmierfehler)[cite: 535, 536].
  * **Immutabilität**: Global zugängliche Konfiguration sollte nach Initialisierung unveränderlich sein[cite: 541]. `CoreConfig` sollte `Clone` ableiten für Momentaufnahmen oder Tests[cite: 540, 543, 544].

### 5\. Modul: `core::utils` (Allgemeine Hilfsfunktionen)

**5.1. Zweck**
Beherbergt allgemeine Hilfsfunktionen und kleine, in sich geschlossene Utilities, die nicht in spezifischere Module passen, aber breit verwendet werden[cite: 392, 546].

**5.2. Allgemeine Richtlinien** [cite: 556, 557, 558, 559, 560, 561, 562]

  * **Geltungsbereich**: Nur wirklich allgemeine Utilities.
  * **Einfachheit**: Einfache Funktionen bevorzugen.
  * **Reinheit**: Reine Funktionen (Ausgabe hängt nur von Eingabe ab, keine Seiteneffekte) bevorzugen.
  * **Fehlerbehandlung**: Jede fehleranfällige Utility-Funktion gibt `Result<T, YourUtilError>` zurück, wobei `YourUtilError` mit `thiserror` im Utility-Submodul definiert wird.
  * **Dokumentation**: Umfassende `rustdoc`-Kommentare mit Beispielen.
  * **Tests**: Gründliche Unit-Tests.

### 6\. Allgemeine Entwicklungsrichtlinien (Kernschicht)

**6.1. Dokumentation (`rustdoc`)** [cite: 133, 134, 135, 136, 137, 138, 139]
Alle öffentlichen Elemente (Module, Structs, Enums, Felder, Konstanten, Methoden) müssen `///`-Dokumentationskommentare haben.

  * Modul-Level: Zweck des Moduls.
  * Typ-Level: Zweck und Invarianten.
  * Feld-Level: Bedeutung des Feldes.
  * Methoden-Level: Was die Methode tut, Parameter, Rückgabewerte, mögliche Panics (idealerweise keine außer in Tests), Vor-/Nachbedingungen, Algorithmen.
  * `# Examples`-Abschnitte verwenden.
  * Strikte Einhaltung der Rust API Guidelines.
  * `cargo doc --open` zur Überprüfung.

**6.2. Unit-Testing** [cite: 128, 129, 130, 131, 132]

  * Ein `#[cfg(test)]`-Modul innerhalb jeder Implementierungsdatei.
  * Tests für Konstruktoren, Konstanten, Methodenlogik, Grenzfälle, Trait-Implementierungen, Invariantenprüfungen.
  * Anstreben einer hohen Testabdeckung.

**6.3. Immutabilität und Stabilität**
Die API der Kernschicht sollte nach Stabilisierung als äußerst stabil behandelt werden[cite: 643]. Änderungen haben weitreichende Auswirkungen[cite: 644]. Komponenten sind so konzipiert, dass sie `Send + Sync` sind, wo sinnvoll, für Multithreading[cite: 644].

**6.4. Schichtübergreifende Integrationsrichtlinien** [cite: 633, 634, 635, 636, 637, 638, 639, 640, 641, 642]

  * **Fehlerbehandlung**: Höhere Schichten definieren eigene `thiserror`-Enums. Fehler aus der Kernschicht werden behandelt oder via `?` propagiert (ggf. mit `#[from]` in eigene Fehlertypen konvertiert), Fehlerkette (`source()`) muss erhalten bleiben.
  * **Logging**: Alle Schichten nutzen `tracing`-Makros. `core::logging::initialize_logging()` wird vom Hauptbinary aufgerufen. Einhaltung von Log-Leveln und Datensensibilität ist zwingend.
  * **Konfiguration**: Höhere Schichten können eigene Konfigs definieren. Zugriff auf Kern-Konfig via `core::config::get_core_config()`. Kern-Konfig nicht zur Laufzeit modifizieren.
  * **Typen und Utilities**: Kerndatentypen und -utilities direkt verwenden. Bei Spezialisierung Komposition oder Newtype-Wrapper um Kerntypen in Betracht ziehen.

Diese Spezifikation legt den Grundstein für eine robuste, wartbare und performante Kernschicht. Die disziplinierte Einhaltung dieser Richtlinien ist für den Erfolg des Projekts entscheidend[cite: 284, 632, 645].
## 2. Domänenschicht

### 1. Allgemeine Prinzipien und Entwicklungsrichtlinien der Domänenschicht

Die Domänenschicht ist das Herzstück der Anwendungslogik und repräsentiert die Geschäftsregeln und -konzepte der Desktop-Umgebung. Sie ist UI-unabhängig und entkoppelt von spezifischen Systemdetails oder Infrastrukturbelangen. [cite: 4, 332, 1105]

**Entwicklungsrichtlinien:**

* **Sprache und Tooling:** Rust wird als primäre Programmiersprache verwendet.
    * **Fehlerbehandlung:** `thiserror` wird für die Definition spezifischer, benutzerdefinierter Fehler-Enums pro Modul verwendet. [cite: 179, 379, 821, 1150] Dies ermöglicht eine klare Kommunikation von Fehlerzuständen. [cite: 180] Fehler werden über `Result<T, E>` zurückgegeben; `unwrap()` und `expect()` sind zu vermeiden, außer in absoluten Ausnahmefällen. [cite: 181, 199, 200, 686] Die `source()`-Kette von Fehlern soll durch korrekte Verwendung von `#[source]` und `#[from]` erhalten bleiben. [cite: 184, 204, 388, 518, 683, 829]
    * **Serialisierung/Deserialisierung:** `serde` (mit `serde_json` für JSON) wird für das Laden und Speichern von Konfigurationen und Datenstrukturen verwendet. [cite: 6, 50, 910] Attribute wie `#[serde(rename_all = "kebab-case")]`, `#[serde(default)]` und `#[serde(skip_serializing_if = "Option::is_none")]` sollen konsistent genutzt werden. [cite: 13, 35, 233, 914, 1034]
    * **Asynchronität:** Wo Operationen potenziell blockierend sind (z.B. I/O beim Laden von Konfigurationen, Kommunikation mit externen Diensten), werden `async/await` und `async_trait` verwendet. [cite: 757, 935, 1133, 1191] Für nebenläufigen Zugriff auf geteilte Zustände sind `tokio::sync` Mechanismen wie `RwLock` und `Mutex` einzusetzen. [cite: 117, 1137, 1180, 1252, 1286]
    * **Eindeutige IDs:** `uuid` (Version 4) wird zur Generierung eindeutiger Identifikatoren für Entitäten verwendet. [cite: 344, 732, 1108, 1227]
    * **Zeitstempel:** `chrono::DateTime<Utc>` wird für Zeitstempel verwendet, um Konsistenz zu gewährleisten. [cite: 352, 713, 1108, 1227]
    * **Event-Handling:** `tokio::sync::broadcast` wird für ein entkoppeltes, internes Event-System genutzt, um Änderungen an andere Systemteile zu kommunizieren. [cite: 119, 1135, 1255]
* **Modularität und Kohäsion:** Die Domänenschicht ist in klar abgegrenzte Module unterteilt, die jeweils spezifische Verantwortlichkeiten haben (z.B. `domain::theming`, `domain::workspaces`, `domain::user_centric_services`, `domain::global_settings_and_state_management`, `domain::notifications_core`, `domain::notifications_rules`). [cite: 1, 333, 697, 895, 1097] Jedes Modul sollte eine hohe Kohäsion aufweisen und lose mit anderen Modulen gekoppelt sein.
* **Typsicherheit:** Newtypes und spezifische Enums werden verwendet, um die Typsicherheit zu erhöhen und die Semantik von Daten klarer zu gestalten (z.B. `TokenIdentifier`[cite: 8, 9], `WorkspaceId`[cite: 364, 365], `SettingKey` [cite: 1108, 1109]).
* **Abstraktion und Schnittstellen:** Öffentliche APIs von Modulen werden oft durch Traits definiert, um Implementierungsdetails zu kapseln und Testbarkeit durch Mocking zu ermöglichen (z.B. `AIInteractionLogicService`[cite: 755, 757], `NotificationService`[cite: 755, 770], `GlobalSettingsService`[cite: 933, 937], `SettingsProvider` [cite: 1103, 1185]).
* **Zustandsverwaltung:** Veränderliche Zustände innerhalb von Services werden typischerweise mit `Arc<Mutex<...>>` oder `Arc<RwLock<...>>` gekapselt, um Thread-Sicherheit zu gewährleisten. [cite: 117, 1137]
* **Validierung:** Eingabedaten und Einstellungsänderungen werden aktiv validiert, um die Konsistenz und Integrität der Domänendaten sicherzustellen. [cite: 51, 53, 59, 346, 900, 1102]
* **Logging:** Das `tracing`-Framework soll für strukturiertes Logging und Debugging verwendet werden. [cite: 61, 257, 873, 1059, 1311]
* **Dokumentation:** Öffentliche Typen, Methoden und Felder müssen umfassend mit `rustdoc`-Kommentaren dokumentiert werden, inklusive Vor- und Nachbedingungen, Fehler und Beispiele. [cite: 415, 416, 555]
* **Testbarkeit:** Unit-Tests sind parallel zur Implementierung zu erstellen und sollen eine hohe Codeabdeckung anstreben. [cite: 230, 317, 868, 885, 1053] Mocking von Abhängigkeiten (insbesondere von Schnittstellen zur Kern- oder Systemschicht) ist entscheidend. [cite: 325, 557, 892, 1080]

### 2. Struktur und Kernkomponenten der Domänenschicht

Die Domänenschicht besteht aus mehreren Kernmodulen, die spezifische Aufgabenbereiche abdecken:

#### 2.1. Modul: `domain::theming`

* **Verantwortlichkeit:** Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel (Farbschema, Akzentfarben). [cite: 1, 2, 3]
* **Datenstrukturen:**
    * `TokenIdentifier` (String-Wrapper für hierarchische Token-IDs wie "color.background.primary"). [cite: 8, 9]
    * `TokenValue` (Enum für Token-Wertetypen: Color, Dimension, FontSize, FontFamily, FontWeight, LineHeight, LetterSpacing, Border, Shadow, Radius, Spacing, ZIndex, Opacity, Text, Reference zu anderem Token). [cite: 11, 12, 13, 14]
    * `RawToken` (Struct: id, value, optionale description, group). [cite: 15, 16, 39]
    * `TokenSet` (Typalias für `HashMap<TokenIdentifier, RawToken>`). [cite: 17]
    * `ThemeIdentifier` (String-Wrapper für Theme-IDs). [cite: 18, 19]
    * `ColorSchemeType` (Enum: Light, Dark). [cite: 20]
    * `AccentColor` (Struct: optionaler name, value als CSS-Farbwert). [cite: 21]
    * `ThemeVariantDefinition` (Struct: applies_to_scheme, tokens als TokenSet für Überschreibungen). [cite: 22, 23]
    * `ThemeDefinition` (Struct: id, name, description, author, version, base_tokens, variants, supported_accent_colors). [cite: 24, 25, 26, 41]
    * `AppliedThemeState` (Struct: theme_id, color_scheme, active_accent_color, resolved_tokens als `HashMap<TokenIdentifier, String>`). [cite: 27, 28, 29, 31, 43]
    * `ThemingConfiguration` (Struct: selected_theme_id, preferred_color_scheme, selected_accent_color, custom_user_token_overrides). [cite: 32, 33, 34]
* **Kernlogik (`ThemingEngine` Service):** [cite: 112, 114]
    * Laden, Parsen und Validieren von Token- (*.tokens.json) und Theme-Definitionen (*.theme.json) von standardisierten Pfaden (System- und Benutzer-spezifisch). [cite: 46, 47, 48, 56] Validierung beinhaltet Eindeutigkeit von Token-IDs und Erkennung zyklischer Referenzen. [cite: 51, 53, 54]
    * Token Resolution Pipeline: Auflösung von Token-Referenzen und Anwendung von Überschreibungen (Theme-Basis, Variante, Akzentfarbe, Benutzer-Overrides) in definierter Reihenfolge. [cite: 64, 65, 66, 67] Ergebnis ist der `AppliedThemeState`.
    * Dynamische Theme-Wechsel basierend auf Änderungen in `ThemingConfiguration`. [cite: 99, 100]
    * Caching von aufgelösten `AppliedThemeState`s. [cite: 96, 97]
* **Öffentliche API (`ThemingEngine`):**
    * `new(initial_config, theme_load_paths, token_load_paths)`: Konstruktor. [cite: 129]
    * `get_current_theme_state()`: Gibt aktuellen `AppliedThemeState` zurück. [cite: 125, 137]
    * `get_available_themes()`: Gibt `Vec<ThemeDefinition>` zurück. [cite: 126, 141]
    * `get_current_configuration()`: Gibt aktuelle `ThemingConfiguration` zurück. [cite: 127, 143]
    * `update_configuration(new_config)`: Aktualisiert Konfiguration und löst Neuberechnung aus. [cite: 144]
    * `reload_themes_and_tokens()`: Lädt alle Definitionen neu. [cite: 150]
    * `subscribe_to_theme_changes()`: Gibt einen `mpsc::Receiver<ThemeChangedEvent>` zurück. [cite: 157]
* **Events:** `ThemeChangedEvent { new_state: AppliedThemeState }`. [cite: 103, 166, 167, 168, 177]
* **Fehlerbehandlung:** `ThemingError` Enum (z.B. `TokenFileParseError`, `CyclicTokenReference`, `ThemeNotFound`, `MissingTokenReference`). [cite: 182, 186, 187, 188, 189, 190, 191, 209]
* **Dateistruktur:** `domain/theming/{mod.rs, types.rs, errors.rs, logic.rs, default_themes/}`. [cite: 211, 212, 213]

#### 2.2. Modul: `domain::workspaces`

Verantwortlich für die Logik und Verwaltung von Arbeitsbereichen ("Spaces" oder virtuelle Desktops). [cite: 330] Unterteilt in `core`, `assignment`, `manager`, und `config`. [cite: 333]

* **`workspaces::core`**: Fundamentale Workspace-Definition. [cite: 337]
    * **Datenstrukturen:**
        * `WorkspaceId` (Typalias für `uuid::Uuid`). [cite: 344, 365]
        * `WindowIdentifier` (Newtype für `String`, repräsentiert Fenster-IDs). [cite: 344, 350, 353, 354]
        * `WorkspaceLayoutType` (Enum: Floating, TilingHorizontal, TilingVertical, Maximized; Default: Floating). [cite: 344, 349, 361, 362]
        * `Workspace` (Struct: id, name, persistent_id, layout_type, window_ids: `HashSet<WindowIdentifier>`, created_at). [cite: 343, 344] Validierungen für `name` (nicht leer, Maximallänge) und `persistent_id`. [cite: 346, 348]
    * **API (`impl Workspace`):** `new()`, `id()`, `name()`, `rename()`, `layout_type()`, `set_layout_type()`, `add_window_id()` (crate-intern), `remove_window_id()` (crate-intern), `window_ids()`, `persistent_id()`, `set_persistent_id()`, `created_at()`. [cite: 367]
    * **Event-Payloads (Definiert in `core::event_data`):** `WorkspaceRenamedData`, `WorkspaceLayoutChangedData`, `WindowAddedToWorkspaceData`, `WindowRemovedFromWorkspaceData`, `WorkspacePersistentIdChangedData`. [cite: 375, 376, 377]
    * **Fehlerbehandlung:** `WorkspaceCoreError` (z.B. `InvalidName`, `NameCannotBeEmpty`, `NameTooLong`, `InvalidPersistentId`). [cite: 378, 380, 382, 383, 399]
* **`workspaces::assignment`**: Logik zur Fensterzuweisung. [cite: 334, 422]
    * **API (Freistehende Funktionen):**
        * `assign_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, target_workspace_id, window_id, ensure_unique_assignment: bool)` [cite: 438, 439]
        * `remove_window_from_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id, window_id)` [cite: 439]
        * `move_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id, target_workspace_id, window_id)` [cite: 439]
        * `find_workspace_for_window(workspaces: &HashMap<WorkspaceId, Workspace>, window_id) -> Option<WorkspaceId>` [cite: 439]
    * **Fehlerbehandlung:** `WindowAssignmentError` (z.B. `WorkspaceNotFound`, `WindowAlreadyAssigned`, `WindowNotOnSourceWorkspace`, `CannotMoveToSameWorkspace`, `RuleViolation`). [cite: 446, 447, 448, 449, 457]
* **`workspaces::manager`**: Orchestrierung und übergeordnete Verwaltung. [cite: 335, 479]
    * **Zustand (`WorkspaceManager` Struct):** `workspaces: HashMap<WorkspaceId, Workspace>`, `active_workspace_id: Option<WorkspaceId>`, `ordered_workspace_ids: Vec<WorkspaceId>`, `next_workspace_number`, `config_provider: Arc<dyn WorkspaceConfigProvider>`, `event_publisher: Arc<dyn EventPublisher<WorkspaceEvent>>`, `ensure_unique_window_assignment: bool`. [cite: 497, 500]
    * **API (`impl WorkspaceManager`):** `new()`, `create_workspace()`, `delete_workspace()`, `get_workspace()`, `get_workspace_mut()`, `all_workspaces_ordered()`, `active_workspace_id()`, `set_active_workspace()`, `assign_window_to_active_workspace()`, `assign_window_to_specific_workspace()`, `remove_window_from_its_workspace()`, `move_window_to_specific_workspace()`, `rename_workspace()`, `set_workspace_layout()`, `save_configuration()`. [cite: 502]
    * **Events (`WorkspaceEvent` Enum):** `WorkspaceCreated`, `WorkspaceDeleted`, `ActiveWorkspaceChanged`, `WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WindowAddedToWorkspace`, `WindowRemovedFromWorkspace`, `WorkspaceOrderChanged`, `WorkspacesReloaded`, `WorkspacePersistentIdChanged`. [cite: 504, 505, 506, 507, 508, 512]
    * **Fehlerbehandlung:** `WorkspaceManagerError` (z.B. `WorkspaceNotFound`, `CannotDeleteLastWorkspace`, `NoActiveWorkspace`, Wraps: `WorkspaceCoreError`, `WindowAssignmentError`, `WorkspaceConfigError`). [cite: 513, 514, 515, 516, 522]
* **`workspaces::config`**: Konfigurations- und Persistenzlogik. [cite: 335, 557]
    * **Datenstrukturen (Snapshots für Persistenz):**
        * `WorkspaceSnapshot` (Struct: persistent_id, name, layout_type). [cite: 564, 565, 566, 568, 569]
        * `WorkspaceSetSnapshot` (Struct: workspaces: `Vec<WorkspaceSnapshot>`, active_workspace_persistent_id). [cite: 570, 571, 572]
    * **Schnittstelle (`WorkspaceConfigProvider` Trait):**
        * `load_workspace_config() -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>` [cite: 573, 575, 581]
        * `save_workspace_config(config_snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>` [cite: 576, 581]
    * **Beispielimplementierung:** `FilesystemConfigProvider` (nutzt `core::config::ConfigService`). [cite: 577, 578]
    * **Fehlerbehandlung:** `WorkspaceConfigError` (z.B. `LoadError`, `SaveError`, `InvalidData`, `SerializationError`, `DeserializationError`, `PersistentIdNotFound`, `DuplicatePersistentId`). [cite: 587, 588, 589, 590, 591, 592, 602]

#### 2.3. Modul: `domain::user_centric_services`

Bündelt Logik für KI-Interaktionen (inkl. Einwilligungsmanagement) und ein umfassendes Benachrichtigungssystem. [cite: 697, 698, 700]

* **KI-Interaktionsmanagement:**
    * **Datenstrukturen:**
        * `AIInteractionContext` (Struct: id: Uuid, creation_timestamp, active_model_id, consent_status: `AIConsentStatus`, associated_data_categories: `Vec<AIDataCategory>`, interaction_history, attachments: `Vec<AttachmentData>`). [cite: 712, 713, 714, 715, 716, 717, 751]
        * `AIConsent` (Struct: id: Uuid, user_id, model_id, data_categories: `Vec<AIDataCategory>`, granted_timestamp, expiry_timestamp, is_revoked). [cite: 720, 721, 722, 723, 724, 725, 751]
        * `AIModelProfile` (Struct: model_id, display_name, description, provider, required_consent_categories: `Vec<AIDataCategory>`, capabilities). [cite: 727, 728, 729, 730, 751]
        * `AttachmentData` (Struct: id: Uuid, mime_type, source_uri, content, description). [cite: 717, 742, 743, 744, 745, 751]
        * `AIConsentStatus` (Enum: Granted, Denied, PendingUserAction, NotRequired). [cite: 714, 745]
        * `AIDataCategory` (Enum: UserProfile, ApplicationUsage, FileSystemRead, ClipboardAccess, LocationData, GenericText, GenericImage). [cite: 701, 715, 723, 729, 745, 746]
    * **API (`AIInteractionLogicService` Trait):** `initiate_interaction()`, `get_interaction_context()`, `provide_consent()`, `get_consent_for_model()`, `add_attachment_to_context()`, `list_available_models()`, `store_consent()`, `get_all_user_consents()`, `load_model_profiles()`. [cite: 748, 755, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769]
    * **Events:** `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`. [cite: 786, 803, 805, 818]
    * **Fehlerbehandlung:** `AIInteractionError` (z.B. `ContextNotFound`, `ConsentRequired`, `ModelNotFound`, `ConsentStorageError`, `ModelProfileLoadError`). [cite: 822, 823, 824, 825, 839]
* **Benachrichtigungsmanagement:**
    * **Datenstrukturen:**
        * `Notification` (Struct: id: Uuid, application_name, application_icon, summary, body, actions: `Vec<NotificationAction>`, urgency: `NotificationUrgency`, timestamp, is_read, is_dismissed, transient). [cite: 703, 732, 733, 734, 735, 736, 737, 738, 751]
        * `NotificationAction` (Struct: key, label, action_type: `NotificationActionType`). [cite: 704, 735, 740, 741, 751]
        * `NotificationUrgency` (Enum: Low, Normal, Critical). [cite: 704, 735, 745, 746]
        * `NotificationActionType` (Enum: Callback, OpenLink). [cite: 742, 745, 746]
        * `NotificationFilterCriteria` (Enum: Unread, Application(String), Urgency(NotificationUrgency)). [cite: 747, 776]
        * `NotificationSortOrder` (Enum: TimestampAscending, TimestampDescending, Urgency). [cite: 747, 776]
    * **API (`NotificationService` Trait):** `post_notification()`, `get_notification()`, `mark_as_read()`, `dismiss_notification()`, `get_active_notifications()`, `get_notification_history()`, `clear_history()`, `set_do_not_disturb()`, `is_do_not_disturb_enabled()`, `invoke_action()`. [cite: 749, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782]
    * **Events:** `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent`. [cite: 808, 809, 810, 811, 812, 813, 814, 815, 816, 818]
    * **Fehlerbehandlung:** `NotificationError` (z.B. `NotFound`, `InvalidData`, `HistoryFull`, `ActionNotFound`). [cite: 822, 826, 827, 839]
* **Dateistruktur:** `domain/user_centric_services/{mod.rs, ai_interaction_service.rs, notification_service.rs, types.rs, errors.rs}`. [cite: 842]

#### 2.4. Modul: `domain::global_settings_and_state_management` (auch `domain::settings_core` + `domain::settings_persistence_iface`)

Verantwortlich für die Repräsentation, Verwaltung und Konsistenz globaler Desktop-Einstellungen. [cite: 895, 896, 897, 1099, 1100]

* **`domain::settings_core`**: Kernlogik der Einstellungsverwaltung. [cite: 1099]
    * **Datenstrukturen:**
        * `SettingKey` (Newtype für `String`, für Einstellungsschlüssel wie "appearance.theme.name"). [cite: 1101, 1108, 1109, 1110]
        * `SettingValue` (Enum: Boolean, Integer, Float, String, Color, FilePath, List, Map). [cite: 1101, 1111, 1112, 1113]
        * `SettingMetadata` (Struct: description, default_value, value_type_hint, possible_values, validation_regex, min_value, max_value, is_sensitive, requires_restart). [cite: 1101, 1115, 1119]
        * `Setting` (Struct: id: Uuid, key, current_value, metadata, last_modified, is_dirty). [cite: 1101, 1120, 1121, 1122]
        * `GlobalDesktopSettings` (Hauptstruktur, die alle globalen Einstellungen kategorisiert, z.B. `AppearanceSettings`, `WorkspaceSettings`, `InputBehaviorSettings`, `PowerManagementPolicySettings`, `DefaultApplicationsSettings`). [cite: 899, 911, 913] Jede Unterstruktur enthält spezifische Einstellungsfelder.
        * `SettingPath` (Enum-Hierarchie zur typsicheren Adressierung von Einstellungen, z.B. `SettingPath::Appearance(AppearanceSettingPath::FontSettings(FontSettingPath::DefaultFontSize))`). [cite: 923, 924, 925]
    * **API (`SettingsCoreManager` oder `GlobalSettingsService` Trait):**
        * `new(provider, initial_metadata, event_channel_capacity)` / `load_settings()` [cite: 1137, 1141, 937, 938, 939]
        * `save_settings()` [cite: 940]
        * `get_current_settings()` / `get_setting_value(key)` / `get_setting(path)` [cite: 941, 945, 946, 1141]
        * `set_setting_value(key, value)` / `update_setting(path, value: JsonValue)` [cite: 942, 943, 944, 1141]
        * `reset_setting_to_default(key)` / `reset_to_defaults()` [cite: 947, 1141]
        * `register_setting_metadata(key, metadata)` [cite: 1141]
        * `get_all_settings_with_metadata()` [cite: 1141]
        * `subscribe_to_changes()` / `subscribe_to_setting_changes()` [cite: 948, 949, 950, 951, 1141]
    * **Events:** `SettingChangedEvent { key/path, new_value }`[cite: 1104, 1136, 1142, 1147, 986], `SettingsLoadedEvent { settings }`[cite: 972, 993], `SettingsSavedEvent`[cite: 997].
    * **Fehlerbehandlung:** `SettingsCoreError` / `GlobalSettingsError` (z.B. `SettingNotFound`, `ValidationError`, `PersistenceError`, `PathNotFound`, `InvalidValueType`). [cite: 1126, 1149, 1150, 1151, 1152, 1155, 1005, 1010, 1011, 1012, 1013, 1014, 1027]
* **`domain::settings_persistence_iface`**: Persistenzabstraktion. [cite: 1097, 1184]
    * **Schnittstelle (`SettingsProvider` Trait):**
        * `load_setting(key) -> Result<Option<SettingValue>, SettingsPersistenceError>` [cite: 1192, 1196]
        * `save_setting(key, value) -> Result<(), SettingsPersistenceError>` [cite: 1193, 1196]
        * `load_all_settings() -> Result<Vec<(SettingKey, SettingValue)>, SettingsPersistenceError>` [cite: 1193, 1196]
        * `delete_setting(key) -> Result<(), SettingsPersistenceError>` [cite: 1194, 1196]
        * `setting_exists(key) -> Result<bool, SettingsPersistenceError>` [cite: 1194, 1196]
    * **Fehlerbehandlung:** `SettingsPersistenceError` (z.B. `BackendUnavailable`, `StorageAccessError`, `SerializationError`, `DeserializationError`, `IoError`). [cite: 1186, 1201, 1202, 1203, 1206]
* **Dateistruktur (Global Settings):** `domain/global_settings_management/{mod.rs, service.rs, types.rs, paths.rs, errors.rs}`. [cite: 1029, 1030]
* **Dateistruktur (Settings Core & Persistence Interface):** `domain/src/settings_core/{mod.rs, types.rs, error.rs}`, `domain/src/settings_persistence_iface/{mod.rs, error.rs}`. [cite: 1106, 1184, 1190, 1201]

#### 2.5. Modul: `domain::notifications_rules`

Implementiert die Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln. [cite: 1097, 1288]

* **Verantwortlichkeit:** Definition von Benachrichtigungsregeln (`NotificationRule`), deren Bedingungen (`RuleCondition`) und Aktionen (`RuleAction`); Bereitstellung einer Engine (`NotificationRulesEngine`) zur Regelauswertung und -anwendung. [cite: 1288, 1289]
* **Datenstrukturen:**
    * `RuleCondition` (Enum: AppNameIs, AppNameMatches (Regex), SummaryContains, UrgencyIs, CategoryIs, HintExists, HintValueIs, SettingIsTrue, LogicalAnd, LogicalOr, LogicalNot etc.). [cite: 1288, 1300, 1301, 1302]
    * `RuleAction` (Enum: SuppressNotification, SetUrgency, AddAction, SetHint, PlaySound, MarkAsPersistent, SetExpiration, LogMessage etc.). [cite: 1288, 1303, 1304, 1305]
    * `NotificationRule` (Struct: id, description, conditions: `RuleCondition`, actions: `Vec<RuleAction>`, is_enabled, priority, stop_after). [cite: 1288, 1306, 1307, 1308]
* **Kernlogik (`NotificationRulesEngine` Service):**
    * Lädt und verwaltet Regeldefinitionen (sortiert nach Priorität). [cite: 1292, 1313, 1314]
    * `process_notification(notification)`: Wertet Regeln gegen eine eingehende Benachrichtigung aus. [cite: 1320]
        * Gibt `RuleProcessingResult` zurück: `Allow(modified_notification)` oder `Suppress(rule_id)`. [cite: 1312]
    * `evaluate_condition(condition, notification, rule)`: Rekursive Auswertung von Regelbedingungen. [cite: 1322, 1330] Interagiert mit `SettingsCoreManager` für `Setting*`-Bedingungen. [cite: 1333]
    * `apply_action(action, notification, rule)`: Anwendung von Regelaktionen auf eine Benachrichtigung. [cite: 1324, 1344]
    * Reagiert auf `SettingChangedEvent` (optional, zur Cache-Invalidierung oder Neubewertung). [cite: 1291, 1315, 1316, 1317, 1362, 1363, 1364]
* **Öffentliche API (`NotificationRulesEngine`):**
    * `new(settings_manager, initial_rules, settings_event_receiver)` [cite: 1312, 1313, 1369]
    * `load_rules(new_rules)` [cite: 1318, 1319, 1369]
    * `process_notification(notification) -> Result<RuleProcessingResult, NotificationRulesError>` [cite: 1320, 1369]
    * `handle_setting_changed(event)` (intern aufgerufen). [cite: 1362, 1369]
* **Fehlerbehandlung:** `NotificationRulesError` (z.B. `InvalidRuleDefinition`, `ConditionEvaluationError`, `ActionApplicationError`, `SettingsAccessError`). [cite: 1371, 1372, 1373, 1374, 1375]
* **Dateistruktur:** `domain/src/notifications_rules/{mod.rs, types.rs, error.rs}`.

### 3. Interaktionen und Abhängigkeiten

* **Domänenmodule untereinander:**
    * `NotificationCoreManager` nutzt `NotificationRulesEngine` zur Verarbeitung von Benachrichtigungen. [cite: 1250, 1252]
    * `NotificationRulesEngine` nutzt `SettingsCoreManager` (oder `GlobalSettingsService`), um regelbedingte Einstellungen abzufragen. [cite: 1291, 1310, 1312]
    * `ThemingEngine` reagiert auf `SettingChangedEvent` von `SettingsCoreManager` für themenrelevante Einstellungen. [cite: 990, 1068]
    * Services aus `domain::user_centric_services` und `domain::workspaces` können globale Einstellungen von `GlobalSettingsService` lesen. [cite: 881, 883, 1069, 1070]
* **Abhängigkeiten zur Kernschicht (`core::*`):**
    * `core::config`: Wird von `domain::settings_persistence_iface`-Implementierungen und `domain::workspaces::config` für das Lesen/Schreiben von Konfigurationsdateien genutzt. [cite: 561, 638, 871, 1056]
    * `core::errors`: Basisfehlertypen können in Domänenfehler gewrappt werden. [cite: 380, 639, 870, 1018, 1058]
    * `core::types`: Fundamentale Typen wie `Uuid`, `DateTime<Utc>`. [cite: 640, 869]
    * `core::logging` (`tracing`): Wird für Logging verwendet. [cite: 641, 873, 1059]
* **Schnittstellen zu höheren Schichten (System- und UI-Schicht):**
    * Die Domänenschicht stellt ihre Funktionalität über öffentliche APIs (oft Traits) ihrer Service-Komponenten bereit. [cite: 4, 332, 708, 874, 1105]
    * Die UI-Schicht (z.B. `ui::control_center`[cite: 905, 989, 1060], `ui::shell` [cite: 655]) konsumiert diese APIs und reagiert auf Events aus der Domänenschicht.
    * Die Systemschicht (z.B. MCP-Client[cite: 707, 875], D-Bus Handler[cite: 707, 876], Compositor [cite: 510, 650, 991]) interagiert ebenfalls mit den Domänendiensten und leitet Systemereignisse an diese weiter oder setzt deren Anweisungen um.

### 4. Zusammenfassende Betrachtungen

Die Domänenschicht ist als eine Sammlung modularer, voneinander entkoppelter Komponenten konzipiert, die jeweils klar definierte Verantwortlichkeiten besitzen. Durch die konsequente Anwendung von Prinzipien wie Typsicherheit, expliziter Fehlerbehandlung, Event-basierter Kommunikation und der Abstraktion von Persistenz- und UI-Belangen wird eine robuste, wartbare und erweiterbare Grundlage für die Desktop-Umgebung geschaffen. [cite: 1084, 1085, 1088, 1090, 1091, 1093, 1408] Die detaillierten Spezifikationen der einzelnen Module, ihrer Datenstrukturen, APIs und Fehlerfälle dienen als direkter Leitfaden für die Implementierung.
## 3. Systemschicht
**Technische Gesamtspezifikation und Entwicklungsrichtlinien (Systemschicht-Fokus)**

**I. Einleitung**

Dieses Dokument ist die umfassende technische Spezifikation und Richtliniensammlung für die Entwicklung einer neuartigen Linux-Desktop-Umgebung. Ziel ist eine moderne, schnelle, intuitive und KI-gestützte Benutzererfahrung, optimiert für Entwickler, Kreative und alltägliche Nutzer. Diese Spezifikation legt die technische Grundlage und klare Entwicklungsrichtlinien fest, definiert die Architektur, den Technologie-Stack, Kernkomponenten und Entwicklungsprinzipien. Sie dient als Basis für detaillierte Implementierungsleitfäden der Architekturschichten und ermöglicht Entwicklern die direkte Implementierung ohne grundlegende Technologie- oder Architekturentscheidungen. Die Desktop-Umgebung basiert auf einer geschichteten Architektur für Modularität, Wartbarkeit und Testbarkeit.

**II. Architektonischer Überblick (Schichtenarchitektur)**

Das System ist in vier logische Schichten unterteilt, jede mit spezifischen Verantwortlichkeiten und definierten Schnittstellen, was Kohäsion fördert und Kopplung reduziert.

* **Kernschicht (Core Layer):**
    * **Verantwortlichkeiten:** Grundlegendste Datentypen, Dienstprogramme, Konfigurationsgrundlagen, Logging-Infrastruktur, allgemeine Fehlerdefinitionen. Keine Abhängigkeiten zu anderen Schichten.
    * **Interaktionen:** Stellt Funktionalität für alle darüberliegenden Schichten bereit.
* **Domänenschicht (Domain Layer):**
    * **Verantwortlichkeiten:** Kernlogik und Geschäftsregeln: Workspace-Verwaltung ("Spaces"), Theming-System, Logik für KI-Interaktionen (inkl. Einwilligungsmanagement), Benachrichtigungsverwaltung, Richtlinien für Fenstermanagement (z.B. Tiling-Regeln). Unabhängig von UI-Implementierungen oder Systemdetails (D-Bus, Wayland).
    * **Interaktionen:** Nutzt Kernschicht. Stellt Logik und Zustand für System- und Benutzeroberflächenschicht bereit.
* **Systemschicht (System Layer):**
    * **Verantwortlichkeiten:** Interaktion mit Betriebssystem und externen Diensten: Wayland-Compositor, Eingabeverarbeitung (libinput), D-Bus-Kommunikation (Netzwerk, Energie, Audio, Secrets, PolicyKit), Implementierung von Wayland-Protokollen (inkl. `xdg-shell`, `wlr-layer-shell-unstable-v1`, `xdg-decoration-unstable-v1`, `wlr-foreign-toplevel-management-unstable-v1`, `wlr-output-management-unstable-v1`, `wlr-output-power-management-unstable-v1`), XWayland-Integration, MCP-Client-Implementierung, Interaktion mit XDG Desktop Portals. Implementiert die "Mechanik" des Fenstermanagements (Positionierung, Tiling-Anwendung, Fokus, Sichtbarkeit, Fensterdekorationen) und des Workspace-Managements (Erstellung, Zuweisung von Fenstern, Wechsel). Stellt die technische Basis für die "Intelligente Tab-Leiste" bereit, indem sie Anwendungsfenster und deren Metadaten verwaltet und Gruppierungslogik für "Spaces" ermöglicht. Handhabt Bildschirmfreigabe über XDG Desktop Portals. Verwaltet Monitorkonfigurationen (Auflösung, Skalierung, Anordnung) und DPMS. Stellt Schnittstellen für Audio-Management (PipeWire) und die Verwaltung von Anwendungs-Streams bereit.
    * **Interaktionen:** Nutzt Kern- und Domänenschicht (Anwendung von Regeln, Zustandsabfragen). Stellt systemnahe Dienste und Ereignisse für Benutzeroberflächenschicht bereit. Empfängt Befehle von der UI-Schicht (z.B. Fenster verschieben, Space wechseln) und setzt diese um. Sendet Systemereignisse (z.B. neues Fenster, Fokusänderung, Output-Änderung) an die UI-Schicht.
* **Benutzeroberflächenschicht (User Interface Layer):**
    * **Verantwortlichkeiten:** Darstellung der Benutzeroberfläche und Benutzerinteraktion: Shell-UI (Panels, Dock, "Intelligente Tab-Leiste" pro Space, Workspace-Switcher, Quick-Settings), Control Center, Widget-System (adaptive Seitenleisten), Übersichtsmodus, kontextuelle Befehlspalette, Speed-Dial. Nutzt GTK4.
    * **Interaktionen:** Nutzt alle darunterliegenden Schichten, insbesondere Systemschicht (Fensterverwaltung, Eingabeempfang, Systemdienstansprache) und Domänenschicht (Zustandsdarstellung, Geschäftslogikauslösung). Sendet Benutzerbefehle an die Systemschicht und reagiert auf deren Ereignisse.

Diese Schichtung minimiert Auswirkungen von Änderungen in einer Schicht auf andere, besonders auf Kern- und Domänenschicht.

**III. Technologie-Stack (Systemschicht-Fokus)**

Die Auswahl basiert auf Modernität, Leistung, Sicherheit, Wartbarkeit und Verfügbarkeit im Linux-Ökosystem.

| Bereich                      | Technologie/Standard                                                                                                   | Begründung                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| :--------------------------- | :--------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Programmiersprache           | Rust                                                                                                                   | Leistung, Speichersicherheit ohne GC, starkes Typsystem, Ownership-Modell, moderne Nebenläufigkeitskonzepte. Zukunftsicher für Systemsoftware.                                                                                                                                                                                                                                                                                                                              |
| Build-System                 | Meson                                                                                                                  | Modern, einfach, schnell, gute Rust/C++ Integration, Abhängigkeitsmanagement über WrapDB/Subprojekte.                                                                                                                                                                                                                                                                                                                                                               |
| GUI-Toolkit                  | GTK4                                                                                                                   | Modern, aktiv entwickelt, erstklassige Wayland-Unterstützung, Rust-Bindings (gtk4-rs), CSS-Theming, dynamischer Theme-Wechsel zur Laufzeit.                                                                                                                                                                                                                                                                                                                           |
| **Wayland Compositor & Bib.** | **Smithay Toolkit** | In Rust geschrieben, modular, selektive Nutzung von Komponenten, Unterstützung für Wayland-Protokolle, XWayland-Integration, Abstraktionen für Backends (DRM, libinput). Native Rust-Implementierung vereinfacht Integration.                                                                                                                                                                                                                                  |
| **Essentielle Wayland-Prot.** | `wayland.xml`, `xdg-shell`, `wlr-layer-shell-unstable-v1`, `xdg-decoration-unstable-v1`, `wlr-foreign-toplevel-management-unstable-v1`, `wlr-output-management-unstable-v1`, `wlr-output-power-management-unstable-v1`, `input-method-unstable-v1`, `text-input-unstable-v3`, `presentation-time`, `viewporter`, `linux-dmabuf-unstable-v1`, `idle-notify-unstable-v1`. | Basisprotokoll. Standard für Desktop-Fenster. Für Panels, Docks, Benachrichtigungen. Fensterdekorationen. Auflisten/Steuern von Fenstern. Monitorkonfiguration. Energiesparmodus von Monitoren. Eingabemethoden. Zwischenablage/DND (Wayland Core, ggf. `wlr-data-control-unstable-v1`). Screencasting/Screenshots (XDG Portals oder `wlr-screencopy-unstable-v1`). X11-Kompatibilität (XWayland). |
| **Inter-Prozess-Komm. (IPC)** | **D-Bus** | De-facto-Standard im Linux-Desktop. Integration mit Systemdiensten (NetworkManager, UPower, logind, PolicyKit, org.freedesktop.Notifications, org.freedesktop.secrets). Etablierte Rust-Bibliotheken (z.B. zbus).                                                                                                                                                                                                                                |
| **KI-Integration** | **Model Context Protocol (MCP)** | Offener Standard für sichere, standardisierte LLM-Anbindung. Client-Server-Architektur, definierte Nachrichtenformate. Ermöglicht lokale/Cloud-Modelle, Benutzerkontrolle über Datenzugriff.                                                                                                                                                                                                                                                                     |
| **Eingabeverarbeitung** | **libinput** (via Smithay)                                                                                             | Standardbibliothek für Eingabeereignisse (Tastatur, Maus, Touchpad). Integration in Wayland-Compositors. Robuste Gestenunterstützung (Pinch, Swipe). Konsistente, präzise Eingabebehandlung.                                                                                                                                                                                                                                                                           |
| **Audio-Management** | **PipeWire** | Moderner Standard für Audio/Video. Geringe Latenz, flexibles Routing, sandboxed. Kompatibilitätsschichten für PulseAudio/JACK/ALSA. Rust-Bibliotheken (pipewire-rs). Steuerung von Lautstärke, Geräteauswahl, Anwendungs-Streams.                                                                                                                                                                                                                                |
| **Geheimnisverwaltung** | **Freedesktop Secret Service API** | Standard zum sicheren Speichern sensibler Daten (Passwörter, API-Schlüssel). Implementierungen (GNOME Keyring, KWallet) via D-Bus. Schützt Daten vor Klartextspeicherung. Rust-Bibliotheken (secret-service-rs).                                                                                                                                                                                                                                                  |
| **Rechteverwaltung** | **PolicyKit (polkit)** | Standard für privilegierte Aktionen (Systemupdates, Energieeinstellungen). Interaktion über D-Bus. Stellt sicher, dass administrative Aufgaben nur mit Benutzerzustimmung erfolgen.                                                                                                                                                                                                                                                                                           |
| Theming-Implementierung      | Token-basiert via GTK4 CSS Custom Properties (`var()`) und `@define-color`.                                            | Abstraktion über konkreten Werten. Designentscheidungen als benannte Tokens. Laufzeitänderungen für dynamische Theme-Umschaltung ohne Neustart. Organisation in Schichten (Foundation -> Alias -> Component). Generierte CSS-Dateien via `GtkCssProvider`.                                                                                                                                                                                                    |
| **Sandboxing-Interaktion** | **XDG Desktop Portals** | Standardisierte D-Bus-Schnittstellen für sandboxed Anwendungen für sicheren Ressourcenzugriff (Dateidialoge, Kamera, Mikrofon, Screencasting). Empfohlener Weg unter Wayland. Rust-Bibliotheken (xdg-portal). Backend-Implementierungen ggf. durch Desktop-Umgebung.                                                                                                                                                                                      |

**IV. Entwicklungsrichtlinien (Auszug)**

* **Coding Style & Formatierung:** Standard `rustfmt` Konfiguration, Rust API Guidelines. CI-Prüfung.
* **API-Design:** Befolgung Rust API Guidelines Checklist (Traits, Fehler, Generics, Newtypes, Builder).
* **Fehlerbehandlung:** `thiserror` Crate für spezifische Fehler-Enums pro Modul. Panics vermeiden.
* **Logging & Tracing:** `tracing` Crate-Framework für strukturiertes, kontextbezogenes Logging mit Spans.
* **Versionskontrolle & Branching:** Git mit GitHub Flow. `main`-Branch stabil. Feature-Branches, PRs obligatorisch.
* **Teststrategie:** Umfassende Unit-Tests (Kern-, Domänenschicht). Integrationstests (Modulzusammenspiel, externe Schnittstellen). Compositor-Tests (Evaluierung von Headless Backends, Test-Clients). UI-Tests (Strategie TBD, Fokus auf untere Schichten). CI-Pipeline für alle Tests.
* **Dokumentation:** Umfassende `rustdoc`-Kommentare für öffentliche APIs. Architektur-Dokus. READMEs. Cargo.toml Metadaten.

**V. Initiale Schichtspezifikationen (Systemschicht-Komponenten – Detailliert)**

* **`system::compositor`**: Smithay-basierter Wayland-Compositor.
    * **`core`**: `DesktopState` (zentraler Zustand, implementiert Smithay Handler wie `CompositorHandler`, `XdgShellHandler`), `SurfaceData` (pro `WlSurface`, speichert Puffer, Rolle, Schaden, Geometrie, Hooks), Globalerstellung (`wl_compositor`, `wl_subcompositor`).
        * *Schnittstellen*: Nimmt Konfigurationsdaten (Fensterrollen, Tiling-Regeln) von der Domänenschicht entgegen. Stellt `WlSurface`-Informationen und Fensterstruktur für UI-Schicht bereit.
    * **`shm`**: `ShmState`, `ShmHandler` für `wl_shm` Puffer.
    * **`xdg_shell`**: `XdgShellState`, `XdgShellHandler`-Implementierungen für `DesktopState`. Verwaltung von `ManagedToplevel` (Titel, AppID, Zustand, Geometrie, Dekorationen) und `ManagedPopup`. Sendet `configure`-Events.
        * *Schnittstellen*: Interagiert mit `domain::window_management` für Platzierungsrichtlinien. Meldet Fensterzustände (Titel, AppID, Geometrie) an `ui::shell` und `ui::window_manager_frontend`.
    * **`display_loop`**: Integration der Wayland-Anzeige (`DisplayHandle`) in `calloop`-Ereignisschleife. `ClientData` für Wayland-Clients.
    * **`renderer_interface`**: Abstrakte Traits `FrameRenderer` und `RenderableTexture` zur Entkopplung von Rendering-Backends. `RenderElement` Enum (Surface, SolidColor, Cursor).
* **`system::input`**: Libinput-basierte Eingabeverarbeitung.
    * **`seat_manager`**: `SeatState`, `SeatHandler` (Fokusmanagement `KeyboardFocus`, `PointerFocus`, `TouchFocus`; `cursor_image`-Logik). `XkbKeyboardData` (Keymap, xkbcommon State, Tastenwiederholung).
        * *Schnittstellen*: Sendet Fokusänderungs-Events und Cursor-Informationen an `ui::shell`. Empfängt Befehle zur Fokusänderung von der UI.
    * **`libinput_handler`**: `LibinputInputBackend`-Initialisierung. `process_input_event` leitet libinput-Events (Keyboard, Pointer, Touch, Gesture) an Übersetzer weiter.
    * **`keyboard`**: `key_event_translator` (Keycode zu Keysym/UTF-8, Modifikatoren, Tastenwiederholung). `focus_handler_keyboard` (sendet `enter`/`leave` an Clients).
    * **`pointer`**: `pointer_event_translator` (Motion, Button, Axis). `focus_handler_pointer` (Enter/Leave, Fokus-Logik basierend auf globaler Cursorposition und Fenstern).
    * **`touch`**: `touch_event_translator` (Down, Up, Motion, Frame, Cancel). `focus_handler_touch`.
* **`system::dbus`**: Schnittstellen zu D-Bus-Diensten via `zbus`.
    * **`connection`**: `DBusConnectionManager` (Session/System-Bus).
    * **`upower_client`**: `UPowerClient`, `UPowerManagerProxy`, `UPowerDeviceProxy`. Typen: `PowerDeviceDetails`, `UPowerProperties`, `PowerDeviceType`, `PowerState`. Signale: `DeviceAdded`, `DeviceRemoved`, `PropertiesChanged`.
        * *Schnittstellen*: Sendet `UPowerEvent` (Batteriestatus, Deckelzustand) an Domänen- und UI-Schicht.
    * **`logind_client`**: `LogindClient`, `LogindManagerProxy`, `LogindSessionProxy`. Typen: `SessionInfo`. Signale: `SessionNew`, `SessionRemoved`, `PrepareForSleep`, `Lock`/`Unlock` auf Session.
        * *Schnittstellen*: Sendet `LogindEvent` (Suspend-Vorbereitung, Sitzungssperre) an Domänen- und UI-Schicht. Kann `LockSession` von UI empfangen.
    * **`networkmanager_client`**: `NetworkManagerClient`, `NetworkManagerProxy`, `NMDeviceProxy`, `NMActiveConnectionProxy`. Typen: `NetworkManagerState`, `NetworkDevice`, `ActiveConnection`. Signale: `StateChanged`, `DeviceAdded/Removed`.
        * *Schnittstellen*: Sendet Netzwerkstatus-Events an Domänen- und UI-Schicht.
    * **`secrets_client`**: `SecretsClient`, `SecretServiceProxy`, `SecretCollectionProxy`, `SecretItemProxy`, `SecretPromptProxy`. Typen: `Secret`, `SecretItemInfo`. Methoden: `StoreSecret`, `RetrieveSecret`, `SearchItems`. Handhabt Prompts.
        * *Schnittstellen*: Speichert/ruft sensible Daten (z.B. MCP API Keys) für `system::mcp` oder Domänenschicht ab. Interagiert mit UI für Prompts.
    * **`policykit_client`**: `PolicyKitClient`, `PolicyKitAuthorityProxy`. Typen: `PolicyKitCheckAuthFlags`, `PolicyKitSubject`, `PolicyKitAuthorizationResult`. Methode: `CheckAuthorization`.
        * *Schnittstellen*: Wird von anderen Systemschicht-Modulen oder der Domänenschicht für Rechteprüfungen genutzt.
* **`system::outputs`**: Verwaltung von Anzeigeausgängen.
    * **`output_device`**: `OutputDevice` (kapselt `smithay::output::Output`, Name, Globals, DPMS-Zustand). `OutputDevicePendingState` für wlr-output-management.
    * **`manager`**: `OutputManager` (Liste von `OutputDevice`), Hotplug-Event-Handling (`DeviceAdded`, `DeviceRemoved`). Erstellt/zerstört Wayland-Globals für Outputs.
        * *Schnittstellen*: Meldet Output-Änderungen an `ui::shell` und `ui::control_center`. Empfängt Konfigurationsbefehle.
    * **`wl_output_handler`**: Integration mit `smithay::wayland::output::OutputHandler`.
    * **`wlr_output_management_handler`**: Serverseitige Implementierung von `wlr-output-management-unstable-v1`. `WlrOutputManagementState`, `OutputConfigurationRequest`. Handhabt `create_configuration`, `apply`, `test`. Serial-Management für Konsistenz.
    * **`wlr_output_power_management_handler`**: Serverseitige Implementierung von `wlr-output-power-management-unstable-v1`. `WlrOutputPowerManagementState`. Handhabt `get_output_power`, `set_mode` (On/Off).
    * **`xdg_output_handler`**: Serverseitige Implementierung von `xdg-output-unstable-v1`. Stellt logische Geometrie bereit.
* **`system::xwayland`**: Logik zur Integration und Verwaltung des XWayland-Servers (via Smithay). Stellt Kompatibilität für X11-Anwendungen sicher.
    * *Schnittstellen*: Macht X11-Fenster für den Compositor und die UI-Schicht sichtbar und handhabbar.
* **`system::audio`**: PipeWire Client-Integration via `pipewire-rs`.
    * **`client`**: `PipeWireClient` (verwaltet Core, MainLoop-Thread, Befehls-/Ereigniskanäle). `PipeWireLoopData` (interner Zustand im Loop-Thread).
    * **`manager`**: Verarbeitet Registry-Events, verwaltet `AudioDevice`- und `StreamInfo`-Objekte. Handhabt Parameteränderungen.
    * **`control`**: Implementiert Lautstärke-/Stummschaltungsbefehle, Standardgeräteauswahl.
    * **`types`**: `AudioDevice` (ID, Name, Typ, Lautstärke, Mute, Default), `StreamInfo` (ID, Name, App, PID, Lautstärke, Mute), `AudioCommand`, `AudioEvent`.
    * **`spa_pod_utils`**: Hilfsfunktionen für SPA POD-Erstellung (Lautstärke, Mute für Props/Route).
        * *Schnittstellen*: Sendet `AudioEvent` (Geräte-/Stream-Änderungen, Lautstärke, Mute, Standardgerät) an Domänen- und UI-Schicht. Empfängt `AudioCommand` von UI (z.B. Lautstärke ändern).
* **`system::mcp`**: Model Context Protocol Client via `mcp_client_rs`.
    * **`client`**: `McpClient` (verwaltet Serverprozess, Client-Handle, Anfrage-Handling, Benachrichtigungsverteilung). `McpServerConfig`.
    * **`types`**: Wrapper/Re-Exporte von `mcp_client_rs::protocol` Typen (`InitializeParams`, `ListResourcesParams`, `CallToolParams`, `Resource`, `Tool`). `McpNotification`.
        * *Schnittstellen*: Stellt KI-Funktionen (Ressourcenauflistung, Tool-Aufrufe) für Domänen- und UI-Schicht bereit. Empfängt Anfragen von UI (z.B. Befehlspalette).
* **`system::portals`**: Backend-Implementierung für XDG Desktop Portals via `zbus`.
    * **`file_chooser`**: `FileChooserPortal` (implementiert `org.freedesktop.portal.FileChooser`: `OpenFile`, `SaveFile`, `SaveFiles`).
    * **`screenshot`**: `ScreenshotPortal` (implementiert `org.freedesktop.portal.Screenshot`: `Screenshot`, `PickColor`).
    * **`common`**: `DesktopPortal`-Struktur (aggregiert Portal-Implementierungen), `run_portal_service` (startet D-Bus-Dienst). Kommunikationsstrukturen (`UiPortalCommand`, `CompositorScreenshotCommand`).
        * *Schnittstellen*: Interagiert mit `ui::shell`/`ui::components` zur Anzeige von Dialogen. Kommuniziert mit `system::compositor` für Screenshot-/Farbpick-Aktionen. Dient Anfragen von sandboxed und nativen Anwendungen.

**VI. Deployment-Überlegungen**

* **Paketierung:** Zielformate (.deb/.rpm, Flatpak für Teile/SDK). Build-Prozess spezifizieren. Tiefere Systemintegration (Display-Manager, systemd User-Sessions, PAM) als reine Agenteninstallation.
* **Konfiguration:** Standardkonfigurationen, Benutzerüberschreibungen. Strikte Einhaltung XDG Base Directory Specification (`$XDG_CONFIG_HOME`, `$XDG_DATA_HOME`, `$XDG_STATE_HOME`).
* **Updates:** Strategie für Updates (Distro-Paketmanager, Flatpak). Versionierung, Konfigurationsänderungen bei Updates.

**VII. Schlussfolgerung**

Diese technische Gesamtspezifikation mit Systemschicht-Fokus legt das Fundament für die Entwicklung. Sie definiert eine klare Architektur, wählt einen modernen Technologie-Stack (Rust, Wayland, GTK4, Smithay, PipeWire, MCP) und etabliert Entwicklungsrichtlinien. Dies bildet die Basis für detaillierte Implementierungsleitfäden. Ziel ist eine hochwertige, moderne, sichere und anpassungsfähige Desktop-Umgebung.

# Implementierungsplan Domänenschicht: Teil 1 – Kerndomäne, Konfiguration und Basissystemintegration

## I. Einleitung

### A. Zielsetzung des Dokuments

Dieses Dokument legt den detaillierten Implementierungsplan für den ersten Teil der Domänenschicht einer neu zu entwickelnden Softwareanwendung dar. Ziel ist es, eine robuste, wartbare und erweiterbare Grundlage für die Geschäftslogik zu schaffen. Der Fokus liegt auf der Definition der Kernkomponenten der Domäne, dem Aufbau eines soliden Konfigurationsmanagements, der Implementierung einer umfassenden Fehlerbehandlungs- und Logging-Strategie sowie der Integration grundlegender Systemdienste und der Etablierung von API-Designrichtlinien.

### B. Umfang und Abgrenzung

Teil 1 dieses Implementierungsplans umfasst die Entwicklung der fundamentalen Domänenlogik, einschließlich Entitäten, Wertobjekten und Repository-Schnittstellen. Des Weiteren werden das Konfigurationsmanagement, die Fehlerbehandlung und das Logging spezifiziert. Die Integration mit Systemdiensten beschränkt sich auf die Geheimnisverwaltung und die Grundlagen der Interprozesskommunikation (IPC) via D-Bus. Schließlich werden API-Designrichtlinien und projektinterne Konventionen festgelegt. Ausdrücklich nicht Teil dieses ersten Plans sind die Entwicklung der Benutzeroberfläche (UI), die Implementierung spezifischer Anwendungsdienste, die über die reine Domänenlogik hinausgehen, sowie alle Funktionalitäten, die für Teil 2 des Implementierungsplans vorgesehen sind.

### C. Zielgruppe

Dieses Dokument richtet sich primär an Softwareentwickler und -architekten, die an der Konzeption und Implementierung der Domänenschicht beteiligt sind. Es dient als technische Grundlage und Referenz für die Entwicklung.

### D. Methodik

Die Erstellung dieses Plans basiert auf einer sorgfältigen Analyse der funktionalen und nicht-funktionalen Anforderungen an die Domänenschicht. Dies beinhaltet die Auswertung von Best Practices im Bereich Softwarearchitektur und Domänendesign, insbesondere im Kontext der Programmiersprache Rust. Eine Auswahl etablierter Bibliotheken (Crates) und Technologien wurde getroffen, um eine hohe Qualität und Effizienz in der Entwicklung sicherzustellen.

## II. Grundlegende Design-Prinzipien und Architektur

### A. Architekturüberblick

Die Domänenschicht wird das Herzstück der Anwendung bilden und die Geschäftslogik sowie die Domänenobjekte kapseln. Sie wird streng nach den Prinzipien der Clean Architecture (alternativ als Hexagonal Architecture oder Ports & Adapters bekannt) entworfen. Dieses Architekturmuster gewährleistet eine klare Trennung der Belange und macht die Domänenschicht unabhängig von äußeren Schichten wie der Benutzeroberfläche, Datenbankimplementierungen oder externen Frameworks. Die Domänenschicht definiert ihre eigenen Schnittstellen (Ports), über die sie mit anderen Schichten kommuniziert, welche die entsprechenden Adapter implementieren. Diese Entkopplung fördert die Testbarkeit, Wartbarkeit und Flexibilität des Systems, da technologische Entscheidungen in den äußeren Schichten geändert werden können, ohne die Kernlogik der Domäne zu beeinträchtigen.

### B. Sprach- und Werkzeugwahl

Als primäre Programmiersprache für die Implementierung der Domänenschicht wurde Rust gewählt. Rust bietet eine einzigartige Kombination aus Performance, Speichersicherheit ohne Garbage Collector und modernen Sprachfeatures, die es besonders geeignet für systemnahe Programmierung und die Entwicklung komplexer, zuverlässiger Anwendungen machen.1 Die strengen Typsystem- und Ownership-Regeln von Rust helfen, viele gängige Programmierfehler bereits zur Kompilierzeit zu verhindern.3 Das Ökosystem von Rust, insbesondere die Verfügbarkeit hochwertiger Crates, unterstützt die schnelle Entwicklung robuster Software.

Für das Build-System und die Paketverwaltung wird Cargo, das offizielle Werkzeug von Rust, eingesetzt.5 Cargo vereinfacht das Kompilieren von Code, das Verwalten von Abhängigkeiten und das Ausführen von Tests erheblich. Zur Sicherstellung einer einheitlichen Codeformatierung wird `rustfmt` mit den Standardeinstellungen verbindlich eingesetzt. Zusätzlich wird `clippy`, ein Linter für Rust, verwendet, um idiomatischen und fehlerfreien Code zu fördern.6 Diese Werkzeuge tragen maßgeblich zur Codequalität und Lesbarkeit bei und erleichtern die Zusammenarbeit im Entwicklungsteam.

### C. Kernkonzepte der Domänenschicht

Die Domänenschicht wird um mehrere Kernkonzepte herum aufgebaut sein, die typisch für Domain-Driven Design (DDD) sind:

- **Entitäten (Entities):** Objekte, die nicht primär durch ihre Attribute, sondern durch eine eindeutige Identität und einen Lebenszyklus definiert sind. Änderungen an Entitäten werden über die Zeit verfolgt.
- **Wertobjekte (Value Objects):** Objekte, die einen beschreibenden Aspekt der Domäne darstellen und keine konzeptionelle Identität besitzen. Sie werden durch ihre Attribute definiert und sind typischerweise unveränderlich (immutable). Die Gleichheit von Wertobjekten basiert auf dem Vergleich ihrer Attribute.
- **Aggregate:** Eine Gruppe von Entitäten und Wertobjekten, die als eine einzelne Einheit für Datenänderungen behandelt werden. Jedes Aggregat hat eine Wurzelentität (Aggregate Root), die der einzige Einstiegspunkt für Modifikationen innerhalb des Aggregats ist und dessen Konsistenz sicherstellt.
- **Repositories (Schnittstellen):** Definieren Schnittstellen für den Zugriff auf und die Persistenz von Aggregaten. Sie abstrahieren die Details der Datenspeicherung und ermöglichen es der Domänenschicht, agnostisch gegenüber der konkreten Datenbanktechnologie zu bleiben.
- **Domänendienste (Domain Services):** Enthalten Domänenlogik, die nicht natürlich einer einzelnen Entität oder einem Wertobjekt zugeordnet werden kann. Solche Dienste operieren oft auf mehreren Domänenobjekten.
- **Domänenereignisse (Domain Events):** Repräsentieren signifikante Vorkommnisse innerhalb der Domäne, die für andere Teile des Systems von Interesse sein könnten.

Ein zentrales Element wird die Entwicklung einer **Ubiquitous Language** sein – einer gemeinsamen, präzisen Sprache, die von allen Teammitgliedern (Entwicklern und Domänenexperten) verwendet wird, um Konzepte der Domäne unmissverständlich zu beschreiben. Diese Sprache wird sich direkt im Code (Namen von Typen, Methoden, Modulen) widerspiegeln.

## III. Domänenmodell-Spezifikation

### A. Entitäten, Wertobjekte und Aggregate

Die korrekte Modellierung von Entitäten, Wertobjekten und Aggregaten ist von fundamentaler Bedeutung für die Fähigkeit der Anwendung, Geschäftskonzepte präzise abzubilden und zu manipulieren. Fehler in dieser frühen Phase können später zu erheblichem Refactoring-Aufwand führen.

**Entitäten** sind durch eine eindeutige Identität und einen Lebenszyklus gekennzeichnet. Ihre Attribute können sich im Laufe der Zeit ändern, aber ihre Identität bleibt bestehen. Ein Beispiel wäre ein `Benutzer` mit einer eindeutigen Benutzer-ID.

**Wertobjekte** hingegen haben keine eigene Identität über ihre Attribute hinaus. Sie beschreiben Merkmale und sind typischerweise unveränderlich. Ein `Geldbetrag` (bestehend aus Währung und Wert) oder eine `Adresse` (bestehend aus Straße, Stadt, Postleitzahl) sind klassische Beispiele. Würde eine Adresse fälschlicherweise als Entität modelliert, könnte dies zu unnötiger Komplexität bei der Identitätsverwaltung und bei Gleichheitsprüfungen führen, wo eigentlich nur ein struktureller Vergleich notwendig wäre.

**Aggregate** fassen Entitäten und Wertobjekte zu einer Konsistenzeinheit zusammen. Jedes Aggregat hat eine Wurzel (Aggregate Root), die als einziger Einstiegspunkt für Modifikationen dient und die Invarianten des Aggregats sicherstellt. Die Grenzen von Aggregaten müssen sorgfältig gewählt werden, um transaktionale Konsistenz zu gewährleisten und gleichzeitig eine übermäßige Kopplung zu vermeiden. Eine falsch gezogene Aggregatgrenze kann es erschweren, atomare Operationen konsistent durchzuführen oder führt zu unnötig großen Transaktionen.

Die folgende Tabelle fasst die initial identifizierten Kernentitäten zusammen:

**Tabelle 1: Kern-Domänenentitäten**

|   |   |   |   |
|---|---|---|---|
|**Entitätsname**|**Beschreibung**|**Schlüsselattribute**|**Identitätsmechanismus**|
|`BenutzerProfil`|Repräsentiert einen Benutzer des Systems.|`benutzer_id`, `email`|UUID (`benutzer_id`)|
|`Aufgabe`|Stellt eine zu erledigende Aufgabe dar.|`aufgaben_id`, `titel`|UUID (`aufgaben_id`)|
|`Projekt`|Gruppiert zusammengehörige Aufgaben.|`projekt_id`, `name`|UUID (`projekt_id`)|
|`Konfiguration`|Speichert benutzerspezifische Einstellungen.|`konfigurations_id`|UUID (`konfigurations_id`)|

Die Unterscheidung zwischen Entitäten und Wertobjekten ist oft subtil, aber entscheidend. Die nachstehende Tabelle listet wichtige Wertobjekte auf:

**Tabelle 2: Schlüssel-Wertobjekte**

|   |   |   |   |
|---|---|---|---|
|**Wertobjekt-Name**|**Beschreibung**|**Attribute**|**Unveränderlichkeits-Hinweise**|
|`EmailAdresse`|Repräsentiert eine E-Mail-Adresse.|`adresse` (String)|Ja, nach Erstellung fix.|
|`Zeitstempel`|Ein spezifischer Zeitpunkt.|`datum_uhrzeit` (z.B. `DateTime<Utc>`)|Ja, repräsentiert einen Punkt.|
|`Status`|Der Zustand einer Aufgabe oder eines Projekts.|`wert` (Enum: z.B. Offen, InArbeit)|Ja, Änderung erzeugt neuen Status.|
|`Prioritaet`|Die Dringlichkeit einer Aufgabe.|`stufe` (Enum: z.B. Niedrig, Hoch)|Ja.|

### B. Repository-Schnittstellen

Repository-Schnittstellen definieren die Verträge für den Zugriff auf und die Persistenz von Domänenobjekten, insbesondere Aggregaten. Sie werden als Rust-Traits implementiert und enthalten Methoden für typische CRUD-Operationen (Create, Read, Update, Delete) sowie ggf. spezifischere Abfragemethoden.

Ein fundamentaler Aspekt dieser Schnittstellen ist die Abstraktion von der konkreten Persistenztechnologie. Die Domänenschicht soll nicht wissen, ob Daten in einer SQL-Datenbank, einem NoSQL-Speicher oder einfachen Dateien abgelegt werden. Diese Unabhängigkeit wird erreicht, indem die Domänenschicht ausschließlich gegen die Repository-Traits programmiert wird. Die konkreten Implementierungen dieser Traits (z.B. ein `PostgresAufgabenRepository` oder ein `InMemoryBenutzerProfilRepository`) befinden sich außerhalb der Domänenschicht, typischerweise in der Infrastrukturschicht.

Diese Vorgehensweise bietet erhebliche Vorteile:

1. **Testbarkeit:** Für Unit-Tests der Domänenlogik können einfache In-Memory-Implementierungen der Repositories verwendet werden, was schnelle und isolierte Tests ohne externe Abhängigkeiten ermöglicht.
2. **Flexibilität:** Die Wahl der Datenbanktechnologie kann zu einem späteren Zeitpunkt geändert oder für verschiedene Umgebungen (z.B. Entwicklung vs. Produktion) unterschiedlich getroffen werden, ohne dass die Domänenschicht angepasst werden muss. Würde die Domänenschicht direkt Typen und Funktionen spezifischer Datenbank-Crates wie `sqlx` oder `diesel` verwenden, wäre sie fest an diese Technologie gebunden, was zukünftige Änderungen erschwert.

Beispielhafte Repository-Schnittstelle:

Rust

```
use std::error::Error;

// Platzhalter für Domänenfehler und Entität
type DomainError = Box<dyn Error + Send + Sync>;
struct Aufgabe { aufgaben_id: String, /*... */ }
struct Projekt { projekt_id: String, /*... */ }


pub trait AufgabenRepository {
    async fn finde_nach_id(&self, id: &str) -> Result<Option<Aufgabe>, DomainError>;
    async fn speichere(&self, aufgabe: &Aufgabe) -> Result<(), DomainError>;
    async fn loesche(&self, id: &str) -> Result<(), DomainError>;
    async fn finde_fuer_projekt(&self, projekt_id: &str) -> Result<Vec<Aufgabe>, DomainError>;
}

pub trait ProjektRepository {
    async fn finde_nach_id(&self, id: &str) -> Result<Option<Projekt>, DomainError>;
    async fn speichere(&self, projekt: &Projekt) -> Result<(), DomainError>;
}
```

### C. Serialisierung und Deserialisierung

Für die Umwandlung von Domänenobjekten in persistierbare Formate oder für die Übertragung über Prozessgrenzen hinweg (IPC) wird der `serde` Crate eingesetzt.7 `serde` ist der De-facto-Standard für Serialisierung und Deserialisierung im Rust-Ökosystem und bietet durch die Traits `Serialize` und `Deserialize` eine flexible und performante Lösung. Die aktuelle stabile Version (z.B. v1.0.219 gemäß 7) wird verwendet.

Die Wahl des konkreten Datenformats hängt vom Anwendungsfall ab:

- **JSON (JavaScript Object Notation):** Für menschenlesbare Konfigurationsdateien oder einfache IPC-Szenarien, bei denen Interoperabilität und Lesbarkeit im Vordergrund stehen.
- **CBOR (Concise Binary Object Representation) oder Bincode:** Für die effiziente binäre Persistenz großer Datenmengen oder performanzkritische IPC. Diese Formate sind kompakter und schneller zu verarbeiten als JSON, aber nicht direkt menschenlesbar.

Die Entscheidung für ein Format hat direkte Auswirkungen auf die Performance, die Speichergröße und die Debugfähigkeit. Beispielsweise wäre die Verwendung von JSON für große binäre Daten ineffizient, während ein benutzerdefiniertes Binärformat für Konfigurationsdateien deren manuelle Bearbeitung erschweren würde. `serde` stellt den Mechanismus bereit, die Wahl des Formats muss jedoch kontextspezifisch getroffen werden.

Bei der Verwendung von `serde` werden je nach Bedarf Features wie `std`, `derive`, `alloc` und `rc` aktiviert.8 Die `derive`-Makros (`#`) werden intensiv genutzt, um Boilerplate-Code für die Implementierung der Traits zu vermeiden.

## IV. Konfigurationsmanagement

### A. Struktur und Speicherort der Konfigurationsdateien

Die Konfiguration der Anwendung wird in Dateien im TOML-Format (Tom's Obvious, Minimal Language) gespeichert. TOML wurde aufgrund seiner guten Lesbarkeit und seiner Verbreitung im Rust-Ökosystem gewählt.9 Der `toml` Crate (z.B. Version 0.8.22 9) wird für das Parsen dieser Dateien verwendet. Die Konfigurationsdaten selbst werden in Rust-Strukturen abgebildet, die dann mittels `serde` deserialisiert werden.

Für die Ablage der Konfigurationsdateien wird die XDG Base Directory Specification 10 befolgt, um eine konsistente Benutzererfahrung auf Linux-Desktops zu gewährleisten. Der `directories` Crate (z.B. Version 6.0.0 11) wird verwendet, um die standardisierten Pfade systemunabhängig zu ermitteln:

- **Benutzerspezifische Konfiguration:** `$XDG_CONFIG_HOME/your_app_name/config.toml`. Falls `$XDG_CONFIG_HOME` nicht gesetzt ist, wird standardmäßig `$HOME/.config/your_app_name/config.toml` verwendet.
- **Systemweite Konfiguration (falls anwendbar):** `/etc/your_app_name/config.toml`.

Es wird eine klare Präzedenz festgelegt, wobei benutzerspezifische Konfigurationen systemweite Einstellungen überschreiben. Die Einhaltung der XDG-Standards ist von Bedeutung, da Benutzer erwarten, Konfigurationsdateien an vorhersagbaren Orten zu finden. Dies erleichtert die Verwaltung für Endanwender und Systemadministratoren und sorgt dafür, dass sich die Anwendung wie andere gut integrierte Linux-Anwendungen verhält.

Die Konfiguration kann bei Bedarf in logische Abschnitte innerhalb der `config.toml`-Datei unterteilt werden. Für den Anfang wird eine einzelne Konfigurationsdatei als ausreichend erachtet.

### B. Laden und Validieren der Konfiguration

Das Laden der Konfiguration erfolgt beim Anwendungsstart. Der Inhalt der TOML-Datei wird mithilfe des `toml` Crates und `serde` in die dafür vorgesehenen Rust-Strukturen deserialisiert.

Ein entscheidender Schritt ist die Validierung der geladenen Konfigurationswerte. Diese Validierung umfasst beispielsweise Bereichsprüfungen für numerische Werte, Formatprüfungen für Zeichenketten oder die Überprüfung der Existenz referenzierter Ressourcen. Hierfür können entweder benutzerdefinierte Validierungsfunktionen direkt in den Konfigurationsstrukturen oder, bei höherer Komplexität, ein dedizierter Validierungs-Crate implementiert werden.

Das Verhalten bei fehlgeschlagener Validierung wird klar definiert: Die Anwendung soll in einem solchen Fall mit einer aussagekräftigen Fehlermeldung beendet werden ("fail fast"). Dies ist vorzuziehen gegenüber einem Betrieb mit potenziell inkonsistenten oder fehlerhaften Einstellungen, der zu unvorhersehbarem Verhalten und schwer diagnostizierbaren Fehlern führen kann.

Standardwerte für Konfigurationsparameter werden über Implementierungen des `Default`-Traits für die Konfigurationsstrukturen oder durch explizite Fallback-Werte im Code bereitgestellt. `serde`-Attribute wie `#[serde(default)]` können hierbei nützlich sein, um das Verhalten bei fehlenden Feldern in der TOML-Datei zu steuern.

Die Frage der dynamischen Neuladung (Hot-Reloading) von Konfigurationsdateien während der Laufzeit wird als optionale, fortgeschrittene Anforderung betrachtet und ist, falls notwendig, eher Teil von Implementierungsplan Teil 2.

Die folgende Tabelle dient als Referenz für die konfigurierbaren Parameter der Domänenschicht:

**Tabelle 3: Konfigurationsparameter**

|   |   |   |   |   |
|---|---|---|---|---|
|**Parametername (Pfad in TOML)**|**Datentyp**|**Beschreibung**|**Standardwert**|**Validierungsregeln**|
|`logging.level`|String|Globaler Log-Level (z.B. "INFO", "DEBUG")|"INFO"|Muss gültiger Log-Level sein.|
|`database.url`|String|Verbindungs-URL zur Datenbank.|""|Muss valides URL-Format haben.|
|`secrets.collection_name`|String|Name der Secret-Service-Kollektion.|"default"|Darf nicht leer sein.|
|`performance.thread_pool_size`|u32|Größe des Thread-Pools für Hintergrundaufgaben.|4|Muss > 0 und < 1024 sein.|

## V. Fehlerbehandlung und Logging

### A. Fehlerarten und -hierarchie

Eine robuste Fehlerbehandlung ist essentiell für die Stabilität und Wartbarkeit der Domänenschicht. Es werden benutzerdefinierte Fehlertypen für die Domänenschicht definiert, wobei spezifische Fehler-Enums gegenüber generischen Fehler-Strings bevorzugt werden.

Der `thiserror` Crate (z.B. Version 2.0.12 12) wird zur Definition dieser Fehler-Enums verwendet. `thiserror` vereinfacht die Erstellung idiomatischer Fehlertypen erheblich:

- Das Attribut `#[error("...")]` wird genutzt, um menschenlesbare `Display`-Implementierungen für Fehler zu generieren.
- Mittels `#[from]` können zugrundeliegende Fehler (z.B. `std::io::Error`, `serde_json::Error`) automatisch in spezifische Varianten des Domänenfehlers konvertiert werden.
- Das Attribut `#[source]` ermöglicht die Verkettung von Fehlern, um den ursprünglichen Kontext für eine bessere Diagnose zu bewahren.

Bei der Definition der Fehler wird eine ausgewogene Granularität angestrebt.14 Fehler sollten spezifisch genug sein, um vom aufrufenden Code sinnvoll behandelt werden zu können, aber nicht so zahlreich, dass die Fehlerbehandlung unübersichtlich wird. Es ist denkbar, Fehler-Enums auf Modulebene zu definieren, die bei Bedarf in einem übergeordneten Domänenfehler-Enum aggregiert werden.

Ein grundlegendes Prinzip ist, dass die Domänenschicht als Bibliothek bei wiederherstellbaren Fehlern nicht paniken darf.15 Stattdessen wird `Result<T, E>` zurückgegeben. Panics sind ausschließlich für nicht wiederherstellbare Zustände reserviert, die auf einen Programmierfehler hindeuten (z.B. gebrochene Invarianten).

Gemäß den Rust API Guidelines 16 werden alle Fehlertypen die Traits `std::error::Error` und `std::fmt::Debug` implementieren (C-GOOD-ERR, C-DEBUG). Die Verwendung von `thiserror` stellt sicher, dass diese Implementierungen korrekt und mit minimalem Boilerplate-Code generiert werden, was die Ergonomie der Fehlerbehandlung sowohl für Entwickler der Domänenschicht als auch für deren Konsumenten signifikant verbessert.

Die folgende Tabelle listet beispielhaft Domänenfehlertypen auf:

**Tabelle 4: Domänenfehlertypen**

|   |   |   |   |
|---|---|---|---|
|**Fehler-Enum-Variante**|**Assoziierte Daten**|**Beschreibung (Wann tritt er auf)**|**#[source] (falls zutreffend)**|
|`KonfigurationNichtGefunden`|`Pfad: String`|Die Konfigurationsdatei konnte am erwarteten Ort nicht gefunden werden.|`std::io::Error`|
|`KonfigurationUngueltig`|`Fehler: String`|Die Konfigurationsdatei ist fehlerhaft oder enthält ungültige Werte.|`toml::de::Error`|
|`DatenbankFehler`|`Ursache: String`|Ein allgemeiner Fehler bei der Datenbankinteraktion.|Spezifischer DB-Fehler|
|`EntitaetNichtGefunden`|`Id: String, Typ: String`|Eine angeforderte Entität konnte nicht gefunden werden.|-|
|`GeheimnisdienstFehler`|`Meldung: String`|Fehler bei der Interaktion mit dem Secret Service.|`secret_service::Error`|

### B. Logging-Strategie und -Implementierung

Für ein strukturiertes und kontextbezogenes Logging wird das `tracing` Ökosystem eingesetzt, bestehend aus dem `tracing` Crate 17 und dem `tracing-subscriber` Crate.19 `tracing` bietet gegenüber dem einfacheren `log` Crate den Vorteil, reichhaltigere diagnostische Informationen zu liefern, insbesondere in asynchronen Kontexten oder komplexen Arbeitsabläufen.

Es wird zwischen `Events` (zeitpunktbezogene Ereignisse) und `Spans` (zeitraumbezogene Kontexte) unterschieden.17 Spans ermöglichen es, den Ausführungsfluss und die Kausalität von Ereignissen besser nachzuvollziehen. Das Makro `tracing::instrument` wird verwendet, um Funktionen einfach mit Spans zu versehen.

Standard-Log-Level (TRACE, DEBUG, INFO, WARN, ERROR) werden definiert und konsistent verwendet. Das Logging erfolgt strukturiert, d.h., Log-Ereignisse werden mit Schlüssel-Wert-Paaren versehen, um die maschinelle Verarbeitung und Analyse durch Log-Management-Tools zu erleichtern.

Die Konfiguration des Loggings erfolgt über `tracing-subscriber`. Die `fmt`-Schicht dient als gängiger Ausgangspunkt für die Formatierung der Log-Ausgaben (z.B. einfacher Text, JSON) und die Steuerung des Outputs (z.B. stdout, Datei). Der `env-filter` ermöglicht die Steuerung der Log-Level über eine Umgebungsvariable wie `RUST_LOG`.20 Diese flexible Konfiguration erlaubt es, die Ausführlichkeit der Logs ohne Codeänderungen an verschiedene Umgebungen (Entwicklung, Produktion) anzupassen.

Es wird sichergestellt, dass Logs relevante kontextuelle Informationen enthalten, wie z.B. Request-IDs, Benutzer-IDs (falls zutreffend) und Span-IDs, um die Fehlersuche zu unterstützen. Bei der Implementierung des Loggings werden Performance-Aspekte berücksichtigt. Obwohl `tracing` auf Effizienz ausgelegt ist, kann exzessives Logging, insbesondere auf hohen Verbositätsstufen, die Anwendungsleistung beeinträchtigen.

## VI. Integration mit Systemdiensten

### A. Geheimnisverwaltung (Secret Management)

Für die sichere Speicherung sensibler Daten wie API-Schlüssel oder Passwörter wird die Freedesktop Secret Service API genutzt. Die Integration erfolgt über den `secret-service-rs` Crate (z.B. Version 5.0.0 23). Dieser Crate ermöglicht die Interaktion mit Diensten wie GNOME Keyring oder KWallet.

Die Verwendung von `secret-service-rs` setzt eine D-Bus-Verbindung und eine asynchrone Laufzeitumgebung (Async Runtime) voraus. Die Wahl des spezifischen Runtime-Features des Crates (z.B. `rt-tokio-crypto-rust` oder `rt-async-io-crypto-openssl` 24) muss mit der übergreifenden asynchronen Strategie des Projekts abgestimmt sein. Die Kernoperationen umfassen das sichere Speichern, Abrufen und Löschen von Geheimnissen. Diese Geheimnisse werden in Kollektionen organisiert, wobei typischerweise die Standardkollektion verwendet wird. Ein typisches Nutzungsmuster beinhaltet das Verbinden zum `SecretService`, das Abrufen der Standardkollektion und dann das Erstellen, Suchen, Abrufen oder Löschen von Items, die ein Label, Attribute (für die Suche) und die eigentliche geheime Nutzlast besitzen.23

Fehler, die vom `secret-service` Crate zurückgegeben werden, müssen in domänenspezifische Fehlertypen der Anwendung verpackt werden, um eine konsistente Fehlerbehandlung zu gewährleisten. Die Abhängigkeit vom Freedesktop Secret Service bedeutet, dass die Anwendung auf Linux-Desktop-Umgebungen angewiesen ist, die diesen Dienst bereitstellen. Für die Portabilität auf Nicht-Linux-Plattformen oder in Headless-Umgebungen wären alternative Strategien zur Geheimnisverwaltung erforderlich, was potenziell plattformspezifische Abstraktionen nach sich zieht, falls plattformübergreifende Unterstützung ein langfristiges Ziel ist.

### B. Interprozesskommunikation (IPC) Grundlagen

D-Bus wird als fundamentales IPC-Mechanismus auf Linux-Desktops anerkannt 25, zumal die Geheimnisverwaltung über `secret-service-rs` bereits darauf basiert. Sollte die Domänenschicht direkt mit anderen D-Bus-Diensten interagieren müssen, die über die Abstraktionen von `secret-service-rs` hinausgehen, oder eine eigene D-Bus-Schnittstelle bereitstellen, käme der `dbus` Crate (z.B. Version 0.9.7 26) zum Einsatz. Dies würde ein Verständnis von D-Bus-Objekten, -Methoden, -Signalen und -Schnittstellen erfordern.

Die Nutzung von D-Bus für die Geheimnisverwaltung und potenziell andere IPC-Aufgaben führt eine asynchrone Abhängigkeit ein. Die Domänenschicht, oder zumindest die Teile, die mit D-Bus interagieren, müssen asynchron-fähig sein. Dies beeinflusst die Wahl der Rust Async Runtime (z.B. Tokio, async-std) für das gesamte Projekt, da D-Bus-Operationen inhärent asynchron sind und der `secret-service` Crate dies widerspiegelt.

Es ist entscheidend, eine robuste Fehlerbehandlung für Szenarien zu implementieren, in denen D-Bus-Dienste nicht verfügbar sind oder fehlerhaft reagieren. Die Domänenschicht kann nicht davon ausgehen, dass diese Dienste immer perfekt funktionieren, und muss Verbindungsfehler, Zeitüberschreitungen und dienstspezifische Fehler adäquat behandeln, beispielsweise durch das Deaktivieren abhängiger Funktionen oder durch informative Fehlermeldungen an den Benutzer.

Obwohl viele Wayland-Protokolle (z.B. `xdg-decoration` 27, `wlr-foreign-toplevel-management` 28) primär der UI- und Kompositor-Interaktion dienen und eine Form von IPC darstellen, wird die Domänenschicht diese nicht direkt implementieren. Sie könnte jedoch Daten bereitstellen oder auf Ereignisse reagieren, die von höheren Schichten orchestriert werden, welche diese Protokolle nutzen. Ähnlich verhält es sich mit XDG Desktop Portals 30, die sandboxed Anwendungen den Zugriff auf Systemressourcen über D-Bus ermöglichen; eine Interaktion hiermit würde ebenfalls auf einer höheren Ebene als der Domänenschicht stattfinden.

## VII. API-Design-Richtlinien und Best Practices

### A. Rust API Guidelines

Die offiziellen Rust API Guidelines 16 werden als verbindliche Grundlage für das Design aller öffentlichen Schnittstellen der Domänenschicht übernommen. Eine konsequente Einhaltung dieser Richtlinien ist ein starker Indikator für die langfristige Nutzbarkeit und Wartbarkeit einer Bibliothek, da sie die kognitive Last für Entwickler reduziert und Konsistenz fördert.

Besonderer Wert wird auf folgende Bereiche gelegt 16:

- **Namensgebung (C-CASE, C-CONV, C-GETTER, C-ITER, C-ITER-TY):** Einheitliche Verwendung von `snake_case` für Funktionen/Variablen und `PascalCase` für Typen. Standardisierte Namen für Konvertierungsmethoden (`as_`, `to_`, `into_`), Getter-Konventionen und Iterator-Benennungen.
- **Interoperabilität (C-COMMON-TRAITS, C-CONV-TRAITS, C-SEND-SYNC, C-GOOD-ERR):** Implementierung gängiger Traits wie `Debug`, `Clone`, `Eq`, `PartialEq`, `Default` sowie `Send` und `Sync`, wo angebracht. Verwendung von Standard-Konvertierungstraits (`From`, `AsRef`). Sicherstellung, dass Fehlertypen sich gut verhalten.
- **Dokumentation (C-CRATE-DOC, C-EXAMPLE, C-FAILURE, C-LINK, C-METADATA):** Umfassende Dokumentation auf Crate- und Item-Ebene, Beispiele für alle öffentlichen Elemente, Dokumentation von Fehlerbedingungen (Errors, Panics). Vollständige Metadaten in `Cargo.toml`.
- **Vorhersagbarkeit (C-METHOD, C-CTOR):** Funktionen mit einem klaren Empfänger (Receiver) werden als Methoden implementiert. Konstruktoren sind statische, inhärente Methoden (z.B. `new()`).
- **Flexibilität (C-GENERIC, C-CUSTOM-TYPE):** Einsatz von Generics, wo sinnvoll. Verwendung spezifischer Typen für Argumente anstelle von Booleans oder `Option`-Typen, um Bedeutung zu transportieren.
- **Verlässlichkeit (C-VALIDATE, C-DTOR-FAIL):** Funktionen validieren ihre Argumente. Destruktoren dürfen nicht fehlschlagen.
- **Debugfähigkeit (C-DEBUG, C-DEBUG-NONEMPTY):** Alle öffentlichen Typen implementieren `Debug`.
- **Zukunftssicherheit (C-STRUCT-PRIVATE, C-NEWTYPE-HIDE):** Strukturfelder sind standardmäßig privat, um interne Änderungen ohne API-Bruch zu ermöglichen. Newtypes kapseln Implementierungsdetails. Diese "Future Proofing"-Richtlinien sind besonders wichtig für eine Domänenschicht, da sich deren Kerndatenstrukturen weiterentwickeln könnten. Kapselung erlaubt solche Änderungen mit minimalen Auswirkungen auf abhängigen Code.

### B. Projektinterne Konventionen

Zusätzlich zu den offiziellen Rust API Guidelines werden folgende projektinterne Konventionen festgelegt:

- **Modulstruktur:** Eine standardisierte Modulstruktur für die Domänenschicht (z.B. `entities/`, `repositories/`, `services/`, `errors.rs`, `config.rs`).
- **Fehlerbehandlung:** Konsequente Anwendung der in Abschnitt V.A beschriebenen Muster unter Verwendung von `thiserror`.
- **Logging:** Konsequente Anwendung der in Abschnitt V.B beschriebenen Muster unter Verwendung von `tracing` für strukturiertes Logging.
- **Teststrategie:** Unit-Tests werden direkt neben dem zu testenden Code platziert. Integrationstests für Repositories verwenden Mocks oder In-Memory-Implementierungen.
- **Codeformatierung:** Die Verwendung von `rustfmt` mit den Standardeinstellungen ist obligatorisch.6
- **Clippy Lints:** Ein strenger Satz von Clippy-Lints wird durchgesetzt, um die Codequalität weiter zu erhöhen.
- **Sichere Programmierpraktiken 4:**
    - Die Verwendung von `unsafe`-Blöcken wird minimiert. Jeder Einsatz erfordert eine gründliche Überprüfung und stichhaltige Begründung.
    - Alle Daten, die Vertrauensgrenzen überschreiten, müssen validiert werden (obwohl die Domänenschicht idealerweise bereits validierte Daten von Anwendungsdiensten erhalten sollte).
    - Abhängigkeiten werden regelmäßig mit `cargo update` aktualisiert und mit Werkzeugen wie `cargo audit` auf bekannte Sicherheitslücken überprüft. Die Integration dieser Sicherheitspraktiken direkt in die Entwicklungsrichtlinien, anstatt sie als nachträglichen Gedanken zu behandeln, ist essentiell für den Aufbau eines vertrauenswürdigen Systems. Rusts Features (Ownership, Typsystem) bieten eine starke Grundlage, erfordern aber dennoch bewusste Anstrengungen.

### C. Versionsmanagement und Branching-Strategie

Für die Versionierung der Domänenschicht-Crate, insbesondere wenn sie unabhängig veröffentlicht oder versioniert wird, wird Semantic Versioning (SemVer) angewendet.

Als Git-Branching-Modell wird GitHub Flow empfohlen.33 GitHub Flow ist einfacher als GitFlow und eignet sich gut für kontinuierliche Integration und Auslieferung (CI/CD). Es basiert auf einem Haupt-Branch (z.B. `main`), von dem Feature-Branches abgeleitet werden. Nach Abschluss und Review werden diese Feature-Branches direkt zurück in den Haupt-Branch gemerged. Dies fördert schnelle Iterationen und eine stets auslieferungsbereite Codebasis.

## VIII. Anhänge

### A. Glossar

- **Aggregat (Aggregate):** Eine Gruppe von Entitäten und Wertobjekten, die als eine einzelne Einheit für Datenänderungen behandelt wird, mit einer Wurzelentität, die Konsistenz sicherstellt.
- **Clean Architecture:** Ein Softwarearchitekturmuster, das auf der Trennung von Belangen basiert und die Unabhängigkeit der Geschäftslogik von äußeren Schichten wie UI und Datenbank betont.
- **D-Bus:** Ein Interprozesskommunikationssystem, das auf Linux-Systemen weit verbreitet ist.
- **Domänenschicht (Domain Layer):** Der Teil einer Anwendung, der die Kernlogik und die Geschäftsregeln enthält.
- **Entität (Entity):** Ein Objekt in der Domäne, das durch eine eindeutige Identität und einen Lebenszyklus definiert ist.
- **Freedesktop Secret Service API:** Eine standardisierte Schnittstelle unter Linux zur sicheren Speicherung von Geheimnissen.
- **IPC (Inter-Process Communication):** Kommunikation zwischen verschiedenen Prozessen.
- **Repository:** Eine Abstraktion, die den Zugriff auf und die Persistenz von Domänenobjekten kapselt.
- **Rust:** Eine Systemprogrammiersprache, die auf Sicherheit und Performance ausgelegt ist.
- **serde:** Ein populärer Rust-Crate für Serialisierung und Deserialisierung.
- **SemVer (Semantic Versioning):** Ein Standard für die Versionierung von Software.
- **thiserror:** Ein Rust-Crate zur einfachen Erstellung von Fehler-Enums.
- **TOML (Tom's Obvious, Minimal Language):** Ein Konfigurationsdateiformat.
- **tracing:** Ein Rust-Framework für instrumentiertes, strukturiertes Logging.
- **Ubiquitous Language:** Eine gemeinsame Sprache, die von Entwicklern und Domänenexperten verwendet wird, um Domänenkonzepte präzise zu beschreiben.
- **Wertobjekt (Value Object):** Ein Objekt, das einen beschreibenden Aspekt der Domäne darstellt und keine Identität über seine Attribute hinaus besitzt; typischerweise unveränderlich.
- **XDG Base Directory Specification:** Ein Standard von freedesktop.org, der festlegt, wo benutzerspezifische Daten- und Konfigurationsdateien gespeichert werden sollen.

### B. Referenzierte Crates und Versionen

Die Entwicklung der Domänenschicht (Teil 1) wird auf der stabilen Rust-Version 1.85.0 (oder neuer, falls zum Entwicklungsstart verfügbar) und der Rust 2024 Edition basieren.35 Die Wahl einer aktuellen Edition ermöglicht die Nutzung der neuesten Sprachfeatures und Idiome. Die Pflege einer Liste der referenzierten Crates und ihrer Versionen ist entscheidend für die Reproduzierbarkeit von Builds und das Management von Abhängigkeitsupdates.

**Tabelle 7: Externe Crate-Abhängigkeiten (Teil 1)**

|   |   |   |   |   |
|---|---|---|---|---|
|**Crate-Name**|**Version (Beispiel)**|**Lizenz**|**Hauptzweck in der Domänenschicht**|**Genutzte Schlüsselfunktionen**|
|`serde`|1.0.219|MIT/Apache-2.0|Serialisierung und Deserialisierung von Datenstrukturen.|`Serialize`, `Deserialize` Traits, `derive` Makros|
|`thiserror`|2.0.12|MIT/Apache-2.0|Ergonomische Definition von benutzerdefinierten Fehlertypen.|`#[derive(Error)]`, `#[error(...)]`, `#[from]`, `#[source]`|
|`tracing`|0.1.x|MIT|Strukturiertes, kontextbezogenes Logging und Tracing.|`span!`, `event!`, `#[instrument]`|
|`tracing-subscriber`|0.3.x|MIT|Konfiguration von Logging-Ausgabe und -Filterung.|`fmt::Layer`, `EnvFilter`|
|`toml`|0.8.22|MIT/Apache-2.0|Parsen und Serialisieren von Konfigurationsdateien im TOML-Format.|`from_str`, `to_string` (via `serde`)|
|`directories`|6.0.0|MIT/Apache-2.0|Ermittlung von Standardverzeichnispfaden (XDG).|`ProjectDirs`, `UserDirs`, `BaseDirs`|
|`secret-service`|5.0.0|MIT/Apache-2.0|Sichere Speicherung und Abruf von Geheimnissen via D-Bus.|`SecretService::connect`, Collection- und Item-Operationen|
|`dbus` (optional)|0.9.7|MIT/Apache-2.0|Direkte D-Bus Interprozesskommunikation (falls benötigt).|Verbindungshandling, Methodenaufrufe, Signalempfang|

## IX. Schlussfolgerungen

Der vorliegende Implementierungsplan für Teil 1 der Domänenschicht legt eine solide Basis für die Entwicklung einer robusten und wartbaren Anwendung. Die Wahl von Rust als Programmiersprache, kombiniert mit einer klaren Architektur nach den Prinzipien der Clean Architecture, verspricht eine hohe Codequalität und Performance. Die konsequente Nutzung etablierter Crates wie `serde` für die Datenverarbeitung, `thiserror` für eine präzise Fehlerbehandlung und `tracing` für ein aufschlussreiches Logging wird die Entwicklungseffizienz steigern und die Diagnosefähigkeit des Systems verbessern.

Die Standardisierung des Konfigurationsmanagements mittels TOML und der XDG Base Directory Specification sowie die Integration mit dem Freedesktop Secret Service für die Geheimnisverwaltung gewährleisten eine gute Einbettung in Linux-Desktop-Umgebungen. Die definierten API-Designrichtlinien und projektinternen Konventionen, einschließlich der Betonung sicherer Programmierpraktiken, werden zur langfristigen Stabilität und Sicherheit der Domänenschicht beitragen.

Durch die klare Abgrenzung der Verantwortlichkeiten und die Schaffung testbarer Komponenten wird eine hohe Softwarequalität angestrebt. Die in diesem Plan getroffenen Entscheidungen zielen darauf ab, eine Domänenschicht zu schaffen, die nicht nur die aktuellen Anforderungen erfüllt, sondern auch flexibel genug ist, um zukünftige Erweiterungen und Änderungen aufzunehmen. Die sorgfältige Modellierung der Domänenkonzepte und die Abstraktion von externen Abhängigkeiten sind hierbei Schlüsselfaktoren für den Erfolg.

# Domänenschicht Implementierungsplan (Ultra-Feinspezifikation)

## 1. Grundlagen und Architektur der Domänenschicht

Die Domänenschicht bildet das Herzstück der Desktop-Umgebung und beinhaltet die Kernlogik sowie die Geschäftsregeln. Ihre Hauptverantwortung liegt in der Verwaltung von Workspaces ("Spaces"), dem Theming-System, der Logik für KI-Interaktionen einschließlich des Einwilligungsmanagements, der Verwaltung von Benachrichtigungen und der Definition von Richtlinien für das Fenstermanagement (z.B. Tiling-Regeln). Ein fundamentaler Aspekt dieser Schicht ist ihre Unabhängigkeit von spezifischen UI-Implementierungen oder Systemdetails wie D-Bus oder Wayland. Sie nutzt Funktionalitäten der Kernschicht und stellt Logik sowie Zustand für die System- und Benutzeroberflächenschicht bereit.

### 1.1. Programmiersprache und Entwicklungsumgebung

- **Sprache:** Rust (Version 1.85.0 oder neuer, Stand Februar 2025 1). Die Wahl von Rust begründet sich durch dessen Fokus auf Speichersicherheit ohne Garbage Collector, exzellente Performance und moderne Concurrency-Features, was für ein System wie eine Desktop-Umgebung von entscheidender Bedeutung ist.2
- **Build-System:** Cargo, das Standard-Build-System und Paketmanager für Rust.5 Meson wird zwar als fähig erachtet, Rust-Projekte zu handhaben 6, jedoch ist Cargo die natürliche Wahl im Rust-Ökosystem.
- **Entwicklungsrichtlinien:**
    - Rust API Guidelines Checklist 7: Strikte Einhaltung dieser Richtlinien für Namenskonventionen (C-CASE, C-CONV, C-GETTER, C-ITER), Interoperabilität (C-COMMON-TRAITS, C-SEND-SYNC), Dokumentation (C-CRATE-DOC, C-EXAMPLE) und weitere Aspekte.
    - Rust Style Guide 8: Formatierungskonventionen (Einrückung, Zeilenlänge), Kommentierungsstil.
    - Secure Coding Practices in Rust 9: Minimierung von `unsafe` Blöcken, sorgfältige Prüfung von Abhängigkeiten, Validierung von Eingabedaten (obwohl die Domänenschicht primär interne Daten verarbeitet, ist das Prinzip wichtig).
    - Git Branching Modell: GitHub Flow wird für seine Einfachheit und den Fokus auf Continuous Delivery bevorzugt, besonders wenn schnelle Iterationen und häufige Releases angestrebt werden.10 Feature-Branches werden von `main` erstellt und nach Fertigstellung und Review direkt zurück in `main` gemerged. Für stabilere Release-Zyklen könnte GitFlow in Betracht gezogen werden, aber für die iterative Entwicklung einer neuen Desktop-Umgebung erscheint GitHub Flow agiler.

Die Entscheidung für Rust basiert auf dessen Fähigkeit, systemnahe Software zu entwickeln, die sowohl sicher als auch performant ist. Die strengen Compiler-Prüfungen von Rust helfen, viele gängige Fehlerklassen bereits zur Compile-Zeit zu eliminieren, was die Stabilität der Domänenschicht maßgeblich erhöht. Die Einhaltung etablierter Entwicklungsrichtlinien stellt sicher, dass der Code verständlich, wartbar und konsistent bleibt.

### 1.2. Kernabhängigkeiten und Basistechnologien

Die Domänenschicht wird so entworfen, dass sie minimale direkte Abhängigkeiten zu externen Systembibliotheken hat. Notwendige Interaktionen mit dem System (Dateizugriff, Prozessmanagement, etc.) erfolgen über Abstraktionen (Ports), die von der Kernschicht implementiert werden.

- **1.2.1. Externe Rust-Crates**
    - Eine detaillierte Liste der verwendeten Crates mit Versionen und Features findet sich in Anhang C.
    - Die Auswahl der Crates folgt dem Prinzip der Stabilität, Verbreitung und Wartungsfreundlichkeit.

|   |   |   |   |
|---|---|---|---|
|**Crate-Name**|**Version (Beispielhaft)**|**Kurzbeschreibung/Zweck**|**Relevante Features (Beispielhaft)**|
|`serde`|`1.0.219` 12|Serialisierung und Deserialisierung von Datenstrukturen.|`derive`|
|`thiserror`|`2.0.12` 14|Einfache Erstellung von benutzerdefinierten Fehlertypen.||
|`tracing`|`0.1.40` 15|Framework für anwendungsspezifische Diagnoseaufzeichnungen (Logging und Tracing).||
|`tracing-subscriber`|`0.3.18` 15|Implementierungen für `tracing` Subscriber (z.B. für formatiertes Logging).|`env-filter`, `fmt`|
|`toml`|`0.8.22` 18|Parsen von TOML-Konfigurationsdateien (indirekt, da Domäne geparste Daten erhält).||
|`uuid`|`1.8.0` (optional)|Generierung und Handhabung von UUIDs für eindeutige IDs.|`v4`, `serde`|
|`log`|`0.4.x`|Logging-Fassade, falls `tracing-log` verwendet wird.||
|`directories-next`|`2.0.0` (oder `directories` v6.0.0 19)|Auflösung von XDG-Standardverzeichnissen (indirekt, durch Kernschicht genutzt).||

- **1.2.2. Fehlerbehandlungsstrategie**
    
    - Verwendung des `thiserror` Crates (Version 2.0.12 14) zur Definition von benutzerdefinierten Fehlertypen.
    - Jedes Modul der Domänenschicht definiert sein eigenes spezifisches Error-Enum (z.B. `WorkspaceError`, `ThemingError`).
    - Ein globales `DomainError` Enum fasst alle modulspezifischen Fehler zusammen (siehe Abschnitt 7).
    - Die `#[from]` Annotation wird genutzt, um Fehler aus abhängigen Operationen (z.B. IO-Fehler aus der Kernschicht, die durchgereicht werden) elegant in domänenspezifische Fehler umzuwandeln.20 Dies vermeidet generische Fehlertypen und macht den Code für Aufrufer verständlicher und besser handhabbar. Die klare Strukturierung von Fehlern, beginnend bei spezifischen Fehlern pro Operation oder Modul und aggregiert in einem übergeordneten `DomainError`, erleichtert sowohl die Fehlerbehandlung innerhalb der Domänenschicht als auch die Kommunikation von Fehlern an höhere Schichten.21
- **1.2.3. Logging- und Tracing-Strategie**
    
    - Verwendung des `tracing` Crates (Core: `tracing-core` Version ~0.1.31+ 16, Subscriber: `tracing-subscriber` Version ~0.3.17+ 15).
    - Strukturierte Logs mit Span-basiertem Tracing zur Nachverfolgung von Abläufen über Modulgrenzen hinweg. Die `tracing` Bibliothek ist dem `log` Crate vorzuziehen, da sie durch Spans zusätzlichen Kontext für Diagnoseinformationen bereitstellt, was besonders bei der Analyse komplexer Abläufe in der Domänenschicht vorteilhaft ist.22
    - Konfigurierbare Loglevel (TRACE, DEBUG, INFO, WARN, ERROR).
    - Die Domänenschicht emittiert Traces und Logs; die Konfiguration des Subscribers (z.B. Format, Output) obliegt der Anwendungsschicht oder dem Hauptprogramm.
    - Die Notwendigkeit eines "lückenlosen Entwickler-Implementierungsleitfadens" schließt die Beobachtbarkeit der Software im Betrieb ein. `tracing` ermöglicht die detaillierte Erfassung des Kontrollflusses und wichtiger Zustandsänderungen. Durch die Verwendung von Spans (z.B. `span!(Level::INFO, "operation_xyz");`) können Operationen, die mehrere Schritte umfassen, logisch gruppiert werden, was die Analyse von Log-Daten erheblich vereinfacht.
- **1.2.4. Konfigurationsmanagement**
    
    - Konfigurationsdaten für Domänendienste (z.B. Standard-Theme, Standard-Workspace-Layout) werden der Domänenschicht von außen (typischerweise von der Anwendungsschicht beim Start, geladen durch die Kernschicht) übergeben.
    - Die Domänenschicht definiert Strukturen für ihre Konfigurationsparameter. Diese Strukturen sollen `serde::Deserialize` implementieren.
    - Das bevorzugte Format für Konfigurationsdateien ist TOML (Crate: `toml` Version 0.8.22+ 5).
    - Pfade zu Konfigurationsdateien werden gemäß XDG Base Directory Specification 19 von der Kernschicht aufgelöst (z.B. `$XDG_CONFIG_HOME/your_app_name/domain_settings.toml`). Die `directories` Crate (Version 6.0.0 19 oder `directories-next` 2.0.0) kann hierfür von der Kernschicht genutzt werden.
    - Die Domänenschicht selbst führt keine Dateisystemoperationen durch, um ihre Unabhängigkeit und Testbarkeit zu wahren. Sie erhält Konfigurationen als bereits geparste Datenstrukturen. Diese Trennung der Verantwortlichkeiten ist entscheidend, da Dateisystemzugriffe als Systemdetails gelten, von denen die Domänenschicht abstrahiert sein soll. `serde` und `toml` sind etablierte Standards im Rust-Ökosystem für diese Aufgabe.
- **1.2.5. Serialisierung/Deserialisierung**
    
    - Verwendung des `serde` Crates (Version 1.0.219+ 12) für die Serialisierung und Deserialisierung von Datenstrukturen, die persistiert oder über Schichtgrenzen hinweg ausgetauscht werden müssen.
    - Alle relevanten Entitäten und Wertobjekte, die persistiert oder als Teil von Events/Signalen übertragen werden, müssen `serde::Serialize` und `serde::Deserialize` implementieren.
- **1.2.6. Asynchrone Operationen**
    
    - Die Domänenschicht wird primär synchron entworfen, um die Komplexität niedrig zu halten. Langlaufende Operationen oder Interaktionen mit I/O-bound Systemen (z.B. komplexe KI-Anfragen, die über die Kernschicht laufen) können jedoch asynchrone Schnittstellen erfordern.
    - Wo Asynchronität notwendig ist, wird `async/await` mit einer durch die Kerninfrastruktur vorgegebenen Runtime (z.B. Tokio) verwendet. Die Domänenschicht selbst startet keine eigenen Runtimes.
    - Kommunikation zwischen synchronen und asynchronen Teilen erfolgt über klar definierte Kanäle (z.B. `tokio::sync::mpsc` oder `async_channel` 25), die von der Kernschicht oder der Anwendungsschicht bereitgestellt werden.
    - Die primär synchrone Natur der Domänenschicht vereinfacht das Design und die Testbarkeit erheblich. Asynchronität wird nur dort eingeführt, wo sie unumgänglich ist, und die Verwaltung des Runtimes wird an die Kernschicht delegiert. Komplexe Geschäftslogik ist oft einfacher synchron zu verstehen und zu implementieren. Würde die Domänenschicht selbst durchgängig asynchron sein, müsste sie sich um Executor, Task-Spawning etc. kümmern, was ihre Komplexität erhöht und sie stärker an eine spezifische async-Runtime bindet. Indem sie synchrone Schnittstellen anbietet und für langlaufende Operationen auf von der Kernschicht bereitgestellte `Future`s oder asynchrone Funktionen zurückgreift, bleibt sie fokussierter.

### 1.3. Interaktionsmuster mit der Kernschicht und anderen Schichten

- **Mit der Kernschicht:**
    - Die Domänenschicht definiert Traits (abstrakte Schnittstellen, sogenannte Ports), die von der Kernschicht implementiert werden müssen (Adapter), um Zugriff auf systemnahe Funktionen zu erhalten. Beispiele hierfür sind `PersistencePort`, `SystemClockPort`, `SecureStoragePort`.
    - Beispiel: Das `ThemingService` (siehe Abschnitt 3) könnte ein `ThemePersistencePort` Trait definieren, um Themes zu laden und zu speichern. Die Kernschicht würde dieses Trait implementieren und dabei z.B. auf das Dateisystem zugreifen.
- **Mit der System- und UI-Schicht:**
    - Die Domänenschicht stellt konkrete Services mit wohldefinierten Methoden bereit.
    - Die Kommunikation von Zustandsänderungen und Ereignissen aus der Domänenschicht an höhere Schichten erfolgt über ein Event/Signal-System (siehe Abschnitt 1.4.2).
    - Die Verwendung von Ports und Adapters (ein Muster der Hexagonalen Architektur) für die Interaktion mit der Kernschicht stellt sicher, dass die Domänenschicht vollständig von den Implementierungsdetails der Kernschicht entkoppelt ist. Die Domänenschicht "nutzt Funktionalität der Kernschicht". Um die Unabhängigkeit zu wahren, darf die Domänenschicht die Kernschicht nicht direkt aufrufen oder deren konkrete Typen kennen. Stattdessen definiert die Domänenschicht, _was_ sie benötigt (z.B. "speichere dieses Objekt"), und die Kernschicht liefert die Implementierung dafür. Dies ist ein Kernprinzip der Inversion of Control.

### 1.4. Allgemeine Datentypen, Traits und Hilfsfunktionen der Domänenschicht

- **1.4.1. Basis-Identifikatoren**
    
    - Typalias `DomainId`: Vorerst wird `String` für Flexibilität und einfache Serialisierung gewählt.
        
        Rust
        
        ```
        pub type DomainId = String;
        ```
        
        Alternativ könnte `uuid::Uuid` verwendet werden, falls global eindeutige IDs über Systemgrenzen hinweg erforderlich sind und dies in der Kerninfrastruktur-Spezifikation festgelegt wurde. Für rein interne Zwecke könnten auch Newtype-Strukturen um `usize` in Betracht gezogen werden. Da die Domänenschicht UI- und systemunabhängig ist, sind einfache, serialisierbare IDs oft ausreichend.
- **1.4.2. Event-System Abstraktion**
    
    - Ein generischer `DomainEvent` Enum kapselt alle Domänenereignisse. Jedes Modul definiert seine eigenen spezifischen Event-Typen, die als Varianten in `DomainEvent` aufgenommen werden.
        
        Rust
        
        ```
        #
        pub enum DomainEvent {
            Workspace(crate::workspace_manager::WorkspaceEvent),
            Theming(crate::theming_manager::ThemingEvent),
            AIConsent(crate::ai_manager::consent_manager::AIConsentEvent),
            AIFeature(crate::ai_manager::feature_service::AIFeatureEvent),
            Notification(crate::notification_manager::NotificationEvent),
            WindowPolicy(crate::window_policy_engine::WindowPolicyEvent),
            // Weitere Event-Kategorien können hier hinzugefügt werden.
        }
        ```
        
    - **Beispiel für eine spezifische Event-Kategorie (WorkspaceEvent):**
        
        Rust
        
        ```
        // Definiert in workspace_manager/events.rs oder workspace_manager/mod.rs
        #
        pub enum WorkspaceEvent {
            SpaceCreated {
                space_id: DomainId,
                name: String,
                layout_type: crate::workspace_manager::LayoutType, // Vollständiger Pfad zum Typ
                // Weitere relevante Felder
            },
            SpaceDeleted { space_id: DomainId },
            SpaceRenamed { space_id: DomainId, new_name: String },
            // Weitere Workspace-spezifische Events
        }
        ```
        
        Ähnliche Enums (`ThemingEvent`, `AIConsentEvent`, etc.) werden in den jeweiligen Modulen definiert.
    - **Publisher:** Typischerweise die Services innerhalb der Domänenschicht (z.B. `SpaceService`).
    - **Subscriber:** Andere Services innerhalb der Domänenschicht, die auf bestimmte Ereignisse reagieren müssen, oder die System-/UI-Schicht, die über Änderungen informiert werden wollen. Die konkrete Event-Bus-Implementierung wird von der Kerninfrastruktur bereitgestellt; die Domänenschicht definiert nur die Events und identifiziert typische Sender und Empfänger.
    - Ein klar definiertes, typisiertes Event-System ist fundamental für eine entkoppelte Architektur. Die Verwendung von `serde` für Events ermöglicht deren einfache Serialisierung, falls sie z.B. über Prozessgrenzen hinweg gesendet oder persistiert werden müssten. Die Anforderung, "Identifikation der typischen Publisher und Subscriber für jedes Event" und "Eindeutiger Event-Name/Typ", wird durch dieses strukturierte Event-System erfüllt. Ein übergreifender `DomainEvent` Enum mit untergeordneten Enums pro Modul schafft eine klare Hierarchie und ermöglicht es Subscribern, sich gezielt für Event-Kategorien oder spezifische Events zu registrieren.
- **1.4.3. Standardisierte Rückgabetypen**
    
    - Verwendung von `Result<T, DomainError>` für alle öffentlichen Operationen der Domänenschicht, die fehlschlagen können.
        
        Rust
        
        ```
        #
        pub enum DomainError {
            #[error("Workspace error: {0}")]
            Workspace(#[from] crate::workspace_manager::WorkspaceError),
            #
            Theming(#[from] crate::theming_manager::ThemingError),
            #[error("AI consent error: {0}")]
            AIConsent(#[from] crate::ai_manager::consent_manager::AIConsentError),
            #[error("AI feature error: {0}")]
            AIFeature(#[from] crate::ai_manager::feature_service::AIFeatureError),
            #[error("Notification error: {0}")]
            Notification(#[from] crate::notification_manager::NotificationError),
            #[error("Window policy error: {0}")]
            WindowPolicy(#[from] crate::window_policy_engine::WindowPolicyError),
        
            #[error("Persistence error: {0}")]
            Persistence(String), // Fehler von der Persistenzschicht (Kernschicht)
            #[error("Configuration error: {0}")]
            Configuration(String), // Fehler beim Verarbeiten von Konfigurationen
            #[error("Invariant violation: {0}")]
            InvariantViolation(String), // Wenn eine Geschäftsregel verletzt wurde
            #[error("Unauthorized operation: {0}")]
            Unauthorized(String),
            #
            NotFound { resource_type: String, resource_id: String },
            #[error("Invalid input: {message}")]
            InvalidInput { message: String },
            #[error("An unexpected internal error occurred: {0}")]
            Internal(String), // Für nicht spezifisch behandelte Fehler
        }
        ```
        
    - Die Definition eines übergreifenden `DomainError` Enums, der spezifischere Fehler aus den einzelnen Modulen aggregiert (mittels `#[from]`), bietet eine konsistente Fehlerbehandlungsschnittstelle für die aufrufenden Schichten. Wenn jeder Service seinen eigenen, nicht verwandten Fehlertyp zurückgibt, wird die Fehlerbehandlung in der aufrufenden Schicht komplex. Ein gemeinsamer `DomainError` mit Varianten für jeden Modulfehler (z.B. `DomainError::Workspace(WorkspaceError::SpaceNotFound)`) ermöglicht es dem Aufrufer, entweder generisch auf `DomainError` zu reagieren oder spezifisch auf `WorkspaceError` oder sogar `SpaceNotFound` zu matchen. `thiserror` erleichtert diese Struktur erheblich.

---

## 2. Modul: Workspace-Management (`workspace_manager`)

### 2.1. Übersicht und Verantwortlichkeiten

Das Modul `workspace_manager` ist für die Verwaltung von "Spaces" – virtuellen Desktops oder Arbeitsbereichen – zuständig. Es kümmert sich um die Zuordnung von Fenstern, die durch abstrakte `WindowHandle`-Identifikatoren repräsentiert werden, zu diesen Spaces. Des Weiteren verwaltet es die Layout-Konfiguration für jeden Space, beispielsweise ob Fenster gekachelt (Tiling) oder frei beweglich (Floating) angeordnet werden. Das Modul stellt Informationen über den aktuellen Zustand der Spaces und der darin enthaltenen Fenster bereit. Eine wichtige Interaktion besteht mit dem `WindowPolicyEngine` (siehe Abschnitt 6), um Standardverhalten oder spezifische Regeln bei Fensteroperationen oder Wechseln zwischen Spaces anzuwenden.

Die zentrale Rolle dieses Moduls für die Organisation der Arbeitsumgebung des Benutzers erfordert eine effiziente und klare Zustandsverwaltung, die maßgeblich zur User Experience beiträgt. Die Abstraktion von "Fenstern" als `WindowHandle` ist hierbei kritisch, um die Unabhängigkeit von spezifischen Fenstersystemen wie Wayland oder X11 zu gewährleisten. Die Domänenschicht darf keine Wayland- oder X11-spezifischen Fenster-IDs direkt kennen. Ein `WindowHandle` (z.B. eine `String` oder `uuid::Uuid`) dient als stabiler, systemunabhängiger Identifikator. Die Systemschicht ist dafür verantwortlich, die Übersetzung zwischen diesem `WindowHandle` und den tatsächlichen Fenster-IDs des jeweiligen Windowing-Systems vorzunehmen.

### 2.2. Entitäten, Wertobjekte und Enums

- **2.2.1. Entität: `Space`**
    
    - Repräsentiert einen einzelnen Workspace.
    - **Attribute:**
        - `id: DomainId` (Eindeutige ID des Space, z.B. generiert via `uuid::Uuid::new_v4().to_string()`). Sichtbarkeit: `pub(crate)`. Initialwert: Generiert bei Erstellung. Invarianten: Eindeutig, unveränderlich nach Erstellung.
        - `name: String` (Benutzerdefinierter Name, z.B. "Arbeit", "Freizeit"). Sichtbarkeit: `pub`. Initialwert: Bei Erstellung übergeben. Invarianten: Nicht leer.
        - `layout_type: LayoutType` (Aktueller Layout-Modus des Space). Sichtbarkeit: `pub`. Initialwert: Bei Erstellung übergeben, Default `LayoutType::Floating`.
        - `windows: std::collections::VecDeque<WindowHandle>` (Geordnete Liste der Fenster-Handles in diesem Space; `VecDeque` für effizientes Hinzufügen/Entfernen an beiden Enden und Beibehaltung der Reihenfolge, was für Stacking-Order oder Tiling-Reihenfolge relevant sein kann). Sichtbarkeit: `pub(crate)`. Initialwert: Leer.
        - `tiling_config: Option<TilingConfiguration>` (Spezifische Konfiguration, wenn `layout_type == LayoutType::Tiling`). Sichtbarkeit: `pub`. Initialwert: `None`. Invarianten: `Some` gdw. `layout_type` eine Tiling-Variante ist.
        - `creation_timestamp: u64` (Unix-Timestamp in Millisekunden der Erstellung). Sichtbarkeit: `pub(crate)`. Initialwert: Zeitstempel bei Erstellung.
        - `last_accessed_timestamp: u64` (Unix-Timestamp in Millisekunden des letzten Zugriffs/Aktivierung). Sichtbarkeit: `pub(crate)`. Initialwert: Zeitstempel bei Erstellung.
    - **Methoden (interne Logik der `Space`-Entität):**
        - `pub(crate) fn new(id: DomainId, name: String, layout_type: LayoutType, tiling_config: Option<TilingConfiguration>, current_timestamp: u64) -> Self`
            - Vorbedingungen: `id` und `name` nicht leer. Wenn `layout_type` eine Tiling-Variante ist, muss `tiling_config` `Some` und valide sein.
            - Nachbedingungen: Ein neues `Space`-Objekt wird mit den initialen Werten erstellt.
        - `pub(crate) fn add_window(&mut self, window_handle: WindowHandle) -> Result<(), WorkspaceError>`
            - Fügt ein Fenster am Ende der `windows`-Liste hinzu.
            - Vorbedingungen: Fenster ist nicht bereits im Space.
            - Nachbedingungen: Fenster ist im Space enthalten.
            - Geschäftsregel: Verhindert Duplikate.
        - `pub(crate) fn remove_window(&mut self, window_handle: &WindowHandle) -> Result<(), WorkspaceError>`
            - Entfernt ein Fenster aus dem Space.
            - Vorbedingungen: Fenster ist im Space enthalten.
            - Nachbedingungen: Fenster ist nicht mehr im Space.
            - Geschäftsregel: Gibt Fehler zurück, wenn Fenster nicht gefunden wird.
        - `pub(crate) fn set_layout(&mut self, layout_type: LayoutType, config: Option<TilingConfiguration>) -> Result<(), WorkspaceError>`
            - Aktualisiert `layout_type` und `tiling_config`.
            - Vorbedingungen: Wenn `layout_type` eine Tiling-Variante ist, muss `config` `Some` und valide sein.
            - Nachbedingungen: Layout-Informationen sind aktualisiert.
            - Geschäftsregel: Validiert die `config` für Tiling-Layouts.
        - `pub(crate) fn is_empty(&self) -> bool`
            - Gibt `true` zurück, wenn keine Fenster im Space sind.
        - `pub(crate) fn contains_window(&self, window_handle: &WindowHandle) -> bool`
            - Prüft, ob das Fenster im Space enthalten ist.
        - `pub(crate) fn update_last_accessed(&mut self, current_timestamp: u64)`
            - Aktualisiert `last_accessed_timestamp`.
    - **Beziehungen:** Enthält eine Sammlung von `WindowHandle`s.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub struct Space {
            pub(crate) id: DomainId,
            pub name: String,
            pub layout_type: LayoutType,
            pub(crate) windows: std::collections::VecDeque<WindowHandle>,
            pub tiling_config: Option<TilingConfiguration>,
            pub(crate) creation_timestamp: u64,
            pub(crate) last_accessed_timestamp: u64,
        }
        ```
        
- **2.2.2. Wertobjekt: `WindowHandle`**
    
    - Eine reine ID-Abstraktion für ein Anwendungsfenster. Die Domänenschicht besitzt keine Kenntnisse über Größe, Position oder Inhalt des Fensters; diese Details werden von der UI- oder Systemschicht verwaltet.
    - **Attribute:**
        - `id: DomainId` (Eindeutiger, persistenter Identifikator). Sichtbarkeit: `pub`.
    - **Invarianten:** `id` ist nicht leer und eindeutig im Kontext aller verwalteten Fenster.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub struct WindowHandle {
            pub id: DomainId,
        }
        ```
        
- **2.2.3. Enum: `LayoutType`**
    
    - Definiert die möglichen Layout-Modi für einen Space.
    - **Varianten:** `Tiling`, `Floating`, `Monocle` (Vollbild für ein einzelnes Fenster im Space), `Custom(String)` (für erweiterbare, benutzerdefinierte Layouts).
    - **Implementiert:** `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`, `PartialEq`, `Eq`, `Default` (z.B. `Floating`).
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum LayoutType {
            Tiling,
            #[default]
            Floating,
            Monocle,
            Custom(String),
        }
        ```
        
- **2.2.4. Wertobjekt: `TilingConfiguration`**
    
    - Spezifische Konfigurationseinstellungen für Tiling-Layouts.
    - **Attribute:**
        - `master_slave_ratio: f32` (Verhältnis der Master- zur Slave-Fläche, z.B. 0.5 für 50/50). Sichtbarkeit: `pub`. Initialwert: z.B. `0.5`. Invarianten: 0.1≤ratio≤0.9.
        - `num_master_windows: u32` (Anzahl der Fenster im Master-Bereich). Sichtbarkeit: `pub`. Initialwert: z.B. `1`. Invarianten: ≥1.
        - `orientation: TilingOrientation` (Ausrichtung der Tiling-Anordnung). Sichtbarkeit: `pub`. Initialwert: `TilingOrientation::Vertical`.
        - `gap_size: u32` (Abstand zwischen Fenstern in logischen Einheiten). Sichtbarkeit: `pub`. Initialwert: z.B. `5`. Invarianten: ≥0.
    - **Implementiert:** `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`, `PartialEq`.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub struct TilingConfiguration {
            pub master_slave_ratio: f32,
            pub num_master_windows: u32,
            pub orientation: TilingOrientation,
            pub gap_size: u32,
        }
        
        impl Default for TilingConfiguration {
            fn default() -> Self {
                Self {
                    master_slave_ratio: 0.5,
                    num_master_windows: 1,
                    orientation: TilingOrientation::Vertical,
                    gap_size: 5,
                }
            }
        }
        ```
        
- **2.2.5. Enum: `TilingOrientation`**
    
    - Definiert die Hauptausrichtung für Tiling-Layouts.
    - **Varianten:** `Horizontal` (Master-Bereich links/rechts), `Vertical` (Master-Bereich oben/unten).
    - **Implementiert:** `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`, `PartialEq`, `Eq`, `Default` (z.B. `Vertical`).
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum TilingOrientation {
            Horizontal,
            #[default]
            Vertical,
        }
        ```
        
- **2.2.6. Fehler-Enum: `WorkspaceError`**
    
    - Spezifische Fehler, die im `workspace_manager`-Modul auftreten können. Definiert mit `thiserror`.
    - **Varianten:**
        - `#` `SpaceNotFound { space_id: DomainId }`
        - `#` `WindowAlreadyInSpace { window_id: DomainId, space_id: DomainId }`
        - `#` `WindowNotInSpace { window_id: DomainId, space_id: DomainId }`
        - `#[error("Invalid layout configuration: {reason}")]` `InvalidLayoutConfiguration { reason: String }`
        - `#[error("A space with the name '{name}' already exists.")]` `DuplicateSpaceName { name: String }`
        - `#[error("Maximum number of spaces reached.")]` `MaxSpacesReached`
        - `#` `CannotDeleteLastSpace`
        - `#` `CannotDeleteNonEmptySpace { space_id: DomainId, window_count: usize }`
        - `#` `EmptySpaceName`
        - `#` `MissingTilingConfiguration`
        - `#` `UnexpectedTilingConfiguration`
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum WorkspaceError {
            #
            SpaceNotFound { space_id: DomainId },
            #
            WindowAlreadyInSpace { window_id: DomainId, space_id: DomainId },
            #
            WindowNotInSpace { window_id: DomainId, space_id: DomainId },
            #[error("Invalid layout configuration: {reason}")]
            InvalidLayoutConfiguration { reason: String },
            #[error("A space with the name '{name}' already exists.")]
            DuplicateSpaceName { name: String },
            #[error("Maximum number of spaces reached.")]
            MaxSpacesReached,
            #
            CannotDeleteLastSpace,
            #
            CannotDeleteNonEmptySpace { space_id: DomainId, window_count: usize },
            #
            EmptySpaceName,
            #
            MissingTilingConfiguration,
            #
            UnexpectedTilingConfiguration,
        }
        ```
        

### 2.3. Service: `SpaceService`

Der `SpaceService` ist die zentrale Komponente für die Orchestrierung aller Operationen im Zusammenhang mit Spaces. Er hält den Zustand aller bekannten Spaces (typischerweise in einer `HashMap<DomainId, Space>`) und nutzt intern die Methoden der `Space`-Entität zur Manipulation einzelner Spaces.

- **2.3.1. Eigenschaften (Interner Zustand des `SpaceService`)**
    
    - `active_space_id: Option<DomainId>`: Die ID des aktuell aktiven/fokussierten Space. Zugriff über Methoden.
    - `spaces: std::collections::HashMap<DomainId, Space>`: Eine Map, die alle bekannten Spaces anhand ihrer ID speichert.
    - `space_order: Vec<DomainId>`: Eine geordnete Liste der Space-IDs, um eine konsistente Reihenfolge (z.B. für UI-Anzeige oder Space-Navigation) beizubehalten.
    - `max_spaces: usize`: Maximale Anzahl erlaubter Spaces (konfigurierbar, z.B. Default 10).
    - `event_publisher: Box<dyn DomainEventPublisher>`: Eine Abstraktion zum Senden von Domänenereignissen (wird bei Initialisierung injiziert).
- **2.3.2. Methoden (Öffentliche API des `SpaceService`)**
    
    Alle Methoden, die den Zustand verändern (`&mut self`), sollten bei Erfolg relevante `WorkspaceEvent`s über den `event_publisher` emittieren. Die Zeitstempel werden typischerweise von einer `Clock`-Abstraktion bezogen, die von der Kernschicht bereitgestellt und dem Service injiziert wird.
    
    - `pub fn new(max_spaces: usize, event_publisher: Box<dyn DomainEventPublisher>, initial_spaces_config: Option<Vec<InitialSpaceConfig>>) -> Self`
        - Konstruktor. Initialisiert den Service. Erstellt einen Default-Space, falls `initial_spaces_config` `None` oder leer ist.
        - `event_publisher` ist eine Trait-Implementierung, die von der Anwendungsschicht bereitgestellt wird, um Events zu publizieren.
        - `InitialSpaceConfig { name: String, layout_type: LayoutType, tiling_config: Option<TilingConfiguration> }`
    - `pub fn create_space(&mut self, name: String, layout_type: LayoutType, tiling_config: Option<TilingConfiguration>) -> Result<DomainId, WorkspaceError>`
        - **Beschreibung:** Erstellt einen neuen Space.
        - **Parameter:**
            - `name: String`: Der gewünschte Name für den neuen Space.
            - `layout_type: LayoutType`: Der initiale Layout-Typ des Space.
            - `tiling_config: Option<TilingConfiguration>`: Konfiguration für Tiling, falls `layout_type` dies erfordert.
        - **Rückgabe:** `Result<DomainId, WorkspaceError>` - Die ID des neu erstellten Space oder ein Fehler.
        - **Vorbedingungen:**
            - `name` darf nicht leer sein (`WorkspaceError::EmptySpaceName`).
            - Anzahl der Spaces < `max_spaces` (`WorkspaceError::MaxSpacesReached`).
            - `name` sollte eindeutig sein (optional, sonst `WorkspaceError::DuplicateSpaceName` oder automatische Umbenennung).
            - Wenn `layout_type == LayoutType::Tiling`, muss `tiling_config` `Some` sein (`WorkspaceError::MissingTilingConfiguration`).
            - Wenn `layout_type!= LayoutType::Tiling`, sollte `tiling_config` `None` sein (optional, sonst `WorkspaceError::UnexpectedTilingConfiguration` oder Ignorieren).
        - **Nachbedingungen:** Ein neuer `Space` existiert im Service. `space_order` wird aktualisiert.
        - **Emittiert:** `WorkspaceEvent::SpaceCreated { space_id, name, layout_type, tiling_config }`.
    - `pub fn get_space(&self, space_id: &DomainId) -> Result<&Space, WorkspaceError>`
        - **Beschreibung:** Gibt eine unveränderliche Referenz auf einen Space anhand seiner ID zurück.
        - **Parameter:** `space_id: &DomainId`.
        - **Rückgabe:** `Result<&Space, WorkspaceError>` (`WorkspaceError::SpaceNotFound`).
    - `pub fn list_spaces(&self) -> Vec<&Space>`
        - **Beschreibung:** Gibt eine Liste von Referenzen auf alle Spaces in der durch `space_order` definierten Reihenfolge zurück.
        - **Rückgabe:** `Vec<&Space>`.
    - `pub fn update_space_name(&mut self, space_id: &DomainId, new_name: String) -> Result<(), WorkspaceError>`
        - **Beschreibung:** Aktualisiert den Namen eines existierenden Space.
        - **Parameter:** `space_id: &DomainId`, `new_name: String`.
        - **Vorbedingungen:** `new_name` nicht leer und (optional) eindeutig.
        - **Emittiert:** `WorkspaceEvent::SpaceRenamed { space_id: space_id.clone(), new_name }`.
    - `pub fn delete_space(&mut self, space_id: &DomainId, force_delete_windows: bool) -> Result<(), WorkspaceError>`
        - **Beschreibung:** Löscht einen Space.
        - **Parameter:** `space_id: &DomainId`, `force_delete_windows: bool`.
        - **Vorbedingungen:**
            - Es muss mehr als ein Space existieren (`WorkspaceError::CannotDeleteLastSpace`).
            - Wenn `force_delete_windows == false` und der Space Fenster enthält, wird `WorkspaceError::CannotDeleteNonEmptySpace` zurückgegeben.
        - **Logik:** Wenn `force_delete_windows == true` und Fenster im Space sind, werden diese Fenster in einen Default-Space (z.B. den ersten in `space_order` oder den aktiven, falls nicht der zu löschende) verschoben. Für jedes verschobene Fenster wird `WorkspaceEvent::WindowMovedBetweenSpaces` emittiert.
        - **Nachbedingungen:** Der Space ist entfernt. `space_order` ist aktualisiert. Wenn der gelöschte Space aktiv war, wird ein anderer Space (z.B. der nächste in der Liste) aktiv gesetzt (`ActiveSpaceChanged` Event).
        - **Emittiert:** `WorkspaceEvent::SpaceDeleted { space_id: space_id.clone() }`.
    - `pub fn add_window_to_space(&mut self, space_id: &DomainId, window_handle: WindowHandle) -> Result<(), WorkspaceError>`
        - **Beschreibung:** Fügt ein Fenster zu einem spezifischen Space hinzu. Wenn das Fenster bereits in einem anderen Space ist, wird es implizit daraus entfernt (oder es wird ein Fehler zurückgegeben, je nach Designentscheidung – hier wird angenommen, es wird verschoben).
        - **Vorbedingungen:** Der Ziel-Space existiert. Das Fenster ist nicht bereits im Ziel-Space.
        - **Logik:** Prüft, ob das Fenster in einem anderen Space ist. Falls ja, `remove_window_from_space` für den Quell-Space aufrufen. Dann zum Ziel-Space hinzufügen.
        - **Emittiert:** `WorkspaceEvent::WindowAddedToSpace { space_id: space_id.clone(), window_id: window_handle.id.clone() }`. Wenn es von einem anderen Space verschoben wurde, wird stattdessen `WindowMovedBetweenSpaces` emittiert.
    - `pub fn remove_window_from_space(&mut self, space_id: &DomainId, window_handle: &WindowHandle) -> Result<(), WorkspaceError>`
        - **Beschreibung:** Entfernt ein Fenster aus einem spezifischen Space.
        - **Vorbedingungen:** Der Space existiert und enthält das Fenster.
        - **Emittiert:** `WorkspaceEvent::WindowRemovedFromSpace { space_id: space_id.clone(), window_id: window_handle.id.clone() }`.
    - `pub fn move_window_to_space(&mut self, window_handle: &WindowHandle, target_space_id: &DomainId) -> Result<(), WorkspaceError>`
        - **Beschreibung:** Verschiebt ein Fenster von seinem aktuellen Space (falls vorhanden) in den `target_space_id`.
        - **Logik:** Findet den Quell-Space des Fensters. Ruft `remove_window_from_space` für den Quell-Space und `add_window_to_space` für den Ziel-Space auf.
        - **Emittiert:** `WorkspaceEvent::WindowMovedBetweenSpaces { window_id: window_handle.id.clone(), source_space_id, target_space_id: target_space_id.clone() }`.
    - `pub fn set_space_layout(&mut self, space_id: &DomainId, layout_type: LayoutType, tiling_config: Option<TilingConfiguration>) -> Result<(), WorkspaceError>`
        - **Beschreibung:** Ändert das Layout eines Space.
        - **Vorbedingungen:** Validierung der `tiling_config` analog zu `create_space`.
        - **Emittiert:** `WorkspaceEvent::SpaceLayoutChanged { space_id: space_id.clone(), new_layout: layout_type, new_config: tiling_config }`.
    - `pub fn get_active_space_id(&self) -> Option<DomainId>`
        - **Beschreibung:** Gibt die ID des aktuell aktiven Space zurück.
    - `pub fn set_active_space(&mut self, space_id: &DomainId) -> Result<(), WorkspaceError>`
        - **Beschreibung:** Setzt den aktiven Space.
        - **Vorbedingungen:** Der Space mit `space_id` existiert.
        - **Nachbedingungen:** `active_space_id` ist aktualisiert. `last_accessed_timestamp` des neuen aktiven Space wird aktualisiert.
        - **Emittiert:** `WorkspaceEvent::ActiveSpaceChanged { old_space_id: self.active_space_id.clone(), new_space_id: space_id.clone() }`.
    - `pub fn get_windows_in_space(&self, space_id: &DomainId) -> Result<Vec<WindowHandle>, WorkspaceError>`
        - **Beschreibung:** Gibt eine Kopie der Liste der Fenster-Handles für einen gegebenen Space zurück.
    - `pub fn find_space_for_window(&self, window_handle: &WindowHandle) -> Option<DomainId>`
        - **Beschreibung:** Gibt die ID des Space zurück, der das angegebene Fenster enthält, falls vorhanden.
    - `pub fn reorder_window_in_space(&mut self, space_id: &DomainId, window_handle: &WindowHandle, new_index: usize) -> Result<(), WorkspaceError>`
        - **Beschreibung:** Ändert die Position eines Fensters innerhalb der `windows`-Liste eines Space (relevant für Stacking-Order oder Tiling).
        - **Emittiert:** `WorkspaceEvent::WindowReorderedInSpace { space_id: space_id.clone(), window_id: window_handle.id.clone(), new_index }`.
    - `pub fn reorder_space(&mut self, space_id: &DomainId, new_index: usize) -> Result<(), WorkspaceError>`
        - **Beschreibung:** Ändert die Position eines Space in der globalen `space_order`-Liste.
        - **Emittiert:** `WorkspaceEvent::SpaceReordered { space_id: space_id.clone(), new_index }`.
- **2.3.3. Signale/Events (als Varianten von `WorkspaceEvent` im `DomainEvent` Enum)**
    
    Diese Events werden vom `SpaceService` emittiert und über den injizierten `DomainEventPublisher` verteilt.
    
    - `SpaceCreated { space_id: DomainId, name: String, layout_type: LayoutType, tiling_config: Option<TilingConfiguration> }`
    - `SpaceDeleted { space_id: DomainId }`
    - `SpaceRenamed { space_id: DomainId, new_name: String }`
    - `SpaceLayoutChanged { space_id: DomainId, new_layout: LayoutType, new_config: Option<TilingConfiguration> }`
    - `WindowAddedToSpace { space_id: DomainId, window_id: DomainId }`
    - `WindowRemovedFromSpace { space_id: DomainId, window_id: DomainId }`
    - `WindowMovedBetweenSpaces { window_id: DomainId, source_space_id: DomainId, target_space_id: DomainId }`
    - `ActiveSpaceChanged { old_space_id: Option<DomainId>, new_space_id: DomainId }`
    - `WindowReorderedInSpace { space_id: DomainId, window_id: DomainId, new_index: usize }`
    - `SpaceReordered { space_id: DomainId, new_index: usize }`
    - **Typische Publisher:** `SpaceService`.
    - **Typische Subscriber:** UI-Schicht (zur Aktualisierung der Darstellung), `WindowPolicyEngine` (um ggf. auf Änderungen zu reagieren, z.B. um Fenster neu anzuordnen, wenn sich der aktive Space ändert), Persistenzmechanismus in der Kernschicht (um Änderungen zu speichern).
- **2.3.4. Trait: `DomainEventPublisher` (von Anwendungsschicht zu implementieren)**
    
    Rust
    
    ```
    pub trait DomainEventPublisher: Send + Sync {
        fn publish(&self, event: DomainEvent);
    }
    ```
    
    Dieser Trait wird benötigt, damit der `SpaceService` (und andere Services) Ereignisse publizieren können, ohne eine konkrete Implementierung eines Event-Busses zu kennen.
    

### 2.4. Geschäftsregeln und Invarianten (Beispiele)

- Ein Fenster kann immer nur in genau einem Space sein. Dies wird durch die Logik in `add_window_to_space` und `move_window_to_space` sichergestellt, die ein Fenster implizit aus seinem vorherigen Space entfernt.
- Es muss immer mindestens ein Space geben. `delete_space` verhindert das Löschen des letzten Space.
- Der Name eines Space sollte eindeutig sein (optional, konfigurierbar, ob Duplikate mit Suffix versehen oder abgelehnt werden). Die Methode `create_space` prüft dies.
- Spezifische Regeln für Tiling-Layouts (z.B. Mindestgröße von Fenstern, Verhalten bei Hinzufügen/Entfernen) werden innerhalb der `TilingConfiguration` und der Logik, die dieses Layout anwendet (potenziell in der UI-Schicht oder einer spezialisierten Layout-Engine, die von der Domänenschicht gesteuert wird), durchgesetzt. Die Domänenschicht speichert nur die Konfiguration.
- Maximale Anzahl von Spaces (`max_spaces`): Wird in `create_space` geprüft.

Die folgende Tabelle fasst die Attribute der `Space`-Entität zusammen:

**Tabelle 2.2.1: Entität `Space` - Attribute**

|   |   |   |   |   |
|---|---|---|---|---|
|**Attribut**|**Typ**|**Sichtbarkeit**|**Initialwert (Beispiel)**|**Invarianten**|
|`id`|`DomainId`|`pub(crate)`|Generiert|Eindeutig, unveränderlich|
|`name`|`String`|`pub`|Bei Erstellung|Nicht leer|
|`layout_type`|`LayoutType`|`pub`|`LayoutType::Floating`|Gültiger `LayoutType`|
|`windows`|`std::collections::VecDeque<WindowHandle>`|`pub(crate)`|Leer|Enthält nur gültige `WindowHandle`s|
|`tiling_config`|`Option<TilingConfiguration>`|`pub`|`None`|`Some` gdw. `layout_type` ist Tiling-Variante|
|`creation_timestamp`|`u64`|`pub(crate)`|Zeitstempel bei Erstellung||
|`last_accessed_timestamp`|`u64`|`pub(crate)`|Zeitstempel bei Erstellung||

Die öffentliche API des `SpaceService` ist in der folgenden Tabelle dargestellt:

**Tabelle 2.3.2: `SpaceService` - Öffentliche API (Auswahl)**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp**|**Kurzbeschreibung**|
|`create_space`|`name: String`, `layout: LayoutType`, `config: Option<TilingConfiguration>`|`Result<DomainId, WorkspaceError>`|Erstellt einen neuen Space.|
|`get_space`|`space_id: &DomainId`|`Result<&Space, WorkspaceError>`|Ruft einen Space anhand seiner ID ab.|
|`list_spaces`||`Vec<&Space>`|Listet alle Spaces auf.|
|`delete_space`|`space_id: &DomainId`, `force: bool`|`Result<(), WorkspaceError>`|Löscht einen Space.|
|`add_window_to_space`|`space_id: &DomainId`, `window: WindowHandle`|`Result<(), WorkspaceError>`|Fügt ein Fenster zu einem Space hinzu.|
|`move_window_to_space`|`window: &WindowHandle`, `target_space_id: &DomainId`|`Result<(), WorkspaceError>`|Verschiebt ein Fenster in einen anderen Space.|
|`set_active_space`|`space_id: &DomainId`|`Result<(), WorkspaceError>`|Setzt den aktiven Space.|
|`get_active_space_id`||`Option<DomainId>`|Gibt die ID des aktiven Space zurück.|

---

## 3. Modul: Theming-System (`theming_manager`)

### 3.1. Übersicht und Verantwortlichkeiten

Das `theming_manager`-Modul ist für die Verwaltung von Themes und deren Design-Tokens zuständig. Es ermöglicht die Anwendung eines aktiven Themes und dessen Variante (z.B. Hell/Dunkel) und stellt Mechanismen bereit, über die die UI-Schicht Token-Werte abfragen kann. Das Laden und Speichern von Theme-Definitionen erfolgt über Abstraktionen (Ports), die von der Kernschicht implementiert werden.

Ein Token-basiertes Theming-System ist hierbei von zentraler Bedeutung.26 Die Domänenschicht verwaltet die _Definition_ und _Auswahl_ der Tokens. Die _Interpretation und Anwendung_ dieser Tokens (z.B. das Rendern von CSS für GTK-Anwendungen) ist Aufgabe der UI-Schicht. GTK4-CSS-Konzepte, wie sie in 28 beschrieben sind (z.B. Custom Properties wie `--prop: value; color: var(--prop);`), dienen als starkes konzeptionelles Vorbild für die Struktur der Tokens, auch wenn die Domänenschicht selbst kein CSS direkt verarbeitet oder generiert. Die UI-Unabhängigkeit der Domänenschicht bedingt, dass das Theming-System keine direkten Zeichenoperationen durchführt. Stattdessen liefert es die notwendigen Informationen, beispielsweise einen Token `primary_background_color: "#FFFFFF"`. Die UI-Schicht fragt diesen Token-Wert ab und verwendet ihn in ihrem spezifischen Rendering-System (z.B. GTK CSS, Qt Stylesheets oder Web CSS). Dieser Ansatz fördert Konsistenz, ermöglicht schnellere Updates und verbessert die Skalierbarkeit des Theming-Systems.26

### 3.2. Entitäten, Wertobjekte und Enums

- **3.2.1. Entität: `Theme`**
    
    - Repräsentiert eine vollständige Theme-Definition.
    - **Attribute:**
        - `id: DomainId` (Eindeutige ID des Themes, z.B. "arc-dark-custom"). Sichtbarkeit: `pub`. Invarianten: Eindeutig, nicht leer.
        - `name: String` (Anzeigename, z.B. "Arc Dark Custom"). Sichtbarkeit: `pub`. Invarianten: Nicht leer.
        - `description: Option<String>` (Optionale Beschreibung des Themes). Sichtbarkeit: `pub`.
        - `author: Option<String>` (Optionaler Autor des Themes). Sichtbarkeit: `pub`.
        - `version: String` (Version des Themes, z.B. "1.0.0"). Sichtbarkeit: `pub`. Invarianten: Nicht leer.
        - `supported_variants: Vec<ThemeVariantType>` (Liste der unterstützten Varianten, z.B. ``). Sichtbarkeit: `pub`. Invarianten: Muss mindestens eine Variante enthalten.
        - `tokens: std::collections::HashMap<String, ThemeToken>` (Schlüssel ist der hierarchische Token-Name, z.B. "color.background.primary"). Sichtbarkeit: `pub(crate)`.
        - `metadata: std::collections::HashMap<String, String>` (Zusätzliche Metadaten, z.B. Pfad zur Quelldatei, Lizenz). Sichtbarkeit: `pub`.
    - **Methoden (interne Logik der `Theme`-Entität):**
        - `pub(crate) fn get_token_value(&self, token_name: &str, variant: ThemeVariantType) -> Option<&ThemeTokenValue>`
            - Sucht den Token mit `token_name`.
            - Gibt `value_dark` zurück, wenn `variant == Dark` und `value_dark` `Some` ist.
            - Gibt ansonsten `value_light` zurück, wenn der Token die Variante unterstützt (implizit, da `value_light` obligatorisch ist).
            - Gibt `None` zurück, wenn der Token nicht existiert oder die spezifische Variante nicht explizit definiert ist und keine Ableitungsregel existiert (für diese Spezifikation wird keine komplexe Ableitung angenommen).
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub struct Theme {
            pub id: DomainId,
            pub name: String,
            pub description: Option<String>,
            pub author: Option<String>,
            pub version: String,
            pub supported_variants: Vec<ThemeVariantType>,
            pub(crate) tokens: std::collections::HashMap<String, ThemeToken>,
            pub metadata: std::collections::HashMap<String, String>,
        }
        ```
        
- **3.2.2. Wertobjekt: `ThemeToken`**
    
    - Definiert einen einzelnen Design-Token. Die Trennung von `value_light` und `value_dark` direkt im Token ermöglicht eine explizite Definition pro Variante und vereinfacht die Abfrage.
    - **Attribute:**
        - `name: String` (Eindeutiger, hierarchischer Name, z.B. "color.text.primary", "font.body.family", "spacing.medium"). Sichtbarkeit: `pub`. Invarianten: Nicht leer, folgt einer Namenskonvention (z.B. `kebab-case` oder `snake_case`).
        - `token_type: ThemeTokenType` (Typ des Tokens). Sichtbarkeit: `pub`.
        - `value_light: ThemeTokenValue` (Wert für die helle Variante). Sichtbarkeit: `pub`. Invarianten: Muss zum `token_type` passen.
        - `value_dark: Option<ThemeTokenValue>` (Optionaler spezifischer Wert für die dunkle Variante; falls `None`, wird `value_light` verwendet). Sichtbarkeit: `pub`. Invarianten: Falls `Some`, muss zum `token_type` passen.
        - `description: Option<String>` (Beschreibung des Tokens und seines Verwendungszwecks). Sichtbarkeit: `pub`.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub struct ThemeToken {
            pub name: String,
            pub token_type: ThemeTokenType,
            pub value_light: ThemeTokenValue,
            pub value_dark: Option<ThemeTokenValue>,
            pub description: Option<String>,
        }
        ```
        
- **3.2.3. Enum: `ThemeTokenType`**
    
    - Klassifiziert die Art eines `ThemeToken`.
    - **Varianten:** `Color` (String, z.B. "#RRGGBBAA" oder "rgba(r,g,b,a)"), `FontSize` (String, z.B. "12pt", "1.2em"), `FontFamily` (String, z.B. "Noto Sans"), `Spacing` (String, z.B. "8px"), `BorderRadius` (String, z.B. "4px"), `Shadow` (String, CSS-ähnliche Definition, z.B. "2px 2px 5px rgba(0,0,0,0.3)"), `IconSet` (String, Name eines Icon-Sets), `Custom(String)` (für anwendungsspezifische Tokens, z.B. "animation.duration.fast").
    - **Implementiert:** `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`, `PartialEq`, `Eq`.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum ThemeTokenType {
            Color,
            FontSize,
            FontFamily,
            Spacing,
            BorderRadius,
            Shadow,
            IconSet,
            Custom(String),
        }
        ```
        
- **3.2.4. Wertobjekt: `ThemeTokenValue`**
    
    - Repräsentiert den konkreten Wert eines Tokens. Für Einfachheit wird hier `String` verwendet; die UI-Schicht interpretiert den String basierend auf `ThemeTokenType`.
    - **Attribute:**
        - `value: String`. Sichtbarkeit: `pub`.
    - **Implementiert:** `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`, `PartialEq`, `Eq`, `Default`.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub struct ThemeTokenValue {
            pub value: String,
        }
        ```
        
- **3.2.5. Wertobjekt: `ActiveThemeState`**
    
    - Speichert den aktuell aktiven Theme-Zustand.
    - **Attribute:**
        - `theme_id: DomainId` (ID des aktiven Themes). Sichtbarkeit: `pub`.
        - `variant: ThemeVariantType` (Aktive Variante). Sichtbarkeit: `pub`.
    - **Implementiert:** `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`, `PartialEq`, `Eq`, `Default`.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub struct ActiveThemeState {
            pub theme_id: DomainId,
            pub variant: ThemeVariantType,
        }
        ```
        
- **3.2.6. Enum: `ThemeVariantType`**
    
    - Definiert die möglichen Varianten eines Themes.
    - **Varianten:** `Light`, `Dark`.
    - **Implementiert:** `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`, `PartialEq`, `Eq`, `Default` (z.B. `Light`).
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum ThemeVariantType {
            #[default]
            Light,
            Dark,
        }
        ```
        
- **3.2.7. Fehler-Enum: `ThemingError`**
    
    - Spezifische Fehler für das `theming_manager`-Modul. Definiert mit `thiserror`.
    - **Varianten:**
        - `#` `ThemeNotFound { theme_id: DomainId }`
        - `#` `TokenNotFound { theme_id: DomainId, token_name: String }`
        - `#[error("Variant '{variant:?}' not supported by theme '{theme_id}'.")]` `VariantNotSupported { theme_id: DomainId, variant: ThemeVariantType }`
        - `#[error("Invalid token value for '{token_name}': '{value}'. Expected type: {expected_type:?}.")]` `InvalidTokenValue { token_name: String, value: String, expected_type: ThemeTokenType }`
        - `#[error("Failed to load theme from '{path}': {reason}")]` `ThemeLoadError { path: String, reason: String }`
        - `#[error("Failed to save theme to '{path}': {reason}")]` `ThemeSaveError { path: String, reason: String }`
        - `#` `ThemeIdExists { theme_id: DomainId }`
        - `#` `DefaultThemeActivationFailed { theme_id: DomainId, reason: String }`
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum ThemingError {
            #
            ThemeNotFound { theme_id: DomainId },
            #
            TokenNotFound { theme_id: DomainId, token_name: String },
            #[error("Variant '{variant:?}' not supported by theme '{theme_id}'.")]
            VariantNotSupported { theme_id: DomainId, variant: ThemeVariantType },
            #[error("Invalid token value for '{token_name}': '{value}'. Expected type: {expected_type:?}.")]
            InvalidTokenValue { token_name: String, value: String, expected_type: ThemeTokenType },
            #[error("Failed to load theme from '{path}': {reason}")]
            ThemeLoadError { path: String, reason: String },
            #[error("Failed to save theme to '{path}': {reason}")]
            ThemeSaveError { path: String, reason: String },
            #
            ThemeIdExists { theme_id: DomainId },
            #
            DefaultThemeActivationFailed { theme_id: DomainId, reason: String },
        }
        ```
        

### 3.3. Service: `ThemingService`

Der `ThemingService` verwaltet die geladenen Themes und den aktiven Theme-Zustand. Er interagiert mit einem `ThemePersistencePort` (implementiert von der Kernschicht) zum Laden und Speichern von Theme-Daten und dem aktiven Zustand.

- **3.3.1. Eigenschaften (Interner Zustand des `ThemingService`)**
    
    - `loaded_themes: std::collections::HashMap<DomainId, Theme>`: Map aller geladenen Themes.
    - `active_theme_state: ActiveThemeState`: Der aktuell ausgewählte Theme und dessen Variante.
    - `theme_persistence_port: Box<dyn ThemePersistencePort>`: Injizierter Port für Persistenz.
    - `event_publisher: Box<dyn DomainEventPublisher>`: Injizierter Publisher für Domänenereignisse.
    - `default_theme_id: DomainId`: ID eines fest einkompilierten oder als sicher bekannten Fallback-Themes.
- **3.3.2. Methoden (Öffentliche API des `ThemingService`)**
    
    - `pub fn new(default_theme_id: DomainId, default_theme: Theme, theme_persistence_port: Box<dyn ThemePersistencePort>, event_publisher: Box<dyn DomainEventPublisher>) -> Self`
        - Konstruktor. Lädt initial verfügbare Themes über den `theme_persistence_port` und den gespeicherten `ActiveThemeState`.
        - Fügt das `default_theme` zu `loaded_themes` hinzu.
        - Versucht, den gespeicherten aktiven Theme-Zustand zu laden. Falls nicht erfolgreich oder inkonsistent, wird `default_theme_id` mit `ThemeVariantType::default()` aktiviert.
    - `pub fn list_available_themes(&self) -> Vec<(DomainId, String)>`
        - Gibt eine Liste von Tupeln `(id, name)` aller geladenen Themes zurück.
    - `pub fn get_theme_details(&self, theme_id: &DomainId) -> Result<&Theme, ThemingError>`
        - Gibt Details zu einem spezifischen Theme zurück.
    - `pub fn set_active_theme(&mut self, theme_id: &DomainId) -> Result<(), ThemingError>`
        - Setzt das aktive Theme. Die Variante bleibt unverändert, sofern vom neuen Theme unterstützt, sonst wird die Default-Variante des neuen Themes gewählt.
        - Vorbedingungen: Theme mit `theme_id` muss existieren und die aktuelle (oder eine Default-) Variante unterstützen.
        - Nachbedingungen: `active_theme_state.theme_id` ist aktualisiert.
        - Emittiert: `ThemingEvent::ActiveThemeChanged { new_theme_id: theme_id.clone(), new_variant: self.active_theme_state.variant }`.
        - Persistiert den neuen Zustand über `theme_persistence_port.save_active_theme_state()`.
    - `pub fn set_active_variant(&mut self, variant: ThemeVariantType) -> Result<(), ThemingError>`
        - Setzt die aktive Theme-Variante.
        - Vorbedingungen: Das aktuell aktive Theme muss die `variant` unterstützen.
        - Nachbedingungen: `active_theme_state.variant` ist aktualisiert.
        - Emittiert: `ThemingEvent::ThemeVariantChanged { new_variant: variant }`.
        - Persistiert den neuen Zustand.
    - `pub fn get_active_theme_id(&self) -> &DomainId`
    - `pub fn get_active_variant(&self) -> ThemeVariantType`
    - `pub fn get_token_value(&self, token_name: &str) -> Result<ThemeTokenValue, ThemingError>`
        - Gibt den Wert des angeforderten Tokens für das aktuell aktive Theme und die aktive Variante zurück.
        - Nutzt intern `Theme::get_token_value()`.
        - Fallback: Wenn Token im spezifischen Theme nicht gefunden, könnte ein Fallback auf das Default-Theme erfolgen (optional, muss klar definiert sein).
    - `pub fn get_specific_token_value(&self, theme_id: &DomainId, variant: ThemeVariantType, token_name: &str) -> Result<ThemeTokenValue, ThemingError>`
        - Gibt den Wert eines Tokens für ein spezifisches (nicht notwendigerweise aktives) Theme und eine spezifische Variante zurück.
    - `pub fn reload_themes(&mut self) -> Result<usize, ThemingError>`
        - Lädt alle Themes von den bekannten Pfaden (die der `ThemePersistencePort` kennt) neu.
        - Aktualisiert `loaded_themes`. Stellt sicher, dass das `active_theme_state` gültig bleibt (ggf. Fallback auf Default-Theme).
        - Gibt die Anzahl der erfolgreich geladenen Themes zurück.
        - Emittiert: `ThemingEvent::ThemesReloaded { num_loaded }`.
    - `pub fn add_theme(&mut self, theme: Theme) -> Result<(), ThemingError>`
        - Fügt ein neues Theme dynamisch hinzu (z.B. von Benutzer importiert).
        - Vorbedingungen: `theme.id` darf nicht bereits existieren.
        - Speichert das Theme über den `ThemePersistencePort`.
        - Emittiert: `ThemingEvent::ThemeAdded { theme_id: theme.id.clone() }`.
    - `pub fn remove_theme(&mut self, theme_id: &DomainId) -> Result<(), ThemingError>`
        - Entfernt ein Theme.
        - Vorbedingungen: Das Theme darf nicht das aktive Theme sein (oder es muss ein Fallback-Mechanismus greifen). Darf nicht das Default-Theme sein.
        - Löscht das Theme über den `ThemePersistencePort`.
        - Emittiert: `ThemingEvent::ThemeRemoved { theme_id: theme_id.clone() }`.
- **3.3.3. Signale/Events (als Varianten von `ThemingEvent` im `DomainEvent` Enum)**
    
    - `ActiveThemeChanged { new_theme_id: DomainId, new_variant: ThemeVariantType }`
    - `ThemeVariantChanged { new_variant: ThemeVariantType }`
    - `ThemesReloaded { num_loaded: usize }`
    - `ThemeAdded { theme_id: DomainId }`
    - `ThemeRemoved { theme_id: DomainId }`
    - `TokenValueChanged { theme_id: DomainId, variant: ThemeVariantType, token_name: String, new_value: ThemeTokenValue }` (Nur relevant, falls einzelne Tokens zur Laufzeit änderbar sein sollen, was typischerweise nicht der Fall ist für persistierte Themes, sondern eher für dynamische Anpassungen).
    - **Typische Publisher:** `ThemingService`.
    - **Typische Subscriber:** UI-Schicht (um auf Theme-Änderungen zu reagieren und die UI neu zu zeichnen/stilisieren), andere Domänendienste, die themenabhängige Logik haben könnten (selten).

### 3.4. Geschäftsregeln

- **Fallback-Mechanismen:** Wenn ein Token im aktiven Theme nicht definiert ist oder die spezifische Variante nicht abdeckt, wird der Wert des Tokens aus dem `default_theme_id` für die entsprechende Variante verwendet. Wenn auch dort nicht vorhanden, muss ein fest kodierter, anwendungsweiter Standardwert greifen (dieser ist außerhalb des ThemingService zu definieren, z.B. in der UI-Schicht als letzte Instanz).
- **Validierung von Theme-Dateien:** Beim Laden (durch den `ThemePersistencePort`) müssen Themes auf syntaktische Korrektheit und das Vorhandensein essentieller Tokens (z.B. Basisfarben, Standardschriftgrößen) geprüft werden. Fehlerhafte Themes werden nicht geladen.
- Das System muss immer ein gültiges aktives Theme haben. Das `default_theme` (mit `default_theme_id`) dient als garantierter Fallback.

### 3.5. Trait: `ThemePersistencePort` (von Kernschicht zu implementieren)

Dieser Port definiert die Schnittstelle, über die der `ThemingService` mit der Kernschicht für die Persistenz von Theme-Daten interagiert. Dies entkoppelt den Service von der konkreten Speicherimplementierung.

- `fn load_all_themes(&self) -> Result<Vec<Theme>, DomainError>;`
    - Lädt alle verfügbaren Theme-Definitionen von konfigurierten Speicherorten.
- `fn save_theme(&self, theme: &Theme) -> Result<(), DomainError>;`
    - Speichert eine einzelne Theme-Definition.
- `fn delete_theme(&self, theme_id: &DomainId) -> Result<(), DomainError>;`
    - Löscht eine Theme-Definition.
- `fn load_active_theme_state(&self) -> Result<Option<ActiveThemeState>, DomainError>;`
    - Lädt den zuletzt gespeicherten aktiven Theme-Zustand. Gibt `Ok(None)` zurück, wenn kein Zustand gespeichert ist.
- `fn save_active_theme_state(&self, state: &ActiveThemeState) -> Result<(), DomainError>;`
    - Speichert den aktuellen aktiven Theme-Zustand.

Die Implementierung dieses Traits in der Kernschicht würde typischerweise TOML-Dateien in XDG-Verzeichnissen (z.B. `$XDG_DATA_HOME/your_app_name/themes/` für Themes, `$XDG_CONFIG_HOME/your_app_name/theming_state.toml` für den aktiven Zustand) lesen und schreiben.

Die folgenden Tabellen fassen wichtige Aspekte des Theming-Systems zusammen:

**Tabelle 3.2.1: Entität `Theme` - Attribute**

|   |   |   |   |
|---|---|---|---|
|**Attribut**|**Typ**|**Sichtbarkeit**|**Invarianten**|
|`id`|`DomainId`|`pub`|Eindeutig, nicht leer|
|`name`|`String`|`pub`|Nicht leer|
|`description`|`Option<String>`|`pub`||
|`author`|`Option<String>`|`pub`||
|`version`|`String`|`pub`|Nicht leer|
|`supported_variants`|`Vec<ThemeVariantType>`|`pub`|Mindestens eine Variante|
|`tokens`|`std::collections::HashMap<String, ThemeToken>`|`pub(crate)`|Enthält gültige `ThemeToken`-Definitionen|
|`metadata`|`std::collections::HashMap<String, String>`|`pub`||

**Tabelle 3.2.2: Wertobjekt `ThemeToken` - Attribute**

|   |   |   |   |
|---|---|---|---|
|**Attribut**|**Typ**|**Sichtbarkeit**|**Invarianten**|
|`name`|`String`|`pub`|Nicht leer, hierarchisch (z.B. "color.text.primary")|
|`token_type`|`ThemeTokenType`|`pub`|Gültiger `ThemeTokenType`|
|`value_light`|`ThemeTokenValue`|`pub`|Passend zu `token_type`|
|`value_dark`|`Option<ThemeTokenValue>`|`pub`|Falls `Some`, passend zu `token_type`|
|`description`|`Option<String>`|`pub`||

**Tabelle 3.3.2: `ThemingService` - Öffentliche API (Auswahl)**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp**|**Kurzbeschreibung**|
|`list_available_themes`||`Vec<(DomainId, String)>`|Listet IDs und Namen aller geladenen Themes.|
|`set_active_theme`|`theme_id: &DomainId`|`Result<(), ThemingError>`|Setzt das aktive Theme.|
|`set_active_variant`|`variant: ThemeVariantType`|`Result<(), ThemingError>`|Setzt die aktive Theme-Variante.|
|`get_active_theme_id`||`&DomainId`|Gibt die ID des aktiven Themes zurück.|
|`get_active_variant`||`ThemeVariantType`|Gibt die aktive Variante zurück.|
|`get_token_value`|`token_name: &str`|`Result<ThemeTokenValue, ThemingError>`|Ruft Token-Wert für aktives Theme/Variante ab.|
|`reload_themes`||`Result<usize, ThemingError>`|Lädt alle Themes neu.|
|`add_theme`|`theme: Theme`|`Result<(), ThemingError>`|Fügt ein neues Theme hinzu und persistiert es.|
|`remove_theme`|`theme_id: &DomainId`|`Result<(), ThemingError>`|Entfernt ein Theme und löscht es aus der Persistenz.|

---

## 4. Modul: KI-Interaktionen (`ai_manager`)

### 4.1. Übersicht und Verantwortlichkeiten

Das `ai_manager`-Modul dient als zentrale Anlaufstelle für die Verwaltung aller KI-gestützten Funktionen innerhalb der Desktop-Umgebung. Es ist in zwei Hauptuntermodule gegliedert: `consent_manager` für die Verwaltung von Benutzereinwilligungen bezüglich der Datennutzung und Funktionsausführung durch KI, und `feature_service` für die Implementierung der eigentlichen Logik der KI-Features. Eine Kernaufgabe des Moduls ist es, sicherzustellen, dass KI-Funktionen nur mit expliziter, informierter und granularer Zustimmung des Benutzers ausgeführt werden. Es abstrahiert die Kommunikation mit potenziellen KI-Modellen oder -Diensten, deren Anbindung über die Kernschicht erfolgt.

Die Architektur dieses Moduls kann von den Konzepten des Model Context Protocol (MCP) profitieren, wie in 31 beschrieben. MCP schlägt eine Client-Server-Architektur vor, bei der "Hosts" (Anwendungen) über "Clients" mit "MCP-Servern" kommunizieren, die Zugriff auf Datenquellen und Werkzeuge bereitstellen. In diesem Kontext könnte die Domänenschicht als "Host" (oder Teil davon) agieren, der Anfragen an KI-Funktionen stellt. Die Kernschicht wäre dann verantwortlich für die Implementierung des "MCP-Clients" und die Anbindung an externe "MCP-Server" oder äquivalente KI-Dienste. Die Domänenschicht definiert dabei die _Struktur_ der Anfragen und der erwarteten Antworten sowie die Logik des Einwilligungsmanagements. KI-Funktionen benötigen oft Kontext (Daten) und die Fähigkeit, Aktionen auszuführen. MCP zielt darauf ab, diesen Zugriff zu standardisieren. Die Domänenschicht muss klar definieren, _welchen_ Kontext eine spezifische KI-Funktion benötigt (z.B. "aktueller Workspace", "aktives Fenster", "Benachrichtigungshistorie") und welche Aktionen sie ausführen darf (z.B. "Fenster anordnen", "Text vorschlagen"). Das `ConsentManager`-Untermodul stellt sicher, dass der Zugriff auf diesen Kontext und die Ausführung dieser Aktionen nur mit gültiger Benutzereinwilligung erfolgt.

### 4.2. Untermodul: Einwilligungsmanagement (`consent_manager`)

Dieses Untermodul ist verantwortlich für die Verwaltung und Persistenz der Benutzereinwilligungen für verschiedene KI-Funktionen und Datenzugriffe.

- **4.2.1. Entität: `UserConsent`**
    
    - Repräsentiert die Einwilligung eines Benutzers für ein spezifisches KI-Feature.
    - **Attribute:**
        - `user_id: DomainId` (Identifikator des Benutzers; bei Single-User-Systemen könnte dies ein konstanter Wert sein oder weggelassen werden, hier als `DomainId` für Flexibilität). Sichtbarkeit: `pub`. Invarianten: Nicht leer.
        - `feature_id: String` (Eindeutige ID des KI-Features, z.B. "ai.window_organizer", "ai.smart_reply.email"). Sichtbarkeit: `pub`. Invarianten: Nicht leer.
        - `is_granted: bool` (Status der Einwilligung). Sichtbarkeit: `pub`. Initialwert: `false`.
        - `last_updated_timestamp: u64` (Unix-Timestamp in Millisekunden der letzten Änderung). Sichtbarkeit: `pub(crate)`.
        - `scope: Option<String>` (Optionaler Geltungsbereich, z.B. "application:org.example.Mail", "global"; dient zur Verfeinerung der Einwilligung). Sichtbarkeit: `pub`.
        - `expires_at: Option<u64>` (Optionaler Unix-Timestamp in Millisekunden für den Ablauf der Einwilligung). Sichtbarkeit: `pub`.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub struct UserConsent {
            pub user_id: DomainId,
            pub feature_id: String,
            pub is_granted: bool,
            #[serde(default = "current_timestamp_ms")] // Helferfunktion für Default
            pub(crate) last_updated_timestamp: u64,
            pub scope: Option<String>,
            pub expires_at: Option<u64>,
        }
        
        // Beispiel für eine Helferfunktion für Default-Zeitstempel
        // Diese müsste im Kontext des Moduls verfügbar sein.
        // fn current_timestamp_ms() -> u64 {
        //     std::time::SystemTime::now()
        //        .duration_since(std::time::UNIX_EPOCH)
        //        .unwrap_or_default()
        //        .as_millis() as u64
        // }
        ```
        
- **4.2.2. Service: `ConsentService`**
    
    - Verwaltet den Zustand aller Benutzereinwilligungen. Interagiert mit einem `ConsentPersistencePort` (implementiert von der Kernschicht) zum Laden/Speichern von Einwilligungen. Die Kernschicht könnte zur sicheren Speicherung sensibler Einwilligungsdaten den Freedesktop Secret Service nutzen 33, was über den `ConsentPersistencePort` abstrakt angefordert würde.
    - **Eigenschaften (Interner Zustand):**
        - `consents: std::collections::HashMap<(DomainId, String), UserConsent>` (Schlüssel: `(user_id, feature_id)`).
        - `persistence_port: Box<dyn ConsentPersistencePort>`.
        - `event_publisher: Box<dyn DomainEventPublisher>`.
        - `clock: Box<dyn Clock>` (Für Zeitstempel, injiziert).
    - **Methoden (Öffentliche API):**
        - `pub fn new(persistence_port: Box<dyn ConsentPersistencePort>, event_publisher: Box<dyn DomainEventPublisher>, clock: Box<dyn Clock>, user_id_for_initial_load: &DomainId) -> Self`
            - Konstruktor. Lädt Einwilligungen für den `user_id_for_initial_load` beim Start.
        - `pub fn grant_consent(&mut self, user_id: DomainId, feature_id: String, scope: Option<String>, expires_at: Option<u64>) -> Result<(), AIConsentError>`
            - Erstellt oder aktualisiert eine `UserConsent`-Entität mit `is_granted = true`.
            - Setzt `last_updated_timestamp` auf die aktuelle Zeit.
            - Speichert über `persistence_port`.
            - Emittiert `AIConsentEvent::ConsentGranted { user_id, feature_id, scope, expires_at }`.
        - `pub fn revoke_consent(&mut self, user_id: &DomainId, feature_id: &str) -> Result<(), AIConsentError>`
            - Aktualisiert eine existierende `UserConsent`-Entität auf `is_granted = false`.
            - Setzt `last_updated_timestamp`.
            - Speichert über `persistence_port`.
            - Emittiert `AIConsentEvent::ConsentRevoked { user_id: user_id.clone(), feature_id: feature_id.to_string() }`.
        - `pub fn get_consent_status(&self, user_id: &DomainId, feature_id: &str) -> Result<&UserConsent, AIConsentError>`
            - Gibt die `UserConsent`-Entität zurück. Prüft intern auf Ablauf (`expires_at`). Wenn abgelaufen, wird `is_granted` als `false` interpretiert, auch wenn es `true` gespeichert ist (oder es wird ein `ConsentExpired` Fehler/Event ausgelöst).
            - Gibt `AIConsentError::ConsentNotFound` zurück, wenn keine explizite Einwilligung existiert (impliziert nicht gewährt).
        - `pub fn list_consents_for_user(&self, user_id: &DomainId) -> Vec<&UserConsent>`
            - Listet alle Einwilligungen für einen Benutzer auf.
        - `pub fn list_all_consents(&self) -> Vec<&UserConsent>`
            - Listet alle Einwilligungen im System (z.B. für administrative Zwecke).
        - `pub fn cleanup_expired_consents(&mut self) -> Result<u32, AIConsentError>`
            - Iteriert durch alle Einwilligungen und entfernt abgelaufene Einträge oder markiert sie als ungültig.
            - Gibt die Anzahl der entfernten/aktualisierten Einwilligungen zurück.
            - Emittiert `AIConsentEvent::ConsentExpired` für jede entfernte/aktualisierte Einwilligung.
            - Speichert Änderungen über `persistence_port`.
    - **Signale/Events (als Varianten von `AIConsentEvent` im `DomainEvent` Enum):**
        - `ConsentGranted { user_id: DomainId, feature_id: String, scope: Option<String>, expires_at: Option<u64> }`
        - `ConsentRevoked { user_id: DomainId, feature_id: String }`
        - `ConsentExpired { user_id: DomainId, feature_id: String }`
        - **Typische Publisher:** `ConsentService`.
        - **Typische Subscriber:** `AIFeatureService` (um zu prüfen, ob Features ausgeführt werden dürfen), UI-Schicht (um Einwilligungs-Dialoge und -Statusanzeigen zu aktualisieren).
- **4.2.3. Trait: `ConsentPersistencePort` (von Kernschicht zu implementieren)**
    
    - Definiert die Schnittstelle für die Persistenz von Einwilligungsdaten.
    - `fn load_consents_for_user(&self, user_id: &DomainId) -> Result<Vec<UserConsent>, DomainError>;`
    - `fn save_consent(&self, consent: &UserConsent) -> Result<(), DomainError>;`
    - `fn delete_consent(&self, user_id: &DomainId, feature_id: &str) -> Result<(), DomainError>;`
    - `fn load_all_consents(&self) -> Result<Vec<UserConsent>, DomainError>;` (Für Admin-Zwecke oder globalen Cleanup)
- **4.2.4. Trait: `Clock` (von Kernschicht zu implementieren)**
    
    Rust
    
    ```
    pub trait Clock: Send + Sync {
        fn current_timestamp_ms(&self) -> u64;
    }
    ```
    
- **4.2.5. Fehler-Enum: `AIConsentError`**
    
    - Spezifische Fehler für das `consent_manager`-Modul.
    - **Varianten:**
        - `#[error("Consent for user '{user_id}' and feature '{feature_id}' not found or not granted.")]` `ConsentNotFoundOrNotGranted { user_id: DomainId, feature_id: String }`
        - `#` `FeatureNotKnown { feature_id: String }`
        - `#` `StorageError { message: String }`
        - `#[error("Consent for user '{user_id}' and feature '{feature_id}' has expired.")]` `ConsentExpiredError { user_id: DomainId, feature_id: String }` // Interner Fehler, der zu ConsentNotFoundOrNotGranted führen kann.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum AIConsentError {
            #[error("Consent for user '{user_id}' and feature '{feature_id}' not found or not granted.")]
            ConsentNotFoundOrNotGranted { user_id: DomainId, feature_id: String },
            #
            FeatureNotKnown { feature_id: String },
            #
            StorageError { message: String },
            #[error("Consent for user '{user_id}' and feature '{feature_id}' has expired.")]
            ConsentExpiredError { user_id: DomainId, feature_id: String },
        }
        ```
        

### 4.3. Untermodul: KI-Funktionslogik (`feature_service`)

Dieses Untermodul enthält die Logik zur Ausführung spezifischer KI-Funktionen, nachdem die Einwilligung geprüft wurde.

- **4.3.1. Service: `AIFeatureService`**
    
    - Abhängig vom `ConsentService`, um Berechtigungen zu prüfen.
    - Definiert Schnittstellen für spezifische KI-Funktionen. Die Implementierung dieser Funktionen (d.h. die Interaktion mit den eigentlichen KI-Modellen) erfolgt in der Kernschicht oder einer dedizierten KI-Infrastrukturschicht, die über die Kernschicht angebunden ist. Der `AIFeatureService` orchestriert den Aufruf und verarbeitet die Ergebnisse.
    - **Eigenschaften (Interner Zustand):**
        - `consent_service: Arc<Mutex<ConsentService>>` (oder eine andere Form des geteilten Zugriffs, wenn `ConsentService` nicht `&mut self` für seine Methoden benötigt).
        - `ai_backend_port: Box<dyn AIBackendPort>` (Injizierter Port für die Kommunikation mit der KI-Infrastruktur).
        - `event_publisher: Box<dyn DomainEventPublisher>`.
    - **Methoden (Beispiele, stark abhängig von den konkreten KI-Features):**
        - `pub async fn suggest_window_layout(&self, user_id: &DomainId, current_windows: Vec<WindowHandle>, context: AIRequestContext) -> Result<AISuggestion<WindowLayoutSuggestion>, AIFeatureError>`
            - Prüft `self.consent_service.lock().unwrap().get_consent_status(user_id, "ai.window_organizer")`. Wenn nicht gewährt oder abgelaufen, gibt `AIFeatureError::ConsentNotGranted` zurück.
            - Bereitet die Anfrage für `ai_backend_port.request_window_layout_suggestion(...)` vor.
            - Verarbeitet die Antwort und gibt `AISuggestion` zurück.
            - Emittiert `AIFeatureEvent::SuggestionProvided`.
        - `pub async fn generate_smart_reply(&self, user_id: &DomainId, notification_content: String, context: AIRequestContext) -> Result<AISuggestion<SmartReplySuggestion>, AIFeatureError>`
            - Prüft `self.consent_service.lock().unwrap().get_consent_status(user_id, "ai.smart_reply")`.
            - Bereitet Anfrage für `ai_backend_port.request_smart_reply_suggestion(...)` vor.
            - Emittiert `AIFeatureEvent::SuggestionProvided`.
    - **Signale/Events (als Varianten von `AIFeatureEvent` im `DomainEvent` Enum):**
        - `SuggestionProvided { feature_id: String, user_id: DomainId, suggestion_id: DomainId, suggestion_payload_summary: String }` (Summary statt vollem Payload, um Eventgröße zu begrenzen)
        - `ActionTakenBasedOnAISuggestion { feature_id: String, user_id: DomainId, suggestion_id: DomainId, action_id: String }`
        - **Typische Publisher:** `AIFeatureService`.
        - **Typische Subscriber:** UI-Schicht (um Vorschläge anzuzeigen und Aktionen auszulösen), andere Domänendienste (um Aktionen basierend auf Vorschlägen auszuführen, z.B. `WorkspaceService` für Layout-Änderungen).
- **4.3.2. Trait: `AIBackendPort` (von Kernschicht zu implementieren)**
    
    - Definiert die Schnittstelle zur eigentlichen KI-Modellinteraktion.
    - `async fn request_window_layout_suggestion(&self, windows: Vec<WindowHandle>, context: AIRequestContext) -> Result<WindowLayoutSuggestion, DomainError>;`
    - `async fn request_smart_reply_suggestion(&self, text_to_reply_to: String, context: AIRequestContext) -> Result<SmartReplySuggestion, DomainError>;`
    - Weitere Methoden für andere KI-Features.
- **4.3.3. Datenstrukturen für KI-Anfragen/Antworten**
    
    - `AIRequestContext`: Enthält kontextuelle Daten, die für eine KI-Anfrage relevant sind und für die eine Einwilligung vorliegt.
        - **Attribute:** `source_application_id: Option<String>`, `current_activity_description: Option<String>`, `user_preferences: std::collections::HashMap<String, String>` (z.B. bevorzugte Sprache, Datenschutzeinstellungen für KI), `timestamp_ms: u64`.
        - **Rust-Definition:**
            
            Rust
            
            ```
            #
            pub struct AIRequestContext {
                pub source_application_id: Option<String>,
                pub current_activity_description: Option<String>,
                pub user_preferences: std::collections::HashMap<String, String>,
                pub timestamp_ms: u64,
            }
            ```
            
    - `AISuggestion<T>`: Generische Struktur für KI-Vorschläge.
        - **Attribute:** `suggestion_id: DomainId`, `feature_id: String`, `confidence_score: Option<f32>` (Wert zwischen 0.0 und 1.0), `payload: T`, `explanation: Option<String>`, `feedback_token: Option<String>` (Für implizites/explizites Feedback).
        - **Rust-Definition:**
            
            Rust
            
            ```
            #
            pub struct AISuggestion<T> {
                pub suggestion_id: DomainId,
                pub feature_id: String,
                pub confidence_score: Option<f32>,
                pub payload: T,
                pub explanation: Option<String>,
                pub feedback_token: Option<String>, // Token für Feedback-Mechanismen
            }
            ```
            
    - `WindowLayoutSuggestion`: Spezifischer Payload für Layout-Vorschläge.
        - **Attribute:** `suggested_space_id: Option<DomainId>` (Wenn ein spezifischer Space vorgeschlagen wird), `window_placements: Vec<(WindowHandle, SuggestedPlacement)>`.
        - **Rust-Definition:**
            
            Rust
            
            ```
            #
            pub struct WindowLayoutSuggestion {
                pub suggested_space_id: Option<DomainId>,
                pub window_placements: Vec<(WindowHandle, SuggestedPlacement)>,
            }
            ```
            
    - `SuggestedPlacement`: Details zur Platzierung eines Fensters.
        - **Attribute:** `target_space_id: Option<DomainId>` (Falls das Fenster in einen anderen Space verschoben werden soll), `relative_x: f32`, `relative_y: f32`, `relative_width: f32`, `relative_height: f32` (Werte zwischen 0.0 und 1.0, relativ zur Space-Größe), `stacking_order: Option<u32>`.
        - **Rust-Definition:**
            
            Rust
            
            ```
            #
            pub struct SuggestedPlacement {
                pub target_space_id: Option<DomainId>, // Wenn None, aktueller Space des Fensters
                pub relative_x: f32, // 0.0 bis 1.0
                pub relative_y: f32, // 0.0 bis 1.0
                pub relative_width: f32, // 0.0 bis 1.0
                pub relative_height: f32, // 0.0 bis 1.0
                pub stacking_order: Option<u32>, // z-Index
            }
            ```
            
    - `SmartReplySuggestion`: Spezifischer Payload für Antwortvorschläge.
        - **Attribute:** `suggested_replies: Vec<String>`.
        - **Rust-Definition:**
            
            Rust
            
            ```
            #
            pub struct SmartReplySuggestion {
                pub suggested_replies: Vec<String>,
            }
            ```
            
    - Alle diese Strukturen implementieren `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`.
- **4.3.4. Fehler-Enum: `AIFeatureError`**
    
    - Spezifische Fehler für das `feature_service`-Modul.
    - **Varianten:**
        - `#[error("Consent not granted for user '{user_id}' and feature '{feature_id}'.")]` `ConsentNotGranted { user_id: DomainId, feature_id: String }` (Kann `#[from] AIConsentError` nutzen)
        - `#[error("Error interacting with AI model/backend: {message}")]` `ModelInteractionError { message: String }` (Typischerweise von `AIBackendPort` propagiert)
        - `#[error("Invalid or insufficient context provided for AI feature '{feature_id}': {reason}")]` `InvalidContext { feature_id: String, reason: String }`
        - `#[error("No suggestion available for feature '{feature_id}' with the given context.")]` `SuggestionNotAvailable { feature_id: String }`
        - `#` `BackendPortError(String)` // Generischer Fehler vom Port
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum AIFeatureError {
            #[error("Consent not granted for user '{user_id}' and feature '{feature_id}'.")]
            ConsentNotGranted { user_id: DomainId, feature_id: String },
            #[error("Error interacting with AI model/backend: {message}")]
            ModelInteractionError { message: String },
            #[error("Invalid or insufficient context provided for AI feature '{feature_id}': {reason}")]
            InvalidContext { feature_id: String, reason: String },
            #[error("No suggestion available for feature '{feature_id}' with the given context.")]
            SuggestionNotAvailable { feature_id: String },
            #
            BackendPortError(String),
        }
        
        // Mögliche Konvertierung von AIConsentError
        impl From<AIConsentError> for AIFeatureError {
            fn from(err: AIConsentError) -> Self {
                match err {
                    AIConsentError::ConsentNotFoundOrNotGranted { user_id, feature_id } => {
                        AIFeatureError::ConsentNotGranted { user_id, feature_id }
                    }
                    // Andere Mappings oder ein generischer Fehler
                    _ => AIFeatureError::ModelInteractionError {
                        message: format!("Consent error: {}", err),
                    },
                }
            }
        }
        ```
        

### 4.4. Geschäftsregeln

- **Strikte Einwilligungsprüfung:** Vor jeder Ausführung einer KI-Funktion oder jedem Zugriff auf potenziell sensible Daten durch eine KI-Funktion _muss_ eine gültige, nicht abgelaufene Einwilligung des Benutzers für das spezifische Feature und den spezifischen Datenumfang vorliegen. Dies wird durch den `AIFeatureService` sichergestellt, der den `ConsentService` konsultiert.
- **Datenminimierung und -relevanz:** An KI-Modelle (über den `AIBackendPort`) werden nur die Daten gesendet, die für die jeweilige Funktion unbedingt notwendig sind und für die eine Einwilligung vorliegt. Die Domänenschicht definiert die Struktur dieser Daten (`AIRequestContext`).
- **Anonymisierung/Pseudonymisierung:** Falls von der Kernschicht (Implementierung des `AIBackendPort`) unterstützt, kann die Domänenschicht anfordern, dass Daten vor der Übermittlung an externe KI-Dienste anonymisiert oder pseudonymisiert werden. Die Domänenschicht selbst führt diese Operationen nicht durch, sondern spezifiziert die Notwendigkeit.
- **Fallback-Verhalten:** Wenn KI-Dienste nicht verfügbar sind (Fehler vom `AIBackendPort`) oder keine sinnvollen Vorschläge liefern (`SuggestionNotAvailable`), muss die Anwendung ein definiertes Fallback-Verhalten zeigen (z.B. Standardfunktionalität ohne KI anbieten, Fehlermeldung anzeigen). Dies wird vom Aufrufer des `AIFeatureService` gehandhabt.
- **Transparenz:** Dem Benutzer sollte (über die UI-Schicht) nachvollziehbar gemacht werden, wann und warum eine KI-Funktion aktiv wird und welche Daten dafür verwendet wurden (z.B. durch `AISuggestion::explanation`).

Die Tabellen fassen die Kernkomponenten des KI-Managements zusammen:

**Tabelle 4.2.1: Entität `UserConsent` - Attribute**

|   |   |   |   |
|---|---|---|---|
|**Attribut**|**Typ**|**Sichtbarkeit**|**Invarianten/Initialwert**|
|`user_id`|`DomainId`|`pub`|Nicht leer|
|`feature_id`|`String`|`pub`|Nicht leer|
|`is_granted`|`bool`|`pub`|Initial `false`|
|`last_updated_timestamp`|`u64`|`pub(crate)`|Aktueller Zeitstempel|
|`scope`|`Option<String>`|`pub`||
|`expires_at`|`Option<u64>`|`pub`||

**Tabelle 4.2.2: `ConsentService` - Öffentliche API (Auswahl)**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp**|**Kurzbeschreibung**|
|`grant_consent`|`user_id: DomainId`, `feature_id: String`, `scope: Option<String>`, `expires_at: Option<u64>`|`Result<(), AIConsentError>`|Erteilt eine Einwilligung.|
|`revoke_consent`|`user_id: &DomainId`, `feature_id: &str`|`Result<(), AIConsentError>`|Widerruft eine Einwilligung.|
|`get_consent_status`|`user_id: &DomainId`, `feature_id: &str`|`Result<&UserConsent, AIConsentError>`|Prüft den aktuellen Einwilligungsstatus.|
|`list_consents_for_user`|`user_id: &DomainId`|`Vec<&UserConsent>`|Listet alle Einwilligungen eines Benutzers.|

**Tabelle 4.3.1: `AIFeatureService` - Beispielhafte Öffentliche API**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter**|**Rückgabetyp**|**Kurzbeschreibung**|
|`suggest_window_layout`|`user_id: &DomainId`, `windows: Vec<WindowHandle>`, `context: AIRequestContext`|`Result<AISuggestion<WindowLayoutSuggestion>, AIFeatureError>`|Schlägt ein Fensterlayout vor.|
|`generate_smart_reply`|`user_id: &DomainId`, `notification_content: String`, `context: AIRequestContext`|`Result<AISuggestion<SmartReplySuggestion>, AIFeatureError>`|Generiert Antwortvorschläge.|

---

## 5. Modul: Benachrichtigungsverwaltung (`notification_manager`)

### 5.1. Übersicht und Verantwortlichkeiten

Das `notification_manager`-Modul ist für die Entgegennahme, Verwaltung und (logische) Anzeige von Benachrichtigungen zuständig, die von Anwendungen und Systemkomponenten stammen. Es unterstützt interaktive Aktionen innerhalb von Benachrichtigungen, ermöglicht deren Priorisierung und Deduplizierung und stellt eine Historie vergangener Benachrichtigungen bereit.

Die Domänenschicht definiert hierbei die _Struktur_ und die _Logik_ von Benachrichtigungen. Die tatsächliche visuelle Darstellung, beispielsweise als Pop-up-Fenster oder Eintrag in einer Benachrichtigungszentrale, ist Aufgabe der UI-Schicht. Die Notification API des XDG Desktop Portals 35 dient als gute Inspiration für die Definition der Felder einer Benachrichtigung, wie ID, Titel, Textkörper, Priorität und mögliche Aktionen. Die Domänenschicht verwaltet Benachrichtigungen als Datenobjekte. Essentielle Felder sind `title`, `body` und `priority`. Darüber hinaus sind `application_name` (als Quelle der Benachrichtigung) und `actions` (zur Ermöglichung von Interaktivität) wichtig. Die UI-Schicht konsumiert diese Datenobjekte und erzeugt daraus die entsprechende visuelle Repräsentation.

### 5.2. Entitäten, Wertobjekte und Enums

- **5.2.1. Entität: `Notification`**
    
    - Repräsentiert eine einzelne Benachrichtigung.
    - **Attribute:**
        - `id: DomainId` (Eindeutige ID der Benachrichtigung, z.B. generiert via `uuid::Uuid::new_v4().to_string()`). Sichtbarkeit: `pub`. Invarianten: Eindeutig, nicht leer.
        - `application_name: String` (Name der sendenden Anwendung/Komponente). Sichtbarkeit: `pub`. Invarianten: Nicht leer.
        - `application_icon: Option<String>` (Name oder Pfad zu einem Icon, das von der UI-Schicht interpretiert wird). Sichtbarkeit: `pub`.
        - `summary: String` (Titel/Zusammenfassung der Benachrichtigung). Sichtbarkeit: `pub`. Invarianten: Nicht leer.
        - `body: Option<String>` (Detaillierter Text der Benachrichtigung). Sichtbarkeit: `pub`.
        - `actions: Vec<NotificationAction>` (Liste möglicher Aktionen, die der Benutzer ausführen kann). Sichtbarkeit: `pub`.
        - `urgency: NotificationUrgency` (Dringlichkeit der Benachrichtigung). Sichtbarkeit: `pub`. Initialwert: `NotificationUrgency::Normal`.
        - `category: Option<String>` (Kategorie zur Filterung/Gruppierung, z.B. "email.new", "chat.message", "system.update.available"). Sichtbarkeit: `pub`.
        - `timestamp_ms: u64` (Unix-Timestamp in Millisekunden der Erstellung). Sichtbarkeit: `pub(crate)`.
        - `expires_timeout_ms: Option<u32>` (Zeit in Millisekunden, nach der die Benachrichtigung automatisch geschlossen wird; `0` oder `None` bedeutet, sie läuft nicht automatisch ab). Sichtbarkeit: `pub`.
        - `is_persistent: bool` (Ob die Benachrichtigung in der Historie verbleibt, auch nachdem sie geschlossen wurde). Sichtbarkeit: `pub`. Initialwert: `true`.
        - `resident: bool` (Ob die Benachrichtigung permanent sichtbar bleiben soll, bis sie explizit geschlossen wird – ähnlich "sticky" Notifications; Freedesktop-Spezifikation "resident"). Sichtbarkeit: `pub`. Initialwert: `false`.
        - `transient: bool` (Ob die Benachrichtigung nur kurz angezeigt und nicht in der Historie gespeichert werden soll, auch wenn `is_persistent` true wäre; Freedesktop-Spezifikation "transient"). Sichtbarkeit: `pub`. Initialwert: `false`.
        - `custom_data: std::collections::HashMap<String, String>` (Für anwendungsspezifische Daten, die von der sendenden Anwendung mitgegeben werden können). Sichtbarkeit: `pub`.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub struct Notification {
            pub id: DomainId,
            pub application_name: String,
            pub application_icon: Option<String>,
            pub summary: String,
            pub body: Option<String>,
            pub actions: Vec<NotificationAction>,
            pub urgency: NotificationUrgency,
            pub category: Option<String>,
            #[serde(default = "crate::ai_manager::consent_manager::current_timestamp_ms")] // Wiederverwendung der Helferfunktion
            pub(crate) timestamp_ms: u64,
            pub expires_timeout_ms: Option<u32>,
            #[serde(default = "default_true")]
            pub is_persistent: bool,
            #[serde(default)]
            pub resident: bool,
            #[serde(default)]
            pub transient: bool,
            #[serde(default)]
            pub custom_data: std::collections::HashMap<String, String>,
        }
        
        fn default_true() -> bool { true }
        // fn current_timestamp_ms() -> u64 {... } // Siehe oben
        ```
        
- **5.2.2. Wertobjekt: `NotificationAction`**
    
    - Definiert eine Aktion, die im Kontext einer Benachrichtigung ausgeführt werden kann.
    - **Attribute:**
        - `key: String` (Eindeutiger Schlüssel für die Aktion innerhalb der Benachrichtigung, z.B. "reply", "archive", "mark-as-read"). Sichtbarkeit: `pub`. Invarianten: Nicht leer.
        - `label: String` (Anzeigetext für den Button in der UI). Sichtbarkeit: `pub`. Invarianten: Nicht leer.
    - **Implementiert:** `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`, `PartialEq`, `Eq`.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub struct NotificationAction {
            pub key: String,
            pub label: String,
        }
        ```
        
- **5.2.3. Enum: `NotificationUrgency`**
    
    - Definiert die Dringlichkeitsstufe einer Benachrichtigung, inspiriert von der Freedesktop Notification Specification.
    - **Varianten:** `Low`, `Normal`, `Critical`.
    - **Implementiert:** `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`, `PartialEq`, `Eq`, `Default` (`Normal`).
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum NotificationUrgency {
            Low,
            #[default]
            Normal,
            Critical,
        }
        ```
        
- **5.2.4. Fehler-Enum: `NotificationError`**
    
    - Spezifische Fehler für das `notification_manager`-Modul. Definiert mit `thiserror`.
    - **Varianten:**
        - `#` `NotificationNotFound { notification_id: DomainId }`
        - `#[error("Action with key '{action_key}' not found for notification '{notification_id}'.")]` `ActionNotFound { notification_id: DomainId, action_key: String }`
        - `#[error("Invalid notification data provided: {reason}")]` `InvalidNotificationData { reason: String }`
        - `#[error("Notification history is full. Maximum size: {max_size}.")]` `HistoryFull { max_size: usize }`
        - `#[error("Maximum number of active notifications reached: {max_active}.")]` `MaxActiveNotificationsReached { max_active: usize }`
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum NotificationError {
            #
            NotificationNotFound { notification_id: DomainId },
            #[error("Action with key '{action_key}' not found for notification '{notification_id}'.")]
            ActionNotFound { notification_id: DomainId, action_key: String },
            #[error("Invalid notification data provided: {reason}")]
            InvalidNotificationData { reason: String },
            #[error("Notification history is full. Maximum size: {max_size}.")]
            HistoryFull { max_size: usize },
            #[error("Maximum number of active notifications reached: {max_active}.")]
            MaxActiveNotificationsReached { max_active: usize },
        }
        ```
        

### 5.3. Service: `NotificationService`

Der `NotificationService` hält den Zustand aller aktiven und ggf. historischen Benachrichtigungen und stellt Methoden zu deren Verwaltung bereit.

- **5.3.1. Eigenschaften (Interner Zustand)**
    
    - `active_notifications: std::collections::VecDeque<Notification>`: Eine Queue für aktive, potenziell sichtbare Benachrichtigungen. `VecDeque` ermöglicht effizientes FIFO-Verhalten, wenn `max_active_notifications` erreicht ist.
    - `notification_history: std::collections::VecDeque<Notification>`: Eine Queue für die Historie geschlossener, persistenter Benachrichtigungen, begrenzt durch `max_history_size`.
    - `next_internal_id_counter: u64`: Ein interner Zähler zur Generierung sequenzieller Teile von IDs, falls UUIDs nicht allein verwendet werden oder zur Deduplizierung.
    - `max_active_notifications: usize`: Konfigurierbare maximale Anzahl aktiver Benachrichtigungen (z.B. Default 5).
    - `max_history_size: usize`: Konfigurierbare maximale Größe der Historie (z.B. Default 100).
    - `persistence_port: Box<dyn NotificationPersistencePort>`: Injizierter Port für Persistenz der Historie.
    - `event_publisher: Box<dyn DomainEventPublisher>`.
    - `clock: Box<dyn crate::ai_manager::consent_manager::Clock>`. // Wiederverwendung des Clock-Traits
- **5.3.2. Methoden (Öffentliche API)**
    
    - `pub fn new(max_active: usize, max_history: usize, persistence_port: Box<dyn NotificationPersistencePort>, event_publisher: Box<dyn DomainEventPublisher>, clock: Box<dyn crate::ai_manager::consent_manager::Clock>) -> Self`
        - Konstruktor. Lädt ggf. die Historie über den `persistence_port`.
    - `pub fn post_notification(&mut self, app_name: String, app_icon: Option<String>, summary: String, body: Option<String>, actions: Vec<NotificationAction>, urgency: NotificationUrgency, category: Option<String>, expires_ms: Option<u32>, persistent: bool, resident: bool, transient: bool, custom_data: std::collections::HashMap<String, String>) -> Result<DomainId, NotificationError>`
        - **Validierung:** Prüft, ob `app_name` und `summary` nicht leer sind (`NotificationError::InvalidNotificationData`).
        - **ID-Generierung:** Erzeugt eine eindeutige `DomainId` (z.B. `uuid::Uuid::new_v4().to_string()`).
        - **Timestamp:** Setzt `timestamp_ms` mittels `self.clock.current_timestamp_ms()`.
        - **Erstellung:** Erstellt das `Notification`-Objekt.
        - **Deduplizierung (Optional):** Implementiert Logik, um Duplikate zu erkennen und ggf. zu ersetzen oder zu ignorieren. (Für diese Spezifikation vorerst nicht detailliert).
        - **Aktive Liste:** Wenn `active_notifications.len() >= self.max_active_notifications`, wird die älteste Benachrichtigung entfernt (und ggf. in die Historie verschoben, falls `is_persistent` und nicht `transient`).
        - Fügt die neue Benachrichtigung zu `active_notifications` hinzu.
        - **Emittiert:** `NotificationEvent::NotificationPosted { notification: new_notification.clone() }`.
        - **Rückgabe:** Die ID der neuen Benachrichtigung.
    - `pub fn close_notification(&mut self, notification_id: &DomainId, reason: NotificationCloseReason) -> Result<(), NotificationError>`
        - Sucht die Benachrichtigung in `active_notifications`. Wenn nicht gefunden, `NotificationError::NotificationNotFound`.
        - Entfernt die Benachrichtigung aus `active_notifications`.
        - **Historie:** Wenn die Benachrichtigung `is_persistent` ist und nicht `transient`, wird sie zu `notification_history` hinzugefügt. Wenn `notification_history.len() >= self.max_history_size`, wird die älteste Benachrichtigung aus der Historie entfernt.
        - **Persistenz:** Speichert die aktualisierte Historie über `persistence_port.save_history()`.
        - **Emittiert:** `NotificationEvent::NotificationClosed { notification_id: notification_id.clone(), reason }`.
    - `pub fn trigger_action(&mut self, notification_id: &DomainId, action_key: &str) -> Result<(), NotificationError>`
        - Sucht die Benachrichtigung in `active_notifications`. Wenn nicht gefunden, `NotificationError::NotificationNotFound`.
        - Sucht die Aktion mit `action_key` in `notification.actions`. Wenn nicht gefunden, `NotificationError::ActionNotFound`.
        - **Emittiert:** `NotificationEvent::NotificationActionTriggered { notification_id: notification_id.clone(), action_key: action_key.to_string() }`.
        - Schließt typischerweise die Benachrichtigung danach: `self.close_notification(notification_id, NotificationCloseReason::ActionTaken)?`.
    - `pub fn get_active_notifications(&self) -> Vec<&Notification>`
        - Gibt eine Kopie der aktiven Benachrichtigungen als Slice oder Vec von Referenzen zurück.
    - `pub fn get_notification_history(&self) -> Vec<&Notification>`
        - Gibt eine Kopie der Benachrichtigungshistorie zurück.
    - `pub fn clear_history(&mut self) -> Result<(), NotificationError>`
        - Leert `notification_history`.
        - Speichert die leere Historie über `persistence_port.save_history()`.
        - **Emittiert:** `NotificationEvent::NotificationHistoryCleared`.
    - `pub fn get_notification_by_id(&self, notification_id: &DomainId) -> Option<&Notification>`
        - Sucht eine Benachrichtigung zuerst in `active_notifications`, dann in `notification_history`.
- **5.3.3. Signale/Events (als Varianten von `NotificationEvent` im `DomainEvent` Enum)**
    
    - `NotificationPosted { notification: Notification }`
    - `NotificationClosed { notification_id: DomainId, reason: NotificationCloseReason }`
    - `NotificationActionTriggered { notification_id: DomainId, action_key: String }`
    - `NotificationHistoryCleared`
    - `NotificationUpdated { notification: Notification }` (Falls Benachrichtigungen nach dem Posten noch modifizierbar sein sollen, z.B. Fortschrittsbalken. Für diese Spezifikation vorerst nicht im Fokus.)
    - **Typische Publisher:** `NotificationService`.
    - **Typische Subscriber:** UI-Schicht (zur Anzeige/Aktualisierung von Benachrichtigungen und der Historie), `AIFeatureService` (z.B. um auf neue Benachrichtigungen zu reagieren und Smart Replies vorzuschlagen).
- **5.3.4. Enum: `NotificationCloseReason`**
    
    - Gibt den Grund an, warum eine Benachrichtigung geschlossen wurde.
    - **Varianten:** `Expired` (Timeout erreicht), `DismissedByUser` (Benutzer hat sie aktiv geschlossen), `ActionTaken` (Eine Aktion wurde ausgeführt), `ProgrammaticallyClosed` (Durch die Anwendung/System geschlossen), `SourceClosed` (Die sendende Anwendung hat das Schließen angefordert).
    - **Implementiert:** `serde::Serialize`, `serde::Deserialize`, `Debug`, `Clone`, `PartialEq`, `Eq`.
    - **Rust-Definition:**
        
        Rust
        
        ```
        #
        pub enum NotificationCloseReason {
            Expired,
            DismissedByUser,
            ActionTaken,
            ProgrammaticallyClosed,
            SourceClosed, // z.B. wenn die App die Notification zurückzieht
        }
        ```
        
- **5.3.5. Trait: `NotificationPersistencePort` (von Kernschicht zu implementieren)**
    
    - `fn load_history(&self) -> Result<Vec<Notification>, DomainError>;`
    - `fn save_history(&self, history: &std::collections::VecDeque<Notification>) -> Result<(), DomainError>;`

### 5.4. Geschäftsregeln

- **Priorisierung:** Kritische Benachrichtigungen (`NotificationUrgency::Critical`) könnten an der Spitze der `active_notifications`-Queue eingefügt werden oder andere weniger wichtige Benachrichtigungen verdrängen, falls `max_active_notifications` erreicht ist. Normale und niedrige Dringlichkeiten werden am Ende der Queue hinzugefügt.
- **Deduplizierung:** (Optional, für spätere Erweiterung) Regeln, um identische oder sehr ähnliche Benachrichtigungen (z.B. gleicher `application_name`, `summary` und `category` innerhalb eines kurzen Zeitfensters) zusammenzufassen oder zu unterdrücken. Dies könnte durch einen Hash über relevante Felder oder eine "replaces_id"-Mechanik implementiert werden.
- **Maximale Anzahl aktiver Benachrichtigungen:** Wenn `max_active_notifications` überschritten wird, wird die älteste nicht-residente Benachrichtigung geschlossen (Grund: `ProgrammaticallyClosed`) und ggf. in die Historie verschoben.
- **Maximale Größe der Historie:** Wenn `max_history_size` beim Hinzufügen einer Benachrichtigung zur Historie überschritten wird, wird der älteste Eintrag aus der Historie entfernt.
- **Verhalten bei `expires_timeout_ms`:** Ein Mechanismus (z.B. ein Timer-Service in der Kernschicht, der vom `NotificationService` über den `event_publisher` oder einen dedizierten Port gesteuert wird) muss dafür sorgen, dass Benachrichtigungen mit `expires_timeout_ms` nach Ablauf der Zeit mit `NotificationCloseReason::Expired` geschlossen werden. Die Domänenschicht selbst verwaltet keine aktiven Timer.
- **`transient` vs. `is_persistent`:** Eine als `transient` markierte Benachrichtigung wird niemals in die Historie aufgenommen, unabhängig vom Wert von `is_persistent`.

Die folgenden Tabellen bieten eine Übersicht über die `Notification`-Entität und die API des `NotificationService`.

**Tabelle 5.2.1: Entität `Notification` - Attribute**

|   |   |   |   |
|---|---|---|---|
|**Attribut**|**Typ**|**Sichtbarkeit**|**Invarianten/Initialwert (Beispiel)**|
|`id`|`DomainId`|`pub`|Eindeutig, nicht leer|
|`application_name`|`String`|`pub`|Nicht leer|
|`application_icon`|`Option<String>`|`pub`||
|`summary`|`String`|`pub`|Nicht leer|
|`body`|`Option<String>`|`pub`||
|`actions`|`Vec<NotificationAction>`|`pub`||
|`urgency`|`NotificationUrgency`|`pub`|`Normal`|
|`category`|`Option<String>`|`pub`||
|`timestamp_ms`|`u64`|`pub(crate)`|Zeitstempel bei Erstellung|
|`expires_timeout_ms`|`Option<u32>`|`pub`|`None` (läuft nicht ab)|
|`is_persistent`|`bool`|`pub`|`true`|
|`resident`|`bool`|`pub`|`false`|
|`transient`|`bool`|`pub`|`false`|
|`custom_data`|`std::collections::HashMap<String, String>`|`pub`|Leer|

**Tabelle 5.3.2: `NotificationService` - Öffentliche API (Auswahl)**

|   |   |   |   |
|---|---|---|---|
|**Methode**|**Parameter (Auszug)**|**Rückgabetyp**|**Kurzbeschreibung**|
|`post_notification`|`app_name: String`, `summary: String`, `urgency: NotificationUrgency`,...|`Result<DomainId, NotificationError>`|Postet eine neue Benachrichtigung.|
|`close_notification`|`notification_id: &DomainId`, `reason: NotificationCloseReason`|`Result<(), NotificationError>`|Schließt eine aktive Benachrichtigung.|
|`trigger_action`|`notification_id: &DomainId`, `action_key: &str`|`Result<(), NotificationError>`|Löst eine Aktion einer Benachrichtigung aus.|
|`get_active_notifications`||`Vec<&Notification>`|Ruft alle aktiven Benachrichtigungen ab.|
|`get_notification_history`||`Vec<&Notification>`|Ruft die Historie der Benachrichtigungen ab.|
|`clear_history`||`Result<(), NotificationError>`|Leert die Benachrichtigungshistorie.|

---

## 6. Modul: Fenstermanagement-Richtlinien (`window_policy_engine`)

### 6.1. Übersicht und Verantwortlichkeiten

Das Modul `window_policy_engine` ist dafür zuständig, Regeln für das Verhalten von Fenstern zu definieren und anzuwenden. Diese Regeln können beispielsweise die automatische Zuweisung von Fenstern zu bestimmten Spaces, Standard-Tiling-Verhalten für spezifische Anwendungen oder andere Aspekte des Fensterverhaltens umfassen. Dieses Modul entkoppelt spezifische Fensterverwaltungsentscheidungen von der allgemeinen Workspace-Verwaltung im `WorkspaceManager`. Es reagiert auf Domänenereignisse wie "Fenster geöffnet" (signalisiert von der Systemschicht über die Kernschicht und dann als Domänenereignis weitergeleitet) oder "Space gewechselt".

Die Verwendung eines solchen Policy-Engines ermöglicht eine hohe Anpassbarkeit des Fenstermanagements, ohne die Kernlogik des `WorkspaceManager` zu verändern. Die Regeln werden als Datenstrukturen repräsentiert und können potenziell zur Laufzeit modifiziert werden (z.B. durch Benutzereingaben in einer Konfigurations-UI). Inspiration für die Definition von Fenstereigenschaften und -zuständen kann von Wayland-Protokollen wie `wlr-foreign-toplevel-management-unstable-v1` 36 oder `xdg-shell` und dessen Erweiterungen (z.B. `xdg-decoration` 40) abgeleitet werden. Konzepte wie `app_id`, `title`, `maximized`, `minimized`, `fullscreen` werden von der Domänenschicht jedoch abstrakt implementiert, ohne direkte Abhängigkeiten zu diesen Protokollen. Die Domänenschicht definiert, welche Informationen sie über ein Fenster benötigt (`WindowStateContext`), und die Systemschicht ist verantwortlich, diese Informationen aus dem jeweiligen Fenstersystem (Wayland, X11) zu extrahieren und bereitzustellen. Die Aktionen, die aus den Regeln resultieren (z.


# Kerninfrastruktur Implementierungsplan (Ultra-Feinspezifikation)

## 1. Einleitung

Dieses Dokument stellt den finalen, lückenlosen Entwickler-Implementierungsleitfaden für die Kerninfrastrukturschicht (Core Layer) dar. Es ist als Ultra-Feinspezifikation konzipiert und enthält alle notwendigen Details, um Entwicklern die direkte Implementierung in Rust zu ermöglichen, ohne dass eigene Architekturentscheidungen, Logikentwürfe oder Algorithmen erforderlich sind. Alle relevanten Aspekte wurden recherchiert, entschieden und präzise spezifiziert.

Die Kerninfrastruktur (`core_infra`) bildet das Fundament des Systems. Ihre Hauptverantwortlichkeiten umfassen die Bereitstellung grundlegendster Datentypen, Dienstprogramme, der Konfigurationsgrundlagen, der Logging-Infrastruktur und allgemeiner Fehlerdefinitionen. Diese Schicht dient als Basis für alle anderen Schichten des Systems und weist selbst keine Abhängigkeiten zu diesen höheren Schichten auf. Ihre Funktionalität wird von allen übergeordneten Schichten genutzt. Die Implementierung folgt strikt den Rust API Guidelines 1 und Best Practices für sichere und wartbare Rust-Entwicklung.3

## 2. Allgemeine Designprinzipien und Konventionen

### 2.1. Programmiersprache und Tooling

- **Sprache:** Rust (aktuellste stabile Version, Mindestanforderung gemäß Abschnitt 10.1).
- **Build-System:** Cargo (Standard Rust Build-System und Paketmanager).5
- **Formatierung:** `rustfmt` mit Standardkonfiguration (100 Zeichen Zeilenbreite, 4 Leerzeichen Einrückung).3
- **Linting:** `clippy` mit Standardempfehlungen (`cargo clippy`).

### 2.2. Code-Stil und Namenskonventionen

- Strikte Einhaltung der offiziellen Rust API Guidelines.1
- **Casing:** `snake_case` für Funktionen, Methoden, Variablen, Module; `PascalCase` für Typen (Structs, Enums, Traits).1
- **Konvertierungen:** `as_` für günstige Referenz-zu-Referenz-Konvertierungen, `to_` für teurere Wert-zu-Wert-Konvertierungen, `into_` für übernehmende Konvertierungen.1
- **Getter:** Namen folgen der Konvention `field_name()` für einfachen Zugriff, `set_field_name()` für Setter (falls mutability erlaubt ist).1
- **Iteratoren:** Methoden liefern `iter()`, `iter_mut()`, `into_iter()`; Iterator-Typen heißen entsprechend (z.B. `MyTypeIter`).1
- **Modulstruktur:** Klar definierte Module gemäß Abschnitt 10.5.

### 2.3. Fehlerbehandlung

- Keine Panics für erwartbare Fehler; stattdessen `Result<T, CoreError>` verwenden.6
- Vermeidung von `.unwrap()` und `.expect()`; Nutzung des `?`-Operators zur Fehlerpropagation.1
- Definition einer zentralen `CoreError`-Enum mit `thiserror` für die gesamte Schicht.6
- Fehlermeldungen müssen klar, kontextbezogen und informativ sein.

### 2.4. Sicherheit

- **Kein `unsafe` Code:** Die Verwendung von `unsafe`-Blöcken ist in dieser Schicht strikt untersagt, um die von Rust garantierte Speichersicherheit zu gewährleisten.4
- **Input Validierung:** Obwohl die Kernschicht primär interne Dienste bereitstellt, müssen alle von außen kommenden Konfigurationsdaten oder Parameter validiert werden (C-VALIDATE 1).
- **Dependency Management:** Abhängigkeiten werden minimal gehalten und regelmäßig auf Sicherheitsupdates überprüft.4

### 2.5. Dokumentation

- Alle öffentlichen Elemente (Module, Typen, Funktionen, Methoden) MÜSSEN mit ausführlichen Rustdoc-Kommentaren (`///`) versehen sein.1
- Dokumentation umfasst Zweck, Parameter, Rückgabewerte, mögliche Fehler (`CoreError`-Varianten) und Beispiele (C-EXAMPLE 1).
- Fehler- und Panikbedingungen (obwohl Panics vermieden werden sollen) müssen dokumentiert werden (C-FAILURE 1).

## 3. Kern-Datentypen (`core_infra::types`)

Dieses Modul definiert grundlegende Datenstrukturen (Structs und Enums), die potenziell von mehreren anderen Modulen innerhalb oder außerhalb der Kernschicht verwendet werden könnten. Es enthält keine komplexe Logik, sondern nur die Definitionen selbst.

### 3.1. Modulstruktur

```
core_infra/
└── src/
    ├── lib.rs
    └── types.rs
```

### 3.2. Grundlegende Wertobjekte und Structs

Wertobjekte sind einfache Strukturen, die hauptsächlich Daten kapseln und deren Identität durch ihre Werte definiert wird. Sie sollten unveränderlich sein, nachdem sie erstellt wurden, was durch private Felder und Konstruktoren, die Validierungen durchführen, sichergestellt wird.

- **Beispiel:** `AppIdentifier` (falls eine spezifische ID-Struktur benötigt wird)
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use std::fmt;
    
    /// Represents a unique identifier for an application component or instance.
    /// Enforces specific formatting rules through its constructor.
    #
    pub struct AppIdentifier(String); // Internal representation is a String
    
    impl AppIdentifier {
        /// Creates a new AppIdentifier from a string slice.
        ///
        /// # Arguments
        /// * `value` - The string representation of the identifier. Must not be empty
        ///           and should adhere to specific format rules (e.g., alphanumeric).
        ///
        /// # Errors
        /// Returns `CoreError::InvalidInput` if the value is empty or does not meet
        /// the required format.
        pub fn new(value: &str) -> Result<Self, crate::error::CoreError> {
            if value.is_empty() {
                Err(crate::error::CoreError::InvalidInput("AppIdentifier cannot be empty".to_string()))
            } else if!value.chars().all(|c| c.is_alphanumeric() |
    ```
    

| c == '-') {

Err(crate::error::CoreError::InvalidInput(format!("AppIdentifier contains invalid characters: {}", value)))

}

else {

Ok(Self(value.to_string()))

}

}

````
    /// Returns a reference to the underlying string value.
    /// Conforms to Rust API guidelines for getters (C-GETTER [1]).
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Allows displaying the AppIdentifier.
impl fmt::Display for AppIdentifier {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Allows conversion from AppIdentifier to String.
impl From<AppIdentifier> for String {
    fn from(id: AppIdentifier) -> Self {
        id.0
    }
}

/// Allows borrowing as a string slice.
/// Conforms to Rust API guidelines for conversions (C-CONV-TRAITS [1]).
impl AsRef<str> for AppIdentifier {
    fn as_ref(&self) -> &str {
        &self.0
    }
}
```
````

- **Spezifikation:**
    - Alle Wertobjekte müssen `Debug`, `Clone`, `PartialEq`, `Eq`, `Hash` implementieren (C-COMMON-TRAITS 1).
    - Falls sie in Konfigurationen oder Logs serialisiert werden sollen, müssen sie `serde::Serialize` und `serde::Deserialize` implementieren.8
    - Felder müssen privat sein, um Invarianten zu schützen (C-STRUCT-PRIVATE 1).
    - Öffentliche Konstruktoren (`fn new(...) -> Result<Self, CoreError>`) validieren Eingaben und erzwingen Invarianten (C-CTOR 1, C-VALIDATE 1).
    - Getter-Methoden (`fn field_name(&self) -> &T`) bieten Lesezugriff.
    - Implementierung relevanter Traits wie `Display`, `From`, `AsRef` (C-CONV-TRAITS 1).

### 3.3. Fundamentale Enums

Definition einfacher Enums für Zustände oder Kategorien, die systemweit relevant sein könnten.

- **Beispiel:** `Status`
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Represents a general status indicator.
    #
    pub enum Status {
        Enabled,
        Disabled,
        Pending,
        Error(i32), // Example with associated data
    }
    
    impl Status {
        /// Checks if the status indicates an active or ready state.
        pub fn is_active(&self) -> bool {
            matches!(self, Status::Enabled)
        }
    }
    ```
    
- **Spezifikation:**
    - Müssen `Debug`, `Clone`, `Copy` (wenn sinnvoll), `PartialEq`, `Eq`, `Hash` implementieren (C-COMMON-TRAITS 1).
    - Falls für Konfiguration/Logs benötigt, `serde::Serialize` und `serde::Deserialize` implementieren.8
    - Varianten klar dokumentieren.
    - Nützliche Hilfsmethoden (wie `is_active`) können implementiert werden.

## 4. Utility Services (`core_infra::utils`)

Dieses Modul stellt grundlegende Hilfsfunktionen und Dienste bereit, die keine spezifische Domänenlogik enthalten, aber von vielen Teilen der Anwendung benötigt werden.

### 4.1. Modulstruktur

```
core_infra/
└── src/
    ├── lib.rs
    ├── types.rs
    ├── error.rs
    └── utils/
        ├── mod.rs  // Re-exportiert öffentliche Funktionen aus Submodulen
        ├── fs.rs
        └── paths.rs
        // Optional: strings.rs, time.rs
```

### 4.2. Filesystem Utilities (`core_infra::utils::fs`)

Enthält grundlegende, sichere Operationen für das Dateisystem. Komplexe Dateioperationen gehören in höhere Schichten.

- **Funktionen:**
    
    Rust
    
    ```
    // core_infra/src/utils/fs.rs
    use crate::error::CoreError;
    use std::fs;
    use std::path::Path;
    
    /// Ensures that a directory exists at the specified path.
    /// If the directory does not exist, it attempts to create it, including any
    /// necessary parent directories.
    ///
    /// # Arguments
    /// * `path` - The path to the directory to ensure existence of.
    ///
    /// # Errors
    /// Returns `CoreError::Filesystem` if the directory could not be created
    /// or if the path exists but is not a directory.
    pub fn ensure_dir_exists(path: &Path) -> Result<(), CoreError> {
        if path.exists() {
            if!path.is_dir() {
                return Err(CoreError::Filesystem {
                    message: format!("Path exists but is not a directory"),
                    path: path.to_path_buf(),
                    // Use a placeholder error kind or map specific std::io::ErrorKind
                    source: std::io::Error::new(std::io::ErrorKind::AlreadyExists, "Path exists but is not a directory"),
                });
            }
            Ok(()) // Directory already exists
        } else {
            fs::create_dir_all(path).map_err(|e| CoreError::Filesystem {
                message: "Failed to create directory".to_string(),
                path: path.to_path_buf(),
                source: e,
            })
        }
    }
    
    // Add other minimal, safe filesystem utilities if absolutely necessary.
    // Example: Reading a file with specific error mapping.
    /// Reads the entire contents of a file into a string.
    ///
    /// # Arguments
    /// * `path` - The path to the file to read.
    ///
    /// # Errors
    /// Returns `CoreError::Filesystem` if the file cannot be read.
    pub fn read_to_string(path: &Path) -> Result<String, CoreError> {
        fs::read_to_string(path).map_err(|e| CoreError::Filesystem {
            message: "Failed to read file to string".to_string(),
            path: path.to_path_buf(),
            source: e,
        })
    }
    ```
    
- **Spezifikation:**
    - Alle Funktionen müssen `Result<(), CoreError>` oder `Result<T, CoreError>` zurückgeben.
    - Unterliegende `std::io::Error` müssen sorgfältig in `CoreError::Filesystem` oder `CoreError::Io` gemappt werden, wobei Kontext (wie der Dateipfad) hinzugefügt wird. Die `Filesystem`-Variante ist vorzuziehen, wenn der Pfad relevant ist, um aussagekräftigere Fehlermeldungen zu ermöglichen.

### 4.3. Path Resolution (`core_infra::utils::paths`)

Stellt standardisierte Pfade für Konfiguration, Daten, Cache etc. bereit, basierend auf Betriebssystemkonventionen (insbesondere XDG Base Directory Specification auf Linux 10). Nutzt die `directories-next` Crate.11

- **Abhängigkeit:** `directories-next = "2.0.0"` (oder aktuellste stabile Version)
- **Funktionen:**
    
    Rust
    
    ```
    // core_infra/src/utils/paths.rs
    use crate::error::{CoreError, ConfigError};
    use directories_next::{BaseDirs, ProjectDirs}; // Verwende directories-next
    use std::path::PathBuf;
    
    // Definiere hier die Projekt-Qualifizierer, falls ProjectDirs verwendet wird.
    // Diese sollten global konfigurierbar sein oder aus einer zentralen Stelle stammen.
    const QUALIFIER: &str = "org"; // Beispiel
    const ORGANIZATION: &str = "YourOrg"; // Beispiel
    const APPLICATION: &str = "YourApp"; // Beispiel
    
    /// Returns the primary base directory for user-specific configuration files.
    /// Corresponds to $XDG_CONFIG_HOME or platform equivalent.
    ///
    /// # Errors
    /// Returns `CoreError::Config(ConfigError::DirectoryUnavailable)` if the directory cannot be determined.
    pub fn get_config_base_dir() -> Result<PathBuf, CoreError> {
        BaseDirs::new()
           .map(|dirs| dirs.config_dir().to_path_buf())
           .ok_or_else(|| CoreError::Config(ConfigError::DirectoryUnavailable { dir_type: "Config Base".to_string() }))
    }
    
     /// Returns the primary base directory for user-specific data files.
    /// Corresponds to $XDG_DATA_HOME or platform equivalent.
    ///
    /// # Errors
    /// Returns `CoreError::Config(ConfigError::DirectoryUnavailable)` if the directory cannot be determined.
    pub fn get_data_base_dir() -> Result<PathBuf, CoreError> {
        BaseDirs::new()
           .map(|dirs| dirs.data_dir().to_path_buf())
           .ok_or_else(|| CoreError::Config(ConfigError::DirectoryUnavailable { dir_type: "Data Base".to_string() }))
    }
    
    /// Returns the primary base directory for user-specific cache files.
    /// Corresponds to $XDG_CACHE_HOME or platform equivalent.
    ///
    /// # Errors
    /// Returns `CoreError::Config(ConfigError::DirectoryUnavailable)` if the directory cannot be determined.
    pub fn get_cache_base_dir() -> Result<PathBuf, CoreError> {
        BaseDirs::new()
           .map(|dirs| dirs.cache_dir().to_path_buf())
           .ok_or_else(|| CoreError::Config(ConfigError::DirectoryUnavailable { dir_type: "Cache Base".to_string() }))
    }
    
    /// Returns the primary base directory for user-specific state files.
    /// Corresponds to $XDG_STATE_HOME or platform equivalent.
    /// Returns None if not applicable on the current platform (e.g., Windows, older macOS).
    ///
    /// # Errors
    /// Returns `CoreError::Config(ConfigError::DirectoryUnavailable)` if the directory cannot be determined.
    pub fn get_state_base_dir() -> Result<PathBuf, CoreError> {
         BaseDirs::new()
            // state_dir() ist in BaseDirs nicht direkt verfügbar,
            // aber XDG definiert es. directories-next unterstützt es möglicherweise
            // nicht direkt oder es muss manuell abgeleitet werden.
            // Fallback auf.local/state gemäß XDG Spec [10]
           .map(|dirs| {
                #[cfg(target_os = "linux")]
                {
                    std::env::var("XDG_STATE_HOME")
                       .map(PathBuf::from)
                       .unwrap_or_else(|_| dirs.home_dir().join(".local/state"))
                }
                #[cfg(not(target_os = "linux"))]
                {
                    // Für andere OS gibt es keinen direkten Standard, oft wird data_local_dir verwendet
                     dirs.data_local_dir().to_path_buf()
                }
            })
           .ok_or_else(|| CoreError::Config(ConfigError::DirectoryUnavailable { dir_type: "State Base".to_string() }))
    }
    
    
    /// Returns the application-specific configuration directory.
    /// Uses ProjectDirs based on QUALIFIER, ORGANIZATION, APPLICATION constants.
    /// Example: ~/.config/YourOrg/YourApp on Linux.
    ///
    /// # Errors
    /// Returns `CoreError::Config(ConfigError::DirectoryUnavailable)` if the directory cannot be determined.
    pub fn get_app_config_dir() -> Result<PathBuf, CoreError> {
        ProjectDirs::from(QUALIFIER, ORGANIZATION, APPLICATION)
           .map(|dirs| dirs.config_dir().to_path_buf())
           .ok_or_else(|| CoreError::Config(ConfigError::DirectoryUnavailable { dir_type: "App Config".to_string() }))
    }
    
    /// Returns the application-specific data directory.
    /// Example: ~/.local/share/YourOrg/YourApp on Linux.
    ///
    /// # Errors
    /// Returns `CoreError::Config(ConfigError::DirectoryUnavailable)` if the directory cannot be determined.
     pub fn get_app_data_dir() -> Result<PathBuf, CoreError> {
        ProjectDirs::from(QUALIFIER, ORGANIZATION, APPLICATION)
           .map(|dirs| dirs.data_dir().to_path_buf())
           .ok_or_else(|| CoreError::Config(ConfigError::DirectoryUnavailable { dir_type: "App Data".to_string() }))
    }
    
    /// Returns the application-specific cache directory.
    /// Example: ~/.cache/YourOrg/YourApp on Linux.
    ///
    /// # Errors
    /// Returns `CoreError::Config(ConfigError::DirectoryUnavailable)` if the directory cannot be determined.
    pub fn get_app_cache_dir() -> Result<PathBuf, CoreError> {
        ProjectDirs::from(QUALIFIER, ORGANIZATION, APPLICATION)
           .map(|dirs| dirs.cache_dir().to_path_buf())
           .ok_or_else(|| CoreError::Config(ConfigError::DirectoryUnavailable { dir_type: "App Cache".to_string() }))
    }
    
     /// Returns the application-specific state directory.
    /// Example: ~/.local/state/YourOrg/YourApp on Linux.
    ///
    /// # Errors
    /// Returns `CoreError::Config(ConfigError::DirectoryUnavailable)` if the directory cannot be determined.
    pub fn get_app_state_dir() -> Result<PathBuf, CoreError> {
        ProjectDirs::from(QUALIFIER, ORGANIZATION, APPLICATION)
             // ProjectDirs hat kein state_dir. Wir leiten es vom Basis-State-Dir ab.
           .and_then(|proj_dirs| {
                 get_state_base_dir().map(|base_state| base_state.join(proj_dirs.project_path()))
            })
           .ok_or_else(|| CoreError::Config(ConfigError::DirectoryUnavailable { dir_type: "App State".to_string() }))
    }
    ```
    
- **Spezifikation:**
    - Die Funktionen kapseln die Logik zur Pfadermittlung und abstrahieren die Unterschiede zwischen Betriebssystemen.11 Dies ist eine zentrale Aufgabe der Kernschicht, um Portabilität zu gewährleisten.
    - `Option`-Rückgabewerte von `directories-next` werden in `CoreError::Config(ConfigError::DirectoryUnavailable)` umgewandelt, um eine konsistente Fehlerbehandlung sicherzustellen.
    - Die Verwendung von `ProjectDirs` ist optional, aber empfohlen, wenn anwendungsspezifische Unterverzeichnisse standardmäßig benötigt werden. Die Konstanten `QUALIFIER`, `ORGANIZATION`, `APPLICATION` müssen definiert werden.

### 4.4. Basic String Manipulation (`core_infra::utils::strings`)

Nur hinzufügen, wenn generische String-Helfer benötigt werden, die über `std::str` und `String` hinausgehen und in der Kernschicht _unbedingt_ erforderlich sind. Im Allgemeinen sollte dieses Modul vermieden werden, um die Schicht schlank zu halten. Falls benötigt, müssen Signaturen exakt definiert werden (`pub fn...(...) ->...`).

### 4.5. Time Utilities (`core_infra::utils::time`)

Normalerweise wird `chrono` direkt in höheren Schichten verwendet. Dieses Modul ist nur notwendig, wenn die Kernschicht spezifische Zeit-Wrapper, Formate oder Abstraktionen _bereitstellen muss_. Wenn `chrono` verwendet wird, sollte es als Abhängigkeit deklariert werden.

## 5. Configuration Management (`core_infra::config`)

Verantwortlich für das Laden, Parsen und Validieren der Kernkonfiguration der Anwendung.

### 5.1. Modulstruktur

```
core_infra/
└── src/
    ├── lib.rs
    ├── types.rs
    ├── error.rs
    ├── utils/
    │   └──...
    └── config/
        ├── mod.rs // Definiert CoreConfig, LoggingConfig etc. und ConfigLoader
        └── defaults.rs // Enthält Funktionen für Standardwerte
```

### 5.2. Configuration Data Structures (`core_infra::config::mod.rs`)

Definition der Rust-Strukturen, die das Schema der Kernkonfiguration abbilden.

Rust

```
// core_infra/src/config/mod.rs
use crate::error::{CoreError, ConfigError};
use serde::Deserialize;
use std::path::{Path, PathBuf};
use std::fs;
use super::utils; // Importiere utils Modul
use super::config::defaults; // Importiere defaults Modul

/// Represents the core configuration for the application.
/// Loaded from a TOML file.
#
#[serde(deny_unknown_fields)] // Strikte Prüfung auf unbekannte Felder
pub struct CoreConfig {
    #[serde(default = "defaults::default_logging_config")]
    pub logging: LoggingConfig,
    // Weitere Kern-Einstellungen hier hinzufügen, z.B.:
    // #[serde(default = "defaults::default_feature_flags")]
    // pub features: FeatureFlags,
}

/// Configuration specific to the logging subsystem.
#
#[serde(deny_unknown_fields)]
pub struct LoggingConfig {
    /// The minimum log level to record (e.g., "trace", "debug", "info", "warn", "error").
    #[serde(default = "defaults::default_log_level")]
    pub level: String,

    /// Optional path to a file where logs should be written.
    /// If None, logs are written to stdout/stderr.
    #[serde(default = "defaults::default_log_file_path")]
    pub file_path: Option<PathBuf>,

    /// Log format (e.g., "text", "json").
    #[serde(default = "defaults::default_log_format")]
    pub format: String, // Oder eine Enum LogFormat definieren
}

// Beispiel für weitere Konfigurationsstrukturen
// #
// #[serde(deny_unknown_fields)]
// pub struct FeatureFlags {
//     #[serde(default = "defaults::default_bool_false")]
//     pub experimental_feature_x: bool,
// }

/// Service responsible for loading the application's core configuration.
#
pub struct ConfigLoader {
    // Keine Felder benötigt, da die Logik in der Methode liegt
}

impl ConfigLoader {
    /// Loads the core configuration from the standard location(s).
    ///
    /// Looks for `config.toml` in the application-specific config directory
    /// determined by `core_infra::utils::paths::get_app_config_dir()`.
    ///
    /// # Errors
    /// Returns `CoreError::Config` variants if loading, parsing, or validation fails.
    pub fn load() -> Result<CoreConfig, CoreError> {
        let config_dir = utils::paths::get_app_config_dir()?;
        let config_path = config_dir.join("config.toml");

        // 1. Sicherstellen, dass das Konfigurationsverzeichnis existiert (optional, aber gut für Erststart)
        // utils::fs::ensure_dir_exists(&config_dir)?; // Kann Fehler werfen, wenn nicht beschreibbar

        // 2. Konfigurationsdatei lesen
        let content = fs::read_to_string(&config_path).map_err(|e| {
            // Unterscheide zwischen "nicht gefunden" und anderen Lesefehlern
            if e.kind() == std::io::ErrorKind::NotFound {
                 CoreError::Config(ConfigError::NotFound { locations: vec![config_path.clone()] })
            } else {
                 CoreError::Config(ConfigError::ReadError { path: config_path.clone(), source: e })
            }
        })?;

        // 3. TOML-Inhalt deserialisieren
        let mut config: CoreConfig = toml::from_str(&content)
           .map_err(|e| CoreError::Config(ConfigError::ParseError(e)))?;

        // 4. Post-Deserialisierungs-Validierung
        Self::validate_config(&mut config)?;

        // 5. Validierte Konfiguration zurückgeben
        Ok(config)
    }

    /// Performs post-deserialization validation of the configuration.
    /// Modifiziert die Konfiguration ggf. (z.B. Pfade absolut machen).
    fn validate_config(config: &mut CoreConfig) -> Result<(), CoreError> {
        // Validiere Log-Level
        let valid_levels = ["trace", "debug", "info", "warn", "error"];
        if!valid_levels.contains(&config.logging.level.to_lowercase().as_str()) {
            return Err(CoreError::Config(ConfigError::ValidationError(format!(
                "Invalid logging level '{}'. Must be one of: {:?}",
                config.logging.level, valid_levels
            ))));
        }

        // Validiere Log-Format
        let valid_formats = ["text", "json"];
        if!valid_formats.contains(&config.logging.format.to_lowercase().as_str()) {
             return Err(CoreError::Config(ConfigError::ValidationError(format!(
                "Invalid logging format '{}'. Must be one of: {:?}",
                config.logging.format, valid_formats
            ))));
        }


        // Wandle relative Logpfade in absolute Pfade um (relativ zum Konfig-Verzeichnis oder Daten-Verzeichnis)
        if let Some(ref mut log_path) = config.logging.file_path {
            if log_path.is_relative() {
                // Entscheide, relativ wozu? Hier Annahme: relativ zum State-Verzeichnis
                let state_dir = utils::paths::get_app_state_dir()?;
                 // Stelle sicher, dass das State-Verzeichnis existiert
                utils::fs::ensure_dir_exists(&state_dir)?;
                *log_path = state_dir.join(&log_path);
            }
             // Optional: Stelle sicher, dass das übergeordnete Verzeichnis des Logfiles existiert
            if let Some(parent_dir) = log_path.parent() {
                utils::fs::ensure_dir_exists(parent_dir)?;
            }
        }


        // Füge hier weitere Validierungen für andere Konfigurationsabschnitte hinzu

        Ok(())
    }
}

```

- **Spezifikation:**
    - Alle Konfigurationsstrukturen müssen `serde::Deserialize`, `Debug`, `Clone`, `PartialEq` implementieren.8
    - `#[serde(deny_unknown_fields)]` ist zwingend, um Fehler bei unbekannten Feldern in der TOML-Datei zu erzeugen.
    - Felder sind `pub`. Standardwerte werden über `#[serde(default = "path::to::default_fn")]` gesetzt, wobei die Default-Funktionen in `core_infra::config::defaults` liegen.
    - Typen müssen exakt spezifiziert sein (`String`, `Option<PathBuf>`, `bool`, etc.).

### 5.3. Configuration Loading Service (`core_infra::config::mod.rs`)

- **Struktur:** `ConfigLoader` (Struct ohne Felder, Logik in `impl`-Block).
- **Methode:** `pub fn load() -> Result<CoreConfig, CoreError>`
- **Logik (Schritt-für-Schritt):**
    1. Ermittle den Pfad zum anwendungsspezifischen Konfigurationsverzeichnis mittels `utils::paths::get_app_config_dir()`.
    2. Konstruiere den vollständigen Pfad zur Konfigurationsdatei (z.B. `config.toml`). Der Dateiname ist fest auf `config.toml` festgelegt.
    3. Versuche, den Inhalt der Datei mit `std::fs::read_to_string` zu lesen. Bilde `std::io::Error` auf `CoreError::Config(ConfigError::ReadError)` oder `CoreError::Config(ConfigError::NotFound)` ab.
    4. Deserialisiere den gelesenen String mittels `toml::from_str::<CoreConfig>`.12 Bilde `toml::de::Error` auf `CoreError::Config(ConfigError::ParseError)` ab.
    5. Rufe die interne Validierungsfunktion `validate_config` auf.
    6. Gib die validierte `CoreConfig` im `Ok`-Fall zurück.

### 5.4. Configuration Format

- Das einzige unterstützte Konfigurationsformat ist **TOML**.12
- **Beispiel `config.toml`:**
    
    Ini, TOML
    
    ```
    # Beispiel config.toml
    
    [logging]
    level = "debug" # Mögliche Werte: "trace", "debug", "info", "warn", "error"
    file_path = "app.log" # Optional. Relativ zum State-Verzeichnis oder absolut.
    format = "text" # Mögliche Werte: "text", "json"
    
    # [features]
    # experimental_feature_x = true
    ```
    

### 5.5. Default Values (`core_infra::config::defaults.rs`)

Definition von Funktionen, die Standardwerte für die Konfigurationsstrukturen liefern.

Rust

```
// core_infra/src/config/defaults.rs
use super::{LoggingConfig}; // Importiere die relevanten Structs
use std::path::PathBuf;

pub(super) fn default_logging_config() -> LoggingConfig {
    LoggingConfig {
        level: default_log_level(),
        file_path: default_log_file_path(),
        format: default_log_format(),
    }
}

pub(super) fn default_log_level() -> String {
    "info".to_string()
}

pub(super) fn default_log_file_path() -> Option<PathBuf> {
    None // Standardmäßig auf stdout/stderr loggen
}

pub(super) fn default_log_format() -> String {
    "text".to_string()
}

// Beispiel für booleschen Default
// pub(super) fn default_bool_false() -> bool {
//     false
// }

// Füge hier Default-Funktionen für alle `#[serde(default = "...")]` Felder hinzu.
```

- **Spezifikation:**
    - Für jedes Feld mit `#[serde(default = "...")]` muss eine entsprechende `pub(super) fn default_...() -> FieldType` Funktion existieren.
    - Die Funktionen müssen den korrekten Typ zurückgeben und den dokumentierten Standardwert repräsentieren.

Die Trennung der Konfigurationslogik (Laden, Parsen, Validieren) vom reinen Datenschema (`CoreConfig`, `LoggingConfig`) und den Standardwerten (`defaults.rs`) fördert die Modularität und Testbarkeit. Die Validierung nach der Deserialisierung ist entscheidend, um sicherzustellen, dass die Konfiguration nicht nur syntaktisch korrekt ist, sondern auch semantisch gültig (z.B. gültige Log-Level). Die Konfiguration beeinflusst direkt das Verhalten anderer Kernkomponenten, insbesondere des Loggings, was eine sorgfältige Initialisierungsreihenfolge erfordert.

## 6. Logging Infrastructure (`core_infra::logging`)

Stellt eine zentrale und konfigurierbare Logging-Lösung für die gesamte Anwendung bereit, basierend auf der `tracing`-Crate.

### 6.1. Modulstruktur

```
core_infra/
└── src/
    ├── lib.rs
    ├── types.rs
    ├── error.rs
    ├── utils/
    │   └──...
    ├── config/
    │   └──...
    └── logging.rs // Enthält Initialisierungslogik
```

### 6.2. Logging Facade

Die `tracing`-Crate 13 wird als alleinige Schnittstelle für alle Logging-Aktivitäten in der Anwendung vorgeschrieben. Sie bietet strukturierte Logs und Span-basiertes Tracing.

### 6.3. Initialisierung (`core_infra::logging::init_logging`)

Eine Funktion zur Initialisierung des globalen `tracing`-Subscribers basierend auf der geladenen Konfiguration.

Rust

```
// core_infra/src/logging.rs
use crate::config::LoggingConfig;
use crate::error::CoreError;
use tracing::{Level, info};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter, Layer, Registry};
use std::io::{stdout, Write};
use std::path::Path;
use tracing_appender; // Für Dateilogging mit Rotation

/// Initializes the global tracing subscriber based on the provided configuration.
///
/// This function should be called **once** at the very beginning of the application startup.
/// It sets up logging to stdout/stderr and optionally to a file.
///
/// Handles the potential issue of needing logging before config is fully loaded
/// by allowing an optional initial call with default settings.
///
/// # Arguments
/// * `config` - The logging configuration obtained from `CoreConfig`.
/// * `is_reload` - Set to true if this is re-initializing after an initial basic setup.
///
/// # Errors
/// Returns `CoreError::LoggingInitialization` if setup fails (e.g., file cannot be opened).
pub fn init_logging(config: &LoggingConfig, is_reload: bool) -> Result<(), CoreError> {
    // 1. Filter-Level bestimmen
    let level_filter = match config.level.to_lowercase().as_str() {
        "trace" => EnvFilter::new(Level::TRACE.to_string()),
        "debug" => EnvFilter::new(Level::DEBUG.to_string()),
        "info" => EnvFilter::new(Level::INFO.to_string()),
        "warn" => EnvFilter::new(Level::WARN.to_string()),
        "error" => EnvFilter::new(Level::ERROR.to_string()),
        _ => {
            // Sollte durch validate_config abgefangen werden, aber sicherheitshalber
            return Err(CoreError::LoggingInitialization(format!(
                "Invalid log level in config: {}",
                config.level
            )));
        }
    };

    // 2. Layer für stdout/stderr erstellen (immer aktiv)
    let use_ansi = atty::is(atty::Stream::Stdout); // Farben nur bei TTY
    let stdout_layer = fmt::layer()
       .with_writer(stdout) // Explizit stdout
       .with_ansi(use_ansi) // ANSI-Farben aktivieren/deaktivieren
       .with_filter(level_filter.clone()); // Klonen, da Filter mehrfach verwendet wird

    // 3. Optional: Layer für Dateilogging erstellen
    let file_layer = if let Some(log_path) = &config.file_path {
        Some(create_file_layer(log_path, &config.format)?
            .with_filter(level_filter)) // Gleiches Level für Datei
    } else {
        None
    };

    // 4. Subscriber zusammenbauen und global setzen
    let registry = Registry::default()
       .with(stdout_layer); // stdout ist immer dabei

    // Füge den Dateilayer hinzu, falls vorhanden
    let subscriber = if let Some(layer) = file_layer {
        registry.with(layer)
    } else {
        registry.with(tracing_subscriber::filter::FilterExt::boxed(stdout_layer)) // Boxen, um Typkonsistenz zu wahren, wenn nur ein Layer da ist
    };


    // Versuche, den globalen Subscriber zu setzen
    if SubscriberInitExt::try_init(subscriber).is_err() {
        // Fehler nur werfen, wenn es nicht der Reload nach der initialen Einrichtung ist.
        // Beim Reload ist es erwartet, dass bereits ein Subscriber gesetzt ist.
        if!is_reload {
             return Err(CoreError::LoggingInitialization(
                "Failed to set global tracing subscriber. Was it already initialized?".to_string(),
            ));
        }
        // Beim Reload loggen wir, dass wir rekonfigurieren (mit dem *alten* Logger)
        info!("Re-initializing logging configuration.");
        // Der neue Subscriber wird nicht gesetzt, aber die Konfiguration wurde validiert.
        // In einem realen Szenario bräuchte man einen Mechanismus zur dynamischen Rekonfiguration
        // des Filters/Writers, was über tracing-subscriber's ReloadHandle ginge, aber
        // die Komplexität hier übersteigt. Für diese Spezifikation reicht die Validierung.
    }

    Ok(())
}

/// Helper function to create a file logging layer.
fn create_file_layer(log_path: &Path, format: &str) -> Result<Box<dyn Layer<Registry> + Send + Sync + 'static>, CoreError> {
     // Stelle sicher, dass das Verzeichnis existiert (sollte durch validate_config erfolgt sein)
    if let Some(parent) = log_path.parent() {
        if!parent.exists() {
             // Versuche es zu erstellen, falls validate_config es nicht getan hat
            utils::fs::ensure_dir_exists(parent)?;
        }
    }

    // Konfiguriere den File Appender (z.B. tägliche Rotation)
    let file_appender = tracing_appender::rolling::daily(
        log_path.parent().unwrap_or_else(|| Path::new(".")), // Sicherstellen, dass parent existiert
        log_path.file_name().unwrap_or_else(|| std::ffi::OsStr::new("core.log")),
    );
    let (non_blocking_writer, _guard) = tracing_appender::non_blocking(file_appender);

    // Wähle das Format basierend auf der Konfiguration
     match format.to_lowercase().as_str() {
        "json" => {
            let layer = fmt::layer()
               .json() // JSON-Format aktivieren
               .with_writer(non_blocking_writer)
               .with_ansi(false); // Keine ANSI-Codes in Dateien
             Ok(Box::new(layer))
        }
        "text" | _ => { // Default auf Text
             let layer = fmt::layer()
               .with_writer(non_blocking_writer)
               .with_ansi(false); // Keine ANSI-Codes in Dateien
             Ok(Box::new(layer))
        }
    }
    // _guard muss im Scope bleiben, damit der Writer funktioniert.
    // In einer echten Anwendung muss dieser Guard an einen geeigneten Ort verschoben werden,
    // z.B. in die Hauptanwendungsstruktur oder global statisch (mit lazy_static/once_cell).
    // Für diese Spezifikation ignorieren wir die Lebenszeit des Guards, gehen aber davon aus,
    // dass er korrekt gehandhabt wird.
    // std::mem::forget(_guard); // NICHT IN PRODUKTION VERWENDEN! Nur zur Kompilierung hier.
    // Besser: Rückgabe des Guards oder Speicherung in einem globalen Kontext.
}

/// Initializes a minimal fallback logger to stderr before configuration is loaded.
/// This should be called unconditionally at the very start.
pub fn init_minimal_logging() {
     // Setze einen einfachen Logger, der nur auf stderr schreibt, falls noch keiner gesetzt ist.
    // Ignoriere Fehler, falls bereits einer gesetzt wurde (z.B. in Tests).
    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(Level::INFO.to_string()));
    let _ = fmt::Subscriber::builder()
       .with_env_filter(filter)
       .with_writer(std::io::stderr) // Explizit stderr für frühe Logs
       .try_init();
}


```

- **Spezifikation:**
    - Die Funktion `init_logging` nimmt die `LoggingConfig` entgegen.
    - Sie MUSS das Log-Level (`config.level`) parsen und in einen `EnvFilter` oder äquivalenten Filter umwandeln. Ungültige Level führen zu `CoreError::LoggingInitialization`.
    - Ein `fmt::Layer` für die Standardausgabe (stdout/stderr) wird immer konfiguriert. ANSI-Farbunterstützung wird basierend auf `atty::is(atty::Stream::Stdout)` aktiviert/deaktiviert.
    - Wenn `config.file_path` `Some` ist:
        - Ein Dateilogging-Layer wird mittels `tracing_appender` (oder einer ähnlichen Crate für Rotation) erstellt. `tracing_appender` muss als Abhängigkeit hinzugefügt werden.
        - Der Pfad wird aus der Konfiguration übernommen. Die Validierung (und Umwandlung in einen absoluten Pfad) sollte bereits in `ConfigLoader::validate_config` erfolgt sein.
        - Fehler beim Öffnen/Erstellen der Logdatei oder des Verzeichnisses führen zu `CoreError::LoggingInitialization` oder `CoreError::Filesystem`.
        - Das Format (`text` oder `json`) wird gemäß `config.format` konfiguriert. ANSI-Codes werden für Dateilogs deaktiviert.
    - Die Layer werden kombiniert (mittels `.with()`) und der resultierende Subscriber wird mit `SubscriberInitExt::try_init` als globaler Standard gesetzt. Fehler beim Setzen (z.B. wenn bereits initialisiert) werden behandelt (siehe `is_reload`).
    - **Initialisierungsproblem:** Die Funktion `init_minimal_logging` wird hinzugefügt. Sie MUSS als Allererstes im `main`-Funktion aufgerufen werden, _bevor_ `ConfigLoader::load` versucht wird. Sie richtet einen einfachen Fallback-Logger ein (z.B. `INFO` Level auf `stderr`). `init_logging` wird dann _nach_ erfolgreichem Laden der Konfiguration erneut aufgerufen (mit `is_reload = true`), um die endgültige Konfiguration anzuwenden. Dies stellt sicher, dass Konfigurationsladefehler geloggt werden können.

### 6.4. Logging Macros

Entwickler MÜSSEN die Standard-`tracing`-Makros verwenden:

- `trace!(...)`: Für sehr detaillierte Diagnoseinformationen.
- `debug!(...)`: Für Debugging-Informationen während der Entwicklung.
- `info!(...)`: Für informative Nachrichten über den normalen Betrieb.
- `warn!(...)`: Für Warnungen über potenziell problematische Situationen.
- `error!(...)`: Für Fehlerbedingungen, die den Betrieb beeinträchtigen.
- `event!(Level::...,...)`: Für explizite Events mit spezifischem Level.

### 6.5. Structured Logging

Die Verwendung von strukturierten Feldern wird dringend empfohlen, um den vollen Nutzen aus `tracing` zu ziehen.13

- **Beispiel:** `info!(user_id = %user.id, operation = "login", success = true, "User logged in successfully");`
- Felder sollten konsistent benannt werden.

### 6.6. Spans

Die Verwendung von `tracing::span!` wird für die Instrumentierung logischer Arbeitsabschnitte empfohlen, insbesondere für Operationen, die Zeit in Anspruch nehmen oder über asynchrone Grenzen hinweggehen.

- **Beispiel:**
    
    Rust
    
    ```
    let span = tracing::span!(Level::DEBUG, "config_loading", path = %config_path.display());
    let _enter = span.enter(); // Span betreten
    //... Logik zum Laden der Konfiguration...
    // Span wird automatisch verlassen, wenn _enter aus dem Scope geht
    ```
    
- Spans ermöglichen die Korrelation von Log-Ereignissen und die Messung von Dauern.

Die Wahl von `tracing` bietet eine flexible und leistungsstarke Grundlage. Die Spezifikation eines klaren Initialisierungsprozesses, der auch frühe Fehler beim Konfigurationsladen abdeckt, ist entscheidend. Die Festlegung auf `fmt::Subscriber` mit optionalem Dateilogging als Standard vereinfacht die Implementierung für Entwickler, während die `tracing`-API selbst fortgeschrittene Anwendungsfälle ermöglicht.

## 7. Error Handling (`core_infra::error`)

Definiert eine einheitliche und robuste Fehlerbehandlungsstrategie für die Kernschicht.

### 7.1. Modulstruktur

```
core_infra/
└── src/
    ├── lib.rs
    ├── types.rs
    ├── utils/
    │   └──...
    ├── config/
    │   └──...
    ├── logging.rs
    └── error.rs // Definiert CoreError, ConfigError etc.
```

### 7.2. Core Error Enum (`core_infra::error.rs`)

Eine zentrale Enum `CoreError`, die alle möglichen Fehlerfälle der Kernschicht repräsentiert. Verwendet `thiserror` zur einfachen Implementierung.7

Rust

```
// core_infra/src/error.rs
use thiserror::Error;
use std::path::PathBuf;

/// The primary error type for the core infrastructure layer.
/// Aggregates specific error categories.
#
pub enum CoreError {
    /// Errors related to configuration loading, parsing, or validation.
    #[error("Configuration Error: {0}")]
    Config(#[from] ConfigError),

    /// Errors occurring during logging subsystem initialization.
    #[error("Logging Initialization Failed: {0}")]
    LoggingInitialization(String), // Kann spezifischer sein, z.B. eine eigene Enum

    /// Errors related to filesystem operations, including context.
    #[error("Filesystem Error: {message} (Path: {path:?})")]
    Filesystem {
        message: String,
        path: PathBuf,
        #[source] // Behält die ursprüngliche IO-Fehlerquelle
        source: std::io::Error,
    },

    /// General I/O errors not covered by Filesystem or Config::ReadError.
    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    /// Errors indicating invalid input parameters or data.
    #[error("Invalid Input: {0}")]
    InvalidInput(String),

    /// Placeholder for other potential core errors.
    #[error("An unexpected internal error occurred: {0}")]
    Internal(String),
}

/// Specific errors related to configuration handling.
#
pub enum ConfigError {
    /// Failed to read the configuration file.
    #[error("Failed to read configuration file from {path:?}")]
    ReadError {
        path: PathBuf,
        #[source]
        source: std::io::Error,
    },

    /// Failed to parse the TOML configuration content.
    #[error("Failed to parse configuration file: {0}")]
    ParseError(#[from] toml::de::Error),

    /// Configuration validation failed after parsing.
    #[error("Configuration validation failed: {0}")]
    ValidationError(String),

    /// Configuration file was not found at the expected location(s).
    #[error("Configuration file not found at expected locations: {locations:?}")]
    NotFound { locations: Vec<PathBuf> },

    /// Required configuration directory (e.g., XDG_CONFIG_HOME) could not be determined.
    #[error("Could not determine base directory for {dir_type}")]
    DirectoryUnavailable { dir_type: String },
}

// Implementiere Konvertierungen, falls nötig, um Kontext hinzuzufügen,
// bevor #[from] verwendet wird. Beispiel:
// impl From<SpecificError> for CoreError {
//     fn from(err: SpecificError) -> Self {
//         CoreError::Internal(format!("Specific error occurred: {}", err))
//     }
// }
```

- **Spezifikation:**
    - `CoreError` ist die einzige Fehlertyp, der von öffentlichen Funktionen dieser Schicht zurückgegeben wird.
    - Verwendet `thiserror::Error` für die Ableitung von `std::error::Error` und `Display`.
    - `#` ist obligatorisch.
    - Varianten decken alle logischen Fehlerquellen ab (Konfiguration, Logging, FS, IO, Input-Validierung).
    - `#[error("...")]` Attribute definieren menschenlesbare Fehlermeldungen. Diese Meldungen sollten kontextreich sein.
    - `#[from]` wird verwendet, um Standardfehler (wie `std::io::Error`, `toml::de::Error`) automatisch in `CoreError`-Varianten umzuwandeln.7 Dies vereinfacht die Fehlerkonvertierung.
    - `#[source]` wird verwendet, um die zugrundeliegende Fehlerursache für Debugging-Zwecke beizubehalten.7
    - Spezifischere Fehler-Enums (wie `ConfigError`) können definiert und mittels `#[from]` in `CoreError` eingebettet werden. Dies verbessert die interne Strukturierung und ermöglicht es Aufrufern bei Bedarf, spezifischere Fehlerfälle zu behandeln, ohne die Komplexität der öffentlichen API zu erhöhen.17
    - Die `CoreError::Filesystem`-Variante demonstriert das Hinzufügen von Kontext (Nachricht, Pfad) zu einem zugrundeliegenden Fehler (`source: std::io::Error`), was für die Fehlersuche unerlässlich ist.

### 7.3. Error Propagation

- Alle fehleranfälligen öffentlichen Funktionen MÜSSEN `Result<T, CoreError>` zurückgeben.
- Der `?`-Operator MUSS zur Fehlerpropagation innerhalb der Funktionen verwendet werden.
- Wo nötig, MUSS `.map_err()` verwendet werden, um Low-Level-Fehler in passende `CoreError`-Varianten umzuwandeln und dabei relevanten Kontext (z.B. Dateipfade, Operationsnamen) hinzuzufügen.

### 7.4. Error Handling Strategy

- **Kein `unwrap`/`expect`:** Die Verwendung von `.unwrap()` oder `.expect()` in der Kernschicht ist verboten, da dies zu Panics führt, die nicht ordnungsgemäß behandelt werden können.1 Erwartete Fehler müssen über `Result` signalisiert werden.
- **Panics:** Panics sollten nur bei logischen Programmierfehlern (Bugs) auftreten, die als nicht behebbar gelten (z.B. Verletzung von internen Invarianten, die durch korrekte Nutzung der API nicht auftreten sollten). Solche Fälle deuten auf einen Fehler im Code selbst hin, nicht auf einen Laufzeitfehler.

Diese Strategie stellt sicher, dass Fehler explizit behandelt und propagiert werden, was die Robustheit und Wartbarkeit des Codes verbessert. Die zentrale `CoreError`-Enum bietet eine konsistente Schnittstelle für Fehler aus der Kernschicht.

## 8. Core Event Definitions

Für diese Kerninfrastrukturschicht werden **keine** eigenen Events definiert.

Die Kernschicht konzentriert sich auf grundlegende, meist synchrone Setup-Aufgaben und die Bereitstellung von Utilities. Ereignisbasierte Kommunikation (Publish/Subscribe) ist typischerweise eine Aufgabe höherer Schichten oder dedizierter Event-Bus-Systeme, die auf der Kerninfrastruktur aufbauen, aber nicht Teil davon sind. Die Definition eines Event-Systems würde die Komplexität der Kernschicht unnötig erhöhen und ihre Abhängigkeiten erweitern (z.B. auf eine asynchrone Laufzeit oder eine spezifische Event-Bibliothek), was ihrem Zweck widerspricht.

Sollte in Zukunft ein Bedarf für _fundamentale_, von der Kernschicht ausgehende Ereignisse entstehen (z.B. dynamische Neuladung der Kernkonfiguration), müsste diese Spezifikation entsprechend erweitert werden, inklusive:

- Definition der Event-Typen (Structs/Enums).
- Spezifikation der Payloads (`Send + Sync + Clone + Debug`).
- Identifikation der emittierenden Komponente (Publisher).
- Definition des Übertragungsmechanismus (z.B. `tokio::sync::broadcast`).

Aktuell ist dies jedoch nicht vorgesehen.

## 9. External Dependencies

Die Kerninfrastruktur minimiert ihre externen Abhängigkeiten, um schlank, stabil und schnell kompilierbar zu bleiben. Nur essenzielle Crates für die Kernfunktionalitäten (Logging, Konfiguration, Fehlerbehandlung, Pfadermittlung) sind erlaubt.

### 9.1. Dependency Policy

- Nur absolut notwendige Abhängigkeiten hinzufügen.
- Stabile Versionen verwenden. Versionen müssen exakt spezifiziert werden.
- Benötigte Crate-Features explizit angeben. Standard-Features deaktivieren (`default-features = false`), wenn nicht alle benötigt werden, um die Abhängigkeitsgröße zu reduzieren.
- Regelmäßige Überprüfung auf Updates und Sicherheitsschwachstellen.

### 9.2. Dependency Table

Die folgenden externen Crates sind für die Implementierung der Kerninfrastruktur zwingend erforderlich:

|   |   |   |   |   |
|---|---|---|---|---|
|**Crate**|**Exakte Version¹**|**Benötigte Features**|**Rationale**|**Snippet Refs**|
|`tracing`|`0.1.40`|`std`|Kern-Logging-Fassade und API|13|
|`tracing-subscriber`|`0.3.18`|`fmt`, `env-filter`, `std`, `registry`, `json` (optional für Format)|`fmt`-Subscriber, Filterung, Registry-Basis|15|
|`tracing-appender`|`0.2.3`|(Standard)|Dateilogging mit Rotation|-|
|`serde`|`1.0.219`|`derive`, `std`|Deserialisierung für Konfigurationsstrukturen|8|
|`toml`|`0.8.22`|(Standard, enthält `parse`)|TOML-Parsing für Konfigurationsdateien|12|
|`thiserror`|`1.0.59`|(Standard)|Ableitung von `std::error::Error`, `Display`|6|
|`directories-next`|`2.0.0`|(Standard)|Cross-Plattform XDG/Standard-Verzeichnisermittlung|11|
|`log`|`0.4.21`|`std`|Transitiv benötigt von `tracing-subscriber`|14|
|`atty`|`0.2.15`|(Standard)|Erkennung von TTY für ANSI-Farben im Logging|-|

¹ _Anmerkung zu Versionen:_ Die hier angegebenen Versionen entsprechen den zum Zeitpunkt der Erstellung dieses Dokuments als stabil bekannten oder in den Referenzmaterialien genannten Versionen. Vor der Implementierung sind die **aktuellsten stabilen Versionen** zu überprüfen und zu verwenden, sofern sie API-kompatibel sind oder die Spezifikation entsprechend angepasst wird. Die exakten Versionen MÜSSEN in der `Cargo.toml` fixiert werden.

Diese Tabelle ist entscheidend für die Reproduzierbarkeit der Builds und die Stabilität der Kernschicht. Jede Änderung an diesen Abhängigkeiten (Version, Features) erfordert eine Überprüfung und Anpassung dieser Spezifikation.

## 10. Implementation Constraints and Guidelines

Diese Richtlinien stellen sicher, dass die Implementierung konsistent, wartbar und konform mit den Designzielen der Kernschicht ist.

### 10.1. Rust Version

- **Minimum Supported Rust Version (MSRV):** `1.70.0` (oder höher, basierend auf den MSRV-Anforderungen der Abhängigkeiten wie `tracing` 16 und der Verwendung von Sprachfeatures). Muss in `Cargo.toml` angegeben werden.
- **Entwicklung:** Die Entwicklung sollte mit der **aktuellsten stabilen Rust-Version** erfolgen.

### 10.2. `unsafe` Code

- Die Verwendung von `unsafe`-Blöcken ist in der gesamten Kerninfrastruktur **strikt verboten** (siehe Abschnitt 2.4).

### 10.3. Testing

- **Unit Tests:** Jede öffentliche Funktion und Methode MUSS durch Unit-Tests abgedeckt sein. Tests müssen sowohl Erfolgs- als auch Fehlerpfade validieren. Testmodule (`#[cfg(test)] mod tests {... }`) sollen direkt in den jeweiligen Quelldateien platziert werden.
- **Integration Tests:** Integrationstests, die das Zusammenspiel der Kernschicht mit anderen Schichten testen, gehören _nicht_ in dieses Crate, sondern in eine übergeordnete Testsuite.

### 10.4. Documentation

- **Rustdoc:** Alle öffentlichen Elemente (Crates, Module, Typen, Funktionen, Methoden, Traits, Konstanten) MÜSSEN umfassende Dokumentationskommentare (`///`) aufweisen.1
- **Inhalt:** Die Dokumentation muss den Zweck, Parameter, Rückgabewerte, garantierte Vor-/Nachbedingungen, mögliche `CoreError`-Varianten und ggf. Beispiele (`#[test]`-fähige Beispiele bevorzugt) enthalten (C-EXAMPLE, C-FAILURE 1).
- **Crate-Level Doku:** `src/lib.rs` MUSS eine ausführliche Crate-Level-Dokumentation enthalten, die den Zweck und die Verwendung der Kerninfrastruktur erklärt (C-CRATE-DOC 1).

### 10.5. Module Structure

Die Implementierung MUSS der folgenden Modulstruktur folgen:

```
core_infra/
└── src/
    ├── lib.rs         # Crate root, re-exportiert öffentliche APIs
    ├── error.rs       # Definition von CoreError, ConfigError etc.
    ├── types.rs       # Definition von Core-Datentypen (Structs, Enums)
    ├── config/        # Konfigurations-bezogene Module
    │   ├── mod.rs     # Definition von CoreConfig, LoggingConfig, ConfigLoader
    │   └── defaults.rs# Funktionen für Standardwerte
    ├── logging.rs     # Logging-Initialisierungslogik
    └── utils/         # Utility-Module
        ├── mod.rs     # Re-exportiert öffentliche Utils
        ├── fs.rs      # Filesystem-Utilities
        └── paths.rs   # Pfadermittlungs-Utilities
        // Optional: strings.rs, time.rs
```

Öffentliche APIs sollten selektiv von `lib.rs` re-exportiert werden, um die Schnittstelle klar zu definieren.

### 10.6. `Cargo.toml` Manifest

Die `Cargo.toml`-Datei MUSS wie folgt konfiguriert sein:

Ini, TOML

```
[package]
name = "core_infra"
version = "0.1.0" # Startversion, SemVer beachten
edition = "2021" # Oder neuere Edition, falls MSRV es erlaubt
authors = ["Your Name <your.email@example.com>"] # Anpassen
description = "Core infrastructure layer providing foundational utilities, configuration, logging, and error handling."
license = "MIT OR Apache-2.0" # Lizenz gemäß Vorgabe [12, 18]
repository = "URL/to/your/repository" # Optional, aber empfohlen
homepage = "URL/to/project/homepage" # Optional
documentation = "URL/to/docs" # Optional, falls extern gehostet
readme = "README.md" # Optional
keywords = ["core", "infrastructure", "config", "logging", "error"] # Optional
categories = ["api-bindings", "config", "filesystem"] # Optional, siehe crates.io Kategorien

# Mindest-Rust-Version festlegen
rust-version = "1.70.0" # Anpassen gemäß Abschnitt 10.1

[dependencies]
# Versionen exakt wie in Abschnitt 9.2 spezifiziert
tracing = { version = "0.1.40" }
tracing-subscriber = { version = "0.3.18", features = ["fmt", "env-filter", "std", "registry", "json"] } # json optional
tracing-appender = { version = "0.2.3" }
serde = { version = "1.0.219", features = ["derive"] } # std ist default feature
toml = { version = "0.8.22" }
thiserror = { version = "1.0.59" }
directories-next = { version = "2.0.0" }
log = { version = "0.4.21" }
atty = { version = "0.2.15" }

# Optional: Dev-Dependencies für Tests
[dev-dependencies]
# z.B. pretty_assertions = "1.4.0" für bessere Test-Diffs

# Optional: Build-Dependencies, falls benötigt
[build-dependencies]

# Optional: Profile für Optimierungen, etc.
[profile.release]
lto = true          # Link Time Optimization für Release-Builds
codegen-units = 1   # Bessere Optimierung, langsamere Kompilierung
panic = 'abort'     # Kleinere Binaries, keine Stack Unwinding Info bei Panic
strip = true        # Symbole entfernen für kleinere Binaries
```

- **Spezifikation:**
    - Alle Metadaten im `[package]`-Abschnitt müssen korrekt ausgefüllt sein.1
    - Die `edition` muss angegeben werden.
    - Die `license` muss den gängigen Open-Source-Lizenzen entsprechen, die in den Referenzen verwendet werden (oft MIT/Apache-2.0).7
    - Die `rust-version` MUSS gesetzt sein.
    - Der `[dependencies]`-Abschnitt MUSS exakt die Crates, Versionen und Features aus Abschnitt 9.2 enthalten. Keine zusätzlichen Abhängigkeiten sind erlaubt.

## 11. Schlussfolgerungen

Dieser Implementierungsleitfaden definiert die Kerninfrastrukturschicht (`core_infra`) mit höchster Präzision und Detailgenauigkeit. Durch die strikte Befolgung dieser Spezifikation wird sichergestellt, dass Entwickler eine konsistente, robuste und wartbare Basis für das Gesamtsystem erstellen können, ohne eigene grundlegende Designentscheidungen treffen zu müssen.

Die Kernpunkte umfassen:

1. **Klare Verantwortlichkeiten:** Die Schicht beschränkt sich auf fundamentale Utilities, Konfiguration, Logging und Fehlerbehandlung und bleibt frei von Abhängigkeiten zu höheren Schichten.
2. **Rust Best Practices:** Die Implementierung folgt konsequent den Rust API Guidelines, Sicherheitsprinzipien (kein `unsafe`) und etablierten Mustern für Fehlerbehandlung und Dokumentation.
3. **Standardisierte Werkzeuge:** Die Verwendung von etablierten Crates wie `tracing`, `serde`, `toml`, `thiserror` und `directories-next` stellt die Nutzung bewährter Lösungen sicher und reduziert den Implementierungsaufwand.
4. **Präzise Schnittstellen:** Alle öffentlichen Typen, Funktionen und Module sind exakt definiert, inklusive Signaturen, Fehlertypen und Verhalten.
5. **Reproduzierbarkeit:** Durch die Festlegung exakter Abhängigkeitsversionen und Build-Konfigurationen wird eine hohe Reproduzierbarkeit gewährleistet.
6. **Plattformabstraktion:** Kritische plattformspezifische Aspekte wie die Verzeichnisstruktur werden durch Utilities (z.B. `core_infra::utils::paths`) abstrahiert.

Die sorgfältige Behandlung von Randfällen, wie die Initialisierungsreihenfolge von Konfiguration und Logging, sowie die detaillierte Definition der Fehlerbehandlung mit `CoreError` und `ConfigError` tragen maßgeblich zur Stabilität der Schicht bei. Entwickler können diesen Leitfaden als direkte Vorlage für die Implementierung verwenden.


# Pflichtenheft für die Coreschicht

**Version:** 1.0

**Datum:** 2024-05-16

**Autor:** Dr. rer. nat. Expertenteam

**Status:** Entwurf

## Inhaltsverzeichnis

1. Einleitung 1.1. Zweck des Dokuments 1.2. Geltungsbereich 1.3. Zielgruppe 1.4. Definitionen und Akronyme 1.5. Referenzierte Dokumente und Standards
2. Datenbankdesign-Spezifikation 2.1. Data Dictionary 2.1.1. Tabellenstruktur und Felddefinitionen 2.1.2. Datentypen 2.1.3. Primär- und Fremdschlüssel 2.1.4. Constraints und Validierungsregeln 2.2. Entity-Relationship-Diagramme (ERD) 2.2.1. Notation 2.2.2. Werkzeuge 2.2.3. Konzeptionelles ER-Diagramm (Beschreibung) 2.2.4. Best Practices für ER-Diagramme
3. Schnittstellendesign-Spezifikation (API) 3.1. Interne Schnittstellen 3.1.1. REST-API für Kernfunktionalitäten 3.1.1.1. Basis-URL 3.1.1.2. Authentifizierung und Autorisierung 3.1.1.3. Datenformate (Request/Response) 3.1.1.4. HTTP-Statuscodes 3.1.1.5. Endpunktspezifikationen (Beispiele) 3.1.1.6. Versionierung 3.2. Externe Schnittstellen (falls zutreffend) 3.3. API-Dokumentation (OpenAPI/Swagger) 3.4. Best Practices für API-Design
4. UI/UX-Design-Spezifikationen (für Administrations- und Konfigurationsoberflächen) 4.1. Wireframes 4.1.1. Zweck und Detailgrad 4.1.2. Werkzeuge 4.1.3. Beispiele (Beschreibung der wichtigsten Ansichten) 4.1.4. Informationsarchitektur und Navigation 4.2. Mockups 4.2.1. Visuelles Design und Detailtiefe 4.2.2. Werkzeuge 4.2.3. Beispiele (Beschreibung der wichtigsten Ansichten) 4.3. Prototypen (klickbar) 4.3.1. Interaktivität und Benutzerflüsse 4.3.2. Werkzeuge 4.3.3. Zu testende Szenarien 4.4. Styleguide 4.4.1. Farbpalette 4.4.2. Typografie 4.4.3. Ikonografie 4.4.4. Abstände und Layout-Raster 4.4.5. UI-Komponentenbibliothek
5. Sicherheitskonzept 5.1. Grundlagen und Prinzipien 5.1.1. Layered Security (Defense in Depth) 5.1.2. Prinzip der geringsten Rechte (Principle of Least Privilege) 5.2. Authentifizierung und Autorisierung 5.2.1. Authentifizierungsmechanismen 5.2.2. Autorisierungsmodell (z.B. RBAC) 5.3. Datensicherheit 5.3.1. Verschlüsselung von Daten "at rest" 5.3.2. Verschlüsselung von Daten "in transit" 5.4. API-Sicherheitsmaßnahmen 5.5. Sichere Eingabevalidierung und -verarbeitung 5.6. Protokollierung (Logging) und Überwachung sicherheitsrelevanter Ereignisse
6. Schlussfolgerungen
7. Anhang 7.1. Glossar 7.2. Referenzierte Dokumente und Standards (erweitert)

---

## 1. Einleitung

Dieses Pflichtenheft (auch als funktionale Spezifikation oder Sollkonzept bezeichnet 1) definiert die Anforderungen und Spezifikationen für die Entwicklung der Coreschicht einer Softwareanwendung. Es dient als verbindliche Grundlage für die Implementierung und stellt sicher, dass das Endprodukt die definierten Bedürfnisse und Erwartungen erfüllt.2 Die Coreschicht umfasst die zentrale Geschäftslogik, die Datenhaltung sowie die internen und externen Schnittstellen des Systems.

### 1.1. Zweck des Dokuments

Der Hauptzweck dieses Dokuments ist die detaillierte und unmissverständliche Beschreibung der zu realisierenden Coreschicht. Es legt fest, _was_ entwickelt werden soll und _wie_ die einzelnen Komponenten strukturiert und implementiert werden müssen, um die übergeordneten Projektziele zu erreichen.3 Dieses Pflichtenheft bildet die Grundlage für Design, Entwicklung, Test und Abnahme der Coreschicht. Es dient der Vermeidung von Missverständnissen zwischen Auftraggeber und Auftragnehmer und reduziert das Risiko von Fehlentwicklungen und Nacharbeiten.5

### 1.2. Geltungsbereich

Dieses Pflichtenheft bezieht sich ausschließlich auf die Entwicklung und Implementierung der Coreschicht. Dies beinhaltet:

- **Datenbankdesign:** Struktur, Tabellen, Felder, Datentypen und Beziehungen der primären Datenbank.
- **Schnittstellendesign:** Spezifikation der internen APIs (insbesondere REST-APIs) für die Kommunikation mit anderen Systemkomponenten (z.B. Frontend, andere Backend-Services) und ggf. externen Diensten.
- **UI/UX-Design-Spezifikationen:** Konzeption und Gestaltung von Benutzeroberflächen, die direkt mit der Coreschicht interagieren, typischerweise Administrations- oder Konfigurationsoberflächen.
- **Sicherheitskonzept:** Maßnahmen zur Gewährleistung der Vertraulichkeit, Integrität und Verfügbarkeit der Daten und Funktionen der Coreschicht.

Aspekte wie die detaillierte Ausgestaltung von Frontend-Applikationen, die nicht direkt Administrationszwecken der Coreschicht dienen, oder die übergeordnete Infrastrukturplanung sind nicht primärer Gegenstand dieses Dokuments, können aber referenziert werden, wo Interdependenzen bestehen.

### 1.3. Zielgruppe

Dieses Dokument richtet sich an folgende Stakeholder:

- **Entwicklerteam:** Als detaillierte Vorgabe für die Implementierung.
- **Projektmanager:** Zur Planung, Steuerung und Überwachung des Entwicklungsprozesses.
- **Qualitätssicherungsteam:** Als Grundlage für die Erstellung von Testfällen und die Durchführung von Tests.
- **Systemarchitekten:** Zur Sicherstellung der Kompatibilität mit der Gesamtarchitektur.
- **Auftraggeber/Produktmanagement:** Zur Überprüfung, ob die spezifizierten Funktionalitäten den Anforderungen entsprechen und zur formalen Abnahme.

Ein klares Verständnis der Inhalte ist für alle Beteiligten essenziell, um den Projekterfolg sicherzustellen.2

### 1.4. Definitionen und Akronyme

Eine umfassende Liste der in diesem Dokument verwendeten Fachbegriffe, Abkürzungen und Akronyme befindet sich im Anhang (Kapitel 7.1 Glossar).5 Dies dient der Vermeidung von Missverständnissen und der Sicherstellung eines einheitlichen Sprachgebrauchs.

### 1.5. Referenzierte Dokumente und Standards

Dieses Pflichtenheft basiert auf und referenziert verschiedene externe Dokumente, Normen und interne Vorgaben. Eine detaillierte Auflistung findet sich im Anhang (Kapitel 7.2 Referenzierte Dokumente und Standards).1 Zu den wichtigsten gehören Normen wie DIN 69901-5 für Projektmanagement und Pflichtenhefte 1 sowie ggf. der IEEE 830 Standard für Software Requirements Specifications (SRS) 8, falls internationale Kontexte relevant sind.

## 2. Datenbankdesign-Spezifikation

Die Datenbank bildet das Fundament der Coreschicht und ist für die persistente Speicherung und Verwaltung aller relevanten Anwendungsdaten zuständig. Eine sorgfältige Planung und Dokumentation des Datenbankdesigns ist entscheidend für die Performance, Integrität und Skalierbarkeit des Gesamtsystems. Dieses Kapitel beschreibt die Struktur der Datenbank, einschließlich des Data Dictionary und der Entity-Relationship-Diagramme (ERD). Die hier getroffenen Entscheidungen müssen Aspekte der Datensicherheit, wie Verschlüsselung und Zugriffskontrolle, von Beginn an berücksichtigen, um ein "Secure by Design"-Prinzip zu gewährleisten.

### 2.1. Data Dictionary

Das Data Dictionary dient als zentrales Nachschlagewerk für alle Datenelemente der Datenbank. Es dokumentiert detailliert jede Tabelle, deren Felder, Datentypen, Beziehungen und Constraints.11 Ein gut gepflegtes Data Dictionary ist unerlässlich für das Verständnis der Datenstruktur, die Entwicklung konsistenter Abfragen und die Wartung des Systems.12

#### 2.1.1. Tabellenstruktur und Felddefinitionen

Für jede Tabelle im Datenbankschema werden die folgenden Informationen spezifiziert:

- **Tabellenname:** Ein eindeutiger und deskriptiver Name für die Tabelle (z.B. `Kunden`, `Bestellungen`, `Produkte`). Es empfiehlt sich, konsistente Namenskonventionen zu verwenden (z.B. Singular- oder Pluralformen).14
- **Beschreibung:** Eine kurze Erläuterung des Zwecks und Inhalts der Tabelle.
- **Felder (Attribute):** Für jedes Feld in der Tabelle:
    - **Feldname:** Eindeutiger Name des Feldes innerhalb der Tabelle (z.B. `KundenID`, `Vorname`, `Erstelldatum`). Auch hier sind konsistente Namenskonventionen wichtig (z.B. CamelCase oder snake_case).12
    - **Beschreibung:** Bedeutung und Zweck des Feldes.
    - **Datentyp:** Der spezifische Datentyp des Feldes (siehe Kapitel 2.1.2).
    - **Primärschlüssel (PK):** Kennzeichnung, ob das Feld Teil des Primärschlüssels ist.
    - **Fremdschlüssel (FK):** Kennzeichnung, ob das Feld ein Fremdschlüssel ist, inklusive der Referenztabelle und des Referenzfeldes.
    - **NotNull-Constraint:** Angabe, ob das Feld einen Wert enthalten muss (`TRUE`/`FALSE`).
    - **Unique-Constraint:** Angabe, ob der Wert des Feldes innerhalb der Tabelle eindeutig sein muss (`TRUE`/`FALSE`).
    - **Standardwert:** Ein optionaler Standardwert, der verwendet wird, wenn beim Einfügen eines neuen Datensatzes kein Wert für dieses Feld angegeben wird.
    - **Beispielwert:** Ein typischer Beispielwert zur Veranschaulichung.
    - **Sensitivität:** Klassifizierung der Sensitivität der Daten im Feld (z.B. öffentlich, intern, vertraulich, streng vertraulich) als Grundlage für Sicherheitsmaßnahmen.

Die Definition der Tabellen und Felder erfolgt in einer strukturierten Form, beispielsweise durch eine Serie von Tabellen, die jeweils eine Datenbanktabelle beschreiben.

**Tabelle 2.1: Beispielstruktur für eine Data Dictionary Tabelle (am Beispiel `Kunden`)**

|   |   |   |   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|---|---|---|
|**Attribut**|**Feldname**|**Datentyp**|**PK**|**FK (Tabelle.Feld)**|**NotNull**|**Unique**|**Standardwert**|**Beispielwert**|**Sensitivität**|**Beschreibung**|
|Kundenidentifikation|`KundenID`|`INTEGER`|Ja||Ja|Ja|AUTOINCREMENT|1001|Intern|Eindeutiger Identifikator des Kunden|
|Vorname des Kunden|`Vorname`|`VARCHAR(50)`|Nein||Ja|Nein||Max|Vertraulich|Vorname des Kunden|
|Nachname des Kunden|`Nachname`|`VARCHAR(50)`|Nein||Ja|Nein||Mustermann|Vertraulich|Nachname des Kunden|
|E-Mail-Adresse|`Email`|`VARCHAR(100)`|Nein||Ja|Ja||max.mustermann@example.com|Vertraulich|E-Mail-Adresse des Kunden|
|Registrierungsdatum|`RegistriertAm`|`TIMESTAMP`|Nein||Ja|Nein|CURRENT_TIMESTAMP|2023-10-26 10:00:00|Intern|Zeitpunkt der Registrierung des Kunden|
|Letzter Login|`LetzterLogin`|`TIMESTAMP`|Nein||Nein|Nein||2024-05-15 14:30:00|Vertraulich|Zeitpunkt des letzten Logins des Kunden|

Die konsequente Anwendung von Namenskonventionen und die detaillierte Beschreibung jedes Elements sind entscheidend. Dies erleichtert nicht nur die Entwicklung, sondern auch die spätere Wartung und Erweiterung des Systems, da neue Teammitglieder sich schneller einarbeiten können und die Datenstrukturen klar verständlich sind.12 Die Klassifizierung der Datensensitivität ist ein wichtiger Input für das Sicherheitskonzept, insbesondere für Verschlüsselungsstrategien und Zugriffskontrollen.

#### 2.1.2. Datentypen

Die Auswahl des korrekten Datentyps für jedes Feld ist fundamental, da sie bestimmt, welche Art von Daten gespeichert werden können, wie viel Speicherplatz benötigt wird und welche Operationen auf den Daten ausgeführt werden können.15 Die Datentypen müssen dem gewählten Datenbanksystem entsprechen. Gängige Datentypen umfassen:

- **Zeichenketten:**
    - `CHAR(n)`: Feste Länge, geeignet für kurze, immer gleich lange Zeichenketten.
    - `VARCHAR(n)`: Variable Länge bis zu `n` Zeichen, effizient für unterschiedlich lange Texte.
    - `TEXT` / `CLOB`: Für sehr lange Textdaten.
- **Numerische Typen:**
    - `INTEGER` / `INT`: Ganze Zahlen.
    - `SMALLINT`, `BIGINT`: Ganze Zahlen mit kleinerem bzw. größerem Wertebereich.
    - `NUMERIC(p,s)` / `DECIMAL(p,s)`: Festkommazahlen mit Präzision `p` und `s` Nachkommastellen, ideal für Währungsbeträge.
    - `FLOAT`, `REAL`, `DOUBLE PRECISION`: Gleitkommazahlen.
- **Datum und Zeit:**
    - `DATE`: Speichert nur das Datum.
    - `TIME`: Speichert nur die Uhrzeit.
    - `TIMESTAMP` / `DATETIME`: Speichert Datum und Uhrzeit, oft mit Zeitzoneninformation.
- **Boole'sche Werte:**
    - `BOOLEAN`: Speichert `TRUE` oder `FALSE`.
- **Binärdaten:**
    - `BLOB` / `BYTEA`: Für die Speicherung von Binärdaten wie Bildern oder Dateien (obwohl die Speicherung großer Binärdateien direkt in der Datenbank oft kritisch hinterfragt werden sollte).
- **Spezifische Typen:**
    - `UUID`: Universally Unique Identifier.
    - `JSON` / `JSONB`: Zur Speicherung von JSON-Dokumenten direkt in der Datenbank.
    - `XML`: Zur Speicherung von XML-Daten.

Die Wahl des Datentyps beeinflusst auch die Datenvalidierung auf Datenbankebene; beispielsweise kann in ein `INTEGER`-Feld kein Text eingegeben werden.15 Die Feldgröße (z.B. bei `VARCHAR(n)` oder die Wahl zwischen `INTEGER` und `BIGINT`) sollte so gewählt werden, dass sie den erwarteten Datenmengen entspricht, aber keinen unnötigen Speicherplatz verschwendet.16

#### 2.1.3. Primär- und Fremdschlüssel

- **Primärschlüssel (PK):** Jede Tabelle muss einen Primärschlüssel besitzen, der jeden Datensatz eindeutig identifiziert. Ein Primärschlüssel kann aus einem oder mehreren Feldern bestehen (zusammengesetzter Primärschlüssel). Üblicherweise werden hierfür `INTEGER`- oder `UUID`-Felder mit automatischer Generierung (z.B. `AUTO_INCREMENT` oder Sequenzen) verwendet.16
- **Fremdschlüssel (FK):** Fremdschlüssel dienen dazu, Beziehungen zwischen Tabellen herzustellen und die referentielle Integrität sicherzustellen. Ein Fremdschlüssel in einer Tabelle verweist auf den Primärschlüssel einer anderen (oder derselben) Tabelle. Es muss sichergestellt werden, dass für jeden Fremdschlüsselwert ein entsprechender Primärschlüsselwert in der referenzierten Tabelle existiert. Datenbanken bieten Optionen wie `ON DELETE CASCADE` oder `ON DELETE SET NULL`, um das Verhalten bei Löschoperationen in der referenzierten Tabelle zu steuern.

Die klare Definition von Primär- und Fremdschlüsseln ist die Basis für die Abbildung von Entitätsbeziehungen im relationalen Modell und somit ein Kernstück des Datenbankdesigns.11

#### 2.1.4. Constraints und Validierungsregeln

Zusätzlich zu `NotNull`- und `Unique`-Constraints können weitere Validierungsregeln auf Datenbankebene definiert werden, um die Datenintegrität zu gewährleisten:

- **CHECK-Constraints:** Erlauben die Definition spezifischer Bedingungen, die Daten erfüllen müssen (z.B. `Alter >= 18`, `Preis > 0`).
- **Default-Werte:** Wie in 2.1.1 erwähnt, können Standardwerte für Felder definiert werden.

Obwohl viele Validierungen auch auf Applikationsebene (in der Coreschicht-Logik) stattfinden, bieten datenbankseitige Constraints eine zusätzliche Sicherheitsebene und stellen die Datenkonsistenz auch bei direkten Datenbankzugriffen sicher. Die Definition dieser Regeln im Data Dictionary ist daher von großer Bedeutung.17

### 2.2. Entity-Relationship-Diagramme (ERD)

Entity-Relationship-Diagramme (ERDs) visualisieren die Struktur der Datenbank, indem sie Entitäten (Tabellen), deren Attribute (Felder) und die Beziehungen zwischen ihnen darstellen.18 Sie sind ein unverzichtbares Werkzeug für das Verständnis und die Kommunikation des Datenbankmodells.

#### 2.2.1. Notation

Es existieren verschiedene Notationen für ERDs. Die gebräuchlichsten sind:

- **Chen-Notation:** Stellt Entitäten als Rechtecke, Attribute als Ovale und Beziehungen als Rauten dar. Sie ist sehr ausdrucksstark und detailliert.18
- **Crow's Foot Notation (Krähenfußnotation):** Stellt Entitäten als Rechtecke dar und Beziehungen als Linien zwischen ihnen, wobei die Kardinalität (z.B. eins-zu-viele, viele-zu-viele) durch spezielle Symbole (Krähenfüße) am Ende der Linien angezeigt wird. Diese Notation ist oft intuitiver und wird in vielen modernen Modellierungswerkzeugen verwendet.18
- **UML-Klassendiagramm-Notation:** Kann ebenfalls zur Darstellung von Datenmodellen verwendet werden, wobei Klassen Entitäten repräsentieren.18

Für dieses Projekt wird die **Crow's Foot Notation** empfohlen, da sie eine klare und weit verbreitete Methode zur Darstellung von Kardinalitäten bietet und von vielen gängigen ERD-Werkzeugen unterstützt wird.

#### 2.2.2. Werkzeuge

Zur Erstellung und Pflege von ER-Diagrammen stehen zahlreiche Werkzeuge zur Verfügung, sowohl Desktop-Anwendungen als auch webbasierte Lösungen. Einige Beispiele sind:

- **Lucidchart:** Ein populäres Online-Tool mit Funktionen für Datenimport und Kollaboration.20
- **ERDPlus:** Ein webbasiertes Tool, das die automatische Konvertierung von ER-Diagrammen in relationale Schemata ermöglicht und SQL exportieren kann.20
- **Visual Paradigm Online:** Bietet eine breite Palette an Diagrammtypen, einschließlich ERDs, mit vielen Vorlagen.20
- **SmartDraw:** Ermöglicht die automatische Erstellung von ERDs aus bestehenden Datenbanken.20
- **Creately:** Ein weiteres kollaboratives Online-Diagrammwerkzeug.20
- **dbdiagram.io:** Ermöglicht die Erstellung von ERDs durch das Schreiben einer einfachen textbasierten Sprache (DSL).21
- **ClickUp:** Bietet Whiteboard-Funktionen und Vorlagen für ER-Diagramme als Teil einer umfassenderen Projektmanagement-Plattform.23

Die Auswahl des Werkzeugs sollte auf Basis der Projektanforderungen, der Teampräferenzen und ggf. vorhandener Lizenzen erfolgen. Wichtig ist, dass das Werkzeug den Export in gängige Bildformate oder als Vektorgrafik ermöglicht und idealerweise eine Versionierung oder Integration mit Versionskontrollsystemen unterstützt.

#### 2.2.3. Konzeptionelles ER-Diagramm (Beschreibung)

Das konzeptionelle ER-Diagramm stellt die Hauptentitäten des Systems und ihre Beziehungen auf einer hohen Abstraktionsebene dar. Es dient dazu, ein grundlegendes Verständnis der Datenstruktur zu vermitteln, ohne sich in Implementierungsdetails zu verlieren.

Für die Coreschicht werden folgende Hauptentitäten und ihre Beziehungen erwartet (Beispielhaft, muss an das spezifische Projekt angepasst werden):

- **Benutzer (`Users`):** Enthält Informationen über die Benutzer des Systems (z.B. `UserID`, `Username`, `PasswortHash`, `Email`, `Rolle`).
- **[Hauptentität 1] (z.B. `Produkte`):** Enthält Attribute spezifisch für die Kernfunktionalität (z.B. `ProduktID`, `Name`, `Beschreibung`, `Preis`).
- **[Hauptentität 2] (z.B. `Bestellungen`):** (z.B. `BestellID`, `KundenID` (FK zu `Users`), `Bestelldatum`, `Status`).
- ** (z.B. `Bestellpositionen`):** Verbindet `Bestellungen` und `Produkte` (z.B. `BestellpositionsID`, `BestellID` (FK), `ProduktID` (FK), `Menge`, `Einzelpreis`).

**Beziehungen (Beispiele):**

- Ein `Benutzer` kann viele `Bestellungen` aufgeben (1:N).
- Eine `Bestellung` gehört zu genau einem `Benutzer` (N:1).
- Eine `Bestellung` kann viele `Produkte` über `Bestellpositionen` enthalten (M:N, realisiert über die Verknüpfungstabelle `Bestellpositionen`).
- Ein `Produkt` kann in vielen `Bestellungen` über `Bestellpositionen` enthalten sein (M:N).

Das tatsächliche ER-Diagramm wird als separate grafische Darstellung beigefügt oder im gewählten Werkzeug gepflegt und hier referenziert. Es muss alle im Data Dictionary definierten Tabellen und ihre durch Fremdschlüssel spezifizierten Beziehungen abbilden.

#### 2.2.4. Best Practices für ER-Diagramme

Bei der Erstellung und Pflege von ER-Diagrammen sollten folgende Best Practices beachtet werden, um Klarheit, Lesbarkeit und Korrektheit zu gewährleisten 14:

- **Standardisierte Symbole und Notationen verwenden:** Dies erleichtert das Verständnis für alle Beteiligten.24
- **Überlappende Linien vermeiden:** Linienkreuzungen können die Lesbarkeit stark beeinträchtigen. Diagramme sollten ausreichend Platz bieten.14
- **Konsistente Ausrichtung und Anordnung:** Objekte sollten logisch gruppiert und ausgerichtet werden, um die Struktur hervorzuheben.24
- **Farbcodierung (optional):** Farben können verwendet werden, um verschiedene Arten von Entitäten oder Beziehungen hervorzuheben, sollten aber sparsam und konsistent eingesetzt werden.14
- **Klare und konsistente Namenskonventionen:** Tabellen- und Attributnamen sollten den im Data Dictionary definierten Namen entsprechen und verständlich sein.14
- **Korrekte Darstellung von Kardinalitäten:** Die Beziehungen (1:1, 1:N, M:N) müssen korrekt abgebildet werden, da sie wesentliche Geschäftsregeln widerspiegeln.24
- **Keine Instanzen, sondern Entitätstypen darstellen:** ERDs zeigen Entitätsmengen (Tabellen), nicht einzelne Datensätze.19
- **Attribute nicht mit Entitäten verwechseln:** Attribute sind Eigenschaften einer Entität, keine eigenständigen Entitäten (es sei denn, es handelt sich um komplexe Attribute, die als eigene Entität modelliert werden sollten).24
- **Lesefluss von links nach rechts oder oben nach unten beibehalten:** Ein konsistenter Lesefluss verbessert die Verständlichkeit.24

Die Einhaltung dieser Praktiken stellt sicher, dass das ER-Diagramm ein effektives Kommunikationsmittel bleibt und die zugrundeliegende Datenbankstruktur präzise repräsentiert.

## 3. Schnittstellendesign-Spezifikation (API)

Die Schnittstellen der Coreschicht sind entscheidend für die Interaktion mit anderen Systemteilen (z.B. Frontend-Anwendungen, mobile Apps, andere Backend-Dienste) sowie potenziell mit externen Systemen. Eine klare, konsistente und gut dokumentierte API-Spezifikation ist unerlässlich für eine effiziente Entwicklung, Integration und Wartung.25 Dieses Kapitel fokussiert sich primär auf RESTful APIs, die als moderner Standard für Web-Schnittstellen gelten.27

### 3.1. Interne Schnittstellen

Interne Schnittstellen ermöglichen die Kommunikation und den Datenaustausch zwischen der Coreschicht und anderen Komponenten innerhalb der Gesamtarchitektur der Anwendung.29

#### 3.1.1. REST-API für Kernfunktionalitäten

Die primäre interne Schnittstelle wird als RESTful API (Representational State Transfer) realisiert. REST-APIs nutzen Standard-HTTP-Methoden, um Operationen auf Ressourcen auszuführen, die durch URIs identifiziert werden.27

##### 3.1.1.1. Basis-URL

Alle Endpunkte der Coreschicht-API werden unter einer gemeinsamen Basis-URL erreichbar sein, die auch die Versionierung der API beinhaltet.

Beispiel: https://api.example.com/core/v1/

Die Verwendung von v1 im Pfad kennzeichnet die erste Hauptversion der API.30

##### 3.1.1.2. Authentifizierung und Autorisierung

Jeder Zugriff auf die API muss authentifiziert und autorisiert werden.

- **Authentifizierung:**
    
    - Die primäre Authentifizierungsmethode für Endbenutzer-initiierte Anfragen (z.B. vom Frontend) erfolgt über **OAuth 2.0** (Authorization Code Flow oder Client Credentials Flow, je nach Anwendungsfall).31 JWTs (JSON Web Tokens) werden als Bearer-Token im `Authorization`-Header übertragen. Die JWTs müssen serverseitig validiert werden (Signatur, Ablaufdatum, Aussteller, Zielgruppe).31
    - Für rein serverseitige Kommunikation zwischen vertrauenswürdigen internen Diensten können **API-Keys** verwendet werden, die ebenfalls im HTTP-Header (z.B. `X-API-Key`) übertragen werden.31 API-Keys müssen sicher generiert, gespeichert und rotiert werden können.
    - Basisauthentifizierung (Username/Passwort im Header) ist aufgrund ihrer Unsicherheit zu vermeiden, es sei denn, sie wird ausschließlich über HTTPS in stark kontrollierten, nicht-produktiven Umgebungen eingesetzt.31
- **Autorisierung:**
    
    - Nach erfolgreicher Authentifizierung wird die Autorisierung auf Basis von Rollen und Berechtigungen durchgeführt (Role-Based Access Control - RBAC).32 Die im JWT enthaltenen `scopes` oder `roles` (oder aus einer Benutzerdatenbank abgerufene Rollen) bestimmen, auf welche Ressourcen und Operationen der Benutzer oder Dienst zugreifen darf.
    - Detaillierte Spezifikationen zu Rollen und Berechtigungen sind im Sicherheitskonzept (Kapitel 5.2.2) definiert.

Die Sicherheit der Authentifizierungs- und Autorisierungsmechanismen ist von höchster Priorität. Passwörter und API-Schlüssel dürfen niemals in Klartext übertragen oder gespeichert werden und sollten stets über HTTPS gesendet werden.27

##### 3.1.1.3. Datenformate (Request/Response)

- **Request Body Format:** Für Anfragen, die Daten im Body übertragen (z.B. POST, PUT, PATCH), wird ausschließlich das **JSON (JavaScript Object Notation)** Format verwendet.27 Der `Content-Type`-Header der Anfrage muss auf `application/json` gesetzt sein.
- **Response Body Format:** Antworten der API werden ebenfalls im JSON-Format ausgeliefert.27 Der `Content-Type`-Header der Antwort wird auf `application/json; charset=utf-8` gesetzt. XML wird aufgrund der geringeren Verbreitung und des höheren Verarbeitungsaufwands im Kontext moderner Web-APIs nicht standardmäßig unterstützt.28

Die JSON-Strukturen für Requests und Responses müssen klar definiert sein (siehe OpenAPI-Spezifikation in Kapitel 3.3).

##### 3.1.1.4. HTTP-Statuscodes

Die API verwendet Standard-HTTP-Statuscodes, um das Ergebnis einer Anfrage anzuzeigen.27 Dies ermöglicht es Clients, standardisiert auf verschiedene Situationen zu reagieren. Wichtige Statuscodes sind:

- **2xx (Erfolg):**
    - `200 OK`: Standardantwort für erfolgreiche GET-, PUT-, PATCH- oder DELETE-Anfragen.
    - `201 Created`: Antwort für erfolgreiche POST-Anfragen, die eine neue Ressource erstellt haben. Die Antwort sollte einen `Location`-Header mit der URI der neu erstellten Ressource enthalten.
    - `204 No Content`: Antwort für erfolgreiche Anfragen, die keinen Antwortkörper zurückgeben (z.B. erfolgreiche DELETE-Anfrage).
- **3xx (Umleitung):**
    - `304 Not Modified`: Wird verwendet, um Caching-Mechanismen zu unterstützen.
- **4xx (Client-Fehler):**
    - `400 Bad Request`: Die Anfrage war fehlerhaft oder konnte nicht verarbeitet werden (z.B. ungültiges JSON, fehlende Pflichtfelder, Validierungsfehler). Die Antwort sollte eine detailliertere Fehlermeldung im JSON-Format enthalten.28
    - `401 Unauthorized`: Authentifizierung ist fehlgeschlagen oder erforderlich, aber nicht vorhanden.28
    - `403 Forbidden`: Der authentifizierte Benutzer hat keine Berechtigung, auf die angeforderte Ressource oder Operation zuzugreifen.28
    - `404 Not Found`: Die angeforderte Ressource existiert nicht.28
    - `405 Method Not Allowed`: Die verwendete HTTP-Methode ist für die angeforderte Ressource nicht zulässig.
    - `409 Conflict`: Die Anfrage konnte aufgrund eines Konflikts mit dem aktuellen Zustand der Ressource nicht abgeschlossen werden (z.B. Versuch, eine eindeutige Ressource zu erstellen, die bereits existiert).
    - `429 Too Many Requests`: Der Client hat zu viele Anfragen in einem bestimmten Zeitraum gesendet (Ratenbegrenzung).
- **5xx (Server-Fehler):**
    - `500 Internal Server Error`: Ein unerwarteter Fehler ist auf dem Server aufgetreten. Es sollten keine sensiblen Fehlerdetails an den Client weitergegeben werden.28
    - `503 Service Unavailable`: Der Server ist temporär nicht verfügbar (z.B. wegen Überlastung oder Wartung).

Eine konsistente Verwendung von HTTP-Statuscodes ist entscheidend für die Interoperabilität und Robustheit der API-Clients.

##### 3.1.1.5. Endpunktspezifikationen (Beispiele)

Die Endpunkte der API folgen den REST-Prinzipien, wobei Pfade Substantive im Plural verwenden, um Sammlungen von Ressourcen darzustellen, und HTTP-Methoden die auszuführenden Aktionen definieren.27

**Beispiel: Ressourcenverwaltung für "Produkte"**

- **`GET /core/v1/produkte`**
    
    - **Beschreibung:** Ruft eine Liste aller Produkte ab.
    - **Parameter (Query):**
        - `limit` (optional, integer): Maximale Anzahl der zurückzugebenden Produkte (für Paginierung).
        - `offset` (optional, integer): Anzahl der zu überspringenden Produkte (für Paginierung).
        - `sortBy` (optional, string): Feld, nach dem sortiert werden soll (z.B. `name`, `preis`).
        - `sortOrder` (optional, enum: `asc`, `desc`): Sortierreihenfolge.
        - Filterparameter (z.B. `kategorie`, `minPreis`).
    - **Erfolgsantwort (`200 OK`):** JSON-Array von Produktobjekten.
    - **Fehlerantworten:** `401`, `403`.
- **`POST /core/v1/produkte`**
    
    - **Beschreibung:** Erstellt ein neues Produkt.
    - **Request Body (JSON):** Produktobjekt mit den erforderlichen Attributen (z.B. `name`, `beschreibung`, `preis`).
    - **Erfolgsantwort (`201 Created`):** JSON-Objekt des neu erstellten Produkts. `Location`-Header mit URI des neuen Produkts.
    - **Fehlerantworten:** `400` (Validierungsfehler), `401`, `403`, `409` (falls Produkt mit gleichem eindeutigen Bezeichner bereits existiert).
- **`GET /core/v1/produkte/{produktId}`**
    
    - **Beschreibung:** Ruft ein spezifisches Produkt anhand seiner ID ab.
    - **Parameter (Path):** `produktId` (string/integer, je nach ID-Format).
    - **Erfolgsantwort (`200 OK`):** JSON-Objekt des Produkts.
    - **Fehlerantworten:** `401`, `403`, `404` (Produkt nicht gefunden).
- **`PUT /core/v1/produkte/{produktId}`**
    
    - **Beschreibung:** Aktualisiert ein bestehendes Produkt vollständig. Alle Felder des Produkts müssen im Request Body mitgesendet werden.
    - **Parameter (Path):** `produktId`.
    - **Request Body (JSON):** Vollständiges Produktobjekt mit den aktualisierten Werten.
    - **Erfolgsantwort (`200 OK`):** JSON-Objekt des aktualisierten Produkts.
    - **Fehlerantworten:** `400` (Validierungsfehler), `401`, `403`, `404`.
- **`PATCH /core/v1/produkte/{produktId}`**
    
    - **Beschreibung:** Aktualisiert ein bestehendes Produkt partiell. Nur die zu ändernden Felder müssen im Request Body mitgesendet werden.
    - **Parameter (Path):** `produktId`.
    - **Request Body (JSON):** Produktobjekt mit den zu aktualisierenden Feldern.
    - **Erfolgsantwort (`200 OK`):** JSON-Objekt des aktualisierten Produkts.
    - **Fehlerantworten:** `400` (Validierungsfehler), `401`, `403`, `404`.
- **`DELETE /core/v1/produkte/{produktId}`**
    
    - **Beschreibung:** Löscht ein spezifisches Produkt.
    - **Parameter (Path):** `produktId`.
    - **Erfolgsantwort (`204 No Content`):** Kein Antwortkörper.
    - **Fehlerantworten:** `401`, `403`, `404`.

Diese Struktur wird für alle Ressourcen der Coreschicht analog angewendet. Die genauen Definitionen aller Endpunkte, ihrer Parameter, Request- und Response-Schemata werden in der OpenAPI-Spezifikation (Kapitel 3.3) dokumentiert. Die Implementierung von Filterung, Sortierung und Paginierung ist entscheidend für die Benutzerfreundlichkeit und Performance bei großen Datenmengen.26

##### 3.1.1.6. Versionierung

API-Versionierung ist notwendig, um Änderungen an der API vorzunehmen, ohne bestehende Clients zu beeinträchtigen. Die Hauptversion der API wird im URI-Pfad angegeben (z.B. `/v1/`, `/v2/`).30 Kleinere, abwärtskompatible Änderungen (Minor- und Patch-Versionen) erfordern keine neue URI-Version, sollten aber in der API-Dokumentation vermerkt werden.30 Breaking Changes führen immer zu einer neuen Hauptversion im URI.

### 3.2. Externe Schnittstellen (falls zutreffend)

Falls die Coreschicht mit externen Diensten oder Systemen von Drittanbietern kommunizieren muss (z.B. Zahlungsanbieter, externe Datenquellen, Benachrichtigungsdienste), werden diese Schnittstellen hier spezifiziert. Für jede externe Schnittstelle sind folgende Informationen zu dokumentieren:

- **Name des externen Dienstes/Systems.**
- **Zweck der Integration.**
- **Kommunikationsprotokoll** (z.B. REST, SOAP, gRPC).
- **Authentifizierungsmethode** (z.B. API-Key, OAuth 2.0).
- **Datenformate.**
- **Wichtige Endpunkte/Funktionen, die genutzt werden.**
- **Fehlerbehandlung und Retry-Mechanismen.**
- **Performance- und Zuverlässigkeitserwartungen.**

Die Spezifikation externer Schnittstellen ist oft von der Dokumentation des Drittanbieters abhängig.

### 3.3. API-Dokumentation (OpenAPI/Swagger)

Eine umfassende und aktuelle API-Dokumentation ist für Entwickler, die die API nutzen, unerlässlich.25 Die API der Coreschicht wird gemäß der **OpenAPI Specification (OAS)**, Version 3.x (früher bekannt als Swagger) 35, dokumentiert. Die OpenAPI-Spezifikation ist eine standardisierte, sprachunabhängige Beschreibung von REST-APIs, die sowohl von Menschen als auch von Maschinen gelesen werden kann.35

Die OpenAPI-Definitionsdatei (üblicherweise im YAML- oder JSON-Format) wird folgende Informationen für jeden Endpunkt enthalten 37:

- **Pfade und Operationen:** Alle verfügbaren Endpunkte und die unterstützten HTTP-Methoden (GET, POST, PUT, PATCH, DELETE etc.).
- **Parameter:** Definition von Pfad-, Query-, Header- und Cookie-Parametern, einschließlich ihrer Namen, Datentypen, ob sie erforderlich sind und Beschreibungen.
- **Request Bodies:** Beschreibung der erwarteten Request-Payloads, einschließlich Medientypen (z.B. `application/json`) und Schemadefinitionen für die Datenstrukturen.
- **Responses:** Beschreibung möglicher HTTP-Statuscodes für jede Operation und die zugehörigen Response Bodies, einschließlich Medientypen und Schemadefinitionen.
- **Schemadefinitionen (Components):** Wiederverwendbare Definitionen für Datenmodelle (z.B. `Produkt`, `Benutzer`), die in Request- und Response-Bodies verwendet werden. Dies fördert Konsistenz und reduziert Redundanz.
- **Sicherheitsdefinitionen (Security Schemes):** Beschreibung der verwendeten Authentifizierungs- und Autorisierungsmechanismen (z.B. OAuth 2.0, API-Key).
- **Metainformationen:** Titel, Version, Beschreibung der API, Kontaktinformationen, Lizenzinformationen.

Werkzeuge wie Swagger Editor oder Swagger UI können verwendet werden, um die OpenAPI-Spezifikation zu erstellen, zu validieren und interaktiv darzustellen.35 Swagger UI ermöglicht es Entwicklern, die API direkt im Browser zu testen. Postman-Templates können ebenfalls als Grundlage für die Dokumentation dienen.25 Die OpenAPI-Datei sollte versioniert und zusammen mit dem Quellcode der Coreschicht verwaltet werden.

### 3.4. Best Practices für API-Design

Bei der Gestaltung der APIs der Coreschicht werden folgende Best Practices berücksichtigt, um eine hohe Qualität, Benutzerfreundlichkeit und Wartbarkeit sicherzustellen:

- **Konsistenz:** Einheitliche Namenskonventionen für Pfade, Parameter und Felder. Konsistente Verwendung von HTTP-Methoden und Statuscodes.27
- **Ressourcenorientierung:** Design der API um Ressourcen herum, nicht um Aktionen (Verben in Pfaden vermeiden, außer für spezifische nicht-CRUD-Operationen).27
- **Korrekte Verwendung von HTTP-Methoden:** GET für Abruf, POST für Erstellung, PUT für vollständige Aktualisierung, PATCH für partielle Aktualisierung, DELETE für Löschung.28
- **Statuslose Kommunikation:** Jede Anfrage vom Client an den Server muss alle Informationen enthalten, die zur Bearbeitung der Anfrage erforderlich sind. Der Server speichert keinen Client-Kontext zwischen Anfragen (fundamental für REST).32
- **Sicherheit:** Implementierung robuster Authentifizierung und Autorisierung, Verwendung von HTTPS für die gesamte Kommunikation, Validierung aller Eingaben.27 Sensible Daten wie Passwörter oder API-Keys dürfen niemals in URLs erscheinen.27
- **Paginierung, Filterung und Sortierung:** Für Endpunkte, die Listen von Ressourcen zurückgeben, müssen Mechanismen zur Paginierung (z.B. `limit`/`offset` oder cursor-basiert), Filterung und Sortierung bereitgestellt werden, um die Performance zu optimieren und die Datenmenge zu kontrollieren.26
- **Fehlerbehandlung:** Klare und informative Fehlermeldungen im JSON-Format zurückgeben, ohne interne Implementierungsdetails preiszugeben.28
- **Caching-Unterstützung:** Verwendung von HTTP-Headern wie `ETag` und `Last-Modified` zur Unterstützung von Caching auf Client- oder Proxy-Ebene, um die Serverlast zu reduzieren und die Antwortzeiten zu verbessern.27
- **Ratenbegrenzung (Rate Limiting):** Schutz der API vor Missbrauch und Überlastung durch Implementierung von Ratenbegrenzungen pro Client/Benutzer.26
- **Dokumentation:** Umfassende und aktuelle Dokumentation unter Verwendung von Standards wie OpenAPI.25

Die Beachtung dieser Prinzipien führt zu APIs, die nicht nur funktional, sondern auch sicher, performant und einfach zu integrieren sind. Die API-Spezifikation sollte als "Vertrag" zwischen dem API-Anbieter (Coreschicht) und den API-Konsumenten betrachtet werden.26

## 4. UI/UX-Design-Spezifikationen (für Administrations- und Konfigurationsoberflächen)

Obwohl die Coreschicht primär Backend-Funktionalitäten bereitstellt, können spezifische Benutzeroberflächen (UIs) für Administrations-, Konfigurations- oder Überwachungsaufgaben erforderlich sein. Diese UIs interagieren direkt mit den APIs der Coreschicht. Dieses Kapitel definiert die Spezifikationen für das User Interface (UI) und die User Experience (UX) dieser speziellen Oberflächen. Der Designprozess folgt typischerweise einer Progression von Wireframes über Mockups zu klickbaren Prototypen.39

### 4.1. Wireframes

Wireframes sind grundlegende, schematische Darstellungen der Bildschirmlayouts und der Informationsarchitektur. Sie fokussieren auf Struktur, Inhaltshierarchie und grundlegende Funktionalität, ohne visuelle Designelemente wie Farben oder detaillierte Grafiken.39

#### 4.1.1. Zweck und Detailgrad

Der Zweck von Wireframes in diesem Kontext ist:

- Definition der grundlegenden Struktur und des Layouts der Administrationsseiten.
- Festlegung der Anordnung von UI-Elementen (z.B. Navigationsmenüs, Tabellen, Formulare, Schaltflächen).
- Visualisierung der Benutzerflüsse für typische Administrationsaufgaben.
- Frühzeitige Abstimmung über Funktionalität und Informationsarchitektur mit den Stakeholdern.

Wireframes für die Coreschicht-Administrationsoberflächen werden in der Regel als Low-Fidelity-Darstellungen erstellt, um schnelle Iterationen und Feedbackschleifen zu ermöglichen.39 Sie sollten jedoch genügend Details enthalten, um die Kernfunktionalitäten und die Navigation klar zu vermitteln.

#### 4.1.2. Werkzeuge

Für die Erstellung von Wireframes können verschiedene Werkzeuge eingesetzt werden:

- **Balsamiq:** Bekannt für seinen skizzenhaften Stil, der den Low-Fidelity-Charakter betont und Diskussionen auf die Struktur lenkt.42
- **Figma:** Ein kollaboratives All-in-One-Tool, das auch für Wireframing gut geeignet ist und einen nahtlosen Übergang zu Mockups und Prototypen ermöglicht.42
- **Moqups:** Einsteigerfreundliches Web-Tool für Wireframes, Mockups und Diagramme.42
- **ClickUp:** Bietet Whiteboard-Funktionen und Vorlagen für Wireframing im Rahmen einer Projektmanagement-Plattform.46
- **Visily:** Bietet KI-gestützte Wireframing-Funktionen, z.B. Umwandlung von Screenshots in editierbare Wireframes.42
- Auch einfache Werkzeuge wie Stift und Papier oder Whiteboards können für erste Entwürfe verwendet werden.41

Die Wahl des Werkzeugs hängt von den Präferenzen des Teams und den Anforderungen an Kollaboration und Detailgrad ab. Figma wird aufgrund seiner Vielseitigkeit und Kollaborationsmöglichkeiten oft bevorzugt.

#### 4.1.3. Beispiele (Beschreibung der wichtigsten Ansichten)

Die Wireframes werden die wichtigsten Ansichten der Administrationsoberfläche abdecken. Typische Ansichten könnten sein:

- **Dashboard/Übersichtsseite:** Anzeige wichtiger Systemstatistiken, Benachrichtigungen oder schneller Zugriff auf häufig genutzte Funktionen.
- **Benutzerverwaltung:** Liste der Benutzer, Formulare zum Anlegen/Bearbeiten von Benutzern, Zuweisung von Rollen und Berechtigungen.
- **Datenmanagement-Ansichten:** Tabellarische Darstellung von Kerndatenobjekten (z.B. Produkte, Bestellungen), mit Funktionen zum Suchen, Filtern, Erstellen, Bearbeiten und Löschen von Einträgen.
- **Konfigurationsseiten:** Formulare zur Einstellung systemspezifischer Parameter der Coreschicht.
- **Log-Ansicht:** Anzeige von System- oder Audit-Logs mit Filter- und Suchfunktionen.

Jeder Wireframe wird die Platzierung von Navigationselementen, Hauptinhaltsbereichen, Aktionsschaltflächen und wichtigen Datenfeldern skizzieren. Die Verwendung von echtem oder realitätsnahem Beispieltext anstelle von "Lorem Ipsum" wird empfohlen, um die Struktur besser beurteilen zu können.41

#### 4.1.4. Informationsarchitektur und Navigation

Ein wesentlicher Bestandteil der Wireframing-Phase ist die Definition der Informationsarchitektur (IA) und des Navigationskonzepts.48 Dies beinhaltet:

- **Strukturierung der Inhalte:** Logische Gruppierung von Funktionen und Informationen.
- **Navigationsmenüs:** Definition der Hauptnavigation (z.B. Seitenleiste, Top-Menü) und ggf. Unternavigation.
- **Benutzerflüsse:** Darstellung, wie Benutzer typische Aufgaben innerhalb der Administrationsoberfläche erledigen (z.B. Anlegen eines neuen Benutzers, Ändern einer Konfigurationseinstellung).

Die IA sollte intuitiv sein und es Administratoren ermöglichen, gesuchte Informationen und Funktionen schnell zu finden und zu bedienen.49 Die Konsistenz in der Navigation und Struktur über verschiedene Ansichten hinweg ist dabei entscheidend.41

### 4.2. Mockups

Mockups sind detailliertere, oft farbige, aber nicht interaktive Entwürfe der Benutzeroberfläche. Sie bauen auf den Wireframes auf und fügen visuelle Designelemente hinzu, um ein realistischeres Bild des Endprodukts zu vermitteln.39

#### 4.2.1. Visuelles Design und Detailtiefe

Mockups für die Administrationsoberfläche der Coreschicht werden folgende Aspekte des visuellen Designs konkretisieren:

- **Farbpalette:** Anwendung der im Styleguide (siehe Kapitel 4.4) definierten Farben.
- **Typografie:** Verwendung der festgelegten Schriftarten, -größen und -schnitte.
- **Ikonografie:** Einsatz spezifischer Icons für Aktionen und Navigationselemente.
- **Layout und Abstände:** Präzisere Definition von Rastern, Abständen und Ausrichtung der Elemente.
- **Visuelle Darstellung von UI-Komponenten:** Detaillierte Gestaltung von Schaltflächen, Formularfeldern, Tabellen, Benachrichtigungen etc.

Mockups sind statisch und dienen primär der Abstimmung des visuellen Erscheinungsbildes.39 Sie sollten High-Fidelity sein, um eine genaue Vorstellung vom Look-and-Feel zu geben.

#### 4.2.2. Werkzeuge

Viele der für Wireframing genannten Werkzeuge eignen sich auch für die Erstellung von Mockups, insbesondere solche, die einen fließenden Übergang von Low- zu High-Fidelity ermöglichen:

- **Figma:** Sehr stark für detailliertes UI-Design und Mockup-Erstellung.42
- **Sketch:** Ein weiteres professionelles UI-Design-Tool, primär für macOS.43
- **Adobe XD:** Teil der Adobe Creative Cloud, bietet umfangreiche Design- und Prototyping-Funktionen.50
- **Visily:** Kann auch für High-Fidelity Mockups verwendet werden, insbesondere durch seine KI-Funktionen und Vorlagen.47
- **Moqups:** Unterstützt ebenfalls den Übergang von Wireframes zu detaillierteren Mockups.45

Die Wahl des Werkzeugs wird oft durch die bereits im Team etablierten Tools und die Notwendigkeit der Kollaboration bestimmt.

#### 4.2.3. Beispiele (Beschreibung der wichtigsten Ansichten)

Für alle in Kapitel 4.1.3 beschriebenen Wireframe-Ansichten werden entsprechende Mockups erstellt. Diese zeigen die finale visuelle Gestaltung:

- **Dashboard:** Mit realitätsnahen Diagrammen, Farbschemata und Icons.
- **Benutzerverwaltung:** Formulare und Tabellen im finalen Design, inklusive Statusanzeigen (z.B. aktiv/inaktiv).
- **Datenmanagement-Ansichten:** Tabellen mit korrekter Typografie, Farbcodierung für bestimmte Zustände, gestaltete Aktionsschaltflächen.
- **Konfigurationsseiten:** Klar strukturierte Formulare mit ansprechenden Eingabeelementen.

Die Mockups dienen als Vorlage für die Frontend-Entwicklung der Administrationsoberfläche.

### 4.3. Prototypen (klickbar)

Klickbare Prototypen sind interaktive Modelle der Benutzeroberfläche, die den Benutzerfluss simulieren und es ermöglichen, die User Experience (UX) vor der eigentlichen Implementierung zu testen.39

#### 4.3.1. Interaktivität und Benutzerflüsse

Die Prototypen für die Administrationsoberfläche werden folgende Interaktionen ermöglichen:

- **Navigation:** Klickbare Menüpunkte, die zu den entsprechenden Seiten führen.
- **Formularinteraktionen:** Simulation von Eingaben in Formularfelder (ohne tatsächliche Datenverarbeitung), Auswahl aus Dropdowns.
- **Schaltflächen-Interaktionen:** Klickbare Schaltflächen, die zu anderen Ansichten navigieren oder Zustandsänderungen simulieren (z.B. Anzeige einer Erfolgs- oder Fehlermeldung).
- **Tabelleninteraktionen:** Simulation von Sortier- oder Filterfunktionen.

Ziel ist es, die wichtigsten Benutzerflüsse (Use Cases) durch die Administrationsoberfläche erlebbar zu machen.39 Die Prototypen sind in der Regel High-Fidelity in Bezug auf das visuelle Design (basierend auf den Mockups), aber die Interaktionen sind simuliert und greifen nicht auf das tatsächliche Backend zu.

#### 4.3.2. Werkzeuge

Viele moderne UI/UX-Designwerkzeuge bieten integrierte Prototyping-Funktionen:

- **Figma:** Ermöglicht das Verknüpfen von Frames und das Definieren von Übergängen und einfachen Interaktionen, um klickbare Prototypen zu erstellen.43
- **Adobe XD:** Bietet ebenfalls starke Prototyping-Funktionen, einschließlich Auto-Animate für komplexere Übergänge.50
- **Sketch:** In Kombination mit Plugins oder anderen Werkzeugen wie InVision oder Marvel für Prototyping nutzbar.43
- **Justinmind:** Spezialisiert auf interaktive Prototypen, ermöglicht auch komplexere Logik und Datenmanipulationen in Prototypen.42
- **ProtoPie:** Ein leistungsstarkes Werkzeug für High-Fidelity-Prototyping mit Fokus auf komplexe Interaktionen, kann Designs aus Figma oder Sketch importieren.43
- **Marvel:** Ein weiteres Tool für schnelles Prototyping und Testing.43
- **UXPin:** Ermöglicht die Erstellung von Prototypen, die sehr nah an das Endprodukt herankommen, inklusive Code-basierter Designelemente.42

Figma und Adobe XD sind oft ausreichend für die meisten klickbaren Prototypen im Administrationsbereich. Spezialisierte Werkzeuge wie ProtoPie oder Justinmind kommen bei Bedarf für komplexere Interaktionssimulationen in Frage.

#### 4.3.3. Zu testende Szenarien

Die klickbaren Prototypen werden verwendet, um spezifische Benutzerszenarien zu testen und Feedback zur Usability zu sammeln. Beispiele für Testszenarien:

- **Anlegen eines neuen Benutzers:** Kann ein Administrator den Prozess von Anfang bis Ende intuitiv durchlaufen?
- **Ändern einer wichtigen Systemeinstellung:** Ist der Pfad zur Einstellung klar? Sind die Optionen verständlich?
- **Suchen und Filtern von Daten in einer Tabelle:** Funktionieren die Interaktionen wie erwartet und sind sie effizient?
- **Verständlichkeit von Fehlermeldungen und Hinweisen (simuliert).**

Die Ergebnisse dieser Tests fließen direkt in die Optimierung des UI/UX-Designs ein, bevor Entwicklungsressourcen gebunden werden.39

### 4.4. Styleguide

Der Styleguide definiert die visuellen und gestalterischen Grundlagen für die Administrationsoberfläche. Er stellt Konsistenz über alle Ansichten und Komponenten hinweg sicher und dient als Referenz für Designer und Entwickler.52 Er ist ein zentrales Element eines umfassenderen Design Systems.54

#### 4.4.1. Farbpalette

- **Primärfarben:** Die Hauptfarben, die das Branding der Administrationsoberfläche prägen (z.B. für Hintergründe, Navigationselemente).
- **Sekundärfarben:** Akzentfarben zur Hervorhebung von aktiven Elementen, Links oder wichtigen Informationen.
- **Statusfarben:** Farben für Erfolgsmeldungen (grün), Warnungen (gelb/orange), Fehlermeldungen (rot) und Informationshinweise (blau).
- **Neutrale Farben:** Graustufen für Text, Hintergründe, Trennlinien und deaktivierte Elemente.

Für jede Farbe werden die exakten Farbwerte (z.B. HEX, RGB, HSL) spezifiziert.52

#### 4.4.2. Typografie

- **Schriftfamilien:** Definition der primären Schriftart für Überschriften und der sekundären Schriftart für Fließtext und UI-Elemente.
- **Schriftschnitte und -größen:** Festlegung verschiedener Schriftschnitte (z.B. Regular, Bold, Italic) und einer Hierarchie von Schriftgrößen für unterschiedliche Textelemente (z.B. H1, H2, H3, Paragraph, Label).
- **Zeilenhöhe und Zeichenabstand:** Vorgaben für optimale Lesbarkeit.
- **Textfarben:** Definition der Standardtextfarbe und Farben für Links oder hervorgehobenen Text in Abstimmung mit der Farbpalette.

Die typografischen Regeln gewährleisten ein einheitliches und gut lesbares Erscheinungsbild.52

#### 4.4.3. Ikonografie

- **Icon-Set:** Auswahl oder Erstellung eines konsistenten Icon-Sets (z.B. Material Design Icons, Font Awesome oder ein benutzerdefiniertes Set).
- **Stil:** Definition des visuellen Stils der Icons (z.B. outlined, filled, two-tone).
- **Größen:** Standardgrößen für Icons in verschiedenen Kontexten (z.B. in Schaltflächen, Menüs, Tabellen).
- **Verwendungsrichtlinien:** Beispiele für die korrekte Anwendung von Icons.52

Icons tragen maßgeblich zur intuitiven Bedienbarkeit bei.

#### 4.4.4. Abstände und Layout-Raster

- **Grid-System:** Definition eines Basisrasters (z.B. 8-Punkt-Grid), das für die Ausrichtung und Platzierung aller UI-Elemente verwendet wird. Dies sorgt für visuelle Harmonie und Konsistenz.
- **Abstandsregeln (Spacing):** Festlegung von Standardabständen zwischen Elementen (z.B. Margin, Padding) basierend auf dem Grid-System.
- **Responsive Design Vorgaben:** Wie sich das Layout und die Abstände auf verschiedenen Bildschirmgrößen anpassen (falls die Administrationsoberfläche responsiv sein soll).53

Ein durchdachtes Raster- und Abstandssystem ist fundamental für ein professionelles und aufgeräumtes UI-Design.52

#### 4.4.5. UI-Komponentenbibliothek

Die UI-Komponentenbibliothek ist eine Sammlung wiederverwendbarer UI-Elemente, die in der Administrationsoberfläche zum Einsatz kommen. Sie ist ein praktischer Teil des Styleguides und oft der Kern eines Design Systems.54 Für jede Komponente werden definiert:

- **Name der Komponente** (z.B. Button, Input Field, Dropdown, Table, Modal, Notification).
- **Visuelle Spezifikation:** Aussehen basierend auf Farben, Typografie, Icons und Abständen des Styleguides.
- **Zustände:** Definition verschiedener Zustände der Komponente (z.B. für einen Button: default, hover, active, disabled, loading).52
- **Verhaltensregeln:** Wie die Komponente auf Benutzerinteraktionen reagiert.
- **Anwendungsbeispiele ("Do's and Don'ts"):** Richtlinien für den korrekten Einsatz der Komponente.52

Beispiele für UI-Komponenten:

- **Schaltflächen (Buttons):** Primär-, Sekundär-, Tertiär-Buttons; Buttons mit Icons.
- **Formularelemente:** Textfelder, Textareas, Checkboxen, Radiobuttons, Select-Dropdowns, Datepicker.
- **Tabellen:** Darstellung, Sortier- und Filterindikatoren, Paginierungselemente.
- **Navigationselemente:** Menüs, Tabs, Breadcrumbs.
- **Feedback-Elemente:** Modale Dialoge, Popovers, Toasts/Notifications, Ladeindikatoren.

Diese Bibliothek stellt sicher, dass Entwickler auf standardisierte und bereits gestaltete Elemente zurückgreifen können, was die Entwicklungszeit verkürzt und die Konsistenz der UI erhöht.49 Die UI-Komponenten sollten so gestaltet sein, dass sie die Prinzipien einer guten Admin-UI erfüllen: Benutzerfreundlichkeit, klare Layouts und Anpassbarkeit.49

## 5. Sicherheitskonzept

Das Sicherheitskonzept beschreibt die geplanten Maßnahmen zur Gewährleistung der Vertraulichkeit, Integrität und Verfügbarkeit der Daten und Funktionen der Coreschicht. Sicherheit ist kein nachträglicher Gedanke, sondern ein integraler Bestandteil des gesamten Entwicklungszyklus ("Secure by Design" und "Secure Software Development Lifecycle" - SDLC).57 Die hier definierten Maßnahmen müssen in allen Phasen des Datenbankdesigns, der API-Entwicklung und der UI/UX-Gestaltung für Administrationstools berücksichtigt werden. Dieses Konzept orientiert sich an etablierten Sicherheitspraktiken und adressiert gängige Bedrohungen.

### 5.1. Grundlagen und Prinzipien

#### 5.1.1. Layered Security (Defense in Depth)

Das Sicherheitskonzept basiert auf dem Prinzip der "Layered Security" oder "Defense in Depth".58 Dies bedeutet, dass mehrere Sicherheitsebenen implementiert werden, sodass ein Angreifer, der eine einzelne Schutzmaßnahme überwindet, immer noch auf weitere Barrieren trifft. Diese Ebenen umfassen typischerweise Netzwerk-, Anwendungs-, Daten- und physische Sicherheit.57 Für die Coreschicht sind insbesondere die Anwendungs- und Datensicherheit relevant, die durch Maßnahmen auf Netzwerkebene (z.B. Firewalls, die hier nicht im Detail spezifiziert werden, aber vorausgesetzt werden) ergänzt werden.

#### 5.1.2. Prinzip der geringsten Rechte (Principle of Least Privilege)

Benutzern und Systemkomponenten werden nur die minimal notwendigen Berechtigungen erteilt, die sie zur Erfüllung ihrer Aufgaben benötigen.31 Dies minimiert den potenziellen Schaden im Falle einer Kompromittierung eines Kontos oder einer Komponente. Dieses Prinzip wird durch das Autorisierungsmodell (siehe 5.2.2) konsequent umgesetzt.

### 5.2. Authentifizierung und Autorisierung

Eine robuste Authentifizierung und Autorisierung ist fundamental, um sicherzustellen, dass nur legitime Benutzer und Systeme auf die Coreschicht zugreifen und nur die ihnen erlaubten Aktionen durchführen können.32

#### 5.2.1. Authentifizierungsmechanismen

Die Coreschicht muss starke Authentifizierungsmechanismen für alle Zugriffe implementieren.

- **Für Benutzer (z.B. über Administrations-UI oder clientseitige Anwendungen):**
    
    - **OAuth 2.0 mit OpenID Connect (OIDC):** Als Standard für die delegierte Authentifizierung.31 Dies ermöglicht es Clients (z.B. Web-Frontends, mobile Apps), Benutzer sicher zu authentifizieren, ohne direkten Zugriff auf deren Anmeldedaten zu haben.
    - **JSON Web Tokens (JWTs):** Nach erfolgreicher Authentifizierung werden JWTs ausgestellt, die als Bearer-Token für nachfolgende API-Anfragen verwendet werden.31 JWTs müssen signiert (z.B. mit RS256 oder ES256) und validiert werden (Signatur, Ablaufdatum, Aussteller, Zielgruppe, `kid`-Header gegen JWK).33
    - **Multi-Faktor-Authentifizierung (MFA):** Für administrative Zugriffe und sensible Operationen ist MFA zwingend erforderlich.60 Dies fügt eine zusätzliche Sicherheitsebene über das reine Passwort hinaus hinzu.
    - **Passwortrichtlinien:** Starke Passwortrichtlinien (Mindestlänge, Komplexität, keine gängigen Passwörter) müssen durchgesetzt werden.60 Passwörter müssen sicher gehasht (z.B. mit Argon2id oder bcrypt) und gesalzen gespeichert werden; niemals in Klartext.33
    - **Konto-Sperrungsrichtlinien:** Nach einer definierten Anzahl fehlgeschlagener Anmeldeversuche wird das Konto temporär gesperrt, um Brute-Force-Angriffe zu erschweren.60
- **Für serverseitige System-zu-System-Kommunikation (interne Dienste):**
    
    - **OAuth 2.0 Client Credentials Flow:** Geeignet für vertrauenswürdige Server-Anwendungen, die im eigenen Namen auf Ressourcen zugreifen.31
    - **API-Keys:** Für einfachere Szenarien können API-Keys verwendet werden. Diese müssen eine hohe Entropie aufweisen, sicher übertragen (z.B. im HTTP-Header `X-API-Key`), serverseitig validiert und regelmäßig rotiert werden.31 API-Keys sollten nicht im Code fest verdrahtet, sondern sicher verwaltet werden (z.B. über Secret-Management-Systeme).

Alle Authentifizierungsdaten (Passwörter, Token, API-Keys) müssen stets über verschlüsselte Verbindungen (HTTPS) übertragen werden.27

#### 5.2.2. Autorisierungsmodell (z.B. RBAC)

Nach erfolgreicher Authentifizierung erfolgt die Autorisierung, um zu bestimmen, welche Aktionen ein authentifizierter Benutzer oder Dienst durchführen darf. Es wird ein **Role-Based Access Control (RBAC)** Modell implementiert.32

- **Rollen:** Definieren Gruppen von Berechtigungen, die typischen Benutzerkategorien oder Systemfunktionen entsprechen (z.B. `Administrator`, `ReadOnlyUser`, `CoreServiceCommunicator`).
- **Berechtigungen:** Spezifische Rechte, die Aktionen auf bestimmten Ressourcen erlauben (z.B. `produkt:lesen`, `produkt:erstellen`, `benutzer:verwalten`).
- **Zuweisung:** Benutzern oder Dienst-Identitäten werden eine oder mehrere Rollen zugewiesen.

Die Autorisierungsentscheidungen werden bei jedem API-Aufruf basierend auf der Rolle/den Berechtigungen des anfragenden Subjekts getroffen. Dies adressiert direkt die OWASP API Security Risiken #1 (Broken Object Level Authorization) und #5 (Broken Function Level Authorization).61

**Tabelle 5.1: Rollen- und Rechteübersicht (Beispiel)**

|   |   |   |   |   |
|---|---|---|---|---|
|**Rolle**|**Beschreibung der Rolle**|**Berechtigungen für Datenzugriff (CRUD - Beispiel: Produkt, Benutzer)**|**Berechtigungen für API-Endpunkte (Beispiel)**|**Zugeordnete Authentifizierungsmethoden**|
|`SystemAdministrator`|Vollständige Kontrolle über das System, Benutzerverwaltung, Konfiguration.|Produkt:CRUDE, Benutzer:CRUDE, Konfiguration:CRUDE|`GET /produkte`, `POST /produkte`, `PUT /produkte/{id}`, `DELETE /produkte/{id}`, `GET /benutzer`, `POST /benutzer`, etc. (alle administrativen Endpunkte)|OAuth 2.0 (mit MFA)|
|`DatenAnalyst`|Kann alle Daten lesen, aber keine Änderungen vornehmen.|Produkt:R, Benutzer:R, Bestellung:R|`GET /produkte`, `GET /produkte/{id}`, `GET /benutzer`, `GET /benutzer/{id}`, `GET /bestellungen`|OAuth 2.0|
|`FrontendService`|Stellt Daten für die Hauptanwendung bereit, kann im Namen von Benutzern Bestellungen erstellen.|Produkt:R, Bestellung:CR (im Kontext des Benutzers), Benutzer:R (eingeschränkt auf eigene Daten des Benutzers)|`GET /produkte`, `GET /produkte/{id}`, `POST /bestellungen` (im Benutzerkontext), `GET /benutzer/me`|OAuth 2.0 (Authorization Code Flow für Benutzer, Client Credentials für eigene Operationen)|
|`InternerBatchService`|Führt Hintergrundaufgaben aus, z.B. Datenaggregation.|Produkt:R, Bestellung:R, AggregierteDaten:CRU|`GET /produkte/all`, `POST /aggregierteDaten`|API-Key oder OAuth 2.0 Client Credentials|

Diese Tabelle ist ein kritisches Werkzeug, um das Prinzip der geringsten Rechte systematisch anzuwenden. Sie muss detailliert für alle relevanten Rollen, Datenobjekte und API-Endpunkte ausgearbeitet werden. Die Granularität der Berechtigungen muss bis auf die Ebene einzelner Objekte und deren Eigenschaften reichen (Object Level und Object Property Level Authorization), um Risiken wie API1:2023 und API3:2023 der OWASP Top 10 zu mitigieren.61

### 5.3. Datensicherheit

Der Schutz der in der Coreschicht gespeicherten und verarbeiteten Daten ist von höchster Bedeutung.

#### 5.3.1. Verschlüsselung von Daten "at rest"

Alle sensiblen Daten, die in der Datenbank oder anderen persistenten Speichern der Coreschicht abgelegt werden, müssen verschlüsselt werden ("encryption at rest").63

- **Algorithmen:** Es sind starke, etablierte symmetrische Verschlüsselungsalgorithmen wie **AES-256 (Advanced Encryption Standard mit 256-Bit Schlüssellänge)** zu verwenden.63
- **Anwendungsbereich:** Dies betrifft insbesondere personenbezogene Daten (PII), Finanzdaten, Authentifizierungsdaten (obwohl Passwörter gehasht und nicht nur verschlüsselt werden) und andere geschäftskritische Informationen.
- **Schlüsselmanagement:** Ein sicheres Schlüsselmanagement ist entscheidend. Die Verschlüsselungsschlüssel müssen sicher generiert, gespeichert, rotiert und verwaltet werden. Hierfür sollte ein dediziertes **Hardware Security Module (HSM)** oder ein **Key Management Service (KMS)** (z.B. AWS KMS, Azure Key Vault, Google Cloud KMS) eingesetzt werden.63 Der Zugriff auf die Schlüssel muss streng kontrolliert und protokolliert werden. Regelmäßige Schlüsselrotation ist ein Muss.
- **Datenbankseitige vs. Applikationsseitige Verschlüsselung:** Je nach Sensitivität und Anforderungen kann die Verschlüsselung auf Datenbankebene (Transparent Data Encryption - TDE) oder auf Applikationsebene (Client-Side Encryption, bevor die Daten in die DB geschrieben werden) erfolgen.64 Applikationsseitige Verschlüsselung bietet oft mehr Kontrolle, erfordert aber sorgfältige Implementierung.

#### 5.3.2. Verschlüsselung von Daten "in transit"

Jegliche Datenübertragung zur und von der Coreschicht sowie zwischen internen Komponenten der Coreschicht (falls diese über ein Netzwerk kommunizieren) muss verschlüsselt werden ("encryption in transit").63

- **Protokoll:** Für die API-Kommunikation (extern und intern) ist ausschließlich **HTTPS (HTTP Secure)** zu verwenden, basierend auf **TLS (Transport Layer Security)** in einer aktuellen Version (mindestens TLS 1.2, bevorzugt TLS 1.3).27
- **Zertifikate:** Es sind gültige digitale Zertifikate von vertrauenswürdigen Zertifizierungsstellen (CAs) zu verwenden.
- **Cipher Suites:** Nur starke und aktuell als sicher geltende Cipher Suites dürfen konfiguriert werden. Veraltete oder schwache Algorithmen (z.B. SSLv3, frühe TLS-Versionen, MD5, SHA1) sind zu deaktivieren.
- **Interne Kommunikation:** Auch die Kommunikation zwischen Microservices oder verschiedenen Instanzen der Coreschicht sollte, wenn sie über ein Netzwerk erfolgt, mittels TLS gesichert werden.

Die konsequente Verschlüsselung von Daten "at rest" und "in transit" schützt vor unbefugtem Zugriff und Datenlecks.

### 5.4. API-Sicherheitsmaßnahmen

Die APIs der Coreschicht sind potenzielle Angriffsvektoren. Daher müssen spezifische Sicherheitsmaßnahmen implementiert werden, die sich insbesondere an den **OWASP API Security Top 10** orientieren.61

- **`API1:2023 Broken Object Level Authorization (BOLA)`:** Strikte Überprüfung bei jedem Zugriff auf ein Objekt (z.B. `GET /produkte/{id}`), ob der authentifizierte Benutzer tatsächlich die Berechtigung hat, auf _dieses spezifische Objekt_ zuzugreifen, nicht nur auf die Objektart allgemein. Dies wird durch das RBAC-Modell und detaillierte Berechtigungsprüfungen in der Geschäftslogik erreicht.61
- **`API2:2023 Broken Authentication`:** Implementierung der robusten Authentifizierungsmechanismen wie in 5.2.1 beschrieben (OAuth 2.0, JWT-Validierung, MFA, sichere Passwort-Policies und -Speicherung).61
- **`API3:2023 Broken Object Property Level Authorization (BOPLA)`:**
    - **Excessive Data Exposure:** API-Antworten dürfen nur die Datenfelder enthalten, die für den jeweiligen Benutzer und Anwendungsfall tatsächlich benötigt und erlaubt sind. Sensible Felder müssen herausgefiltert werden.
    - **Mass Assignment:** Bei Operationen, die Datenobjekte entgegennehmen (z.B. PUT, POST, PATCH), dürfen nur die Felder aktualisiert werden, die vom Benutzer geändert werden dürfen. Eine Whitelist erlaubter Felder ist zu verwenden, um das Überschreiben interner oder schützenswerter Felder zu verhindern.61
- **`API4:2023 Unrestricted Resource Consumption`:** Implementierung von Maßnahmen zur Begrenzung der Ressourcennutzung:
    - **Ratenbegrenzung (Rate Limiting):** Begrenzung der Anzahl der Anfragen, die ein Client innerhalb eines bestimmten Zeitraums stellen kann.26
    - **Quotas:** Begrenzung der Gesamtmenge an Ressourcen (z.B. Speicherplatz, Anzahl Objekte), die ein Benutzer/Tenant nutzen darf.
    - **Größenbeschränkungen:** Validierung und Begrenzung der Größe von Request- und Response-Payloads sowie hochgeladenen Dateien.61
    - **Timeout-Konfigurationen:** Angemessene Timeouts für Anfragen.
- **`API5:2023 Broken Function Level Authorization (BFLA)`:** Strikte Trennung der Berechtigungen für administrative Funktionen (z.B. Benutzerverwaltung, Systemkonfiguration) von regulären Benutzerfunktionen. Administrative Endpunkte müssen besonders geschützt und nur für autorisierte Rollen zugänglich sein.61
- **`API6:2023 Unrestricted Access to Sensitive Business Flows`:** Identifizierung und besondere Absicherung von Geschäftsabläufen, die über APIs ausgelöst werden und ein hohes Missbrauchspotenzial haben (z.B. Massenbestellungen, Kontoerstellungen). Dies kann zusätzliche Validierungen, Überwachung oder menschliche Interaktion erfordern.61
- **`API7:2023 Server-Side Request Forgery (SSRF)`:** Wenn die API serverseitig Anfragen an andere URLs stellt (basierend auf Benutzereingaben), müssen diese URLs rigoros validiert und auf eine Whitelist erlaubter Ziele beschränkt werden, um zu verhindern, dass Angreifer interne Systeme scannen oder angreifen können.61
- **Weitere OWASP-Punkte:**
    - **`API8:2023 Security Misconfiguration`:** Sorgfältiges Konfigurationsmanagement, Deaktivierung unnötiger Features, regelmäßige Sicherheitsüberprüfungen der Konfigurationen.62
    - **`API9:2023 Improper Inventory Management`:** Führen eines aktuellen Inventars aller API-Endpunkte, Versionen und deren Sicherheitsstatus. "Shadow APIs" oder veraltete, ungesicherte Endpunkte sind zu vermeiden.62
    - **`API10:2023 Unsafe Consumption of APIs`:** Wenn die Coreschicht selbst externe APIs konsumiert, müssen auch hier Sicherheitsaspekte wie Validierung der Antworten, sichere Authentifizierung und Fehlerbehandlung beachtet werden.62

Die Implementierung dieser Maßnahmen erfordert eine kontinuierliche Aufmerksamkeit während des gesamten API-Lebenszyklus.

### 5.5. Sichere Eingabevalidierung und -verarbeitung

Alle von externen Quellen (insbesondere API-Requests) stammenden Daten müssen serverseitig in der Coreschicht rigoros validiert werden, bevor sie weiterverarbeitet oder gespeichert werden. Clientseitige Validierung dient lediglich der Verbesserung der User Experience, bietet aber keinen Sicherheitsschutz, da sie leicht umgangen werden kann.67

**Arten der Validierung:**

- **Typprüfung:** Sicherstellen, dass die Daten dem erwarteten Datentyp entsprechen (z.B. String, Integer, Boolean, Array, Objekt).67
- **Formatprüfung:** Überprüfung, ob Daten spezifischen Formaten entsprechen (z.B. E-Mail-Adresse, Datum (ISO 8601), UUID, Telefonnummer).67
- **Längen-/Größenprüfung:** Validierung der Mindest- und Maximallänge von Zeichenketten, der Anzahl von Elementen in Arrays oder der Größe von Dateien.67
- **Bereichsprüfung:** Sicherstellen, dass numerische Werte innerhalb eines erlaubten Bereichs liegen (z.B. `Alter >= 0`, `Preis > 0`).
- **Prüfung auf erlaubte Zeichen/Werte (Whitelisting):** Bevorzugt sollte eine Whitelist von erlaubten Zeichen oder Werten verwendet werden, anstatt eine Blacklist von verbotenen Zeichen zu pflegen. Dies ist sicherer, da es schwieriger ist, alle potenziell schädlichen Eingaben vorherzusehen.67
- **Konsistenzprüfung:** Überprüfung, ob zusammengehörige Daten logisch konsistent sind (z.B. Startdatum vor Enddatum).67

**Schutz vor Injection-Angriffen:**

- **SQL-Injection (und NoSQL-Injection):** Verwendung von Prepared Statements (parametrisierten Abfragen) oder ORM-Frameworks, die dies intern handhaben, ist zwingend erforderlich, um SQL-Injection-Angriffe zu verhindern.65 Benutzereingaben dürfen niemals direkt in SQL-Abfragen konkateniert werden.
- **Command-Injection:** Vermeidung der Ausführung von Betriebssystembefehlen, die direkt oder indirekt aus Benutzereingaben konstruiert werden. Wenn unvermeidbar, müssen Eingaben extrem sorgfältig validiert und saniert werden.
- **Cross-Site Scripting (XSS):** Obwohl XSS primär ein Frontend-Problem ist, kann die Coreschicht dazu beitragen, indem sie Daten, die später im Frontend angezeigt werden, korrekt validiert und ggf. vor der Speicherung saniert oder bei der Ausgabe kontextbezogen kodiert (z.B. HTML-Encoding).

Fehlgeschlagene Validierungen müssen zu einer klaren Fehlermeldung an den Client führen (z.B. HTTP `400 Bad Request`), ohne sensible interne Details preiszugeben.67

### 5.6. Protokollierung (Logging) und Überwachung sicherheitsrelevanter Ereignisse

Eine umfassende Protokollierung aller sicherheitsrelevanten Ereignisse ist notwendig, um Sicherheitsvorfälle erkennen, analysieren und darauf reagieren zu können.60

**Zu protokollierende Ereignisse umfassen mindestens:**

- **Authentifizierungsversuche:** Erfolgreiche und fehlgeschlagene Anmeldungen (Benutzername, Quell-IP, Zeitstempel).60
- **Autorisierungsentscheidungen:** Verweigerte Zugriffsversuche auf Ressourcen oder Funktionen (Benutzerkennung, angeforderte Ressource/Funktion, Zeitstempel).
- **Wichtige Konfigurationsänderungen:** Änderungen an Sicherheitseinstellungen, Benutzerrollen oder Berechtigungen (wer hat was wann geändert).
- **API-Anfragen mit Fehlern:** Insbesondere solche, die auf potenzielle Angriffe hindeuten (z.B. wiederholte `401`/`403`-Fehler, Validierungsfehler).
- **Fehler bei der kryptographischen Schlüsselverwaltung.**
- **Erkannte Angriffsversuche oder Anomalien.**

**Anforderungen an die Protokolle:**

- **Ausreichender Detaillierungsgrad:** Logs müssen genügend Informationen enthalten, um den Kontext eines Ereignisses zu verstehen (z.B. Zeitstempel mit Zeitzone, Quell-IP-Adresse, betroffene Benutzerkennung, Ereignistyp, Ergebnis, betroffene Ressource).
- **Integrität und Schutz:** Log-Daten müssen vor unbefugtem Zugriff und Manipulation geschützt werden. Sie sollten idealerweise an ein zentrales, gesichertes Log-Management-System (z.B. SIEM - Security Information and Event Management) gesendet werden.
- **Regelmäßige Auswertung:** Logs müssen regelmäßig (automatisiert und manuell) auf verdächtige Aktivitäten und Muster überwacht werden.60
- **Aufbewahrungsfristen:** Definition von Aufbewahrungsfristen für Log-Daten gemäß rechtlicher und betrieblicher Anforderungen.

Die Protokollierung unterstützt nicht nur die Reaktion auf Vorfälle, sondern auch proaktive Sicherheitsanalysen und die Einhaltung von Compliance-Vorgaben. Die Dokumentation der Logging-Mechanismen und der Zugriff auf Logs ist ebenfalls Teil eines umfassenden Sicherheitsansatzes.57

## 6. Schlussfolgerungen

Dieses Pflichtenheft legt die detaillierten Spezifikationen für die Entwicklung der Coreschicht fest und dient als zentrale Referenz für alle Projektbeteiligten. Es umfasst die genauen Anforderungen an das Datenbankdesign, die API-Schnittstellen, die UI/UX-Gestaltung für administrative Zwecke sowie ein umfassendes Sicherheitskonzept.

Die **Datenbankdesign-Spezifikation** mit einem detaillierten Data Dictionary und konzeptionellen ER-Diagrammen bildet die Grundlage für eine robuste und skalierbare Datenhaltung. Die konsequente Anwendung von Namenskonventionen, die sorgfältige Auswahl von Datentypen und die klare Definition von Beziehungen und Constraints sind hierbei unerlässlich.

Die **Schnittstellendesign-Spezifikation** definiert primär eine RESTful API unter Verwendung von JSON als Datenformat und OAuth 2.0 sowie API-Keys für die Authentifizierung. Die Dokumentation mittels OpenAPI (Swagger) gewährleistet eine klare und maschinenlesbare Beschreibung aller Endpunkte und Datenstrukturen, was die Integration und Nutzung der API erleichtert. Die Einhaltung von Best Practices im API-Design ist entscheidend für die Erstellung einer sicheren, performanten und benutzerfreundlichen Schnittstelle.

Für eventuell notwendige **Administrations- und Konfigurationsoberflächen** werden UI/UX-Spezifikationen bereitgestellt, die den Prozess von Wireframes über Mockups bis hin zu klickbaren Prototypen beschreiben. Ein detaillierter Styleguide inklusive einer UI-Komponentenbibliothek stellt die visuelle Konsistenz und eine effiziente Entwicklung dieser Oberflächen sicher.

Das **Sicherheitskonzept** ist als integraler Bestandteil des gesamten Pflichtenhefts zu verstehen. Es basiert auf den Prinzipien der Layered Security und der geringsten Rechte. Starke Authentifizierungs- und Autorisierungsmechanismen (RBAC), die Verschlüsselung von Daten "at rest" (AES-256) und "in transit" (TLS), die Adressierung der OWASP API Security Top 10, rigorose Eingabevalidierung und umfassende Protokollierung sind Kernkomponenten dieses Konzepts. Die Sicherheit der Coreschicht muss in jeder Phase des Designs und der Entwicklung berücksichtigt werden, um ein "Secure by Design"-Produkt zu gewährleisten.

Die erfolgreiche Umsetzung der in diesem Pflichtenheft definierten Spezifikationen erfordert eine enge Zusammenarbeit aller Beteiligten und eine kontinuierliche Überprüfung der Anforderungen im Projektverlauf. Dieses Dokument ist als "lebendes Dokument" zu betrachten, das bei Bedarf und nach formaler Abstimmung angepasst werden kann, um Änderungen und neue Erkenntnisse zu reflektieren.4 Die Einhaltung der hier festgelegten Vorgaben ist entscheidend für die Entwicklung einer qualitativ hochwertigen, sicheren und wartbaren Coreschicht, die den Anforderungen des Gesamtsystems gerecht wird.

## 7. Anhang

### 7.1. Glossar

|   |   |   |
|---|---|---|
|**Begriff**|**Definition**|**Quelle (falls zutreffend)**|
|API|Application Programming Interface (Programmierschnittstelle)|29|
|CRUD|Create, Read, Update, Delete (Grundlegende Datenoperationen)|27|
|ERD|Entity-Relationship-Diagram (Diagramm zur Darstellung von Datenbankstrukturen)|18|
|GUI|Graphical User Interface (Grafische Benutzeroberfläche)|29|
|HSM|Hardware Security Module (Hardwaremodul zur sicheren Schlüsselspeicherung und -verwaltung)|63|
|HTTP|Hypertext Transfer Protocol (Protokoll zur Übertragung von Daten im Web)||
|HTTPS|Hypertext Transfer Protocol Secure (Sichere Variante von HTTP durch TLS/SSL-Verschlüsselung)|27|
|JWT|JSON Web Token (Standard zur Übertragung von Claims zwischen Parteien als JSON-Objekt)|31|
|JSON|JavaScript Object Notation (Leichtgewichtiges Datenaustauschformat)|27|
|KMS|Key Management Service (Dienst zur Verwaltung kryptographischer Schlüssel)|63|
|MFA|Multi-Factor Authentication (Authentifizierungsmethode mit mehreren Faktoren)|60|
|OAuth 2.0|Open Authorization 2.0 (Offenes Protokoll für delegierte Autorisierung)|31|
|OIDC|OpenID Connect (Identitätsschicht aufbauend auf OAuth 2.0)|31|
|OpenAPI|Standardisierte Speifikation zur Beschreibung von REST-APIs (früher Swagger)|35|
|ORM|Object-Relational Mapping (Technik zur Abbildung von Objekten auf relationale Datenbanken)||
|OWASP|Open Web Application Security Project (Non-Profit-Organisation mit Fokus auf Softwaresicherheit)|61|
|PII|Personally Identifiable Information (Personenbezogene Daten)||
|PK|Primary Key (Primärschlüssel in einer Datenbanktabelle)||
|FK|Foreign Key (Fremdschlüssel in einer Datenbanktabelle)||
|RBAC|Role-Based Access Control (Rollenbasiertes Zugriffskontrollmodell)|32|
|REST|Representational State Transfer (Architekturstil für verteilte Hypermedia-Systeme)|27|
|SDLC|Software Development Lifecycle (Softwareentwicklungslebenszyklus)|57|
|SIEM|Security Information and Event Management (System zur Sammlung und Analyse von Sicherheitsinformationen)||
|SQL|Structured Query Language (Standardsprache zur Verwaltung relationaler Datenbanken)||
|SRS|Software Requirements Specification (Software-Anforderungsspezifikation)|1|
|SSRF|Server-Side Request Forgery (Sicherheitslücke, bei der ein Server dazu gebracht wird, Anfragen an beliebige Ziele zu senden)|61|
|Swagger|Werkzeugsatz zur Implementierung der OpenAPI-Spezifikation (siehe OpenAPI)|35|
|TLS|Transport Layer Security (Verschlüsselungsprotokoll zur sicheren Datenübertragung)|31|
|UI|User Interface (Benutzerschnittstelle)|47|
|UML|Unified Modeling Language (Standardisierte Modellierungssprache)|2|
|URI|Uniform Resource Identifier (Eindeutiger Bezeichner für eine Ressource)||
|URL|Uniform Resource Locator (Spezifische Art von URI, die den Ort einer Ressource angibt)||
|UX|User Experience (Benutzererlebnis)|72|
|UUID|Universally Unique Identifier (Eindeutiger 128-Bit-Identifikator)||
|XSS|Cross-Site Scripting (Art von Sicherheitslücke in Webanwendungen)|67|
|YAML|YAML Ain't Markup Language (Menschenlesbares Datenformat, oft für Konfigurationsdateien verwendet)|37|

### 7.2. Referenzierte Dokumente und Standards (erweitert)

- DIN 69901-5: Projektmanagement – Projektmanagementsysteme – Teil 5: Begriffe 1
- VDI Richtlinie 2519 Blatt 1: Vorgehensweise bei der Planung und Ausführung von Automatisierungsprojekten 1
- VDI Richtlinie 3694: Anforderungen an Automatisierungssysteme 1
- IEEE Std 830-1998: IEEE Recommended Practice for Software Requirements Specifications (ggf. ersetzt durch ISO/IEC/IEEE 29148) 8
- ISO/IEC/IEEE 29148:2018: Systems and software engineering — Life cycle processes — Requirements engineering 7
- OpenAPI Specification (Version 3.x): Standard zur Beschreibung von REST-APIs 35
- OWASP API Security Top 10: Regelmäßig aktualisierte Liste der kritischsten Sicherheitsrisiken für APIs 61
- OWASP Secure Coding Practices
- NIST Special Publications (z.B. SP 800-53 für Sicherheitskontrollen, NIST Cybersecurity Framework) 57
- RFCs (Request for Comments) relevant für HTTP, TLS, JWT, OAuth 2.0 (z.B. RFC 2616, RFC 8446, RFC 7519, RFC 6749)
- [Internes Dokument XYZ]: Lastenheft für das Projekt (falls vorhanden und Basis für dieses Pflichtenheft)
- : Übergeordnete Systemarchitektur


---

## 1. Allgemeine Vorbemerkungen zur Implementierung

- **Rust Edition:** Es wird die jeweils aktuell stabile Rust-Edition zum Zeitpunkt der Implementierung verwendet (aktuell Rust 2021, potenziell Rust 2024, falls bis dahin relevant).
- **Abhängigkeitsmanagement:** Cargo wird für das Abhängigkeitsmanagement verwendet. Versionen von Abhängigkeiten sollten sorgfältig gewählt und bei Bedarf über `Cargo.lock` fixiert werden, um reproduzierbare Builds sicherzustellen. Es wird empfohlen, `cargo update -p <crate_name>` für gezielte Updates zu verwenden.
- **Asynchrone Runtime:** Wo nicht anders spezifiziert (z.B. für GTK-spezifische Aufgaben), wird `tokio` als primäre asynchrone Runtime für I/O-gebundene Operationen und Nebenläufigkeit verwendet, insbesondere in der System- und UI-Schicht.
- **Fehlerbehandlung (Globale Konvention):** Die Verwendung von `thiserror` für spezifische Fehler-Enums pro Modul und die Weitergabe von Fehlern über `Result<T, E>` ist verbindlich. Panics sind strikt zu vermeiden, außer in Tests oder bei nachweislich nicht behebbaren internen Invariantenverletzungen mit aussagekräftiger Begründung. Die `source()`-Kette von Fehlern muss erhalten bleiben.
- **Logging (Globale Konvention):** Das `tracing`-Framework ist für strukturiertes, kontextbezogenes Logging verbindlich. Sensible Daten dürfen niemals geloggt werden.
- **Code-Formatierung und Linting:** `rustfmt` mit Projektstandardkonfiguration und `clippy` (mit `-D warnings`) sind bei jedem Commit/Push obligatorisch und werden durch CI erzwungen.
- **Dokumentation:** Umfassende `rustdoc`-Kommentare für alle öffentlichen APIs sind zwingend erforderlich.
- **Tests:** Unit-Tests (`#[cfg(test)] mod tests { ... }`) müssen parallel zur Implementierung geschrieben werden und eine hohe Codeabdeckung anstreben. Integrationstests (`tests/integration_test.rs`) sind für das Zusammenspiel von Modulen/Crates vorzusehen.

---

## 2. Ultra-Feinspezifikation: Kernschicht (Core Layer)

Die Kernschicht (`novade-core` Crate) enthält die absolut grundlegendsten, systemweit genutzten Elemente und hat keine Abhängigkeiten zu anderen Schichten von NovaDE.

### Modul: `core::types` (Fundamentale Datentypen)

**Zweck:** Definition grundlegender, universell einsetzbarer Datentypen für Geometrie, Farben und allgemeine Enumerationen. Diese Typen sind reine Datenstrukturen ohne komplexe Geschäftslogik.

**Designphilosophie:** Modularität, Wiederverwendbarkeit, minimale Kopplung. Generische Typen wo sinnvoll. Klare Trennung von Datenrepräsentation und Fehlerbehandlung.

**Abhängigkeiten:** `std`, `uuid` (für IDs in höheren Schichten, hier als Beispiel für einen Basistyp), `chrono` (für Zeitstempel, dito), `serde` (optional, mit `derive`-Feature, falls Serialisierung hier benötigt wird), `num-traits` (optional).

#### Untermodul: `core::types::geometry`

**Datei:** `src/types/geometry.rs`

##### 1. Struct: `Point<T>`

- **Zweck:** Repräsentiert einen Punkt im 2D-Raum.
- **Generische Parameter:** `T`
- **Felder:**
    - `pub x: T`
    - `pub y: T`
- **Ableitungen (Basis):** `#[derive(Debug, Clone, Copy, PartialEq, Default)]`
    - `Eq` und `Hash` nur, wenn `T: Eq` bzw. `T: Hash`.
- **`serde` (optional):** `#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]`
- **Invarianten:** Keine spezifischen, hängen von `T` ab.
- **Methoden:**
    - `pub const fn new(x: T, y: T) -> Self`
        - **Logik:** Erstellt einen neuen Punkt.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.x == x`, `self.y == y`.
    - `pub fn distance_squared(&self, other: &Point<T>) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + std::ops::Mul<Output = T>`
        - **Logik:** Berechnet das Quadrat der euklidischen Distanz: `(self.x - other.x)^2 + (self.y - other.y)^2`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das Quadrat der Distanz zurück.
    - `pub fn distance(&self, other: &Point<T>) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + std::ops::Mul<Output = T> + num_traits::Float` (oder spezifische Implementierung für `f32`, `f64`)
        - **Logik:** Berechnet die euklidische Distanz: `sqrt((self.x - other.x)^2 + (self.y - other.y)^2)`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt die Distanz zurück.
    - `pub fn manhattan_distance(&self, other: &Point<T>) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + num_traits::Signed`
        - **Logik:** Berechnet die Manhattan-Distanz: `abs(self.x - other.x) + abs(self.y - other.y)`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt die Manhattan-Distanz zurück.
- **Trait-Implementierungen (Zusätzlich):**
    - `impl<T: std::ops::Add<Output = T>> std::ops::Add for Point<T>`
    - `impl<T: std::ops::Sub<Output = T>> std::ops::Sub for Point<T>`
- **Assoziierte Konstanten:**
    - `pub const ZERO_I32: Point<i32> = Point { x: 0, y: 0 };`
    - `pub const ZERO_F32: Point<f32> = Point { x: 0.0, y: 0.0 };`
    - (Weitere für `u32`, `f64` etc.)

##### 2. Struct: `Size<T>`

- **Zweck:** Repräsentiert eine 2D-Dimension (Breite und Höhe).
- **Generische Parameter:** `T`
- **Felder:**
    - `pub width: T`
    - `pub height: T`
- **Ableitungen (Basis):** `#[derive(Debug, Clone, Copy, PartialEq, Default)]`
    - `Eq` und `Hash` nur, wenn `T: Eq` bzw. `T: Hash`.
- **`serde` (optional):** `#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]`
- **Invarianten:** Logisch sollten `width` und `height` nicht-negativ sein. Dies wird nicht durch den Typ erzwungen, aber durch `is_valid()` prüfbar gemacht.
- **Methoden:**
    - `pub const fn new(width: T, height: T) -> Self`
        - **Logik:** Erstellt eine neue Größe.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.width == width`, `self.height == height`.
    - `pub fn area(&self) -> T`
        - **Generische Constraints:** `T: Copy + std::ops::Mul<Output = T>`
        - **Logik:** Berechnet die Fläche: `self.width * self.height`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt die Fläche zurück.
    - `pub fn is_empty(&self) -> bool`
        - **Generische Constraints:** `T: PartialEq + num_traits::Zero`
        - **Logik:** Prüft, ob `self.width == T::zero()` oder `self.height == T::zero()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn leer, sonst `false`.
    - `pub fn is_valid(&self) -> bool`
        - **Generische Constraints:** `T: PartialOrd + num_traits::Zero`
        - **Logik:** Prüft, ob `self.width >= T::zero()` und `self.height >= T::zero()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn gültig, sonst `false`.
- **Assoziierte Konstanten:**
    - `pub const ZERO_I32: Size<i32> = Size { width: 0, height: 0 };`
    - `pub const ZERO_F32: Size<f32> = Size { width: 0.0, height: 0.0 };`
    - (Weitere für `u32`, `f64` etc.)

##### 3. Struct: `Rect<T>`

- **Zweck:** Repräsentiert ein 2D-Rechteck, definiert durch Ursprung (oben-links) und Größe.
- **Generische Parameter:** `T`
- **Felder:**
    - `pub origin: Point<T>`
    - `pub size: Size<T>`
- **Ableitungen (Basis):** `#[derive(Debug, Clone, Copy, PartialEq, Default)]`
    - `Eq` und `Hash` nur, wenn `T: Eq` bzw. `T: Hash`.
- **`serde` (optional):** `#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]`
- **Invarianten:** Logisch sollten `size.width` und `size.height` nicht-negativ sein. `is_valid()` prüft dies. Die Verantwortung für das Melden eines Fehlers bei Verwendung eines ungültigen `Rect` liegt beim Aufrufer.
- **Methoden:**
    - `pub const fn new(origin: Point<T>, size: Size<T>) -> Self`
        - **Logik:** Erstellt ein neues Rechteck.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.origin == origin`, `self.size == size`.
    - `pub fn from_coords(x: T, y: T, width: T, height: T) -> Self`
        - **Generische Constraints:** `T` muss die Constraints für `Point::new` und `Size::new` erfüllen.
        - **Logik:** Erstellt ein neues Rechteck aus Koordinaten und Dimensionen.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** `self.origin.x == x`, `self.origin.y == y`, `self.size.width == width`, `self.size.height == height`.
    - `pub fn x(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.origin.x` zurück.
    - `pub fn y(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.origin.y` zurück.
    - `pub fn width(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.size.width` zurück.
    - `pub fn height(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.size.height` zurück.
    - `pub fn top(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.y()` zurück.
    - `pub fn left(&self) -> T` (Constraints: `T: Copy`) - Gibt `self.x()` zurück.
    - `pub fn bottom(&self) -> T` (Constraints: `T: Copy + std::ops::Add<Output = T>`) - Gibt `self.y() + self.height()` zurück.
    - `pub fn right(&self) -> T` (Constraints: `T: Copy + std::ops::Add<Output = T>`) - Gibt `self.x() + self.width()` zurück.
    - `pub fn center(&self) -> Point<T>`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T> + std::ops::Div<Output = T> + num_traits::FromPrimitive` (für `T::from(2).unwrap()`).
        - **Logik:** Berechnet den Mittelpunkt: `Point::new(self.x() + self.width() / 2, self.y() + self.height() / 2)`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt den Mittelpunkt zurück.
    - `pub fn contains_point(&self, point: &Point<T>) -> bool`
        - **Generische Constraints:** `T: Copy + PartialOrd + std::ops::Add<Output = T>`
        - **Logik:** `point.x >= self.left() && point.x < self.right() && point.y >= self.top() && point.y < self.bottom()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn der Punkt enthalten ist, sonst `false`.
    - `pub fn intersects(&self, other: &Rect<T>) -> bool`
        - **Generische Constraints:** `T: Copy + PartialOrd + std::ops::Add<Output = T>`
        - **Logik:** `self.left() < other.right() && self.right() > other.left() && self.top() < other.bottom() && self.bottom() > other.top()`.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn sich die Rechtecke überschneiden, sonst `false`.
    - `pub fn intersection(&self, other: &Rect<T>) -> Option<Rect<T>>`
        - **Generische Constraints:** `T: Copy + Ord + std::ops::Add<Output = T> + std::ops::Sub<Output = T> + num_traits::Zero`
        - **Logik:**
            1. `intersect_x = self.x().max(other.x())`
            2. `intersect_y = self.y().max(other.y())`
            3. `intersect_right = self.right().min(other.right())`
            4. `intersect_bottom = self.bottom().min(other.bottom())`
            5. Wenn `intersect_right > intersect_x` und `intersect_bottom > intersect_y`:
                - `intersect_width = intersect_right - intersect_x`
                - `intersect_height = intersect_bottom - intersect_y`
                - `Some(Rect::new(Point::new(intersect_x, intersect_y), Size::new(intersect_width, intersect_height)))`
            6. Sonst: `None`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das Schnittrechteck oder `None` zurück.
    - `pub fn union(&self, other: &Rect<T>) -> Rect<T>`
        - **Generische Constraints:** `T: Copy + Ord + std::ops::Add<Output = T> + std::ops::Sub<Output = T>`
        - **Logik:**
            1. `union_x = self.x().min(other.x())`
            2. `union_y = self.y().min(other.y())`
            3. `union_right = self.right().max(other.right())`
            4. `union_bottom = self.bottom().max(other.bottom())`
            5. `union_width = union_right - union_x`
            6. `union_height = union_bottom - union_y`
            7. `Rect::new(Point::new(union_x, union_y), Size::new(union_width, union_height))`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das umschließende Rechteck zurück.
    - `pub fn translated(&self, dx: T, dy: T) -> Rect<T>`
        - **Generische Constraints:** `T: Copy + std::ops::Add<Output = T>`
        - **Logik:** `Rect::new(Point::new(self.origin.x + dx, self.origin.y + dy), self.size)`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das verschobene Rechteck zurück.
    - `pub fn scaled(&self, sx: T, sy: T) -> Rect<T>` (Skaliert Ursprung und Größe)
        - **Generische Constraints:** `T: Copy + std::ops::Mul<Output = T>`
        - **Logik:** `Rect::new(Point::new(self.origin.x * sx, self.origin.y * sy), Size::new(self.size.width * sx, self.size.height * sy))`
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt das skalierte Rechteck zurück.
    - `pub fn is_valid(&self) -> bool`
        - **Generische Constraints:** `T` muss `Size::is_valid` unterstützen.
        - **Logik:** Ruft `self.size.is_valid()` auf.
        - **Vorbedingungen:** Keine.
        - **Nachbedingungen:** Gibt `true` zurück, wenn `size` gültig ist, sonst `false`.
- **Assoziierte Konstanten:**
    - `pub const ZERO_I32: Rect<i32> = Rect { origin: Point::ZERO_I32, size: Size::ZERO_I32 };`
    - `pub const ZERO_F32: Rect<f32> = Rect { origin: Point::ZERO_F32, size: Size::ZERO_F32 };`

##### 4. Struct `RectInt` (Spezifische Implementierung von `Rect<i32/u32>`)

- **Zweck:** Ein achsenparalleles Rechteck mit ganzzahligen `i32` Koordinaten und `u32` Dimensionen. Dies ist oft praktisch für Pixel-basierte Operationen und Fenstergeometrie.
- **Felder:**
    - `pub x: i32`
    - `pub y: i32`
    - `pub width: u32`
    - `pub height: u32`
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize)]` (Serde ist hier oft nützlich)
- **Invarianten:** `width >= 0`, `height >= 0` (durch `u32` Typ erzwungen).
- **Methoden (Beispiele, basierend auf):**
    - `pub const fn new(x: i32, y: i32, width: u32, height: u32) -> Self`
    - `pub fn from_points(p1: Point<i32>, p2: Point<i32>) -> Self`
        - **Logik:** `x = p1.x.min(p2.x)`, `y = p1.y.min(p2.y)`, `width = (p1.x - p2.x).abs() as u32`, `height = (p1.y - p2.y).abs() as u32`.
    - `pub fn top_left(&self) -> Point<i32>` - Gibt `Point::new(self.x, self.y)` zurück.
    - `pub fn size(&self) -> Size<u32>` - Gibt `Size::new(self.width, self.height)` zurück.
    - `pub fn right(&self) -> i32` - Gibt `self.x.saturating_add(self.width as i32)` zurück.
    - `pub fn bottom(&self) -> i32` - Gibt `self.y.saturating_add(self.height as i32)` zurück.
    - `pub fn contains_point(&self, p_x: i32, p_y: i32) -> bool` - `p_x >= self.x && p_x < self.right() && p_y >= self.y && p_y < self.bottom()`.
    - `pub fn intersects(&self, other: RectInt) -> bool` - `self.x < other.right() && self.right() > other.x && self.y < other.bottom() && self.bottom() > other.y`.
    - `pub fn intersection(&self, other: RectInt) -> Option<RectInt>` (Logik wie bei `Rect<T>`)
    - `pub fn union(&self, other: RectInt) -> RectInt` (Logik wie bei `Rect<T>`)
    - `pub fn translate(&self, dx: i32, dy: i32) -> RectInt` - `RectInt::new(self.x.saturating_add(dx), self.y.saturating_add(dy), self.width, self.height)`.
    - `pub fn inflate(&self, dw: i32, dh: i32) -> RectInt`
        - **Logik:** `new_x = self.x.saturating_sub(dw)`, `new_y = self.y.saturating_sub(dh)`. `new_width_signed = (self.width as i64).saturating_add(2 * dw as i64)`. `new_height_signed = (self.height as i64).saturating_add(2 * dh as i64)`. `RectInt::new(new_x, new_y, new_width_signed.max(0) as u32, new_height_signed.max(0) as u32)`.
    - `pub fn is_empty(&self) -> bool` - `self.width == 0 || self.height == 0`.

#### Untermodul: `core::types::color`

**Datei:** `src/types/color.rs`

##### 1. Struct: `Color` (RGBA)

- **Zweck:** Repräsentiert eine Farbe mit Rot-, Grün-, Blau- und Alpha-Komponenten.
- **Felder:**
    - `pub r: f32` (Bereich `[0.0, 1.0]`)
    - `pub g: f32` (Bereich `[0.0, 1.0]`)
    - `pub b: f32` (Bereich `[0.0, 1.0]`)
    - `pub a: f32` (Bereich `[0.0, 1.0]`)
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq)]`
- **Invarianten:** Alle Komponenten `r, g, b, a` müssen im Bereich `[0.0, 1.0]` liegen. Konstruktoren und Methoden klemmen Werte entsprechend.
- **Methoden:**
    - `pub fn new(r: f32, g: f32, b: f32, a: f32) -> Self`
        - **Logik:** `Self { r: r.clamp(0.0, 1.0), g: g.clamp(0.0, 1.0), b: b.clamp(0.0, 1.0), a: a.clamp(0.0, 1.0) }`.
        - **Nachbedingungen:** Alle Felder sind im Bereich `[0.0, 1.0]`.
    - `pub fn from_rgba8(r_u8: u8, g_u8: u8, b_u8: u8, a_u8: u8) -> Self`
        - **Logik:** `Self::new(r_u8 as f32 / 255.0, g_u8 as f32 / 255.0, b_u8 as f32 / 255.0, a_u8 as f32 / 255.0)`.
    - `pub fn to_rgba8(&self) -> (u8, u8, u8, u8)`
        - **Logik:** `((self.r * 255.0).round() as u8, (self.g * 255.0).round() as u8, (self.b * 255.0).round() as u8, (self.a * 255.0).round() as u8)`.
    - `pub fn with_alpha(&self, alpha: f32) -> Self`
        - **Logik:** `Self::new(self.r, self.g, self.b, alpha)`.
    - `pub fn blend(&self, background: &Color) -> Color` (Source-Over Blending)
        - **Logik:**
            1. `fg_a = self.a`
            2. `bg_a = background.a`
            3. `out_a = fg_a + bg_a * (1.0 - fg_a)`
            4. Wenn `out_a == 0.0`, gib `Color::TRANSPARENT` zurück.
            5. `out_r = (self.r * fg_a + background.r * bg_a * (1.0 - fg_a)) / out_a`
            6. `out_g = (self.g * fg_a + background.g * bg_a * (1.0 - fg_a)) / out_a`
            7. `out_b = (self.b * fg_a + background.b * bg_a * (1.0 - fg_a)) / out_a`
            8. `Color::new(out_r, out_g, out_b, out_a)`
    - `pub fn lighten(&self, amount: f32) -> Color`
        - **Logik:** `amount_clamped = amount.clamp(0.0, 1.0)`. `Color::new(self.r + (1.0 - self.r) * amount_clamped, self.g + (1.0 - self.g) * amount_clamped, self.b + (1.0 - self.b) * amount_clamped, self.a)`
    - `pub fn darken(&self, amount: f32) -> Color`
        - **Logik:** `amount_clamped = amount.clamp(0.0, 1.0)`. `Color::new(self.r * (1.0 - amount_clamped), self.g * (1.0 - amount_clamped), self.b * (1.0 - amount_clamped), self.a)`
    - `pub fn interpolate(&self, other: Color, t: f32) -> Color`
        - **Logik:** `t_clamped = t.clamp(0.0, 1.0)`. `r = self.r * (1.0 - t_clamped) + other.r * t_clamped` `g = self.g * (1.0 - t_clamped) + other.g * t_clamped` `b = self.b * (1.0 - t_clamped) + other.b * t_clamped` `a = self.a * (1.0 - t_clamped) + other.a * t_clamped` `Color::new(r,g,b,a)`
    - `pub fn from_hex(hex_string: &str) -> Result<Self, ColorParseError>`
        - **Logik:**
            1. Entferne optionales `#`-Präfix.
            2. Validiere Länge (3, 4, 6, 8 Zeichen). Bei ungültiger Länge: `Err(ColorParseError::InvalidHexLength(hex_string.to_string()))`.
            3. Parse Hex-Zeichen in `u8` Komponenten. Bei ungültigen Zeichen: `Err(ColorParseError::InvalidHexDigit(...))`.
                - `#RGB`: `R`, `G`, `B` (Alpha = FF) -> `RR`, `GG`, `BB`
                - `#RGBA`: `R`, `G`, `B`, `A` -> `RR`, `GG`, `BB`, `AA`
                - `#RRGGBB`: `RR`, `GG`, `BB` (Alpha = FF)
                - `#RRGGBBAA`: `RR`, `GG`, `BB`, `AA`
            4. Konvertiere `u8` zu `f32` (`/ 255.0`).
            5. Erzeuge `Color` via `Color::new()`.
            6. Bei Erfolg `Ok(Self)`.
        - **Fehler:** `ColorParseError` (siehe `core::errors`)
    - `pub fn to_hex_string(&self, include_alpha: bool) -> String`
        - **Logik:** Konvertiere `r,g,b,a` zu `u8`. Formatiere als Hex-String.
            - Wenn `include_alpha` oder `self.a < 1.0` (oder immer Alpha für Konsistenz): `format!("#{:02X}{:02X}{:02X}{:02X}", r_u8, g_u8, b_u8, a_u8)`
            - Sonst: `format!("#{:02X}{:02X}{:02X}", r_u8, g_u8, b_u8)`
- **Trait-Implementierungen (Zusätzlich):**
    - `impl Default for Color { fn default() -> Self { Color::TRANSPARENT } }`
- **Assoziierte Konstanten:**
    - `pub const TRANSPARENT: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };`
    - `pub const BLACK: Color = Color { r: 0.0, g: 0.0, b: 0.0, a: 1.0 };`
    - `pub const WHITE: Color = Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };`
    - (Weitere wie `RED`, `GREEN`, `BLUE`)
- **Serialisierung (`serde`):**
    - Soll als Hex-String serialisiert/deserialisiert werden (siehe).
    - `impl Serialize for Color { ... serializer.serialize_str(&self.to_hex_string(true)) ... }`
    - `impl<'de> Deserialize<'de> for Color { ... Color::from_hex(&s).map_err(serde::de::Error::custom) ... }`

#### Untermodul: `core::types::enums`

**Datei:** `src/types/enums.rs`

##### 1. Enum: `Orientation`

- **Zweck:** Repräsentiert eine horizontale oder vertikale Ausrichtung.
- **Varianten:**
    - `Horizontal`
    - `Vertical`
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]`
- **Methoden:**
    - `pub fn toggle(&self) -> Self`
        - **Logik:** `match self { Orientation::Horizontal => Orientation::Vertical, Orientation::Vertical => Orientation::Horizontal }`.
- **Trait-Implementierungen (Zusätzlich):**
    - `impl Default for Orientation { fn default() -> Self { Orientation::Horizontal } }`

#### Untermodul: `core::types::ids`

Datei: src/types/ids.rs

(Obwohl in der Gesamtspezifikation WorkspaceId, WindowIdentifier etc. in core::types erwähnt werden, gehören sie semantisch eher in die Domänenschicht oder sind Newtypes um primitive IDs. Hier ein Beispiel für generische ID-Typen, falls benötigt.)

##### 1. Struct: `GenericId` (Beispiel)

- **Zweck:** Ein typsicherer Wrapper um `uuid::Uuid` für generische Entitäts-IDs.
- **Felder:** `pub id: uuid::Uuid`
- **Ableitungen:** `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]`
- **Methoden:**
    - `pub fnnew() -> Self { Self { id: Uuid::new_v4() } }`
    - `pub fnfrom_uuid(uuid: Uuid) -> Self { Self { id: uuid } }`
    - `pub fnas_uuid(&self) -> &Uuid { &self.id }`
- **Trait-Implementierungen:** `impl Default for GenericId { fn default() -> Self { Self::new() } }`

#### Moduldeklaration `core::types::mod.rs`

Rust

```
// src/types/mod.rs

pub mod color;
pub mod enums;
pub mod geometry;
// pub mod ids; // Falls vorhanden

pub use color::Color;
pub use enums::Orientation;
pub use geometry::{Point, Rect, Size, RectInt};
// pub use ids::GenericId;
```

#### Implementierungsschritte `core::types`

1. **Verzeichnis- und Dateierstellung:**
    - `core/src/types/mod.rs`
    - `core/src/types/geometry.rs`
    - `core/src/types/color.rs`
    - `core/src/types/enums.rs`
    - (`core/src/types/ids.rs` optional)
2. **Implementierung `geometry.rs`:**
    - `Point<T>`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `distance_squared`, `distance`, `manhattan_distance`), Trait-Impls.
    - `Size<T>`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `area`, `is_empty`, `is_valid`).
    - `Rect<T>`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `from_coords`, Zugriffsmethoden, `center`, `contains_point`, `intersects`, `intersection`, `union`, `translated`, `scaled`, `is_valid`).
    - `RectInt`: Struktur, Ableitungen, Methoden wie spezifiziert.
    - Hinzufügen von `use num_traits::{Float, Signed, Zero};` und `use serde::{Serialize, Deserialize};` (letzteres mit `cfg_attr`).
3. **Implementierung `color.rs`:**
    - `Color`: Struktur, Ableitungen, Konstanten, Methoden (`new`, `from_rgba8`, `to_rgba8`, `with_alpha`, `blend`, `lighten`, `darken`, `interpolate`, `from_hex`, `to_hex_string`), `Default`-Impl, `Serialize`/`Deserialize`-Impls.
    - Benötigt `use crate::core::errors::ColorParseError;` (siehe `core::errors`) und `use serde::{Serializer, Deserializer, de::Error as SerdeError};`.
4. **Implementierung `enums.rs`:**
    - `Orientation`: Enum, Ableitungen, `toggle`-Methode, `Default`-Impl.
5. **Implementierung `ids.rs` (optional):**
    - `GenericId` (oder spezifischere ID-Typen, falls hier sinnvoll).
6. **Moduldeklaration `types/mod.rs`:** `pub mod ...` und `pub use ...` für alle definierten Typen.
7. **Aktualisierung `core/src/lib.rs`:** `pub mod types;`
8. **Unit-Tests:**
    - Für jeden Typ und jede Methode Testfälle erstellen.
    - `Point<T>`: Teste `new`, Distanzberechnungen für `i32` und `f32`.
    - `Size<T>`: Teste `new`, `area`, `is_empty`, `is_valid` für `i32`, `u32`, `f32`.
    - `Rect<T>`: Teste Konstruktoren, Zugriffsmethoden, `center`, `contains_point`, `intersects`, `intersection`, `union`.
    - `RectInt`: Teste alle Methoden, insbesondere `inflate` mit positiven/negativen Werten.
    - `Color`: Teste `new` (Klemmung), `from_rgba8`, `to_rgba8`, `blend`, `lighten`, `darken`, `from_hex` (alle Formate, Fehlerfälle), `to_hex_string`, `Default`.
    - `Orientation`: Teste `toggle`, `Default`.
    - Überprüfe `serde`-Implementierungen (Serialisierung zu erwartetem JSON/String, Deserialisierung).
9. **Dokumentation (`rustdoc`):**
    - Umfassende Kommentare für alle öffentlichen Elemente (Module, Structs, Enums, Felder, Methoden, Konstanten).
    - Erklärung von Invarianten, Wertebereichen, Vor-/Nachbedingungen.
    - `# Examples` für komplexere Methoden oder Typverwendungen.

---

### Modul: `core::errors` (Fehlerbehandlung)

**Zweck:** Definition einer robusten und konsistenten Fehlerbehandlungsstrategie und grundlegender Fehlertypen für die Kernschicht.

**Designphilosophie:** Verwendung von `thiserror` für spezifische Fehler-Enums pro Modul. Klare Trennung zwischen `Result<T, E>` für behebbare Fehler und `panic!` für nicht behebbare Programmierfehler. Kontextreiche Fehlermeldungen.

**Abhängigkeiten:** `std`, `thiserror`, `uuid` (für IDs in Fehlermeldungen), `std::path::PathBuf`.

**Datei:** `src/errors.rs`

##### 1. Enum: `CoreError` (Basis-Fehlertyp der Kernschicht)

- **Zweck:** Dient als primäre Schnittstelle für allgemeine Fehler, die von öffentlichen Funktionen der Kernschicht propagiert werden können, oder für Fehler, die keinem spezifischen Submodul zugeordnet werden können.
- **Ableitungen:** `#[derive(Debug, thiserror::Error)]`
- **Varianten:**
    - `#[error("Core component '{component}' failed to initialize")]` `InitializationFailed { component: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
    - `#[error("I/O error accessing path '{path}': {source}")]` `Io { path: PathBuf, #[source] source: std::io::Error }`
        - **Publisher:** Jede Kernfunktion, die direkt I/O-Operationen durchführt.
        - **Subscriber:** Aufrufer, die diese I/O-Fehler behandeln müssen.
    - `#[error("Serialization error: {description}")]` (für generische Serialisierungsfehler, spezifischere sollten eigene Typen haben) `Serialization { description: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
    - `#[error("Deserialization error: {description}")]` `Deserialization { description: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
    - `#[error("Invalid identifier provided: '{invalid_id}'")]` `InvalidId { invalid_id: String }`
    - `#[error("Resource not found: {resource_description}")]` `NotFound { resource_description: String }`
    - `#[error("Configuration error (core level): {message}")]` `CoreConfigError { message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }` (Spezifischere `ConfigError` in `core::config::errors`)
    - `#[error("An internal logic error occurred: {0}")]` `InternalError(String)` (Sollte selten verwendet werden; spezifischere Fehler sind vorzuziehen)

##### 2. Enum: `ColorParseError` (Spezifischer Fehler für `Color::from_hex`)

- **Zweck:** Repräsentiert Fehler, die beim Parsen eines Hex-Strings zu einer `Color` auftreten können.
- **Datei:** `src/types/color.rs` (oder `src/errors/color_errors.rs` und re-exportiert) – hier in `errors.rs` für Zentralität der Fehler.
- **Ableitungen:** `#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]`
- **Varianten:**
    - `#[error("Invalid hex color string format for '{0}'. Expected formats: #RGB, #RGBA, #RRGGBB, #RRGGBBAA.")]` `InvalidHexFormat(String)`
    - `#[error("Invalid hex digit in string '{0}': {source}")]` `InvalidHexDigit(String, #[source] std::num::ParseIntError)`
    - `#[error("Invalid hex color string length for '{0}'. Expected 3, 4, 6, or 8 characters after '#'.")]` `InvalidHexLength(String)`

##### Implementierungsschritte `core::errors`

1. **Abhängigkeiten in `core/Cargo.toml` sicherstellen:**
    
    Ini, TOML
    
    ```
    [dependencies]
    thiserror = "1.0"
    uuid = { version = "1.0", features = ["v4", "serde"] } # serde optional für Fehler
    chrono = { version = "0.4", features = ["serde"] } # serde optional
    # num-traits, serde, toml, once_cell je nach Bedarf anderer Module
    ```
    
2. **Datei `core/src/errors.rs` erstellen/modifizieren:**
    - `CoreError`-Enum mit allen Varianten, `#[error(...)]`-Attributen und `#[source]`-Feldern definieren.
    - `ColorParseError`-Enum definieren.
3. **Öffentliche API und Interne Schnittstellen:**
    - Alle Enums und ihre Varianten sind `pub`.
    - Die `source()`-Methode wird von `thiserror` bereitgestellt.
4. **Unit-Tests (`core/src/errors.rs` -> `#[cfg(test)] mod tests`):**
    - Für jede Fehlervariante testen, ob die `Display`-Implementierung (via `#[error]`) die erwartete Nachricht erzeugt.
    - Für Varianten mit `#[source]`, testen, ob `source()` den zugrunde liegenden Fehler korrekt zurückgibt.
        - Beispiel für `CoreError::Io`:
            
            Rust
            
            ```
            let original_io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "file not found");
            let core_io_err = CoreError::Io { path: "test.txt".into(), source: original_io_err };
            assert!(core_io_err.source().is_some());
            // Ggf. den Typ des source-Fehlers prüfen.
            ```
            
    - Testen der `ColorParseError`-Varianten.
5. **Aktualisierung `core/src/lib.rs`:** `pub mod errors;`
    - `pub use errors::{CoreError, ColorParseError};` (oder nur `CoreError` und `ColorParseError` wird über `crate::types::Color::from_hex` verwendet)

---

### Modul: `core::logging` (Logging-Infrastruktur)

**Zweck:** Initialisierung und Konfiguration des globalen `tracing`-Frameworks.

**Designphilosophie:** Bereitstellung einer einfachen Initialisierungsfunktion. Die eigentliche Verwendung der `tracing::{trace, debug, info, warn, error}` Makros erfolgt direkt im Code der anderen Module/Schichten.

**Abhängigkeiten:** `tracing`, `tracing-subscriber` (mit Features wie `fmt`, `json`, `env-filter`).

**Datei:** `src/logging.rs`

##### 1. Enum: `LogFormat`

- **Zweck:** Definiert die möglichen Ausgabeformate für das Logging.
- **Varianten:**
    - `PlainTextDevelopment`
    - `JsonProduction`
- **Ableitungen:** `#[derive(Debug, Clone, Copy)]`

##### 2. Enum: `LoggingError`

- **Zweck:** Fehler, die bei der Initialisierung des Loggings auftreten können.
- **Ableitungen:** `#[derive(Debug, thiserror::Error)]`
- **Varianten:**
    - `#[error("Failed to set global default tracing subscriber: {0}")]` `SetGlobalDefaultError(String)` (Kapselt den Fehler von `tracing::subscriber::set_global_default`)
    - `#[error("Failed to initialize tracing subscriber: {0}")]` `InitializationError(String)`

##### 3. Funktion: `initialize_logging`

- **Signatur:** `pub fn initialize_logging(level_filter: tracing::LevelFilter, format: LogFormat) -> Result<(), LoggingError>`
- **Parameter:**
    - `level_filter: tracing::LevelFilter`: Der minimale Log-Level, der global gelten soll.
    - `format: LogFormat`: Das gewünschte Ausgabeformat.
- **Rückgabe:** `Result<(), LoggingError>`
- **Logik:**
    1. Erstelle einen `tracing_subscriber::fmt::Builder` oder einen `tracing_subscriber::Registry` mit Layern.
    2. Konfiguriere den Subscriber basierend auf `format`:
        - `LogFormat::PlainTextDevelopment`:
            - Verwende `tracing_subscriber::fmt::layer()`
            - `with_ansi(true)` (falls Terminal es unterstützt, kann über Feature-Flag gesteuert werden)
            - `with_target(true)` (Modulpfad anzeigen)
            - `with_file(true)`
            - `with_line_number(true)`
            - `with_level(true)`
            - `with_filter(level_filter)`
        - `LogFormat::JsonProduction`:
            - Verwende `tracing_subscriber::fmt::layer().json()`
            - `with_current_span(true)`
            - `with_span_list(true)`
            - `with_filter(level_filter)`
            - Alternativ: `tracing_bunyan_formatter` für spezifisches Bunyan-JSON-Format.
    3. Optional: Füge einen `EnvFilter` hinzu, um Log-Levels zur Laufzeit über `RUST_LOG` feingranularer zu steuern, zusätzlich zum globalen `level_filter`. `let env_filter = tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| tracing_subscriber::EnvFilter::new(level_filter.to_string()));` Der `level_filter` Parameter dient dann als Fallback, wenn `RUST_LOG` nicht gesetzt ist. Der Layer wird dann mit `with_filter(env_filter)` konfiguriert.
    4. Baue den Subscriber und versuche, ihn als globalen Default zu setzen: `tracing::subscriber::set_global_default(subscriber).map_err(|e| LoggingError::SetGlobalDefaultError(e.to_string()))`.
- **Fehlerbehandlung:** Gibt `LoggingError` zurück, falls die Initialisierung fehlschlägt.

##### Implementierungsschritte `core::logging`

1. **Abhängigkeiten in `core/Cargo.toml`:**
    
    Ini, TOML
    
    ```
    tracing = "0.1"
    tracing-subscriber = { version = "0.3", features = ["fmt", "json", "env-filter"] }
    # Ggf. tracing-bunyan-formatter
    ```
    
2. **Datei `core/src/logging.rs` erstellen:**
    - `LogFormat` Enum definieren.
    - `LoggingError` Enum mit `thiserror` definieren.
    - `initialize_logging` Funktion implementieren.
3. **Unit-Tests (konzeptionell, da `set_global_default` global ist):**
    - Testen, ob die Funktion mit verschiedenen Formaten und Leveln ohne Panic durchläuft. Das tatsächliche Setzen des globalen Subscribers ist schwer isoliert zu testen. Man könnte prüfen, ob der Builder korrekt konfiguriert wird.
4. **Aktualisierung `core/src/lib.rs`:** `pub mod logging;`
    - `pub use logging::{initialize_logging, LogFormat, LoggingError};`

---

### Modul: `core::config` (Konfigurationsprimitive)

**Zweck:** Definition von Mechanismen zum Laden, Parsen und Zugreifen auf Basiskonfigurationen.

**Designphilosophie:** Einfachheit, Robustheit. Verwendung von TOML als Konfigurationsformat und `serde` für (De-)Serialisierung.

**Abhängigkeiten:** `serde` (mit `derive`), `toml`, `once_cell` (für globalen Zugriff).

**Datei:** `src/config/mod.rs` (kann `errors.rs`, `types.rs`, `loader.rs` enthalten)

#### Untermodul: `core::config::errors`

**Datei:** `src/config/errors.rs`

##### 1. Enum: `ConfigError`

- **Zweck:** Fehler, die beim Laden oder Verarbeiten von Konfigurationen auftreten können.
- **Ableitungen:** `#[derive(Debug, thiserror::Error)]`
- **Varianten:**
    - `#[error("Failed to read configuration file from path '{path}': {source}")]` `FileReadError { path: PathBuf, #[source] source: std::io::Error }`
    - `#[error("Failed to deserialize configuration from path '{path}': {source}")]` `DeserializationError { path: PathBuf, #[source] source: toml::de::Error }`
    - `#[error("No configuration file found. Checked paths: {checked_paths:?}")]` `NoConfigurationFileFound { checked_paths: Vec<PathBuf> }`
    - `#[error("Configuration already initialized.")]` `AlreadyInitializedError`
    - `#[error("Configuration not yet initialized.")]` `NotInitializedError`
    - `#[error("Invalid configuration value for key '{key}': {reason}")]` (Falls Validierung hier stattfindet) `InvalidValueError { key: String, reason: String }`

#### Untermodul: `core::config::types`

**Datei:** `src/config/types.rs`

##### 1. Struct: `CoreConfig` (Beispielstruktur)

- **Zweck:** Hält alle spezifischen Konfigurationen der Kernschicht. Muss an die tatsächlichen Bedürfnisse angepasst werden.
- **Ableitungen:** `#[derive(Debug, Clone, serde::Deserialize, Default)]`
- **Attribute:** `#[serde(deny_unknown_fields)]` auf der Struktur.
- **Felder (Beispiele):**
    
    Rust
    
    ```
    use serde::Deserialize;
    use std::path::PathBuf;
    
    #[derive(Debug, Clone, Deserialize, Default)]
    #[serde(rename_all = "kebab-case")] // TOML verwendet oft kebab-case
    pub enum LogLevelConfig { // Muss auch in core::logging bekannt sein oder hierhin verschoben werden
        Trace,
        Debug,
        #[default]
        Info,
        Warn,
        Error,
    }
    
    #[derive(Debug, Clone, Deserialize)]
    #[serde(deny_unknown_fields)]
    pub struct CoreConfig {
        #[serde(default = "default_log_level")]
        pub log_level: LogLevelConfig,
        #[serde(default = "default_some_path")]
        pub some_critical_path: PathBuf,
        #[serde(default)] // Verwendet FeatureFlags::default()
        pub feature_flags: FeatureFlags,
    }
    
    // Default-Funktionen müssen den korrekten Typ zurückgeben
    fn default_log_level() -> LogLevelConfig { LogLevelConfig::default() }
    fn default_some_path() -> PathBuf { PathBuf::from("/usr/share/novade/default_resource") }
    
    impl Default for CoreConfig {
        fn default() -> Self {
            Self {
                log_level: default_log_level(),
                some_critical_path: default_some_path(),
                feature_flags: FeatureFlags::default(),
            }
        }
    }
    
    #[derive(Debug, Clone, Deserialize, Default)]
    #[serde(deny_unknown_fields)]
    pub struct FeatureFlags {
        #[serde(default)] // bool standardmäßig auf false
        pub enable_alpha_feature: bool,
        #[serde(default = "default_beta_timeout_ms")]
        pub beta_feature_timeout_ms: u64,
    }
    
    fn default_beta_timeout_ms() -> u64 { 1000 }
    ```
    
- **Validierung:** Grundlegende Validierung durch Typen und `serde`-Attribute. Komplexere Validierung kann nach Deserialisierung erfolgen (z.B. `TryFrom<RawCoreConfig>` oder `validate()`-Methode), die dann `ConfigError::InvalidValueError` zurückgibt.

#### Untermodul: `core::config::loader`

**Datei:** `src/config/loader.rs`

##### 1. Funktion: `load_core_config`

- **Signatur:** `pub fn load_core_config(config_paths: &[PathBuf]) -> Result<CoreConfig, ConfigError>` (Nimmt eine Liste von Pfaden, um sie der Reihe nach zu prüfen).
- **Logik:**
    1. Iteriere über `config_paths`.
    2. Für jeden Pfad:
        - Prüfe, ob die Datei existiert.
        - Wenn ja, versuche sie zu lesen: `std::fs::read_to_string(path).map_err(|e| ConfigError::FileReadError { path: path.to_path_buf(), source: e })?`.
        - Versuche, den Inhalt zu deserialisieren: `toml::from_str(&content_str).map_err(|e| ConfigError::DeserializationError { path: path.to_path_buf(), source: e })?`.
        - Wenn erfolgreich, gib `Ok(config)` zurück.
    3. Wenn keine Datei gefunden oder erfolgreich geparst wurde, gib `Err(ConfigError::NoConfigurationFileFound { checked_paths: config_paths.to_vec() })` zurück.

#### Statischer Zugriff (`core::config::mod.rs` oder `core::config::global.rs`)

Rust

```
// In core::config::mod.rs oder einem neuen core::config::global.rs
use super::types::CoreConfig;
use super::errors::ConfigError;
use once_cell::sync::OnceCell;
use std::path::PathBuf;

static CORE_CONFIG: OnceCell<CoreConfig> = OnceCell::new();

/// Initialisiert die globale Core-Konfiguration.
/// Darf nur einmal während des Anwendungsstarts aufgerufen werden.
pub fn initialize_global_core_config(config: CoreConfig) -> Result<(), ConfigError> {
    CORE_CONFIG.set(config).map_err(|_| ConfigError::AlreadyInitializedError)
}

/// Gibt eine Referenz auf die global initialisierte Core-Konfiguration zurück.
///
/// # Panics
///
/// Paniert, wenn `initialize_global_core_config()` nicht zuvor erfolgreich aufgerufen wurde.
/// Dies signalisiert einen schwerwiegenden Programmierfehler in der Anwendungsinitialisierung.
pub fn get_global_core_config() -> &'static CoreConfig {
    CORE_CONFIG.get().expect("CoreConfig wurde nicht initialisiert. initialize_global_core_config() muss zuerst aufgerufen werden.")
}

/// Lädt die Konfiguration von den angegebenen Pfaden und initialisiert sie global.
/// Dies ist eine Bequemlichkeitsfunktion.
pub fn load_and_initialize_global_config(config_paths: &[PathBuf]) -> Result<(), ConfigError> {
    use super::loader::load_core_config; // Pfad anpassen
    let config = load_core_config(config_paths)?;
    initialize_global_core_config(config)
}
```

##### Implementierungsschritte `core::config`

1. **Abhängigkeiten in `core/Cargo.toml`:**
    
    Ini, TOML
    
    ```
    serde = { version = "1.0", features = ["derive"] }
    toml = "0.8" # Aktuelle Version prüfen
    once_cell = "1.19" # Aktuelle Version prüfen
    ```
    
2. **Verzeichnisstruktur erstellen:** `core/src/config/`, darin `mod.rs`, `errors.rs`, `types.rs`, `loader.rs`, `global.rs` (optional).
3. **`errors.rs`:** `ConfigError` Enum implementieren.
4. **`types.rs`:** `CoreConfig` (und ggf. untergeordnete Strukturen wie `LogLevelConfig`, `FeatureFlags`) mit `serde`-Attributen und `Default`-Implementierungen definieren. Default-Funktionen erstellen.
5. **`loader.rs`:** `load_core_config` Funktion implementieren.
6. **`global.rs` (oder `mod.rs`):** Statische `CORE_CONFIG` Variable mit `OnceCell`, `initialize_global_core_config`, `get_global_core_config` und `load_and_initialize_global_config` implementieren.
7. **`config/mod.rs`:** Module deklarieren und öffentliche Typen/Funktionen re-exportieren.
    
    Rust
    
    ```
    pub mod errors;
    pub mod types;
    pub mod loader;
    pub mod global; // oder Inhalt direkt hier
    
    pub use errors::ConfigError;
    pub use types::{CoreConfig, LogLevelConfig, FeatureFlags}; // Beispiele
    pub use loader::load_core_config;
    pub use global::{initialize_global_core_config, get_global_core_config, load_and_initialize_global_config};
    ```
    
8. **Aktualisierung `core/src/lib.rs`:** `pub mod config;`
9. **Unit-Tests:**
    - `ConfigError`: Teste Display-Implementierungen.
    - `CoreConfig`: Teste `Default`-Implementierung und `serde` (De-)Serialisierung mit Beispieldaten (gültiges TOML, TOML mit fehlenden Feldern, TOML mit unbekannten Feldern bei `deny_unknown_fields`).
    - `load_core_config`:
        - Test mit gültiger Konfigurationsdatei.
        - Test mit mehreren Pfaden, wobei die erste gefundene Datei verwendet wird.
        - Test, wenn keine Datei gefunden wird (`NoConfigurationFileFound`).
        - Test mit nicht lesbarer Datei (`FileReadError`).
        - Test mit fehlerhafter TOML-Syntax (`DeserializationError`).
    - Globaler Zugriff: Teste `initialize_global_core_config` (Erfolg, Fehler bei Mehrfachinitialisierung), `get_global_core_config` (Erfolg nach Init, Panic vor Init).

---

### Modul: `core::utils` (Allgemeine Hilfsfunktionen)

**Zweck:** Beherbergt allgemeine, in sich geschlossene Hilfsfunktionen, die nicht in spezifischere Module passen.

**Designphilosophie:** Einfachheit, Reinheit (wo möglich), keine Abhängigkeiten zu anderen Kernschicht-Modulen außer `core::errors` (für Utility-spezifische Fehler).

**Abhängigkeiten:** `std`, `thiserror`.

**Struktur:** Dieses Modul kann in Submodule unterteilt werden, falls viele Utilities entstehen (z.B. `core::utils::string`, `core::utils::math`). Für den Anfang eine einzelne `src/utils.rs`.

**Datei:** `src/utils.rs` (und ggf. `src/utils/errors.rs`)

#### Beispiel: Utility-Submodul `core::utils::path_utils`

**Datei:** `src/utils/path_utils.rs`

##### 1. Enum: `PathUtilError`

- **Ableitungen:** `#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]`
- **Varianten:**
    - `#[error("Path normalization failed: {0}")]` `NormalizationFailed(String)`

##### 2. Funktion: `normalize_path_robustly` (Beispiel für ein komplexeres Utility)

- **Signatur:** `pub fn normalize_path_robustly(path: &std::path::Path) -> Result<PathBuf, PathUtilError>`
- **Logik:** (Hier würde eine detaillierte Schritt-für-Schritt-Beschreibung des Normalisierungsalgorithmus stehen, z.B. Auflösen von `.` und `..`, Umgang mit Symlinks (falls im Scope), Sicherstellung einer kanonischen Form). Für diese Spezifikation wird kein konkreter Algorithmus vorgegeben, da die Anforderung eines "komplexen" Utilities noch nicht klar ist.
- **Fehlerbehandlung:** Gibt `PathUtilError` zurück.

#### Allgemeine Richtlinien für `core::utils`

- **Geltungsbereich:** Nur wirklich allgemeine Utilities.
- **Einfachheit:** Einfache Funktionen bevorzugen.
- **Reinheit:** Reine Funktionen bevorzugen.
- **Fehlerbehandlung:** Jede fehleranfällige Utility-Funktion gibt `Result<T, YourUtilError>` zurück, wobei `YourUtilError` mit `thiserror` im Utility-Submodul definiert und in einen allgemeinen `UtilsError` (oder direkt in `CoreError` via `#[from]`, falls sehr generisch) gewrappt werden kann.
- **Dokumentation:** Umfassende `rustdoc`-Kommentare mit Beispielen.
- **Tests:** Gründliche Unit-Tests für jede Utility-Funktion.

##### Implementierungsschritte `core::utils`

1. **Datei `core/src/utils/mod.rs` (oder `core/src/utils.rs`) erstellen.**
2. Falls Submodule für Utilities benötigt werden (z.B. `path_utils.rs`), diese erstellen und in `utils/mod.rs` deklarieren.
3. Für jedes Utility oder Utility-Submodul ggf. eine eigene `errors.rs` erstellen oder Fehler im Haupt-`core::errors` definieren, falls extrem generisch.
4. Utility-Funktionen implementieren, dabei die oben genannten Richtlinien beachten.
5. Umfassende Unit-Tests für jede Funktion schreiben.
6. **Aktualisierung `core/src/lib.rs`:** `pub mod utils;`

---

**Finale `core/src/lib.rs` (Beispiel):**

Rust

```
// src/lib.rs

// Module deklarieren
pub mod config;
pub mod errors;
pub mod logging;
pub mod types;
pub mod utils;

// Wichtige Typen und Funktionen re-exportieren, falls gewünscht
pub use errors::{CoreError, ColorParseError}; // Beispiel
pub use types::{Point, Size, Rect, RectInt, Color, Orientation}; // Beispiel
// ...usw. für andere Module, falls eine flachere API für das Crate gewünscht ist.

// Dieser Crate dient als Fundament und sollte keine spezifische Anwendungslogik enthalten.
// Seine API sollte stabil und gut dokumentiert sein.
```

---

## 3. Ausblick auf weitere Schichten (Methodik)

Die Ultra-Feinspezifikationen für die Domänen-, System- und UI-Schicht würden derselben detaillierten Methodik folgen:

1. **Modulübersicht:** Zweck, Verantwortlichkeiten, Design-Rationale.
2. **Datenstrukturen und Typdefinitionen:**
    - Alle `struct`s, `enum`s, `trait`s, Typaliase in Rust-Syntax.
    - Felder/Varianten: Name, Typ, Sichtbarkeit, Initialwerte (falls zutreffend).
    - Ableitungen (`Debug`, `Clone`, `Serialize`, `Deserialize`, `Default`, `thiserror::Error`, etc.).
    - Invarianten und Geschäftsregeln, die durch die Typen abgebildet werden.
3. **Öffentliche API und Interne Schnittstellen:**
    - Exakte Signaturen aller `pub fn`, `pub trait`, `pub struct` Methoden (Parameter: Name, Typ; Rückgabetyp; `async`, `const`, Zugriffsmodifikatoren).
    - Vor- und Nachbedingungen für jede Methode.
    - Detaillierte Beschreibung der Logik/Algorithmen, die die Methode implementiert.
4. **Event-Spezifikationen (falls zutreffend):**
    - Eindeutiger Event-Name/Typ (Rust-Struktur).
    - Payload-Struktur (Felder und deren Typen).
    - Typische Publisher und Subscriber.
    - Auslösebedingungen für das Event.
5. **Fehlerbehandlung:**
    - Definition des modulspezifischen Fehler-Enums mit `thiserror`.
    - Jede Variante: `#[error("...")]`-Nachricht, Felder für Kontext.
    - Verwendung von `#[source]` und `#[from]` für Fehlerverkettung und -konvertierung.
    - Abbildung von Fehlern aus tieferliegenden Schichten oder externen Bibliotheken.
6. **Zustandsverwaltung und Lebenszyklus (für komplexe Komponenten):**
    - Detaillierte Beschreibung des internen Zustands.
    - Methoden zur Zustandsänderung und deren Auswirkungen.
    - Lebenszyklusmanagement (Initialisierung, Laufzeit, Beendigung).
7. **Interaktionen und Abhängigkeiten:**
    - Mit anderen Modulen derselben Schicht.
    - Mit Modulen anderer Schichten (explizite Nutzung von deren APIs oder Events).
8. **Detaillierte Implementierungsschritte:**
    - Ziel-Dateistruktur für das Modul.
    - Schritt-für-Schritt-Anleitung zur Implementierung von Datenstrukturen, Logik und API.
    - Reihenfolge der Implementierung von Funktionen/Methoden.
9. **Testaspekte:**
    - Identifikation testkritischer Logik.
    - Beispiele für Unit-Testfälle (Szenarien, Eingaben, erwartete Ausgaben/Fehler).
    - Hinweise zu Mocking-Strategien für Abhängigkeiten.

Für die **Domänenschicht** würde dies beispielsweise für `domain::theming`, `domain::workspaces`, `domain::user_centric_services` etc. detailliert erfolgen, wobei jede Entität, jeder Service-Trait und jede Methode genau spezifiziert wird.

Für die **Systemschicht** (z.B. `system::compositor`, `system::input`, `system::dbus`) wäre die Spezifikation besonders komplex, da sie die Interaktion mit externen Bibliotheken (Smithay, libinput, zbus), Wayland-Protokollen und Systemdiensten detailliert beschreiben muss. Hier wären die Handler-Implementierungen (z.B. `CompositorHandler`, `XdgShellHandler`) und die exakte Nutzung der Smithay-APIs im Fokus.

Für die **UI-Schicht** (z.B. `ui::shell`, `ui::widgets`, `ui::control_center`) würde die Spezifikation die GTK4-Widget-Struktur, das Layout, die Signal-Handler, die Datenbindung an Domänen-/Systemzustände und die Logik zur Auslösung von Aktionen in den unteren Schichten detailliert beschreiben.

Dieser extrem detaillierte Ansatz ist sehr aufwendig, stellt aber sicher, dass Entwickler eine klare, unmissverständliche Anleitung haben, was die Konsistenz und Qualität des Endprodukts maßgeblich verbessert.

**Struktur der Domänenschicht-Spezifikation:**

Die Domänenschicht (`novade-domain` Crate) wird in folgende logische Hauptmodule unterteilt, die teilweise bereits in Ihren Dokumenten skizziert wurden. Ich werde diese Struktur beibehalten und verfeinern:

1. **`domain::theming`**: Logik der Theming-Engine. (Basierend auf)
2. **`domain::workspaces`**: Umfassende Verwaltungslogik für Arbeitsbereiche. (Basierend auf)
    - `workspaces::core`
    - `workspaces::assignment`
    - `workspaces::manager`
    - `workspaces::config`
3. **`domain::user_centric_services`**: KI-Interaktion und Benachrichtigungsmanagement. (Basierend auf)
    - `user_centric_services::ai_interaction`
    - `user_centric_services::notifications_core`
4. **`domain::notifications_rules`**: Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf Regeln. (Basierend auf der Gesamtspezifikation und )
5. **`domain::global_settings_and_state_management`**: Repräsentation und Logik globaler Desktop-Einstellungen. (Basierend auf der Gesamtspezifikation und)
    - `global_settings::types` (Definition der Einstellungsstrukturen)
    - `global_settings::service` (Der `GlobalSettingsService` Trait und Implementierung)
    - `global_settings::paths` (Der `SettingPath` Enum)
    - `global_settings::persistence_iface` (Trait für die Persistenz, Interaktion mit `core::config`)
6. **`domain::window_management_policy`**: High-Level-Regeln und Richtlinien für Fensterplatzierung, Tiling etc. (Basierend auf der Gesamtspezifikation)
7. **`domain::common_events`**: Definition von Domänen-übergreifenden Events, die nicht spezifisch einem einzelnen Service zugeordnet sind, oder als gemeinsame Payloads dienen.
8. **`domain::shared_types`**: Wiederverwendbare, domänenspezifische Typen, die von mehreren Domänenmodulen genutzt werden, aber nicht in `core::types` gehören (z.B. spezifische IDs, Status-Enums).

**Allgemeine Entwicklungsrichtlinien für die Domänenschicht (Wiederholung und Erweiterung):**

- **UI-Unabhängigkeit:** Die Domänenschicht darf keine direkten Abhängigkeiten zu UI-Toolkits (GTK4) oder spezifischen UI-Implementierungen haben.
- **Systemunabhängigkeit:** Keine direkte Abhängigkeit von Systemdetails wie D-Bus oder Wayland-Protokollen. Diese werden von der Systemschicht gehandhabt.
- **Fokus auf Geschäftslogik:** Enthält die Kernregeln und -prozesse der Desktop-Umgebung.
- **API-Design:** Öffentliche Schnittstellen werden primär über Traits definiert, um Testbarkeit (Mocking) und lose Kopplung zu fördern.
- **Zustandsverwaltung:** Veränderliche Zustände innerhalb von Services werden threadsicher gekapselt (z.B. `Arc<Mutex<...>>` oder `Arc<RwLock<...>>`).
- **Asynchronität:** `async/await` und `async_trait` werden für Operationen verwendet, die potenziell blockieren könnten (z.B. Warten auf Ergebnisse von der Systemschicht, komplexe Berechnungen, die ausgelagert werden können). Die primäre Runtime (z.B. `tokio`) wird von der Anwendung bereitgestellt, die die Domänenschicht nutzt.
- **Events:** Ein klar definierter Event-Mechanismus (z.B. `tokio::sync::broadcast` oder ein dedizierter Event-Bus-Trait) wird für die Kommunikation von Zustandsänderungen zwischen Domänenmodulen und an höhere Schichten verwendet.
- **Fehlerbehandlung:** Konsequente Nutzung von `thiserror` für modulspezifische Fehler-Enums. Fehler aus der Kernschicht werden ggf. gewrappt (`#[from]`).
- **Validierung:** Eingabedaten und Zustandsänderungen werden aktiv validiert.
- **Serialisierung:** `serde` wird für Datenstrukturen verwendet, die persistiert oder über Schnittstellen ausgetauscht werden müssen.
- **Abhängigkeit zur Kernschicht:** Die Domänenschicht nutzt ausschließlich die Kernschicht (`core::*`) für fundamentale Typen, Fehlerbasis, Logging und Konfigurationsprimitive.

---

## Ultra-Feinspezifikation: Domänenschicht (`novade-domain` Crate)

### Modul 1: `domain::theming`

**Zweck:** Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel.

**Bestehende Spezifikation:** wird als Basis verwendet und hier integriert/verfeinert.

#### Untermodul: `domain::theming::types`

**Datei:** `src/theming/types.rs`

- **Struct `TokenIdentifier`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Ord, PartialOrd` (für konsistente Sortierung in HashMaps/Sets, falls Schlüssel Iteriert werden).
- **Enum `TokenValue`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Eq, Hash` (falls `TokenIdentifier` es ist und für `Color`, `Dimension` etc. eine Hash-Implementierung sinnvoll ist – für String-basierte Werte ist dies der Fall).
- **Struct `RawToken`**: Wie in spezifiziert.
- **Typalias `TokenSet`**: Wie in spezifiziert.
- **Struct `ThemeIdentifier`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Ord, PartialOrd`.
- **Enum `ColorSchemeType`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Eq, Hash`.
- **Struct `AccentColor`**: Wie in spezifiziert.
    - **Ableitungen zusätzlich:** `Eq, Hash` (falls `name` `Option<String>` ist und `value` `String`).
- **Struct `ThemeVariantDefinition`**: Wie in spezifiziert.
- **Struct `ThemeDefinition`**: Wie in spezifiziert.
- **Struct `AppliedThemeState`**: Wie in spezifiziert.
    - **Felder:**
        - `pub theme_id: ThemeIdentifier`
        - `pub color_scheme: ColorSchemeType`
        - `pub active_accent_color: Option<AccentColor>`
        - `pub resolved_tokens: std::collections::HashMap<TokenIdentifier, String>`
    - **Invarianten:** `resolved_tokens` darf keine Referenzen enthalten, alle Werte sind finale CSS-Strings.
- **Struct `ThemingConfiguration`**: Wie in spezifiziert.

#### Untermodul: `domain::theming::errors`

**Datei:** `src/theming/errors.rs`

- **Enum `ThemingError`**: Wie in spezifiziert.
    - **Varianten (Beispiele, konsolidiert):**
        - `TokenFileParseError { path: PathBuf, #[source] source: serde_json::Error }`
        - `TokenFileIoError { path: PathBuf, #[source] source: std::io::Error }`
        - `InvalidTokenData { path: PathBuf, message: String }`
        - `CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> }`
        - `ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: serde_json::Error }`
        - `ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: std::io::Error }`
        - `InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String }`
        - `ThemeNotFound { theme_id: ThemeIdentifier }`
        - `MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier }`
        - `MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 }`
        - `ThemeApplicationError { message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
        - `FallbackThemeLoadError { #[source] source: Box<dyn std::error::Error + Send + Sync + 'static> }`
        - `InitialConfigurationError(String)`
        - `InternalStateError(String)`
        - `EventSubscriptionError(String)`
        - `AccentColorProcessingError { theme_id: ThemeIdentifier, accent_value: String, message: String }` (Neu, für Fehler bei Akzentfarben-Anwendung)
        - `TokenResolutionError { token_id: TokenIdentifier, message: String }` (Allgemeiner Fehler während der Auflösung)

#### Untermodul: `domain::theming::logic` (oder `domain::theming::engine_internal`)

**Datei:** `src/theming/logic.rs` (oder aufgeteilt in `token_loader.rs`, `theme_loader.rs`, `token_resolver.rs` etc.)

- **Kernlogik und Geschäftsregeln** wie in spezifiziert:
    - Laden, Parsen, Validieren von Token- (_.tokens.json) und Theme-Definitionen (_.theme.json).
        - **Funktion:** `pub(crate) async fn load_and_validate_token_files(paths: &[PathBuf]) -> Result<TokenSet, ThemingError>`
        - **Funktion:** `pub(crate) async fn load_and_validate_theme_files(paths: &[PathBuf], global_tokens: &TokenSet) -> Result<Vec<ThemeDefinition>, ThemingError>`
    - Token Resolution Pipeline:
        - **Funktion:** `pub(crate) fn resolve_tokens_for_config(config: &ThemingConfiguration, theme_def: &ThemeDefinition, global_tokens: &TokenSet, max_depth: u8) -> Result<std::collections::HashMap<TokenIdentifier, String>, ThemingError>`
            - Schritt 1: Basissatz (Globale Tokens + Theme Base Tokens)
            - Schritt 2: Varianten-spezifische Tokens anwenden
            - Schritt 3: Akzentfarben-Logik anwenden (Direkte Ersetzung spezifischer Tokens, z.B. `token.system.accent.primary`, `token.system.accent.secondary`)
            - Schritt 4: Benutzerdefinierte globale Token-Overrides anwenden
            - Schritt 5: Rekursive Auflösung von `TokenValue::Reference` mit Zyklenerkennung und Tiefenbegrenzung.
            - Schritt 6: Finale Wertkonvertierung zu `String`.
    - Caching-Logik für `AppliedThemeState`.
        - **Typ:** `CacheKey(ThemeIdentifier, ColorSchemeType, Option<AccentColorHash>, UserOverridesHash)`
        - Cache-Struktur: `std::collections::HashMap<CacheKey, AppliedThemeState>`
    - Laden des Fallback-Themes (siehe).
        - **Funktion:** `pub(crate) fn load_fallback_theme_definition() -> Result<(ThemeDefinition, TokenSet), ThemingError>` (aus eingebetteten Strings)
        - **Funktion:** `pub(crate) fn generate_fallback_applied_state() -> AppliedThemeState`

#### Öffentliche API: `ThemingEngine` Service

**Datei:** `src/theming/mod.rs` (oder `src/theming/api.rs` oder `src/theming/service.rs`)

- **Struct `ThemingEngine`**: Wie in spezifiziert, verwendet `Arc<Mutex<ThemingEngineInternalState>>`.
    - **`ThemingEngineInternalState` Felder:**
        - `current_config: ThemingConfiguration`
        - `available_themes: Vec<ThemeDefinition>`
        - `global_raw_tokens: TokenSet`
        - `applied_state: AppliedThemeState`
        - `theme_load_paths: Vec<PathBuf>`
        - `token_load_paths: Vec<PathBuf>`
        - `resolved_state_cache: std::collections::HashMap<(ThemeIdentifier, ColorSchemeType, Option<String>, u64), AppliedThemeState>` (Cache-Schlüssel muss Hashable sein; Option&lt;AccentColor> könnte zu Option&lt;String> für den Farbwert vereinfacht werden, UserOverrides zu einem Hash).
        - `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>` (anstelle von `mpsc`)
- **Methoden der `ThemingEngine`**:
    - `pub async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, broadcast_capacity: usize) -> Result<Self, ThemingError>`
        - Initialisiert `event_sender = tokio::sync::broadcast::channel(broadcast_capacity).0;`
        - Lädt Themes und Tokens asynchron.
        - Berechnet initialen `applied_state` oder Fallback.
    - `pub async fn get_current_theme_state(&self) -> AppliedThemeState` (gibt Klon von `applied_state` zurück, kein `Result` wenn interner Zustand immer gültig ist).
    - `pub async fn get_available_themes(&self) -> Vec<ThemeDefinition>` (gibt Klon zurück).
    - `pub async fn get_current_configuration(&self) -> ThemingConfiguration` (gibt Klon zurück).
    - `pub async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`
        - Berechnet neuen `applied_state`.
        - Wenn geändert, `self.event_sender.send(ThemeChangedEvent { ... }).map_err(...)`. Ignoriere Fehler, wenn keine Subscriber da sind (`Ok(_)`).
    - `pub async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`
        - Lädt Themes/Tokens neu.
        - Wendet `current_config` neu an, aktualisiert `applied_state`.
        - Sendet Event, falls geändert.
        - Invalidiert Cache.
    - `pub fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`
        - Gibt `self.event_sender.subscribe()` zurück.
- **Event `ThemeChangedEvent`**: Wie in spezifiziert.
    - **Payload:** `pub new_state: AppliedThemeState`
    - **Publisher:** `ThemingEngine`
    - **Subscriber:** `ui::theming_gtk`, andere UI-Komponenten, `domain::global_settings_service` (falls Theming von globalen Einstellungen abhängt).

#### Implementierungsschritte `domain::theming`

1. **Dateistruktur anlegen:** Gemäß.
2. **`types.rs` implementieren:** Alle Datenstrukturen mit `serde`-Attributen und Ableitungen.
3. **`errors.rs` implementieren:** `ThemingError`-Enum mit `thiserror`.
4. **`logic.rs` (oder Submodule) implementieren:**
    - Token-/Theme-Lade- und Validierungsfunktionen (asynchron).
    - Token Resolution Pipeline (synchron, da CPU-gebunden nach dem Laden).
    - Fallback-Theme-Logik.
    - Caching-Logik.
5. **`ThemingEngine`-Service (`mod.rs` oder `service.rs`) implementieren:**
    - `ThemingEngineInternalState` und `ThemingEngine` Strukturen.
    - `new()`-Konstruktor (asynchron).
    - Alle öffentlichen API-Methoden (asynchron, wo sinnvoll).
    - Event-Versand mit `tokio::sync::broadcast`.
6. **Unit-Tests:**
    - Für alle Datenstrukturen: Serialisierung/Deserialisierung.
    - Für `ThemingError`: `Display`-Implementierung und `source()`-Verhalten.
    - Für Lade-/Validierungslogik: Gültige/ungültige Dateien, Zyklen, fehlende Referenzen.
    - Für Token Resolution Pipeline: Verschiedene Szenarien (Basis, Varianten, Overrides, Akzente, komplexe Referenzen, Fehlerfälle).
    - Für `ThemingEngine`: API-Methodenverhalten, Zustandsänderungen, Event-Auslösung, Cache-Verhalten, Thread-Sicherheit (konzeptionell, durch korrekte Mutex-Nutzung).

---

### Modul 2: `domain::workspaces`

**Zweck:** Umfassende Verwaltungslogik für Arbeitsbereiche ("Spaces").

**Bestehende Spezifikation:** wird als Basis verwendet.

#### Untermodul: `domain::workspaces::core`

**Datei:** `src/workspaces/core/types.rs` (konsolidiert Typen hier)

- **Typalias `WorkspaceId`**: `pub type WorkspaceId = uuid::Uuid;`
- **Struct `WindowIdentifier`**: `#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)] pub struct WindowIdentifier(String);`
    - Methoden: `new(id: String) -> Result<Self, WorkspaceCoreError>`, `as_str()`. `From<String>` für einfache Konvertierung (kann Validierung in `new` haben). `Display`-Implementierung.
- **Enum `WorkspaceLayoutType`**: `#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)] pub enum WorkspaceLayoutType { #[default] Floating, TilingHorizontal, TilingVertical, Maximized }`
- **Struct `Workspace`**: Wie in spezifiziert.
    - **Felder:** `id: WorkspaceId`, `name: String`, `persistent_id: Option<String>`, `layout_type: WorkspaceLayoutType`, `window_ids: HashSet<WindowIdentifier>`, `created_at: chrono::DateTime<chrono::Utc>`.
    - **Ableitungen:** `#[derive(Debug, Clone, Serialize, Deserialize)]` (`PartialEq` ggf. manuell wegen `HashSet`).
    - **Methoden:** `new(...) -> Result<Self, WorkspaceCoreError>`, `id()`, `name()`, `rename(...) -> Result<...>`, `layout_type()`, `set_layout_type(...)`, `add_window_id(&mut self, ...)` (pub(crate)), `remove_window_id(&mut self, ...)` (pub(crate)), `window_ids()`, `persistent_id()`, `set_persistent_id(...) -> Result<...>`, `created_at()`.

**Datei:** `src/workspaces/core/event_data.rs`

- **Event-Payload-Strukturen**: `WorkspaceRenamedData`, `WorkspaceLayoutChangedData`, `WindowAddedToWorkspaceData`, `WindowRemovedFromWorkspaceData`, `WorkspacePersistentIdChangedData` - wie in spezifiziert. Alle mit `#[derive(Debug, Clone, Serialize, Deserialize)]`.

**Datei:** `src/workspaces/core/errors.rs`

- **Konstante `MAX_WORKSPACE_NAME_LENGTH`**: `pub const MAX_WORKSPACE_NAME_LENGTH: usize = 64;`
- **Enum `WorkspaceCoreError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `InvalidName(String)`
        - `NameCannotBeEmpty`
        - `NameTooLong { name: String, max_len: usize, actual_len: usize }`
        - `InvalidPersistentId(String)` (z.B. leer oder ungültige Zeichen)
        - `Internal { context: String }`
        - `WindowIdentifierEmpty` (Für `WindowIdentifier::new`)

#### Untermodul: `domain::workspaces::assignment`

**Datei:** `src/workspaces/assignment/mod.rs`

- **Öffentliche API-Funktionen**: Operieren auf `&mut std::collections::HashMap<WorkspaceId, Workspace>`. Wie in spezifiziert.
    - `pub fn assign_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier, ensure_unique_assignment: bool) -> Result<(), WindowAssignmentError>`
    - `pub fn remove_window_from_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<bool, WindowAssignmentError>`
    - `pub fn move_window_to_workspace(workspaces: &mut HashMap<WorkspaceId, Workspace>, source_workspace_id: WorkspaceId, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WindowAssignmentError>`
    - `pub fn find_workspace_for_window(workspaces: &HashMap<WorkspaceId, Workspace>, window_id: &WindowIdentifier) -> Option<WorkspaceId>`

**Datei:** `src/workspaces/assignment/errors.rs`

- **Enum `WindowAssignmentError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `WorkspaceNotFound(WorkspaceId)`
        - `WindowAlreadyAssigned { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `WindowNotAssignedToWorkspace { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `SourceWorkspaceNotFound(WorkspaceId)`
        - `TargetWorkspaceNotFound(WorkspaceId)`
        - `WindowNotOnSourceWorkspace { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `CannotMoveToSameWorkspace { workspace_id: WorkspaceId, window_id: WindowIdentifier }`
        - `RuleViolation { reason: String, window_id: Option<WindowIdentifier>, target_workspace_id: Option<WorkspaceId> }`
        - `Internal { context: String }`

#### Untermodul: `domain::workspaces::manager`

**Datei:** `src/workspaces/manager/events.rs`

- **Enum `WorkspaceEvent`**: Wie in spezifiziert. Alle Payloads mit `#[derive(Debug, Clone, Serialize, Deserialize)]`.
    - Payload-Strukturen aus `workspaces::core::event_data` werden hier verwendet.

**Datei:** `src/workspaces/manager/errors.rs`

- **Enum `WorkspaceManagerError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `WorkspaceNotFound(WorkspaceId)`
        - `CannotDeleteLastWorkspace`
        - `DeleteRequiresFallbackForWindows { workspace_id: WorkspaceId, window_count: usize }`
        - `FallbackWorkspaceNotFound(WorkspaceId)`
        - `CoreError { #[from] source: crate::domain::workspaces::core::errors::WorkspaceCoreError }`
        - `AssignmentError { #[from] source: crate::domain::workspaces::assignment::errors::WindowAssignmentError }`
        - `ConfigError { #[from] source: crate::domain::workspaces::config::errors::WorkspaceConfigError }`
        - `SetActiveWorkspaceNotFound(WorkspaceId)`
        - `NoActiveWorkspace`
        - `DuplicatePersistentId(String)`
        - `Internal { context: String }`

**Datei:** `src/workspaces/manager/mod.rs` (oder `service.rs`)

- **Trait `EventPublisher<E>` (Beispiel, falls nicht global):** `pub trait EventPublisher<E: Clone + Send + 'static>: Send + Sync { fn publish(&self, event: E); }`
- **Struct `WorkspaceManager`**: Wie in spezifiziert.
    - **Felder:**
        - `workspaces: HashMap<WorkspaceId, Workspace>`
        - `active_workspace_id: Option<WorkspaceId>`
        - `ordered_workspace_ids: Vec<WorkspaceId>`
        - `next_workspace_number: u32`
        - `config_provider: Arc<dyn WorkspaceConfigProvider>` (aus `workspaces::config`)
        - `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`
        - `ensure_unique_window_assignment: bool`
- **Methoden der `WorkspaceManager`** (alle `async` wo I/O oder potenziell blockierende Logik involviert ist, insbesondere `save_configuration` und `new`):
    - `pub async fn new(config_provider: Arc<dyn WorkspaceConfigProvider>, broadcast_capacity: usize, ensure_unique_window_assignment: bool) -> Result<Self, WorkspaceManagerError>`
    - `pub async fn create_workspace(&mut self, name: Option<String>, persistent_id: Option<String>) -> Result<WorkspaceId, WorkspaceManagerError>`
    - `pub async fn delete_workspace(&mut self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>`
    - `pub fn get_workspace(&self, id: WorkspaceId) -> Option<&Workspace>`
    - `pub fn get_workspace_mut(&mut self, id: WorkspaceId) -> Option<&mut Workspace>`
    - `pub fn all_workspaces_ordered(&self) -> Vec<&Workspace>`
    - `pub fn active_workspace_id(&self) -> Option<WorkspaceId>`
    - `pub async fn set_active_workspace(&mut self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>`
    - `pub async fn assign_window_to_active_workspace(&mut self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `pub async fn assign_window_to_specific_workspace(&mut self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `pub async fn remove_window_from_its_workspace(&mut self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>`
    - `pub async fn move_window_to_specific_workspace(&mut self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>`
    - `pub async fn rename_workspace(&mut self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>`
    - `pub async fn set_workspace_layout(&mut self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>`
    - `pub async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>`
    - `pub fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>`

#### Untermodul: `domain::workspaces::config`

**Datei:** `src/workspaces/config/errors.rs`

- **Enum `WorkspaceConfigError`**: Wie in spezifiziert.
    - **Varianten (konsolidiert):**
        - `LoadError { path: String, #[source] source: crate::core::config::ConfigError }` (nutzt `ConfigError` aus `core`)
        - `SaveError { path: String, #[source] source: crate::core::config::ConfigError }`
        - `InvalidData { reason: String, path: Option<String> }`
        - `SerializationError { message: String, #[source] source: Option<serde_json::Error> }` (oder `toml::ser::Error`)
        - `DeserializationError { message: String, snippet: Option<String>, #[source] source: Option<serde_json::Error> }` (oder `toml::de::Error`)
        - `PersistentIdNotFoundInLoadedSet { persistent_id: String }` (Umbenannt für Klarheit)
        - `DuplicatePersistentIdInLoadedSet { persistent_id: String }` (Umbenannt für Klarheit)
        - `VersionMismatch { expected: Option<String>, found: Option<String> }`
        - `Internal { context: String }`

**Datei:** `src/workspaces/config/mod.rs` (oder `provider.rs` und `types.rs` hier)

- **Struct `WorkspaceSnapshot`**: Wie in spezifiziert. `#[derive(Debug, Clone, Serialize, Deserialize)]`.
    - Felder: `persistent_id: String`, `name: String`, `layout_type: WorkspaceLayoutType`.
- **Struct `WorkspaceSetSnapshot`**: Wie in spezifiziert. `#[derive(Debug, Clone, Serialize, Deserialize, Default)]`.
    - Felder: `workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`.
- **Trait `WorkspaceConfigProvider`**: `#[async_trait::async_trait] pub trait WorkspaceConfigProvider: Send + Sync { async fn load_workspace_config(&self) -> Result<WorkspaceSetSnapshot, WorkspaceConfigError>; async fn save_workspace_config(&self, config_snapshot: &WorkspaceSetSnapshot) -> Result<(), WorkspaceConfigError>; }` (Methoden sind `async` da Dateizugriff erfolgt).
- **Struct `FilesystemConfigProvider`**: Wie in spezifiziert.
    - Implementiert `WorkspaceConfigProvider` `async`. Nutzt `core::config::ConfigService` (oder `load_core_config`/`save_core_config` Äquivalente, die `async` sind).
        - **Logik für `load_workspace_config`**: Asynchrones Lesen der Datei, Deserialisierung, Validierung.
        - **Logik für `save_workspace_config`**: Serialisierung, asynchrones Schreiben der Datei.

#### Implementierungsschritte `domain::workspaces`

1. **`core` Modul implementieren:**
    - Dateien `types.rs`, `event_data.rs`, `errors.rs`, `mod.rs` anlegen.
    - Alle Typen, Enums, Fehler und `Workspace`-Methoden implementieren. Unit-Tests.
2. **`assignment` Modul implementieren:**
    - Dateien `errors.rs`, `mod.rs` anlegen.
    - `WindowAssignmentError` und Zuweisungsfunktionen implementieren. Unit-Tests.
3. **`config` Modul implementieren:**
    - Dateien `errors.rs`, `mod.rs` anlegen.
    - Snapshot-Structs, `WorkspaceConfigError`, `WorkspaceConfigProvider`-Trait und `FilesystemConfigProvider` implementieren (`async`). Unit-Tests mit Mocking für `core::config`.
4. **`manager` Modul implementieren:**
    - Dateien `events.rs`, `errors.rs`, `mod.rs` anlegen.
    - `WorkspaceEvent`, `WorkspaceManagerError` und `WorkspaceManager`-Service implementieren (`async`).
    - Integration von `core`, `assignment`, `config` Logik. Event-Versand mit `tokio::sync::broadcast`.
    - Umfassende Unit- und Integrationstests (Mocking für `config_provider` und `event_publisher`).

---

(Die Spezifikationen für die Module 3 bis 8 würden analog folgen, mit derselben Detailtiefe. Aufgrund der aktuellen Längenbeschränkung werde ich die Titel und eine kurze Zusammenfassung der Verantwortlichkeiten für die verbleibenden Module geben, basierend auf der Gesamtspezifikation und Ihrer vorherigen Ausgabe.)

### Modul 3: `domain::user_centric_services`

**Zweck:** KI-Interaktionsmanagement (inkl. Einwilligungen) und Benachrichtigungsmanagement.

**Bestehende Spezifikation:** wird als Basis verwendet.

#### Untermodul: `domain::user_centric_services::ai_interaction`

- **Datenstrukturen:** `AIInteractionContext`, `AIConsent`, `AIModelProfile`, `AttachmentData`, `AIConsentStatus`, `AIDataCategory`.
- **Service Trait:** `AIInteractionLogicService` (asynchron).
- **Fehler-Enum:** `AIInteractionError`.
- **Events:** `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent`.

#### Untermodul: `domain::user_centric_services::notifications_core`

- **Datenstrukturen:** `Notification`, `NotificationAction`, `NotificationUrgency`, `NotificationActionType`, `NotificationFilterCriteria`, `NotificationSortOrder`.
- **Service Trait:** `NotificationService` (asynchron).
- **Fehler-Enum:** `NotificationError`.
- **Events:** `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent`.

**Implementierungsschritte:** Analog zu den vorherigen Modulen, mit Fokus auf die jeweilige Geschäftslogik, Fehlerbehandlung und Event-Auslösung. Die Persistenz von `AIConsent` und `AIModelProfile` wird an `core::config` delegiert.

---

### Modul 4: `domain::notifications_rules`

**Zweck:** Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln.

#### Untermodul: `domain::notifications_rules::types`

- **Struct `RuleCondition`**: Enum mit Varianten wie `AppNameIs(String)`, `SummaryContains(String)`, `UrgencyIs(NotificationUrgency)`, `SettingIsTrue(SettingPath)` etc. Muss rekursive Strukturen wie `And(Vec<RuleCondition>)`, `Or(Vec<RuleCondition>)`, `Not(Box<RuleCondition>)` unterstützen.
- **Struct `RuleAction`**: Enum mit Varianten wie `SuppressNotification`, `SetUrgency(NotificationUrgency)`, `PlaySound(String)`, `MarkAsPersistent(bool)`.
- **Struct `NotificationRule`**: Enthält `id: Uuid`, `description: String`, `conditions: RuleCondition`, `actions: Vec<RuleAction>`, `is_enabled: bool`, `priority: i32`, `stop_processing_after_match: bool`.
- **Typalias `NotificationRuleSet`**: `Vec<NotificationRule>`.

#### Untermodul: `domain::notifications_rules::errors`

- **Enum `NotificationRulesError`**: Varianten wie `InvalidRuleDefinition`, `ConditionEvaluationError` (mit Details zum Fehler), `ActionApplicationError`, `SettingsAccessError` (wenn `SettingIsTrue` evaluiert wird und `GlobalSettingsService` einen Fehler zurückgibt), `RulePersistenceError` (beim Laden/Speichern von Regeln).

#### Untermodul: `domain::notifications_rules::engine` (oder `service.rs`)

- **Struct `NotificationRulesEngine`**:
    - Hält `rules: NotificationRuleSet` (sortiert nach Priorität).
    - Abhängigkeit zum `GlobalSettingsService` (für `SettingIsTrue` Bedingungen).
    - Methode `pub async fn process_notification(&self, notification: &mut Notification, settings: &GlobalDesktopSettings) -> Result<RuleProcessingResult, NotificationRulesError>`
        - Iteriert durch `is_enabled` Regeln in Prioritätsreihenfolge.
        - Für jede Regel: `evaluate_condition(&rule.conditions, notification, settings)`.
        - Wenn Bedingung zutrifft: `apply_actions(&rule.actions, notification)`.
        - Gibt `RuleProcessingResult::Allow` (ggf. modifizierte Notification) oder `RuleProcessingResult::Suppress` zurück.
- **Enum `RuleProcessingResult`**: `Allow(Notification)`, `Suppress { rule_id: Uuid }`.
- **Interne Funktionen**: `evaluate_condition_recursive(...)`, `apply_action_internal(...)`.

#### Untermodul: `domain::notifications_rules::persistence_iface`

- **Trait `NotificationRulesProvider`**: `async fn load_rules() -> Result<NotificationRuleSet, NotificationRulesError>`, `async fn save_rules(rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`.
- Implementierung (z.B. `FilesystemNotificationRulesProvider`) interagiert mit `core::config`.

**Implementierungsschritte:** Datenstrukturen, Fehler, Logik der Engine (rekursive Bedingungsauswertung), Persistenzschnittstelle. Integration mit `notifications_core::NotificationService`.

---

### Modul 5: `domain::global_settings_and_state_management`

**Zweck:** Repräsentation, Logik zur Verwaltung und Konsistenz globaler Desktop-Einstellungen.

**Bestehende Spezifikation:** wird als Basis verwendet.

#### Untermodul: `domain::global_settings::types`

- **Strukturen:** `GlobalDesktopSettings`, `AppearanceSettings`, `WorkspaceSettings`, `FontSettings`, `InputBehaviorSettings`, `PowerManagementPolicySettings`, `DefaultApplicationsSettings` etc. mit allen Feldern und `serde`-Attributen.
- **Enums:** `ColorScheme`, `FontHinting`, `LidCloseAction` etc.
- `SerdeF32` Wrapper.

#### Untermodul: `domain::global_settings::paths`

- **Enum `SettingPath`**: Hierarchischer Enum zur typsicheren Adressierung von Einstellungen (z.B. `SettingPath::Appearance(AppearanceSettingPath::FontSettings(FontSettingPath::DefaultFontSize))`).

#### Untermodul: `domain::global_settings::errors`

- **Enum `GlobalSettingsError`**: Varianten wie `PathNotFound`, `InvalidValueType`, `ValidationError`, `SerializationError`, `DeserializationError`, `PersistenceError { #[from] source: crate::core::config::ConfigError }`.

#### Untermodul: `domain::global_settings::service`

- **Trait `GlobalSettingsService`**: Methoden (`async` wo nötig):
    - `load_settings()`
    - `save_settings()`
    - `get_current_settings() -> GlobalDesktopSettings`
    - `update_setting(path: SettingPath, value: serde_json::Value)`
    - `get_setting(path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`
    - `reset_to_defaults()`
    - `subscribe_to_changes() -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`
- **Implementierung `DefaultGlobalSettingsService`**: Hält `settings: GlobalDesktopSettings`, `persistence_provider: Arc<dyn SettingsPersistenceProvider>`, `event_sender: tokio::sync::broadcast::Sender<SettingChangedEvent>`.

#### Untermodul: `domain::global_settings::persistence_iface`

- **Trait `SettingsPersistenceProvider`**: `async fn load_global_settings() -> Result<GlobalDesktopSettings, GlobalSettingsError>`, `async fn save_global_settings(settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`.
- Implementierung (z.B. `FilesystemSettingsProvider`) interagiert mit `core::config`.

**Events:** `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`, `SettingsLoadedEvent { settings: GlobalDesktopSettings }`, `SettingsSavedEvent`.

**Implementierungsschritte:** Definition aller Einstellungsstrukturen, `SettingPath`, Fehler, Service-Trait und Implementierung, Persistenzschnittstelle. Event-Mechanismus.

---

### Modul 6: `domain::window_management_policy`

**Zweck:** Definition von High-Level-Regeln und Richtlinien für Fensterplatzierung, Logik für automatisches Tiling (Layout-Typen wie Spalten, Spiralen), Snapping-Verhalten, Fenstergruppierung und Gap-Management. Diese Schicht definiert die "Policy", die Systemschicht die "Mechanik".

#### Untermodul: `domain::window_management_policy::types`

- **Enum `TilingLayoutType`**: `Columns`, `Rows`, `Spiral`, `MaximizedFocused`, `Floating`.
- **Struct `GapSettings`**: `outer_gap: u32`, `inner_gap: u32`.
- **Struct `WindowSnappingPolicy`**: `snap_to_screen_edges: bool`, `snap_to_other_windows: bool`, `snap_distance: u32`.
- **Struct `WindowGroupingPolicy`**: (Regeln für automatische oder manuelle Fenstergruppierung, z.B. `group_by_application_id: bool`).
- **Struct `WindowPlacementPolicy`**: `new_window_placement_strategy: NewWindowPlacementStrategy` (Enum: `Smart`, `Center`, `Cascade`).
- **Struct `FocusPolicy`**: `focus_follows_mouse: bool`, `click_to_focus: bool`, `focus_new_windows: bool`.
- **Struct `ManagedWindowProperties`**: Hält domänenspezifische Eigenschaften eines Fensters, die für die Policy relevant sind (z.B. `current_tiling_layout_override: Option<TilingLayoutType>`, `user_defined_size: Option<Size<u32>>`, `is_floating_override: bool`). Wird über `WindowIdentifier` referenziert.

#### Untermodul: `domain::window_management_policy::errors`

- **Enum `WindowPolicyError`**: `LayoutCalculationError`, `InvalidPolicyConfiguration`.

#### Untermodul: `domain::window_management_policy::service`

- **Trait `WindowManagementPolicyService`**:
    - `async fn get_layout_for_workspace(&self, workspace_id: WorkspaceId, windows_on_workspace: Vec<WindowIdentifier>, available_space: RectInt) -> Result<HashMap<WindowIdentifier, RectInt>, WindowPolicyError>`: Berechnet die Geometrien für Fenster auf einem Workspace basierend auf der Policy.
    - `async fn apply_new_window_policy(&self, window_id: WindowIdentifier, workspace_id: WorkspaceId, current_windows: &[WindowIdentifier]) -> Result<RectInt, WindowPolicyError>`: Bestimmt die initiale Geometrie für ein neues Fenster.
    - `async fn get_snapping_target(&self, moving_window_id: WindowIdentifier, current_rect: RectInt, other_windows: &[(&WindowIdentifier, &RectInt)]) -> Option<RectInt>`: Berechnet ein "Snap"-Ziel.
    - (Weitere Methoden zur Abfrage/Aktualisierung von Policies für Tiling, Gaps, Snapping, Gruppierung, Fokus).
- **Implementierung `DefaultWindowManagementPolicyService`**:
    - Hält die aktuellen Policy-Konfigurationen (geladen von `GlobalSettingsService`).
    - Implementiert die Logik zur Layoutberechnung (Spalten, Spiralen etc.) und Snapping.

**Abhängigkeiten:** `domain::global_settings_service` (zum Lesen der Policy-Konfigurationen), `domain::workspaces` (um Infos über Workspaces und Fenster darauf zu erhalten).

**Interaktion:** Die Systemschicht (`system::window_mechanics`) ruft Methoden dieses Services auf, um die gewünschten Fenstergeometrien und -verhalten zu erhalten und technisch umzusetzen.

---

### Modul 7: `domain::common_events`

**Datei:** `src/common_events.rs`

- **Zweck:** Definition von Event-Typen, die von mehreren Domänenmodulen ausgelöst oder konsumiert werden können oder die als generische Payloads dienen.
- **Beispiele:**
    - `pub struct UserActivityDetectedEvent { timestamp: DateTime<Utc>, activity_type: UserActivityType }`
    - `pub enum UserActivityType { MouseMoved, KeyPressed, WorkspaceSwitched }`
    - `pub struct SystemShutdownInitiatedEvent { reason: String }`

---

### Modul 8: `domain::shared_types`

**Datei:** `src/shared_types.rs`

- **Zweck:** Definition von domänenspezifischen Typen, die von mehreren Domänenmodulen verwendet werden, aber nicht allgemein genug für `core::types` sind.
- **Beispiele:**
    - `pub type ApplicationId = String;` (Falls spezifischer als `WindowIdentifier`)
    - `pub enum UserSessionState { Active, Locked, Idle }` (Domänenrepräsentation, Systemschicht mappt Logind-Zustände darauf)
    - `pub struct ResourceIdentifier { pub r#type: String, pub id: String }` (Für KI-Interaktionen oder andere Ressourcen)

---

**Implementierungsleitfaden (Allgemein für Domänenschicht):**

1. **Crate-Struktur:** Erstellen Sie ein `novade-domain`-Crate.
2. **Modulstruktur:** Legen Sie die Verzeichnisstruktur für die oben genannten Hauptmodule an (z.B. `src/theming/`, `src/workspaces/`, etc.).
3. **Abhängigkeiten in `novade-domain/Cargo.toml`:**
    
    Ini, TOML
    
    ```
    [dependencies]
    novade-core = { path = "../novade-core" } # Relative Pfade anpassen
    thiserror = "1.0"
    serde = { version = "1.0", features = ["derive"] }
    serde_json = "1.0" # Für JsonValue und Fehler
    uuid = { version = "1.0", features = ["v4", "serde"] }
    chrono = { version = "0.4", features = ["serde"] }
    async-trait = "0.1"
    tokio = { version = "1", features = ["sync"] } # Für broadcast channels
    # Ggf. weitere spezifische Crates
    ```
    
4. **Implementierung pro Modul:**
    - Beginnen Sie mit `types.rs` und `errors.rs`.
    - Implementieren Sie dann die Service-Traits und deren interne Logik.
    - Definieren und implementieren Sie die Event-Strukturen und deren Versandlogik.
    - Schreiben Sie umfassende Unit-Tests für jede Komponente.
5. **`novade-domain/src/lib.rs`:** Deklarieren Sie alle öffentlichen Module und re-exportieren Sie die primären Service-Traits und wichtigsten Typen für eine saubere Crate-API.

Dieser detaillierte Plan für die Domänenschicht sollte es den Entwicklern ermöglichen, die Geschäftslogik der NovaDE-Desktop-Umgebung systematisch und konsistent zu implementieren. Der Fokus auf Traits, klare Fehlerdefinitionen und einen Event-basierten Ansatz wird zu einer robusten und wartbaren Schicht führen.

Okay, ich werde nun die Ultra-Feinspezifikation und den detaillierten Implementierungsplan für die **Domänenschicht** des NovaDE-Projekts entwickeln. Ich werde die bereits existierenden Spezifikationen (,,) als Grundlage nehmen, sie konsolidieren, verfeinern und erweitern, um einen lückenlosen Leitfaden zu erstellen.

**Autonome Entscheidung zur Sequenzierung und Submodul-Aufteilung:**

1. **`domain::shared_types`** (Wird zuerst definiert, da von vielen anderen Modulen genutzt)
2. **`domain::common_events`** (Ebenfalls früh, da Events modulübergreifend sein können)
3. **`domain::theming`**
4. **`domain::global_settings_and_state_management`** (Einstellungen beeinflussen viele andere Module)
5. **`domain::workspaces`**
6. **`domain::window_management_policy`** (Baut auf Workspaces und globalen Einstellungen auf)
7. **`domain::user_centric_services`** (KI und Benachrichtigungen, können Einstellungen und Kontext nutzen)
    - `user_centric_services::ai_interaction`
    - `user_centric_services::notifications_core`
8. **`domain::notifications_rules`** (Baut auf `notifications_core` und `global_settings` auf)

Diese Reihenfolge versucht, Abhängigkeiten zu berücksichtigen, indem grundlegendere oder breiter genutzte Module früher spezifiziert werden.

---

## Ultra-Feinspezifikation und Implementierungsplan: Domänenschicht (`novade-domain` Crate)

**Allgemeine Entwicklungsrichtlinien für die Domänenschicht:** (Wiederholung zur Betonung)

- **Sprache:** Rust (Edition 2021 oder neuer)
- **UI-Unabhängigkeit:** Strikte Trennung von UI-Belangen. Keine GTK-Abhängigkeiten.
- **Systemunabhängigkeit:** Keine direkten Systemaufrufe (D-Bus, Wayland-Protokolle).
- **Kernlogik:** Fokus auf Geschäftsregeln und -prozesse.
- **API-Design:** Öffentliche Schnittstellen primär über `async_trait` Traits.
- **Zustandsverwaltung:** Threadsichere Kapselung (`Arc<Mutex<...>>` oder `Arc<RwLock<...>>`).
- **Asynchronität:** `async/await` für potenziell blockierende Operationen. Runtime (`tokio`) wird von der Anwendung bereitgestellt.
- **Events:** `tokio::sync::broadcast` für die Event-Kommunikation.
- **Fehlerbehandlung:** `thiserror` für modulspezifische Fehler-Enums. Sauberes Wrapping von `novade-core::errors`.
- **Validierung:** Aktive Validierung von Eingaben und Zustandsänderungen.
- **Serialisierung:** `serde` für Datenstrukturen, die persistiert oder ausgetauscht werden.
- **Abhängigkeiten:**
    - `novade-core = { path = "../novade-core" }`
    - `thiserror = "1.0"`
    - `serde = { version = "1.0", features = ["derive"] }`
    - `serde_json = "1.0"`
    - `uuid = { version = "1.8", features = ["v4", "serde"] }` (Aktuelle Version prüfen)
    - `chrono = { version = "0.4", features = ["serde"] }` (Aktuelle Version prüfen)
    - `async-trait = "0.1"`
    - `tokio = { version = "1", features = ["sync"] }`
    - `tracing = "0.1"`
- **Logging:** Verwendung von `tracing::{trace, debug, info, warn, error}` Makros aus `novade-core`.

---

### Modul 1: `domain::shared_types`

Zweck: Definition von domänenspezifischen Typen, die von mehreren Domänenmodulen verwendet werden, aber nicht allgemein genug für core::types sind.

Datei: src/shared_types.rs

#### 1.1. Type Alias: `ApplicationId`

- **Definition:** `pub type ApplicationId = String;`
- **Zweck:** Eindeutiger Bezeichner für eine Anwendung (z.B. Reverse-DNS-Name wie "org.novade.FileExplorer").
- **Invarianten:** Sollte nicht leer sein. Formatierungsregeln können von der Systemschicht (z.B. AppID aus `.desktop`-Dateien) abhängen und hier nur als Konvention dokumentiert werden.
- **Ableitungen (indirekt durch String):** `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.

#### 1.2. Enum: `UserSessionState`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum UserSessionState {
        #[default]
        Active, // Normale Benutzersitzung
        Locked, // Sitzung gesperrt (z.B. Bildschirmschoner aktiv)
        Idle,   // Benutzer ist für eine bestimmte Zeit inaktiv
    }
    ```
    
- **Zweck:** Repräsentiert den aktuellen Zustand der Benutzersitzung aus Sicht der Domäne. Die Systemschicht mappt hierauf ggf. detailliertere Zustände von `logind` o.ä.
- **Initialwert:** `Active` (durch `#[default]`).

#### 1.3. Struct: `ResourceIdentifier`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use uuid::Uuid;
    
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct ResourceIdentifier {
        pub r#type: String, // z.B. "file", "contact", "calendar_event"
        pub id: String,     // Eindeutige ID innerhalb des Typs, kann auch Uuid sein
    }
    
    impl ResourceIdentifier {
        pub fn new(r#type: impl Into<String>, id: impl Into<String>) -> Self {
            Self {
                r#type: r#type.into(),
                id: id.into(),
            }
        }
    }
    ```
    
- **Zweck:** Allgemeiner Bezeichner für eine Ressource, die von KI-Funktionen oder anderen Diensten referenziert werden könnte.
- **Felder:**
    - `r#type: String` (öffentlich): Der Typ der Ressource.
    - `id: String` (öffentlich): Die eindeutige ID der Ressource innerhalb ihres Typs.
- **Invarianten:** `r#type` und `id` sollten nicht leer sein.

#### 1.4. Implementierungsschritte `domain::shared_types`

1. **Datei erstellen:** `novade-domain/src/shared_types.rs`.
2. **Typen definieren:** `ApplicationId`, `UserSessionState`, `ResourceIdentifier` wie oben spezifiziert.
3. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    pub mod shared_types;
    pub use shared_types::{ApplicationId, UserSessionState, ResourceIdentifier};
    ```
    
4. **Unit-Tests:**
    - Für `ResourceIdentifier::new`.
    - Für `UserSessionState`: `Default`-Implementierung.
    - Serialisierung/Deserialisierung der Typen testen.

---

### Modul 2: `domain::common_events`

Zweck: Definition von Event-Typen, die von mehreren Domänenmodulen ausgelöst oder konsumiert werden können.

Datei: src/common_events.rs

#### 2.1. Enum: `UserActivityType`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum UserActivityType {
        MouseMoved,
        MouseClicked,
        KeyPressed,
        WorkspaceSwitched,
        ApplicationFocused,
        // Weitere Typen nach Bedarf
    }
    ```
    
- **Zweck:** Kategorisierung von Benutzeraktivitäten.

#### 2.2. Struct: `UserActivityDetectedEvent`

- **Definition:**
    
    Rust
    
    ```
    use chrono::{DateTime, Utc};
    use serde::{Serialize, Deserialize};
    use super::shared_types::UserSessionState; // Oder spezifischere Aktivitätsdaten
    use super::UserActivityType; // aus demselben Modul
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct UserActivityDetectedEvent {
        pub timestamp: DateTime<Utc>,
        pub activity_type: UserActivityType,
        pub current_session_state: UserSessionState, // Beispielhafter zusätzlicher Kontext
        // Optional: pub source_component: String; // z.B. "system::input", "domain::workspaces"
        // Optional: pub details: serde_json::Value; // Für flexible Zusatzdaten
    }
    
    impl UserActivityDetectedEvent {
        pub fn new(activity_type: UserActivityType, current_session_state: UserSessionState) -> Self {
            Self {
                timestamp: Utc::now(),
                activity_type,
                current_session_state,
            }
        }
    }
    ```
    
- **Zweck:** Wird ausgelöst, wenn eine signifikante Benutzeraktivität erkannt wird. Kann für Idle-Detection, kontextsensitive Aktionen etc. verwendet werden.
- **Payload:**
    - `timestamp: DateTime<Utc>`
    - `activity_type: UserActivityType`
    - `current_session_state: UserSessionState`
- **Typische Publisher:** `system::input` (indirekt über Domänenadapter), `domain::workspaces::manager`.
- **Typische Subscriber:** `domain::user_centric_services` (für Idle-Timer der KI), `domain::power_management_policy` (für Idle-basierte Energiesparmaßnahmen), UI-Komponenten für Statusanzeigen.

#### 2.3. Struct: `SystemShutdownInitiatedEvent`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum ShutdownReason {
        UserRequest,
        PowerButton,
        LowBattery,
        SystemUpdate,
        Unknown,
    }
    
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct SystemShutdownInitiatedEvent {
        pub reason: ShutdownReason,
        pub delay_seconds: Option<u32>, // Optionale Verzögerung, bevor der Shutdown tatsächlich erfolgt
    }
    ```
    
- **Zweck:** Signalisiert, dass das System heruntergefahren oder neu gestartet wird.
- **Payload:**
    - `reason: ShutdownReason`
    - `delay_seconds: Option<u32>`
- **Typische Publisher:** Ein Systemdienst-Adapter in der Systemschicht (z.B. Reaktion auf `logind PrepareForShutdown`).
- **Typische Subscriber:** Alle Domänendienste, die Zustände speichern müssen (`ThemingEngine`, `WorkspaceManager`, `GlobalSettingsService`), Anwendungen (über Portals).

#### 2.4. Implementierungsschritte `domain::common_events`

1. **Datei erstellen:** `novade-domain/src/common_events.rs`.
2. **Typen definieren:** `UserActivityType`, `UserActivityDetectedEvent`, `ShutdownReason`, `SystemShutdownInitiatedEvent`.
3. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    pub mod common_events;
    pub use common_events::{UserActivityType, UserActivityDetectedEvent, ShutdownReason, SystemShutdownInitiatedEvent};
    ```
    
4. **Unit-Tests:**
    - Für `UserActivityDetectedEvent::new`.
    - Serialisierung/Deserialisierung der Event-Strukturen.

---

### Modul 3: `domain::theming`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

- Verwendung von `tokio::sync::broadcast` für `ThemeChangedEvent` ist bestätigt.
- Alle Ladeoperationen (`load_and_validate_token_files`, `load_and_validate_theme_files` in der Logik sowie `ThemingEngine::new` und `ThemingEngine::reload_themes_and_tokens` in der API) sind `async`, da sie potenziell Dateisystem-I/O beinhalten. Die Kernauflösungslogik (`resolve_tokens_for_config`) bleibt synchron, da sie CPU-gebunden ist.
- **Fehler-Enum `ThemingError`**:
    - Die Variante `FallbackThemeLoadError` erhält ein `#[source]`-Feld, da das Laden selbst fehlschlagen kann: `FallbackThemeLoadError { #[source] source: Box<dyn std::error::Error + Send + Sync + 'static> }`
    - `TokenResolutionError` hinzugefügt als allgemeinerer Fehler während der Auflösung. `#[error("Failed to resolve token '{token_id}': {message}")] TokenResolutionError { token_id: TokenIdentifier, message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }`
- **`ThemingEngineInternalState` Cache-Schlüssel:** Um `AccentColor` und `TokenSet` (für `custom_user_token_overrides`) hashbar zu machen, werden sie im Cache-Schlüssel durch einen Hash ihres Inhalts repräsentiert oder durch eine kanonische String-Repräsentation.
    - `AccentColor` wird im Cache-Key zu `Option<String>` (dem `value` der Akzentfarbe).
    - `custom_user_token_overrides: Option<TokenSet>` wird zu einem `u64`-Hash (z.B. mit `std::collections::hash_map::DefaultHasher`).
    - `resolved_state_cache: std::collections::HashMap<(ThemeIdentifier, ColorSchemeType, Option<String>, u64), AppliedThemeState>`

---

### Modul 4: `domain::global_settings_and_state_management`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

#### `domain::global_settings::types`

- **Enum `MouseAccelerationProfile`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
    pub enum MouseAccelerationProfile {
        Adaptive,
        Flat,
        // Custom(f32) // Direktes f32 ist problematisch für Default und Eq.
                       // Besser wäre eine separate Einstellung für den Custom-Wert.
    }
    impl Default for MouseAccelerationProfile { fn default() -> Self { Self::Adaptive } }
    // Zusätzliches Feld in InputBehaviorSettings:
    // pub custom_mouse_acceleration_value: Option<f32>; // Nur relevant wenn Profil Custom(TODO: Wie Custom hier darstellen ohne f32?)
    // Alternative für Custom: Keine f32 im Enum, sondern ein Flag und separates Feld
    // Oder der Custom-Wert wird direkt über einen Slider gesetzt und das Enum
    // dient nur zur Auswahl des Profils. Für die Domäne ist es einfacher, wenn
    // `Custom` keine Daten enthält und der Wert separat verwaltet wird.
    // Hier vereinfacht zu: `Custom` (ohne Wert im Enum)
    ```
    
    Überarbeitung: `MouseAccelerationProfile` enthält kein `f32`. Der Custom-Wert wird ein separates Feld in `InputBehaviorSettings`: `pub custom_mouse_acceleration_factor: Option<f32>; // Aktiv, wenn Profil auf Custom gesetzt ist` Das Enum `MouseAccelerationProfile` wird: `Adaptive, Flat, Custom`.

#### `domain::global_settings::paths`

- Der `SettingPath`-Enum muss vollständig für alle Einstellungen in `GlobalDesktopSettings` und dessen Unterstrukturen ausdefiniert werden.
    - Beispiel für `InputBehaviorSettings`:
        
        Rust
        
        ```
        // In paths.rs
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum InputBehaviorSettingPath {
            MouseAccelerationProfile,
            CustomMouseAccelerationFactor, // Neu
            MouseSensitivity,
            NaturalScrollingMouse,
            NaturalScrollingTouchpad,
            TapToClickTouchpad,
            TouchpadPointerSpeed,
            KeyboardRepeatDelayMs,
            KeyboardRepeatRateCps,
        }
        ```
        
    - Dies muss für `WorkspaceSettingPath`, `PowerManagementPolicySettingPath`, `DefaultApplicationsSettingPath` etc. analog erfolgen.

#### `domain::global_settings::service`

- **Trait `GlobalSettingsService`**:
    - `load_settings()` und `save_settings()` sind `async`.
    - `update_setting()` ist `async`.
    - `reset_to_defaults()` ist `async`.
    - `subscribe_to_changes()` wird `pub fn subscribe_to_setting_changes(&self) -> tokio::sync::broadcast::Receiver<SettingChangedEvent>`
- **Implementierung `DefaultGlobalSettingsService`**:
    - Hält `persistence_provider: Arc<dyn SettingsPersistenceProvider>`.
    - Verwendet `tokio::sync::broadcast::Sender<SettingChangedEvent>`.
    - Die `update_setting` Logik zur Pfad-Navigation und Deserialisierung/Validierung muss robust implementiert werden. Hier ist ein Beispielansatz:
        - Eine interne Hilfsfunktion/Makro, die basierend auf `SettingPath` einen `&mut dyn std::any::Any` auf das Feld liefert und dessen `TypeId` kennt.
        - Dann `serde_json::from_value` verwenden und das Ergebnis dynamisch prüfen/casten und validieren.
        - Oder eine große `match`-Anweisung auf `SettingPath`.

#### `domain::global_settings::persistence_iface`

- **Trait `SettingsPersistenceProvider`**: Methoden sind `async`.
    - `async fn load_global_settings() -> Result<GlobalDesktopSettings, GlobalSettingsError>`
    - `async fn save_global_settings(settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>`
- **Implementierung `FilesystemSettingsProvider`**:
    - Nutzt `Arc<dyn novade_core::config::ConfigServiceAsync>` (hypothetischer Trait für asynchronen Zugriff auf `core::config` oder direkt `novade_core::config::load_core_config_async` / `save_core_config_async`).
    - Die Methoden `load_global_settings` und `save_global_settings` werden `async`.

**Events:** `SettingChangedEvent { path: SettingPath, new_value: serde_json::Value }`, `SettingsLoadedEvent { settings: GlobalDesktopSettings }`, `SettingsSavedEvent`.

---

### Modul 5: `domain::workspaces`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

- **`WorkspaceManager`**:
    - Der `event_publisher` wird `tokio::sync::broadcast::Sender<WorkspaceEvent>`.
    - Die Methode `subscribe_to_workspace_events()` gibt `tokio::sync::broadcast::Receiver<WorkspaceEvent>` zurück.
    - Alle Methoden, die potenziell die Konfiguration speichern (`create_workspace`, `delete_workspace`, `set_active_workspace`, `rename_workspace`, `set_workspace_layout`) oder laden (`new`), werden `async`, da `save_configuration` und `config_provider.load_workspace_config` `async` sind.
- **`FilesystemConfigProvider`**:
    - Nutzt einen asynchronen `core::config::ConfigServiceAsync` oder äquivalente `async` Funktionen zum Lesen/Schreiben von Dateien.
    - Die Methoden `load_workspace_config` und `save_workspace_config` sind `async`.

---

### Modul 6: `domain::window_management_policy`

Zweck: High-Level-Regeln für Fensterplatzierung, Tiling, Snapping, Gruppierung, Gap-Management.

Datei: src/window_management_policy/types.rs

#### 6.1. Typen

- **Enum `TilingMode`** (ersetzt `TilingLayoutType` für Klarheit, da Layouts spezifischer sind):
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum TilingMode {
        #[default]
        Manual, // Keine automatische Anordnung, Fenster sind floating
        Columns,
        Rows,
        Spiral, // Fibonacci-Spirale
        MaximizedFocused, // Aktives Fenster maximiert, andere ggf. versteckt/klein
    }
    ```
    
- **Struct `GapSettings`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct GapSettings {
        pub screen_outer_horizontal: u16, // Rand zum Bildschirm horizontal
        pub screen_outer_vertical: u16,   // Rand zum Bildschirm vertikal
        pub window_inner: u16,            // Abstand zwischen Fenstern
    }
    ```
    
- **Struct `WindowSnappingPolicy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct WindowSnappingPolicy {
        pub snap_to_screen_edges: bool,
        pub snap_to_other_windows: bool,
        pub snap_to_workspace_gaps: bool, // Snapping an virtuelle Gap-Grenzen
        pub snap_distance_px: u16,
    }
    ```
    
- **Struct `WindowGroupingPolicy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct WindowGroupingPolicy {
        pub enable_manual_grouping: bool,
        // Automatische Gruppierungsregeln (komplexer, für V2):
        // pub auto_group_by_application_id: bool,
        // pub auto_group_transients_with_parent: bool,
    }
    ```
    
- **Enum `NewWindowPlacementStrategy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum NewWindowPlacementStrategy {
        #[default]
        Smart,    // Versucht intelligent zu platzieren (z.B. nicht überlappend, im größten freien Bereich)
        Center,   // Zentriert auf dem Bildschirm/Workspace
        Cascade,  // Kaskadierend vom letzten Fenster
        UnderMouse, // Unter dem Mauszeiger (falls zutreffend)
    }
    ```
    
- **Enum `FocusStealingPreventionLevel`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum FocusStealingPreventionLevel {
        None,   // Jedes Fenster darf Fokus anfordern
        #[default]
        Moderate, // Verhindert aggressives Stehlen, erlaubt aber legitime Anforderungen
        Strict, // Nur explizite Benutzeraktion kann Fokus ändern
    }
    ```
    
- **Struct `FocusPolicy`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub struct FocusPolicy {
        pub focus_follows_mouse: bool, // Mausbewegung ändert Fokus
        pub click_to_focus: bool,      // Klick erforderlich
        pub focus_new_windows_on_creation: bool, // Neue Fenster erhalten sofort Fokus
        pub focus_new_windows_on_workspace_switch: bool, // Beim Workspace-Wechsel wird das zuletzt fokussierte Fenster des Ziel-WS fokussiert
        pub focus_stealing_prevention: FocusStealingPreventionLevel,
    }
    ```
    
- **Struct `WindowPolicyOverrides`** (pro Fenster, optional, von Benutzer oder Regeln setzbar):
    
    Rust
    
    ```
    use crate::core::types::RectInt; // Aus der Kernschicht
    use uuid::Uuid;
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
    pub struct WindowPolicyOverrides {
        pub preferred_tiling_mode: Option<TilingMode>,
        pub is_always_floating: Option<bool>, // Überschreibt Workspace-Tiling-Modus
        pub fixed_size: Option<(u32, u32)>, // Breite, Höhe
        pub fixed_position: Option<(i32, i32)>, // x, y (relativ zum Workspace)
        pub prevent_focus_stealing: Option<bool>, // Individuelle Überschreibung der globalen Policy
        pub min_size_override: Option<(u32, u32)>,
        pub max_size_override: Option<(u32, u32)>,
    }
    ```
    
    - Dieses Struct würde nicht direkt in `GlobalDesktopSettings` sein, sondern dynamisch pro Fenster verwaltet (z.B. in einer `HashMap<WindowIdentifier, WindowPolicyOverrides>`).
- **Struct `WorkspaceWindowLayout`**: Repräsentiert das berechnete Layout für einen Workspace.
    
    Rust
    
    ```
    use crate::core::types::RectInt;
    use crate::domain::workspaces::core::types::WindowIdentifier;
    use std::collections::HashMap;
    
    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct WorkspaceWindowLayout {
        // Fenster-ID zu seiner berechneten Geometrie (Position und Größe)
        pub window_geometries: HashMap<WindowIdentifier, RectInt>,
        // Bereich, der vom Layout genutzt wird (kann kleiner sein als available_space, z.B. bei zentrierten Layouts)
        pub occupied_area: Option<RectInt>,
    }
    ```
    

**Datei:** `src/window_management_policy/errors.rs`

- **Enum `WindowPolicyError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use crate::domain::workspaces::core::types::WorkspaceId;
    
    #[derive(Debug, Error)]
    pub enum WindowPolicyError {
        #[error("Failed to calculate layout for workspace '{workspace_id}': {reason}")]
        LayoutCalculationError { workspace_id: WorkspaceId, reason: String },
        #[error("Invalid window management policy configuration: {setting_path}, reason: {reason}")]
        InvalidPolicyConfiguration { setting_path: String, reason: String },
        #[error("Window referenced by identifier '{0:?}' not found for policy application.")]
        WindowNotFoundForPolicy(crate::domain::workspaces::core::types::WindowIdentifier),
        #[error("An internal error occurred in window management policy: {0}")]
        InternalError(String),
    }
    ```
    

**Datei:** `src/window_management_policy/service.rs` (oder `mod.rs`)

- **Trait `WindowManagementPolicyService`**:
    
    Rust
    
    ```
    use async_trait::async_trait;
    use std::collections::HashMap;
    use crate::core::types::{RectInt, Size, Point};
    use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};
    use super::types::{TilingMode, GapSettings, WindowSnappingPolicy, NewWindowPlacementStrategy, WorkspaceWindowLayout, WindowPolicyOverrides};
    use super::errors::WindowPolicyError;
    use crate::domain::global_settings_and_state_management::types::GlobalDesktopSettings; // Für den Zugriff auf globale Policies
    
    #[async_trait]
    pub trait WindowManagementPolicyService: Send + Sync {
        /// Berechnet das Layout für alle Fenster auf einem gegebenen Workspace.
        /// `windows_on_workspace`: Liste der Fenster-IDs auf dem Workspace und ihre aktuellen (oder gewünschten Mindest-)Größen.
        /// `workspace_tiling_mode`: Der vom Workspace gewünschte Tiling-Modus.
        /// `global_settings`: Aktuelle globale Einstellungen, die Policies enthalten.
        /// `window_specific_overrides`: Map von Fenster-IDs zu ihren spezifischen Policy-Überschreibungen.
        async fn calculate_workspace_layout(
            &self,
            workspace_id: WorkspaceId,
            windows_on_workspace: &[(WindowIdentifier, Size<u32>)], // Fenster und ihre (Mindest-)Größen
            available_area: RectInt, // Der für Fenster verfügbare Bereich auf dem Workspace
            workspace_tiling_mode: TilingMode, // Vom Workspace Manager festgelegter Modus
            gap_settings: &GapSettings, // Aktuelle Gap-Einstellungen
            window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>
        ) -> Result<WorkspaceWindowLayout, WindowPolicyError>;
    
        /// Bestimmt die initiale Geometrie und den Zustand für ein neues Fenster.
        async fn get_initial_window_geometry(
            &self,
            window_id: &WindowIdentifier,
            requested_size: Option<Size<u32>>, // Vom Fenster gewünschte Größe
            is_transient_for: Option<&WindowIdentifier>, // Elternfenster für transiente Fenster
            workspace_id: WorkspaceId,
            active_layout_on_workspace: &WorkspaceWindowLayout, // Aktuelles Layout des Ziel-Workspace
            available_area: RectInt,
            placement_strategy: NewWindowPlacementStrategy,
            window_specific_overrides: &Option<WindowPolicyOverrides>
        ) -> Result<RectInt, WindowPolicyError>;
    
        /// Berechnet ein potenzielles "Snap"-Ziel für ein sich bewegendes oder größenveränderndes Fenster.
        async fn calculate_snap_target(
            &self,
            moving_window_id: &WindowIdentifier,
            current_geometry: RectInt, // Aktuelle Geometrie des bewegten Fensters
            other_windows_on_workspace: &[(&WindowIdentifier, &RectInt)], // Andere Fenster
            workspace_area: RectInt, // Gesamtbereich des Workspace
            snapping_policy: &WindowSnappingPolicy,
            gap_settings: &GapSettings
        ) -> Option<RectInt>;
    
        /// Gibt die Fokus-Policy zurück.
        async fn get_focus_policy(&self, global_settings: &GlobalDesktopSettings) -> FocusPolicy;
    
        /// Gibt die Policy für neue Fensterplatzierung zurück.
        async fn get_new_window_placement_strategy(&self, global_settings: &GlobalDesktopSettings) -> NewWindowPlacementStrategy;
    
        // Ggf. Methoden zum Abrufen spezifischer Policy-Objekte wie GapSettings, WindowSnappingPolicy etc.
        // basierend auf global_settings oder Workspace-spezifischen Einstellungen.
    }
    ```
    
- **Implementierung `DefaultWindowManagementPolicyService`**:
    - **Konstruktor:** `pub fn new(settings_service: Arc<dyn GlobalSettingsService>) -> Self`
        - Hält eine Referenz (`Arc`) zum `GlobalSettingsService`, um bei Bedarf aktuelle Policy-Einstellungen abzurufen.
    - **`calculate_workspace_layout` Logik:**
        1. Ruft globale Einstellungen (Tiling-Modus-Präferenz, Gaps) vom `settings_service` ab (oder erhält sie als Parameter).
        2. Filtert Fenster heraus, die `is_always_floating == Some(true)` haben. Diese werden ignoriert für Tiling.
        3. Basierend auf dem `workspace_tiling_mode` (und ggf. Fenster-spezifischen `preferred_tiling_mode` Overrides):
            - `TilingMode::Manual`: Gibt aktuelle Geometrien zurück (oder platziert sie initial gemäß `NewWindowPlacementStrategy`).
            - `TilingMode::Columns`: Teilt `available_area` (unter Berücksichtigung von `gap_settings`) vertikal für jedes nicht-floating Fenster auf. Berücksichtigt `min_size_override`.
            - `TilingMode::Rows`: Teilt horizontal auf.
            - `TilingMode::Spiral`: Implementiert Fibonacci-Spiral-Layout-Algorithmus.
            - `TilingMode::MaximizedFocused`: Macht das "aktive" Fenster (muss als Parameter übergeben werden oder heuristisch bestimmt werden) bildschirmfüllend (innerhalb `available_area` minus Gaps), andere minimiert/versteckt.
        4. Floating-Fenster werden über den gekachelten Fenstern platziert, ihre Positionen bleiben relativ erhalten oder werden initial gemäß `get_initial_window_geometry` platziert.
        5. Erstellt und gibt `WorkspaceWindowLayout` zurück.
    - **`get_initial_window_geometry` Logik:**
        1. Berücksichtigt `requested_size`, `is_transient_for` (z.B. zentriert über Parent).
        2. Wendet `placement_strategy` an (`Smart` könnte versuchen, Überlappungen mit `active_layout_on_workspace` zu vermeiden).
        3. Berücksichtigt `window_specific_overrides.fixed_position` und `fixed_size`.
    - **`calculate_snap_target` Logik:**
        1. Prüft Distanz zu Bildschirmrändern, Gap-Grenzen und Kanten/Mittelpunkten anderer Fenster.
        2. Wenn innerhalb `snap_distance_px`, gibt die neue "eingerastete" `RectInt` zurück.

**Abhängigkeiten & Interaktion:**

- Liest Policy-Konfigurationen von `domain::global_settings_service`.
- Wird von der Systemschicht (`system::window_mechanics`) aufgerufen, um Layouts und Platzierungen zu bestimmen.
- Könnte von `domain::workspaces::manager` Events abonnieren (z.B. `WindowAddedToWorkspaceEvent`), um Layouts proaktiv neu zu berechnen.

**Implementierungsschritte:**

1. `types.rs` und `errors.rs` definieren.
2. `service.rs`: `WindowManagementPolicyService`-Trait definieren.
3. `DefaultWindowManagementPolicyService` implementieren:
    - Konstruktor.
    - Implementierung der Layout-Algorithmen (Columns, Rows, Spiral etc.) als private Hilfsfunktionen.
    - Implementierung der Snapping-Logik.
    - Implementierung der öffentlichen Trait-Methoden.
4. Unit-Tests für jeden Layout-Algorithmus, Snapping-Logik und die Service-Methoden mit verschiedenen Szenarien und Konfigurationen.

---

### Modul 7: `domain::user_centric_services`

Bestehende Spezifikation: Übernommen und integriert aus, siehe vorherige Antwort.

Anpassungen/Verfeinerungen:

#### `domain::user_centric_services::ai_interaction`

- **Strukturen/Enums:** Wie definiert in.
- **`AIInteractionLogicService` Trait & Implementierung `DefaultAIInteractionLogicService`**:
    - Methoden sind `async`.
    - `initiate_interaction`: Benötigt ggf. Zugriff auf `GlobalSettingsService` für Standardmodell oder globale KI-Einstellungen.
    - `provide_consent`: Muss den `AIConsentStatus` im `AIInteractionContext` und ggf. einen persistenten `AIConsent`-Eintrag aktualisieren.
    - `store_consent` / `get_all_user_consents`: Delegieren die Persistenz an einen `AIConsentProvider` (neuer Trait, ähnlich `SettingsPersistenceProvider`, interagiert mit `core::config`).
    - `load_model_profiles`: Lädt von `core::config` über einen `AIModelProfileProvider`.
- **Events:** `AIInteractionInitiatedEvent`, `AIConsentUpdatedEvent` (gesendet via `tokio::sync::broadcast`).

#### `domain::user_centric_services::notifications_core`

- **Strukturen/Enums:** Wie definiert in.
- **`NotificationService` Trait & Implementierung `DefaultNotificationService`**:
    - Methoden sind `async`.
    - `post_notification`: Berücksichtigt `DoNotDisturbModeChangedEvent` und DND-Status. Interagiert mit `domain::notifications_rules::NotificationRulesEngine` (wird als Abhängigkeit injiziert), um Benachrichtigungen vor dem Posten zu verarbeiten.
- **Events:** `NotificationPostedEvent`, `NotificationDismissedEvent`, `NotificationReadEvent`, `DoNotDisturbModeChangedEvent` (gesendet via `tokio::sync::broadcast`).

**Neue Sub-Traits/Provider für Persistenz:**

- `domain::user_centric_services::ai_interaction::persistence_iface`:
    - `AIConsentProvider`: `async fn load_consents(user_id: &str) -> Result<Vec<AIConsent>, AIInteractionError>`, `async fn save_consent(consent: &AIConsent) -> Result<(), AIInteractionError>`.
    - `AIModelProfileProvider`: `async fn load_model_profiles() -> Result<Vec<AIModelProfile>, AIInteractionError>`.
    - Implementierungen nutzen `core::config`.

---

### Modul 8: `domain::notifications_rules`

Bestehende Spezifikation: Übernommen und integriert aus der vorherigen Antwort.

Anpassungen/Verfeinerungen:

#### `domain::notifications_rules::engine` (oder `service.rs`)

- **Struct `NotificationRulesEngine`**:
    - Konstruktor `pub async fn new(rules_provider: Arc<dyn NotificationRulesProvider>, settings_service: Arc<dyn GlobalSettingsService>) -> Self`
    - `load_rules()`-Methode, um Regeln vom `rules_provider` neu zu laden.
    - `process_notification`: Nimmt `&Notification` und gibt `Result<Option<Notification>, NotificationRulesError>` zurück (None, wenn unterdrückt, Some(modified_notification) wenn erlaubt/geändert).

#### `domain::notifications_rules::persistence_iface`

- **Trait `NotificationRulesProvider`**:
    - `async fn load_rules() -> Result<NotificationRuleSet, NotificationRulesError>`
    - `async fn save_rules(rules: &NotificationRuleSet) -> Result<(), NotificationRulesError>`
- Implementierung `FilesystemNotificationRulesProvider` nutzt `core::config`.

**Interaktion:**

- Der `notifications_core::DefaultNotificationService` wird eine Instanz des `NotificationRulesEngine` halten und `process_notification` aufrufen, bevor eine Benachrichtigung tatsächlich "gepostet" wird (d.h. bevor das `NotificationPostedEvent` ausgelöst und die Benachrichtigung den aktiven/historischen Listen hinzugefügt wird).
- Der `NotificationRulesEngine` benötigt Zugriff auf den `GlobalSettingsService`, um `SettingIsTrue`-Bedingungen auszuwerten.

---

**Finale `novade-domain/src/lib.rs` (Struktur):**

Rust

```
// novade-domain/src/lib.rs

// Kern-Abhängigkeiten (Beispiel)
// use novade_core; // Wird implizit durch Pfade wie crate::core::... genutzt

// Öffentliche Module deklarieren
pub mod common_events;
pub mod global_settings_and_state_management;
pub mod notifications_rules;
pub mod shared_types;
pub mod theming;
pub mod user_centric_services;
pub mod window_management_policy;
pub mod workspaces;

// Öffentliche API Re-Exports (Beispiele)
pub use common_events::{UserActivityDetectedEvent, SystemShutdownInitiatedEvent, /* ... */};
pub use global_settings_and_state_management::{
    GlobalSettingsService, GlobalDesktopSettings, SettingPath, GlobalSettingsError,
    SettingsPersistenceProvider, /* ... Untertypen und Enums ... */
};
pub use theming::{ThemingEngine, ThemeDefinition, AppliedThemeState, ThemingError, /* ... */};
pub use workspaces::{
    WorkspaceManager, Workspace, WorkspaceId, WindowIdentifier, WorkspaceEvent, WorkspaceLayoutType,
    WorkspaceConfigProvider, WorkspaceCoreError, WindowAssignmentError, WorkspaceManagerError, WorkspaceConfigError, /* ... */
};
pub use user_centric_services::{
    AIInteractionLogicService, NotificationService, AIInteractionContext, Notification, AIConsent, AIModelProfile,
    AIInteractionError, NotificationError, /* ... Events und andere Typen ... */
    // Ggf. auch die Provider-Traits für Persistenz
    ai_interaction::persistence_iface::{AIConsentProvider, AIModelProfileProvider},
};
pub use notifications_rules::{
    NotificationRulesEngine, NotificationRule, RuleCondition, RuleAction, NotificationRulesError,
    persistence_iface::NotificationRulesProvider,
};
pub use window_management_policy::{
    WindowManagementPolicyService, TilingMode, GapSettings, WorkspaceWindowLayout, WindowPolicyError, /* ... */
};
pub use shared_types::{ApplicationId, UserSessionState, ResourceIdentifier};

// Initialisierungsfunktion für die gesamte Domänenschicht könnte hier existieren,
// die alle Services instanziiert und ggf. miteinander verbindet.
// pub async fn initialize_domain_layer(
//     core_config_service: Arc<dyn novade_core::config::ConfigServiceAsync>,
//     // ... andere notwendige Abhängigkeiten aus der Kernschicht ...
// ) -> Result<DomainServices, DomainInitializationError> {
//     // ... Instanziiere alle Provider und Services ...
//     // Beispiel:
//     // let settings_persistence_provider = Arc::new(global_settings_and_state_management::FilesystemSettingsProvider::new(core_config_service.clone()));
//     // let settings_service = Arc::new(global_settings_and_state_management::DefaultGlobalSettingsService::new(settings_persistence_provider));
//     // settings_service.load_settings().await?;
//     // ...
//     // Ok(DomainServices { settings_service, ... })
// }

// pub struct DomainServices {
//     pub settings_service: Arc<dyn GlobalSettingsService>,
//     pub theming_engine: Arc<ThemingEngine>,
//     pub workspace_manager: Arc<WorkspaceManager>,
//     // ... andere Services
// }

// #[derive(Debug, thiserror::Error)]
// pub enum DomainInitializationError {
//     #[error("Failed to initialize settings service: {0}")]
//     SettingsInitError(#[from] global_settings_and_state_management::GlobalSettingsError),
//     // ... andere Initialisierungsfehler
// }
```

Diese umfassende Spezifikation für die Domänenschicht sollte eine sehr solide Grundlage für die Implementierung bieten. Jedes Modul ist klar abgegrenzt, und die Interaktionen sowie Abhängigkeiten sind definiert. Der nächste Schritt wäre, für jedes dieser Module die detaillierten Implementierungsschritte (wie im Beispiel für `core::types` gezeigt) und die Unit-Tests vollständig auszuarbeiten.

---

## Ultra-Feinspezifikation und Implementierungsplan: Domänenschicht (`novade-domain` Crate)

Allgemeine Entwicklungsrichtlinien für die Domänenschicht: (Siehe vorherige Antwort für eine vollständige Liste)

Kurzfassung: Rust (Edition 2021+), UI- und Systemunabhängigkeit, Fokus auf Geschäftslogik, APIs über async_trait Traits, threadsichere Zustandsverwaltung, tokio für Asynchronität und Events, thiserror für Fehler, serde für Serialisierung, Nutzung von novade-core.

**Cargo.toml für `novade-domain`:**

Ini, TOML

```
[package]
name = "novade-domain"
version = "0.1.0"
edition = "2021" # oder neuer

[dependencies]
novade-core = { path = "../novade-core" } # Pfad anpassen
thiserror = "1.0.58" # Aktuelle Version prüfen
serde = { version = "1.0.197", features = ["derive"] } # Aktuelle Version prüfen
serde_json = "1.0.115" # Aktuelle Version prüfen
uuid = { version = "1.8.0", features = ["v4", "serde"] } # Aktuelle Version prüfen
chrono = { version = "0.4.38", features = ["serde"] } # Aktuelle Version prüfen
async-trait = "0.1.79" # Aktuelle Version prüfen
tokio = { version = "1.37.0", features = ["sync", "macros", "rt-multi-thread"] } # Aktuelle Version prüfen, rt-multi-thread für broadcast ggf.
tracing = "0.1.40" # Aktuelle Version prüfen

# Optional, falls für spezifische Algorithmen benötigt
# parking_lot = "0.12" # Für Mutex/RwLock Alternativen
# im = { version = "15.1.0", features = ["serde"] } # Für persistente Datenstrukturen, falls HashMap/Vec nicht ausreichen
```

---

### Modul 1: `domain::shared_types`

Zweck: Definition von domänenspezifischen Typen, die von mehreren Domänenmodulen verwendet werden, aber nicht allgemein genug für core::types sind. Diese Typen sind oft einfache Wrapper oder Enums, die die Semantik im Domänencode verbessern.

Verantwortlichkeiten: Bereitstellung dieser gemeinsam genutzten Typen.

Design-Rationale: Zentralisierung vermeidet Duplikation und fördert Konsistenz.

**Datei:** `src/shared_types.rs`

#### 1.1. Type Alias: `ApplicationId`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Eindeutiger Bezeichner für eine Anwendung.
    ///
    /// Repräsentiert typischerweise einen Reverse-DNS-Namen (z.B. "org.novade.FileExplorer")
    /// oder den Namen der .desktop-Datei ohne Erweiterung.
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default, PartialOrd, Ord)]
    pub struct ApplicationId(String);
    
    impl ApplicationId {
        /// Erstellt eine neue `ApplicationId`.
        ///
        /// # Panics
        /// Paniert, wenn die `id` leer ist (im Debug-Modus).
        pub fn new(id: impl Into<String>) -> Self {
            let id_str = id.into();
            debug_assert!(!id_str.is_empty(), "ApplicationId darf nicht leer sein.");
            Self(id_str)
        }
    
        /// Gibt die `ApplicationId` als String-Slice zurück.
        pub fn as_str(&self) -> &str {
            &self.0
        }
    }
    
    impl From<String> for ApplicationId {
        fn from(s: String) -> Self {
            debug_assert!(!s.is_empty(), "ApplicationId (from String) darf nicht leer sein.");
            Self(s)
        }
    }
    
    impl From<&str> for ApplicationId {
        fn from(s: &str) -> Self {
            debug_assert!(!s.is_empty(), "ApplicationId (from &str) darf nicht leer sein.");
            Self(s.to_string())
        }
    }
    
    impl std::fmt::Display for ApplicationId {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.0)
        }
    }
    ```
    
- **Zweck:** Eindeutiger Bezeichner für eine Anwendung.
- **Invarianten:** Der interne String darf nicht leer sein. Diese Invariante wird durch `debug_assert!` in `new()` und `From`-Implementierungen im Debug-Modus geprüft. Für Release-Builds wird auf die Korrektheit der Eingabe vertraut oder höhere Schichten validieren.
- **Methoden:** `new(id: impl Into<String>) -> Self`, `as_str(&self) -> &str`.
- **Trait-Implementierungen:** `From<String>`, `From<&str>`, `std::fmt::Display`.
- **Ableitungen:** `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Default, PartialOrd, Ord`.

#### 1.2. Enum: `UserSessionState`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Repräsentiert den aktuellen Zustand der Benutzersitzung aus Sicht der Domäne.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum UserSessionState {
        #[default]
        Active, // Normale Benutzersitzung, Benutzer ist aktiv
        Locked, // Sitzung gesperrt (z.B. durch Bildschirmsperre)
        Idle,   // Benutzer ist für eine definierte Zeit inaktiv
    }
    ```
    
- **Zweck:** Abstraktion des Sitzungszustands.
- **Initialwert:** `Active`.
- **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.

#### 1.3. Struct: `ResourceIdentifier`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use uuid::Uuid; // Wird für das Beispiel eines Uuid-basierten IDs verwendet
    
    /// Allgemeiner Bezeichner für eine Ressource.
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct ResourceIdentifier {
        /// Der Typ der Ressource (z.B. "file", "contact", "calendar-event", "web-url").
        /// Sollte ein konsistenter, definierter Satz von Strings sein.
        pub r#type: String,
        /// Die eindeutige ID der Ressource innerhalb ihres Typs.
        /// Dies kann ein Pfad, eine URL, eine Datenbank-ID oder eine UUID sein.
        pub id: String,
        /// Optionale menschenlesbare Beschreibung oder Name der Ressource.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
    }
    
    impl ResourceIdentifier {
        /// Erstellt einen neuen `ResourceIdentifier`.
        ///
        /// # Panics
        /// Paniert, wenn `resource_type` oder `resource_id` leer sind (im Debug-Modus).
        pub fn new(resource_type: impl Into<String>, resource_id: impl Into<String>, label: Option<String>) -> Self {
            let type_str = resource_type.into();
            let id_str = resource_id.into();
            debug_assert!(!type_str.is_empty(), "ResourceIdentifier type darf nicht leer sein.");
            debug_assert!(!id_str.is_empty(), "ResourceIdentifier id darf nicht leer sein.");
            Self {
                r#type: type_str,
                id: id_str,
                label,
            }
        }
    
        /// Erstellt einen `ResourceIdentifier` für eine Datei.
        pub fn file(path: impl Into<String>, label: Option<String>) -> Self {
            Self::new("file", path, label)
        }
    
        /// Erstellt einen `ResourceIdentifier` für eine URL.
        pub fn url(url_str: impl Into<String>, label: Option<String>) -> Self {
            Self::new("web-url", url_str, label)
        }
    
        /// Erstellt einen `ResourceIdentifier` mit einer generierten UUID.
        pub fn new_uuid(resource_type: impl Into<String>, label: Option<String>) -> Self {
            Self::new(resource_type, Uuid::new_v4().to_string(), label)
        }
    }
    ```
    
- **Zweck:** Allgemeiner, typisierter Bezeichner für Ressourcen.
- **Felder:**
    - `r#type: String` (öffentlich)
    - `id: String` (öffentlich)
    - `label: Option<String>` (öffentlich, optional)
- **Invarianten:** `r#type` und `id` dürfen nicht leer sein (geprüft via `debug_assert!`).
- **Methoden:** `new(...)`, `file(...)`, `url(...)`, `new_uuid(...)`.
- **Ableitungen:** `Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize`.

#### 1.4. Implementierungsschritte `domain::shared_types`

1. **Datei erstellen:** `novade-domain/src/shared_types.rs`.
2. **Typen definieren:** `ApplicationId`, `UserSessionState`, `ResourceIdentifier` wie oben spezifiziert, inklusive aller Methoden, Trait-Implementierungen und `serde`-Attributen.
3. **Unit-Tests erstellen (`novade-domain/src/shared_types.rs` -> `#[cfg(test)] mod tests { ... }`):**
    - Für `ApplicationId`:
        - `test_application_id_new()`: Erstellung, `as_str()`.
        - `test_application_id_from_string()`: Konvertierung.
        - `test_application_id_from_str()`: Konvertierung.
        - `test_application_id_display()`: `Display`-Trait.
        - `test_application_id_serde()`: Serialisierung zu JSON und Deserialisierung.
        - `#[should_panic]` (im Debug-Modus) für `ApplicationId::new("")`.
    - Für `UserSessionState`:
        - `test_user_session_state_default()`: Prüft `Active` als Default.
        - `test_user_session_state_serde()`: Serialisierung/Deserialisierung.
    - Für `ResourceIdentifier`:
        - `test_resource_identifier_new()`: Korrekte Erstellung.
        - `test_resource_identifier_file_url_uuid()`: Hilfskonstruktoren.
        - `test_resource_identifier_serde()`: Serialisierung/Deserialisierung (auch mit `Option<String>` für Label).
        - `#[should_panic]` (im Debug-Modus) für `ResourceIdentifier::new("", "id", None)` und `ResourceIdentifier::new("type", "", None)`.
4. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    // In novade-domain/src/lib.rs
    pub mod shared_types;
    // Re-export für einfacheren Zugriff von anderen Crates/Modulen
    pub use shared_types::{ApplicationId, UserSessionState, ResourceIdentifier};
    ```
    

---

### Modul 2: `domain::common_events`

Zweck: Definition von Event-Typen, die von mehreren Domänenmodulen ausgelöst oder konsumiert werden können oder die als generische Payloads dienen.

Design-Rationale: Fördert lose Kopplung und eine klare Ereignis-basierte Architektur. Events sind Datenstrukturen, die Zustandsänderungen oder signifikante Vorkommnisse repräsentieren.

Event-Mechanismus: Es wird tokio::sync::broadcast für die Verteilung dieser Events angenommen, wo ein globaler oder Service-spezifischer broadcast::Sender verwendet wird.

**Datei:** `src/common_events.rs`

#### 2.1. Enum: `UserActivityType`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Kategorisiert die Art einer erkannten Benutzeraktivität.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum UserActivityType {
        MouseMoved,
        MouseClicked,
        MouseWheelScrolled,
        KeyPressed,
        TouchInteraction, // Generisch für Touch-Events
        WorkspaceSwitched,
        ApplicationFocused,
        WindowOpened,
        WindowClosed,
        // Weitere spezifische Aktivitätstypen nach Bedarf
    }
    ```
    
- **Zweck:** Granulare Unterscheidung von Benutzeraktivitäten für verschiedene Zwecke (z.B. Idle-Detection, kontextuelle Aktionen).
- **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`.

#### 2.2. Struct: `UserActivityDetectedEvent`

- **Definition:**
    
    Rust
    
    ```
    use chrono::{DateTime, Utc};
    use serde::{Serialize, Deserialize};
    use super::shared_types::{UserSessionState, ApplicationId}; // Pfad anpassen
    use super::UserActivityType; // Aus demselben Modul
    use uuid::Uuid;
    
    /// Wird ausgelöst, wenn eine signifikante Benutzeraktivität im System erkannt wird.
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct UserActivityDetectedEvent {
        /// Eindeutige ID des Events.
        pub event_id: Uuid,
        /// Zeitstempel der Aktivitätserkennung.
        pub timestamp: DateTime<Utc>,
        /// Art der erkannten Aktivität.
        pub activity_type: UserActivityType,
        /// Der Sitzungszustand des Benutzers zum Zeitpunkt der Aktivität.
        pub current_session_state: UserSessionState,
        /// Optional: ID der Anwendung, die im Fokus war oder die Aktivität ausgelöst hat.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_application_id: Option<ApplicationId>,
        /// Optional: ID des Workspaces, auf dem die Aktivität stattfand.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_workspace_id: Option<crate::workspaces::core::types::WorkspaceId>, // Pfad anpassen
        // Zukünftig: Optionale, spezifischere Daten zum Event, z.B. welcher Key gedrückt wurde (mit Bedacht auf PII)
        // pub details: Option<serde_json::Value>,
    }
    
    impl UserActivityDetectedEvent {
        pub fn new(
            activity_type: UserActivityType,
            current_session_state: UserSessionState,
            active_application_id: Option<ApplicationId>,
            active_workspace_id: Option<crate::workspaces::core::types::WorkspaceId> // Pfad anpassen
        ) -> Self {
            Self {
                event_id: Uuid::new_v4(),
                timestamp: Utc::now(),
                activity_type,
                current_session_state,
                active_application_id,
                active_workspace_id,
            }
        }
    }
    ```
    
- **Zweck:** Zentrales Event zur Signalisierung von Benutzeraktivität.
- **Payload:**
    - `event_id: Uuid` (öffentlich): Eindeutige ID für das Event selbst.
    - `timestamp: DateTime<Utc>` (öffentlich)
    - `activity_type: UserActivityType` (öffentlich)
    - `current_session_state: UserSessionState` (öffentlich)
    - `active_application_id: Option<ApplicationId>` (öffentlich, optional)
    - `active_workspace_id: Option<WorkspaceId>` (öffentlich, optional, Typ aus `domain::workspaces`)
- **Typische Publisher:** Ein Adapter in der Systemschicht, der rohe Input-Events von `system::input` konsumiert und aggregiert, oder spezifische Domänendienste wie `domain::workspaces::manager` bei einem Workspace-Wechsel.
- **Typische Subscriber:**
    - `domain::user_centric_services::ai_interaction` (z.B. für Reset von Idle-Timern für KI-Kontext-Timeouts).
    - `domain::power_management_policy` (für System-Idle-Detection und Auslösen von Energiesparmaßnahmen).
    - UI-Komponenten, die auf Benutzeraktivität reagieren (z.B. "Zuletzt aktiv"-Anzeigen, obwohl dies eher UI-Zustand ist).
    - Logging/Auditing-Systeme.

#### 2.3. Enum: `ShutdownReason`

- **Definition:**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    /// Definiert den Grund für ein System-Shutdown oder einen Neustart.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum ShutdownReason {
        #[default]
        UserRequest,     // Direkte Anforderung durch den Benutzer (z.B. über Menü)
        PowerButtonPress,  // Physischer Power-Button wurde gedrückt
        LowBattery,        // Kritischer Batteriestand erfordert Shutdown
        SystemUpdate,      // Shutdown/Neustart aufgrund eines Systemupdates
        ApplicationRequest,// Eine Anwendung hat einen Shutdown angefordert (selten, braucht spezielle Rechte)
        OsError,           // Kritischer OS-Fehler erfordert Neustart (hypothetisch für Domäne)
        Unknown,           // Unbekannter Grund
    }
    ```
    
- **Zweck:** Klare Angabe des Grundes für einen Shutdown.
- **Initialwert:** `UserRequest`.
- **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`.

#### 2.4. Struct: `SystemShutdownInitiatedEvent`

- **Definition:**
    
    Rust
    
    ```
    use chrono::{DateTime, Utc};
    use serde::{Serialize, Deserialize};
    use super::ShutdownReason; // Aus demselben Modul
    use uuid::Uuid;
    
    /// Wird ausgelöst, wenn der Prozess des Herunterfahrens oder Neustarts des Systems initiiert wird.
    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    pub struct SystemShutdownInitiatedEvent {
        pub event_id: Uuid,
        pub timestamp: DateTime<Utc>,
        /// Der Grund für den Shutdown.
        pub reason: ShutdownReason,
        /// Gibt an, ob es sich um einen Neustart (`true`) oder ein Herunterfahren (`false`) handelt.
        pub is_reboot: bool,
        /// Optionale Verzögerung in Sekunden, bevor der eigentliche Shutdown/Neustart ausgeführt wird.
        /// Dies gibt Anwendungen Zeit, ihre Daten zu speichern.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub delay_seconds: Option<u32>,
        /// Optionale Nachricht, die dem Benutzer angezeigt werden könnte.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
    }
    
    impl SystemShutdownInitiatedEvent {
        pub fn new(reason: ShutdownReason, is_reboot: bool, delay_seconds: Option<u32>, message: Option<String>) -> Self {
            Self {
                event_id: Uuid::new_v4(),
                timestamp: Utc::now(),
                reason,
                is_reboot,
                delay_seconds,
                message,
            }
        }
    }
    ```
    
- **Zweck:** Signalisiert bevorstehenden System-Shutdown/Neustart.
- **Payload:**
    - `event_id: Uuid` (öffentlich)
    - `timestamp: DateTime<Utc>` (öffentlich)
    - `reason: ShutdownReason` (öffentlich)
    - `is_reboot: bool` (öffentlich): `true` für Neustart, `false` für Herunterfahren.
    - `delay_seconds: Option<u32>` (öffentlich, optional)
    - `message: Option<String>` (öffentlich, optional)
- **Typische Publisher:** Ein Adapter in der Systemschicht, der auf Signale von `logind` (z.B. `PrepareForShutdown(true/false)`) reagiert.
- **Typische Subscriber:**
    - Alle Domänendienste, die einen sauberen Shutdown-Prozess benötigen, um Zustände zu speichern (z.B. `GlobalSettingsService::save_settings`, `WorkspaceManager::save_configuration`, `ThemingEngine` falls er Caches persistiert, `AIInteractionLogicService` für `AIConsent`).
    - Die Systemschicht selbst, um z.B. Anwendungen über XDG Portals oder andere Mechanismen zu benachrichtigen.
    - Die UI-Schicht, um einen Shutdown-Dialog anzuzeigen.

#### 2.5. Implementierungsschritte `domain::common_events`

1. **Datei erstellen:** `novade-domain/src/common_events.rs`.
2. **Typen definieren:** `UserActivityType`, `UserActivityDetectedEvent`, `ShutdownReason`, `SystemShutdownInitiatedEvent` wie oben spezifiziert, inklusive aller Methoden und `serde`-Attribute.
3. **`novade-domain/src/lib.rs` anpassen:**
    
    Rust
    
    ```
    // In novade-domain/src/lib.rs
    pub mod common_events;
    // Re-export für einfacheren Zugriff
    pub use common_events::{
        UserActivityType, UserActivityDetectedEvent,
        ShutdownReason, SystemShutdownInitiatedEvent,
    };
    ```
    
4. **Unit-Tests erstellen (`novade-domain/src/common_events.rs` -> `#[cfg(test)] mod tests { ... }`):**
    - Für `UserActivityDetectedEvent`:
        - `test_user_activity_event_new()`: Korrekte Initialisierung von `event_id` und `timestamp`.
        - `test_user_activity_event_serde()`: Serialisierung/Deserialisierung.
    - Für `SystemShutdownInitiatedEvent`:
        - `test_system_shutdown_event_new()`: Korrekte Initialisierung.
        - `test_system_shutdown_event_serde()`: Serialisierung/Deserialisierung.
    - Für Enums: Teste `Default`-Implementierung und Serialisierung/Deserialisierung.

---

### Modul 3: `domain::theming`

Bestehende Spezifikation: und vorherige Antwort.

Verantwortlichkeiten: Logik für Erscheinungsbild, Design-Token-Verwaltung, dynamische Theme-Wechsel.

#### Verfeinerungen und Ergänzungen:

**3.1. `domain::theming::types` (`src/theming/types.rs`)**

- **`TokenIdentifier`**:
    - **Validierung in `new()`**: `debug_assert!(!id_str.is_empty() && id_str.chars().all(|c| c.is_ascii_alphanumeric() || c == '.' || c == '-'), "TokenIdentifier darf nur ASCII-Alphanumerisch, Punkte und Bindestriche enthalten und nicht leer sein.");`
- **`TokenValue`**:
    - **`Reference(TokenIdentifier)`**: Stellt sicher, dass Alias-Tokens klar definiert sind.
    - **Validierung**: Die String-Werte für `Color`, `Dimension` etc. sollten idealerweise bei der Erstellung oder beim Parsen einer Basisvalidierung unterzogen werden (z.B. Hex-Format für Farben, Suffix "px"/"rem" für Dimensionen). Dies kann durch spezifische Newtype-Wrapper oder Validierungsfunktionen in der Logikschicht erfolgen. Für die `TokenValue` selbst bleiben es Strings, die Validierung erfolgt in der `TokenResolutionPipeline`.
- **`AccentColor`**:
    - **`value: novade_core::types::Color`**: Anstatt `String` direkt den `Color`-Typ aus der Kernschicht verwenden. Dies erfordert, dass `Color` `serde` mit `from_hex`/`to_hex_string` implementiert.
        - **Konsequenz:** Die `from_hex`-Logik und `ColorParseError` aus `core::types::color` bzw. `core::errors` wird hier relevant.
- **`AppliedThemeState`**:
    - `resolved_tokens: std::collections::BTreeMap<TokenIdentifier, String>`: `BTreeMap` statt `HashMap` verwenden, um eine deterministische Reihenfolge der Tokens zu gewährleisten, was für Tests und das Debugging von generiertem CSS nützlich sein kann. `TokenIdentifier` muss `Ord` implementieren.
- **`ThemingConfiguration`**:
    - `selected_accent_color: Option<novade_core::types::Color>`: Verwendet `core::types::Color`.

**3.2. `domain::theming::errors` (`src/theming/errors.rs`)**

- **`ThemingError`**:
    - `InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String }`: Neuer Fehler für ungültige Werte innerhalb eines `RawToken` nach dem Parsen, aber vor der Auflösung.
    - `AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: novade_core::types::Color, details: String }`: Spezifischer Fehler für die Akzentfarbenanwendung.

**3.3. `domain::theming::logic` (oder `engine_internal`) (`src/theming/logic.rs`)**

- **Token- und Theme-Laden (`async fn load_and_validate_token_files`, `async fn load_and_validate_theme_files`):**
    - Nutzen `novade_core::config::ConfigServiceAsync` (hypothetischer Trait) für asynchronen Dateizugriff. Die Implementierung dieses Traits in `novade-core` würde `tokio::fs` verwenden.
    - Beim Parsen von `RawToken.value` (z.B. `TokenValue::Color(s)`) könnte eine erste Basisvalidierung des `s` erfolgen.
- **Token Resolution Pipeline (`resolve_tokens_for_config`):**
    - **Akzentfarben-Logik:**
        1. Die `ThemeDefinition` sollte definieren, welche Tokens "akzentfähig" sind und wie sie modifiziert werden (z.B. eine Liste von `(TokenIdentifier, AccentModificationType)` wobei `AccentModificationType` `DirectReplace`, `Lighten(f32)`, `Darken(f32)` sein könnte).
        2. Wenn `config.selected_accent_color` gesetzt ist:
            - Iteriere über die akzentfähigen Tokens des Themes.
            - `DirectReplace`: Der Wert des akzentfähigen Tokens (z.B. `token.system.accent.primary`) wird direkt auf den Wert der `selected_accent_color` gesetzt.
            - `Lighten/Darken`: Der Basiswert des akzentfähigen Tokens wird mit der `selected_accent_color` als Referenz aufgehellt/abgedunkelt (erfordert Farbmodifikationslogik, die ggf. `novade_core::types::Color` Methoden nutzt).
    - **Caching-Schlüssel für `resolved_state_cache`**:
        - `CacheKey(ThemeIdentifier, ColorSchemeType, Option<novade_core::types::Color>, u64)`: `AccentColor` direkt (da `Color` hashbar sein kann, wenn f32-Felder mit einer Wrapper-Struct gehasht werden, die Bit-Repräsentationen vergleicht oder eine feste Präzision annimmt – einfacher ist, `color.to_hex_string(true)` zu hashen oder zu verwenden). Für `u64` den Hash der `custom_user_token_overrides` verwenden.
- **Fallback-Theme Laden (`load_fallback_theme_definition`):**
    - JSON-Strings für Fallback-Theme und -Tokens werden mittels `include_str!("default_themes/fallback.theme.json")` etc. einkompiliert.

**3.4. `ThemingEngine` Service (`src/theming/service.rs`)**

- **`ThemingEngineInternalState`**:
    - `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`: Wird korrekt initialisiert.
    - `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`: Wird injiziert für das Laden von Dateien.
- **Methoden:**
    - `new(...)`: Benötigt `Arc<dyn novade_core::config::ConfigServiceAsync>`.
    - `reload_themes_and_tokens()`: Nutzt den injizierten `config_service` für asynchrones Neuladen.
    - Event-Versand: `if self.event_sender.send(event).is_err() { tracing::warn!("ThemingEngine: Keine aktiven Subscriber für ThemeChangedEvent vorhanden."); }`

**3.5. Detaillierte Implementierungsschritte `domain::theming`**

1. **Grundgerüst schaffen:** Verzeichnisstruktur anlegen, `Cargo.toml`-Abhängigkeiten prüfen/ergänzen.
2. **`types.rs` implementieren:**
    - `TokenIdentifier`, `TokenValue`, `RawToken`, `TokenSet` definieren.
    - `ThemeIdentifier`, `ColorSchemeType`, `AccentColor` (mit `core::types::Color`), `ThemeVariantDefinition`, `ThemeDefinition` definieren.
    - `AppliedThemeState` (mit `BTreeMap`), `ThemingConfiguration` (mit `core::types::Color`) definieren.
    - Alle notwendigen `derive`s (`Debug`, `Clone`, `PartialEq`, `Serialize`, `Deserialize`, `Default`, `Ord`, `Hash` wo sinnvoll) und `serde`-Attribute hinzufügen.
    - Unit-Tests für Serialisierung/Deserialisierung und `Default`-Werte schreiben.
3. **`errors.rs` implementieren:**
    - `ThemingError`-Enum mit allen Varianten und `thiserror`-Attributen.
    - Unit-Tests für `Display`-Format und `source()`-Verhalten.
4. **`logic.rs` (oder Submodule) implementieren:**
    - `load_and_validate_token_files_async`: Liest JSON-Dateien (via `config_service`), parst zu `TokenSet`, validiert (Duplikate, Basis-Format von Werten).
    - `load_and_validate_theme_files_async`: Liest JSON, parst zu `ThemeDefinition`, validiert (Token-Referenzen).
    - `validate_tokenset_for_cycles`: Implementiert Zyklenerkennung.
    - `resolve_tokens_for_config`: Implementiert die vollständige Pipeline (Basis, Variante, Akzent, Overrides, Referenzauflösung).
        - Private Hilfsfunktionen für jeden Schritt der Pipeline.
        - Funktion zur Anwendung von Akzentfarben (ggf. mit `Lighten`/`Darken`-Logik).
    - `generate_fallback_applied_state`: Lädt einkompilierte JSONs und erzeugt daraus einen minimalen `AppliedThemeState`.
    - Unit-Tests für jeden Logik-Schritt und Fehlerfall.
5. **`service.rs` (oder `mod.rs`) `ThemingEngine` implementieren:**
    - `ThemingEngineInternalState`-Struktur definieren.
    - `ThemingEngine`-Struktur mit `Arc<Mutex<ThemingEngineInternalState>>` und `broadcast::Sender`.
    - `new()`-Konstruktor: Initialisiert `event_sender`, `config_service`, lädt initial Themes/Tokens, berechnet ersten `applied_state` (oder Fallback), füllt Cache.
    - `get_current_theme_state()`, `get_available_themes()`, `get_current_configuration()`: Implementieren Klonen aus dem internen Zustand.
    - `update_configuration()`: Berechnet neuen Zustand, prüft auf Änderungen, aktualisiert internen Zustand, sendet Event, aktualisiert Cache.
    - `reload_themes_and_tokens()`: Lädt neu, berechnet neu, sendet Event, invalidiert Cache.
    - `subscribe_to_theme_changes()`: Gibt `event_sender.subscribe()` zurück.
    - Unit-Tests für alle API-Methoden, Zustandsänderungen, Event-Auslösung, Cache-Verhalten (Invalidierung, Treffer). Mocking des `ConfigServiceAsync`.
6. **`default_themes/` Verzeichnis anlegen:** `fallback.theme.json` und `base.tokens.json` mit minimalen, gültigen Werten erstellen.
7. **`src/theming/mod.rs` erstellen:** Module deklarieren und öffentliche API re-exportieren (`ThemingEngine`, `ThemeChangedEvent`, wichtige Typen aus `types.rs`, `ThemingError`).

---

Die Spezifikationen für die Module `domain::global_settings_and_state_management`, `domain::workspaces`, `domain::window_management_policy`, `domain::user_centric_services` und `domain::notifications_rules` würden mit derselben Detailtiefe folgen, aufbauend auf den bereits existierenden Zitationen und den hier gezeigten Verfeinerungen und Implementierungsschritten.

**Beispielhafte Verfeinerungen für `domain::global_settings_and_state_management`:**

- **`types.rs`**:
    - Für alle Einstellungs-Unterstrukturen (z.B. `AppearanceSettings`) eine `validate(&self) -> Result<(), GlobalSettingsError>`-Methode hinzufügen, die spezifische Konsistenzprüfungen durchführt (z.B. "wenn `color_scheme == AutoSystem`, dann darf `manual_dark_mode_active` nicht `true` sein" – hypothetisch). Diese wird von `DefaultGlobalSettingsService::update_setting` nach der Deserialisierung aufgerufen.
- **`paths.rs`**:
    - Implementierung von `impl std::fmt::Display for SettingPath` für menschenlesbare Pfade in Logs/Fehlern.
    - Implementierung von `impl TryFrom<&str> for SettingPath` und `impl From<SettingPath> for String` für die Konvertierung zu/von String-basierten Pfaden (nützlich für D-Bus APIs oder Debugging).
- **`service.rs`**:
    - `DefaultGlobalSettingsService::update_setting`:
        1. Auflösen des `SettingPath` zu einem mutierbaren Verweis auf das spezifische Feld in `self.settings` (z.B. mittels Makro oder einer großen `match`-Anweisung).
        2. Deserialisieren des `serde_json::Value` in den erwarteten Typ des Feldes. `Err(GlobalSettingsError::InvalidValueType)` bei Fehlschlag.
        3. Validieren des deserialisierten Wertes mit einer spezifischen Validierungsfunktion für diese Einstellung (oder einer Methode auf der Einstellungs-Unterstruktur). `Err(GlobalSettingsError::ValidationError)` bei Fehlschlag.
        4. Wert aktualisieren, `SettingChangedEvent` senden, `save_settings()` aufrufen.

Dieser extrem granulare Ansatz ist zwar aufwendig, aber unerlässlich, um das Ziel eines "finalen lückenlosen Entwickler-Implementierungsleitfadens" zu erreichen. Jede Komponente ist bis ins Detail durchdacht, was die Implementierung erheblich beschleunigt und die Fehleranfälligkeit reduziert.


---

### Modul 3: `domain::theming`

Zweck: Logik des Erscheinungsbilds (Theming), Verwaltung von Design-Tokens, Interpretation von Theme-Definitionen, dynamische Theme-Wechsel (Farbschema, Akzentfarben). Dieses Modul stellt sicher, dass die UI-Schicht die korrekten, aufgelösten Stilwerte erhält.

Verantwortlichkeiten: Parsen von Token- und Theme-Dateien, Auflösen von Token-Referenzen und -Hierarchien, Anwenden von Benutzerkonfigurationen auf Themes, Bereitstellen des finalen AppliedThemeState und Benachrichtigen bei Änderungen.

Design-Rationale: Trennung der Theming-Logik von der UI-Darstellung. Ein Token-basiertes System ermöglicht hohe Flexibilität und Konsistenz. Dynamische Wechsel zur Laufzeit sind ein Kernziel.

Bestehende Spezifikation: und vorherige Antwort.

#### 3.1. Untermodul: `domain::theming::types`

**Datei:** `src/theming/types.rs`

- **Struct `TokenIdentifier`**
    
    - **Definition:**
        
        Rust
        
        ```
        use serde::{Serialize, Deserialize};
        use std::fmt;
        
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct TokenIdentifier(String);
        
        impl TokenIdentifier {
            pub fn new(id: impl Into<String>) -> Self {
                let id_str = id.into();
                // Invariante: Nicht leer und nur erlaubte Zeichen.
                // Hier nur Debug-Assert, da Validierung auch beim Parsen erfolgen kann.
                debug_assert!(!id_str.is_empty(), "TokenIdentifier darf nicht leer sein.");
                debug_assert!(
                    id_str.chars().all(|c| c.is_ascii_alphanumeric() || c == '.' || c == '-'),
                    "TokenIdentifier ({}) enthält ungültige Zeichen.", id_str
                );
                Self(id_str)
            }
            pub fn as_str(&self) -> &str { &self.0 }
        }
        impl fmt::Display for TokenIdentifier { /* ... */ } // Wie in [cite:656]
        impl From<&str> for TokenIdentifier { fn from(s: &str) -> Self { Self::new(s) } }
        ```
        
    - **Invarianten:** String nicht leer, enthält nur `a-zA-Z0-9.-`.
- **Enum `TokenValue`**
    
    - **Definition:**
        
        Rust
        
        ```
        // ... (andere Varianten wie in)
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        #[serde(rename_all = "kebab-case")]
        pub enum TokenValue {
            Color(String),      // CSS-kompatibler Farbwert, z.B. "#RRGGBB", "rgba(...)", "var(--andere-farbe)"
            Dimension(String),  // z.B. "16px", "2rem", "calc(100% - 20px)"
            FontSize(String),
            FontFamily(String),
            FontWeight(String), // z.B. "400", "bold"
            LineHeight(String), // z.B. "1.5", "150%"
            LetterSpacing(String),
            Border(String),     // z.B. "1px solid var(--border-color)"
            Shadow(String),
            Radius(String),
            Spacing(String),
            ZIndex(i32),
            Opacity(f64),       // Validierung: 0.0 <= opacity <= 1.0
            Text(String),
            Reference(TokenIdentifier), // Verweis auf eine andere TokenIdentifier
        }
        ```
        
    - **Invarianten:** Für `Opacity`, Wert muss zwischen 0.0 und 1.0 liegen. Die Strings in den anderen Varianten sollten gültige CSS-Werte sein (Validierung erfolgt später in der Pipeline oder bei der Anwendung).
- **Struct `RawToken`**
    
    - **Definition:** Wie in. `id: TokenIdentifier`, `value: TokenValue`, `description: Option<String>`, `group: Option<String>`.
    - **Ableitungen:** `Debug, Clone, PartialEq, Serialize, Deserialize`.
- **Typalias `TokenSet`**: `pub type TokenSet = std::collections::BTreeMap<TokenIdentifier, RawToken>;` (BTreeMap für deterministische Reihenfolge).
    
- **Struct `ThemeIdentifier`**
    
    - **Definition:** Analog zu `TokenIdentifier`.
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct ThemeIdentifier(String);
        // ... impls wie TokenIdentifier ...
        ```
        
    - **Invarianten:** String nicht leer, empfohlene Zeichen: `a-zA-Z0-9-`.
- **Enum `ColorSchemeType`**
    
    - **Definition:** Wie in. `Light`, `Dark`.
    - **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default`. (`#[default]` für `Light` oder `Dark` festlegen).
- **Struct `AccentColor`**
    
    - **Definition:**
        
        Rust
        
        ```
        use novade_core::types::Color as CoreColor; // Verwendung des Kerntyps
        
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AccentColor {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub name: Option<String>, // z.B. "Blau", "Waldgrün"
            pub value: CoreColor,     // Der tatsächliche Farbwert
        }
        // Eq und Hash manuell implementieren, wenn CoreColor::f32 nicht direkt Eq/Hash ist.
        // Für Cache-Zwecke kann der Hex-String von CoreColor verwendet werden.
        ```
        
- **Struct `ThemeVariantDefinition`**: Wie in. `applies_to_scheme: ColorSchemeType`, `tokens: TokenSet`.
    
- **Struct `ThemeDefinition`**: Wie in. Enthält `id`, `name`, `base_tokens`, `variants`, `supported_accent_colors: Option<Vec<AccentColor>>`.
    
- **Struct `AppliedThemeState`**
    
    - **Definition:** Wie in vorheriger Antwort verfeinert (mit `BTreeMap`).
        
        Rust
        
        ```
        use std::collections::BTreeMap;
        // ...
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)] // Serialize/Deserialize für Caching/Events
        pub struct AppliedThemeState {
            pub theme_id: ThemeIdentifier,
            pub color_scheme: ColorSchemeType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub active_accent_color: Option<AccentColor>,
            pub resolved_tokens: BTreeMap<TokenIdentifier, String>, // CSS-finale Werte
        }
        ```
        
- **Struct `ThemingConfiguration`**
    
    - **Definition:** Wie in vorheriger Antwort verfeinert.
        
        Rust
        
        ```
        use novade_core::types::Color as CoreColor;
        // ...
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct ThemingConfiguration {
            pub selected_theme_id: ThemeIdentifier,
            pub preferred_color_scheme: ColorSchemeType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub selected_accent_color: Option<CoreColor>, // Verwendet CoreColor
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub custom_user_token_overrides: Option<TokenSet>,
        }
        impl Default for ThemingConfiguration { /* Sinnvolle Standardwerte, z.B. Fallback-Theme */ }
        ```
        

#### 3.2. Untermodul: `domain::theming::errors`

**Datei:** `src/theming/errors.rs`

- **Enum `ThemingError`**: Wie in vorheriger Antwort verfeinert (konsolidierte Liste aus und Ergänzungen).
    
    Rust
    
    ```
    use thiserror::Error;
    use std::path::PathBuf;
    use super::types::{TokenIdentifier, ThemeIdentifier}; // Lokale Typen
    use novade_core::types::Color as CoreColor; // Kerntyp
    
    #[derive(Debug, Error)]
    pub enum ThemingError {
        #[error("Failed to parse token file '{path}': {source}")]
        TokenFileParseError { path: PathBuf, #[source] source: serde_json::Error },
        #[error("I/O error while processing token file '{path}': {source}")]
        TokenFileIoError { path: PathBuf, #[source] source: std::io::Error },
        #[error("Invalid token data in file '{path}': {message}")]
        InvalidTokenData { path: PathBuf, message: String },
        #[error("Invalid token value for '{token_id}': '{value_string}'. Reason: {reason}")]
        InvalidTokenValue { token_id: TokenIdentifier, value_string: String, reason: String },
        #[error("Cyclic dependency detected involving token '{token_id}'. Cycle path: {cycle_path:?}")]
        CyclicTokenReference { token_id: TokenIdentifier, cycle_path: Vec<TokenIdentifier> },
        #[error("Failed to load theme definition '{theme_id}' from file '{path}': {source}")]
        ThemeFileLoadError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: serde_json::Error },
        #[error("I/O error while loading theme definition '{theme_id}' from file '{path}': {source}")]
        ThemeFileIoError { theme_id: ThemeIdentifier, path: PathBuf, #[source] source: std::io::Error },
        #[error("Invalid theme data for theme '{theme_id}' in file '{path}': {message}")]
        InvalidThemeData { theme_id: ThemeIdentifier, path: PathBuf, message: String },
        #[error("Theme with ID '{theme_id}' not found.")]
        ThemeNotFound { theme_id: ThemeIdentifier },
        #[error("Referenced token '{target_token_id}' not found (referenced by '{referencing_token_id}').")]
        MissingTokenReference { referencing_token_id: TokenIdentifier, target_token_id: TokenIdentifier },
        #[error("Maximum token reference depth ({depth}) exceeded while resolving '{token_id}'.")]
        MaxReferenceDepthExceeded { token_id: TokenIdentifier, depth: u8 },
        #[error("Failed to apply theming configuration: {message}")]
        ThemeApplicationError { message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> },
        #[error("Critical error: Failed to initialize theming engine because no suitable fallback theme could be loaded: {source}")]
        FallbackThemeLoadError { #[source] source: Box<dyn std::error::Error + Send + Sync + 'static> },
        #[error("Initial theming configuration is invalid: {0}")]
        InitialConfigurationError(String),
        #[error("Internal state error in ThemingEngine: {0}")]
        InternalStateError(String),
        #[error("Failed to subscribe to theme change events: {0}")]
        EventSubscriptionError(String),
        #[error("Error applying accent color '{accent_color}' to theme '{theme_id}': {details}")]
        AccentColorApplicationError { theme_id: ThemeIdentifier, accent_color: CoreColor, details: String },
        #[error("Failed to resolve token '{token_id}': {message}")]
        TokenResolutionError { token_id: TokenIdentifier, message: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> },
        #[error("Filesystem operation error for ThemingEngine: {0}")] // Neuer Fehler für ConfigServiceAsync-Fehler
        FilesystemError(#[from] novade_core::errors::CoreError), // Annahme: ConfigServiceAsync gibt CoreError zurück
    }
    ```
    

#### 3.3. Untermodul: `domain::theming::logic` (oder `engine_internal`)

**Datei:** `src/theming/logic.rs` (und ggf. `token_loader.rs`, `theme_loader.rs`, `token_resolver.rs`)

- **Konstante:** `const MAX_TOKEN_RESOLUTION_DEPTH: u8 = 16;`
- **Funktion: `async fn load_raw_tokens_from_file(path: &Path, config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`**
    1. `content = config_service.read_file_to_string(path).await.map_err(|e| ThemingError::TokenFileIoError { path: path.to_path_buf(), source: e.into_std_io_error_or_generic() })?;` (Annahme: `ConfigServiceAsync` gibt einen Fehler zurück, der in `std::io::Error` oder einen generischen `CoreError` konvertiert werden kann).
    2. `raw_tokens: Vec<RawToken> = serde_json::from_str(&content).map_err(|e| ThemingError::TokenFileParseError { path: path.to_path_buf(), source: e })?;`
    3. In `TokenSet` (`BTreeMap`) konvertieren. Bei Duplikaten: `ThemingError::InvalidTokenData`.
    4. Basisvalidierung jedes `RawToken.value` (z.B. `TokenValue::Opacity(o)` prüfen, ob `0.0 <= o <= 1.0`). Bei Fehler: `ThemingError::InvalidTokenValue`.
- **Funktion: `async fn load_and_validate_token_files(paths: &[PathBuf], config_service: &Arc<dyn novade_core::config::ConfigServiceAsync>) -> Result<TokenSet, ThemingError>`**
    1. Iteriert über `paths`, ruft `load_raw_tokens_from_file` für jede Datei auf.
    2. Mergt die `TokenSet`s (Benutzer-spezifische überschreiben System-spezifische, falls Pfade so interpretiert werden). Loggt Überschreibungen mit `tracing::debug!`.
    3. Ruft `validate_tokenset_for_cycles` für das finale Set auf.
- **Funktion: `async fn load_theme_definition_from_file(...)`**: Analog zu Tokens, parst zu `ThemeDefinition`.
- **Funktion: `async fn load_and_validate_theme_files(...)`**: Analog, validiert zusätzlich Referenzen mittels `validate_theme_definition_references`.
- **Funktion: `validate_tokenset_for_cycles(tokens: &TokenSet) -> Result<(), ThemingError>`**
    - Implementiert Tiefensuche. Verfolgt den aktuellen Pfad (`Vec<TokenIdentifier>`). Wenn ein bereits besuchtes Token im aktuellen Pfad erneut angetroffen wird -> Zyklus.
- **Funktion: `validate_theme_definition_references(theme_def: &ThemeDefinition, global_tokens: &TokenSet) -> Result<(), ThemingError>`** (Wie in).
- **Funktion: `resolve_tokens_for_config(...) -> Result<BTreeMap<TokenIdentifier, String>, ThemingError>`**
    1. **Ausgangspunkt:** Erstelle `current_resolved_tokens: BTreeMap<TokenIdentifier, TokenValue>` (noch nicht final Strings).
    2. **Basissatz:** Kopiere `global_tokens` nach `current_resolved_tokens`. Überschreibe/Merge mit `theme_def.base_tokens`.
    3. **Variante anwenden:** Finde passende `ThemeVariantDefinition` für `config.preferred_color_scheme`. Merge deren `tokens` in `current_resolved_tokens`.
    4. **Akzentfarbe anwenden:**
        - Wenn `config.selected_accent_color` (Typ `CoreColor`) vorhanden ist:
        - Iteriere über `theme_def.accentable_tokens` (neues Feld in `ThemeDefinition`: `Option<HashMap<TokenIdentifier, AccentModificationType>>`).
        - Für jeden `token_id_to_accent` und `modification_type`:
            - Hole den Basiswert des `token_id_to_accent` aus `current_resolved_tokens` (muss ein `TokenValue::Color` sein).
            - Wende `modification_type` an (z.B. `DirectReplace` -> setze auf `selected_accent_color`; `Lighten(0.2)` -> helle `selected_accent_color` um 20% auf und setze das als neuen Wert).
            - Aktualisiere `current_resolved_tokens`. Bei Fehlern: `ThemingError::AccentColorApplicationError`.
    5. **Benutzer-Overrides:** Merge `config.custom_user_token_overrides` (falls vorhanden) in `current_resolved_tokens`.
    6. **Rekursive Referenzauflösung:**
        - Iteriere über `current_resolved_tokens`. Für jedes `(id, value)`:
        - `final_value = resolve_single_token_value(id, value, &current_resolved_tokens, Vec::new(), max_depth)?`
        - Speichere `(id, final_value_as_string)` in `final_css_tokens: BTreeMap<TokenIdentifier, String>`.
        - Die `resolve_single_token_value` Funktion ist rekursiv:
            
            Rust
            
            ```
            fn resolve_single_token_value(
                original_id: &TokenIdentifier,
                current_value: &TokenValue,
                all_tokens: &BTreeMap<TokenIdentifier, TokenValue>, // Zustand vor String-Konvertierung
                visited_path: &mut Vec<TokenIdentifier>, // Für Zyklenerkennung
                max_depth: u8,
            ) -> Result<String, ThemingError> {
                if visited_path.len() > max_depth as usize {
                    return Err(ThemingError::MaxReferenceDepthExceeded { token_id: original_id.clone(), depth: max_depth });
                }
                if visited_path.contains(original_id) {
                    return Err(ThemingError::CyclicTokenReference { token_id: original_id.clone(), cycle_path: visited_path.clone() });
                }
                visited_path.push(original_id.clone());
            
                let result = match current_value {
                    TokenValue::Reference(target_id) => {
                        let target_raw_value = all_tokens.get(target_id)
                            .ok_or_else(|| ThemingError::MissingTokenReference {
                                referencing_token_id: original_id.clone(),
                                target_token_id: target_id.clone(),
                            })?;
                        // Rekursiver Aufruf für das Ziel
                        resolve_single_token_value(target_id, target_raw_value, all_tokens, visited_path, max_depth)
                    }
                    TokenValue::Color(s) => Ok(s.clone()),
                    TokenValue::Dimension(s) => Ok(s.clone()),
                    // ... andere direkte Typen zu String ...
                    TokenValue::Opacity(o) => Ok(format!("{:.2}", o.clamp(0.0, 1.0))),
                    TokenValue::ZIndex(z) => Ok(z.to_string()),
                    TokenValue::Text(s) => Ok(s.clone()),
                };
                visited_path.pop(); // Wichtig: Beim Verlassen des Rekursionsschritts entfernen
                result
            }
            ```
            
    7. Gib `final_css_tokens` zurück.
- **Caching-Logik:**
    - **Cache-Schlüssel:** `(ThemeIdentifier, ColorSchemeType, Option<String> /* hex von AccentColor */, u64 /* hash von Overrides */)`.
    - Vor der Auflösung im Cache nachsehen. Bei Treffer direkt zurückgeben.
    - Nach erfolgreicher Auflösung Ergebnis im Cache speichern.
- **Fallback-Theme Laden:**
    - `pub(crate) fn generate_fallback_applied_state() -> AppliedThemeState`: Parst einkompilierte JSONs für `fallback.theme.json` und `base.tokens.json`, führt minimale Auflösung durch (sollte keine komplexen Referenzen haben).

#### 3.4. Öffentliche API: `ThemingEngine` Service

**Datei:** `src/theming/service.rs` (oder `mod.rs`)

- **Struct `ThemingEngineInternalState`**:
    - `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>` (neu)
    - Rest wie in vorheriger Antwort (Cache-Typ angepasst).
- **Struct `ThemingEngine`**:
    - `internal_state: Arc<tokio::sync::Mutex<ThemingEngineInternalState>>` (Verwendung von `tokio::sync::Mutex` für `async` Methoden).
    - `event_sender: tokio::sync::broadcast::Sender<ThemeChangedEvent>`.
- **Methoden der `ThemingEngine`**:
    - `pub async fn new(initial_config: ThemingConfiguration, theme_load_paths: Vec<PathBuf>, token_load_paths: Vec<PathBuf>, config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, broadcast_capacity: usize) -> Result<Self, ThemingError>`:
        1. Initialisiert `event_sender`, `config_service_ref`.
        2. Sperrt `internal_state` (initial leer).
        3. Speichert `theme_load_paths`, `token_load_paths`, `config_service_ref` in `internal_state`.
        4. Ruft `internal_load_themes_and_tokens_locked(&mut internal_state_guard).await?` auf.
        5. Ruft `internal_apply_configuration_locked(&mut internal_state_guard, initial_config, true /* is_initial */).await?` auf.
        6. Gibt `Self` zurück.
    - `async fn internal_load_themes_and_tokens_locked(&mut self_internal: &mut ThemingEngineInternalState) -> Result<(), ThemingError>`: Interne Methode zum Neuladen.
    - `async fn internal_apply_configuration_locked(&mut self_internal: &mut ThemingEngineInternalState, config: ThemingConfiguration, is_initial: bool) -> Result<(), ThemingError>`: Interne Methode zum Anwenden einer Konfig, prüft Cache, löst Pipeline aus, aktualisiert `applied_state`, `current_config`, sendet Event. Wenn `is_initial` und Auflösung fehlschlägt, wird `generate_fallback_applied_state` verwendet.
    - `pub async fn get_current_theme_state(&self) -> AppliedThemeState`: Sperrt `internal_state`, klont und gibt `applied_state` zurück.
    - `pub async fn get_available_themes(&self) -> Vec<ThemeDefinition>`: Sperrt, klont, gibt zurück.
    - `pub async fn get_current_configuration(&self) -> ThemingConfiguration`: Sperrt, klont, gibt zurück.
    - `pub async fn update_configuration(&self, new_config: ThemingConfiguration) -> Result<(), ThemingError>`: Sperrt `internal_state`, ruft `internal_apply_configuration_locked(..., new_config, false).await`.
    - `pub async fn reload_themes_and_tokens(&self) -> Result<(), ThemingError>`: Sperrt `internal_state`, ruft `internal_load_themes_and_tokens_locked().await`, dann `internal_apply_configuration_locked(..., self_internal.current_config.clone(), false).await`. Invalidiert kompletten Cache.
    - `pub fn subscribe_to_theme_changes(&self) -> tokio::sync::broadcast::Receiver<ThemeChangedEvent>`: Gibt `self.event_sender.subscribe()` zurück.
- **Event `ThemeChangedEvent`**:
    - **Payload:** `pub new_state: AppliedThemeState`
    - **Publisher:** `ThemingEngine` (via `event_sender`).
    - **Subscriber:** `ui::theming_gtk` (wendet CSS an), `domain::global_settings_service` (wenn Theming-Einstellungen sich auf globale Nicht-Theme-Einstellungen auswirken, z.B. Kontrastmodus).

#### 3.5. Implementierungsschritte `domain::theming`

(Wie in vorheriger Antwort, aber mit `async` für Ladeoperationen und `tokio::sync::Mutex` für `ThemingEngineInternalState`.)

1. **Grundgerüst** und `Cargo.toml` aktualisieren.
2. **`types.rs`**: `AccentColor` mit `CoreColor`, `AppliedThemeState` mit `BTreeMap`, `ThemingConfiguration` mit `CoreColor`. `TokenIdentifier` Validierung.
3. **`errors.rs`**: `ThemingError` um `InvalidTokenValue`, `AccentColorApplicationError`, `FilesystemError` erweitern. `FallbackThemeLoadError` mit `#[source]`.
4. **`logic.rs`**:
    - Ladefunktionen (`load_raw_tokens_from_file`, etc.) `async` machen, `ConfigServiceAsync` nutzen.
    - `resolve_tokens_for_config`: Akzentfarben-Logik detaillieren (Nutzung von `accentable_tokens` aus `ThemeDefinition`). `MAX_TOKEN_RESOLUTION_DEPTH` verwenden. Rekursive `resolve_single_token_value` Funktion implementieren.
    - Caching-Logik mit `CacheKey` (inkl. Hash für Overrides) implementieren.
    - `generate_fallback_applied_state`: JSONs parsen und minimalen State erzeugen.
5. **`service.rs`**: `ThemingEngine` mit `tokio::sync::Mutex` für `internal_state`. `async` API-Methoden. Interne `_locked`-Methoden für die Hauptlogik. Event-Versand über `tokio::sync::broadcast`.
6. **Unit-Tests**: An `async` anpassen. Mocking des `ConfigServiceAsync`. Tests für Akzentfarben, Cache-Logik (Treffer, Fehlschlag, Invalidierung).
7. **Fallback-JSONs** in `default_themes/` erstellen.
8. **`mod.rs`**: Öffentliche API re-exportieren.

---

### Modul 4: `domain::global_settings_and_state_management`

Zweck: Repräsentation, Logik zur Verwaltung und Konsistenz globaler Desktop-Einstellungen.

Bestehende Spezifikation: und vorherige Antwort.

#### Verfeinerungen und Ergänzungen:

**4.1. `domain::global_settings::types` (`src/global_settings/types.rs`)**

- Alle Einstellungs-Structs (z.B. `AppearanceSettings`, `InputBehaviorSettings`) müssen vollständig ausdefiniert werden, inklusive aller Felder, Typen, `serde`-Attribute (`#[serde(default)]`, `#[serde(rename_all = "kebab-case")]` für TOML-Kompatibilität) und `Default`-Implementierungen.
    
    Rust
    
    ```
    // Beispiel für InputBehaviorSettings
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    #[serde(default, rename_all = "kebab-case")]
    pub struct InputBehaviorSettings {
        pub mouse_acceleration_profile: MouseAccelerationProfile,
        pub custom_mouse_acceleration_factor: Option<f32>, // Validierung: 0.0 < factor
        pub mouse_sensitivity: f32, // Validierung: z.B. 0.1 - 10.0
        pub natural_scrolling_mouse: bool,
        pub natural_scrolling_touchpad: bool,
        pub tap_to_click_touchpad: bool,
        pub touchpad_pointer_speed: f32, // Validierung: z.B. 0.1 - 10.0
        pub keyboard_repeat_delay_ms: u32, // Validierung: z.B. 100-2000
        pub keyboard_repeat_rate_cps: u32, // Zeichen pro Sekunde; Validierung: z.B. 10-100
    }
    impl Default for InputBehaviorSettings { /* ... */ }
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
    pub enum MouseAccelerationProfile { #[default] Adaptive, Flat, Custom }
    ```
    
- **Validierungsmethoden**: Jede Einstellungs-Unterstruktur sollte eine `pub fn validate(&self) -> Result<(), String>`-Methode (oder `Result<(), GlobalSettingsError::ValidationError>`) haben, die interne Konsistenz und Wertebereiche prüft.
    - Beispiel: `InputBehaviorSettings::validate(&self)` prüft, ob `custom_mouse_acceleration_factor` nur `Some` ist, wenn `mouse_acceleration_profile == Custom`, und ob Faktoren/Raten in gültigen Bereichen liegen.

**4.2. `domain::global_settings::paths` (`src/global_settings/paths.rs`)**

- Der `SettingPath`-Enum muss die gesamte Hierarchie von `GlobalDesktopSettings` exakt abbilden.
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum SettingPath {
        Appearance(AppearanceSettingPath),
        WorkspaceConfig(WorkspaceSettingPath),
        InputBehavior(InputBehaviorSettingPath),
        // ...
    }
    // ... für jede Unterstruktur
    ```
    
- **Implementierung von `TryFrom<&str>` und `Display` für `SettingPath`:**
    
    Rust
    
    ```
    // Beispielhaft für einen Teilpfad
    impl fmt::Display for AppearanceSettingPath {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                AppearanceSettingPath::ActiveThemeName => write!(f, "appearance.active-theme-name"),
                AppearanceSettingPath::FontSettings(fp) => write!(f, "appearance.font-settings.{}", fp),
                // ...
            }
        }
    }
    // TryFrom<&str> erfordert sorgfältiges Parsen des Strings.
    ```
    

**4.3. `domain::global_settings::errors` (`src/global_settings/errors.rs`)**

- **`GlobalSettingsError`**:
    - `ValidationError { path: SettingPath, reason: String }`: Verwendet `SettingPath` statt `String`.
    - `PathNotFound { path: SettingPath }`.
    - `PersistenceError` sollte den spezifischen Fehler aus dem `SettingsPersistenceProvider` wrappen.

**4.4. `domain::global_settings::persistence_iface` (`src/global_settings/persistence_iface.rs`)**

- **Trait `SettingsPersistenceProvider`**:
    
    Rust
    
    ```
    #[async_trait]
    pub trait SettingsPersistenceProvider: Send + Sync {
        async fn load_global_settings(&self) -> Result<GlobalDesktopSettings, GlobalSettingsError>;
        async fn save_global_settings(&self, settings: &GlobalDesktopSettings) -> Result<(), GlobalSettingsError>;
    }
    ```
    
- **Implementierung `FilesystemSettingsProvider`**:
    - Nutzt `Arc<dyn novade_core::config::ConfigServiceAsync>`.
    - `load_global_settings`: Liest TOML-Datei, deserialisiert zu `GlobalDesktopSettings`. Bei Deserialisierungsfehlern (z.B. unbekannte Felder, wenn `deny_unknown_fields` aktiv ist, oder Typfehler), wird ein `GlobalSettingsError::DeserializationError` zurückgegeben. Wenn die Datei nicht existiert, wird `Ok(GlobalDesktopSettings::default())` zurückgegeben.
    - `save_global_settings`: Serialisiert `GlobalDesktopSettings` zu TOML, schreibt in Datei.

**4.5. `domain::global_settings::service` (`src/global_settings/service.rs`)**

- **`DefaultGlobalSettingsService`**:
    - Hält `settings: Arc<tokio::sync::RwLock<GlobalDesktopSettings>>` für threadsicheren Lese-/Schreibzugriff.
    - **`update_setting(path: SettingPath, value: serde_json::Value)`**:
        1. Holt eine Schreibsperre für `self.settings`.
        2. Erstellt einen Klon der aktuellen `settings` für die Modifikation (`let mut new_settings = (*settings_guard).clone();`).
        3. **Pfad-Navigation und Aktualisierung (komplex):**
            - Eine große `match path { ... }`-Anweisung, die für jede `SettingPath`-Variante:
                - Das entsprechende Feld in `new_settings` referenziert.
                - `serde_json::from_value::<TargetType>(value)` versucht. Bei Fehler -> `InvalidValueType`.
                - Den deserialisierten Wert in `new_settings` setzt.
        4. `new_settings.validate_recursive() -> Result<(), GlobalSettingsError::ValidationError>` aufrufen (eine Methode, die alle `validate()`-Methoden der Unterstrukturen aufruft). Bei Fehler, Änderung nicht anwenden, Fehler zurückgeben.
        5. Wenn Validierung erfolgreich: Ersetze `*settings_guard = new_settings;`.
        6. `self.event_sender.send(SettingChangedEvent { path, new_value: value /* oder serialisierter neuer Wert */})`.
        7. `self.save_settings_internal(settings_guard).await` (interne Methode, die die Sperre nutzt).
    - **`get_setting(path: &SettingPath) -> Result<serde_json::Value, GlobalSettingsError>`**:
        1. Holt eine Lesesperre.
        2. Navigiert zum Wert via `match path`.
        3. Serialisiert den Wert zu `serde_json::Value`.
- **Events:** `SettingChangedEvent`, `SettingsLoadedEvent`, `SettingsSavedEvent` (via `tokio::sync::broadcast`).

**4.6. Detaillierte Implementierungsschritte `domain::global_settings`**

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml`.
2. **`types.rs`**: Alle Einstellungs-`struct`s und `enum`s mit `serde`, `Default`, `validate()`-Methoden.
3. **`paths.rs`**: `SettingPath` Enum vollständig definieren, `Display` und `TryFrom<&str>` implementieren.
4. **`errors.rs`**: `GlobalSettingsError` definieren.
5. **`persistence_iface.rs`**: `SettingsPersistenceProvider`-Trait. `FilesystemSettingsProvider` implementieren (mit Mocking von `ConfigServiceAsync` für Tests).
6. **`service.rs`**: `GlobalSettingsService`-Trait. `DefaultGlobalSettingsService` implementieren:
    - Konstruktor, `RwLock` für `settings`.
    - `load_settings`, `save_settings` (interagieren mit Provider).
    - `update_setting` mit detaillierter Pfad-Navigation, Deserialisierung, Validierung.
    - `get_setting`, `reset_to_defaults`.
    - Event-Versand (`tokio::sync::broadcast`).
7. **Unit-Tests**: Für jede Einstellungsstruktur (Validierung, Serde, Default). Für `SettingPath` (Konvertierungen). Für `FilesystemSettingsProvider` (Mocking). Für `DefaultGlobalSettingsService` (alle API-Methoden, Fehlerfälle, Event-Auslösung, korrekte Aktualisierung verschachtelter Einstellungen).
8. **`mod.rs`**: Module deklarieren, öffentliche API re-exportieren.

---

Dieser detaillierte Plan für die Module `domain::theming` und `domain::global_settings_and_state_management` sollte es Entwicklern ermöglichen, diese Komponenten präzise zu implementieren. Die verbleibenden Module (Workspaces, Window Management Policy, User-Centric Services, Notifications Rules) würden nach demselben Schema und mit derselben Detailtiefe ausgearbeitet.


---

### Modul 5: `domain::workspaces`

Zweck: Umfassende Verwaltungslogik für Arbeitsbereiche ("Spaces"), einschließlich ihrer Definition, Fensterzuweisung, Orchestrierung und Persistenz.

Verantwortlichkeiten: Definition der Workspace-Entität, Regeln für Fensterzuweisung, Verwaltung der Workspace-Sammlung (inkl. aktivem Workspace), Laden und Speichern der Workspace-Konfiguration, Publizieren von Workspace-bezogenen Events.

Design-Rationale: Kapselung aller Workspace-bezogenen Logik an einem Ort, um Konsistenz und Wartbarkeit zu gewährleisten. Strikte Trennung von UI- und Systemdetails.

Bestehende Spezifikation: und vorherige Antworten.

#### 5.1. Untermodul: `domain::workspaces::core`

**Zweck:** Fundamentale Definition der `Workspace`-Entität und zugehöriger Typen.

**Datei:** `src/workspaces/core/types.rs`

- **Typalias `WorkspaceId`**
    - **Definition:** `pub type WorkspaceId = uuid::Uuid;`
    - **Ableitungen:** (Keine direkt, `uuid::Uuid` hat eigene)
- **Struct `WindowIdentifier`**
    - **Definition:**
        
        Rust
        
        ```
        use serde::{Serialize, Deserialize};
        use std::fmt;
        use super::errors::WorkspaceCoreError; // Für Validierungsfehler
        
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct WindowIdentifier(String);
        
        impl WindowIdentifier {
            pub fn new(id: impl Into<String>) -> Result<Self, WorkspaceCoreError> {
                let id_str = id.into();
                if id_str.is_empty() {
                    return Err(WorkspaceCoreError::WindowIdentifierEmpty);
                }
                // Ggf. weitere Validierungen (z.B. erlaubte Zeichen)
                Ok(Self(id_str))
            }
            pub fn as_str(&self) -> &str { &self.0 }
        }
        impl fmt::Display for WindowIdentifier { /* ... */ }
        impl From<&str> for WindowIdentifier { fn from(s: &str) -> Self { Self::new(s).expect("Ungültiger WindowIdentifier aus &str") } }
        // From<String> ist riskanter ohne Fehlerbehandlung, new() bevorzugen
        ```
        
    - **Invarianten:** String nicht leer.
- **Enum `WorkspaceLayoutType`**
    - **Definition:** Wie in und vorheriger Antwort.
        
        Rust
        
        ```
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
        pub enum WorkspaceLayoutType {
            #[default]
            Floating,
            TilingHorizontal, // Fenster nebeneinander
            TilingVertical,   // Fenster untereinander
            // Zukünftig ggf. komplexere Tiling-Modi direkt hier definieren oder durch
            // domain::window_management_policy referenzieren. Fürs Erste sind diese fix.
            Maximized,        // Ein Fenster ist maximiert, andere ggf. verborgen/minimiert
        }
        ```
        

**Datei:** `src/workspaces/core/mod.rs` (enthält `Workspace`-Struct-Definition)

- **Struct `Workspace`**
    - **Definition:**
        
        Rust
        
        ```
        use std::collections::HashSet;
        use uuid::Uuid;
        use chrono::{DateTime, Utc};
        use serde::{Serialize, Deserialize};
        use super::types::{WorkspaceId, WindowIdentifier, WorkspaceLayoutType};
        use super::errors::WorkspaceCoreError;
        use super::errors::MAX_WORKSPACE_NAME_LENGTH;
        
        #[derive(Debug, Clone, Serialize, Deserialize)]
        // PartialEq manuell implementieren wegen HashSet, falls nötig, oder nur auf IDs vergleichen.
        // Für die meisten Anwendungsfälle ist der Vergleich über `id` ausreichend.
        pub struct Workspace {
            id: WorkspaceId,
            name: String,
            persistent_id: Option<String>,
            layout_type: WorkspaceLayoutType,
            window_ids: HashSet<WindowIdentifier>,
            created_at: DateTime<Utc>,
            // Neu: Optionale Metadaten für den Workspace, z.B. benutzerdefiniertes Icon/Farbe
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub icon_name: Option<String>, // Name eines Icons aus dem System-Theme
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub accent_color_hex: Option<String>, // z.B. "#RRGGBB"
        }
        
        impl Workspace {
            pub fn new(name: String, persistent_id: Option<String>, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<Self, WorkspaceCoreError> {
                if name.is_empty() {
                    return Err(WorkspaceCoreError::NameCannotBeEmpty);
                }
                if name.len() > MAX_WORKSPACE_NAME_LENGTH {
                    return Err(WorkspaceCoreError::NameTooLong {
                        name: name.clone(),
                        max_len: MAX_WORKSPACE_NAME_LENGTH,
                        actual_len: name.len(),
                    });
                }
                if let Some(pid) = &persistent_id {
                    if pid.is_empty() || pid.chars().any(|c| !c.is_ascii_alphanumeric() && c != '-' && c != '_') {
                        return Err(WorkspaceCoreError::InvalidPersistentId(pid.clone()));
                    }
                }
                if let Some(hex) = &accent_color_hex {
                    // Basis-Validierung für Hex-Farbe
                    if !(hex.starts_with('#') && (hex.len() == 7 || hex.len() == 9) && hex[1..].chars().all(|c| c.is_ascii_hexdigit())) {
                        return Err(WorkspaceCoreError::InvalidAccentColorFormat(hex.clone()));
                    }
                }
        
                Ok(Self {
                    id: Uuid::new_v4(),
                    name,
                    persistent_id,
                    layout_type: WorkspaceLayoutType::default(),
                    window_ids: HashSet::new(),
                    created_at: Utc::now(),
                    icon_name,
                    accent_color_hex,
                })
            }
        
            pub fn id(&self) -> WorkspaceId { self.id }
            pub fn name(&self) -> &str { &self.name }
            pub fn persistent_id(&self) -> Option<&str> { self.persistent_id.as_deref() }
            pub fn layout_type(&self) -> WorkspaceLayoutType { self.layout_type }
            pub fn window_ids(&self) -> &HashSet<WindowIdentifier> { &self.window_ids }
            pub fn created_at(&self) -> DateTime<Utc> { self.created_at }
            pub fn icon_name(&self) -> Option<&str> { self.icon_name.as_deref() }
            pub fn accent_color_hex(&self) -> Option<&str> { self.accent_color_hex.as_deref() }
        
            pub fn rename(&mut self, new_name: String) -> Result<(), WorkspaceCoreError> {
                if new_name.is_empty() { /* ... NameCannotBeEmpty ... */ }
                if new_name.len() > MAX_WORKSPACE_NAME_LENGTH { /* ... NameTooLong ... */ }
                self.name = new_name;
                Ok(())
            }
        
            pub fn set_layout_type(&mut self, layout_type: WorkspaceLayoutType) {
                self.layout_type = layout_type;
            }
        
            pub(crate) fn add_window_id(&mut self, window_id: WindowIdentifier) -> bool {
                self.window_ids.insert(window_id)
            }
        
            pub(crate) fn remove_window_id(&mut self, window_id: &WindowIdentifier) -> bool {
                self.window_ids.remove(window_id)
            }
        
            pub fn set_persistent_id(&mut self, pid: Option<String>) -> Result<(), WorkspaceCoreError> {
                if let Some(p) = &pid {
                    if p.is_empty() || p.chars().any(|c| !c.is_ascii_alphanumeric() && c != '-' && c != '_') {
                        return Err(WorkspaceCoreError::InvalidPersistentId(p.clone()));
                    }
                }
                self.persistent_id = pid;
                Ok(())
            }
        
            pub fn set_icon_name(&mut self, icon: Option<String>) {
                self.icon_name = icon;
            }
        
            pub fn set_accent_color_hex(&mut self, color_hex: Option<String>) -> Result<(), WorkspaceCoreError> {
                 if let Some(hex) = &color_hex {
                    if !(hex.starts_with('#') && (hex.len() == 7 || hex.len() == 9) && hex[1..].chars().all(|c| c.is_ascii_hexdigit())) {
                        return Err(WorkspaceCoreError::InvalidAccentColorFormat(hex.clone()));
                    }
                }
                self.accent_color_hex = color_hex;
                Ok(())
            }
        }
        ```
        
    - **Felder:** Wie in vorheriger Antwort, plus `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    - **Methoden:** Wie in vorheriger Antwort, plus `set_icon_name`, `set_accent_color_hex`. Die `new`-Methode wird angepasst, um die neuen Felder zu akzeptieren und zu validieren.

**Datei:** `src/workspaces/core/event_data.rs`

- **Event-Payload-Strukturen**: Wie in. Zusätzlich:
    - `pub struct WorkspaceIconChangedData { pub id: WorkspaceId, pub old_icon_name: Option<String>, pub new_icon_name: Option<String> }`
    - `pub struct WorkspaceAccentChangedData { pub id: WorkspaceId, pub old_color_hex: Option<String>, pub new_color_hex: Option<String> }`
    - Alle mit `#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]`.

**Datei:** `src/workspaces/core/errors.rs`

- **Konstante `MAX_WORKSPACE_NAME_LENGTH`**: `pub const MAX_WORKSPACE_NAME_LENGTH: usize = 64;`
- **Enum `WorkspaceCoreError`**: Wie in. Zusätzlich:
    - `WindowIdentifierEmpty`
    - `InvalidAccentColorFormat(String)`

#### 5.2. Untermodul: `domain::workspaces::assignment`

**Zweck:** Geschäftslogik für die Zuweisung von Fenstern zu Workspaces.

**Datei:** `src/workspaces/assignment/errors.rs`

- **Enum `WindowAssignmentError`**: Wie in. Keine Änderungen zur vorherigen Spezifikation notwendig, da es bereits umfassend war.

**Datei:** `src/workspaces/assignment/mod.rs`

- **API-Funktionen**: Wie in. Die Implementierung der Funktionen muss detailliert werden:
    - **`assign_window_to_workspace(...)` Logik:**
        1. Prüfe `target_workspace_id` in `workspaces`. Wenn nicht gefunden: `Err(WorkspaceNotFound)`.
        2. Wenn `ensure_unique_assignment` `true` ist:
            - Iteriere über alle `(ws_id, ws)` in `workspaces`.
            - Wenn `ws_id != target_workspace_id` UND `ws.window_ids().contains(window_id)`:
                - `ws.remove_window_id(window_id);` (Diese Methode ist `pub(crate)` in `Workspace`).
        3. Hole `target_ws = workspaces.get_mut(&target_workspace_id).unwrap()`.
        4. Wenn `target_ws.add_window_id(window_id.clone())` `false` zurückgibt (Fenster war bereits da):
            - `Ok(())` (Kein Fehler, wenn es bereits auf dem Ziel-Workspace ist, auch wenn `ensure_unique_assignment` `false` war. Die Semantik ist "stelle sicher, dass es auf dem Ziel ist").
        5. Sonst (wurde neu hinzugefügt): `Ok(())`.
    - **`remove_window_from_workspace(...)` Logik:**
        1. Prüfe `source_workspace_id`. Wenn nicht gefunden: `Err(WorkspaceNotFound)`.
        2. Hole `source_ws = workspaces.get_mut(&source_workspace_id).unwrap()`.
        3. `Ok(source_ws.remove_window_id(window_id))`
    - **`move_window_to_workspace(...)` Logik:**
        1. Wenn `source_workspace_id == target_workspace_id`: `Err(CannotMoveToSameWorkspace)`.
        2. Prüfe `source_workspace_id`. Wenn nicht: `Err(SourceWorkspaceNotFound)`.
        3. Prüfe `target_workspace_id`. Wenn nicht: `Err(TargetWorkspaceNotFound)`.
        4. `source_ws = workspaces.get_mut(&source_workspace_id).unwrap()`.
        5. Wenn `!source_ws.remove_window_id(window_id)`: `Err(WindowNotOnSourceWorkspace)`.
        6. `target_ws = workspaces.get_mut(&target_workspace_id).unwrap()`.
        7. `target_ws.add_window_id(window_id.clone());` (Rückgabewert hier ignorieren, da wir wissen, dass es von der Quelle entfernt wurde).
        8. `Ok(())`.
    - **`find_workspace_for_window(...)` Logik:**
        1. Iteriere `workspaces.values()`.
        2. Wenn `ws.window_ids().contains(window_id)`, gib `Some(ws.id())` zurück.
        3. Sonst `None`.

#### 5.3. Untermodul: `domain::workspaces::config`

**Zweck:** Persistenzlogik für Workspace-Konfigurationen.

**Datei:** `src/workspaces/config/errors.rs`

- **Enum `WorkspaceConfigError`**: Wie in vorheriger Antwort (basierend auf).

**Datei:** `src/workspaces/config/mod.rs` (oder `provider.rs` und `types.rs` hier)

- **Struct `WorkspaceSnapshot`**: Wie in vorheriger Antwort. Zusätzlich `icon_name: Option<String>`, `accent_color_hex: Option<String>`.
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct WorkspaceSnapshot {
        pub persistent_id: String, // Eindeutig über Sitzungen
        pub name: String,
        pub layout_type: WorkspaceLayoutType,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub icon_name: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub accent_color_hex: Option<String>,
    }
    ```
    
- **Struct `WorkspaceSetSnapshot`**: Wie in vorheriger Antwort (`workspaces: Vec<WorkspaceSnapshot>`, `active_workspace_persistent_id: Option<String>`).
- **Trait `WorkspaceConfigProvider`**: Wie in vorheriger Antwort (`async fn load_workspace_config`, `async fn save_workspace_config`).
- **Struct `FilesystemConfigProvider`**:
    - **Felder:** `config_service: Arc<dyn novade_core::config::ConfigServiceAsync>`, `config_key_or_path: String` (z.B. "workspaces.toml").
    - **Konstruktor:** `pub fn new(config_service: Arc<dyn novade_core::config::ConfigServiceAsync>, config_key_or_path: String) -> Self`.
    - **Implementierung von `WorkspaceConfigProvider`**:
        - **`load_workspace_config`**:
            1. `content_result = self.config_service.read_config_file_string(&self.config_key_or_path).await;`
            2. `match content_result { Ok(content_str) => { ... } Err(core_err) => { ... } }`
            3. Wenn `core_err` "nicht gefunden" signalisiert (z.B. `CoreError::Io` mit `ErrorKind::NotFound` oder spezifischer `ConfigError`-Typ): `Ok(WorkspaceSetSnapshot::default())` zurückgeben (Manager erstellt dann Standard).
            4. Wenn anderer `core_err`: `Err(WorkspaceConfigError::LoadError { ..., source: core_err })`.
            5. Wenn `Ok(content_str)`: `toml::from_str(&content_str).map_err(|e| DeserializationError { ... source: Some(e) })`.
            6. Nach Deserialisierung: Validierung (doppelte `persistent_id`s in `snapshot.workspaces`, Existenz von `active_workspace_persistent_id` im Set). Bei Fehlern `InvalidData` oder `PersistentIdNotFoundInLoadedSet`.
        - **`save_workspace_config`**:
            1. `serialized_content = toml::to_string_pretty(config_snapshot).map_err(|e| SerializationError { ... source: Some(e) })?;`
            2. `self.config_service.write_config_file_string(&self.config_key_or_path, serialized_content).await.map_err(|e| SaveError { ..., source: e })?;`

#### 5.4. Untermodul: `domain::workspaces::manager`

**Zweck:** Zentraler Orchestrator für Workspace-Operationen.

**Datei:** `src/workspaces/manager/events.rs`

- **Enum `WorkspaceEvent`**: Wie in vorheriger Antwort. Zusätzlich:
    - `WorkspaceIconChanged(WorkspaceIconChangedData)`
    - `WorkspaceAccentChanged(WorkspaceAccentChangedData)`

**Datei:** `src/workspaces/manager/errors.rs`

- **Enum `WorkspaceManagerError`**: Wie in vorheriger Antwort. Keine wesentlichen Änderungen.

**Datei:** `src/workspaces/manager/mod.rs` (oder `service.rs`)

- **Trait `WorkspaceManagerService`**: (Neuer Trait für die öffentliche API, um die Implementierung zu entkoppeln).
    
    Rust
    
    ```
    use async_trait::async_trait;
    // ... imports ...
    #[async_trait]
    pub trait WorkspaceManagerService: Send + Sync {
        async fn create_workspace(&self, name: Option<String>, persistent_id: Option<String>, icon_name: Option<String>, accent_color_hex: Option<String>) -> Result<WorkspaceId, WorkspaceManagerError>;
        async fn delete_workspace(&self, id: WorkspaceId, fallback_id_for_windows: Option<WorkspaceId>) -> Result<(), WorkspaceManagerError>;
        fn get_workspace(&self, id: WorkspaceId) -> Option<Workspace>; // Gibt Klon zurück
        fn all_workspaces_ordered(&self) -> Vec<Workspace>; // Gibt Klone zurück
        fn active_workspace_id(&self) -> Option<WorkspaceId>;
        async fn set_active_workspace(&self, id: WorkspaceId) -> Result<(), WorkspaceManagerError>;
        async fn assign_window_to_active_workspace(&self, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn assign_window_to_specific_workspace(&self, workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn remove_window_from_its_workspace(&self, window_id: &WindowIdentifier) -> Result<Option<WorkspaceId>, WorkspaceManagerError>;
        async fn move_window_to_specific_workspace(&self, target_workspace_id: WorkspaceId, window_id: &WindowIdentifier) -> Result<(), WorkspaceManagerError>;
        async fn rename_workspace(&self, id: WorkspaceId, new_name: String) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_layout(&self, id: WorkspaceId, layout_type: WorkspaceLayoutType) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_icon(&self, id: WorkspaceId, icon_name: Option<String>) -> Result<(), WorkspaceManagerError>;
        async fn set_workspace_accent_color(&self, id: WorkspaceId, color_hex: Option<String>) -> Result<(), WorkspaceManagerError>;
        async fn save_configuration(&self) -> Result<(), WorkspaceManagerError>;
        fn subscribe_to_workspace_events(&self) -> tokio::sync::broadcast::Receiver<WorkspaceEvent>;
        // Neu: Methode zur Änderung der Reihenfolge
        async fn reorder_workspace(&self, workspace_id: WorkspaceId, new_index: usize) -> Result<(), WorkspaceManagerError>;
    }
    ```
    
- **Struct `WorkspaceManager`** (umbenannt zu `DefaultWorkspaceManager` für die Implementierung).
    - **Felder:** `internal: Arc<tokio::sync::Mutex<WorkspaceManagerInternalState>>`.
- **Struct `WorkspaceManagerInternalState`**:
    - `workspaces: HashMap<WorkspaceId, Workspace>`
    - `active_workspace_id: Option<WorkspaceId>`
    - `ordered_workspace_ids: Vec<WorkspaceId>`
    - `next_workspace_number: u32`
    - `config_provider: Arc<dyn WorkspaceConfigProvider>`
    - `event_publisher: tokio::sync::broadcast::Sender<WorkspaceEvent>`
    - `ensure_unique_window_assignment: bool`
- **Implementierung `#[async_trait] impl WorkspaceManagerService for DefaultWorkspaceManager`**:
    - **`new(...)`**:
        1. Sperrt `internal`, initialisiert Felder.
        2. `snapshot = self.internal.config_provider.load_workspace_config().await.map_err(WorkspaceManagerError::from)?;`
        3. Wenn `snapshot.workspaces` leer ist (oder `load_config` "nicht gefunden" signalisiert und Default zurückgibt):
            - Ruft `internal_create_workspace_locked` auf, um einen Standard-Workspace ("Workspace 1") zu erstellen.
            - Setzt diesen als aktiv.
        4. Sonst: Rekonstruiert `workspaces` und `ordered_workspace_ids` aus `snapshot`. Setzt `active_workspace_id` basierend auf `snapshot.active_workspace_persistent_id`.
        5. Aktualisiert `next_workspace_number`.
        6. Sendet `WorkspacesReloaded` und `ActiveWorkspaceChanged` Events.
    - **`create_workspace(...)`**:
        1. Sperrt `internal`.
        2. Prüft auf `DuplicatePersistentId`.
        3. Ruft `Workspace::new(...)`.
        4. Fügt zu `workspaces` und `ordered_workspace_ids` hinzu.
        5. Sendet `WorkspaceCreated`.
        6. Ruft `internal_save_configuration_locked()`.
    - **`delete_workspace(...)`**: Sperrt, prüft Bedingungen, verschiebt Fenster via `assignment`-Modul, sendet Events, speichert.
    - `get_workspace()` / `all_workspaces_ordered()`: Sperrt, klont die angeforderten `Workspace`-Objekte und gibt sie zurück.
    - **`set_active_workspace(...)`**: Sperrt, prüft, aktualisiert, sendet Event, speichert (optional).
    - **Fensterzuweisungsmethoden**: Sperren `internal`, rufen Funktionen aus `domain::workspaces::assignment` mit `&mut internal.workspaces` auf, senden Events.
    - **`rename_workspace(...)`, `set_workspace_layout(...)`, `set_workspace_icon(...)`, `set_workspace_accent_color(...)`**:
        1. Sperrt `internal`.
        2. Findet `workspace_mut` in `internal.workspaces`. Wenn nicht: `Err(WorkspaceNotFound)`.
        3. Ruft entsprechende `workspace_mut.set_...(...)` Methode auf.
        4. Sendet entsprechendes Event (`WorkspaceRenamed`, `WorkspaceLayoutChanged`, `WorkspaceIconChanged`, `WorkspaceAccentChanged`).
        5. Ruft `internal_save_configuration_locked()`.
    - **`reorder_workspace(...)`**:
        1. Sperrt `internal`.
        2. Validiert `workspace_id` und `new_index`.
        3. Entfernt `workspace_id` aus `ordered_workspace_ids` und fügt es an `new_index` wieder ein.
        4. Sendet `WorkspaceOrderChanged` mit der neuen `ordered_workspace_ids` (als Klon).
        5. Ruft `internal_save_configuration_locked()`.
    - **`save_configuration()`**: Sperrt `internal`, ruft `internal_save_configuration_locked()`.
    - **`internal_save_configuration_locked()`**: Private Hilfsmethode, die den Snapshot erstellt und `config_provider.save_workspace_config()` aufruft.
    - **`subscribe_to_workspace_events()`**: `self.internal.lock().await.event_publisher.subscribe()`.

#### 5.5. Implementierungsschritte `domain::workspaces`

(Reihenfolge und Tests wie in vorheriger Antwort, aber mit Fokus auf `async` wo spezifiziert und `tokio::sync::Mutex`.)

1. **`core` Modul**: `Workspace` um neue Felder und Methoden erweitern. Neue Event-Payloads. `WorkspaceCoreError` erweitern. Tests.
2. **`assignment` Modul**: Implementierungslogik der Funktionen detaillieren und testen.
3. **`config` Modul**: `WorkspaceSnapshot` anpassen. `FilesystemConfigProvider` mit `async` Methoden und `ConfigServiceAsync`. Tests (Mocking).
4. **`manager` Modul**: `WorkspaceEvent` erweitern. `WorkspaceManagerService` Trait definieren. `DefaultWorkspaceManager` mit `tokio::sync::Mutex` und `async` Methoden implementieren. `reorder_workspace` Methode hinzufügen. Umfassende Tests.
5. **`src/workspaces/mod.rs`**: Module deklarieren, öffentliche API (Service-Trait, wichtige Typen, Fehler, Events) re-exportieren.

---

### Modul 6: `domain::window_management_policy`

Zweck: Definition von High-Level-Regeln und Richtlinien für Fensterplatzierung, Tiling, Snapping, Gruppierung, Fokus und Gap-Management. Definiert die "Policy", die Systemschicht die "Mechanik".

Verantwortlichkeiten: Bereitstellung von Algorithmen zur Berechnung von Fenstergeometrien basierend auf aktuellen Policies und Workspace-Zuständen.

Design-Rationale: Entkopplung der komplexen Layout- und Policy-Logik von der technischen Umsetzung im Compositor. Ermöglicht flexible und austauschbare Fensterverwaltungsstrategien.

#### 6.1. Untermodul: `domain::window_management_policy::types`

**Datei:** `src/window_management_policy/types.rs`

- **Enum `TilingMode`**: Wie in vorheriger Antwort (Manual, Columns, Rows, Spiral, MaximizedFocused).
- **Struct `GapSettings`**: Wie in vorheriger Antwort.
- **Struct `WindowSnappingPolicy`**: Wie in vorheriger Antwort.
- **Struct `WindowGroupingPolicy`**: Wie in vorheriger Antwort.
- **Enum `NewWindowPlacementStrategy`**: Wie in vorheriger Antwort.
- **Enum `FocusStealingPreventionLevel`**: Wie in vorheriger Antwort.
- **Struct `FocusPolicy`**: Wie in vorheriger Antwort.
- **Struct `WindowPolicyOverrides`**: Wie in vorheriger Antwort.
- **Struct `WorkspaceWindowLayout`**: Wie in vorheriger Antwort.
    - **Zusatzfeld**: `pub tiling_mode_applied: TilingMode` (Speichert, welcher Modus tatsächlich für dieses Layout verwendet wurde).
- **Struct `WindowLayoutInfo`** (neu, für die Übergabe an `calculate_workspace_layout`):
    
    Rust
    
    ```
    use crate::domain::workspaces::core::types::WindowIdentifier;
    use crate::core::types::Size; // u32 Annahme
    
    #[derive(Debug, Clone, PartialEq)]
    pub struct WindowLayoutInfo {
        pub id: WindowIdentifier,
        pub requested_min_size: Option<Size<u32>>, // Vom Client oder Policy
        pub requested_base_size: Option<Size<u32>>,// Für Größeninkremente (zukünftig)
        pub is_fullscreen_requested: bool,
        pub is_maximized_requested: bool, // Expliziter Maximierungswunsch vom Client/User
        // Weitere Flags, die das Layout beeinflussen könnten
    }
    ```
    

#### 6.2. Untermodul: `domain::window_management_policy::errors`

**Datei:** `src/window_management_policy/errors.rs`

- **Enum `WindowPolicyError`**: Wie in vorheriger Antwort.

#### 6.3. Untermodul: `domain::window_management_policy::service`

**Datei:** `src/window_management_policy/service.rs` (oder `mod.rs`)

- **Trait `WindowManagementPolicyService`**:
    
    - **`calculate_workspace_layout` Signatur angepasst:**
        
        Rust
        
        ```
        async fn calculate_workspace_layout(
            &self,
            workspace_id: WorkspaceId,
            windows_to_layout: &[WindowLayoutInfo], // Geänderter Typ
            available_area: RectInt,
            // Policy-Einstellungen werden jetzt intern vom Service über GlobalSettingsService bezogen
            // oder es gibt spezifische Methoden, um sie zu setzen/abzurufen.
            // Hier gehen wir davon aus, dass sie intern über GlobalSettingsService bezogen werden.
            workspace_current_tiling_mode: TilingMode, // Tiling-Modus, der für diesen Workspace gilt
            focused_window_id: Option<&WindowIdentifier>, // Optional, für MaximizedFocused
            window_specific_overrides: &HashMap<WindowIdentifier, WindowPolicyOverrides>
        ) -> Result<WorkspaceWindowLayout, WindowPolicyError>;
        ```
        
    - **`get_initial_window_geometry` Signatur angepasst:**
        
        Rust
        
        ```
        async fn get_initial_window_geometry(
            &self,
            window_info: &WindowLayoutInfo, // Enthält requested_size etc.
            is_transient_for: Option<&WindowIdentifier>,
            parent_geometry: Option<RectInt>, // Geometrie des Elternfensters für transiente Fenster
            workspace_id: WorkspaceId,
            active_layout_on_workspace: &WorkspaceWindowLayout,
            available_area: RectInt,
            // placement_strategy wird intern vom Service via GlobalSettingsService bezogen
            window_specific_overrides: &Option<WindowPolicyOverrides>
        ) -> Result<RectInt, WindowPolicyError>;
        ```
        
    - **`calculate_snap_target`**: Signatur bleibt ähnlich.
    - **Neue Methoden zum Abruf von Teil-Policies (statt Übergabe von `GlobalDesktopSettings`):**
        
        Rust
        
        ```
        async fn get_effective_tiling_mode_for_workspace(&self, workspace_id: WorkspaceId) -> Result<TilingMode, WindowPolicyError>;
        async fn get_effective_gap_settings_for_workspace(&self, workspace_id: WorkspaceId) -> Result<GapSettings, WindowPolicyError>;
        async fn get_effective_snapping_policy(&self) -> Result<WindowSnappingPolicy, WindowPolicyError>;
        async fn get_effective_focus_policy(&self) -> Result<FocusPolicy, WindowPolicyError>;
        async fn get_effective_new_window_placement_strategy(&self) -> Result<NewWindowPlacementStrategy, WindowPolicyError>;
        // Diese Methoden würden intern den GlobalSettingsService konsultieren und
        // ggf. Workspace-spezifische Overrides berücksichtigen (falls diese in Zukunft eingeführt werden).
        ```
        
- **Implementierung `DefaultWindowManagementPolicyService`**:
    
    - **Konstruktor:** `pub fn new(settings_service: Arc<dyn GlobalSettingsService>) -> Self`.
    - **`calculate_workspace_layout` Logik (verfeinert):**
        1. Holt `GapSettings` über `self.get_effective_gap_settings_for_workspace()`.
        2. `effective_area = available_area` abzüglich äußerer `screen_outer_horizontal/vertical` Gaps.
        3. **Floating-Fenster herausfiltern:** Identifiziere Fenster mit `is_always_floating == Some(true)` aus `window_specific_overrides` oder solche, die aufgrund von Client-Hints (z.B. feste Größe, Dialoge - Information nicht direkt hier verfügbar, muss von Systemschicht kommen und in `WindowLayoutInfo` oder `WindowPolicyOverrides` reflektiert werden) als floating behandelt werden sollen. Für diese wird keine Tiling-Geometrie berechnet; ihre Positionen/Größen bleiben (oder werden initial gesetzt).
        4. `tiled_windows: Vec<&WindowLayoutInfo>` = verbleibende Fenster.
        5. Wenn `tiled_windows` leer ist oder `workspace_current_tiling_mode == TilingMode::Manual`:
            - Für jedes `window_info` in `windows_to_layout` (auch die "floating" markierten):
                - Wenn es ein Override für `fixed_position`/`fixed_size` gibt, dieses verwenden.
                - Sonst: Rufe `self.get_initial_window_geometry(...)` für dieses Fenster auf, um eine initiale Platzierung zu erhalten (oder behalte die aktuelle Position, falls es ein Re-Layout ist).
            - `WorkspaceWindowLayout` mit diesen Geometrien und `tiling_mode_applied = TilingMode::Manual` zurückgeben.
        6. **Tiling-Logik (Beispiel für `TilingMode::Columns`):**
            - `num_tiled_windows = tiled_windows.len()`.
            - `total_inner_gaps_width = gap_settings.window_inner * (num_tiled_windows - 1) as u16`.
            - `allocatable_width = effective_area.width - total_inner_gaps_width`.
            - `width_per_window = allocatable_width / num_tiled_windows as u32`. (Restbreite könnte verteilt oder ignoriert werden).
            - `current_x = effective_area.x`.
            - Für jedes `window_info` in `tiled_windows`:
                - `height = effective_area.height`.
                - `actual_width = width_per_window`. Ggf. Mindestbreite aus `window_info.requested_min_size` oder `WindowPolicyOverrides` berücksichtigen und `actual_width` anpassen (komplexere Verteilung nötig, wenn Mindestbreiten Summe überschreiten).
                - Speichere `RectInt::new(current_x, effective_area.y, actual_width, height)` für `window_info.id`.
                - `current_x += actual_width as i32 + gap_settings.window_inner as i32`.
            - `WorkspaceWindowLayout` mit diesen Geometrien und `tiling_mode_applied = TilingMode::Columns` zurückgeben.
        7. **`TilingMode::MaximizedFocused` Logik:**
            - Wenn `focused_window_id` und dieses Fenster in `tiled_windows` ist:
                - Geometrie für `focused_window_id` ist `effective_area`.
                - Andere `tiled_windows` erhalten eine (0,0)-Größe oder werden nicht in die `window_geometries` Map aufgenommen (signalisiert "versteckt").
            - Sonst (kein Fokus oder fokussiertes Fenster ist floating): Falle zurück auf `Manual` oder einen anderen Default-Tiling-Modus.
        8. Algorithmen für `Rows` (analog zu Columns), `Spiral` (Fibonacci-Partitionierung des `effective_area`) implementieren.
    - **Interne Hilfsfunktionen für Layout-Algorithmen.**

#### 6.4. Detaillierte Implementierungsschritte `domain::window_management_policy`

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml`.
2. **`types.rs`**: Alle Policy-Typen (`TilingMode`, `GapSettings`, etc.), `WindowLayoutInfo`, `WorkspaceWindowLayout` definieren. `serde` und `Default`.
3. **`errors.rs`**: `WindowPolicyError` definieren.
4. **`service.rs`**:
    - `WindowManagementPolicyService`-Trait definieren mit den verfeinerten Signaturen.
    - `DefaultWindowManagementPolicyService`-Struktur mit `Arc<dyn GlobalSettingsService>`.
    - `new()`-Konstruktor implementieren.
    - `get_effective_*_policy()`-Methoden implementieren (lesen aus `GlobalSettingsService`).
    - `calculate_workspace_layout()`:
        - Implementiere Logik zum Herausfiltern von Floating-Fenstern.
        - Implementiere die spezifischen Layout-Algorithmen (Manual, Columns, Rows, Spiral, MaximizedFocused) als private Methoden, die `available_area`, `gap_settings` und die Liste der zu kachelnden Fenster berücksichtigen.
        - Stelle sicher, dass Mindest-/Maximalgrößen und Overrides aus `WindowPolicyOverrides` beachtet werden.
    - `get_initial_window_geometry()`: Implementiere verschiedene Strategien (`Smart`, `Center` etc.).
    - `calculate_snap_target()`: Implementiere Snapping-Logik.
5. **Unit-Tests**:
    - Für jeden Layout-Algorithmus: Verschiedene Anzahlen von Fenstern, verschiedene `available_area`, verschiedene Gap-Settings. Teste auch mit Mindestgrößen.
    - Für `get_initial_window_geometry`: Teste alle Platzierungsstrategien.
    - Für `calculate_snap_target`: Teste Snapping an Bildschirmränder und andere Fenster.
    - Für die Service-Methoden: Mocking des `GlobalSettingsService`. Teste, dass die korrekten Policies abgerufen und angewendet werden.

---

Die detaillierten Spezifikationen für die Module 7 (`user_centric_services`) und 8 (`notifications_rules`) werden in der nächsten Antwort folgen, basierend auf dieser Struktur und Methodik.
### Modul 7: `domain::user_centric_services`

Zweck: Bündelt die Logik für Dienste, die direkt auf die Bedürfnisse und Interaktionen des Benutzers ausgerichtet sind, insbesondere KI-Interaktionen (inklusive Einwilligungsmanagement) und ein umfassendes Benachrichtigungssystem.

Verantwortlichkeiten: Verwaltung von KI-Interaktionskontexten, Benutzereinwilligungen und KI-Modellprofilen. Entgegennahme, Verarbeitung, Speicherung und Verwaltung von System- und Anwendungsbenachrichtigungen.

Design-Rationale: Zentralisierung benutzerorientierter Dienste, um eine kohärente und kontrollierte Benutzererfahrung in Bezug auf Assistenzfunktionen und Benachrichtigungen zu ermöglichen. Trennung der Domänenlogik von der technischen Umsetzung (MCP-Kommunikation, D-Bus-Notification-Daemon-Interaktion) in der Systemschicht und der Darstellung in der UI-Schicht.

Bestehende Spezifikation: und vorherige Antworten.

#### 7.1. Untermodul: `domain::user_centric_services::ai_interaction`

**Zweck:** Verwaltung von KI-Interaktionen, Benutzereinwilligungen und KI-Modellprofilen.

**Datei:** `src/user_centric_services/ai_interaction/types.rs`

- **Enum `AIDataCategory`**
    
    - **Definition:** Wie in (UserProfile, ApplicationUsage, FileSystemRead, ClipboardAccess, LocationData, GenericText, GenericImage).
    - **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`.
    - **Zusatz:**
        
        Rust
        
        ```
        // Optional: Methode zur menschenlesbaren Beschreibung
        impl AIDataCategory {
            pub fn description(&self) -> &'static str {
                match self {
                    AIDataCategory::UserProfile => "Persönliche Profilinformationen (z.B. Name, Einstellungen)",
                    AIDataCategory::ApplicationUsage => "Informationen über genutzte Anwendungen und deren Aktivität",
                    AIDataCategory::FileSystemRead => "Lesezugriff auf das Dateisystem",
                    AIDataCategory::ClipboardAccess => "Zugriff auf den Inhalt der Zwischenablage",
                    AIDataCategory::LocationData => "Standortinformationen",
                    AIDataCategory::GenericText => "Allgemeiner Textinhalt (z.B. vom Benutzer eingegeben)",
                    AIDataCategory::GenericImage => "Allgemeiner Bildinhalt",
                }
            }
        }
        ```
        
- **Enum `AIConsentStatus`**
    
    - **Definition:** Wie in (Granted, Denied, PendingUserAction, NotRequired).
    - **Ableitungen:** `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`.
- **Struct `AttachmentData`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        use uuid::Uuid;
        use serde::{Serialize, Deserialize};
        
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AttachmentData {
            pub id: Uuid,
            pub mime_type: String, // z.B. "text/plain", "image/png", "application/pdf"
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub source_uri: Option<String>, // z.B. "file:///path/to/file.txt"
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub content_base64: Option<String>, // Base64-kodierter Inhalt für Binärdaten
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub text_content: Option<String>, // Für reinen Textinhalt
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub description: Option<String>,
        }
        
        impl AttachmentData {
            pub fn new_text(text: String, description: Option<String>) -> Self { /* ... */ }
            pub fn new_from_uri(uri: String, mime_type: String, description: Option<String>) -> Self { /* ... */ }
            // new_from_binary_content(content: Vec<u8>, mime_type: String, description: Option<String>) -> Self
        }
        ```
        
    - **Verfeinerung:** `content: Option<Vec<u8>>` wird zu `content_base64: Option<String>` für leichtere Serialisierung (JSON) und `text_content: Option<String>`. `source_uri` bleibt für Verweise.
- **Struct `AIInteractionContext`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        use chrono::{DateTime, Utc};
        // ... andere Imports ...
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct AIInteractionContext {
            pub id: Uuid,
            pub creation_timestamp: DateTime<Utc>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub active_model_id: Option<String>, // ID des KI-Modells
            pub consent_status: AIConsentStatus,
            pub associated_data_categories: Vec<AIDataCategory>,
            // interaction_history als separate Struktur für mehr Flexibilität
            pub history_entries: Vec<InteractionHistoryEntry>,
            pub attachments: Vec<AttachmentData>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub user_prompt_template: Option<String>, // Vorlage für den initialen Prompt
            #[serde(default)]
            pub is_active: bool, // Ob dieser Kontext gerade "offen" oder aktiv in der UI ist
        }
        ```
        
    - **Neue Struktur `InteractionHistoryEntry`**:
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub enum InteractionParticipant { User, Assistant, System }
        
        #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
        pub struct InteractionHistoryEntry {
            pub entry_id: Uuid,
            pub timestamp: DateTime<Utc>,
            pub participant: InteractionParticipant,
            pub content: String, // Text der Nachricht/Aktion
            #[serde(default, skip_serializing_if = "Vec::is_empty")]
            pub related_attachment_ids: Vec<Uuid>, // IDs von Attachments, die sich auf diesen Eintrag beziehen
        }
        ```
        
- **Struct `AIConsent`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
        pub struct AIConsent {
            pub id: Uuid, // Eindeutige ID der Einwilligung selbst
            pub user_id: String, // Vereinfacht, könnte komplexer sein
            pub model_id: String, // Für welches spezifische Modell oder "*" für alle
            pub data_category: AIDataCategory, // Einwilligung pro Kategorie
            pub granted_timestamp: DateTime<Utc>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub expiry_timestamp: Option<DateTime<Utc>>,
            pub is_revoked: bool,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub last_used_timestamp: Option<DateTime<Utc>>, // Wann zuletzt genutzt
            pub consent_scope: AIConsentScope, // Neu
        }
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
        pub enum AIConsentScope { #[default] SessionOnly, PersistentUntilRevoked, SpecificDuration }
        ```
        
    - **Verfeinerung:** `data_categories: Vec<AIDataCategory>` wird zu `data_category: AIDataCategory`, um granularere Einwilligungen pro Kategorie zu ermöglichen (d.h. ein `AIConsent`-Objekt pro (user, model, category)-Tupel). `AIConsentScope` hinzugefügt.
- **Struct `AIModelProfile`**
    
    - **Definition:** Wie in.
        
        Rust
        
        ```
        #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
        pub struct AIModelProfile {
            pub model_id: String, // Eindeutig, z.B. "local-llama3-8b", "openai-gpt-4o"
            pub display_name: String,
            pub description: String,
            pub provider: String, // z.B. "Local", "OpenAI", "Groq"
            pub required_consent_categories: Vec<AIDataCategory>,
            pub capabilities: Vec<AIModelCapability>, // Enum statt String
            pub supports_streaming: bool, // Gibt das Modell Antworten im Stream zurück?
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub endpoint_url: Option<String>, // Für Remote-Modelle
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pub api_key_secret_name: Option<String>, // Name des Secrets im Secret Service
            #[serde(default)]
            pub is_default_model: bool, // Kann nur ein Modell Default sein
            #[serde(default)]
            pub sort_order: i32, // Für die Anzeige in UI-Auswahlen
        }
        
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
        pub enum AIModelCapability { TextGeneration, CodeGeneration, Summarization, Translation, ImageAnalysis, FunctionCalling }
        ```
        
    - **Verfeinerung:** `capabilities` als Enum `AIModelCapability`. Zusätzliche Felder `supports_streaming`, `endpoint_url`, `api_key_secret_name`, `is_default_model`, `sort_order`.

**Datei:** `src/user_centric_services/ai_interaction/errors.rs`

- **Enum `AIInteractionError`**: Wie in. Zusätzlich/Verfeinert:
    - `ConsentCheckFailed { model_id: String, category: AIDataCategory, reason: String }`
    - `ApiKeyNotFoundInSecrets { secret_name: String }`
    - `ModelEndpointUnreachable { model_id: String, url: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> }` (Dieser Fehler käme eher von der Systemschicht, wird hier aber als möglicher Domänenfehler bei der Modellvalidierung aufgeführt)
    - `NoDefaultModelConfigured`
    - `CoreConfigError(#[from] novade_core::config::ConfigError)` (Wenn Laden von Profilen/Consents fehlschlägt)

**Datei:** `src/user_centric_services/ai_interaction/persistence_iface.rs`

- **Trait `AIConsentProvider`**:
    
    Rust
    
    ```
    #[async_trait]
    pub trait AIConsentProvider: Send + Sync {
        async fn load_consents_for_user(&self, user_id: &str) -> Result<Vec<AIConsent>, AIInteractionError>;
        async fn save_consent(&self, consent: &AIConsent) -> Result<(), AIInteractionError>;
        async fn revoke_consent(&self, consent_id: Uuid, user_id: &str) -> Result<(), AIInteractionError>;
        // Ggf. Methode zum Löschen abgelaufener Consents
    }
    ```
    
- **Trait `AIModelProfileProvider`**:
    
    Rust
    
    ```
    #[async_trait]
    pub trait AIModelProfileProvider: Send + Sync {
        async fn load_model_profiles(&self) -> Result<Vec<AIModelProfile>, AIInteractionError>;
        // Ggf. async fn save_model_profiles(&self, profiles: &[AIModelProfile]) -> Result<(), AIInteractionError>;
    }
    ```
    
- **Implementierungen** (z.B. `FilesystemAIConsentProvider`, `FilesystemAIModelProfileProvider`) in einem `persistence.rs` Untermodul, die `Arc<dyn novade_core::config::ConfigServiceAsync>` nutzen, um Daten als TOML/JSON in spezifischen Dateien unter `$XDG_CONFIG_HOME/novade/ai/` zu speichern/laden.

**Datei:** `src/user_centric_services/ai_interaction/service.rs` (oder `mod.rs`)

- **Trait `AIInteractionLogicService`**:
    - **Signaturen:** Wie in.
    - **Zusätzliche Methoden/Verfeinerungen:**
        - `async fn get_consent_status_for_interaction(&self, context_id: Uuid, model_id: &str, required_categories: &[AIDataCategory]) -> Result<AIConsentStatus, AIInteractionError>;` (Prüft spezifisch für einen Kontext)
        - `async fn get_default_model(&self) -> Result<Option<AIModelProfile>, AIInteractionError>;`
        - `async fn update_interaction_history(&mut self, context_id: Uuid, entry: InteractionHistoryEntry) -> Result<(), AIInteractionError>;`
- **Implementierung `DefaultAIInteractionLogicService`**:
    - **Felder:**
        - `active_contexts: Arc<tokio::sync::Mutex<HashMap<Uuid, AIInteractionContext>>>`
        - `model_profiles: Arc<tokio::sync::RwLock<Vec<AIModelProfile>>>`
        - `user_consents: Arc<tokio::sync::Mutex<HashMap<String /* user_id */, Vec<AIConsent>>>>`
        - `consent_provider: Arc<dyn AIConsentProvider>`
        - `profile_provider: Arc<dyn AIModelProfileProvider>`
        - `event_publisher: tokio::sync::broadcast::Sender<super::events::AIInteractionEventEnum>` (Wrapper-Enum für Events)
    - **Konstruktor `new(...)`**: Nimmt Provider, lädt initial Profile und Consents für den aktuellen Benutzer.
    - **Logik `initiate_interaction`**: Erstellt `AIInteractionContext`, speichert in `active_contexts`, sendet `AIInteractionInitiatedEvent`.
    - **Logik `provide_consent`**:
        1. Findet oder erstellt `AIConsent`-Objekt(e) basierend auf `model_id`, `granted_categories`, `consent_decision`.
        2. Ruft `consent_provider.save_consent()` auf.
        3. Aktualisiert `user_consents` Cache.
        4. Aktualisiert `consent_status` im `AIInteractionContext` (falls `context_id` gegeben).
        5. Sendet `AIConsentUpdatedEvent`.
    - **Logik `get_consent_status_for_interaction`**:
        1. Lädt `active_model_id` aus `AIInteractionContext` (falls nicht direkt übergeben).
        2. Iteriert `required_categories`. Für jede Kategorie:
            - Sucht in `self.user_consents` nach einem gültigen (nicht abgelaufen, nicht widerrufen) `AIConsent` für den `user_id` (aus Kontext, hier vereinfacht), `model_id` und die `category`.
            - Wenn für eine Kategorie keine explizite Zustimmung (Granted) gefunden wird -> `AIConsentStatus::PendingUserAction` oder `Denied` (wenn zuvor explizit verweigert).
        3. Wenn für alle `Granted` -> `AIConsentStatus::Granted`.
        4. Wenn `model_profile.required_consent_categories` leer ist -> `AIConsentStatus::NotRequired`.
- **Events:** (Wrapper-Enum `AIInteractionEventEnum` für `tokio::sync::broadcast`)
    - `AIInteractionInitiatedEvent { context: AIInteractionContext }` (Payload enthält ganzen Kontext)
    - `AIConsentUpdatedEvent { user_id: String, model_id: String, category: AIDataCategory, new_status: AIConsentStatus, scope: AIConsentScope }`
    - `AIContextUpdatedEvent { context_id: Uuid, updated_field: String /* z.B. "history", "attachment" */}`
    - `AIModelProfilesReloadedEvent { profiles: Vec<AIModelProfile> }`

#### 7.2. Untermodul: `domain::user_centric_services::notifications_core`

**Zweck:** Kernlogik für das Verwalten von Benachrichtigungen.

**Datei:** `src/user_centric_services/notifications_core/types.rs`

- **Enum `NotificationUrgency`**: Wie in (Low, Normal, Critical).
- **Enum `NotificationActionType`**: Wie in (Callback, OpenLink).
- **Struct `NotificationAction`**: Wie in.
- **Struct `Notification`**: Wie in.
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct Notification {
        pub id: Uuid,
        pub application_name: String, // Optional: ApplicationId statt String
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub application_icon: Option<String>, // Icon-Name oder Pfad
        pub summary: String, // Darf nicht leer sein
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub body: Option<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub actions: Vec<NotificationAction>,
        pub urgency: NotificationUrgency,
        pub timestamp: DateTime<Utc>, // Zeitpunkt des Eintreffens in diesem Service
        #[serde(default)]
        pub is_read: bool,
        #[serde(default)]
        pub is_dismissed: bool, // Vom Benutzer aktiv geschlossen
        #[serde(default)]
        pub transient: bool, // Nicht in Historie speichern, wenn true
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub category: Option<String>, // Standardkategorien: "device", "email", "im", "transfer" etc.
        #[serde(default, skip_serializing_if = "HashMap::is_empty")]
        pub hints: HashMap<String, serde_json::Value>, // Für zusätzliche Daten (z.B. x-coordinates, image-data)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub timeout_ms: Option<u32>, // 0 für persistent, None für Standard-Timeout
    }
    impl Notification { /* ... new() ... mark_as_read(), dismiss() ... */ }
    ```
    
    - **Verfeinerung:** Zusätzliche Felder `category`, `hints`, `timeout_ms`.
- **Enum `NotificationFilterCriteria`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum NotificationFilterCriteria {
        Unread(bool), // true für nur ungelesene, false für nur gelesene
        Application(ApplicationId),
        Urgency(NotificationUrgency),
        Category(String),
        HasAction(String), // Action Key
        BodyContains(String),
        SummaryContains(String),
        IsTransient(bool),
        AndTimeRange { // Neu
            start: Option<DateTime<Utc>>,
            end: Option<DateTime<Utc>>,
        },
        And(Vec<NotificationFilterCriteria>), // Neu
        Or(Vec<NotificationFilterCriteria>),  // Neu
        Not(Box<NotificationFilterCriteria>), // Neu
    }
    ```
    
- **Enum `NotificationSortOrder`**: Wie in (TimestampAscending, TimestampDescending, Urgency). Zusätzlich: `ApplicationNameAscending`, `SummaryAscending`.

**Datei:** `src/user_centric_services/notifications_core/errors.rs`

- **Enum `NotificationError`**: Wie in. Zusätzlich:
    - `InvalidFilterCriteria(String)`
    - `ActionInvocationFailed { notification_id: Uuid, action_id: String, reason: String }`

**Datei:** `src/user_centric_services/notifications_core/service.rs` (oder `mod.rs`)

- **Trait `NotificationService`**:
    - **Signaturen:** Wie in.
    - `post_notification` nimmt `notification_data: NotificationInput` (eine vereinfachte Struktur ohne `id`, `timestamp`, `is_read`, `is_dismissed`).
    - **Neue Methoden:**
        - `async fn get_stats(&self) -> Result<NotificationStats, NotificationError>;`
        - `async fn clear_all_for_app(&mut self, app_id: &ApplicationId) -> Result<usize, NotificationError>;` (gibt Anzahl gelöschter zurück)
- **Implementierung `DefaultNotificationService`**:
    - **Felder:**
        - `active_notifications: Arc<tokio::sync::RwLock<VecDeque<Notification>>>` (VecDeque für einfaches FIFO-Verhalten, wenn ein Limit für aktive Popups existiert)
        - `history: Arc<tokio::sync::RwLock<VecDeque<Notification>>>`
        - `dnd_enabled: Arc<tokio::sync::RwLock<bool>>`
        - `rules_engine: Arc<dyn domain::notifications_rules::NotificationRulesEngine>` (Abhängigkeit injiziert)
        - `settings_service: Arc<dyn domain::global_settings_and_state_management::GlobalSettingsService>` (für MAX_HISTORY etc.)
        - `event_publisher: tokio::sync::broadcast::Sender<super::events::NotificationEventEnum>`
        - `max_active_popups: usize` (aus Einstellungen)
        - `max_history_items: usize` (aus Einstellungen)
    - **Konstruktor `new(...)`**: Nimmt Abhängigkeiten, lädt `max_active_popups` und `max_history_items` aus `settings_service`.
    - **Logik `post_notification(input: NotificationInput)`**:
        1. Erstellt `Notification`-Objekt aus `input`, generiert `id`, setzt `timestamp`.
        2. `processed_notification_option = self.rules_engine.process_notification(&mut notification_from_input, &current_global_settings).await?`
        3. Wenn `processed_notification_option` `None` ist (Regel hat unterdrückt) -> `Ok(notification_from_input.id)` (oder spezifischer Rückgabewert/Event).
        4. `let final_notification = processed_notification_option.unwrap();`
        5. Prüfe `dnd_enabled` und `final_notification.urgency`.
        6. Wenn nicht unterdrückt: Füge zu `active_notifications` hinzu. Wenn `max_active_popups` überschritten, ältestes entfernen (und ggf. Event für "Popup abgelaufen" senden). Sendet `NotificationPostedEvent { notification: final_notification.clone(), suppressed_by_dnd: false }`.
        7. Wenn unterdrückt: Sendet `NotificationPostedEvent { notification: final_notification.clone(), suppressed_by_dnd: true }`.
        8. Wenn `!final_notification.transient`: Füge zu `history` hinzu. Wenn `max_history_items` überschritten, ältestes aus `history` entfernen.
        9. `Ok(final_notification.id)`.
    - **Logik `get_active_notifications` / `get_notification_history`**: Implementiert Filterung (rekursiv für And/Or/Not) und Sortierung.
- **Struct `NotificationInput`**: Enthält Felder, die ein Client zum Erstellen einer Benachrichtigung bereitstellt (ohne `id`, `timestamp`, `is_read`, `is_dismissed`).
- **Struct `NotificationStats`**: `num_active: usize`, `num_history: usize`, `num_unread: usize`.
- **Events:** (Wrapper-Enum `NotificationEventEnum`)
    - `NotificationPostedEvent { notification: Notification, suppressed_by_dnd: bool }`
    - `NotificationDismissedEvent { notification_id: Uuid, reason: DismissReason }` (Grund für Dismiss, z.B. User, Timeout, Replaced)
    - `NotificationReadEvent { notification_id: Uuid }`
    - `NotificationActionInvokedEvent { notification_id: Uuid, action_key: String }`
    - `DoNotDisturbModeChangedEvent { dnd_enabled: bool }`
    - `NotificationHistoryClearedEvent`
    - `NotificationPopupExpiredEvent { notification_id: Uuid }` (Wenn aus aktiven Popups entfernt wegen Limit)

**Datei:** `src/user_centric_services/mod.rs`

- Deklariert Submodule `ai_interaction`, `notifications_core`, und ein gemeinsames `events.rs`.
- Re-exportiert öffentliche Traits (`AIInteractionLogicService`, `NotificationService`), Event-Enums und wichtige Typen.

#### 7.3. Implementierungsschritte `domain::user_centric_services`

1. **Grundgerüst:** Verzeichnisse für `ai_interaction` und `notifications_core` sowie gemeinsames `events.rs`.
2. **`ai_interaction` Modul:**
    - `types.rs`: Alle KI-bezogenen Typen und Enums.
    - `errors.rs`: `AIInteractionError`.
    - `persistence_iface.rs`: `AIConsentProvider`, `AIModelProfileProvider` Traits.
    - `persistence.rs` (intern): Implementierungen der Provider-Traits (z.B. `Filesystem...Provider`), die `Arc<dyn novade_core::config::ConfigServiceAsync>` nutzen.
    - `service.rs`: `AIInteractionLogicService`-Trait und `DefaultAIInteractionLogicService`-Implementierung.
    - Unit-Tests für Typen, Fehler, Provider-Implementierungen (Mocking `ConfigServiceAsync`), Service-Logik.
3. **`notifications_core` Modul:**
    - `types.rs`: Alle Benachrichtigungs-bezogenen Typen und Enums. `NotificationInput`.
    - `errors.rs`: `NotificationError`.
    - `service.rs`: `NotificationService`-Trait und `DefaultNotificationService`-Implementierung (nimmt `NotificationRulesEngine`, `GlobalSettingsService` als Abhängigkeiten).
    - Unit-Tests für Typen, Fehler, Service-Logik (insb. DND, History-Limit, Filter/Sort). Mocking von `NotificationRulesEngine` und `GlobalSettingsService`.
4. **`user_centric_services/events.rs`**: Event-Wrapper-Enums (`AIInteractionEventEnum`, `NotificationEventEnum`) definieren.
5. **`user_centric_services/mod.rs`**: Öffentliche API re-exportieren.
6. **Abhängigkeiten in `Cargo.toml`** für `user_centric_services` prüfen (insbesondere `uuid`, `chrono`, `serde`, `thiserror`, `async-trait`, `tokio`).

---

### Modul 8: `domain::notifications_rules`

Zweck: Logik zur dynamischen Verarbeitung von Benachrichtigungen basierend auf konfigurierbaren Regeln. Diese Regeln modifizieren oder unterdrücken Benachrichtigungen, bevor sie dem Benutzer präsentiert oder in der Historie gespeichert werden.

Verantwortlichkeiten: Definition von Regelstrukturen, Laden/Speichern von Regeldefinitionen, Auswerten von Regeln gegen eingehende Benachrichtigungen.

Design-Rationale: Entkopplung der komplexen Regellogik vom Kern-Benachrichtigungsdienst. Ermöglicht es Benutzern oder Administratoren, das Benachrichtigungsverhalten fein granular anzupassen.

**Datei:** `src/notifications_rules/types.rs`

- **Enum `RuleConditionValue`** (neu, für Vergleiche):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum RuleConditionValue {
        String(String),
        Integer(i64),
        Boolean(bool),
        Urgency(NotificationUrgency), // NotificationUrgency aus notifications_core::types
        Regex(String), // Für Regex-Matching
    }
    ```
    
- **Enum `RuleConditionOperator`** (neu):
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum RuleConditionOperator {
        Is, IsNot,
        Contains, NotContains,
        StartsWith, EndsWith,
        MatchesRegex, NotMatchesRegex, // Für String-Werte gegen Regex
        GreaterThan, LessThan, GreaterThanOrEqual, LessThanOrEqual, // Für Integer
    }
    ```
    
- **Struct `RuleConditionField`** (neu, um das Feld der Notification zu spezifizieren):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum RuleConditionField {
        ApplicationName,
        Summary,
        Body,
        Urgency, // Vergleicht mit NotificationUrgency
        Category,
        HintExists(String), // Prüft Existenz eines Hints
        HintValue(String),  // Prüft Wert eines Hints (benötigt Operator und RuleConditionValue)
        // Zukünftig: ApplicationId, etc.
    }
    ```
    
- **Struct `SimpleRuleCondition`** (neu, für atomare Bedingungen):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct SimpleRuleCondition {
        pub field: RuleConditionField,
        pub operator: RuleConditionOperator,
        pub value: RuleConditionValue, // Wert, mit dem verglichen wird
    }
    ```
    
- **Enum `RuleCondition`** (rekursiv):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum RuleCondition {
        Simple(SimpleRuleCondition),
        SettingIsTrue(crate::global_settings_and_state_management::paths::SettingPath), // Pfad zu einer booleschen Einstellung
        And(Vec<RuleCondition>),
        Or(Vec<RuleCondition>),
        Not(Box<RuleCondition>),
    }
    ```
    
- **Enum `RuleAction`**:
    
    Rust
    
    ```
    use novade_core::types::Color as CoreColor; // Für das Setzen von Akzenten
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub enum RuleAction {
        SuppressNotification, // Benachrichtigung komplett unterdrücken
        SetUrgency(NotificationUrgency),
        AddActionToNotification(NotificationAction), // NotificationAction aus notifications_core::types
        SetHint(String /* key */, serde_json::Value /* value */),
        PlaySound(String /* sound_name_or_path */),
        MarkAsPersistent(bool), // Überschreibt transient-Flag der Notification
        SetTimeoutMs(Option<u32>), // Überschreibt Timeout
        SetCategory(String),
        // Neu:
        SetSummary(String), // Kann Template-Variablen enthalten, z.B. "{{original_summary}} - Wichtig!"
        SetBody(String),    // dito
        SetIcon(String),    // Icon-Name oder Pfad
        SetAccentColor(Option<CoreColor>), // Spezifische Akzentfarbe für diese Benachrichtigung
        StopProcessingFurtherRules, // Verhindert, dass nachfolgende Regeln ausgewertet werden
        LogMessage(String), // Loggt eine Nachricht, wenn die Regel zutrifft (für Debugging)
    }
    ```
    
- **Struct `NotificationRule`**:
    
    Rust
    
    ```
    use uuid::Uuid;
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct NotificationRule {
        pub id: Uuid,
        pub name: String, // Menschenlesbarer Name/Beschreibung der Regel
        pub condition: RuleCondition, // Die Bedingung(en)
        pub actions: Vec<RuleAction>, // Aktionen, die ausgeführt werden, wenn Bedingung zutrifft
        pub is_enabled: bool,
        pub priority: i32, // Höhere Zahl = höhere Priorität (wird früher ausgewertet)
        // stop_processing_after_match ist jetzt eine RuleAction::StopProcessingFurtherRules
    }
    impl Default for NotificationRule { /* ... id = new_v4(), is_enabled = true, priority = 0 ... */ }
    ```
    
- **Typalias `NotificationRuleSet`**: `pub type NotificationRuleSet = Vec<NotificationRule>;`

**Datei:** `src/notifications_rules/errors.rs`

- **Enum `NotificationRulesError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use super::types::NotificationRule; // Pfad ggf. anpassen
    
    #[derive(Debug, Error)]
    pub enum NotificationRulesError {
        #[error("Invalid rule definition for rule '{rule_name}' (ID: {rule_id}): {reason}")]
        InvalidRuleDefinition { rule_id: uuid::Uuid, rule_name: String, reason: String },
        #[error("Error evaluating condition for rule '{rule_name}' (ID: {rule_id}): {details}")]
        ConditionEvaluationError { rule_id: uuid::Uuid, rule_name: String, details: String, #[source] source: Option<Box<dyn std::error::Error + Send + Sync + 'static>> },
        #[error("Error applying action for rule '{rule_name}' (ID: {rule_id}): {details}")]
        ActionApplicationError { rule_id: uuid::Uuid, rule_name: String, details: String },
        #[error("Error accessing global settings for rule condition evaluation: {0}")]
        SettingsAccessError(#[from] crate::global_settings_and_state_management::GlobalSettingsError), // Pfad anpassen
        #[error("Error loading or saving notification rules: {0}")]
        RulePersistenceError(#[from] novade_core::errors::CoreError), // Annahme: Provider nutzt CoreError für I/O
        #[error("Invalid regex in rule condition: {0}")]
        InvalidRegex(String),
        #[error("An internal error occurred in notification rules engine: {0}")]
        InternalError(String),
    }
    ```
    

**Datei:** `src/notifications_rules/persistence_iface.rs`

- **Trait `NotificationRulesProvider`**: Wie in vorheriger Antwort.

**Datei:** `src/notifications_rules/persistence.rs` (intern)

- **Struct `FilesystemNotificationRulesProvider`**: Implementiert `NotificationRulesProvider`, nutzt `Arc<dyn novade_core::config::ConfigServiceAsync>` zum Laden/Speichern der `NotificationRuleSet` (z.B. als JSON-Array in `$XDG_CONFIG_HOME/novade/notification_rules.json`).

**Datei:** `src/notifications_rules/engine.rs` (oder `service.rs` / `mod.rs`)

- **Enum `RuleProcessingResult`**:
    
    Rust
    
    ```
    use crate::user_centric_services::notifications_core::types::Notification; // Pfad anpassen
    
    #[derive(Debug, Clone, PartialEq)]
    pub enum RuleProcessingResult {
        Allow(Notification),      // Benachrichtigung (ggf. modifiziert) erlauben
        Suppress { rule_id: uuid::Uuid }, // Benachrichtigung aufgrund dieser Regel unterdrücken
    }
    ```
    
- **Trait `NotificationRulesEngine`**:
    
    Rust
    
    ```
    use async_trait::async_trait;
    use crate::user_centric_services::notifications_core::types::Notification;
    use crate::global_settings_and_state_management::types::GlobalDesktopSettings;
    use super::types::NotificationRuleSet; // Eigene Typen
    use super::errors::NotificationRulesError;
    
    #[async_trait]
    pub trait NotificationRulesEngine: Send + Sync {
        /// Lädt oder aktualisiert die im System verwendeten Regeln.
        async fn reload_rules(&self) -> Result<(), NotificationRulesError>;
    
        /// Verarbeitet eine eingehende Benachrichtigung gegen die geladenen Regeln.
        /// Kann die Benachrichtigung modifizieren oder deren Unterdrückung signalisieren.
        async fn process_notification(
            &self,
            notification: Notification, // Nimmt Ownership, gibt ggf. modifizierte zurück
            // settings_snapshot: &GlobalDesktopSettings, // Benötigt aktuellen Snapshot für SettingIsTrue
        ) -> Result<RuleProcessingResult, NotificationRulesError>;
    
        /// Gibt die aktuell geladenen Regeln zurück (z.B. für UI zur Anzeige/Bearbeitung).
        async fn get_rules(&self) -> Result<NotificationRuleSet, NotificationRulesError>;
    
        /// Speichert einen neuen Satz von Regeln.
        async fn update_rules(&self, new_rules: NotificationRuleSet) -> Result<(), NotificationRulesError>;
    }
    ```
    
- **Implementierung `DefaultNotificationRulesEngine`**:
    - **Felder:**
        - `rules: Arc<tokio::sync::RwLock<NotificationRuleSet>>`
        - `rules_provider: Arc<dyn NotificationRulesProvider>`
        - `settings_service: Arc<dyn crate::global_settings_and_state_management::GlobalSettingsService>`
    - **Konstruktor `new(...)`**: Nimmt Provider, lädt initial Regeln via `reload_rules_internal_locked()`.
    - **`reload_rules()`**: Sperrt `rules`-Lock, ruft `rules_provider.load_rules()`, sortiert nach `priority`, aktualisiert `self.rules`.
    - **`process_notification(...)` Logik:**
        1. Holt Lesesperre für `self.rules`. Holt aktuellen Snapshot der `GlobalDesktopSettings` vom `settings_service`.
        2. Iteriert durch eine Kopie der `enabled_rules` (sortiert nach `priority` DESC).
        3. `let mut current_notification = notification;` (mutable Kopie für mögliche Modifikationen).
        4. Für jede Regel:
            - `match self.evaluate_condition_recursive(&rule.condition, &current_notification, &settings_snapshot).await { ... }`
            - Wenn `Ok(true)` (Bedingung erfüllt):
                - `let stop_after_this = self.apply_actions_internal(&rule.actions, &mut current_notification, &rule).await?;`
                - Wenn eine Aktion `SuppressNotification` war: `return Ok(RuleProcessingResult::Suppress { rule_id: rule.id });`
                - Wenn `stop_after_this` (durch `RuleAction::StopProcessingFurtherRules`): `break;` (aus der Regelschleife).
            - Bei `Err(e)`: Logge Fehler, fahre ggf. mit nächster Regel fort oder gib Fehler zurück.
        5. `Ok(RuleProcessingResult::Allow(current_notification))`.
    - **`evaluate_condition_recursive(...)` Logik:**
        - `Simple(simple_cond)`: Wertet Feld gegen `operator` und `value` aus. Für `HintValue`, `Regex` etc.
        - `SettingIsTrue(setting_path)`: Ruft `settings_service.get_setting(&setting_path)` ab, prüft ob `serde_json::Value::Bool(true)`.
        - `And`, `Or`, `Not`: Rekursive Auswertung.
    - **`apply_actions_internal(...)` Logik:** Modifiziert `current_notification` basierend auf `RuleAction`s. Gibt `bool` zurück, ob Verarbeitung gestoppt werden soll.
    - **`get_rules()`**: Sperrt, klont, gibt `self.rules` zurück.
    - **`update_rules(...)`**: Sperrt, ersetzt `self.rules`, ruft `rules_provider.save_rules()` auf.

**Datei:** `src/notifications_rules/mod.rs`

- Deklariert Submodule. Re-exportiert `NotificationRulesEngine`-Trait, `NotificationRule`, `RuleCondition`, `RuleAction`, `NotificationRulesError`, `RuleProcessingResult` und den `NotificationRulesProvider`-Trait.

#### 7.4. Implementierungsschritte `domain::notifications_rules`

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml`.
2. **`types.rs`**: Alle Regel-Typen (`RuleConditionValue`, `Operator`, `Field`, `SimpleRuleCondition`, `RuleCondition`, `RuleAction`, `NotificationRule`, `NotificationRuleSet`). `serde` und `Default`.
3. **`errors.rs`**: `NotificationRulesError` definieren.
4. **`persistence_iface.rs`**: `NotificationRulesProvider`-Trait definieren.
5. **`persistence.rs`**: `FilesystemNotificationRulesProvider` implementieren (nutzt `ConfigServiceAsync`). Tests mit Mocking.
6. **`engine.rs`**: `RuleProcessingResult` Enum. `NotificationRulesEngine`-Trait. `DefaultNotificationRulesEngine` implementieren:
    - Konstruktor, `RwLock` für `rules`.
    - `reload_rules()`, `process_notification()` (mit rekursiver Bedingungsauswertung und Aktionsanwendung), `get_rules()`, `update_rules()`.
    - Tests für Bedingungsauswertung (alle Operatoren, Feldtypen, logische Verknüpfungen, `SettingIsTrue`). Tests für Aktionsanwendung. Tests für Regelpriorisierung und `StopProcessingFurtherRules`. Mocking von `NotificationRulesProvider` und `GlobalSettingsService`.
7. **`mod.rs`**: Öffentliche API re-exportieren.

---

Diese detaillierten Pläne für die Module 1 bis 8 der Domänenschicht sollten eine sehr solide Grundlage für die Implementierung bieten. Jede Komponente ist klar abgegrenzt, und die Interaktionen sowie Abhängigkeiten sind definiert. Der nächste Schritt wäre, für jedes dieser Module die detaillierten Implementierungsschritte (wie im Beispiel für `core::types` und jetzt für die Domänenmodule gezeigt) und die Unit-Tests vollständig auszuarbeiten.



1. **Die detaillierte Aufteilung der Systemschicht in Hauptmodule und deren Submodule** basierend auf der Gesamtspezifikation () und Ihren Anforderungen festlegen.
2. Für **ein ausgewähltes, kritisches Hauptmodul (z.B. `system::compositor`) und dessen wichtigste Submodule eine vollständige Ultra-Feinspezifikation** mit der geforderten Detailtiefe erstellen, einschließlich Dateistruktur, Datentypen, API-Signaturen, Logikbeschreibungen und Implementierungsschritten.
3. Für die **weiteren Hauptmodule der Systemschicht die Struktur (Submodule) und die Kernverantwortlichkeiten skizzieren** sowie auf die relevanten Abschnitte in der Gesamtspezifikation () verweisen. Eine vollständige Ausarbeitung aller Module würde den Rahmen sprengen, aber die Methodik des detaillierten Moduls dient als Blaupause.

**Autonome Entscheidung zur Sequenzierung und Submodul-Aufteilung der Systemschicht:**

Basierend auf der Gesamtspezifikation () und der Notwendigkeit einer klaren Struktur, unterteile ich die Systemschicht (`novade-system` Crate) wie folgt:

1. **`system::compositor`**: Wayland-Compositor-Logik (Smithay-basiert).
    - `compositor::core`: Zentrale Compositor-Zustände und Handler.
    - `compositor::surface_management`: Verwaltung von `WlSurface`-Daten.
    - `compositor::shm`: SHM-Pufferbehandlung.
    - `compositor::xdg_shell`: XDG-Shell-Protokollintegration (Toplevels, Popups).
    - `compositor::layer_shell`: `wlr-layer-shell`-Integration für Panels, Docks etc.
    - `compositor::decoration`: `xdg-decoration`-Integration (Client/Server-Side Decorations).
    - `compositor::output_management`: `wlr-output-management` und `xdg-output` für Monitor-Konfiguration.
    - `compositor::input_method`: Integration von Eingabemethoden (IME).
    - `compositor::screencopy`: Screenshot- und Screencasting-Protokolle (z.B. `wlr-screencopy`).
    - `compositor::data_device`: Zwischenablage (Copy & Paste) und Drag & Drop.
    - `compositor::xwayland`: Integration und Verwaltung des XWayland-Servers.
    - `compositor::renderer_interface`: Abstrakte Schnittstelle zum Rendering-Backend.
    - `compositor::drm_gbm_renderer` (optional, eine konkrete Renderer-Implementierung).
    - `compositor::winit_renderer` (optional, eine weitere konkrete Renderer-Implementierung für verschachtelten Betrieb).
2. **`system::input`**: Eingabeverarbeitung (libinput-basiert).
    - `input::seat_manager`: Seat-Management, Fokus, Capabilities.
    - `input::libinput_handler`: Integration des Libinput-Backends.
    - `input::keyboard`: Tastaturereignis-Übersetzung, XKB-Management.
    - `input::pointer`: Maus-/Zeigerereignis-Verarbeitung, Cursor.
    - `input::touch`: Touch-Ereignis-Verarbeitung.
    - `input::gestures`: Gestenerkennung (aufbauend auf libinput-Events).
3. **`system::dbus_interfaces`**: Schnittstellen zu System-D-Bus-Diensten.
    - `dbus_interfaces::connection_manager`: Basis für D-Bus-Verbindungen.
    - `dbus_interfaces::network_manager`: Client für NetworkManager.
    - `dbus_interfaces::upower`: Client für UPower.
    - `dbus_interfaces::logind`: Client für systemd-logind.
    - `dbus_interfaces::notifications_server`: Implementierung des `org.freedesktop.Notifications`-Servers (nutzt `domain::user_centric_services::notifications_core`).
    - `dbus_interfaces::secrets_service`: Client für `org.freedesktop.secrets`.
    - `dbus_interfaces::policykit`: Client für PolicyKit.
    - `dbus_interfaces::xdg_desktop_portal_handler`: Backend-Logik für Portale (Interaktion mit Compositor etc.).
4. **`system::audio_management`**: PipeWire-Client-Integration.
    - `audio_management::client`: PipeWire-Core-Interaktion.
    - `audio_management::device_manager`: Verwaltung von Audio-Geräten.
    - `audio_management::stream_manager`: Verwaltung von Anwendungs-Streams.
    - `audio_management::volume_control`: Lautstärkeregelung.
5. **`system::mcp_client`**: Implementierung des Model Context Protocol Clients.
    - `mcp_client::connection`: Verwaltung der MCP-Server-Verbindung.
    - `mcp_client::protocol_handler`: Senden/Empfangen von MCP-Nachrichten.
    - `mcp_client::resource_provider`: Bereitstellung von Systemressourcen für KI-Modelle.
6. **`system::window_mechanics`**: Technische Umsetzung des Fenstermanagements.
    - `window_mechanics::placement`: Anwendung von Platzierungsrichtlinien.
    - `window_mechanics::tiling_engine`: Anwendung von Tiling-Layouts.
    - `window_mechanics::focus_arbitration`: Technische Fokushandhabung.
    - `window_mechanics::decoration_manager`: Koordination von SSD/CSD.
7. **`system::event_bridge`**: Brücke für Systemereignisse zur Domänenschicht und UI-Schicht.
8. **`system::power_management`**: Interaktion mit `wlr-output-power-management` und DPMS.

**Detailausarbeitung für `system::compositor` (Teil 1 - Kern & XDG Shell):**

---

## Ultra-Feinspezifikation und Implementierungsplan: Systemschicht (`novade-system` Crate)

**Allgemeine Entwicklungsrichtlinien für die Systemschicht:**

- **Sprache:** Rust (Edition 2021+).
- **Abhängigkeiten:** `novade-core`, `novade-domain`, `smithay` (spezifische Version, z.B. 0.10 oder neuer), `wayland-server`, `wayland-protocols`, `calloop`, `libinput`, `xkbcommon`, `zbus`, `pipewire-rs`, `mcp_client_rs`, `tracing`, `thiserror`, `uuid`, `serde`, `serde_json`, `parking_lot` (optional für Mutex).
- **Fehlerbehandlung:** Modulspezifische Fehler-Enums mit `thiserror`. Fehler aus `smithay` und anderen Bibliotheken werden gewrappt.
- **Asynchronität:** `calloop` ist die primäre Ereignisschleife für `smithay`. Andere asynchrone Operationen (z.B. `zbus`) müssen ggf. über Adapter integriert werden oder in eigenen Threads laufen und mit `calloop` über Kanäle/Signale kommunizieren. Wo `smithay` oder seine Abhängigkeiten `async/await` erfordern (z.B. einige `zbus`-Interaktionen), wird dies genutzt.
- **Zustandsverwaltung:** Eine zentrale `DesktopState`-Struktur wird die meisten `smithay`-Handler implementieren und die Zustände der Subsysteme halten.
- **Interaktion mit Domänenschicht:** Die Systemschicht ruft Services der Domänenschicht auf, um Geschäftslogik anzuwenden oder Zustände zu aktualisieren/abzufragen. Sie übersetzt Systemereignisse in Domänenereignisse oder -aufrufe.

**Cargo.toml für `novade-system` (Auszug):**

Ini, TOML

```
[dependencies]
novade-core = { path = "../novade-core" }
novade-domain = { path = "../novade-domain" }

smithay = { version = "0.10.0", features = ["renderer_gl", "backend_libinput", "backend_session", "backend_udev", "backend_drm", "backend_winit", "desktop", "xwayland", "use_system_lib"] } # Beispielversion, Features anpassen
wayland-server = "0.30" # Smithay-kompatible Version
wayland-protocols = { version = "0.30", features = ["server", "unstable_protocols"] } # Smithay-kompatible Version
calloop = "0.12"
libinput = "0.9"
xkbcommon = "0.7"
# ... weitere Abhängigkeiten ...
```

---

### Modul 1: `system::compositor`

Zweck: Implementierung des Wayland-Compositors unter Verwendung des Smithay-Toolkits.

Verantwortlichkeiten: Client-Verwaltung, Oberflächen-Lebenszyklus, Pufferbehandlung, Shell-Protokolle, Koordination des Renderings.

#### 1.1. Submodul: `system::compositor::core`

**Zweck:** Zentrale Compositor-Zustände, `DesktopState`-Definition, Basis-Handler-Implementierungen.

**Datei:** `src/compositor/core/errors.rs`

- **Enum `CompositorCoreError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use smithay::wayland::compositor::SurfaceRoleError;
    use wayland_server::{backend::ClientId, protocol::wl_surface::WlSurface};
    
    #[derive(Debug, Error)]
    pub enum CompositorCoreError {
        #[error("Failed to create Wayland global object '{0}'")]
        GlobalCreationFailed(String),
        #[error("Surface role error: {0}")]
        RoleError(#[from] SurfaceRoleError), // From smithay
        #[error("Client data not found for client ID {0:?}")]
        ClientDataMissing(ClientId),
        #[error("SurfaceData not found or of wrong type for WlSurface {0:?}")]
        SurfaceDataMissing(WlSurface),
        #[error("Invalid surface state: {0}")]
        InvalidSurfaceState(String),
        #[error("Renderer backend initialization failed: {0}")]
        RendererInitializationFailed(String),
        #[error("Display or EventLoop creation failed: {0}")]
        DisplayOrLoopCreationFailed(String),
        #[error("Failed to initialize XWayland: {0}")]
        XWaylandInitializationError(String),
        // Weitere spezifische Fehler
    }
    ```
    

**Datei:** `src/compositor/core/state.rs`

- **Struct `ClientCompositorData`** (für `Client::data_map`)
    
    Rust
    
    ```
    use smithay::wayland::compositor::CompositorClientState;
    use smithay::wayland::shell::xdg::XdgShellClientData; // Für XDG-Shell
    // Ggf. weitere Client-spezifische Zustände von Smithay-Modulen
    
    pub struct ClientCompositorData {
        pub compositor_state: CompositorClientState,
        // pub xdg_shell_data: XdgShellClientData, // Wird von XdgShellState::new_client verwaltet
    }
    
    impl ClientCompositorData {
        pub fn new() -> Self {
            Self {
                compositor_state: CompositorClientState::default(),
            }
        }
    }
    ```
    
- **Struct `DesktopState`** (Zentrale Zustandsstruktur)
    
    Rust
    
    ```
    use smithay::{
        backend::renderer::gles2::Gles2Renderer, // Beispiel-Renderer
        desktop::{Space, Window, WindowSurfaceType},
        input::{Seat, SeatState, pointer::CursorImageStatus},
        reexports::{
            calloop::{LoopHandle, Interest, Mode, PostAction},
            wayland_server::{Display, DisplayHandle, Client, backend::{GlobalId, ClientId}},
        },
        utils::{Clock, Logical, Point, Rectangle, Serial, Transform},
        wayland::{
            compositor::{CompositorState, CompositorClientState, CompositorHandler, SurfaceAttributes as WlSurfaceAttributes, add_destruction_hook},
            output::OutputManagerState, // Für wlr-output-management & xdg-output
            shell::{
                xdg::{XdgShellState, XdgShellHandler, XdgToplevelSurfaceData, XdgPopupSurfaceData, SurfaceCachedState, XdgWmBaseClientData},
                kde_decoration::KdeDecorationManagerState, // Beispiel für SSD
            },
            shm::{ShmState, ShmHandler},
            seat::WaylandSeatData, // Für wl_seat UserData
            // ... weitere Smithay-Module ...
            selection::data_device::{DataDeviceState, DataDeviceHandler},
            selection::primary_selection::{PrimarySelectionState, PrimarySelectionHandler},
            input_method::InputMethodManagerState,
            relative_pointer::RelativePointerManagerState,
            pointer_constraints::PointerConstraintsState,
            viewporter::ViewporterState,
            presentation::PresentationState,
            xdg_activation::XdgActivationState,
        },
    };
    use crate::domain::window_management_policy::{WindowManagementPolicyService, WindowPolicyOverrides, TilingMode, WorkspaceWindowLayout}; // Domain Service
    use crate::domain::workspaces::core::types::{WorkspaceId, WindowIdentifier as DomainWindowIdentifier};
    use crate::domain::workspaces::manager::WorkspaceManagerService;
    use std::{collections::HashMap, sync::{Arc, Mutex}}; // Mutex für Domain-Services
    use uuid::Uuid;
    use super::surface_management::{SurfaceData, RenderableElement}; // Eigene Typen
    use super::super::input::keyboard::xkb_config::XkbKeyboardData; // Aus system::input
    
    pub const CLOCK_ID: usize = 0;
    
    pub struct NovaDEWaylandState { /* Für Globals, die nur einmal existieren */
        pub shm_global: GlobalId,
        pub xdg_shell_global: GlobalId,
        pub output_manager_global: GlobalId,
        pub seat_global: GlobalId,
        pub data_device_global: GlobalId,
        // ... weitere GlobalIds ...
        pub xdg_activation_global: GlobalId,
    }
    
    pub struct DesktopState {
        pub display_handle: DisplayHandle,
        pub loop_handle: LoopHandle<'static, Self>, // 'static, wenn DesktopState global ist
        pub clock: Clock<u64>, // Für Timings, Animationen
    
        // Compositor & Core States
        pub compositor_state: CompositorState,
        pub shm_state: ShmState,
        pub presentation_state: PresentationState,
        pub viewporter_state: ViewporterState,
    
    
        // Shells & Window Management
        pub xdg_shell_state: XdgShellState,
        pub xdg_activation_state: XdgActivationState,
        // pub layer_shell_state: LayerShellState, // Für wlr-layer-shell
        // pub kde_decoration_state: KdeDecorationManagerState, // Für KWin SSD
    
        // Workspace & Window Tracking (Compositor-Sicht)
        pub space: Space<Window>, // Smithay's Desktop-Raum für Fensterverwaltung
        pub windows: HashMap<DomainWindowIdentifier, Window>, // Eigene Map für Zugriff via Domain ID
    
        // Input & Seat
        pub seat_state: SeatState<Self>,
        pub seat: Seat<Self>, // Der primäre Seat
        pub seat_name: String,
        pub input_method_manager_state: InputMethodManagerState, // Für IME
        pub relative_pointer_manager_state: RelativePointerManagerState,
        pub pointer_constraints_state: PointerConstraintsState,
        pub keyboard_data_map: HashMap<String /* seat_name oder device_id */, XkbKeyboardData>, // Für XKB
        pub current_cursor_status: Arc<Mutex<CursorImageStatus>>, // Für Cursor-Rendering
    
        // Output Management
        pub output_manager_state: OutputManagerState,
    
        // Data Exchange (Clipboard, DnD)
        pub data_device_state: DataDeviceState,
        // pub primary_selection_state: PrimarySelectionState,
    
        // XWayland
        // pub xwayland: XWayland, // Smithay's XWayland-Struktur
    
        // Domain Service Handles (Arc<Mutex<...>> oder Arc<dyn ...>)
        pub window_policy_service: Arc<dyn WindowManagementPolicyService>,
        pub workspace_manager_service: Arc<dyn WorkspaceManagerService>,
        // ... weitere Domain-Services ...
    
        // Renderer (wird später konkretisiert)
        // pub renderer: Gles2Renderer,
        // pub last_render_time: std::time::Instant,
    
        // Wayland Global IDs (um sie am Leben zu halten)
        pub wayland_globals: Option<NovaDEWaylandState>, // Wird nach Erstellung der Globals gefüllt
    }
    
    impl DesktopState {
        pub fn new(
            loop_handle: LoopHandle<'static, Self>,
            display_handle: DisplayHandle,
            window_policy_service: Arc<dyn WindowManagementPolicyService>,
            workspace_manager_service: Arc<dyn WorkspaceManagerService>,
        ) -> Self {
            let clock = Clock::new(Some(tracing::Span::current())); // tracing integration
            let compositor_state = CompositorState::new::<Self>(&display_handle, Some(tracing::Span::current()));
            let shm_state = ShmState::new::<Self>(&display_handle, vec![], Some(tracing::Span::current())); // Keine zusätzlichen Formate initial
            let presentation_state = PresentationState::new::<Self>(&display_handle, clock.id() as u32);
            let viewporter_state = ViewporterState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
            let xdg_shell_state = XdgShellState::new::<Self>(&display_handle, Some(tracing::Span::current()));
            let xdg_activation_state = XdgActivationState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
            let space = Space::new(Some(tracing::Span::current()));
    
            let mut seat_state = SeatState::new();
            let seat_name = "seat0".to_string();
            let seat = seat_state.new_wl_seat(&display_handle, seat_name.clone(), Some(tracing::Span::current()));
            // Capabilities (Keyboard, Pointer, Touch) werden später beim Input-Backend-Init hinzugefügt
    
            let input_method_manager_state = InputMethodManagerState::new::<Self>(&display_handle);
            let relative_pointer_manager_state = RelativePointerManagerState::new::<Self>(&display_handle);
            let pointer_constraints_state = PointerConstraintsState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
    
            let output_manager_state = OutputManagerState::new_with_xdg_output::<Self>(&display_handle);
            let data_device_state = DataDeviceState::new::<Self>(&display_handle, Some(tracing::Span::current()));
    
            Self {
                display_handle,
                loop_handle,
                clock,
                compositor_state,
                shm_state,
                presentation_state,
                viewporter_state,
                xdg_shell_state,
                xdg_activation_state,
                space,
                windows: HashMap::new(),
                seat_state,
                seat,
                seat_name,
                input_method_manager_state,
                relative_pointer_manager_state,
                pointer_constraints_state,
                keyboard_data_map: HashMap::new(),
                current_cursor_status: Arc::new(Mutex::new(CursorImageStatus::Default)),
                output_manager_state,
                data_device_state,
                window_policy_service,
                workspace_manager_service,
                wayland_globals: None,
            }
        }
    }
    ```
    
    - **Initialisierung der Smithay-States:** Erfolgt im `new()` Konstruktor von `DesktopState`. Die `Logger` Parameter sind in neueren Smithay-Versionen oft durch `Option<tracing::Span>` ersetzt oder implizit.
    - **Domain Service Handles:** Werden als `Arc<dyn TraitName>` gespeichert, um Flexibilität und Testbarkeit zu gewährleisten. Sie werden von außen injiziert.
- **Implementierung `CompositorHandler` für `DesktopState`**:
    - **`compositor_state(&mut self) -> &mut CompositorState`**: Gibt `&mut self.compositor_state` zurück.
    - **`client_compositor_state<'a>(&self, client: &'a Client) -> &'a CompositorClientState`**:
        1. `client.get_data::<ClientCompositorData>().unwrap().compositor_state` (Annahme: `ClientCompositorData` wird beim Client-Connect in `Client::data_map` eingefügt).
    - **`commit(&mut self, surface: &WlSurface)`**:
        1. `tracing::debug!(surface_id = ?surface.id(), "Commit für WlSurface");`
        2. `smithay::wayland::compositor::with_states(surface, |states| { ... })` verwenden, um auf `SurfaceAttributes` und `SurfaceData` zuzugreifen.
        3. `let surface_attributes = states.cached_state.current::<WlSurfaceAttributes>();`
        4. **Puffer-Handling:**
            - Wenn `surface_attributes.buffer.is_some()` und `surface_attributes.buffer_delta != (0,0)` oder ein neuer Puffer angehängt wurde:
                - Die `SurfaceData` für diesen `surface` abrufen (aus `states.data_map`).
                - `surface_data.lock().unwrap().current_buffer = surface_attributes.buffer.clone();`
                - `surface_data.lock().unwrap().buffer_scale = surface_attributes.buffer_scale;`
                - `surface_data.lock().unwrap().buffer_transform = surface_attributes.buffer_transform;`
                - Renderer benachrichtigen, die Textur für diesen Puffer zu aktualisieren/erstellen (Details im Renderer-Modul).
        5. **Schadensverfolgung (Damage Tracking):**
            - `let damage = &surface_attributes.damage;` (Liste von `Rectangle<i32, BufferCoords>`).
            - Die `SurfaceData` mit diesen Schadensregionen aktualisieren: `surface_data.lock().unwrap().damage_buffer_coords.extend(damage.iter().cloned());`
        6. **Rollenbasierte Commit-Logik:**
            - `let role = smithay::wayland::compositor::get_role(surface);`
            - `match role { Some("xdg_toplevel") => { ... }, Some("xdg_popup") => { ... }, ... }`
            - Ruft spezifische Commit-Handler für XDG-Toplevels, Popups, Subsurfaces, Layer-Surfaces etc. auf. Diese könnten in `SurfaceData` als Callbacks/Hooks gespeichert sein oder direkt hier behandelt werden. Für XDG-Shell wird dies oft vom `XdgShellHandler` übernommen. Smithay's `desktop::Space` und `Window` handhaben vieles davon.
        7. **Synchronisierte Subsurfaces:** `if surface.is_sync_subsurface() { ... }` Logik für Parent-Commit ( Schritt 8).
        8. Oberfläche für Neuzeichnung im nächsten Frame markieren (z.B. `self.space.damage_window(&window_für_surface, ...)`).
    - **`new_surface(&mut self, surface: &WlSurface, client_data: &Arc<ClientCompositorData>)`** (Signatur kann variieren, je nachdem wie Client-Daten übergeben werden):
        1. `tracing::info!(surface_id = ?surface.id(), client_id = ?surface.client().unwrap().id(), "Neue WlSurface erstellt");`
        2. Initialisiere `SurfaceData::new(surface.client().unwrap().id())`.
        3. `surface.data_map().insert_if_missing_threadsafe(|| Arc::new(Mutex::new(SurfaceData::new(...))));`
        4. `add_destruction_hook(surface, |data_map| { ... Bereinigung von SurfaceData ... });`
    - **`new_subsurface(&mut self, surface: &WlSurface, parent: &WlSurface, client_data: &Arc<ClientCompositorData>)`**:
        1. `tracing::info!(surface_id = ?surface.id(), parent_id = ?parent.id(), "Neue WlSubsurface erstellt");`
        2. `SurfaceData` von `surface` aktualisieren: `surface_data.lock().unwrap().parent = Some(parent.downgrade());`
        3. `SurfaceData` von `parent` aktualisieren: `parent_surface_data.lock().unwrap().children.push(surface.downgrade());`
    - **`destroyed(&mut self, surface: &WlSurface)`**:
        1. `tracing::info!(surface_id = ?surface.id(), "WlSurface zerstört");`
        2. Smithay kümmert sich um das Entfernen aus der `UserDataMap`.
        3. Sicherstellen, dass alle Referenzen auf diese `WlSurface` in `DesktopState` (z.B. in `space`, `windows`, Fokus-Listen) entfernt werden. Dies geschieht oft über den `destruction_hook` der `SurfaceData`.

#### 1.2. Submodul: `system::compositor::surface_management`

**Zweck:** Definition und Verwaltung von `SurfaceData`.

**Datei:** `src/compositor/surface_management/mod.rs`

- **Enum `RenderableElement`** (kann auch direkt Smithay's `Element` sein oder dieses wrappen)
    
    Rust
    
    ```
    // Beispiel, wird durch Renderer-Schnittstelle konkretisiert
    pub enum RenderableElement {
        WaylandSurface {
            surface: WlSurface, // Oder eine ID/Wrapper, der die Textur hält
            position: Point<i32, Logical>,
            scale: f64,
            transform: Transform, // Bildschirmrotation etc.
            damage_surface_local: Vec<Rectangle<i32, Logical>>, // Schaden relativ zur Oberfläche
            opaque_regions_surface_local: Vec<Rectangle<i32, Logical>>,
        },
        SolidColor { /* ... */ },
        Cursor { /* ... */ },
    }
    ```
    
- **Struct `SurfaceData`**:
    - **Felder:**
        - `pub id: Uuid` (Eigene interne ID)
        - `pub client_id: ClientId`
        - `pub role: Mutex<Option<String>>` (Rolle, z.B. "toplevel", "popup", "cursor", "layer")
        - `pub current_buffer_info: Mutex<Option<AttachedBufferInfo>>` (Infos zum aktuellen Puffer)
        - `pub texture_handle: Mutex<Option<Box<dyn RenderableTexture>>>` (Handle vom Renderer, `RenderableTexture` Trait wird in `renderer_interface` definiert)
        - `pub damage_buffer_coords: Mutex<Vec<Rectangle<i32, smithay::utils::Buffer>>>`
        - `pub damage_surface_coords: Mutex<Vec<Rectangle<i32, Logical>>>` (Transformierter Schaden)
        - `pub opaque_region_surface_local: Mutex<Option<smithay::utils::Region<Logical>>>`
        - `pub input_region_surface_local: Mutex<Option<smithay::utils::Region<Logical>>>`
        - `pub user_data_ext: UserDataMap` (Für anwendungsspezifische Daten, die von anderen Modulen wie XDG-Shell oder Layer-Shell hier abgelegt werden)
        - `pub parent: Mutex<Option<wayland_server::Weak<WlSurface>>>`
        - `pub children: Mutex<Vec<wayland_server::Weak<WlSurface>>>`
        - `pub pre_commit_hooks: Mutex<Vec<Box<dyn FnMut(&mut DesktopState, &WlSurface) + Send + Sync>>>`
        - `pub post_commit_hooks: Mutex<Vec<Box<dyn FnMut(&mut DesktopState, &WlSurface) + Send + Sync>>>`
        - `destruction_callback: Mutex<Option<Box<dyn FnOnce(&mut DesktopState, &WlSurface) + Send + Sync>>>` (Ein dedizierter Callback statt Vec für einmalige Zerstörung)
        - `pub surface_viewporter_state: Mutex<smithay::wayland::viewporter::SurfaceState>`
        - `pub surface_presentation_state: Mutex<smithay::wayland::presentation::SurfaceState>`
        - `pub surface_scale_factor: Mutex<f64>` (Skalierungsfaktor, der auf diese Oberfläche angewendet wird, z.B. vom Output)
    - **Struct `AttachedBufferInfo`**:
        
        Rust
        
        ```
        #[derive(Debug, Clone)]
        pub struct AttachedBufferInfo {
            pub buffer: WlBuffer,
            pub scale: i32, // Smithay's buffer_scale
            pub transform: Transform, // Smithay's buffer_transform
            pub dimensions: Size<i32, smithay::utils::Buffer>, // Größe des Puffers
        }
        ```
        
    - **Methoden für `SurfaceData`**:
        - `pub fn new(client_id: ClientId) -> Self`
        - `pub fn set_role(&self, role: &str) -> Result<(), CompositorCoreError>`
        - `pub fn get_role(&self) -> Option<String>`
        - `pub fn attach_buffer(&self, buffer_info: Option<AttachedBufferInfo>)`
        - `pub fn take_damage_buffer_coords(&self) -> Vec<Rectangle<i32, smithay::utils::Buffer>>`
        - `pub fn add_pre_commit_hook(...)`, `add_post_commit_hook(...)`
        - `pub fn set_destruction_callback(...)`
        - `pub fn get_effective_damage_and_transform(&self, output_transform: Transform) -> (Vec<Rectangle<i32, Logical>>, Transform)` (Berechnet transformierten Schaden)
- **Funktionen:**
    - `pub fn get_surface_data(surface: &WlSurface) -> Option<Arc<SurfaceData>>`: Ruft `Arc<SurfaceData>` aus `surface.data_map()` ab.
    - `pub fn with_surface_data_mut<F, R>(surface: &WlSurface, callback: F) -> Result<R, CompositorCoreError> where F: FnOnce(&mut SurfaceData, &WlSurfaceAttributes) -> R`: Kapselt Locken und Zugriff. `WlSurfaceAttributes` wird über `with_states` geholt.

#### 1.3. Submodul: `system::compositor::shm`

**Zweck:** SHM-Pufferbehandlung (`wl_shm`).

**Datei:** `src/compositor/shm/errors.rs`

- **Enum `ShmError`**: ()
    - `PoolCreationFailed(String)`
    - `BufferCreationFailed(String)`
    - `InvalidFormat(wl_shm::Format)`
    - `AccessError(#[from] smithay::wayland::shm::BufferAccessError)`

**Datei:** `src/compositor/shm/mod.rs` (oder `state.rs`)

- **Implementierung `ShmHandler` für `DesktopState`**:
    - `shm_state(&self) -> &ShmState`: Gibt `&self.shm_state` zurück.
- **Implementierung `BufferHandler` für `DesktopState`** (Hier spezifisch für SHM-Puffer, obwohl der Trait generisch ist):
    - `buffer_destroyed(&mut self, buffer: &wl_buffer::WlBuffer)`:
        1. `tracing::debug!(buffer_id = ?buffer.id(), "SHM WlBuffer zerstört");`
        2. Finde alle `SurfaceData`-Instanzen, die diesen `buffer` in `current_buffer_info` verwenden.
        3. Für jede gefundene Instanz:
            - Entferne die Referenz auf den Puffer.
            - Benachrichtige den Renderer, die zugehörige Textur freizugeben (`surface_data.texture_handle.take()`).
            - Markiere die Oberfläche als beschädigt, da ihr Inhalt nun ungültig ist.
- **Implementierung `GlobalDispatch<WlShm, ()>` für `DesktopState`**: ()
    - `bind(...)`: `data_init.init(resource, ());` (Smithay's `ShmState` kümmert sich um das Senden von Formaten).
- **Funktion `pub fn create_shm_global(state: &mut DesktopState, display_handle: &DisplayHandle)`**: ()
    1. `let shm_global_id = state.shm_state.global().clone();` (Da `shm_state` bereits in `DesktopState::new` initialisiert wurde).
    2. Speichere `shm_global_id` in `state.wayland_globals.as_mut().unwrap().shm_global`.
    3. `tracing::info!("wl_shm Global für Clients verfügbar gemacht. Unterstützte Formate: ARGB8888, XRGB8888.");`

**Datei:** `src/compositor/shm/buffer_access.rs`

- **Funktion `pub fn with_shm_buffer_contents<F, T>(buffer: &wl_buffer::WlBuffer, callback: F) -> Result<T, ShmError> where F: FnOnce(*const u8, usize, &smithay::wayland::shm::BufferData) -> T`**:
    1. `smithay::wayland::shm::with_buffer_contents(buffer, callback).map_err(ShmError::from)`

#### 1.4. Submodul: `system::compositor::xdg_shell`

**Zweck:** XDG-Shell-Protokollintegration (`xdg_wm_base`, `xdg_surface`, `xdg_toplevel`, `xdg_popup`).

**Datei:** `src/compositor/xdg_shell/errors.rs`

- **Enum `XdgShellError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use smithay::{utils::Serial, wayland::shell::xdg::ToplevelConfigureError};
    use wayland_server::protocol::wl_surface::WlSurface;
    use uuid::Uuid; // Für interne Window-IDs
    use crate::compositor::core::errors::CompositorCoreError;
    
    #[derive(Debug, Error)]
    pub enum XdgShellError {
        #[error("Surface {0:?} already has a different XDG role or is uninitialized.")]
        InvalidSurfaceRole(WlSurface),
        #[error("Window handling error for window ID {0}: {1}")]
        WindowHandlingError(Uuid, String), // Uuid ist die interne ID des ManagedWindow
        #[error("Popup positioning failed: {0}")]
        PopupPositioningError(String),
        #[error("Client provided invalid serial {client_serial:?} for configure, expected around {expected_serial:?}.")]
        InvalidAckConfigureSerial { client_serial: Serial, expected_serial: Serial },
        #[error("ManagedToplevel with ID {0} not found.")]
        ToplevelNotFound(Uuid),
        #[error("ManagedPopup with ID {0} not found.")]
        PopupNotFound(Uuid),
        #[error("XDG Toplevel configure operation failed: {0}")]
        ToplevelConfigureFailed(#[from] ToplevelConfigureError),
        #[error("Core compositor error during XDG operation: {0}")]
        CoreError(#[from] CompositorCoreError),
        #[error("XDG WM Base client data not found.")]
        XdgWmBaseClientDataMissing,
    }
    ```
    

**Datei:** `src/compositor/xdg_shell/types.rs`

- **Struct `ManagedWindow`** (ersetzt `ManagedToplevel` und `ManagedPopup` für Smithay's `Space<Window>`)
    
    Rust
    
    ```
    use smithay::{
        desktop::{Window, WindowSurface, WindowSurfaceType, Space},
        output::Output,
        reexports::wayland_protocols::xdg::shell::server::xdg_toplevel,
        utils::{Logical, Point, Rectangle, Size},
        wayland::shell::xdg::{ToplevelSurface, PopupSurface, PositionerState, XdgPopupSurfaceData, XdgToplevelSurfaceData},
    };
    use wayland_server::protocol::wl_surface::WlSurface;
    use wayland_server::Weak;
    use uuid::Uuid;
    use crate::domain::workspaces::core::types::WindowIdentifier as DomainWindowIdentifier; // Domain-ID
    use crate::compositor::surface_management::SurfaceData; // Zugriff auf SurfaceData
    use std::sync::{Arc, Mutex};
    
    #[derive(Debug, Clone, PartialEq)] // PartialEq ggf. manuell oder nur auf ID
    pub struct ManagedWindow {
        pub id: Uuid, // Interne Compositor-ID
        pub domain_id: DomainWindowIdentifier, // Verknüpfung zur Domänenschicht
        pub xdg_surface: WindowSurface, // Smithay's WindowSurface (Toplevel oder Popup)
        // app_id und title werden über xdg_surface.get_app_id() / .get_title() geholt
        pub current_geometry: Rectangle<i32, Logical>, // Berechnete Geometrie
        pub requested_size: Option<Size<i32, Logical>>,
        pub min_size: Option<Size<i32, Logical>>,
        pub max_size: Option<Size<i32, Logical>>,
        pub parent_id: Option<Uuid>, // Für transiente Toplevels oder Popups
        pub is_mapped: bool,
        // Weitere Zustände wie maximized, fullscreen, activated werden über xdg_surface.toplevel()
        // und dessen Methoden (e.g. current_states()) oder XdgToplevelSurfaceData verwaltet.
    }
    
    impl ManagedWindow {
        pub fn new_toplevel(toplevel_surface: ToplevelSurface, domain_id: DomainWindowIdentifier) -> Self {
            // Initialgeometrie etc. wird später vom Layout-Manager gesetzt
            Self {
                id: Uuid::new_v4(),
                domain_id,
                xdg_surface: WindowSurface::Toplevel(toplevel_surface),
                current_geometry: Rectangle::from_loc_and_size((0,0), (0,0)),
                requested_size: None, min_size: None, max_size: None,
                parent_id: None, // TODO: Parent-Logik für transiente Toplevel
                is_mapped: false,
            }
        }
    
        pub fn new_popup(popup_surface: PopupSurface, parent_domain_id: DomainWindowIdentifier) -> Self {
             // Popups haben eine komplexere Geometrieberechnung
            Self {
                id: Uuid::new_v4(),
                domain_id: DomainWindowIdentifier::new(format!("popup-{}", Uuid::new_v4())).unwrap(), // Eigene ID für Popups
                xdg_surface: WindowSurface::Popup(popup_surface),
                current_geometry: Rectangle::from_loc_and_size((0,0), (0,0)), // Wird durch Positioner bestimmt
                requested_size: None, min_size: None, max_size: None,
                parent_id: Some(Uuid::default()), // TODO: parent_id korrekt setzen auf Uuid des Parent ManagedWindow
                is_mapped: false,
            }
        }
    
        pub fn wl_surface(&self) -> &WlSurface {
            self.xdg_surface.wl_surface()
        }
        // ... weitere Hilfsmethoden ...
    }
    
    // Implementierung von smithay::desktop::Window für ManagedWindow
    impl Window for ManagedWindow {
        fn id(&self) -> usize {
            // Smithay's Space benötigt usize. Wir können die Bytes unserer Uuid nehmen.
            // Dies muss stabil sein für die Lebenszeit des Fensters.
            let mut hasher = std::collections::hash_map::DefaultHasher::new();
            self.id.hash(&mut hasher);
            std::hash::Hasher::finish(&hasher) as usize
        }
        fn wl_surface(&self) -> Option<WlSurface> { Some(self.xdg_surface.wl_surface().clone()) }
        fn surface_type(&self) -> WindowSurfaceType { self.xdg_surface.surface_type() }
        fn geometry(&self) -> Rectangle<i32, Logical> { self.current_geometry }
        fn is_mapped(&self) -> bool { self.is_mapped && self.xdg_surface.alive() } // Und ob die Wayland-Oberfläche noch existiert
        fn is_suspended(&self) -> bool {
            // Abfragen von XdgToplevelSurfaceData, ob minimiert etc.
            if let WindowSurface::Toplevel(t) = &self.xdg_surface {
                let data = t.user_data().get::<XdgToplevelSurfaceData>().unwrap();
                return data.minimized || data.suspended;
            }
            false
        }
        // ... weitere Methoden des Window-Traits implementieren (send_configure, set_activated etc.)
        // Diese rufen oft Methoden auf self.xdg_surface.toplevel() oder .popup() auf.
        fn send_frame(&self, output: &Output, time: impl Into<Duration>, throttle: Option<Duration>, primary_scan_out_output: Option<&Output>) {
            // Für Frame-Callbacks des Presentation-Time Protokolls
            if let Some(wl_surface) = self.wl_surface() {
                 smithay::wayland::presentation::send_frames_surface_dest harming_region_transform,
                    &wl_surface,
                    output,
                    time,
                    throttle,
                    primary_scan_out_output,
                );
            }
        }
        // ...
    }
    ```
    
    - **Verwendung von `smithay::desktop::Window` Trait**: Die `ManagedWindow`-Struktur implementiert diesen Trait, um mit `smithay::desktop::Space` kompatibel zu sein. Dies vereinfacht die Fensterverwaltung, das Stapeln und die Schadensberechnung für den Renderer erheblich.

**Datei:** `src/compositor/xdg_shell/handlers.rs`

- **Implementierung `XdgShellHandler` für `DesktopState`**:
    - **`xdg_shell_state(&mut self) -> &mut XdgShellState`**: Gibt `&mut self.xdg_shell_state` zurück.
    - **`new_toplevel(&mut self, surface: ToplevelSurface)`**:
        1. `tracing::info!(surface = ?surface.wl_surface().id(), "Neues XDG Toplevel wird erstellt.");`
        2. `let domain_window_id = DomainWindowIdentifier::new(format!("xdg-toplevel-{}", Uuid::new_v4())).unwrap();`
        3. `let mut managed_window = ManagedWindow::new_toplevel(surface.clone(), domain_window_id.clone());`
        4. **Initialgeometrie von Domäne anfordern:**
            - `let window_layout_info = WindowLayoutInfo { id: domain_window_id.clone(), requested_min_size: None, ... };`
            - `let initial_geom_result = block_on(self.window_policy_service.get_initial_window_geometry(&window_layout_info, ...));` (Blockieren hier ist problematisch in `calloop`. Besser: `get_initial_window_geometry` synchron machen oder die Fenstererstellung in eine Task-Pipeline verschieben.)
            - Wenn `Ok(geom)`, setze `managed_window.current_geometry = geom;`. Sonst Standardgeometrie.
        5. Füge `XdgToplevelSurfaceData` zur UserDataMap des `surface.wl_surface()` hinzu (Smithay macht das oft schon).
        6. `surface.with_pending_state(|state| { state.size = Some(managed_window.current_geometry.size); });`
        7. `surface.send_configure();` (Sendet initiale Größe etc. an Client).
        8. Füge `managed_window` zu `self.space` hinzu: `let window_arc = Arc::new(managed_window); self.space.map_window(window_arc.clone(), (initial_x, initial_y), true);` (Aktivieren, falls es Fokus bekommen soll).
        9. `self.windows.insert(domain_window_id, window_arc);`
    - **`new_popup(&mut self, surface: PopupSurface, _client_data: &XdgWmBaseClientData)`**:
        1. `tracing::info!(surface = ?surface.wl_surface().id(), "Neues XDG Popup wird erstellt.");`
        2. `let parent_wl_surface = surface.get_parent_surface().ok_or_else(|| XdgShellError::PopupPositioningError("Popup hat keine Elternoberfläche".into()))?;`
        3. Finde `parent_managed_window` über `parent_wl_surface` in `self.space` oder `self.windows`.
        4. `let managed_popup = ManagedWindow::new_popup(surface.clone(), parent_managed_window.domain_id.clone());`
        5. Füge `XdgPopupSurfaceData` zum `surface.wl_surface().data_map()` hinzu (Smithay macht das oft).
        6. Berechne Popup-Geometrie: `let positioner = surface.get_positioner(); let popup_geom = calculate_popup_geometry(&positioner, parent_managed_window.geometry());`
        7. `managed_popup.current_geometry = popup_geom;`
        8. `surface.send_configure();`
        9. Füge Popup zu `self.space` hinzu (Smithay's Space kann auch Popups verwalten, oder sie werden relativ zum Parent gerendert).
        10. `self.windows.insert(managed_popup.domain_id.clone(), Arc::new(managed_popup));`
    - **`map_toplevel(&mut self, surface: &ToplevelSurface)`**:
        1. Finde `ManagedWindow` für `surface.wl_surface()`.
        2. `managed_window.is_mapped = true;`
        3. Benachrichtige Domänenschicht (z.B. `workspace_manager_service.assign_window_to_active_workspace(&managed_window.domain_id)`).
        4. Fordere ein Re-Layout für den Workspace an.
        5. `self.space.damage_all_outputs();` (Oder spezifischer Schaden).
    - **`unmap_toplevel(&mut self, surface: &ToplevelSurface)`**:
        1. Finde `ManagedWindow`. `managed_window.is_mapped = false;`
        2. Entferne Fenster aus Workspace (`workspace_manager_service.remove_window_from_its_workspace`).
        3. `self.space.unmap_window(&managed_window_arc);`
    - **`ack_configure(&mut self, surface: WlSurface, configure_data: XdgSurfaceConfigureUserData)`**:
        1. `tracing::debug!(surface = ?surface.id(), serial = ?configure_data.serial, "XDG Surface ack_configure empfangen.");`
        2. Finde `ManagedWindow`.
        3. Logik für `ack_configure` gemäß Smithay-Dokumentation (Serial-Vergleich, Zustandsanwendung).
        4. `if let SurfaceCachedState::Toplevel(toplevel_data) = configure_data.cached_state { ... }`
    - **Andere `XdgShellHandler`-Methoden (`*_request_*`):**
        - Finde das `ManagedWindow`.
        - Aktualisiere den Zustand im `ManagedWindow` und/oder dessen `XdgToplevelSurfaceData` (z.B. `title`, `app_id`, `maximized`, `fullscreen`).
        - Interagiere mit `self.window_policy_service` für Größen-/Zustandsänderungen.
        - Rufe `toplevel_surface.send_configure()` auf, um den Client über den neuen Zustand zu informieren.
        - Für `move` und `resize`: Starte einen interaktiven Grab über `self.seat.start_pointer_grab(...)` oder `self.seat.start_touch_grab(...)`.
    - **`toplevel_destroyed(&mut self, toplevel: ToplevelSurface)`**:
        1. Finde `ManagedWindow`.
        2. `self.space.unmap_window(&managed_window_arc);`
        3. `self.windows.remove(&managed_window.domain_id);`
        4. Benachrichtige Domäne.
    - **`popup_destroyed(&mut self, popup: PopupSurface)`**: Analog.

**Datei:** `src/compositor/xdg_shell/mod.rs` (oder `state.rs`)

- **Implementierung `GlobalDispatch<XdgWmBase, ()>` für `DesktopState`**: ()
    - `bind(...)`:
        1. `let client_data = client.get_data::<Arc<Mutex<XdgWmBaseClientData>>>().cloned();` (oder `state.xdg_shell_state.new_client(client)` und speichern).
        2. `data_init.init(resource, client_data.expect("XdgWmBase client data must be set").clone());`
- **Funktion `pub fn create_xdg_shell_global(state: &mut DesktopState, display_handle: &DisplayHandle)`**: ()
    1. `let xdg_shell_global_id = state.xdg_shell_state.global().clone();`
    2. Speichere in `state.wayland_globals`.
    3. `tracing::info!("xdg_wm_base Global v{} für Clients verfügbar gemacht.", XdgWmBase::VERSION);`

#### 1.5. Implementierungsschritte `system::compositor` (Teil 1)

1. **Grundgerüst**: Verzeichnisse anlegen, `Cargo.toml` für Smithay etc. anpassen.
2. **`core/errors.rs`**: `CompositorCoreError` definieren.
3. **`surface_management/mod.rs`**: `SurfaceData`, `AttachedBufferInfo` definieren. `get_surface_data`, `with_surface_data_mut` implementieren.
4. **`core/state.rs`**: `ClientCompositorData`. `DesktopState` Grundstruktur mit `compositor_state`, `display_handle`, `loop_handle`, `clock`, `space`, `windows`, `seat_state`, `seat`, Domain-Service-Handles. `new()`-Konstruktor.
5. **`core/state.rs`**: `CompositorHandler` für `DesktopState` implementieren (`compositor_state`, `client_compositor_state`, `commit`, `new_surface`, `new_subsurface`, `destroyed`).
6. **`shm/errors.rs`**: `ShmError`.
7. **`shm/mod.rs`**: `ShmHandler` und `BufferHandler` (SHM-Teil) für `DesktopState`. `GlobalDispatch<WlShm, ()>`. `create_shm_global`.
8. **`shm/buffer_access.rs`**: `with_shm_buffer_contents`.
9. **`xdg_shell/errors.rs`**: `XdgShellError`.
10. **`xdg_shell/types.rs`**: `ManagedWindow` (implementiert `smithay::desktop::Window`), `XdgToplevelSurfaceData`, `XdgPopupSurfaceData` (Smithay-Typen, die via `UserDataMap` an `WlSurface` gehängt werden).
11. **`xdg_shell/handlers.rs`**: `XdgShellHandler` für `DesktopState` implementieren (alle Methoden, Interaktion mit `ManagedWindow`, `Space`, `window_policy_service`).
12. **`xdg_shell/mod.rs`**: `GlobalDispatch<XdgWmBase, ()>`. `create_xdg_shell_global`.
13. **`src/compositor/mod.rs`**: Öffentliche API des Compositor-Moduls definieren (z.B. Initialisierungsfunktionen, Zugriff auf `DesktopState` falls nötig).
14. **Unit-Tests (sehr anspruchsvoll für Compositor-Logik, Fokus auf Handler-Teillogik):**
    - Testen der Zustandsübergänge von `ManagedWindow`.
    - Testen der `SurfaceData`-Manipulation.
    - Mocking von Domain-Services, um Interaktionen mit `window_policy_service` etc. zu testen.
    - Smithay bietet Test-Utilities (`smithay::test_render`, Test-Clients), die evaluiert werden sollten.

---

**Nächste Schritte für `system::compositor` (Skizze für weitere Teile):**

- **`layer_shell`**: Implementierung von `WlrLayerShellHandler` etc. für Panels, Docks.
- **`decoration`**: `KdeDecorationManagerHandler` oder `XdgDecorationHandler`.
- **`output_management`**: `OutputManagerState`-Nutzung, `WlrOutputManagementHandlerV1`.
- **`input_method`**: `InputMethodManagerHandler`.
- **`screencopy`**, `data_device`, `xwayland` etc. analog.
- **`renderer_interface`**: Definition der Traits `FrameRenderer`, `RenderableTexture`.
- **Konkrete Renderer**: Implementierung für DRM/GBM und/oder Winit.

Diese detaillierte Ausarbeitung für den Kern des Compositors und XDG-Shell legt den Grundstein. Die weiteren Module der Systemschicht (`system::input`, `system::dbus_interfaces` etc.) würden mit ähnlicher Tiefe und Struktur spezifiziert werden, wobei jeweils die spezifischen Smithay-Komponenten, Systembibliotheken und Domäneninteraktionen im Fokus stehen.

---

### Modul 2: `system::input`

Zweck: Umfassende Verarbeitung von Benutzereingaben von diversen Geräten (Tastatur, Maus, Touchpad, Touchscreen, Tablets). Dies beinhaltet die Initialisierung und Verwaltung von Eingabegeräten mittels libinput, die Übersetzung roher Eingabeereignisse in für den Compositor und Wayland-Clients verständliche Formate, sowie die Handhabung des Seat-Managements, des Eingabefokus und der Cursor-Darstellung.

Verantwortlichkeiten: Integration mit libinput, Seat-Erstellung und -Verwaltung, Capability-Management (Tastatur, Zeiger, Touch), Fokuslogik, Übersetzung von Keycodes zu Keysyms/UTF-8 mittels xkbcommon, Verarbeitung von Zeigerbewegungen, Klicks, Scroll-Events, Touch-Interaktionen und Basis-Gesten.

Design-Rationale: Kapselung der komplexen Eingabelogik. libinput als Standard für die Geräteabstraktion unter Linux. Enge Verzahnung mit smithay's Seat-Management und Event-Strukturen. Die Logik muss performant und präzise sein, um eine direkte und reaktionsschnelle Benutzerinteraktion zu gewährleisten.

Bestehende Spezifikation: (ausführliche Basis aus Systemschicht Teil 1/4 der Recherche)

#### 2.1. Submodul: `system::input::errors`

**Datei:** `src/input/errors.rs`

- **Enum `InputError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use smithay::input::{SeatError, keyboard::KeyboardError};
    use std::io;
    
    #[derive(Debug, Error)]
    pub enum InputError {
        #[error("Failed to create or configure a seat: {0}")]
        SeatCreationFailed(String), // Generischer Fehler für Seat-Erstellung
        #[error("Failed to add capability '{capability}' to seat '{seat_name}': {source}")]
        CapabilityAdditionFailed {
            seat_name: String,
            capability: String,
            #[source]
            source: Box<dyn std::error::Error + Send + Sync + 'static>, // Kann SeatError oder KeyboardError sein
        },
        #[error("XKB configuration error for seat '{seat_name}': {message}")]
        XkbConfigError { seat_name: String, message: String },
        #[error("Libinput backend initialization or processing error: {0}")]
        LibinputError(String), // Für Fehler direkt von libinput oder dem Smithay-Backend
        #[error("Libinput session error: {0}")] // Für Fehler von der LibinputInterface (open_restricted/close_restricted)
        LibinputSessionError(#[from] io::Error),
        #[error("Seat '{0}' not found.")]
        SeatNotFound(String),
        #[error("Keyboard handle not found for seat '{0}'.")]
        KeyboardHandleNotFound(String),
        #[error("Pointer handle not found for seat '{0}'.")]
        PointerHandleNotFound(String),
        #[error("Touch handle not found for seat '{0}'.")]
        TouchHandleNotFound(String),
        #[error("Failed to initialize input event source in event loop: {0}")]
        EventSourceSetupError(String),
        #[error("Internal error in input system: {0}")]
        InternalError(String),
    }
    ```
    
    - **Begründung:** Diese Fehlerstruktur deckt die in genannten Fehler ab und erweitert sie um spezifischere Fälle für `libinput` und die Ereignisschleifenintegration. Das `CapabilityAdditionFailed` fasst Fehler von `seat.add_keyboard/pointer/touch` generisch zusammen.

#### 2.2. Submodul: `system::input::seat_manager`

**Zweck:** Definiert und verwaltet `SeatState` und `SeatHandler` für Eingabefokus und Capabilities.

**Datei:** `src/input/seat_manager/mod.rs` (oder `state.rs` und `handler.rs`)

- **Struktur `DesktopState` (Erweiterung für Input-Aspekte)**:
    
    Rust
    
    ```
    // In src/compositor/core/state.rs (oder wo DesktopState definiert ist)
    // ... existing fields ...
    // pub seat_state: SeatState<Self>, // Bereits vorhanden
    // pub seat: Seat<Self>,           // Bereits vorhanden
    // pub seat_name: String,          // Bereits vorhanden
    // pub keyboard_data_map: HashMap<String /* seat_name */, XkbKeyboardData>, // Bereits vorhanden
    // pub current_cursor_status: Arc<Mutex<CursorImageStatus>>, // Bereits vorhanden
    
    // Neu oder verfeinert für Fokusmanagement:
    pub pointer_location: Point<f64, Logical>, // Aktuelle globale Zeigerposition
    pub last_active_window_per_workspace: HashMap<WorkspaceId, Weak<ManagedWindow>>, // Für Fokuswiederherstellung
    pub active_input_surface: Option<Weak<WlSurface>>, // Die Oberfläche, die aktuell den logischen Input-Fokus hat (Tastatur, Zeiger, Touch)
                                                       // Dies kann komplexer sein, wenn Zeiger- und Tastaturfokus getrennt sind.
                                                       // Smithay's Seat/KeyboardHandle/PointerHandle verwalten den Fokus auf Protokollebene.
                                                       // Dieses Feld könnte den "logischen" Anwendungsfokus speichern.
    ```
    
- **Implementierung `SeatHandler` für `DesktopState`**: ()
    
    - **`type KeyboardFocus = WlSurface;`**
    - **`type PointerFocus = WlSurface;`**
    - **`type TouchFocus = WlSurface;`**
    - **`fn seat_state(&mut self) -> &mut SeatState<Self>`**: Gibt `&mut self.seat_state` zurück.
    - **`fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&Self::KeyboardFocus>)`**:
        1. `tracing::debug!(seat_name = %seat.name(), old_focus = ?self.active_input_surface.as_ref().and_then(|w| w.upgrade()).map(|s| s.id()), new_focus = ?focused.map(|s| s.id()), "SeatHandler::focus_changed (keyboard) called");`
        2. **Wichtig**: Diese Methode wird von `KeyboardHandle::set_focus` aufgerufen. Sie sollte primär dazu dienen, _interne Compositor-Zustände_ zu aktualisieren, die von der Fokusänderung abhängen, nicht umgekehrt den Fokus erneut zu setzen.
        3. Die `KeyboardHandle` sendet bereits `wl_keyboard.enter/leave`.
        4. Aktualisiere `self.active_input_surface` (oder eine spezifischere Variable für Tastaturfokus).
        5. Benachrichtige die Domänenschicht (`workspace_manager_service` oder einen dedizierten `FocusManagerService` in der Domäne) über die Fokusänderung, damit diese z.B. Fenstertitel in der UI aktualisieren oder Policy-Entscheidungen treffen kann.
            
            Rust
            
            ```
            // Beispiel:
            // let domain_window_id = find_domain_window_id_for_surface(focused);
            // block_on(self.workspace_manager_service.notify_focus_changed(domain_window_id));
            ```
            
    - **`fn cursor_image(&mut self, seat: &Seat<Self>, image: CursorImageStatus)`**:
        1. `tracing::trace!(seat_name = %seat.name(), status = ?image, "Cursor-Image-Anfrage erhalten");`
        2. `let mut current_status_guard = self.current_cursor_status.lock().unwrap();`
        3. `*current_status_guard = image;`
        4. Renderer muss benachrichtigt werden, den Cursor neu zu zeichnen. Dies kann über ein Flag geschehen oder indem der Renderer den `current_cursor_status` direkt abfragt. Der Renderer braucht auch die `pointer_location`.
            - Wenn `image == CursorImageStatus::Hidden`, setzt der Renderer den Cursor unsichtbar.
            - Wenn `image == CursorImageStatus::Surface(surface)`, muss der Renderer den Puffer dieser `surface` als Cursor verwenden (Hotspot-Informationen sind in `SurfaceData` oder als Teil von `SurfaceAttributes`).
            - Wenn `image == CursorImageStatus::Named(name)`, muss eine Cursor-Theming-Logik den Namen in eine Textur auflösen (z.B. über `libwayland-cursor` oder eine eigene Implementierung, die XCursor-Themes parst). Diese Logik gehört ggf. in ein Hilfsmodul.
- **Funktion `pub fn create_seat(state: &mut DesktopState, display_handle: &DisplayHandle, seat_name: String) -> Result<Seat<DesktopState>, InputError>`**:
    
    1. `tracing::info!("Erstelle neuen Seat: {}", seat_name);`
    2. `let seat = state.seat_state.new_wl_seat(display_handle, seat_name.clone(), Some(tracing::Span::current()));`
    3. `seat.user_data().insert_if_missing(WaylandSeatData::default);` // Standard-UserData für wl_seat
    4. **Capabilities initialisieren (aber noch nicht setzen, wenn Geräte noch nicht bekannt):**
        - `state.keyboard_data_map.insert(seat_name.clone(), XkbKeyboardData::new(&Default::default())?);` (Mit Default-XKB-Config, wird später aktualisiert).
    5. `tracing::info!("Seat '{}' erfolgreich erstellt. Capabilities werden beim Hinzufügen von Geräten gesetzt.", seat_name);`
    6. Speichere `seat.clone()` in `state.seat` (falls dies der primäre Seat ist) und `state.active_seat_name`.
    7. `Ok(seat)`

#### 2.3. Submodul: `system::input::libinput_handler`

**Zweck:** Initialisiert und konfiguriert das `LibinputInputBackend` und leitet dessen Events an spezifische Handler weiter.

**Datei:** `src/input/libinput_handler/session_interface.rs`

- **Struct `LibinputSessionManager`**:
    
    Rust
    
    ```
    use smithay::backend::session::{Session, Signal as SessionSignal, SessionNotifier};
    use std::rc::Rc; // Oder Arc, wenn thread-übergreifend benötigt
    use calloop::LoopHandle;
    use super::super::core::state::DesktopState; // Pfad anpassen
    
    // Diese Struktur wird die Logik für das Öffnen/Schließen von Geräten kapseln,
    // basierend auf dem gewählten Session-Typ (logind, direct).
    // Für diese Spezifikation ist sie ein Platzhalter.
    pub struct LibinputSessionManager {
        // notifier: SessionNotifier, // Von Smithay's Session
        // session: Rc<dyn Session>, // Oder eine konkrete Session-Implementierung
    }
    
    impl LibinputSessionManager {
        // pub fn new(session: Rc<dyn Session>, loop_handle: LoopHandle<'static, DesktopState>) -> Self {
        //     let notifier = session.notifier(loop_handle).expect("Failed to create session notifier");
        //     Self { session, notifier }
        // }
    }
    
    // Implementiert smithay::backend::input::LibinputInterface
    impl smithay::backend::input::LibinputInterface for LibinputSessionManager {
        fn open_restricted(&mut self, path: &std::path::Path, flags: i32) -> Result<std::os::unix::io::RawFd, std::io::Error> {
            // self.session.open(path, flags)
            // Platzhalter:
            Err(std::io::Error::new(std::io::ErrorKind::Unsupported, "Session Management nicht implementiert"))
        }
        fn close_restricted(&mut self, fd: std::os::unix::io::RawFd) {
            // self.session.close(fd);
            // Platzhalter:
            let _ = fd;
        }
    }
    ```
    
    - **Wichtig:** Die konkrete Implementierung hängt stark vom gewählten `Session`-Typ ab (`smithay::backend::session::direct::DirectSession` für Start ohne `logind`, `smithay::backend::session::logind::LogindSession` für `logind`-Integration). Die `Session` selbst muss korrekt initialisiert und in die `calloop`-Schleife integriert werden (Behandlung von `SessionSignal`). Dies ist ein komplexes Thema für sich und wird hier nur angerissen. Für eine minimale Lauffähigkeit kann eine Dummy-Implementierung verwendet werden, die immer Fehler zurückgibt oder `/dev/input/*` direkt öffnet (was Root-Rechte erfordert).

**Datei:** `src/input/libinput_handler/mod.rs` (oder `backend_init.rs` und `event_dispatcher.rs`)

- **Funktion `pub fn init_libinput_backend<S: Session + 'static>(loop_handle: &LoopHandle<'static, DesktopState>, session: Rc<S>) -> Result<LibinputInputBackend, InputError>`**:
    1. `tracing::info!("Initialisiere Libinput-Backend...");`
    2. `let session_interface = Rc::new(std::cell::RefCell::new(smithay::backend::session::libinput_session_interface(session)));` (Smithay stellt diese Hilfsfunktion bereit).
    3. `let mut libinput_context = libinput::Libinput::new_from_path(session_interface.clone());`
    4. `libinput_context.udev_assign_seat("seat0").map_err(|e| InputError::LibinputError(format!("Zuweisung zu udev seat0 fehlgeschlagen: {:?}", e)))?;`
    5. `let libinput_backend = LibinputInputBackend::new(libinput_context, Some(tracing::Span::current()));`
    6. `tracing::info!("Libinput-Backend erfolgreich initialisiert.");`
    7. `Ok(libinput_backend)`
- **Funktion `pub fn register_libinput_source(loop_handle: &LoopHandle<'static, DesktopState>, libinput_backend: LibinputInputBackend, seat_name: String) -> Result<calloop::Source<LibinputInputBackend>, InputError>`**:
    1. `let libinput_event_source = loop_handle.insert_source(libinput_backend, move |event, _metadata, desktop_state| { // desktop_state ist hier &mut DesktopState // Rufe den zentralen Event-Dispatcher auf super::event_dispatcher::process_input_event(desktop_state, event, &seat_name); }).map_err(|e| InputError::EventSourceSetupError(e.to_string()))?;`
    2. `Ok(libinput_event_source)` (Der Rückgabewert ist hier nicht ganz korrekt, `insert_source` gibt `RegistrationToken` oder `Source` zurück, abhängig von der calloop-Version und Methode). Korrekt wäre, dass der `LibinputInputBackend` selbst die Quelle ist. Die Logik ist, dass der `LibinputInputBackend` in die Schleife eingefügt wird.
- **Datei: `src/input/event_dispatcher.rs`**
    - **Funktion `pub fn process_input_event(desktop_state: &mut DesktopState, event: InputEvent<LibinputInputBackend>, seat_name: &str)`**: ()
        1. `let seat = match desktop_state.seat_state.seats().find(|s| s.name() == seat_name) { Some(s) => s.clone(), None => { tracing::error!("Seat '{}' nicht gefunden für Input-Event.", seat_name); return; } };`
        2. `match event { ... }` wie in detailliert.
            - **`InputEvent::DeviceAdded { device }`**:
                - `tracing::info!("Eingabegerät hinzugefügt: {} (Sys: {})", device.name(), device.sysname());`
                - Wenn `device.has_capability(libinput::DeviceCapability::Keyboard)` und `seat.get_keyboard().is_none()`:
                    - `let kbd_config = XkbConfig::default(); // Oder aus GlobalSettings laden`
                    - `match seat.add_keyboard(kbd_config, 200, 25) { Ok(_) => tracing::info!("Tastatur-Capability zu Seat '{}' hinzugefügt.", seat_name), Err(e) => tracing::error!("Fehler beim Hinzufügen der Tastatur-Capability: {}", e), };`
                    - (XkbKeyboardData muss ggf. aktualisiert werden)
                - Analog für `Pointer` und `Touch`.
            - **`InputEvent::DeviceRemoved { device }`**:
                - `tracing::info!("Eingabegerät entfernt: {}", device.name());`
                - Wenn `device.has_capability(libinput::DeviceCapability::Keyboard)`: `seat.remove_keyboard();`
                - Analog für `Pointer` und `Touch`.

#### 2.4. Submodul: `system::input::keyboard`

**Zweck:** Tastaturereignis-Übersetzung, XKB-Management.

**Datei:** `src/input/keyboard/xkb_config.rs`

- **Struct `XkbKeyboardData`**:
    
    Rust
    
    ```
    use xkbcommon::xkb;
    use smithay::input::keyboard::{KeyboardConfig, ModifiersState as SmithayModifiersState};
    use calloop::TimerHandle;
    use smithay::reexports::wayland_server::protocol::wl_surface::WlSurface;
    use wayland_server::Weak;
    use smithay::utils::Serial;
    
    #[derive(Debug)] // TimerHandle ist nicht Debug
    pub struct XkbKeyboardData {
        pub context: xkb::Context,
        pub keymap: xkb::Keymap,
        pub state: xkb::State,
        pub repeat_timer: Option<TimerHandle>,
        pub repeat_info: Option<(u32 /* keycode */, xkb::Keycode /* xkb keycode */, SmithayModifiersState, std::time::Duration /* delay */, std::time::Duration /* rate */)>,
        pub focused_surface_on_seat: Option<Weak<WlSurface>>,
        pub repeat_key_serial: Option<Serial>,
        // Für Tastenwiederholung: Speichern des xkb-Keycodes, nicht nur des libinput-Keycodes.
    }
    
    impl XkbKeyboardData {
        pub fn new(config: &KeyboardConfig<'_>) -> Result<Self, InputError> {
            let context = xkb::Context::new(xkb::CONTEXT_NO_FLAGS);
            let keymap_name = config.keymap_name.as_deref().unwrap_or("default"); // Bessere Defaults nötig
            let rules = config.rules.as_deref().unwrap_or("evdev");
            let model = config.model.as_deref().unwrap_or("pc105");
            let layout = config.layout.as_deref().unwrap_or("us");
            let variant = config.variant.as_deref();
            let options = config.options.as_deref();
    
            tracing::debug!("Lade XKB Keymap: rules={}, model={}, layout={}, variant={:?}, options={:?}",
                rules, model, layout, variant, options);
    
            let mut keymap_builder = xkb::KeymapCompileArgsBuilder::new();
            keymap_builder.rules(rules);
            keymap_builder.model(model);
            keymap_builder.layout(layout);
            if let Some(v) = variant { keymap_builder.variant(v); }
            if let Some(o) = options { keymap_builder.options(o); }
    
    
            let keymap = match xkb::Keymap::new_from_names(
                &context,
                &keymap_builder.build(), // Verwende den Builder
                xkb::KEYMAP_COMPILE_NO_FLAGS,
            ) {
                Ok(km) => km,
                Err(_) => { // Fallback zu einfacherem Setup
                    tracing::warn!("Komplexe XKB-Keymap '{}' konnte nicht geladen werden, versuche Fallback (us).", keymap_name);
                    let fallback_args = xkb::KeymapCompileArgsBuilder::new()
                        .layout("us").build();
                    xkb::Keymap::new_from_names(&context, &fallback_args, xkb::KEYMAP_COMPILE_NO_FLAGS)
                        .map_err(|_| InputError::XkbConfigError { seat_name: "unknown".into(), message: "Fallback XKB Keymap (us) konnte nicht kompiliert werden".into() })?
                }
            };
    
            let state = xkb::State::new(&keymap);
            Ok(Self {
                context, keymap, state,
                repeat_timer: None, repeat_info: None, focused_surface_on_seat: None, repeat_key_serial: None
            })
        }
    }
    ```
    
- **`Default for KeyboardConfig`**: Wird benötigt, um `XkbKeyboardData::new(&Default::default())` aufrufen zu können.
    
    Rust
    
    ```
    // Ggf. in KeyboardConfig von Smithay oder hier lokal
    // impl Default for KeyboardConfig<'_> { ... }
    ```
    

**Datei:** `src/input/keyboard/key_event_translator.rs`

- **Funktion `pub fn handle_keyboard_key_event(...)`**: ()
    1. Hole `keyboard_handle = seat.get_keyboard().ok_or(...)?.clone();`
    2. Hole `xkb_data = desktop_state.keyboard_data_map.get_mut(seat_name).ok_or(...)?;`
    3. `let keycode = event.key_code();`
    4. `let xkb_keycode = keycode + 8; // Libinput keycodes sind XKB keycodes - 8`
    5. `let key_state_xkb = match event.state() { KeyState::Pressed => xkb::KeyDirection::Down, KeyState::Released => xkb::KeyDirection::Up, };`
    6. `xkb_data.state.update_key(xkb_keycode.into(), key_state_xkb);`
    7. `let smithay_mods_state = SmithayModifiersState { ... /* von xkb_data.state.serialize_mods etc. */ };`
    8. `keyboard_handle.modifiers(event.serial(), smithay_mods_state.clone(), Some(tracing::Span::current()));`
    9. Wenn `event.state() == KeyState::Pressed`:
        - `let serial = event.serial();`
        - `let time = event.time();`
        - `keyboard_handle.key(serial, time, xkb_keycode, KeyState::Pressed, Some(tracing::Span::current()));`
        - **Tastenwiederholung einrichten:**
            - `if let Some(timer) = xkb_data.repeat_timer.take() { timer.cancel(); }`
            - `if keyboard_handle.is_repeating(xkb_keycode) { ... }`
            - `let (delay, rate) = keyboard_handle.repeat_info();`
            - `xkb_data.repeat_info = Some((keycode, xkb_keycode.into(), smithay_mods_state, delay, rate));`
            - `xkb_data.repeat_key_serial = Some(serial);`
            - `let timer_seat_name = seat_name.to_string();`
            - `xkb_data.repeat_timer = Some(desktop_state.loop_handle.insert_timer(delay, move |ds: &mut DesktopState| { ... repeat_logic ... }).expect("Timer creation failed"));`
    10. Wenn `event.state() == KeyState::Released`:
        - `keyboard_handle.key(event.serial(), event.time(), xkb_keycode, KeyState::Released, Some(tracing::Span::current()));`
        - **Tastenwiederholung abbrechen:** `if xkb_data.repeat_info.map_or(false, |(_, rkc, ..)| rkc == xkb_keycode.into()) { ... cancel timer ... }`
- **Tastenwiederholungslogik im Timer-Callback:**
    1. Hole `xkb_data` für `timer_seat_name`.
    2. Wenn `xkb_data.repeat_info` `None` ist oder der Fokus gewechselt hat (prüfe `xkb_data.focused_surface_on_seat`), Timer abbrechen und `return;`.
    3. `let (keycode, xkb_keycode, mods_state, _, rate) = xkb_data.repeat_info.as_ref().unwrap().clone();`
    4. Hole aktuellen `seat` und `keyboard_handle`.
    5. `let new_serial = Serial::now();` // Wichtig: Neuer Serial für wiederholte Events
    6. `keyboard_handle.modifiers(new_serial, mods_state, Some(tracing::Span::current()));`
    7. `keyboard_handle.key(new_serial, current_time_ms(), xkb_keycode, KeyState::Pressed, Some(tracing::Span::current()));`
    8. `xkb_data.repeat_key_serial = Some(new_serial);`
    9. Timer mit `rate` neu planen.

**Datei:** `src/input/keyboard/focus.rs` (ersetzt `focus_handler_keyboard.rs`)

- **Funktion `pub fn set_keyboard_focus(desktop_state: &mut DesktopState, seat_name: &str, surface: Option<&WlSurface>, serial: Serial)`**:
    1. `tracing::debug!(seat = %seat_name, new_focus_surface = ?surface.map(|s| s.id()), ?serial, "Setze Tastaturfokus");`
    2. Hole `seat = desktop_state.seat_state.seats().find(|s| s.name() == seat_name).cloned().ok_or(...)`;
    3. Hole `keyboard = seat.get_keyboard().ok_or(...)?.clone();`
    4. Hole `xkb_data = desktop_state.keyboard_data_map.get_mut(seat_name).ok_or(...)?;`
    5. `let old_focus_wl_surface = xkb_data.focused_surface_on_seat.as_ref().and_then(|w| w.upgrade());`
    6. `if old_focus_wl_surface.as_ref() == surface { tracing::trace!("Tastaturfokus unverändert."); return Ok(()); }`
    7. `keyboard.set_focus(surface, serial, Some(tracing::Span::current()));` // Smithay sendet Enter/Leave
    8. `xkb_data.focused_surface_on_seat = surface.map(|s| s.downgrade());`
    9. // Domänenschicht über Fokusänderung informieren, falls `SeatHandler::focus_changed` nicht ausreicht
        
        Rust
        
        ```
        // let domain_window_id = surface.and_then(|s| find_domain_window_id_for_surface(desktop_state, s));
        // block_on(desktop_state.workspace_manager_service.notify_keyboard_focus_changed(domain_window_id));
        ```
        

#### 2.5. Submodul: `system::input::pointer`

**Zweck:** Maus-/Zeigerereignis-Verarbeitung, Cursor.

**Datei:** `src/input/pointer/mod.rs` (oder `event_translator.rs`, `focus.rs`, `cursor.rs`)

- **Funktion `pub fn handle_pointer_motion_event(...)`**: ()
    1. Hole `pointer_handle = seat.get_pointer().ok_or(...)?;`
    2. `desktop_state.pointer_location += event.delta();` // Einfache Akkumulation, ggf. an Bildschirmgrenzen klemmen.
    3. `let (new_focus_surface_option, surface_local_coords) = find_surface_and_coords_at_global_point(desktop_state, desktop_state.pointer_location);`
    4. `pointer_handle.motion(event.time(), new_focus_surface_option.as_ref(), serial, desktop_state.pointer_location, surface_local_coords, Some(tracing::Span::current()));` (Smithay's `motion` sendet `enter`/`leave` und `motion`).
    5. Aktualisiere `desktop_state.active_input_surface` basierend auf `new_focus_surface_option`.
    6. Renderer Cursor-Position aktualisieren (indem Renderer `desktop_state.pointer_location` liest).
- **Funktion `find_surface_and_coords_at_global_point(desktop_state: &DesktopState, global_pos: Point<f64, Logical>) -> (Option<WlSurface>, Point<f64, Logical>)`**:
    1. Iteriere über `desktop_state.space.elements_under(global_pos)` (Smithay's Space liefert Fenster in korrekter Reihenfolge).
    2. Für jedes `Window` (unsere `ManagedWindow`-Implementierung):
        - Hole `wl_surface = window.wl_surface()`.
        - Prüfe, ob `wl_surface` eine Eingaberegion hat (`SurfaceData::input_region_surface_local`).
        - Transformiere `global_pos` in Oberflächen-lokale Koordinaten.
        - Wenn `global_pos` innerhalb der Eingaberegion (oder der Oberflächengeometrie, falls keine Eingaberegion):
            - Gib `(Some(wl_surface.clone()), surface_local_coords)` zurück.
    3. Sonst: `(None, global_pos)` (oder `(0.0, 0.0)` für lokale Coords).
- **Funktion `handle_pointer_button_event(...)`**: ()
    1. Hole `pointer_handle`.
    2. `pointer_handle.button(event.button(), event.button_state().into(), event.serial(), event.time(), Some(tracing::Span::current()));`
    3. Wenn `event.button_state() == ButtonState::Pressed`:
        - `let (focused_surface_option, _) = find_surface_and_coords_at_global_point(desktop_state, desktop_state.pointer_location);`
        - Wenn `focused_surface_option` `Some(surface_to_focus)`:
            - `set_keyboard_focus(desktop_state, seat_name, Some(&surface_to_focus), event.serial())?;` (Click-to-focus).
            - Hier könnte auch Logik für Fenstermanagement-Aktionen (Move/Resize-Start) basierend auf `surface_to_focus` und Klickposition (relativ zu Dekorationen) ausgelöst werden.
- **Funktion `handle_pointer_axis_event(...)`**: ()
    1. Hole `pointer_handle`.
    2. `pointer_handle.axis(event.time(), event.axis(), event.axis_source().into(), event.axis_value_discrete(), event.axis_value(smithay::utils:: SERIAL_COUNTER_RANGE), event.serial(), Some(tracing::Span::current()));` (Smithay-Signatur anpassen).

#### 2.6. Submodul: `system::input::touch`

**Zweck:** Touch-Ereignis-Verarbeitung.

**Datei:** `src/input/touch/mod.rs` (oder `event_translator.rs`, `focus.rs`)

- **Logik für `handle_touch_down_event`**: ()
    1. Hole `touch_handle = seat.get_touch().ok_or(...)?;`
    2. `let slot = event.slot().ok_or_else(|| InputError::InternalError("Touch down event ohne Slot ID".into()))?;`
    3. `let (focused_surface_option, surface_local_coords) = find_surface_and_coords_at_global_point(desktop_state, event.position_transformed(output_size));`
    4. Wenn `focused_surface_option` `Some(surface)`:
        - Speichere `surface.clone()` als Fokus für diesen `slot` (z.B. in einer `HashMap<TouchSlotId, WlSurface>` in `DesktopState`).
        - `touch_handle.down(event.serial(), event.time(), slot, surface_local_coords, &surface, Some(tracing::Span::current()));`
        - `set_keyboard_focus(desktop_state, seat_name, Some(&surface), event.serial())?;` (Touch-to-focus).
- **Logik für `handle_touch_up_event`**: ()
    1. Hole `touch_handle`. `let slot = event.slot().ok_or(...)`;
    2. `touch_handle.up(event.serial(), event.time(), slot, Some(tracing::Span::current()));`
    3. Entferne Fokus für diesen `slot` aus der internen Map.
- **Logik für `handle_touch_motion_event`**: ()
    1. Hole `touch_handle`. `let slot = event.slot().ok_or(...)`;
    2. Hole die fokussierte Oberfläche für diesen `slot` aus der internen Map.
    3. Transformiere `event.position_transformed(output_size)` in lokale Koordinaten dieser Oberfläche.
    4. `touch_handle.motion(event.serial(), event.time(), slot, surface_local_coords, Some(tracing::Span::current()));`
- **`handle_touch_frame_event`, `handle_touch_cancel_event`**: Rufen entsprechende `touch_handle`-Methoden auf.

#### 2.7. Submodul: `system::input::gestures`

Zweck: Grundlegende Gestenerkennung (Pinch, Swipe) aufbauend auf libinput-Events.

Datei: src/input/gestures/mod.rs

- **Initial:** Für Gesten wie `InputEvent::GesturePinchBegin/Update/End`, `InputEvent::GestureSwipeBegin/Update/End`:
    1. Logge das Ereignis mit `tracing::debug!`.
    2. **Zukünftige Erweiterung:**
        - Eine `GestureState`-Struktur pro aktivem Seat, die laufende Gesten verfolgt.
        - Bei `GestureSwipeBegin`: Starte eine "Swipe"-Geste.
        - Bei `GestureSwipeUpdate`: Akkumuliere `event.dx()`, `event.dy()`. Wenn ein Schwellenwert überschritten wird:
            - Wandle in eine Domänenaktion um (z.B. Workspace wechseln). Rufe z.B. `desktop_state.workspace_manager_service.switch_to_next_workspace().await;`.
        - Bei `GestureSwipeEnd`: Beende die Geste.
        - Ähnlich für Pinch-to-Zoom (könnte z.B. Skalierungsfaktor einer App oder des Desktops beeinflussen - komplexe Interaktion mit Compositor/Anwendung).
- **Abhängigkeiten:** Benötigt Zugriff auf Domänenservices (z.B. `WorkspaceManagerService`).

#### 2.8. Implementierungsschritte `system::input`

1. **Grundgerüst**: Verzeichnisse anlegen, `Cargo.toml` für `libinput`, `xkbcommon` etc.
2. **`errors.rs`**: `InputError` Enum definieren.
3. **`seat_manager/mod.rs`**:
    - `DesktopState`-Felder für Input/Fokus erweitern.
    - `SeatHandler` für `DesktopState` implementieren (`focus_changed`, `cursor_image`).
    - `create_seat` Funktion implementieren.
4. **`libinput_handler/session_interface.rs`**: `LibinputSessionManager` (ggf. mit Dummy-Implementierung für `open/close_restricted` initial).
5. **`libinput_handler/mod.rs`**: `init_libinput_backend`, `register_libinput_source`.
6. **`event_dispatcher.rs`**: `process_input_event` mit `match` für alle relevanten `InputEvent`-Typen und Delegation an Handler in `keyboard`, `pointer`, `touch`. Logik für `DeviceAdded/Removed`.
7. **`keyboard/xkb_config.rs`**: `XkbKeyboardData`-Struct und `new()`-Methode.
8. **`keyboard/key_event_translator.rs`**: `handle_keyboard_key_event` inklusive Tastenwiederholungslogik (Timer-Setup und Callback).
9. **`keyboard/focus.rs`**: `set_keyboard_focus` implementieren.
10. **`pointer/mod.rs`**: `handle_pointer_motion_event` (inkl. `find_surface_and_coords_at_global_point`), `handle_pointer_button_event`, `handle_pointer_axis_event`.
11. **`touch/mod.rs`**: `handle_touch_down/up/motion/frame/cancel_event`. Interne Verwaltung des Touch-Fokus pro Slot.
12. **`gestures/mod.rs`**: Basis-Logging für Gesten-Events.
13. **`src/input/mod.rs`**: Öffentliche API des Input-Moduls definieren (z.B. Initialisierungsfunktionen).
14. **Unit-Tests (anspruchsvoll, erfordert oft Mocking von `Seat`, `KeyboardHandle` etc. oder Integrationstests):**
    - Testen der XKB-Keymap-Erstellung.
    - Testen der Keycode-zu-Keysym/UTF-8-Übersetzung für einige Tasten.
    - Testen der Fokussetzungslogik (Keyboard, Pointer, Touch).
    - Testen der Event-Weiterleitung für verschiedene Eingabetypen.
    - Testen der `find_surface_and_coords_at_global_point`-Logik mit verschiedenen Fensterlayouts.

---

**Nächste Schritte für `system` (Skizze für weitere Module):**

- **`system::dbus_interfaces`**:
    - **Verantwortlichkeiten:** Clients für wichtige Systemdienste (NetworkManager, UPower, logind, Secrets, PolicyKit) und Server für `org.freedesktop.Notifications`.
    - **Technologie:** `zbus` (async).
    - **Struktur:** Pro Dienst ein Submodul (z.B. `dbus_interfaces::upower_client`).
    - **Jedes Client-Submodul:**
        - Definiert Proxy-Structs für die D-Bus-Interfaces des Dienstes.
        - Implementiert Methoden zum Abrufen von Eigenschaften und Aufrufen von Methoden des Dienstes.
        - Implementiert Signal-Handler, um auf D-Bus-Signale zu reagieren und diese in interne System-Events oder Domänenaufrufe zu übersetzen.
        - Fehlerbehandlung mit spezifischem `DBusInterfaceError`.
    - **`notifications_server`**: Implementiert den `org.freedesktop.Notifications`-D-Bus-Service. Leitet eingehende `Notify`-Aufrufe an `domain::user_centric_services::NotificationService::post_notification` weiter. Handhabt `GetCapabilities`, `CloseNotification`, `GetServerInformation`. Sendet `NotificationClosed`, `ActionInvoked` Signale.
- **`system::audio_management`**:
    - **Verantwortlichkeiten:** Steuerung der Systemlautstärke, Auswahl von Audio-Geräten, Verwaltung von Anwendungs-Streams.
    - **Technologie:** `pipewire-rs`.
    - **Struktur:** `client` (Core-Verbindung), `device_manager`, `stream_manager`, `volume_control`.
    - Interaktion mit PipeWire-Registry, um Geräte und Streams zu entdecken.
    - Nutzung von `PWStream` für Lautstärkeregelung etc.
    - Übersetzung von PipeWire-Events in interne System-Events oder Domänenaufrufe.
- **`system::mcp_client`**:
    - **Verantwortlichkeiten:** Sichere Kommunikation mit lokalen/remote MCP-Servern.
    - **Technologie:** `mcp_client_rs`.
    - Nimmt Anweisungen und Kontextdaten von `domain::user_centric_services::ai_interaction` entgegen.
    - Ruft Methoden des `mcp_client_rs::McpClient` auf.
    - Leitet Ergebnisse/Fehler an die Domänenschicht zurück.
    - Verwaltet API-Schlüssel sicher (über `dbus_interfaces::secrets_service`).
- **`system::window_mechanics`**:
    - **Verantwortlichkeiten:** Konkrete Umsetzung der Fenstermanagement-"Mechanik" basierend auf Richtlinien aus `domain::window_management_policy`.
    - Interagiert eng mit `system::compositor::xdg_shell` und `smithay::desktop::Space`.
    - Ruft `domain::window_management_policy_service::calculate_workspace_layout()` auf und wendet die resultierenden Geometrien auf `ManagedWindow`s an (z.B. über deren `send_configure`-Methoden oder direkte Manipulation im `Space`).
    - Implementiert Snapping während interaktiver Move/Resize-Operationen.
    - Koordiniert Client-Side vs. Server-Side Decorations.
- **`system::event_bridge`**:
    - Ein Modul, das `tokio::sync::broadcast` Kanäle oder ähnliche Mechanismen nutzt, um System-interne Events (z.B. "Neues Eingabegerät", "Netzwerkstatus geändert", "Batteriestand niedrig") für andere Systemmodule oder Adapter zur Domänenschicht bereitzustellen.
- **`system::power_management`**:
    - Interagiert mit `wlr-output-power-management-unstable-v1` (serverseitig im Compositor implementiert).
    - Interagiert mit `system::dbus_interfaces::logind` für Suspend/Hibernate.
    - Setzt DPMS-Modi für Outputs basierend auf `domain::global_settings_service` und Benutzeraktivität (`domain::common_events::UserActivityDetectedEvent`).

Diese detaillierte Ausarbeitung für `system::input` und die Skizzen für die weiteren Module sollten eine solide Basis für die Implementierung der gesamten Systemschicht bilden. Jedes dieser Module erfordert eine ähnliche Tiefe der Spezifikation, insbesondere bei der Interaktion mit externen Bibliotheken und Protokollen.

Kurzfassung: Rust (Edition 2021+), Nutzung von novade-core und novade-domain, zbus für D-Bus-Interaktionen, smithay (wo relevant für Compositor-Interaktionen), tokio (oft von zbus benötigt), thiserror für Fehler.

**Cargo.toml für `novade-system` (relevante Ergänzungen für D-Bus):**

Ini, TOML

```
[dependencies]
# ... (bestehende Abhängigkeiten wie novade-core, novade-domain, smithay, etc.) ...
zbus = { version = "3.15", default-features = false, features = ["tokio"] } # Aktuelle zbus 4.x Version prüfen, tokio feature ist wichtig
serde = { version = "1.0.197", features = ["derive"] }
serde_json = "1.0.115" # Falls einige D-Bus Properties/Methoden JSON verwenden
tracing = "0.1.40"
thiserror = "1.0.58"
async-trait = "0.1.79"
tokio = { version = "1.37.0", features = ["sync", "rt", "macros"] }
# Ggf. spezifische Crates für Freedesktop-Spezifikationen, falls zbus nicht alles abdeckt
# oder für komplexere Typen (z.B. `dbus-crossroads` für Server-Seite, obwohl zbus auch Server kann)
```

---

### Modul 3: `system::dbus_interfaces`

Zweck: Implementierung von Schnittstellen zur Interaktion mit etablierten System-D-Bus-Diensten sowie Bereitstellung eigener D-Bus-Schnittstellen, wo dies von der Architektur vorgesehen ist (z.B. org.freedesktop.Notifications).

Verantwortlichkeiten:

- Erstellen und Verwalten von D-Bus-Verbindungen (Session und System Bus).
- Implementierung von Clients (Proxies) für externe D-Bus-Dienste wie NetworkManager, UPower, logind, org.freedesktop.secrets, PolicyKit.
- Abrufen von Eigenschaften, Aufrufen von Methoden und Abonnieren von Signalen dieser Dienste.
- Übersetzung von D-Bus-Daten und -Signalen in interne System-Events oder Aufrufe an die Domänenschicht.
- Implementierung von D-Bus-Server-Objekten für Dienste, die NovaDE selbst bereitstellt (z.B. `org.freedesktop.Notifications`). **Design-Rationale:** Kapselung aller D-Bus-spezifischen Logik. Verwendung von `zbus` als moderne, asynchrone D-Bus-Bibliothek in Rust. Klare Trennung zwischen D-Bus-Protokoll-Interaktion und der Verarbeitungslogik in anderen System- oder Domänenmodulen.

#### 3.1. Submodul: `system::dbus_interfaces::common`

**Zweck:** Definition gemeinsamer Typen, Fehler und Hilfsfunktionen für alle D-Bus-Interaktionen.

**Datei:** `src/dbus_interfaces/common/errors.rs`

- **Enum `DBusInterfaceError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use zbus::Error as ZBusError;
    use zbus::names::ErrorName;
    
    #[derive(Debug, Error)]
    pub enum DBusInterfaceError {
        #[error("D-Bus connection failed: {0}")]
        ConnectionFailed(#[from] ZBusError), // Direkter Fehler von zbus beim Verbindungsaufbau
        #[error("Failed to create D-Bus proxy for service '{service}' path '{path}' interface '{interface}': {source}")]
        ProxyCreationFailed {
            service: String,
            path: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("D-Bus method call '{method}' on '{interface}' failed: {source}")]
        MethodCallFailed {
            method: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Failed to get D-Bus property '{property}' from '{interface}': {source}")]
        PropertyGetFailed {
            property: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Failed to set D-Bus property '{property}' on '{interface}': {source}")]
        PropertySetFailed {
            property: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Failed to subscribe to D-Bus signal '{signal}' from '{interface}': {source}")]
        SignalSubscriptionFailed {
            signal: String,
            interface: String,
            #[source]
            source: ZBusError,
        },
        #[error("Received D-Bus error reply: {name} - {body}")]
        DBusErrorReply {
            name: ErrorName<'static>, // 'static hier, da ErrorName oft geklont wird
            body: String, // Oft der Message-Teil des D-Bus-Fehlers
        },
        #[error("Type conversion error during D-Bus operation: {0}")]
        TypeConversionError(String), // Wenn z.B. ein zvariant nicht in den erwarteten Rust-Typ passt
        #[error("Required D-Bus service '{service}' is not available or not activatable.")]
        ServiceUnavailable { service: String },
        #[error("D-Bus object path '{0}' not found for service.")]
        ObjectPathNotFound(String),
        #[error("D-Bus interface '{0}' not found on object.")]
        InterfaceNotFound(String),
        #[error("An internal error occurred in a D-Bus interface: {0}")]
        InternalError(String),
    }
    
    // Hilfsfunktion, um zbus::Error in DBusErrorReply zu konvertieren, falls es ein D-Bus-Fehler war
    impl From<ZBusError> for DBusInterfaceError {
        fn from(err: ZBusError) -> Self {
            if let ZBusError::MethodError(name, body, _) = err {
                DBusInterfaceError::DBusErrorReply { name: name.into_static(), body: body.unwrap_or_default() }
            } else {
                // Für andere ZBusError-Typen, die nicht MethodError sind,
                // könnte man spezifischere Mappings oder eine generische Variante haben.
                // Hier als Beispiel: fallback auf MethodCallFailed (kontextabhängig anpassen)
                DBusInterfaceError::MethodCallFailed {
                    method: "unknown".to_string(),
                    interface: "unknown".to_string(),
                    source: err,
                }
            }
        }
    }
    ```
    
    - **Begründung:** Fasst generische D-Bus-Fehler und spezifischere Fälle wie `ProxyCreationFailed` oder `ServiceUnavailable` zusammen. Die `From<ZBusError>` Implementierung hilft, `zbus`-Fehler direkt in benutzerdefinierte Fehler zu überführen.

**Datei:** `src/dbus_interfaces/common/connection_manager.rs`

- **Struct `DBusConnectionManager`**:
    
    Rust
    
    ```
    use zbus::{Connection, ConnectionBuilder, Address, Transport};
    use super::errors::DBusInterfaceError;
    use std::sync::{Arc, OnceLock}; // OnceLock für Singleton-Verbindungen
    use tokio::sync::Mutex; // Mutex, falls die Verbindung modifiziert werden kann (selten)
    
    static SESSION_BUS: OnceLock<Arc<Connection>> = OnceLock::new();
    static SYSTEM_BUS: OnceLock<Arc<Connection>> = OnceLock::new();
    
    #[derive(Debug, Clone)]
    pub struct DBusConnectionManager;
    
    impl DBusConnectionManager {
        /// Stellt die Session-Bus-Verbindung her (oder gibt die bestehende zurück).
        pub async fn session_bus() -> Result<Arc<Connection>, DBusInterfaceError> {
            if let Some(conn) = SESSION_BUS.get() {
                return Ok(conn.clone());
            }
            let conn = ConnectionBuilder::session()?
                .build()
                .await?;
            let arc_conn = Arc::new(conn);
            match SESSION_BUS.set(arc_conn.clone()) {
                Ok(_) => Ok(arc_conn),
                Err(existing_conn_arc) => Ok(existing_conn_arc.clone()), // Rennen gewonnen von anderem Thread
            }
        }
    
        /// Stellt die System-Bus-Verbindung her (oder gibt die bestehende zurück).
        pub async fn system_bus() -> Result<Arc<Connection>, DBusInterfaceError> {
            if let Some(conn) = SYSTEM_BUS.get() {
                return Ok(conn.clone());
            }
            let conn = ConnectionBuilder::system()?
                .build()
                .await?;
            let arc_conn = Arc::new(conn);
            match SYSTEM_BUS.set(arc_conn.clone()) {
                Ok(_) => Ok(arc_conn),
                Err(existing_conn_arc) => Ok(existing_conn_arc.clone()),
            }
        }
    
        /// Erstellt einen zbus Proxy.
        pub async fn create_proxy<'a, T: zbus::ProxyDefault + Send + Sync + 'static>(
            connection: Arc<Connection>,
            destination: &'static str, // Muss 'static sein für einige Proxy-Konstrukte
            path: &'static str,
        ) -> Result<T, DBusInterfaceError> {
            T::builder(&connection)
                .destination(destination)?
                .path(path)?
                .build()
                .await
                .map_err(|e| DBusInterfaceError::ProxyCreationFailed {
                    service: destination.to_string(),
                    path: path.to_string(),
                    interface: T::INTERFACE.unwrap_or("unknown").to_string(), // T::INTERFACE ist Option<&'static str>
                    source: e,
                })
        }
    }
    ```
    
    - **Zweck:** Stellt sicher, dass nur eine Verbindung pro Bus-Typ (Session/System) besteht und verwaltet wird (`OnceLock` für Singleton-Pattern). Bietet eine Hilfsfunktion zum Erstellen von Proxies.
    - **Methoden:** `session_bus() -> Result<Arc<Connection>>`, `system_bus() -> Result<Arc<Connection>>`, `create_proxy<T>(...)`.
    - **Zustand:** Die `OnceLock`-statischen Variablen halten die globalen Verbindungen.

**Datei:** `src/dbus_interfaces/common/mod.rs`

- `pub mod errors;`
- `pub mod connection_manager;`
- `pub use errors::DBusInterfaceError;`
- `pub use connection_manager::DBusConnectionManager;`

#### 3.2. Submodul: `system::dbus_interfaces::upower_client`

Zweck: Client für den org.freedesktop.UPower Dienst zur Abfrage von Energieinformationen (Batteriestatus, Deckelzustand etc.).

Interaktion mit Domäne: Sendet UPowerEvent (neu zu definierendes Event in system::event_bridge oder direkt an einen Domänen-Service) an die Domänenschicht (z.B. domain::power_management_policy oder einen allgemeinen SystemStatusService).

**Datei:** `src/dbus_interfaces/upower_client/types.rs`

- **Enums (Spiegelung der D-Bus-Typen von UPower):**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize}; // Für Events
    use zbus::zvariant::Type; // Für D-Bus Typ-Annotationen
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Type, Serialize, Deserialize)]
    #[repr(u32)] // Entspricht den UPower-Enum-Werten
    pub enum PowerDeviceType {
        Unknown = 0,
        LinePower = 1,
        Battery = 2,
        Ups = 3,
        Monitor = 4,
        Mouse = 5,
        Keyboard = 6,
        Pda = 7,
        Phone = 8,
        MediaPlayer = 9,
        Tablet = 10,
        Computer = 11,
    }
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Type, Serialize, Deserialize)]
    #[repr(u32)]
    pub enum PowerState {
        Unknown = 0,
        Charging = 1,
        Discharging = 2,
        Empty = 3,
        FullyCharged = 4,
        PendingCharge = 5,
        PendingDischarge = 6,
    }
    
    #[derive(Debug, Clone, PartialEq, Type, Serialize, Deserialize)]
    pub struct PowerDeviceDetails {
        pub native_path: String, // z.B. /sys/class/power_supply/BAT0
        pub vendor: String,
        pub model: String,
        pub serial: String,
        pub update_time: u64, // Unix-Timestamp
        pub device_type: PowerDeviceType,
        pub online: bool,
        pub energy: f64, // Wh (Watt-hours)
        pub energy_empty: f64,
        pub energy_full: f64,
        pub energy_full_design: f64,
        pub energy_rate: f64, // Watt (aktuelle Leistung)
        pub voltage: f64,
        pub time_to_empty: u64, // Sekunden
        pub time_to_full: u64, // Sekunden
        pub percentage: f64, // 0.0 - 100.0
        pub temperature: f64, // Celsius
        pub is_rechargeable: bool,
        pub capacity: f64, // Prozentsatz der Design-Kapazität
        pub technology: u32, // Enum UPowerTechnology
        pub warning_level: u32, // Enum UPowerWarningLevel
        pub state: PowerState,
        pub icon_name: String,
        // Weitere Felder nach Bedarf aus `org.freedesktop.UPower.Device`
    }
    ```
    
- **Event-Struktur (für `system::event_bridge`):**
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum UPowerEvent {
        DeviceAdded(String /* object_path */),
        DeviceRemoved(String /* object_path */),
        DeviceChanged(String /* object_path */), // Wenn Eigenschaften eines Geräts sich ändern
        LidStateChanged(bool /* is_closed */),
        OnBatteryChanged(bool /* is_on_battery */),
        PowerSupplyChanged, // Generelles Event, wenn sich etwas an der Stromversorgung ändert
    }
    ```
    

**Datei:** `src/dbus_interfaces/upower_client/proxies.rs`

- **zbus Proxy-Definitionen (manuell oder mit `zbus::proxy` Makro):**
    - **`UPowerProxy` für `org.freedesktop.UPower` auf `/org/freedesktop/UPower`**:
        
        Rust
        
        ```
        use zbus::proxy;
        use zbus::zvariant::{OwnedObjectPath, Value};
        use super::types::PowerDeviceDetails; // Annahme: PowerDeviceDetails ist als Value deserialisierbar
        
        #[proxy(
            interface = "org.freedesktop.UPower",
            default_service = "org.freedesktop.UPower",
            default_path = "/org/freedesktop/UPower"
        )]
        trait UPower {
            fn enumerate_devices(&self) -> zbus::Result<Vec<OwnedObjectPath>>;
            fn get_display_device(&self) -> zbus::Result<OwnedObjectPath>;
            fn get_critical_action(&self) -> zbus::Result<String>;
        
            #[zbus(property)]
            fn lid_is_closed(&self) -> zbus::Result<bool>;
            #[zbus(property)]
            fn lid_is_present(&self) -> zbus::Result<bool>;
            #[zbus(property)]
            fn on_battery(&self) -> zbus::Result<bool>;
            #[zbus(property)]
            fn daemon_version(&self) -> zbus::Result<String>;
        
            #[zbus(signal)]
            fn device_added(&self, device_path: OwnedObjectPath) -> zbus::Result<()>;
            #[zbus(signal)]
            fn device_removed(&self, device_path: OwnedObjectPath) -> zbus::Result<()>;
            // Weitere Signale: LidIsClosed, LidIsOpened, DeviceChanged (oft als PropertiesChanged auf Device-Interface)
        }
        ```
        
    - **`UPowerDeviceProxy` für `org.freedesktop.UPower.Device` (dynamischer Pfad)**:
        
        Rust
        
        ```
        #[proxy(
            interface = "org.freedesktop.UPower.Device",
            default_service = "org.freedesktop.UPower"
            // default_path wird dynamisch gesetzt
        )]
        trait UPowerDevice {
            fn refresh(&self) -> zbus::Result<()>;
            fn get_history(&self, type_: &str, timespan: u32, resolution: u32) -> zbus::Result<Vec<(u32, f64, u32)>>; // Array of (time, value, state)
            fn get_statistics(&self, type_: &str) -> zbus::Result<Vec<(f64, f64)>>; // Array of (value, accuracy)
        
            // Alle Eigenschaften aus PowerDeviceDetails als #[zbus(property)]
            #[zbus(property)] fn native_path(&self) -> zbus::Result<String>;
            #[zbus(property)] fn vendor(&self) -> zbus::Result<String>;
            #[zbus(property)] fn model(&self) -> zbus::Result<String>;
            #[zbus(property)] fn serial(&self) -> zbus::Result<String>;
            // ... alle weiteren Properties aus PowerDeviceDetails ...
            #[zbus(property)] fn state(&self) -> zbus::Result<super::types::PowerState>;
            #[zbus(property)] fn type_(&self) -> zbus::Result<super::types::PowerDeviceType>; // type ist ein Keyword
            #[zbus(property, name = "Type")] // Expliziter Name für D-Bus
            fn device_type_prop(&self) -> zbus::Result<super::types::PowerDeviceType>;
        
        
            // Oft wird `org.freedesktop.DBus.Properties.PropertiesChanged` Signal auf diesem Interface verwendet
        }
        ```
        
    - **Wichtig:** `zbus` erfordert, dass Enums, die direkt als D-Bus-Typen verwendet werden (wie `PowerState`, `PowerDeviceType`), `TryFrom<Value<'a>>` und `Into<Value<'static>>` implementieren, oder `zbus::zvariant::Type` und `serde` für automatische Konvertierung. `#[repr(u32)]` und `Type` sollten hier helfen.

**Datei:** `src/dbus_interfaces/upower_client/service.rs` (oder `client.rs`)

- **Struct `UPowerClientService`**:
    - **Felder:**
        - `connection: Arc<Connection>`
        - `proxy: UPowerProxy<'static>` (Proxy benötigt eine Lebenszeit, oft an die Connection gebunden)
        - `device_proxies: Arc<tokio::sync::Mutex<HashMap<OwnedObjectPath, UPowerDeviceProxy<'static>>>>`
        - `event_publisher: tokio::sync::broadcast::Sender<UPowerEvent>` (aus `system::event_bridge`)
        - `is_initialized: Arc<tokio::sync::watch::Sender<bool>>` (um Signale erst nach Initialisierung zu verarbeiten)
    - **Konstruktor `pub async fn new(event_publisher: tokio::sync::broadcast::Sender<UPowerEvent>) -> Result<Self, DBusInterfaceError>`**:
        1. `connection = DBusConnectionManager::system_bus().await?;`
        2. `proxy = UPowerProxy::new(&connection).await?;`
        3. Initialisiert `device_proxies` als leere Map.
        4. Initialisiert `is_initialized` Sender.
        5. Gibt `Self` zurück.
    - **Methode `pub async fn initialize_and_listen(&self) -> Result<(), DBusInterfaceError>`**:
        1. Ruft `proxy.enumerate_devices().await?` auf, um initiale Geräte zu bekommen.
        2. Für jedes Gerät: `self.add_device_proxy(device_path).await?;`
        3. Abonniert Signale des `UPowerProxy`:
            - `device_added_stream = proxy.receive_device_added().await?;` -> `self.handle_device_added(path).await;`
            - `device_removed_stream = proxy.receive_device_removed().await?;` -> `self.handle_device_removed(path).await;`
            - (Signale für LidIsClosed, LidIsOpened, OnBatteryChanged auf dem UPower-Interface, falls vorhanden, oder über PropertiesChanged)
        4. Abonniert `org.freedesktop.DBus.Properties.PropertiesChanged` auf dem `UPowerProxy` für Änderungen an `LidIsClosed`, `OnBattery`.
            
            Rust
            
            ```
            // let properties_changed_stream = self.proxy.receive_properties_changed().await?;
            // tokio::spawn(handle_property_changes_stream(properties_changed_stream, self.event_publisher.clone()));
            ```
            
        5. Setzt `*self.is_initialized.send(true).is_ok();`.
        6. Startet eine `tokio::task` für jeden Signal-Stream, der die Events verarbeitet.
    - **Private Methode `async fn add_device_proxy(&self, device_path: OwnedObjectPath) -> Result<(), DBusInterfaceError>`**:
        1. `let device_proxy = UPowerDeviceProxy::builder(&self.connection).path(device_path.clone())?.build().await?;`
        2. Abonniert `org.freedesktop.DBus.Properties.PropertiesChanged` auf `device_proxy`.
            
            Rust
            
            ```
            // let device_props_stream = device_proxy.receive_properties_changed().await?;
            // tokio::spawn(handle_device_property_changes_stream(device_path.clone(), device_props_stream, self.event_publisher.clone()));
            ```
            
        3. `self.device_proxies.lock().await.insert(device_path, device_proxy);`
        4. `self.event_publisher.send(UPowerEvent::DeviceAdded(device_path.into_inner().into_string())).ok();`
    - **Private Methode `async fn handle_device_added(&self, device_path: OwnedObjectPath)`**: Ruft `add_device_proxy`.
    - **Private Methode `async fn handle_device_removed(&self, device_path: OwnedObjectPath)`**: Entfernt aus `device_proxies`, sendet `DeviceRemoved` Event.
    - **Öffentliche Methoden zum Abrufen von Daten (Beispiele):**
        - `pub async fn get_all_device_details(&self) -> Result<Vec<PowerDeviceDetails>, DBusInterfaceError>`: Iteriert `device_proxies`, ruft alle Properties jedes Geräts ab und konstruiert `PowerDeviceDetails`.
        - `pub async fn is_lid_closed(&self) -> Result<bool, DBusInterfaceError>`: Ruft `proxy.lid_is_closed().await?`.
        - `pub async fn is_on_battery(&self) -> Result<bool, DBusInterfaceError>`: Ruft `proxy.on_battery().await?`.
- **Signal-Handler-Tasks (Beispiel für `PropertiesChanged` auf UPowerProxy):**
    
    Rust
    
    ```
    // async fn handle_upower_property_changes_stream(
    //     mut stream: zbus::fdo::PropertiesChangedStream<'_>, // Korrekter Stream-Typ
    //     event_publisher: tokio::sync::broadcast::Sender<UPowerEvent>,
    // ) {
    //     while let Some(signal) = stream.next().await {
    //         if let Ok(args) = signal.args() {
    //             if args.interface_name() == "org.freedesktop.UPower" {
    //                 if args.changed_properties().contains_key("LidIsClosed") {
    //                     if let Some(Value::Bool(closed)) = args.changed_properties().get("LidIsClosed") {
    //                         event_publisher.send(UPowerEvent::LidStateChanged(*closed)).ok();
    //                     }
    //                 }
    //                 if args.changed_properties().contains_key("OnBattery") {
    //                    // ... ähnlich ...
    //                    event_publisher.send(UPowerEvent::PowerSupplyChanged).ok(); // Generisches Event
    //                 }
    //             }
    //         }
    //     }
    // }
    ```
    

**Datei:** `src/dbus_interfaces/upower_client/mod.rs`

- `pub mod types;`
- `pub mod proxies;` // Ist oft intern, wenn Service die Fassade ist
- `pub mod service;`
- `pub use service::UPowerClientService;`
- `pub use types::{PowerDeviceDetails, PowerDeviceType, PowerState, UPowerEvent};`

#### 3.3. Implementierungsschritte `system::dbus_interfaces::upower_client`

1. **Grundgerüst**: Verzeichnis, `mod.rs`.
2. **`types.rs`**: `PowerDeviceType`, `PowerState`, `PowerDeviceDetails`, `UPowerEvent` definieren. `serde` und `zbus::zvariant::Type` implementieren.
3. **`proxies.rs`**: `UPowerProxy` und `UPowerDeviceProxy` mit `#[zbus::proxy]` definieren. Alle relevanten Methoden und Properties aus der UPower-Spezifikation aufnehmen.
4. **`service.rs`**: `UPowerClientService`-Struktur definieren.
    - `new()`-Konstruktor: D-Bus-Verbindung herstellen, Hauptproxy erstellen.
    - `initialize_and_listen()`: Initiale Geräte laden, Signal-Handler für `DeviceAdded`/`Removed` und `PropertiesChanged` (sowohl auf Hauptproxy als auch auf Geräteproxies) einrichten. Diese Handler laufen in eigenen `tokio::spawn`-Tasks.
    - `add_device_proxy()`: Erstellt, speichert und abonniert Signale für einen Geräteproxy.
    - Öffentliche Getter-Methoden (`get_all_device_details`, `is_lid_closed`, etc.) implementieren, die Properties von den Proxies abrufen.
5. **Event-Publishing**: Sicherstellen, dass bei relevanten Signalempfängen oder Zustandsänderungen die definierten `UPowerEvent`s über den `event_publisher` gesendet werden.
6. **Fehlerbehandlung**: Alle `zbus::Error`-Fälle in `DBusInterfaceError` umwandeln und propagieren.
7. **Unit-/Integrationstests**:
    - **Schwierig ohne laufenden D-Bus-Dienst.** Man könnte `zbus::MockConnection` verwenden, um D-Bus-Interaktionen zu mocken.
    - Testen der Proxy-Generierung.
    - Testen der Property-Abfrage-Logik gegen einen gemockten Dienst.
    - Testen der Signal-Verarbeitung (indem man Signale im Mock simuliert).
    - Testen der korrekten Event-Erzeugung.

---

**Nächste Schritte für `system::dbus_interfaces` (Skizze für weitere Dienste):**

- **`logind_client`**:
    - **Zweck:** Interaktion mit `org.freedesktop.login1` für Sitzungsmanagement (Sperren, Suspend, Shutdown-Signale).
    - **Proxies:** `LogindManagerProxy` (`/org/freedesktop/login1`), `LogindSessionProxy` (`/org/freedesktop/login1/session/self`).
    - **Signale:** `PrepareForShutdown`, `PrepareForSleep`, `Lock`, `Unlock` auf Session-Objekt.
    - **Events:** `LogindEvent::PrepareForShutdown(bool is_reboot)`, `LogindEvent::PrepareForSleep(bool is_suspending)`, `LogindEvent::SessionLocked`, `LogindEvent::SessionUnlocked`.
    - **Methoden:** `LockSession()`, `UnlockSession()`, `CanSuspend()`, `Suspend(bool interactive)`, etc. an Domäne weiterleiten oder von dort empfangen.
- **`network_manager_client`**:
    - **Zweck:** Abfrage von Netzwerkstatus, verfügbaren Verbindungen, Signalstärke (WLAN), IP-Adressen.
    - **Proxies:** `NetworkManagerProxy`, `NMDeviceProxy`, `NMActiveConnectionProxy`, `NMAccessPointProxy`, etc.
    - **Signale:** `StateChanged`, `DeviceAdded/Removed`, `PropertiesChanged` auf verschiedenen Objekten.
    - **Events:** `NetworkEvent::ConnectivityChanged(ConnectivityState)`, `NetworkEvent::WifiDeviceAdded/Removed`, `NetworkEvent::WiredDeviceAdded/Removed`, `NetworkEvent::ActiveConnectionChanged { ... }`.
    - **Typen:** `ConnectivityState` (Disconnected, Connecting, Limited, Full), `NetworkDeviceDetails`, `ActiveConnectionDetails`.
- **`notifications_server`**:
    - **Zweck:** Implementierung des `org.freedesktop.Notifications` D-Bus-Servers.
    - **Technologie:** `zbus` Server-Fähigkeiten (`#[dbus_interface(...)]` auf einem Struct).
    - **Methoden (D-Bus):** `Notify`, `CloseNotification`, `GetCapabilities`, `GetServerInformation`.
    - **Interaktion:** Leitet `Notify`-Aufrufe an `domain::user_centric_services::NotificationService::post_notification` weiter.
    - **Signale (D-Bus):** `NotificationClosed`, `ActionInvoked`. Reagiert auf `NotificationDismissedEvent` und `NotificationActionInvokedEvent` aus der Domäne, um diese D-Bus-Signale zu senden.
- **`secrets_service_client`**:
    - **Zweck:** Client für `org.freedesktop.secrets` zum sicheren Speichern und Abrufen von Geheimnissen (z.B. API-Keys für `mcp_client`).
    - **Proxies:** `SecretServiceProxy`, `SecretCollectionProxy`, `SecretItemProxy`.
    - **Methoden:** `CreateCollection`, `CreateItem`, `GetSecret`, `SearchItems`, `Unlock`.
    - **Interaktion:** Wird von anderen Systemmodulen (z.B. `mcp_client`) oder ggf. Domänendiensten genutzt. UI-Interaktion für Prompts (Unlock) wird oft vom Secret Service selbst gehandhabt (z.B. GNOME Keyring).
- **`policykit_client`**:
    - **Zweck:** Client für `org.freedesktop.PolicyKit1.Authority` zur Autorisierung privilegierter Aktionen.
    - **Proxy:** `PolicyKitAuthorityProxy`.
    - **Methode:** `CheckAuthorization`.
    - **Interaktion:** Wird von System- oder Domänenmodulen aufgerufen, bevor eine privilegierte Aktion ausgeführt wird. UI-Interaktion für Passwortabfragen wird vom PolicyKit-Agenten des Systems gehandhabt.
- **`xdg_desktop_portal_handler`**:
    - **Zweck:** Dies ist kein Client, sondern die Backend-Logik, die von den XDG Desktop Portal D-Bus-Server-Implementierungen (die NovaDE bereitstellt) aufgerufen wird.
    - **Schnittstellen:** Definiert Traits oder konkrete Methoden, die von den Portal-D-Bus-Objekten aufgerufen werden.
    - **Beispiele:**
        - Für `org.freedesktop.portal.FileChooser`: `async fn open_file_dialog(...) -> Result<Vec<PathBuf>, PortalError>`. Interagiert mit der UI-Schicht, um den Dialog anzuzeigen.
        - Für `org.freedesktop.portal.Screenshot`: `async fn take_screenshot(interactive: bool, region: Option<RectInt>) -> Result<PathBuf, PortalError>`. Interagiert mit `system::compositor::screencopy`.
        - Für `org.freedesktop.portal.ScreenCast`: Interagiert mit Compositor und PipeWire.
    - **Wichtig:** Die eigentlichen D-Bus-Server-Objekte für die Portale werden typischerweise in einem separaten Prozess oder zumindest einem dedizierten D-Bus-Dienst innerhalb von NovaDE laufen. Dieses Modul hier liefert die Logik, die diese D-Bus-Methoden ausführt.

Diese detaillierte Ausarbeitung für `system::dbus_interfaces::upower_client` und die Skizzen für die weiteren Dienste legen einen klaren Pfad für die Implementierung der D-Bus-Interaktionen fest. Jedes Client-Modul erfordert sorgfältige Definition der Proxy-Interfaces und die Übersetzung der D-Bus-spezifischen Daten und Signale in die internen Strukturen und Events von NovaDE.

---

### Modul 3: `system::dbus_interfaces` (Fortsetzung)

#### 3.4. Submodul: `system::dbus_interfaces::logind_client`

Zweck: Client für den org.freedesktop.login1 Dienst zur Abfrage und Steuerung von Sitzungsinformationen und Systemzuständen (Suspend, Shutdown).

Interaktion mit Domäne: Sendet LogindEvents an die Domänenschicht (z.B. domain::power_management_policy, domain::common_events). Empfängt Befehle (z.B. LockSession) von der Domäne oder UI über die Domäne.

**Datei:** `src/dbus_interfaces/logind_client/types.rs`

- **Event-Struktur (für `system::event_bridge` oder direkt an Domänen-Services):**
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use crate::dbus_interfaces::common::DBusObjectPath; // Typalias für String oder OwnedObjectPath
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub enum LogindPowerOperation {
        Suspend,
        Hibernate,
        HybridSleep,
        SuspendThenHibernate,
        Reboot,
        PowerOff,
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum LogindEvent {
        PrepareForShutdown(bool /* is_reboot */),
        PrepareForSleep(bool /* is_suspending_to_ram_not_disk */), // true für Suspend, false für Hibernate
        SessionLocked(DBusObjectPath /* session_id */),
        SessionUnlocked(DBusObjectPath /* session_id */),
        SessionRemoved(DBusObjectPath /* session_id */),
        SystemIdleHintChanged(bool /* is_idle */), // Falls logind IdleHint sendet
    }
    
    #[derive(Debug, Clone, Type, Serialize, Deserialize, PartialEq)] // zbus::zvariant::Type
    pub struct SessionDetails {
        pub id: String, // Session ID
        pub user_id: u32,
        pub user_name: String,
        pub seat_id: String,
        pub seat_path: DBusObjectPath,
        pub vtnr: u32,
        pub display: String, // z.B. ":0"
        pub remote: bool,
        pub remote_host: String,
        pub remote_user: String,
        pub service: String, // z.B. "gdm-password", "tty"
        pub desktop: String, // z.B. "NovaDE"
        pub scope: String, // z.B. "system-user"
        pub leader_pid: u32,
        pub audit_session_id: u32,
        pub session_class: String, // z.B. "user"
        pub session_type: String, // z.B. "wayland", "x11"
        pub active: bool,
        pub state: String, // z.B. "active", "online", "closing"
        pub idle_hint: bool,
        pub idle_since_hint_usec: u64, // Mikrosekunden
        pub locked_hint: bool,
    }
    ```
    

**Datei:** `src/dbus_interfaces/logind_client/proxies.rs`

- **`LogindManagerProxy` für `org.freedesktop.login1.Manager` auf `/org/freedesktop/login1`**:
    
    Rust
    
    ```
    use zbus::{proxy, zvariant::{OwnedObjectPath, Type, Value, Dict}};
    use super::types::SessionDetails;
    
    #[proxy(
        interface = "org.freedesktop.login1.Manager",
        default_service = "org.freedesktop.login1",
        default_path = "/org/freedesktop/login1"
    )]
    trait LogindManager {
        fn get_session(&self, session_id: &str) -> zbus::Result<OwnedObjectPath>;
        fn get_session_by_pid(&self, pid: u32) -> zbus::Result<OwnedObjectPath>;
        fn get_user(&self, uid: u32) -> zbus::Result<OwnedObjectPath>;
        fn get_user_by_pid(&self, pid: u32) -> zbus::Result<OwnedObjectPath>;
        fn get_seat(&self, seat_id: &str) -> zbus::Result<OwnedObjectPath>;
        fn list_sessions(&self) -> zbus::Result<Vec<(String, u32, String, String, OwnedObjectPath)>>; // (id, uid, user, seat, path)
        fn list_users(&self) -> zbus::Result<Vec<(u32, String, OwnedObjectPath)>>; // (uid, name, path)
        fn list_seats(&self) -> zbus::Result<Vec<(String, OwnedObjectPath)>>; // (id, path)
    
        fn inhibit(&self, what: &str, who: &str, why: &str, mode: &str) -> zbus::Result<zbus::zvariant::Fd>; // Returns FD for inhibitor lock
        fn can_power_off(&self) -> zbus::Result<String>; // "yes", "no", "challenge"
        fn can_reboot(&self) -> zbus::Result<String>;
        fn can_suspend(&self) -> zbus::Result<String>;
        fn can_hibernate(&self) -> zbus::Result<String>;
        fn can_hybrid_sleep(&self) -> zbus::Result<String>;
        fn can_suspend_then_hibernate(&self) -> zbus::Result<String>;
    
        fn power_off(&self, interactive: bool) -> zbus::Result<()>;
        fn reboot(&self, interactive: bool) -> zbus::Result<()>;
        fn suspend(&self, interactive: bool) -> zbus::Result<()>;
        fn hibernate(&self, interactive: bool) -> zbus::Result<()>;
        fn hybrid_sleep(&self, interactive: bool) -> zbus::Result<()>;
        fn suspend_then_hibernate(&self, interactive: bool) -> zbus::Result<()>;
        // TerminateSeat, TerminateSession, TerminateUser...
    
        #[zbus(signal)]
        fn session_new(&self, session_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn session_removed(&self, session_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn seat_new(&self, seat_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn seat_removed(&self, seat_id: String, object_path: OwnedObjectPath) -> zbus::Result<()>;
        #[zbus(signal)]
        fn prepare_for_shutdown(&self, start: bool) -> zbus::Result<()>; // true = about to shut down, false = cancelled
        #[zbus(signal)]
        fn prepare_for_sleep(&self, start: bool) -> zbus::Result<()>;   // true = about to suspend/hibernate, false = cancelled
    }
    ```
    
- **`LogindSessionProxy` für `org.freedesktop.login1.Session` (dynamischer Pfad)**:
    
    Rust
    
    ```
    #[proxy(
        interface = "org.freedesktop.login1.Session",
        default_service = "org.freedesktop.login1"
    )]
    trait LogindSession {
        fn terminate(&self) -> zbus::Result<()>;
        fn activate(&self) -> zbus::Result<()>;
        fn lock(&self) -> zbus::Result<()>;
        fn unlock(&self) -> zbus::Result<()>;
        fn set_idle_hint(&self, idle: bool) -> zbus::Result<()>;
        fn set_locked_hint(&self, locked: bool) -> zbus::Result<()>;
        // Kill(who: &str, signal_number: i32)
        // TakeControl(force: bool)
        // ReleaseControl()
        // TakeDevice(major: u32, minor: u32) -> zbus::Result<(zbus::zvariant::Fd, bool)>
        // ReleaseDevice(major: u32, minor: u32)
        // PauseDeviceComplete(major: u32, minor: u32)
        // SetBrightness(subsystem: &str, name: &str, value: u32)
    
        // Properties (viele, können über Properties.GetAll abgerufen werden)
        #[zbus(property)] fn id(&self) -> zbus::Result<String>;
        #[zbus(property)] fn user(&self) -> zbus::Result<(u32, OwnedObjectPath)>; // (uid, user_path)
        #[zbus(property)] fn name(&self) -> zbus::Result<String>; // Username
        #[zbus(property)] fn timestamp(&self) -> zbus::Result<u64>; // usec
        #[zbus(property)] fn timestamp_monotonic(&self) -> zbus::Result<u64>; // usec
        #[zbus(property)] fn vtnr(&self) -> zbus::Result<u32>;
        #[zbus(property)] fn seat(&self) -> zbus::Result<(String, OwnedObjectPath)>; // (seat_id, seat_path)
        #[zbus(property)] fn display(&self) -> zbus::Result<String>;
        #[zbus(property)] fn remote(&self) -> zbus::Result<bool>;
        #[zbus(property)] fn remote_host(&self) -> zbus::Result<String>;
        #[zbus(property)] fn remote_user(&self) -> zbus::Result<String>;
        #[zbus(property)] fn service(&self) -> zbus::Result<String>;
        #[zbus(property)] fn desktop(&self) -> zbus::Result<String>;
        #[zbus(property)] fn scope(&self) -> zbus::Result<String>;
        #[zbus(property)] fn leader(&self) -> zbus::Result<u32>; // PID
        #[zbus(property)] fn audit(&self) -> zbus::Result<u32>; // Audit Session ID
        #[zbus(property, name = "Class")] fn class_prop(&self) -> zbus::Result<String>; // "user", "greeter", ...
        #[zbus(property, name = "Type")] fn type_prop(&self) -> zbus::Result<String>;   // "x11", "wayland", "tty"
        #[zbus(property)] fn active(&self) -> zbus::Result<bool>;
        #[zbus(property)] fn state(&self) -> zbus::Result<String>;
        #[zbus(property)] fn idle_hint(&self) -> zbus::Result<bool>;
        #[zbus(property)] fn idle_since_hint(&self) -> zbus::Result<u64>; // usec
        #[zbus(property)] fn locked_hint(&self) -> zbus::Result<bool>;
    
        #[zbus(signal)]
        fn pause_device(&self, major: u32, minor: u32, type_: &str) -> zbus::Result<()>; // type: "pause", "force-pause", "timeout-pause"
        #[zbus(signal)]
        fn resume_device(&self, major: u32, minor: u32, fd_idx: zbus::zvariant::Fd, type_: &str) -> zbus::Result<()>; // type: "resume"
        #[zbus(signal)]
        fn lock(&self) -> zbus::Result<()>; // Sitzung wurde gesperrt
        #[zbus(signal)]
        fn unlock(&self) -> zbus::Result<()>; // Sitzung wurde entsperrt
    }
    ```
    

**Datei:** `src/dbus_interfaces/logind_client/service.rs`

- **Struct `LogindClientService`**:
    - **Felder:** `connection: Arc<Connection>`, `manager_proxy: LogindManagerProxy<'static>`, `session_proxies: Arc<tokio::sync::Mutex<HashMap<String /*session_id*/, LogindSessionProxy<'static>>>>`, `event_publisher: tokio::sync::broadcast::Sender<LogindEvent>`.
    - **Konstruktor `new(...)`**: Stellt Verbindung her, erstellt `manager_proxy`.
    - **Methode `initialize_and_listen()`**:
        1. `list_sessions()` vom `manager_proxy` abrufen, um initiale Sessions zu cachen und ggf. Proxies zu erstellen.
        2. `LogindManagerProxy`-Signale abonnieren (`SessionNew`, `SessionRemoved`, `PrepareForShutdown`, `PrepareForSleep`).
            - `SessionNew`: Erstelle `LogindSessionProxy`, speichere in `session_proxies`, abonniere dessen `Lock`/`Unlock`-Signale.
            - `SessionRemoved`: Entferne Proxy.
            - `PrepareForShutdown/Sleep`: Sende `LogindEvent` an `event_publisher`.
        3. `LogindSessionProxy`-Signale (`Lock`, `Unlock`) für jede aktive Session abonnieren und entsprechende `LogindEvent`s senden.
    - **Öffentliche Methoden (Beispiele):**
        - `pub async fn get_current_session_details(&self) -> Result<Option<SessionDetails>, DBusInterfaceError>`: Ruft `GetSessionByPid(std::process::id())` auf, dann alle Properties vom Session-Proxy.
        - `pub async fn lock_current_session(&self) -> Result<(), DBusInterfaceError>`: Ruft `Lock()` auf dem aktuellen Session-Proxy auf.
        - `pub async fn can_power_off(&self) -> Result<String, DBusInterfaceError>`: Ruft `manager_proxy.can_power_off()`.
        - `pub async fn power_off(&self, interactive: bool) -> Result<(), DBusInterfaceError>`: Ruft `manager_proxy.power_off(interactive)`. (Benötigt PolicyKit-Autorisierung, die von logind gehandhabt wird).

**Implementierungsschritte `logind_client`**:

1. `types.rs`: `LogindEvent`, `SessionDetails`, `LogindPowerOperation` definieren.
2. `proxies.rs`: `LogindManagerProxy` und `LogindSessionProxy` definieren.
3. `service.rs`: `LogindClientService` implementieren (Konstruktor, Initialisierung/Signal-Listener, öffentliche Methoden).
4. Tests mit gemockter D-Bus-Verbindung.

---

#### 3.5. Submodul: `system::dbus_interfaces::network_manager_client`

Zweck: Client für org.freedesktop.NetworkManager.

Interaktion: Sendet NetworkManagerEvents.

(Struktur analog zu upower_client und logind_client)

- **`types.rs`**: Enums (`NMState`, `NMDeviceType`, `NMConnectivityState`), Structs (`NetworkDeviceDetails`, `AccessPointDetails`, `ActiveConnectionDetails`), Event (`NetworkManagerEvent`).
- **`proxies.rs`**: `NetworkManagerProxy`, `NMDeviceProxy`, `NMActiveConnectionProxy`, `NMAccessPointProxy`, `NMSettingsConnectionProxy` etc.
- **`service.rs`**: `NetworkManagerClientService` mit Logik zum Auflisten von Geräten, Verbindungen, APs; Abonnieren von `StateChanged`, `DeviceAdded/Removed`, `PropertiesChanged` etc.

---

#### 3.6. Submodul: `system::dbus_interfaces::secrets_service_client`

Zweck: Client für org.freedesktop.Secret.Service.

Interaktion: Stellt Methoden zum Speichern/Abrufen von Geheimnissen bereit, die von anderen Systemmodulen (z.B. mcp_client) genutzt werden.

(Struktur analog zu upower_client)

- **`types.rs`**: Structs (`Secret`, `SecretItemAttributes`).
- **`proxies.rs`**: `SecretServiceProxy`, `SessionProxy` (für D-Bus-Session der Secret Service API), `CollectionProxy`, `ItemProxy`, `PromptProxy`.
- **`service.rs`**: `SecretsServiceClientService` mit Methoden wie `async fn store_secret(collection_alias: &str, label: &str, secret_content: &[u8], attributes: HashMap<String, String>, replace: bool) -> Result<DBusObjectPath, DBusInterfaceError>`, `async fn retrieve_secret(item_path: &DBusObjectPath) -> Result<Vec<u8>, DBusInterfaceError>`, `async fn search_items(attributes: HashMap<String, String>) -> Result<Vec<DBusObjectPath>, DBusInterfaceError>`. Handhabt Unlock-Prompts (oft delegiert an den Secret Service Agenten).

---

#### 3.7. Submodul: `system::dbus_interfaces::policykit_client`

Zweck: Client für org.freedesktop.PolicyKit1.Authority.

Interaktion: Stellt eine Methode zur Autorisierungsprüfung bereit.

(Struktur analog, aber einfacher, da meist nur eine Hauptmethode)

- **`types.rs`**: Enum `PolicyKitAuthorizationResult` (allow, challenge, deny). Structs für `Subject` (pid, uid), `ActionId`.
- **`proxies.rs`**: `PolicyKitAuthorityProxy`.
- **`service.rs`**: `PolicyKitClientService` mit Methode `async fn check_authorization(action_id: &str, subject_pid: Option<u32>, details: HashMap<String, String>, flags: u32 /* PolicyKitCheckAuthorizationFlags */) -> Result<PolicyKitAuthorizationResult, DBusInterfaceError>`.

---

#### 3.8. Submodul: `system::dbus_interfaces::notifications_server`

Zweck: Implementierung des org.freedesktop.Notifications D-Bus-Servers.

Interaktion: Empfängt Notify-Aufrufe und leitet sie an domain::user_centric_services::NotificationService weiter. Sendet NotificationClosed und ActionInvoked Signale basierend auf Events aus der Domänenschicht.

**Datei:** `src/dbus_interfaces/notifications_server/mod.rs` (kann `interface.rs`, `service_object.rs` enthalten)

- **Struct `FreedesktopNotificationsServer`** (Das D-Bus-Objekt):
    
    Rust
    
    ```
    use zbus::dbus_interface;
    use crate::domain::user_centric_services::{NotificationService, Notification, NotificationUrgency as DomainUrgency, NotificationAction as DomainAction}; // Domain Traits/Typen
    use crate::domain::user_centric_services::notifications_core::types::NotificationInput; // Für Notify
    use crate::domain::shared_types::ApplicationId;
    use std::sync::Arc;
    use tokio::sync::Mutex; // Für NotificationService Handle
    use zbus::zvariant::{Value, Dict, Array};
    use zbus::SignalContext;
    use super::common::DBusInterfaceError; // Eigener Fehlertyp
    
    pub struct FreedesktopNotificationsServer {
        notification_service: Arc<Mutex<dyn NotificationService>>, // Injizierter Domain-Service
        // Ggf. ein tokio::sync::broadcast::Receiver für Domain-Events (NotificationDismissedEvent etc.)
        // um D-Bus Signale zu senden.
    }
    
    impl FreedesktopNotificationsServer {
        pub fn new(notification_service: Arc<Mutex<dyn NotificationService>>) -> Self {
            Self { notification_service }
            // Hier den Event-Receiver von notification_service abonnieren und Task starten,
            // der Domain-Events in D-Bus-Signale umwandelt.
        }
    
        // Hilfsmethode zur Konvertierung von D-Bus Urgency zu Domain Urgency
        fn to_domain_urgency(level: u8) -> DomainUrgency {
            match level {
                0 => DomainUrgency::Low,
                1 => DomainUrgency::Normal,
                2 => DomainUrgency::Critical,
                _ => DomainUrgency::Normal, // Fallback
            }
        }
    }
    
    #[dbus_interface(name = "org.freedesktop.Notifications")]
    impl FreedesktopNotificationsServer {
        async fn get_capabilities(&self) -> Vec<String> {
            // Fähigkeiten, die NovaDE unterstützt, z.B. "body", "actions", "persistence", "icon-static"
            vec![
                "body".to_string(),
                "actions".to_string(),
                "persistence".to_string(), // Wenn Benachrichtigungen gespeichert werden
                "icon-static".to_string(),
                "body-markup".to_string(), // Wenn Pango-Markup im Body unterstützt wird
                // "sound"
            ]
        }
    
        async fn notify(
            &self,
            app_name: String,
            replaces_id: u32, // ID der zu ersetzenden Benachrichtigung (0 für neue)
            app_icon: String,  // Icon-Name oder Pfad
            summary: String,
            body: String,
            actions: Vec<String>, // Actions als flache Liste: [key1, label1, key2, label2, ...]
            hints: Dict<'_, String, Value<'_>>, // zbus Dict für a{sv}
            expire_timeout: i32, // Millisekunden, -1 für Default, 0 für persistent (laut Spezifikation)
        ) -> Result<u32, zbus::fdo::Error> { // Gibt die neue Notification ID zurück
            tracing::info!("D-Bus Notify: app='{}', summary='{}'", app_name, summary);
    
            let mut domain_actions = Vec::new();
            for chunk in actions.chunks_exact(2) {
                domain_actions.push(DomainAction {
                    key: chunk[0].clone(),
                    label: chunk[1].clone(),
                    // action_type wird hier nicht direkt übergeben, müsste ggf. aus Hints oder Konvention abgeleitet werden
                    // oder Aktionen sind immer "Callback" für D-Bus.
                    action_type: crate::domain::user_centric_services::notifications_core::types::NotificationActionType::Callback,
                });
            }
    
            let urgency_hint = hints.get("urgency")
                .and_then(|v| v.downcast_ref::<Value<'_>>()) // Value in Value ist seltsam, eher direkt u8 oder byte
                .and_then(|v_inner| v_inner.try_into().ok()) // u8
                .map(Self::to_domain_urgency)
                .unwrap_or(DomainUrgency::Normal);
    
            let category_hint = hints.get("category")
                                .and_then(|v| v.downcast_ref::<String>())
                                .cloned();
    
            // TODO: 'replaces_id' Logik implementieren (alte Notification mit dieser ID entfernen/aktualisieren)
            // TODO: 'app_icon' und 'hints' genauer verarbeiten (image-data, sound etc.)
    
            let notification_input = NotificationInput {
                application_name: app_name, // Optional: ApplicationId::new(app_name)
                application_icon: if app_icon.is_empty() { None } else { Some(app_icon) },
                summary,
                body: if body.is_empty() { None } else { Some(body) },
                actions: domain_actions,
                urgency: urgency_hint,
                transient: hints.get("transient").and_then(|v| v.try_into().ok()).unwrap_or(false),
                category: category_hint,
                hints: hints.iter().map(|(k,v)| (k.to_string(), serde_json::to_value(v).unwrap_or(serde_json::Value::Null))).collect(), // Konvertiere zbus::Value zu serde_json::Value
                timeout_ms: if expire_timeout == 0 { Some(0) } // 0 für persistent laut D-Bus
                             else if expire_timeout > 0 { Some(expire_timeout as u32) }
                             else { None }, // -1 für Default
            };
    
            let mut service_guard = self.notification_service.lock().await;
            match service_guard.post_notification(notification_input).await {
                // Die zurückgegebene u32 ID muss für D-Bus eindeutig sein.
                // Der Domain-Service verwendet Uuid. Hier muss eine Abbildung erfolgen,
                // z.B. eine laufende u32-ID, die der Uuid zugeordnet wird.
                // Für Einfachheit hier: Hash der Uuid (nicht ideal, da Kollisionen möglich)
                // Besser: Map<Uuid, u32> im Server halten.
                Ok(domain_id) => {
                    let dbus_id =贫穷的男子哈希(domain_id); // Vereinfacht
                    Ok(dbus_id)
                }
                Err(e) => {
                    tracing::error!("Fehler beim Posten der Benachrichtigung an den Domain-Service: {:?}", e);
                    Err(zbus::fdo::Error::Failed(format!("Interner Fehler beim Verarbeiten der Benachrichtigung: {}", e)))
                }
            }
        }
    
        async fn close_notification(&self, id: u32) -> zbus::fdo::Result<()> {
            tracing::info!("D-Bus CloseNotification für ID: {}", id);
            // TODO: ID von u32 (D-Bus) zu Uuid (Domain) mappen
            // let domain_id = map_dbus_id_to_domain_id(id);
            // let mut service_guard = self.notification_service.lock().await;
            // match service_guard.dismiss_notification(domain_id).await {
            //     Ok(_) => Ok(()),
            //     Err(domain::user_centric_services::NotificationError::NotFound(_)) => {
            //         // Gemäß Spezifikation kein Fehler, wenn ID unbekannt ist
            //         Ok(())
            //     }
            //     Err(e) => Err(zbus::fdo::Error::Failed(format!("Fehler beim Schließen: {}", e))),
            // }
            Ok(()) // Platzhalter
        }
    
        async fn get_server_information(&self) -> (String, String, String, String) {
            (
                "NovaDE Notification Server".to_string(), // name
                "NovaDE Team".to_string(),                // vendor
                "0.1.0".to_string(),                      // version
                "1.2".to_string(),                        // spec_version
            )
        }
    
        #[dbus_interface(signal)]
        async fn notification_closed(ctxt: &SignalContext<'_>, id: u32, reason: u32) -> zbus::Result<()>;
        // reason: 1=expired, 2=dismissed by user, 3=closed by call to CloseNotification, 4=undefined
    
        #[dbus_interface(signal)]
        async fn action_invoked(ctxt: &SignalContext<'_>, id: u32, action_key: String) -> zbus::Result<()>;
    }
    ```
    
- **Logik zur Signal-Weiterleitung:**
    - Der `FreedesktopNotificationsServer` muss `NotificationDismissedEvent` und `NotificationActionInvokedEvent` vom `NotificationService` abonnieren.
    - Wenn ein `NotificationDismissedEvent { notification_id, reason }` empfangen wird:
        - `dbus_id = map_domain_id_to_dbus_id(notification_id);`
        - `dbus_reason = match reason { DismissReason::User => 2, DismissReason::Timeout => 1, ... };`
        - `FreedesktopNotificationsServer::notification_closed(ctxt, dbus_id, dbus_reason).await;` (Benötigt `SignalContext`).
    - Wenn ein `NotificationActionInvokedEvent { notification_id, action_key }` empfangen wird:
        - `dbus_id = map_domain_id_to_dbus_id(notification_id);`
        - `FreedesktopNotificationsServer::action_invoked(ctxt, dbus_id, action_key).await;`

#### 3.9. Implementierungsschritte `system::dbus_interfaces` (Fortsetzung)

5. **`logind_client` implementieren**: Typen, Proxies, Service. Signal-Handler für `PrepareForShutdown/Sleep`, `SessionNew/Removed`, `Lock/Unlock`. Tests.
6. **`network_manager_client` implementieren**: Typen, Proxies, Service. Signal-Handler für relevante NM-Signale. Tests.
7. **`secrets_service_client` implementieren**: Typen, Proxies, Service. Methoden für Speichern/Abrufen. Tests.
8. **`policykit_client` implementieren**: Typen, Proxy, Service. `check_authorization`-Methode. Tests.
9. **`notifications_server` implementieren**:
    - D-Bus-Interface-Struct `FreedesktopNotificationsServer`.
    - Implementierung der Methoden (`Notify`, `CloseNotification`, etc.), die den `domain::NotificationService` aufrufen.
    - ID-Mapping zwischen D-Bus `u32` und Domain `Uuid` implementieren (z.B. `HashMap<u32, Uuid>` und `HashMap<Uuid, u32>`).
    - Task starten, der Domain-Events (`NotificationDismissedEvent`, `NotificationActionInvokedEvent`) abonniert und entsprechende D-Bus-Signale (`notification_closed`, `action_invoked`) über den `SignalContext` sendet.
    - Registrierung des D-Bus-Objekts auf dem Session-Bus.
10. **`xdg_desktop_portal_handler`** (wird später detailliert, da es von UI-Dialogen und Compositor-Funktionen abhängt).

---

### Modul 4: `system::audio_management`

Zweck: Integration mit PipeWire zur Steuerung der Systemlautstärke, Auswahl von Audio-Geräten und Verwaltung von Anwendungs-Streams.

Verantwortlichkeiten: Aufbau und Verwaltung der PipeWire-Verbindung, Auflisten von Audio-Geräten (Sinks, Sources) und Streams, Setzen/Abfragen von Lautstärke und Mute-Status, Auswahl von Standardgeräten.

Design-Rationale: PipeWire als moderner Standard für Audio unter Linux. Kapselung der PipeWire-spezifischen Logik. Bereitstellung einer abstrahierten Schnittstelle für die Domänen- und UI-Schicht.

Technologie: pipewire-rs Crate.

#### 4.1. Submodul: `system::audio_management::types`

**Datei:** `src/audio_management/types.rs`

- **Enum `AudioDeviceType`**:
    
    Rust
    
    ```
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub enum AudioDeviceType {
        Sink,    // Wiedergabegerät (z.B. Lautsprecher, Kopfhörer)
        Source,  // Aufnahmegerät (z.B. Mikrofon)
        Other,
    }
    ```
    
- **Struct `AudioDevice`**:
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    use uuid::Uuid; // Interne ID für das Domänenobjekt
    
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct AudioDevice {
        pub internal_id: Uuid, // Eigene ID, da PipeWire IDs u32 sind und sich ändern können
        pub pipewire_id: u32,  // Die aktuelle PipeWire Node ID
        pub name: String,      // z.B. "alsa_output.pci-0000_00_1f.3.analog-stereo"
        pub description: String, // Menschenlesbar, z.B. "Built-in Audio Analog Stereo"
        pub device_type: AudioDeviceType,
        pub volume_percent: u8, // 0-100 (oder höher, falls >100% unterstützt)
        pub is_muted: bool,
        pub is_default: bool,   // Ob es das Standardgerät seines Typs ist
        // Optional: channel_map, sample_format, etc.
    }
    ```
    
- **Struct `AudioStream`** (repräsentiert einen Anwendungs-Audiostream):
    
    Rust
    
    ```
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct AudioStream {
        pub internal_id: Uuid,
        pub pipewire_id: u32, // PipeWire Client/Stream ID
        pub application_name: Option<String>, // Name der Anwendung, die den Stream erzeugt
        pub media_role: Option<String>, // z.B. "Music", "Video", "Game", "Notification"
        pub volume_percent: u8,
        pub is_muted: bool,
        pub target_device_pw_id: Option<u32>, // PipeWire ID des Geräts, mit dem der Stream verbunden ist
    }
    ```
    
- **Event-Struktur (für `system::event_bridge` oder direkt an Domäne):**
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum AudioEvent {
        DeviceListChanged(Vec<AudioDevice>),
        DefaultDeviceChanged { device_type: AudioDeviceType, new_default_pw_id: Option<u32> },
        DeviceVolumeChanged { device_pw_id: u32, new_volume_percent: u8, is_muted: bool },
        StreamListChanged(Vec<AudioStream>),
        StreamVolumeChanged { stream_pw_id: u32, new_volume_percent: u8, is_muted: bool },
        ServerConnectionStateChanged(bool /* is_connected */),
    }
    ```
    

#### 4.2. Submodul: `system::audio_management::errors`

**Datei:** `src/audio_management/errors.rs`

- **Enum `AudioManagementError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    
    #[derive(Debug, Error)]
    pub enum AudioManagementError {
        #[error("PipeWire connection failed: {0}")]
        ConnectionFailed(String),
        #[error("PipeWire context error: {0}")]
        ContextError(String),
        #[error("PipeWire main loop error: {0}")]
        MainLoopError(String),
        #[error("PipeWire core error: {0}")]
        CoreError(String), // Generischer Fehler von pipewire-rs
        #[error("Failed to create PipeWire proxy or object: {0}")]
        ProxyCreationFailed(String),
        #[error("PipeWire object not found (ID: {0})")]
        ObjectNotFound(u32),
        #[error("Invalid parameter for PipeWire operation: {0}")]
        InvalidParameter(String),
        #[error("Operation timed out: {0}")]
        Timeout(String),
        #[error("Type conversion error in PipeWire data: {0}")]
        TypeConversionError(String),
        #[error("Audio device or stream is in an unexpected state: {0}")]
        InvalidState(String),
        #[error("An internal error occurred in audio management: {0}")]
        InternalError(String),
    }
    // Hilfsimplementierungen, um Fehler von pipewire-rs zu wrappen
    impl From<pipewire::Error> for AudioManagementError {
        fn from(err: pipewire::Error) -> Self {
            AudioManagementError::CoreError(err.to_string())
        }
    }
    ```
    

#### 4.3. Submodul: `system::audio_management::client`

**Zweck:** Kernlogik für die PipeWire-Verbindung, Event-Loop-Integration und Objektverwaltung.

**Datei:** `src/audio_management/client/mod.rs` (oder `service.rs`)

- **Struct `PipeWireClientService`**:
    - **Felder:**
        - `main_loop: Arc<pipewire::MainLoop>` (muss in eigenem Thread laufen oder in `calloop` integriert werden)
        - `context: Arc<pipewire::Context>`
        - `core: Arc<pipewire::Core>`
        - `registry: Arc<pipewire::Registry>`
        - `devices: Arc<tokio::sync::RwLock<HashMap<u32 /*pw_id*/, AudioDevice>>>`
        - `streams: Arc<tokio::sync::RwLock<HashMap<u32 /*pw_id*/, AudioStream>>>`
        - `default_sink_id: Arc<tokio::sync::RwLock<Option<u32>>>`
        - `default_source_id: Arc<tokio::sync::RwLock<Option<u32>>>`
        - `event_publisher: tokio::sync::broadcast::Sender<AudioEvent>`
        - `registry_listener: Option<pipewire::registry::Listener>` (muss `'static` sein oder anders verwaltet werden)
        - `core_listener: Option<pipewire::core::CoreListener>`
        - `loop_thread_handle: Option<std::thread::JoinHandle<()>>` (Falls MainLoop in eigenem Thread)
    - **Konstruktor `pub async fn new(event_publisher: tokio::sync::broadcast::Sender<AudioEvent>) -> Result<Self, AudioManagementError>`**:
        1. `pipewire::init()` aufrufen.
        2. `MainLoop::new(None)?` erstellen.
        3. `Context::new(&main_loop)?` erstellen.
        4. `Core::new(&context, None)?` (Verbindung zum PipeWire-Daemon herstellen).
        5. `Registry::new(&core)?` erstellen.
        6. Referenzen (`Arc`) für diese Objekte erstellen.
        7. `registry_listener` einrichten:
            - Im `global` Callback: Objekte filtern nach Typ (`PipewireObject::Node` für Geräte, `PipewireObject::Client` oder `PipewireObject::Stream` für Streams).
            - Für Nodes: Prüfen, ob es Audio Sinks/Sources sind (via Properties). `AudioDevice` erstellen, in `devices` speichern. `AudioEvent::DeviceListChanged` senden.
            - Für Streams: `AudioStream` erstellen, in `streams` speichern. `AudioEvent::StreamListChanged` senden.
            - `Metadata`-Objekt beobachten, um Standardgeräte zu finden (`default.audio.sink`, `default.audio.source`). `AudioEvent::DefaultDeviceChanged` senden.
        8. `core_listener` für `info` (um Server-Verbindungsstatus zu bekommen) und `error` einrichten.
        9. Wenn `main_loop` in eigenem Thread: `std::thread::spawn(move || main_loop_ref.run());`.
        10. Gibt `Self` zurück.
    - **Methode `pub async fn shutdown(&self)`**: Stoppt den `main_loop`-Thread sauber.
    - **Öffentliche Getter-Methoden (Beispiele):**
        - `pub async fn get_audio_devices(&self) -> Vec<AudioDevice>`: Gibt Klon von `self.devices.read().await.values()` zurück.
        - `pub async fn get_audio_streams(&self) -> Vec<AudioStream>`
        - `pub async fn get_default_sink(&self) -> Option<AudioDevice>`
        - `pub async fn get_default_source(&self) -> Option<AudioDevice>`
    - **Öffentliche Setter-Methoden (Beispiele):**
        - `pub async fn set_device_volume(&self, device_pw_id: u32, volume_percent: u8, is_muted: bool) -> Result<(), AudioManagementError>`:
            1. Findet das `Device` oder `Node` Proxy-Objekt für `device_pw_id` (muss im Registry-Handler gecacht werden).
            2. Erstellt `SpaPodBuilder` mit den neuen Lautstärkeparametern (`Props` mit `mute`, `channelVolumes`).
            3. Ruft `node_proxy.set_param("Props", 0, &pod)` auf.
            4. (PipeWire sendet dann über den Listener ein Event über die Volumenänderung, das dann ein `AudioEvent::DeviceVolumeChanged` auslöst).
        - `pub async fn set_stream_volume(...)` (analog).
        - `pub async fn set_default_device(&self, device_pw_id: u32, device_type: AudioDeviceType) -> Result<(), AudioManagementError>`:
            1. Erstellt `Metadata` Proxy für das `core`-Objekt.
            2. Setzt die Eigenschaft `default.audio.sink` oder `default.audio.source` auf die `device_pw_id`.
- **Wichtig:** Die `pipewire-rs` API ist Callback-basiert und integriert sich in eine `MainLoop`. Diese `MainLoop` muss entweder in einem dedizierten Thread laufen oder, falls möglich und komplexer, in die `calloop`-Schleife des Compositors integriert werden (z.B. indem der FD des PipeWire-Loops in `calloop` überwacht wird). Ein eigener Thread für den PipeWire-`MainLoop` ist oft einfacher zu handhaben. Die Kommunikation zwischen diesem Thread und den `async` Methoden des `PipeWireClientService` erfolgt dann über `tokio::sync::mpsc` Kanäle oder indem die `Arc<RwLock<...>>`-geschützten Zustände aktualisiert und `watch` Kanäle für Benachrichtigungen verwendet werden.

#### 4.4. Implementierungsschritte `system::audio_management`

1. **Grundgerüst**: Verzeichnis, `mod.rs`, `Cargo.toml` um `pipewire-rs` und ggf. `libspa` (falls für Pods nötig) erweitern.
2. **`types.rs`**: Alle Audio-bezogenen Typen und Enums (`AudioDeviceType`, `AudioDevice`, `AudioStream`, `AudioEvent`) definieren.
3. **`errors.rs`**: `AudioManagementError` Enum mit `thiserror` und `From<pipewire::Error>` definieren.
4. **`client/mod.rs`**:
    - `PipeWireClientService`-Struktur definieren.
    - `new()`-Konstruktor implementieren: Initialisiert PipeWire-Objekte (`MainLoop`, `Context`, `Core`, `Registry`).
    - `RegistryListener`-Logik implementieren:
        - `global` Callback: Erkennt Nodes (Sinks/Sources) und Streams. Parst deren Properties, um `AudioDevice`- und `AudioStream`-Objekte zu erstellen/aktualisieren. Speichert sie in den `RwLock`-geschützten HashMaps.
        - `global` Callback: Beobachtet `Metadata` für Default-Geräte.
        - Sendet entsprechende `AudioEvent`s über den `event_publisher`.
    - `CoreListener`-Logik für Fehler und Server-Info.
    - Startet den `MainLoop` in einem eigenen Thread.
    - `shutdown()`-Methode implementieren.
    - Öffentliche `async` Getter-Methoden implementieren (lesen aus den `RwLock`-geschützten Maps).
    - Öffentliche `async` Setter-Methoden implementieren (`set_device_volume`, `set_default_device` etc.), die PipeWire-Befehle (oft über Setzen von Properties/Params auf Nodes/Streams via SPA Pods) asynchron ausführen. Dies könnte das Senden von Nachrichten an den MainLoop-Thread über einen Kanal erfordern, falls die `pipewire-rs` Proxies nicht direkt `Send+Sync` sind oder Operationen im MainLoop-Kontext erfordern.
5. **Unit-/Integrationstests**:
    - Sehr schwierig ohne laufenden PipeWire-Server. Fokus auf:
    - Korrekte Erstellung/Parsen der eigenen Typen (`AudioDevice` etc.).
    - Logik der Listener-Callbacks (mocken von `Registry`, `GlobalObject` etc. ist aufwendig). Eventuell Tests, die auf einem Test-PipeWire-Server laufen (falls headless möglich).
    - Testen der Setter-Methoden, ob sie die korrekten PipeWire-Parameter (SPA Pods) generieren würden.

---

Diese detaillierten Pläne für die Module `system::dbus_interfaces` (Fortsetzung) und `system::audio_management` sollten eine sehr solide Grundlage für die Implementierung bieten. Die Komplexität liegt hier oft in der korrekten asynchronen Integration und der genauen Abbildung der externen D-Bus/PipeWire-APIs und -Events auf die internen Strukturen und das Event-System von NovaDE.

---

### Modul 3: `system::dbus_interfaces` (Fortsetzung und Vervollständigung)

#### 3.4. Submodul: `system::dbus_interfaces::logind_client` (Vervollständigung)

Zweck: Client für org.freedesktop.login1 für Sitzungsmanagement.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

**Datei:** `src/dbus_interfaces/logind_client/service.rs` (Fortsetzung)

- **`LogindClientService` Implementierung (Methoden-Details):**
    - **`async fn initialize_and_listen(&self) -> Result<(), DBusInterfaceError>`**:
        1. `sessions = self.manager_proxy.list_sessions().await?.into_iter().map(|(id, _uid, _user, _seat, path)| (id, path)).collect::<HashMap<_,_>>();`
        2. Für jede `(id, path)` in `sessions`:
            - `self.add_session_proxy_and_listen(&id, path).await?;`
        3. Starte `tokio::task` für `manager_proxy.receive_session_new()`:
            - Bei `SessionNew { session_id, object_path }`: `self.add_session_proxy_and_listen(&session_id, object_path).await;` `self.event_publisher.send(LogindEvent::SessionNew(...))`.
        4. Starte `tokio::task` für `manager_proxy.receive_session_removed()`:
            - Bei `SessionRemoved { session_id, object_path }`: `self.session_proxies.lock().await.remove(&session_id);` `self.event_publisher.send(LogindEvent::SessionRemoved(...))`.
        5. Starte `tokio::task` für `manager_proxy.receive_prepare_for_shutdown()`:
            - `self.event_publisher.send(LogindEvent::PrepareForShutdown(start_signal_arg)).ok();`
        6. Starte `tokio::task` für `manager_proxy.receive_prepare_for_sleep()`:
            - `self.event_publisher.send(LogindEvent::PrepareForSleep(start_signal_arg)).ok();`
    - **`async fn add_session_proxy_and_listen(&self, session_id: &str, object_path: OwnedObjectPath) -> Result<(), DBusInterfaceError>`**:
        1. `session_proxy = LogindSessionProxy::builder(&self.connection).path(object_path.clone())?.build().await?;`
        2. Starte `tokio::task` für `session_proxy.receive_lock()`: `self.event_publisher.send(LogindEvent::SessionLocked(object_path.clone())).ok();`
        3. Starte `tokio::task` für `session_proxy.receive_unlock()`: `self.event_publisher.send(LogindEvent::SessionUnlocked(object_path.clone())).ok();`
        4. `self.session_proxies.lock().await.insert(session_id.to_string(), session_proxy);`
    - **`get_current_session_details()`**:
        1. `current_pid = std::process::id();`
        2. `session_path = self.manager_proxy.get_session_by_pid(current_pid).await?;`
        3. `session_proxy = LogindSessionProxy::builder(&self.connection).path(session_path.clone())?.build().await?;`
        4. Rufe alle Properties von `session_proxy` ab (z.B. `id()`, `user()`, `name()`, etc.) und fülle `SessionDetails`.
    - **`lock_current_session()`**:
        1. `session_path = self.manager_proxy.get_session_by_pid(std::process::id()).await?;`
        2. `session_proxy = self.session_proxies.lock().await.get(session_path.as_str())` (oder neu erstellen, falls nicht gecacht).
        3. `session_proxy.lock().await?;`
    - Andere Methoden (`can_power_off`, `power_off`, etc.) rufen die entsprechenden `manager_proxy`-Methoden auf.

**Datei:** `src/dbus_interfaces/logind_client/mod.rs`

- `pub mod types;`
- `pub mod proxies;`
- `pub mod service;`
- `pub use service::LogindClientService;`
- `pub use types::{LogindEvent, SessionDetails, LogindPowerOperation};`

#### 3.5. Submodul: `system::dbus_interfaces::network_manager_client` (Vervollständigung)

**Zweck:** Client für `org.freedesktop.NetworkManager`.

**Datei:** `src/dbus_interfaces/network_manager_client/types.rs`

- **Enums:**
    - `NMState`: `Unknown, Asleep, Disconnected, Disconnecting, Connecting, ConnectedLocal, ConnectedSite, ConnectedGlobal`. `#[repr(u32)]`, `Type`.
    - `NMDeviceType`: `Unknown, Ethernet, Wifi, Wimax, Modem, Bluetooth, OlpcMesh, WifiP2p, Bond, Vlan, Adsl, Bridge, Generic, Team, Tun, IpTunnel, Macvlan, Vxlan, Veth, Dummy, Sriov`. `#[repr(u32)]`, `Type`.
    - `NMConnectivityState`: `Unknown, None, Portal, Limited, Full`. `#[repr(u32)]`, `Type`.
    - `NMWifiAccessPointFlags`, `NMWifiAccessPointSecurityFlags`.
- **Structs:**
    - `NetworkDeviceDetails { id: u32, path: DBusObjectPath, interface: String, device_type: NMDeviceType, state: u32 /* NMDeviceState */, ip4_address: Option<String>, ip6_address: Option<String>, hw_address: Option<String>, mtu: u32, managed: bool, firmware_missing: bool, driver: String, ... }`
    - `AccessPointDetails { path: DBusObjectPath, ssid: String, bssid: String, strength: u8, frequency: u32, flags: u32, wpa_flags: u32, rsn_flags: u32, max_bitrate: u32, ... }`
    - `ActiveConnectionDetails { path: DBusObjectPath, uuid: String, connection_type: String, id: String, specific_object_path: DBusObjectPath, state: u32 /* NMActiveConnectionState */, default: bool, default6: bool, vpn: bool, master_path: Option<DBusObjectPath>, ip4_config_path: Option<DBusObjectPath>, ... }`
- **Event:**
    
    Rust
    
    ```
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum NetworkManagerEvent {
        ConnectivityChanged(NMConnectivityState),
        StateChanged(NMState),
        DeviceAdded(NetworkDeviceDetails),
        DeviceRemoved(DBusObjectPath /* device path */),
        DeviceStateChanged { device_path: DBusObjectPath, new_state: u32 /* NMDeviceState */, old_state: u32 },
        ActiveConnectionAdded(ActiveConnectionDetails),
        ActiveConnectionRemoved(DBusObjectPath /* active connection path */),
        AccessPointAdded(AccessPointDetails),
        AccessPointRemoved(DBusObjectPath /* ap path */),
        PrimaryConnectionChanged(Option<ActiveConnectionDetails>),
    }
    ```
    

**Datei:** `src/dbus_interfaces/network_manager_client/proxies.rs`

- **`NetworkManagerProxy` für `org.freedesktop.NetworkManager`**: Properties (`Connectivity`, `State`, `NetworkingEnabled`, `WirelessEnabled`, `WirelessHardwareEnabled`, `WwanEnabled`, `WwanHardwareEnabled`, `ActiveConnections`, `PrimaryConnection`, `Devices`, etc.). Methoden (`GetDevices`, `GetActiveConnections`, `ActivateConnection`, `DeactivateConnection`, `ScanWifiAccessPoints`, etc.). Signale (`CheckPermissions`, `StateChanged`, `PropertiesChanged`, `DeviceAdded`, `DeviceRemoved`, `ActiveConnectionAdded`, `ActiveConnectionRemoved`).
- **`NMDeviceProxy` für `org.freedesktop.NetworkManager.Device`**: Viele Properties (Interface, IpInterface, Udi, State, DeviceType, AvailableConnections, Ip4Config, Dhcp4Config, etc.).
- **`NMWifiDeviceProxy` für `org.freedesktop.NetworkManager.Device.Wireless`**: Properties (`HwAddress`, `PermHwAddress`, `Mode`, `Bitrate`, `ActiveAccessPoint`, etc.). Methoden (`GetAccessPoints`, `RequestScan`, etc.). Signale (`AccessPointAdded`, `AccessPointRemoved`, `PropertiesChanged`).
- **`NMAccessPointProxy` für `org.freedesktop.NetworkManager.AccessPoint`**: Properties (`Ssid`, `Frequency`, `HwAddress`, `Mode`, `MaxBitrate`, `Strength`, `Flags`, `WpaFlags`, `RsnFlags`, etc.).
- **`NMActiveConnectionProxy` für `org.freedesktop.NetworkManager.Connection.Active`**: Properties (`Connection` (path), `SpecificObject` (path), `Id`, `Uuid`, `Type`, `Devices`, `State`, `Default`, `Ip4Config`, etc.). Signale (`StateChanged`, `PropertiesChanged`).
- **`NMSettingsProxy` für `org.freedesktop.NetworkManager.Settings`**: Methoden (`ListConnections`, `AddConnection`, `GetConnectionByUuid`, etc.).
- **`NMSettingsConnectionProxy` für `org.freedesktop.NetworkManager.Settings.Connection`**: Methoden (`Update`, `Delete`, `GetSettings`, `GetSecrets`, etc.).

**Datei:** `src/dbus_interfaces/network_manager_client/service.rs`

- **`NetworkManagerClientService`**:
    - **Felder:** Connection, Hauptproxy, Maps für Geräte-, AP-, aktive Verbindungsproxies. Event-Publisher.
    - **`initialize_and_listen()`**: Initiales Laden von Devices, aktiven Verbindungen. Signale abonnieren (Hauptproxy, Geräte, aktive Verbindungen).
    - **Öffentliche Methoden:** `get_connectivity_state()`, `get_primary_connection_details()`, `list_devices()`, `list_active_connections()`, `list_wifi_access_points(device_path: &DBusObjectPath)`, `activate_connection(connection_path: &DBusObjectPath, device_path: &DBusObjectPath)`, etc.

**Implementierungsschritte `network_manager_client`**:

1. `types.rs`: Alle NM-bezogenen Typen und Events.
2. `proxies.rs`: Alle benötigten NM-Proxies.
3. `service.rs`: `NetworkManagerClientService` implementieren.
4. Tests (schwierig ohne NM, `zbus::MockConnection` verwenden).

---

#### 3.6. Submodul: `system::dbus_interfaces::secrets_service_client` (Vervollständigung)

**Zweck:** Client für `org.freedesktop.Secret.Service`.

**Datei:** `src/dbus_interfaces/secrets_service_client/types.rs`

- **Struct `Secret`**: `session: DBusObjectPath`, `parameters: Vec<u8>`, `value: Vec<u8>`, `content_type: String`.
- **Struct `SecretItemProperties`**: `label: String`, `attributes: HashMap<String, String>`, `created: u64`, `modified: u64`, `locked: bool`.
- **Event:** `SecretServiceEvent::PromptRequired { prompt_path: DBusObjectPath }`, `SecretServiceEvent::PromptCompleted { prompt_path: DBusObjectPath, dismissed: bool }`.

**Datei:** `src/dbus_interfaces/secrets_service_client/proxies.rs`

- **`SecretServiceProxy` (`org.freedesktop.Secret.Service`)**: Methoden (`OpenSession`, `CreateCollection`, `SearchItems`, `Unlock`, `Lock`, `GetSecrets`, `ReadAlias`, `SetAlias`). Properties (`Collections`, `State`). Signal (`CollectionCreated`, `CollectionDeleted`, `CollectionChanged`).
- **`SecretSessionProxy` (`org.freedesktop.Secret.Session`)**: Methode (`Close`). (Lebensdauer beachten).
- **`SecretCollectionProxy` (`org.freedesktop.Secret.Collection`)**: Methoden (`Delete`, `SearchItems`, `CreateItem`). Properties (`Items`, `Label`, `Locked`, `Created`, `Modified`). Signal (`ItemCreated`, `ItemDeleted`, `ItemChanged`).
- **`SecretItemProxy` (`org.freedesktop.Secret.Item`)**: Methoden (`Delete`, `GetSecret`, `SetSecret`). Properties (`Locked`, `Attributes`, `Label`, `Type`, `Created`, `Modified`).
- **`SecretPromptProxy` (`org.freedesktop.Secret.Prompt`)**: Methode (`Prompt`). Signal (`Completed`).

**Datei:** `src/dbus_interfaces/secrets_service_client/service.rs`

- **Struct `SecretsServiceClientService`**:
    - **Felder:** Connection, `service_proxy: SecretServiceProxy`, `default_collection_alias: String` (z.B. "novade_default" oder "login"), `open_sessions: Arc<tokio::sync::Mutex<HashMap<DBusObjectPath, SecretSessionProxy<'static>>>>`. Event-Publisher für `SecretServiceEvent`.
    - **Konstruktor:** `new(...)`.
    - **`initialize_and_listen()`**: Öffnet eine initiale Session für die Default-Collection (oder "login"). Abonniert Signale von `SecretServiceProxy`.
    - **Öffentliche Methoden:**
        - `async fn ensure_collection_exists(&self, alias: &str, label: &str) -> Result<DBusObjectPath, DBusInterfaceError>`
        - `async fn store_secret_in_collection(&self, collection_path_or_alias: &str, item_label: &str, secret_content: &[u8], attributes: HashMap<String, String>, content_type: &str, replace: bool) -> Result<DBusObjectPath /* item_path */, DBusInterfaceError>`
        - `async fn retrieve_secret_from_item(&self, item_path: &DBusObjectPath) -> Result<Vec<u8>, DBusInterfaceError>`
        - `async fn search_items_in_collection(&self, collection_path_or_alias: &str, attributes: HashMap<String, String>) -> Result<Vec<(DBusObjectPath, SecretItemProperties)>, DBusInterfaceError>`
        - `async fn delete_item(&self, item_path: &DBusObjectPath) -> Result<(), DBusInterfaceError>`
        - `async fn unlock_items_or_paths(&self, paths: &[DBusObjectPath]) -> Result<(), DBusInterfaceError>`: Ruft `Unlock` auf `SecretServiceProxy`. Startet Task, um `Prompt.Completed`-Signal zu behandeln.
    - **Handhabung von `Prompt`**: Wenn `Unlock` einen `Prompt`-Pfad zurückgibt, wird ein `SecretPromptProxy` erstellt, `Prompt()` aufgerufen und das `Completed`-Signal abgewartet. Das `SecretServiceEvent` wird gesendet, um UI ggf. zu informieren.

**Implementierungsschritte `secrets_service_client`**:

1. Typen, Proxies, Service-Struktur.
2. Implementierung der Methoden, insbesondere der komplexen Abläufe mit Sessions und Collections.
3. Sorgfältige Handhabung von `Unlock`-Prompts und deren Signalen.
4. Tests mit gemocktem D-Bus.

---

#### 3.7. Submodul: `system::dbus_interfaces::policykit_client` (Vervollständigung)

**Zweck:** Client für `org.freedesktop.PolicyKit1.Authority`.

**Datei:** `src/dbus_interfaces/policykit_client/types.rs`

- **Enum `PolicyKitImplicitAuthorization`**: (aus Polkit-Spezifikation) `Unknown, NotAuthorized, AuthenticationRequired, AdministratorAuthenticationRequired, AuthenticationRequiredRetained, AdministratorAuthenticationRequiredRetained, Authorized`. `#[repr(u32)]`, `Type`.
- **Struct `PolicyKitAuthorizationResultDetails`**: Enthält zusätzliche Daten vom Result.
- **Struct `PolicyKitSubjectSystemBusName`**: `name: String`.
- **Enum `PolicyKitSubjectKind`**: `User { user_id: u32 }`, `SystemBusName { name: String }`, `Binary { path: String, pid: Option<u32> }`. (Vereinfacht, Polkit hat komplexere Subject-Typen).

**Datei:** `src/dbus_interfaces/policykit_client/proxies.rs`

- **`PolicyKitAuthorityProxy` für `org.freedesktop.PolicyKit1.Authority`**:
    
    Rust
    
    ```
    #[proxy(
        interface = "org.freedesktop.PolicyKit1.Authority",
        default_service = "org.freedesktop.PolicyKit1",
        default_path = "/org/freedesktop/PolicyKit1/Authority"
    )]
    trait PolicyKitAuthority {
        // flags: 0x00000001 (ALLOW_USER_INTERACTION)
        // cancellation_id: String (leer für keinen)
        async fn check_authorization(
            &self,
            subject: zbus::zvariant::Value<'_>, // ('sys', {'unix-process': <{'pid': <uint32 ProcessID>, 'start-time': <uint64 StartTime>}>})
            action_id: &str,
            details: std::collections::HashMap<&str, &str>,
            flags: u32,
            cancellation_id: &str,
        ) -> zbus::Result<(bool, bool, Dict<'static, String, Value<'static>>)>; // (is_authorized, is_challenge, details)
        // Weitere Methoden wie EnumerateActions, RegisterAuthenticationAgent etc.
    }
    ```
    
    - **Hinweis:** Der `subject`-Parameter ist komplex (`a{sv}`). `zbus` sollte dies als `Value` oder `Dict` handhaben können.

**Datei:** `src/dbus_interfaces/policykit_client/service.rs`

- **Struct `PolicyKitClientService`**:
    - **Felder:** Connection, `authority_proxy: PolicyKitAuthorityProxy`.
    - **Konstruktor:** `new(...)`.
    - **Öffentliche Methode `async fn check_authorization(...) -> Result<PolicyKitAuthorizationDetails, DBusInterfaceError>`**:
        1. Konstruiert das `subject`-Value (z.B. für den aktuellen Prozess `std::process::id()`).
        2. Ruft `authority_proxy.check_authorization(...)`.
        3. Parst das Ergebnis-Tuple in `PolicyKitAuthorizationDetails`.
        4. UI-Interaktion für Passwortabfragen wird vom systemweiten PolicyKit-Agenten gehandhabt, nicht von diesem Client.

**Implementierungsschritte `policykit_client`**:

1. Typen, Proxy, Service-Struktur.
2. `check_authorization` Implementierung mit korrekter Erstellung des `subject`-Parameters.
3. Tests mit gemocktem D-Bus.

---

#### 3.8. Submodul: `system::dbus_interfaces::notifications_server` (Vervollständigung)

**Zweck:** Implementierung des `org.freedesktop.Notifications` D-Bus-Servers.

**Datei:** `src/dbus_interfaces/notifications_server/service_object.rs`

- **Struct `FreedesktopNotificationsServer`**:
    - **Felder:**
        - `notification_service: Arc<Mutex<dyn NotificationService>>`
        - `id_map: Arc<tokio::sync::Mutex<HashMap<u32, Uuid>>>` (D-Bus ID -> Domain ID)
        - `reverse_id_map: Arc<tokio::sync::Mutex<HashMap<Uuid, u32>>>` (Domain ID -> D-Bus ID)
        - `next_dbus_id: Arc<tokio::sync::atomic::AtomicU32>` (Für eindeutige D-Bus IDs)
        - `signal_ctxt_sender: tokio::sync::mpsc::Sender<DbusSignalTask>` (Um Signale aus einem anderen Kontext senden zu können)
    - **Enum `DbusSignalTask`**: `NotificationClosed { dbus_id: u32, reason: u32 }`, `ActionInvoked { dbus_id: u32, action_key: String }`.
    - **Konstruktor `new(...)`**: Initialisiert Felder. Startet einen `tokio::task`, der Domain-Events (`NotificationDismissedEvent`, `NotificationActionInvokedEvent`) vom `notification_service` empfängt (über dessen `subscribe` Methode), die Domain-UUIDs in D-Bus-`u32`-IDs umwandelt und Tasks über `signal_ctxt_sender` sendet, um die D-Bus-Signale zu emittieren.
    - **D-Bus Methoden Implementierung (`#[dbus_interface(...)]`)**:
        - **`notify(...)`**:
            1. Konvertiert D-Bus Parameter in `NotificationInput`.
            2. Ruft `self.notification_service.lock().await.post_notification(input).await`.
            3. Bei Erfolg: Generiert neue `dbus_id` (aus `next_dbus_id`), speichert Mapping zu Domain-`Uuid`, gibt `dbus_id` zurück.
        - **`close_notification(id: u32)`**:
            1. Findet Domain-`Uuid` für `id` in `id_map`.
            2. Ruft `self.notification_service.lock().await.dismiss_notification(domain_id, DismissReason::DbusRequest).await`. (Grund anpassen)
        - **`get_server_information()`, `get_capabilities()`**: Wie zuvor.
    - **D-Bus Signale**: (`notification_closed`, `action_invoked`) werden von dem separaten Task gesendet, der auf Domain-Events lauscht und den `SignalContext` vom Server-Objekt benötigt. Der `SignalContext` kann geklont und an den Task übergeben werden oder man verwendet den `signal_ctxt_sender` um die Aufgabe ans Hauptobjekt zu delegieren.
- **Funktion zum Starten des D-Bus Dienstes:**
    
    Rust
    
    ```
    // In service_object.rs oder mod.rs
    pub async fn run_notifications_server(
        notification_service: Arc<Mutex<dyn NotificationService>>,
        // broadcast_receiver_for_domain_events: tokio::sync::broadcast::Receiver<NotificationEventEnum>
    ) -> Result<(), DBusInterfaceError> {
        let conn = DBusConnectionManager::session_bus().await?;
        let server_logic = Arc::new(FreedesktopNotificationsServer::new(notification_service));
    
        // Task starten, der Domain-Events in D-Bus-Signale umwandelt
        // Dieser Task benötigt eine Möglichkeit, Signale zu senden.
        // Entweder durch Klonen des SignalContext (falls möglich und sicher)
        // oder durch einen internen MPSC-Kanal zum Server-Objekt.
        // setup_domain_event_to_dbus_signal_handler(server_logic.clone(), broadcast_receiver_for_domain_events);
    
        conn.object_server().at("/org/freedesktop/Notifications", server_logic)?.await?;
        conn.request_name("org.freedesktop.Notifications", zbus:: stazione::RequestNameFlags::ReplaceExisting.into()).await?;
        tracing::info!("org.freedesktop.Notifications D-Bus Service gestartet und Name angefordert.");
        // Die Connection muss am Leben erhalten werden, z.B. indem der Server in einem blockierenden Task läuft
        // oder die Connection selbst in einem Arc gehalten und nie fallengelassen wird.
        // Für einen langlaufenden Dienst ist es üblich, dass diese Funktion nicht zurückkehrt oder
        // die Connection in einer globalen Variable/einem Manager gehalten wird.
        std::future::pending::<()>().await; // Hält den Server am Laufen
        Ok(())
    }
    ```
    

#### 3.10. `system::dbus_interfaces::mod.rs`

- Deklariert alle Submodule (`common`, `upower_client`, `logind_client`, etc.).
- Re-exportiert die öffentlichen Service-Structs/Traits und wichtigen Event-Typen/Fehler.

---

### Modul 4: `system::audio_management` (Vervollständigung)

Zweck: PipeWire-Integration für Audio-Steuerung.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

**Datei:** `src/audio_management/types.rs` (Vervollständigung)

- **`AudioDevice`**:
    - Zusätzliche Felder: `ports: Vec<AudioPortInfo>`, `active_profile_index: Option<u32>`, `profiles: Vec<AudioProfileInfo>`, `form_factor: String` (z.B. "headset", "speaker", "microphone"), `bus_path: String`.
- **`AudioPortInfo`**: `id: u32`, `name: String`, `direction: pipewire::spa::Direction`, `available: bool`.
- **`AudioProfileInfo`**: `index: u32`, `name: String`, `description: String`, `available: bool`, `priority: u32`.
- **`AudioStream`**:
    - Zusätzliche Felder: `process_id: Option<u32>`, `process_binary_name: Option<String>`, `is_corked: bool`.
- **`AudioEvent`**:
    - `DefaultDeviceChanged` Payload: `{ device_type: AudioDeviceType, new_default_device: Option<AudioDevice> }` (ganzes Objekt statt nur ID).
    - `DevicePropertiesChanged(AudioDevice)` (Wenn sich andere Properties als nur Volume/Mute ändern).
    - `StreamPropertiesChanged(AudioStream)`.

**Datei:** `src/audio_management/client/pipewire_listener.rs` (Neues Submodul/Datei)

- **Struct `PipeWireRegistryEventHandler`**:
    - **Felder:** `devices: Arc<tokio::sync::RwLock<HashMap<u32, AudioDevice>>>`, `streams: Arc<tokio::sync::RwLock<HashMap<u32, AudioStream>>>`, `default_sink_id: Arc<tokio::sync::RwLock<Option<u32>>>`, `default_source_id: Arc<tokio::sync::RwLock<Option<u32>>>`, `event_publisher: tokio::sync::broadcast::Sender<AudioEvent>`, `core_ref: Weak<pipewire::Core>` (um Proxies zu erstellen).
    - **Methoden (Callbacks für `RegistryListener`):**
        - **`global(global_object)`**:
            1. Prüft Typ (`Node` für Geräte, `Client`/`Stream` für Streams, `Metadata` für Defaults).
            2. Für `Node`:
                - `node_proxy = registry.bind::<pipewire::node::Node>(&global_object)?;`
                - Properties parsen (media.class, device.description, device.api, etc.) um `AudioDeviceType` zu bestimmen.
                - Listener für `node_proxy.receive_info_changed()` und `node_proxy.receive_param_changed()` einrichten.
                    - `info_changed`: Aktualisiert `AudioDevice`-Properties, sendet `DevicePropertiesChanged` oder `DeviceListChanged`.
                    - `param_changed` (für "Props", "Route"): Aktualisiert Volume/Mute in `AudioDevice`, sendet `DeviceVolumeChanged`.
                - Erstellt `AudioDevice`, speichert in `devices`, sendet `DeviceListChanged`.
            3. Für `Stream` (oder `Client`, das Streams hat): Analog für `AudioStream`.
            4. Für `Metadata` (Name "default"):
                - Listener für `metadata_proxy.receive_property_changed()` einrichten.
                - Bei Änderung von "default.audio.sink" oder "default.audio.source": Aktualisiere `default_sink_id`/`default_source_id`, finde das `AudioDevice`-Objekt, setze `is_default`, sende `DefaultDeviceChanged`.
        - **`global_remove(id)`**: Entfernt Objekt aus Maps, sendet `DeviceListChanged`/`StreamListChanged`.
- **Struct `PipeWireCoreEventHandler`**:
    - **Felder:** `event_publisher: tokio::sync::broadcast::Sender<AudioEvent>`.
    - **Methoden (Callbacks für `CoreListener`):**
        - `info(info)`: Prüft `info.change_mask` für `CoreChangeMask::PROPS`, um Server-Verbindungsstatus zu erkennen. Sendet `ServerConnectionStateChanged`.
        - `error(...)`: Loggt Fehler.

**Datei:** `src/audio_management/client/service.rs` (oder `mod.rs`)

- **`PipeWireClientService`**:
    - **Konstruktor `new(...)`**:
        1. Initialisiert PipeWire-Objekte.
        2. Erstellt `PipeWireRegistryEventHandler` und `PipeWireCoreEventHandler`.
        3. `registry.add_listener_local(registry_event_handler_struct)` (oder `Weak` Referenzen verwenden, um Zyklen zu vermeiden, Listener müssen `'static` sein für `add_listener_local`).
        4. `core.add_listener_local(core_event_handler_struct)`.
        5. Startet `MainLoop`-Thread.
    - **Setter-Methoden (`set_device_volume`, `set_default_device` etc.):**
        - Müssen nun asynchron mit dem `MainLoop`-Thread kommunizieren, wenn die `pipewire-rs`-Proxies nicht `Send` sind oder Operationen im Loop-Kontext erfordern.
        - **Ansatz 1 (Kanal zum MainLoop-Thread):**
            - `PipeWireClientService` hält `command_sender: tokio::sync::mpsc::Sender<AudioCommand>`.
            - Im `MainLoop`-Thread wird ein `mpsc::Receiver<AudioCommand>` abgefragt.
            - `AudioCommand` Enum: `SetDeviceVolume { pw_id: u32, volume: u8, mute: bool }, SetDefaultDevice { ... }`.
            - Setter-Methoden senden Befehl über Kanal. `MainLoop` führt Aktion aus, aktualisiert internen Zustand und der Listener sendet dann das `AudioEvent`.
        - **Ansatz 2 (Proxies direkt nutzen, wenn `Send`):** Wenn `pipewire::node::Node` (der Proxy) `Send` ist, können die Setter-Methoden ihn direkt verwenden. Die Aktualisierung der `AudioDevice`-Struktur und das Senden des `AudioEvent` erfolgt dann immer noch über den Listener-Pfad als Reaktion auf das `param_changed`-Signal von PipeWire.
    - **`Youtube_property(core_proxy: &Arc<Core>, key: &str) -> Option<String>`**: Hilfsfunktion zum Lesen von Metadaten-Properties für Default-Geräte.

#### 4.4. Implementierungsschritte `system::audio_management` (Fortsetzung)

1. **`types.rs`**: `AudioDevice`, `AudioStream`, `AudioEvent` vervollständigen. `AudioPortInfo`, `AudioProfileInfo`.
2. **`errors.rs`**: `AudioManagementError` vervollständigen.
3. **`client/pipewire_listener.rs`**: `PipeWireRegistryEventHandler` und `PipeWireCoreEventHandler` implementieren, inklusive der detaillierten Logik in den Callbacks zum Parsen von Properties und Senden von Events.
4. **`client/service.rs`**:
    - `PipeWireClientService`-Struktur mit Feldern für PipeWire-Objekte, Listener-Handles und Zustand (Maps, Default-IDs) definieren.
    - `new()`-Konstruktor: Initialisierung, Listener-Registrierung, `MainLoop`-Thread starten.
    - Getter-Methoden implementieren (lesen aus den `RwLock`-geschützten Maps).
    - Setter-Methoden implementieren:
        - Entscheiden, ob Kommunikation mit MainLoop-Thread via Kanal nötig ist oder ob Proxies direkt verwendet werden können.
        - SPA Pods für Lautstärke etc. korrekt erstellen.
        - `set_default_device` über PipeWire-Metadaten implementieren.
    - `shutdown()`-Methode.
5. **Tests**: Fokus auf korrekte Erstellung von SPA Pods, Parsing von Properties in Listenern (mit Beispiel-Property-Dicts), korrekte Event-Erzeugung. Integrationstests mit laufendem PipeWire-Server sind ideal, aber schwer aufzusetzen.

---

**Nächste Schritte für `system` (Skizze für verbleibende Module):**

- **Modul 5: `system::mcp_client`**:
    - **Zweck:** Implementierung des Model Context Protocol Clients.
    - **Verantwortlichkeiten:** Verbindung zu MCP-Servern, Senden von Anfragen (Ressourcenauflistung, Tool-Aufrufe) basierend auf Anweisungen von `domain::user_centric_services::ai_interaction`, Empfangen und Weiterleiten von Antworten/Benachrichtigungen. API-Schlüssel-Management via `secrets_service_client`.
    - **Technologie:** `mcp_client_rs` Crate.
    - **Struktur:** `connection.rs` (Verwaltung der Verbindung, ggf. Starten eines lokalen MCP-Server-Prozesses), `protocol_handler.rs` (Wrapper um `mcp_client_rs::McpClient`), `resource_provider.rs` (stellt `mcp_client_rs::Resource`s bereit, z.B. für Dateisystemzugriff, Zwischenablage – interagiert mit anderen Systemmodulen).
    - **Fehler:** `McpClientError`.
    - **Events:** `McpResponseEvent`, `McpNotificationEvent`.
- **Modul 6: `system::window_mechanics`**:
    - **Zweck:** Technische Umsetzung des Fenstermanagements (Positionierung, Größe, Stapelreihenfolge, Tiling, Fokus, Dekorationen).
    - **Verantwortlichkeiten:** Nimmt `WorkspaceWindowLayout` von `domain::window_management_policy` entgegen und wendet es auf `ManagedWindow`s im `system::compositor::core::DesktopState::space` an. Sendet `configure`-Events an Wayland-Clients. Handhabt interaktive Operationen (Move/Resize-Grabs). Koordiniert Server-Side Decorations (SSD) mit Client-Side Decorations (CSD) basierend auf `xdg-decoration`-Protokoll und Domänen-Policy.
    - **Interaktion:** Eng mit `system::compositor` (insb. `xdg_shell` und `Space`) und `domain::window_management_policy`.
    - **Fehler:** `WindowMechanicsError`.
- **Modul 7: `system::event_bridge`**:
    - **Zweck:** Eine zentrale Stelle für System-interne Events, die nicht direkt an einen spezifischen D-Bus-Dienst oder ein Wayland-Protokoll gebunden sind.
    - **Verantwortlichkeiten:** Definition von generischen System-Event-Typen. Bereitstellung von `tokio::sync::broadcast` Kanälen für diese Events.
    - **Beispiel-Events:** `InputDeviceHotplugEvent { device_name: String, event_type: HotplugType (Added/Removed) }`, `SystemSuspendRequestEvent { operation: SuspendOperation (Suspend/Hibernate) }`, `ActiveOutputConfigurationChangedEvent`.
    - Dient als Entkopplungsschicht innerhalb des Systems.
- **Modul 8: `system::power_management`**:
    - **Zweck:** Implementierung von DPMS und Interaktion mit `wlr-output-power-management`.
    - **Verantwortlichkeiten:** Hört auf `UserActivityDetectedEvent` und `LogindEvent::SystemIdleHintChanged`. Liest Energieeinstellungen von `domain::global_settings_service`. Steuert den DPMS-Zustand von Outputs über die Compositor-Schnittstelle (z.B. direkte Aufrufe an DRM-Backend oder über `wlr-output-power-management`-Protokoll, falls als Client implementiert).
    - **Interaktion:** `system::compositor::output_management` (für serverseitige `wlr-output-power-management`-Implementierung), `system::dbus_interfaces::logind_client`, `domain::global_settings_service`.
    - **Fehler:** `PowerManagementError`.

Diese detaillierte Aufschlüsselung und die Pläne für die einzelnen Module sollten eine sehr klare Richtung für die Implementierung der Systemschicht geben. Der Fokus liegt auf der korrekten Integration externer Bibliotheken und Protokolle, der robusten Fehlerbehandlung und der Bereitstellung klarer Schnittstellen zur Domänen- und UI-Schicht.

---

### Modul 5: `system::mcp_client`

Zweck: Implementierung des Clients für das Model Context Protocol (MCP), um sicher mit lokalen oder Cloud-basierten KI-Modellen (LLMs) zu interagieren.

Verantwortlichkeiten:

- Aufbau und Verwaltung der Verbindung zu einem MCP-Server (kann ein lokaler Prozess oder ein Remote-Endpunkt sein).
- Senden von Anfragen an den MCP-Server (z.B. `ListResources`, `CallTool`) basierend auf Anweisungen von `domain::user_centric_services::ai_interaction`.
- Empfangen von Antworten und asynchronen Benachrichtigungen vom MCP-Server.
- Sichere Handhabung von API-Schlüsseln (via `system::dbus_interfaces::secrets_service_client`) für Cloud-basierte Modelle.
- Bereitstellung einer abstrahierten Schnittstelle für die Domänenschicht, um KI-Funktionen anzufordern, ohne MCP-Protokolldetails kennen zu müssen. **Design-Rationale:** Kapselung der MCP-spezifischen Kommunikationslogik. Nutzung des `mcp_client_rs` Crates als Basis. Ermöglichung einer flexiblen Anbindung verschiedener KI-Modelle, die das MCP unterstützen. **Technologie:** `mcp_client_rs` Crate, `tokio` für asynchrone Operationen, `serde` für Datenstrukturen.

#### 5.1. Untermodul: `system::mcp_client::types`

**Datei:** `src/mcp_client/types.rs`

- **Struct `McpServerConfig`** (Konfiguration für die Verbindung zu einem MCP-Server):
    
    Rust
    
    ```
    use serde::{Serialize, Deserialize};
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub enum McpServerType {
        LocalExecutable {
            command: String,
            args: Vec<String>,
            working_directory: Option<String>,
        },
        RemoteHttp {
            endpoint_url: String, // z.B. "http://localhost:8000/mcp"
            // api_key_secret_name: Option<String>, // Wird über AIModelProfile gehandhabt
        },
    }
    
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub struct McpServerConfig {
        pub server_id: String, // Eindeutige ID für diese Serverkonfiguration
        pub server_type: McpServerType,
        #[serde(default)]
        pub default_request_timeout_ms: u64, // Standard-Timeout für Anfragen
    }
    
    impl Default for McpServerConfig {
        fn default() -> Self {
            Self {
                server_id: "default_local_mcp".to_string(),
                server_type: McpServerType::LocalExecutable {
                    command: "nova-mcp-server".to_string(), // Beispiel
                    args: vec![],
                    working_directory: None,
                },
                default_request_timeout_ms: 30000, // 30 Sekunden
            }
        }
    }
    ```
    
- **Re-Export und Wrapper für `mcp_client_rs::protocol` Typen (falls nötig):**
    - `pub use mcp_client_rs::protocol::{InitializeParams, InitializeResult, ListResourcesParams, ListResourcesResult, Resource, CallToolParams, CallToolResult, ToolCall, ToolResult, McpMessage, Notification, ErrorResponse, ErrorCode};`
    - Ggf. eigene Wrapper-Structs, wenn Felder hinzugefügt oder angepasst werden müssen.
- **Event-Struktur (für `system::event_bridge` oder direkt an Domäne):**
    
    Rust
    
    ```
    use mcp_client_rs::protocol::{Notification as McpNotification, ErrorResponse as McpErrorResponse, ToolResult as McpToolResult};
    use uuid::Uuid;
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum McpClientEvent {
        McpNotificationReceived {
            server_id: String,
            interaction_id: Option<Uuid>, // Interne ID der AIInteractionContext
            notification: McpNotification,
        },
        McpToolCallSuccessful {
            server_id: String,
            interaction_id: Uuid,
            request_id: String, // Aus CallToolParams
            tool_result: McpToolResult,
        },
        McpRequestFailed {
            server_id: String,
            interaction_id: Option<Uuid>,
            request_id: Option<String>,
            error: McpErrorResponse, // Der MCP-Fehler
        },
        McpServerError { // Für Verbindungsfehler etc.
            server_id: String,
            message: String,
        },
        McpServerConnectionStateChanged {
            server_id: String,
            is_connected: bool,
        }
    }
    ```
    

#### 5.2. Untermodul: `system::mcp_client::errors`

**Datei:** `src/mcp_client/errors.rs`

- **Enum `McpSystemClientError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use mcp_client_rs::Error as McpLibError;
    use crate::dbus_interfaces::common::DBusInterfaceError; // Für Secrets Service Fehler
    
    #[derive(Debug, Error)]
    pub enum McpSystemClientError {
        #[error("MCP Server configuration not found for ID: {0}")]
        ServerConfigNotFound(String),
        #[error("Failed to start local MCP server (command: '{command}'): {source}")]
        LocalServerStartFailed {
            command: String,
            #[source]
            source: std::io::Error,
        },
        #[error("MCP client library error: {0}")]
        McpLibError(#[from] McpLibError),
        #[error("Failed to retrieve API key '{secret_name}' from secrets service: {source}")]
        ApiKeyRetrievalFailed {
            secret_name: String,
            #[source]
            source: DBusInterfaceError,
        },
        #[error("API key '{secret_name}' not found in secrets service.")]
        ApiKeyNotFound(String),
        #[error("MCP request timed out for request ID '{request_id}' to server '{server_id}'.")]
        RequestTimeout { server_id: String, request_id: String },
        #[error("MCP Server '{server_id}' is not connected or connection lost.")]
        ServerNotConnected(String),
        #[error("No active MCP server connection available.")]
        NoActiveConnection,
        #[error("Internal MCP client error: {0}")]
        InternalError(String),
    }
    ```
    

#### 5.3. Submodul: `system::mcp_client::connection_manager`

**Zweck:** Verwaltung von Verbindungen zu MCP-Servern (lokal oder remote), inklusive Starten lokaler Server.

**Datei:** `src/mcp_client/connection_manager.rs`

- **Struct `McpConnection`**:
    - **Felder:**
        - `server_id: String`
        - `client: mcp_client_rs::McpClient` (Der eigentliche Client aus dem Crate)
        - `local_process_handle: Option<tokio::process::Child>` (Für lokale Server)
        - `is_connected: Arc<tokio::sync::watch::Sender<bool>>`
    - **Methoden:**
        - `pub async fn new(config: &McpServerConfig, api_key: Option<String>) -> Result<Self, McpSystemClientError>`:
            1. Wenn `config.server_type` `LocalExecutable`:
                - Starte den Prozess mit `tokio::process::Command`. Speichere `Child` Handle.
                - `client = McpClient::connect_local_stdio(child_process_stdio).await?`
            2. Wenn `config.server_type` `RemoteHttp`:
                - `client = McpClient::connect_http(&config.endpoint_url, api_key).await?`
            3. Setze `is_connected` auf `true`.
        - `pub async fn close(&mut self)`: Schließt die Verbindung, beendet ggf. lokalen Prozess.
        - Getter für `client`.
- **Struct `McpConnectionManager`**:
    - **Felder:**
        - `connections: Arc<tokio::sync::Mutex<HashMap<String /* server_id */, Arc<McpConnection>>>>`
        - `server_configs: Arc<tokio::sync::RwLock<HashMap<String /* server_id */, McpServerConfig>>>` (Geladen aus `core::config` oder `GlobalSettingsService`)
        - `secrets_service: Arc<dyn crate::dbus_interfaces::secrets_service_client::SecretsServiceClient>` // Pfad anpassen
        - `event_publisher: tokio::sync::broadcast::Sender<McpClientEvent>`
    - **Konstruktor `new(...)`**: Nimmt `secrets_service` und `event_publisher`. Lädt `server_configs` initial.
    - **Methoden:**
        - `pub async fn load_server_configs(&self, configs: Vec<McpServerConfig>)`: Aktualisiert `self.server_configs`.
        - `pub async fn get_or_connect(&self, server_id: &str, ai_model_profile: Option<&crate::domain::user_centric_services::ai_interaction::types::AIModelProfile>) -> Result<Arc<McpConnection>, McpSystemClientError>`:
            1. Prüft, ob Verbindung in `connections` existiert und verbunden ist. Wenn ja, zurückgeben.
            2. Sucht `McpServerConfig` in `server_configs`. Wenn nicht -> `ServerConfigNotFound`.
            3. Wenn `config.server_type` `RemoteHttp` und `ai_model_profile.api_key_secret_name` gesetzt ist:
                - Rufe `self.secrets_service.retrieve_secret_by_label_or_item_path(...)` auf, um API-Key zu holen. Fehler bei Fehlschlag.
            4. Erstelle neue `McpConnection::new(&config, api_key)`.
            5. Speichere in `connections`.
            6. Starte einen Task, der auf Nachrichten/Notifications vom `mcp_connection.client.receive_message()` lauscht und `McpClientEvent`s publiziert.
            7. Sendet `McpServerConnectionStateChanged`.
        - `pub async fn disconnect(&self, server_id: &str) -> Result<(), McpSystemClientError>`: Schließt Verbindung, entfernt aus `connections`. Sendet `McpServerConnectionStateChanged`.
        - `pub async fn get_active_connection_for_model(&self, model_profile: &crate::domain::user_centric_services::ai_interaction::types::AIModelProfile) -> Result<Arc<McpConnection>, McpSystemClientError>`:
            - Bestimmt `server_id` basierend auf `model_profile` (z.B. wenn Profil eine `mcp_server_id` enthält oder ein Default verwendet wird).
            - Ruft `get_or_connect(server_id, Some(model_profile))`.

#### 5.4. Submodul: `system::mcp_client::service`

**Zweck:** Implementierung des `SystemMcpService` Traits, der die Abstraktion zur Domänenschicht darstellt.

**Datei:** `src/mcp_client/service.rs`

- **Trait `SystemMcpService`** (definiert, was die Domänenschicht vom MCP-Client erwartet):
    
    Rust
    
    ```
    use async_trait::async_trait;
    use super::types::*; // McpClientEvent, McpSystemClientError etc.
    use crate::domain::user_centric_services::ai_interaction::types::AIModelProfile;
    use uuid::Uuid;
    
    #[async_trait]
    pub trait SystemMcpService: Send + Sync {
        /// Initialisiert den MCP-Client mit Serverkonfigurationen.
        async fn configure_servers(&self, server_configs: Vec<McpServerConfig>) -> Result<(), McpSystemClientError>;
    
        /// Sendet eine `Initialize` Nachricht an einen spezifischen MCP-Server.
        async fn initialize_server(
            &self,
            server_id: &str,
            params: InitializeParams,
            model_profile: Option<&AIModelProfile>, // Für API-Key etc.
        ) -> Result<InitializeResult, McpSystemClientError>;
    
        /// Listet Ressourcen vom MCP-Server auf.
        async fn list_resources(
            &self,
            server_id: &str,
            params: ListResourcesParams,
            model_profile: Option<&AIModelProfile>,
            interaction_id: Option<Uuid>, // Für Event-Korrelation
        ) -> Result<ListResourcesResult, McpSystemClientError>;
    
        /// Ruft ein Tool auf dem MCP-Server auf.
        async fn call_tool(
            &self,
            server_id: &str,
            params: CallToolParams,
            model_profile: Option<&AIModelProfile>,
            interaction_id: Uuid, // Für Event-Korrelation und Timeout-Management
        ) -> Result<CallToolResult, McpSystemClientError>; // McpClient::call_tool gibt McpMessage zurück
    
        /// Abonniert MCP-Client-Events.
        fn subscribe_to_mcp_events(&self) -> tokio::sync::broadcast::Receiver<McpClientEvent>;
    }
    ```
    
- **Struct `DefaultSystemMcpService`**:
    - **Felder:** `connection_manager: Arc<McpConnectionManager>`.
    - **Konstruktor `new(connection_manager: Arc<McpConnectionManager>) -> Self`**.
    - **Implementierung von `SystemMcpService`**:
        - `configure_servers`: Ruft `connection_manager.load_server_configs()`.
        - `initialize_server`, `list_resources`, `call_tool`:
            1. `mcp_conn = self.connection_manager.get_or_connect(server_id, model_profile).await?;`
            2. `let client = &mcp_conn.client;`
            3. Erstelle `McpMessage` für die Anfrage.
            4. `response_message = client.send_request(request_message).await.map_err(McpSystemClientError::from)?;` (Timeout hier oder im `McpClient` Crate)
            5. Parse `response_message` in den erwarteten Ergebnistyp (z.B. `InitializeResult`). Bei Fehler `McpSystemClientError::McpLibError` oder spezifischer.
            6. Für `call_tool`, wenn erfolgreich, `McpToolCallSuccessful` Event senden (über `connection_manager.event_publisher`).
            7. Bei MCP-Fehlerantwort, `McpRequestFailed` Event senden.
        - `subscribe_to_mcp_events`: Gibt `connection_manager.event_publisher.subscribe()` zurück.

#### 5.5. `system::mcp_client::mod.rs`

- Deklariert Submodule.
- Re-exportiert `SystemMcpService`-Trait, `DefaultSystemMcpService` (als konkrete Implementierung), `McpClientEvent`, `McpSystemClientError`, `McpServerConfig`.

#### 5.6. Implementierungsschritte `system::mcp_client`

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml` für `mcp_client_rs`.
2. **`types.rs`**: `McpServerConfig`, `McpClientEvent`, ggf. Wrapper definieren.
3. **`errors.rs`**: `McpSystemClientError` definieren.
4. **`connection_manager.rs`**: `McpConnection`, `McpConnectionManager` implementieren. Logik zum Starten lokaler Server, API-Key-Abruf via `SecretsServiceClientService`. Task für `client.receive_message()` und Event-Publishing.
5. **`service.rs`**: `SystemMcpService`-Trait und `DefaultSystemMcpService`-Implementierung.
6. **Unit-Tests**:
    - Testen von `McpServerConfig`-Serialisierung.
    - Testen der `McpConnectionManager`-Logik (Mocking von `SecretsServiceClientService` und `mcp_client_rs::McpClient` falls möglich, oder Integrationstests gegen einen Dummy-MCP-Server).
    - Testen der `DefaultSystemMcpService`-Methoden (Mocking von `McpConnectionManager`).

---

### Modul 6: `system::window_mechanics`

Zweck: Technische Umsetzung des Fenstermanagements basierend auf den Richtlinien der Domänenschicht.

Verantwortlichkeiten:

- Empfangen von `WorkspaceWindowLayout` von `domain::window_management_policy`.
- Anwenden dieser Geometrien auf die tatsächlichen Fenster (`ManagedWindow`s im Compositor).
- Senden von `configure`-Events an Wayland-Clients, um sie über neue Größen/Zustände zu informieren.
- Handhabung interaktiver Operationen (Move/Resize-Grabs), Anwendung von Snapping.
- Koordination von Server-Side Decorations (SSD) und Client-Side Decorations (CSD) in Absprache mit `system::compositor::decoration` und der Domänen-Policy.
- Technische Umsetzung des Fokuswechsels basierend auf Domänenentscheidungen. **Design-Rationale:** Trennt die "Mechanik" (Wie wird ein Fenster bewegt/gegrößert?) von der "Policy" (Wohin soll es bewegt/gegrößert werden?). Enge Kopplung mit dem Compositor (`DesktopState::space`, `ManagedWindow`).

#### 6.1. Submodul: `system::window_mechanics::types`

**Datei:** `src/window_mechanics/types.rs`

- **Struct `InteractiveOpState`** (für laufende Move/Resize Grabs):
    
    Rust
    
    ```
    use smithay::utils::{Logical, Point, Rectangle, Serial};
    use crate::compositor::core::state::ManagedWindow; // Pfad anpassen
    use std::sync::Arc;
    
    #[derive(Debug, Clone)]
    pub enum InteractiveOpType { Move, ResizeEdge(xdg_toplevel::ResizeEdge), ResizeCorner(/* ... */) }
    
    #[derive(Debug, Clone)]
    pub struct InteractiveOpState {
        pub window_arc: Arc<ManagedWindow>, // Das Fenster, das bewegt/vergrößert wird
        pub op_type: InteractiveOpType,
        pub start_pointer_pos_global: Point<f64, Logical>,
        pub initial_window_geometry: Rectangle<i32, Logical>,
        pub last_configure_serial: Option<Serial>, // Um Configure-Storms zu vermeiden
        // Ggf. weitere Felder für Snapping-Feedback etc.
    }
    ```
    
- **Event (System-intern, via `system::event_bridge`):**
    
    Rust
    
    ```
    #[derive(Debug, Clone)]
    pub enum WindowMechanicsEvent {
        WindowConfigured { window_domain_id: DomainWindowIdentifier, new_geometry: RectInt, new_state_flags: u32 },
        InteractiveOpStarted(DomainWindowIdentifier, InteractiveOpType),
        InteractiveOpEnded(DomainWindowIdentifier, InteractiveOpType),
    }
    ```
    

#### 6.2. Submodul: `system::window_mechanics::errors`

**Datei:** `src/window_mechanics/errors.rs`

- **Enum `WindowMechanicsError`**:
    
    Rust
    
    ```
    use thiserror::Error;
    use crate::compositor::xdg_shell::errors::XdgShellError; // Pfad anpassen
    
    #[derive(Debug, Error)]
    pub enum WindowMechanicsError {
        #[error("Window not found for mechanics operation: {0:?}")]
        WindowNotFound(crate::domain::workspaces::core::types::WindowIdentifier),
        #[error("Failed to apply layout from domain policy: {0}")]
        LayoutApplicationFailed(String),
        #[error("Error during interactive operation (move/resize): {0}")]
        InteractiveOpFailed(String),
        #[error("XDG Shell operation failed during window mechanics: {0}")]
        XdgShellError(#[from] XdgShellError), // Wenn Configure-Sends etc. fehlschlagen
        #[error("Failed to acquire necessary lock for window operation.")]
        LockFailed,
        #[error("Internal window mechanics error: {0}")]
        InternalError(String),
    }
    ```
    

#### 6.3. Submodul: `system::window_mechanics::layout_applier`

**Zweck:** Anwenden eines von der Domäne berechneten Layouts.

**Datei:** `src/window_mechanics/layout_applier.rs`

- **Funktion `pub async fn apply_workspace_layout(desktop_state: &Arc<Mutex<DesktopState>>, workspace_id: WorkspaceId, layout: &WorkspaceWindowLayout) -> Result<(), WindowMechanicsError>`**:
    1. Sperre `desktop_state`.
    2. Für jede `(domain_window_id, target_geometry)` in `layout.window_geometries`:
        - Finde das `Arc<ManagedWindow>` in `desktop_state.windows` (oder `desktop_state.space`). Wenn nicht: `WindowMechanicsError::WindowNotFound`.
        - `let mut window_guard = managed_window_arc.lock_blocking();` (Oder `async` Lock, wenn `ManagedWindow` selbst einen `async` Mutex hat. Hier Annahme: `ManagedWindow` ist `desktop::Window`, das intern ggf. synchron ist oder dessen `send_configure` etc. synchron sind).
        - **Geometrie setzen:** `window_guard.current_geometry = target_geometry;`
        - **Größe/Status an Client senden:**
            - `if let WindowSurface::Toplevel(toplevel_surface) = &window_guard.xdg_surface { ... }`
            - `toplevel_surface.with_pending_state(|state| { state.size = Some(target_geometry.size); /* state.maximized, .fullscreen etc. basierend auf Layout-Anforderungen setzen */ });`
            - `toplevel_surface.send_configure();` (Dies sendet `xdg_surface.configure` und `xdg_toplevel.configure`).
        - Ggf. `WindowMechanicsEvent::WindowConfigured` senden.
    3. Für Fenster, die im alten Layout waren, aber nicht im neuen (d.h. geschlossen oder auf anderen Workspace verschoben): `desktop_state.space.unmap_window(...)`.
    4. Für neue Fenster im Layout (noch nicht im Space): `desktop_state.space.map_window(...)`.
    5. `desktop_state.space.damage_all_outputs();` (Oder spezifischerer Schaden).

#### 6.4. Submodul: `system::window_mechanics::interactive_ops`

**Zweck:** Handhabung von interaktiven Fenster-Moves und -Resizes.

**Datei:** `src/window_mechanics/interactive_ops.rs`

- **Funktionen zum Starten von Grabs (aufgerufen von `XdgShellHandler` in `system::compositor`):**
    - `pub fn start_interactive_move(desktop_state: &Arc<Mutex<DesktopState>>, seat: &Seat<DesktopState>, window_arc: Arc<ManagedWindow>, serial: Serial, start_pointer_pos: Point<f64, Logical>)`
    - `pub fn start_interactive_resize(desktop_state: &Arc<Mutex<DesktopState>>, seat: &Seat<DesktopState>, window_arc: Arc<ManagedWindow>, serial: Serial, edge: xdg_toplevel::ResizeEdge, start_pointer_pos: Point<f64, Logical>)`
    - **Logik:**
        1. Erstelle `InteractiveOpState`.
        2. `seat.start_pointer_grab(...)` mit einem spezifischen `PointerGrabStartData` und einem `PointerGrab` Handler.
        3. Der `PointerGrab` Handler:
            - **`motion(...)`**:
                - Berechne neue Geometrie basierend auf `delta` und `InteractiveOpState`.
                - Rufe `domain::window_management_policy_service.calculate_snap_target(...)` auf, um Snapping anzuwenden.
                - Aktualisiere `window_arc.lock_blocking().current_geometry` (vorläufig, ohne Configure).
                - Optional: Zeige visuelles Feedback (z.B. Umriss des Fensters an neuer Position – dies ist Renderer-Aufgabe).
            - **`button(...)`**: Wenn Maustaste losgelassen:
                - Finalisiere Geometrie.
                - Sende `configure` an Client (via `window_arc.xdg_surface.toplevel().send_configure()`).
                - Beende den Grab (`pointer_handle.unset_grab()`).
                - Sende `WindowMechanicsEvent::InteractiveOpEnded`.
            - **`axis(...)`**: Ignorieren während Grab.
            - **`cancel(...)`**: Grab abbrechen, Fenster auf `initial_window_geometry` zurücksetzen.

#### 6.5. Submodul: `system::window_mechanics::focus_manager`

**Zweck:** Technische Umsetzung des Fokuswechsels.

**Datei:** `src/window_mechanics/focus_manager.rs`

- **Funktion `pub async fn set_application_focus(desktop_state: &Arc<Mutex<DesktopState>>, seat_name: &str, window_domain_id_to_focus: Option<&DomainWindowIdentifier>, serial: Serial)`**:
    1. Sperre `desktop_state`.
    2. Finde das `Arc<ManagedWindow>` für `window_domain_id_to_focus` (oder `None`).
    3. Rufe `system::input::keyboard::focus::set_keyboard_focus(desktop_state_guard, seat_name, target_wl_surface_option, serial)`.
    4. Aktualisiere `desktop_state_guard.active_input_surface`.
    5. Wenn `target_wl_surface_option` ein Toplevel ist: `target_toplevel.set_activated(true); target_toplevel.send_configure();`
    6. Für den vorherigen Fokus: `old_toplevel.set_activated(false); old_toplevel.send_configure();`
    7. Ggf. Fenster im `Space` anheben (`desktop_state_guard.space.raise_window(...)`).

#### 6.6. Implementierungsschritte `system::window_mechanics`

1. `types.rs`, `errors.rs` definieren.
2. `layout_applier.rs`: `apply_workspace_layout` implementieren.
3. `interactive_ops.rs`: Logik für Start und Handling von Pointer-Grabs für Move/Resize.
4. `focus_manager.rs`: `set_application_focus` implementieren.
5. Tests: Mocking von `DesktopState` (schwierig), `DomainWindowManagementPolicyService`. Testen der Geometrieanwendung. Testen der Grab-Logik (Zustandsübergänge).

---

### Modul 7: `system::power_management`

Zweck: Implementierung von DPMS und Interaktion mit Power-Management-Protokollen/Diensten.

Verantwortlichkeiten: Überwachen der Benutzeraktivität und System-Idle-Hinweise, Anwenden von Energieeinstellungen (Bildschirm-Timeout, Suspend-Verhalten) von der Domänenschicht, Steuerung des DPMS-Zustands von Bildschirmen.

Design-Rationale: Zentralisierung der Energieverwaltungslogik, die sowohl auf Benutzereingaben als auch auf Systemzustände reagiert.

#### 7.1. Untermodul: `system::power_management::types`

**Datei:** `src/power_management/types.rs`

- **Enum `DpmsState`**: `On, Standby, Suspend, Off`.
- **Event (System-intern, via `system::event_bridge`):**
    
    Rust
    
    ```
    #[derive(Debug, Clone)]
    pub enum PowerManagementEvent {
        OutputDpmsStateChanged { output_name: String, new_state: DpmsState },
        SystemSuspending(crate::dbus_interfaces::logind_client::types::LogindPowerOperation), // Pfad anpassen
        SystemResumed,
    }
    ```
    
- **Struct `IdleTimerState`**: `last_activity_ts: DateTime<Utc>`, `current_timeout_secs: u32`, `timer_handle: Option<calloop::TimerHandle>`.

#### 7.2. Untermodul: `system::power_management::errors`

**Datei:** `src/power_management/errors.rs`

- **Enum `PowerManagementError`**:
    
    Rust
    
    ```
    #[derive(Debug, Error)]
    pub enum PowerManagementError {
        #[error("Failed to set DPMS state for output '{output_name}': {reason}")]
        SetDpmsFailed { output_name: String, reason: String },
        #[error("Logind operation failed: {0}")]
        LogindError(#[from] crate::dbus_interfaces::common::DBusInterfaceError), // Pfad anpassen
        #[error("Failed to interact with compositor output management: {0}")]
        CompositorOutputError(String),
        #[error("Internal power management error: {0}")]
        InternalError(String),
    }
    ```
    

#### 7.3. Submodul: `system::power_management::service`

**Zweck:** Hauptlogik des Power-Management-Dienstes.

**Datei:** `src/power_management/service.rs`

- **Struct `PowerManagementService`**:
    - **Felder:**
        - `desktop_state_weak: Weak<Mutex<DesktopState>>` (oder direkter Zugriff, falls in `DesktopState` integriert)
        - `settings_service: Arc<dyn GlobalSettingsService>`
        - `logind_service: Arc<dyn LogindClientService>` // Annahme, dass LogindClientService ein Trait ist
        - `event_publisher: tokio::sync::broadcast::Sender<PowerManagementEvent>`
        - `user_activity_receiver: tokio::sync::broadcast::Receiver<UserActivityDetectedEvent>` (aus `common_events`)
        - `logind_event_receiver: tokio::sync::broadcast::Receiver<LogindEvent>`
        - `output_idle_timers: Arc<tokio::sync::Mutex<HashMap<String /* output_name */, IdleTimerState>>>`
        - `system_idle_timer: Arc<tokio::sync::Mutex<Option<IdleTimerState>>>` // Für automatischen Suspend
    - **Konstruktor `new(...)`**: Nimmt Abhängigkeiten, abonniert `UserActivityDetectedEvent` und `LogindEvent`.
    - **Methode `pub async fn run(&self)`**: Hauptschleife des Dienstes (läuft als `tokio::task`).
        1. Lädt initiale Energieeinstellungen vom `settings_service`.
        2. Startet Listener für `SettingChangedEvent` (um Energieeinstellungen neu zu laden).
        3. Verarbeitet eingehende `UserActivityDetectedEvent`: Setzt alle Idle-Timer zurück.
        4. Verarbeitet eingehende `LogindEvent::PrepareForSleep/Shutdown`: Führt Aktionen aus (z.B. DPMS Off).
        5. Verarbeitet `LogindEvent::SystemIdleHintChanged`.
        6. Periodisch (oder bei Timer-Ablauf):
            - Prüft `output_idle_timers`. Wenn Timeout erreicht: Setze DPMS-Status des Outputs (via Compositor/DRM-Backend). Sendet `OutputDpmsStateChanged`.
            - Prüft `system_idle_timer`. Wenn Timeout erreicht: Rufe `self.logind_service.suspend(false)` oder `hibernate(false)` auf, basierend auf Policy.
    - **Private Methoden:**
        - `async fn reset_idle_timers(&self, current_settings: &PowerManagementPolicySettings)`
        - `async fn apply_dpms_state(&self, output_name: &str, dpms_state: DpmsState)`: Interagiert mit `system::compositor::output_management` (oder direkt DRM-Backend), um DPMS zu setzen.
        - `async fn on_screen_blank_timeout(&self, output_name: &str, current_settings: &PowerManagementPolicySettings)`
        - `async fn on_system_suspend_timeout(&self, current_settings: &PowerManagementPolicySettings)`

#### 7.4. Implementierungsschritte `system::power_management`

1. `types.rs`, `errors.rs` definieren.
2. `service.rs`: `PowerManagementService` implementieren.
    - Event-Loops für `UserActivityDetectedEvent` und `LogindEvent`.
    - Logik für Idle-Timer-Management mit `calloop::Timer` (muss mit `tokio` synchronisiert werden, wenn Service `async` ist, z.B. Timer in `calloop`-Schleife, der Nachricht an `tokio`-Task sendet).
    - Interaktion mit `GlobalSettingsService` für Policies.
    - Interaktion mit `LogindClientService` für Suspend/Hibernate.
    - Interaktion mit Compositor (Output-Management) für DPMS.
3. Tests: Mocking von Abhängigkeiten, Testen der Timer-Logik und Zustandsübergänge.

---

### Modul 8: `system::event_bridge`

Zweck: Eine zentrale Stelle für System-interne Events, die nicht direkt an einen spezifischen D-Bus-Dienst oder ein Wayland-Protokoll gebunden sind. Dient der Entkopplung innerhalb der Systemschicht und als definierte Quelle für bestimmte Domänen-Events.

Verantwortlichkeiten: Definition von generischen System-Event-Typen. Bereitstellung von tokio::sync::broadcast Kanälen für diese Events.

Design-Rationale: Verhindert direkte Abhängigkeiten zwischen allen Systemmodulen. Ermöglicht es Modulen, relevante Ereignisse zu publizieren, ohne ihre Konsumenten explizit kennen zu müssen.

**Datei:** `src/event_bridge/mod.rs` (kann `types.rs` und `channels.rs` enthalten)

- **Struct `SystemEventBridge`**:
    - **Felder (Beispiele für `broadcast::Sender`):**
        - `upower_event_tx: tokio::sync::broadcast::Sender<UPowerEvent>`
        - `logind_event_tx: tokio::sync::broadcast::Sender<LogindEvent>`
        - `network_manager_event_tx: tokio::sync::broadcast::Sender<NetworkManagerEvent>`
        - `audio_event_tx: tokio::sync::broadcast::Sender<AudioEvent>`
        - `mcp_client_event_tx: tokio::sync::broadcast::Sender<McpClientEvent>`
        - `window_mechanics_event_tx: tokio::sync::broadcast::Sender<WindowMechanicsEvent>`
        - `power_management_event_tx: tokio::sync::broadcast::Sender<PowerManagementEvent>`
        - `input_device_hotplug_event_tx: tokio::sync::broadcast::Sender<InputDeviceHotplugEvent>`
        - **Domänen-Events, die von der Systemschicht ausgelöst werden:**
        - `user_activity_event_tx: tokio::sync::broadcast::Sender<crate::domain::common_events::UserActivityDetectedEvent>`
        - `system_shutdown_event_tx: tokio::sync::broadcast::Sender<crate::domain::common_events::SystemShutdownInitiatedEvent>`
    - **Konstruktor `new(capacity_per_channel: usize) -> Self`**: Initialisiert alle Sender.
    - **Methoden zum Abrufen von `Receiver`n**:
        - `pub fn subscribe_upower_events(&self) -> tokio::sync::broadcast::Receiver<UPowerEvent>` (analog für alle anderen).
    - **Methoden zum Senden von Events (intern von anderen Systemmodulen genutzt):**
        - `pub(crate) fn publish_upower_event(&self, event: UPowerEvent)` (analog).
- **Event-Typen (Beispiele, falls noch nicht in spezifischen Modulen definiert):**
    - `InputDeviceHotplugEvent { device_name: String, device_type: String /* z.B. "keyboard", "pointer" */, event_type: HotplugType /* Added, Removed */}`
    - Die meisten spezifischen Events (`UPowerEvent`, `LogindEvent` etc.) werden in ihren jeweiligen Modulen (`system::dbus_interfaces::upower_client::types`) definiert und hier nur die Sender verwaltet.

**Implementierungsschritte `system::event_bridge`**:

1. `SystemEventBridge`-Struktur definieren.
2. Konstruktor und `subscribe_`/`publish_`-Methoden implementieren.
3. Sicherstellen, dass alle Systemmodule, die Events publizieren oder konsumieren, eine Referenz (`Arc`) zum `SystemEventBridge` erhalten (z.B. bei der Initialisierung von `DesktopState` oder der Systemschicht).

---

Diese detaillierten Pläne für die Module 3 (Vervollständigung) bis 8 der Systemschicht bilden eine solide Grundlage für die Implementierung. Die Komplexität liegt weiterhin in der korrekten asynchronen Integration, der Interaktion mit externen Bibliotheken/Protokollen und der robusten Fehlerbehandlung.

---

### Modul 5: `system::mcp_client`

Zweck: Implementierung des Clients für das Model Context Protocol (MCP), um sicher mit lokalen oder Cloud-basierten KI-Modellen (LLMs) zu interagieren.

Verantwortlichkeiten:

- Aufbau und Verwaltung der Verbindung zu einem MCP-Server.
- Senden von Anfragen an den MCP-Server (z.B. `Initialize`, `ListResources`, `CallTool`) basierend auf Anweisungen von `domain::user_centric_services::ai_interaction`.
- Empfangen von Antworten und asynchronen Benachrichtigungen (`Notification`) vom MCP-Server.
- Sichere Handhabung von API-Schlüsseln (via `system::dbus_interfaces::secrets_service_client`) für Cloud-basierte Modelle.
- Bereitstellung einer abstrahierten Schnittstelle (`SystemMcpService`-Trait) für die Domänenschicht. **Design-Rationale:** Kapselung der MCP-spezifischen Kommunikationslogik. Nutzung des `mcp_client_rs` Crates als Basis. Ermöglichung einer flexiblen Anbindung verschiedener KI-Modelle. **Technologie:** `mcp_client_rs` Crate, `tokio` für asynchrone Operationen, `serde` für Datenstrukturen.

**Abhängigkeiten in `novade-system/Cargo.toml` (zusätzlich):**

Ini, TOML

```
mcp_client_rs = "0.2.0" # Aktuelle Version des mcp_client_rs Crates prüfen
# ggf. http_types oder reqwest, falls RemoteHttp direkt implementiert wird und mcp_client_rs dies nicht vollständig abstrahiert
```

#### 5.1. Untermodul: `system::mcp_client::types`

**Datei:** `src/mcp_client/types.rs`

- **Struct `McpServerConfig`**:
    
    - **Definition:** Wie in der vorherigen Antwort (Teil 4 der Systemschicht-Spezifikation).
        
        Rust
        
        ```
        use serde::{Serialize, Deserialize};
        use std::path::PathBuf; // Für working_directory
        
        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
        pub enum McpServerType {
            LocalExecutable {
                command: String,
                args: Vec<String>,
                #[serde(default, skip_serializing_if = "Option::is_none")]
                working_directory: Option<PathBuf>, // PathBuf verwenden
            },
            RemoteHttp {
                endpoint_url: String,
            },
        }
        
        #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
        pub struct McpServerConfig {
            pub server_id: String,
            pub server_type: McpServerType,
            #[serde(default = "default_request_timeout_ms_config")]
            pub default_request_timeout_ms: u64,
        }
        
        fn default_request_timeout_ms_config() -> u64 { 30000 } // 30 Sekunden
        
        impl Default for McpServerConfig { /* ... */ } // Sinnvoller Default, z.B. für einen häufig genutzten lokalen Server
        ```
        
- **Re-Export von `mcp_client_rs::protocol` Typen:**
    
    Rust
    
    ```
    pub use mcp_client_rs::protocol::{
        InitializeParams, InitializeResult, ListResourcesParams, ListResourcesResult,
        Resource, ToolDefinition, CallToolParams, CallToolResult, ToolCall, ToolResult,
        McpMessage, Notification as McpProtocolNotification, ErrorResponse, ErrorCode,
        // Weitere benötigte Typen aus dem Protokoll
    };
    ```
    
- **Event-Struktur (für `system::event_bridge` oder direkt an Domäne):**
    
    Rust
    
    ```
    use uuid::Uuid;
    // McpProtocolNotification, McpErrorResponse, McpToolResult sind bereits oben re-exportiert
    
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum McpClientSystemEvent { // Umbenannt von McpClientEvent zur Unterscheidung von Domain-Events
        McpNotificationReceived {
            server_id: String,
            interaction_id: Option<Uuid>,
            notification: McpProtocolNotification,
        },
        McpToolCallSuccessful {
            server_id: String,
            interaction_id: Uuid,
            request_id: String,
            tool_result: McpToolResult,
        },
        McpRequestFailed { // Wenn die Anfrage den Server erreicht hat, aber dieser einen Fehler zurückgibt
            server_id: String,
            interaction_id: Option<Uuid>,
            request_id: Option<String>,
            error: McpErrorResponse,
        },
        McpCommunicationError { // Für Verbindungsfehler, Timeouts etc. vor/während der Anfrage
            server_id: String,
            interaction_id: Option<Uuid>,
            request_id: Option<String>,
            message: String, // Detailliertere Fehlermeldung des Clients
        },
        McpServerConnectionStateChanged {
            server_id: String,
            is_connected: bool,
            error_message: Option<String>, // Grund für Disconnect
        }
    }
    ```
    

#### 5.2. Untermodul: `system::mcp_client::errors`

**Datei:** `src/mcp_client/errors.rs`

- **Enum `McpSystemClientError`**:
    
    - **Definition:** Wie in der vorherigen Antwort, aber `McpLibError` wird differenzierter behandelt. <!-- end list -->
    
    Rust
    
    ```
    use thiserror::Error;
    use mcp_client_rs::Error as McpLibInternalError; // Interner Fehler des mcp_client_rs Crates
    use crate::dbus_interfaces::common::DBusInterfaceError; // Für Secrets Service Fehler
    use super::types::ErrorResponse as McpErrorResponse; // MCP Protokoll-Fehler
    
    #[derive(Debug, Error)]
    pub enum McpSystemClientError {
        #[error("MCP Server configuration not found for ID: {0}")]
        ServerConfigNotFound(String),
        #[error("Failed to start local MCP server (command: '{command}'): {source}")]
        LocalServerStartFailed { command: String, #[source] source: std::io::Error },
        #[error("MCP client library internal error: {0}")]
        McpLibInternalError(#[from] McpLibInternalError),
        #[error("MCP server returned an error: {error_code:?} - {message}")]
        McpServerErrorReply { error_code: mcp_client_rs::protocol::ErrorCode, message: String, diagnostic_info: Option<String> }, // Von McpErrorResponse
        #[error("Failed to retrieve API key '{secret_name}' from secrets service: {source}")]
        ApiKeyRetrievalFailed { secret_name: String, #[source] source: DBusInterfaceError },
        #[error("API key '{secret_name}' not found in secrets service.")]
        ApiKeyNotFound(String),
        #[error("MCP request timed out for request ID '{request_id}' to server '{server_id}'.")]
        RequestTimeout { server_id: String, request_id: String },
        #[error("MCP Server '{server_id}' is not connected or connection lost.")]
        ServerNotConnected(String),
        #[error("No active MCP server connection available for the request.")]
        NoActiveConnection,
        #[error("Failed to serialize MCP request: {0}")]
        SerializationError(#[from] serde_json::Error), // Falls wir manuell serialisieren
        #[error("Failed to deserialize MCP response: {0}")]
        DeserializationError(serde_json::Error), // Falls wir manuell deserialisieren
        #[error("Unsupported MCP server type: {0:?}")]
        UnsupportedServerType(super::types::McpServerType),
        #[error("Internal MCP client error: {0}")]
        InternalError(String),
    }
    
    // Konvertierung von McpErrorResponse zu McpSystemClientError
    impl From<McpErrorResponse> for McpSystemClientError {
        fn from(err_resp: McpErrorResponse) -> Self {
            McpSystemClientError::McpServerErrorReply {
                error_code: err_resp.error.code,
                message: err_resp.error.message,
                diagnostic_info: err_resp.error.data.and_then(|v| serde_json::to_string(&v).ok()),
            }
        }
    }
    ```
    

#### 5.3. Untermodul: `system::mcp_client::connection_manager`

**Zweck:** Verwaltung von Verbindungen zu MCP-Servern.

**Datei:** `src/mcp_client/connection_manager.rs`

- **Struct `McpConnection`**:
    - **Felder:** Wie in der vorherigen Antwort.
        - `server_id: String`
        - `client: mcp_client_rs::McpClient`
        - `local_process_handle: Arc<tokio::sync::Mutex<Option<tokio::process::Child>>>` (Arc&lt;Mutex&lt;Option&lt;...>>> damit der Listener-Task den Prozess ggf. beenden kann)
        - `is_connected_state: Arc<tokio::sync::watch::Sender<bool>>` (Sender, damit der Manager den Status setzen kann)
        - `notification_task_handle: Option<tokio::task::JoinHandle<()>>` (Für den Task, der `client.receive_message()` lauscht)
    - **Methoden:**
        - **`pub async fn new(config: &McpServerConfig, api_key: Option<String>, event_publisher_clone: tokio::sync::broadcast::Sender<McpClientSystemEvent>, server_id_clone: String) -> Result<Self, McpSystemClientError>`**:
            1. `is_connected_state_tx = Arc::new(tokio::sync::watch::channel(false).0);`
            2. Wenn `LocalExecutable`: Starte Prozess, `client = McpClient::attach_stdio(child_process.stdin.take().unwrap(), child_process.stdout.take().unwrap()).await?`.
            3. Wenn `RemoteHttp`: `client = McpClient::connect_http(&config.endpoint_url, api_key).await?`.
            4. Setze `is_connected_state_tx.send(true).ok();`.
            5. Starte `notification_task`:
                
                Rust
                
                ```
                let client_clone = client.clone(); // McpClient muss Clone sein
                let is_connected_state_clone = is_connected_state_tx.clone();
                let publisher_clone = event_publisher_clone;
                let s_id_clone = server_id_clone;
                
                let handle = tokio::spawn(async move {
                    loop {
                        match client_clone.receive_message().await {
                            Ok(Some(McpMessage::Notification(notification))) => {
                                publisher_clone.send(McpClientSystemEvent::McpNotificationReceived {
                                    server_id: s_id_clone.clone(),
                                    interaction_id: None, // Muss aus Notification-Payload extrahiert werden, falls vorhanden
                                    notification,
                                }).ok();
                            }
                            Ok(Some(McpMessage::Response { .. })) => {
                                tracing::warn!("Unerwartete Response im Notification-Stream von MCP Server {}", s_id_clone);
                            }
                            Ok(None) => { // Stream beendet (Verbindung geschlossen)
                                tracing::info!("MCP Notification-Stream für Server {} beendet.", s_id_clone);
                                is_connected_state_clone.send(false).ok();
                                publisher_clone.send(McpClientSystemEvent::McpServerConnectionStateChanged {
                                    server_id: s_id_clone.clone(),
                                    is_connected: false,
                                    error_message: Some("Connection closed by server or stream ended.".to_string()),
                                }).ok();
                                break;
                            }
                            Err(e) => {
                                tracing::error!("Fehler beim Empfangen der MCP Notification von Server {}: {:?}", s_id_clone, e);
                                is_connected_state_clone.send(false).ok();
                                publisher_clone.send(McpClientSystemEvent::McpServerConnectionStateChanged {
                                    server_id: s_id_clone.clone(),
                                    is_connected: false,
                                    error_message: Some(format!("Receive error: {}", e)),
                                }).ok();
                                break;
                            }
                        }
                    }
                });
                ```
                
            6. Return `Self { ..., notification_task_handle: Some(handle), ... }`.
        - **`pub async fn close(&mut self)`**:
            1. `self.is_connected_state.send(false).ok();`
            2. `self.client.close().await;` (Wenn `McpClient` eine `close`-Methode hat).
            3. Wenn `notification_task_handle.take().is_some()`, `handle.abort();` (oder sanfter beenden).
            4. Wenn `local_process_handle.lock().await.take().is_some()`, `child.kill().await?`.
- **Struct `McpConnectionManager`**:
    - **Felder:** Wie in der vorherigen Antwort.
    - **Methoden:**
        - `load_server_configs` (wie zuvor).
        - `get_or_connect`:
            1. Prüft `connections` Cache. Wenn verbunden (`is_connected_state.borrow() == true`), zurückgeben.
            2. API-Key-Abruf via `secrets_service`.
            3. `McpConnection::new(...)` aufrufen.
            4. Verbindung in `connections` speichern.
            5. `event_publisher.send(McpServerConnectionStateChanged { is_connected: true, ... })`.
        - `disconnect` (wie zuvor, ruft `McpConnection::close()`).
        - `get_active_connection_for_model` (wie zuvor).

#### 5.4. Submodul: `system::mcp_client::service`

**Zweck:** Implementierung des `SystemMcpService` Traits.

**Datei:** `src/mcp_client/service.rs`

- **Trait `SystemMcpService`**: Wie in der vorherigen Antwort.
- **Struct `DefaultSystemMcpService`**:
    - **Felder:** `connection_manager: Arc<McpConnectionManager>`.
    - **Implementierung von `SystemMcpService`**:
        - **`initialize_server`, `list_resources`, `call_tool`**:
            1. `mcp_conn_arc = self.connection_manager.get_or_connect(server_id, model_profile).await?;`
            2. `let mcp_conn_guard = mcp_conn_arc; // Arc kann direkt verwendet werden, McpClient ist Clone`
            3. `let client_ref = &mcp_conn_guard.client;`
            4. Timeout erstellen: `tokio::time::timeout(Duration::from_millis(timeout_ms), client_ref.send_request_json(mcp_protocol_message)).await`
                - Wenn `Ok(Ok(response_message))`: Verarbeite `response_message`.
                - Wenn `Ok(Err(mcp_lib_err))`: `Err(McpSystemClientError::McpLibInternalError(mcp_lib_err))`.
                - Wenn `Err(_timeout_err)`: `Err(McpSystemClientError::RequestTimeout { ... })`.
            5. Wenn `response_message` eine `McpMessage::Error(err_resp)` ist:
                - `self.connection_manager.event_publisher.send(McpClientSystemEvent::McpRequestFailed { ..., error: err_resp.clone() }).ok();`
                - `Err(McpSystemClientError::from(err_resp))`
            6. Sonst: Parse Response in den erwarteten Typ (z.B. `InitializeResult`). Bei Erfolg, `McpToolCallSuccessful` Event senden (für `call_tool`).
        - **`subscribe_to_mcp_events`**: `self.connection_manager.event_publisher.subscribe()`.

#### 5.5. Implementierungsschritte `system::mcp_client`

(Wie in vorheriger Antwort, aber mit Fokus auf `tokio::sync::Mutex/RwLock/watch`, `tokio::process` und `tokio::task` für asynchrone Operationen und den Notification-Listener-Task in `McpConnection`.)

1. **Grundgerüst**: Verzeichnisse, `Cargo.toml` anpassen.
2. **`types.rs`**: `McpServerConfig` (mit `PathBuf`), `McpClientSystemEvent`, Protokoll-Typen re-exportieren.
3. **`errors.rs`**: `McpSystemClientError` (mit detaillierter Fehlerbehandlung für `McpLibInternalError` und `McpErrorResponse`).
4. **`connection_manager.rs`**:
    - `McpConnection`: `new` implementieren (Prozessstart, Verbindung, Notification-Listener-Task). `close` implementieren.
    - `McpConnectionManager`: `new`, `load_server_configs`, `get_or_connect` (mit API-Key-Abruf), `disconnect`, `get_active_connection_for_model`.
5. **`service.rs`**: `SystemMcpService`-Trait und `DefaultSystemMcpService`-Implementierung. Timeout-Logik für Anfragen. Korrektes Event-Publishing.
6. **`mod.rs`**: API re-exportieren.
7. **Unit-/Integrationstests**:
    - Mocking für `SecretsServiceClientService`.
    - Testen der lokalen Prozessstart- und Managementlogik.
    - Für HTTP-Verbindungen: Testen gegen einen einfachen Mock-MCP-HTTP-Server.
    - Testen der Timeout-Logik.
    - Testen des Notification-Listener-Tasks (Senden von Dummy-Notifications).

---

### Modul 6: `system::window_mechanics`

Zweck: Technische Umsetzung des Fenstermanagements (Positionierung, Größe, Stapelreihenfolge, Tiling, Fokus, Dekorationen) basierend auf Domänen-Policies.

Verantwortlichkeiten: Anwenden von WorkspaceWindowLayout auf Compositor-Fenster, Senden von configure-Events, Handhabung interaktiver Operationen (Move/Resize), Koordination von SSD/CSD, technische Fokusumsetzung.

Design-Rationale: Trennung von "Mechanik" und "Policy". Enge Kopplung mit system::compositor und domain::window_management_policy.

#### 6.1. Untermodul: `system::window_mechanics::types`

**Datei:** `src/window_mechanics/types.rs`

- **Struct `InteractiveOpState`**: Wie in der vorherigen Antwort.
    
    Rust
    
    ```
    use smithay::{
        utils::{Logical, Point, Rectangle, Serial},
        reexports::wayland_protocols::xdg::shell::server::xdg_toplevel::ResizeEdge,
    };
    use crate::compositor::xdg_shell::types::ManagedWindow; // Pfad anpassen
    use std::sync::Arc;
    
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum InteractiveOpType { Move, Resize(ResizeEdge) } // ResizeEdge aus xdg_toplevel
    
    #[derive(Debug, Clone)]
    pub struct InteractiveOpState {
        pub window_arc: Arc<ManagedWindow>, // Smithay's Window Trait-Objekt
        pub op_type: InteractiveOpType,
        pub start_pointer_pos_global: Point<f64, Logical>, // Globale Position beim Start des Grabs
        pub initial_window_geometry: Rectangle<i32, Logical>, // Geometrie des Fensters beim Start des Grabs
        pub last_configure_serial: Option<Serial>, // Um Configure-Storms zu vermeiden
        // Für Resize:
        pub initial_window_size_constraints: Option<(Option<Size<i32, Logical>>, Option<Size<i32, Logical>>)>, // (min_size, max_size)
    }
    ```
    
- **Event (System-intern, via `system::event_bridge`):**
    
    Rust
    
    ```
    use crate::domain::workspaces::core::types::WindowIdentifier as DomainWindowIdentifier;
    use crate::core::types::RectInt; // Aus novade-core
    use smithay::wayland::shell::xdg::ToplevelState; // Beispiel für Zustandsflags
    
    #[derive(Debug, Clone)]
    pub enum WindowMechanicsEvent {
        WindowConfiguredByMechanics { // Unterscheidung von Client-initiiertem Configure
            window_domain_id: DomainWindowIdentifier,
            new_geometry: RectInt, // Die tatsächlich angewendete Geometrie
            new_state: Vec<ToplevelState>, // z.B. Maximized, Activated etc.
        },
        InteractiveOpStarted { window_domain_id: DomainWindowIdentifier, op_type: InteractiveOpType },
        InteractiveOpEnded { window_domain_id: DomainWindowIdentifier, op_type: InteractiveOpType, final_geometry: RectInt },
        FocusSetByMechanics(Option<DomainWindowIdentifier>), // Wenn der Fokus durch Mechanics geändert wurde
    }
    ```
    

#### 6.2. Untermodul: `system::window_mechanics::errors`

**Datei:** `src/window_mechanics/errors.rs`

- **Enum `WindowMechanicsError`**: Wie in der vorherigen Antwort.
    - Zusätzlich: `#[error("Window {0:?} does not support the requested operation (e.g., trying to resize a non-resizable window).")] WindowOperationNotSupported(DomainWindowIdentifier)`

#### 6.3. Untermodul: `system::window_mechanics::layout_applier`

**Zweck:** Anwenden eines von der Domäne berechneten Layouts.

**Datei:** `src/window_mechanics/layout_applier.rs`

- **Funktion `pub async fn apply_workspace_layout(desktop_state_accessor: &impl Fn() -> Arc<Mutex<DesktopState>>, workspace_id: WorkspaceId, layout: &WorkspaceWindowLayout) -> Result<(), WindowMechanicsError>`**:
    
    - **Annahme:** `DesktopStateAccessor` ist ein Weg, um Zugriff auf `DesktopState` zu bekommen, da `DesktopState` selbst nicht einfach `Send` sein könnte für `async fn`. Einfacher: Wenn `apply_workspace_layout` von einem Ort aufgerufen wird, der bereits Zugriff auf `&mut DesktopState` hat (z.B. innerhalb eines `calloop` Callbacks oder eines `tokio::task::block_in_place`), dann kann es synchron sein. Für die Spezifikation nehmen wir an, dass es irgendwie Zugriff bekommt.
    - **Alternative (synchron, wenn im Compositor-Thread):** `pub fn apply_workspace_layout_blocking(desktop_state: &mut DesktopState, workspace_id: WorkspaceId, layout: &WorkspaceWindowLayout) -> Result<(), WindowMechanicsError>` <!-- end list -->
    
    1. `tracing::debug!("Wende Layout für Workspace {:?} an: {:?}", workspace_id, layout);`
    2. `let space = &mut desktop_state.space;`
    3. `let windows_map = &mut desktop_state.windows;` // Map von DomainWindowIdentifier zu Arc&lt;ManagedWindow>
    4. Für jede `(domain_id, target_geometry)` in `layout.window_geometries`:
        - `let managed_window_arc = match windows_map.get(&domain_id) { Some(w) => w.clone(), None => { tracing::warn!("Fenster {:?} im Layout nicht in DesktopState gefunden.", domain_id); continue; } };`
        - `let mut managed_window_ref = (*managed_window_arc).clone(); // Klone Arc für Smithay-Window-Trait-Methoden, wenn ManagedWindow selbst nicht Mutex-geschützt ist.`
        - `managed_window_ref.current_geometry = target_geometry;` // Internen Zustand aktualisieren
        - **Senden der Konfiguration an den Client (Beispiel für Toplevel):**
            - `if let WindowSurface::Toplevel(toplevel) = &managed_window_ref.xdg_surface { ... }`
            - `let mut new_xdg_states = Vec::new();`
            - // Logik, um layout.tiling_mode_applied in XDG-Zustände zu übersetzen (z.B. Maximized)
            - // if layout.tiling_mode_applied == TilingMode::MaximizedFocused && Some(&amp;domain_id) == layout.focused_window_id {
            - // new_xdg_states.push(xdg_toplevel::State::Maximized);
            - // }
            - `toplevel.with_pending_state(|xdg_state| { xdg_state.size = Some(target_geometry.size); xdg_state.states = ToplevelState::new(&new_xdg_states); });`
            - `toplevel.send_configure();`
        - `space.map_window(managed_window_arc.clone(), target_geometry.loc, true);` (Stellt sicher, dass es im Space ist und die Position aktualisiert wird. `true` für Aktivierung, falls es das fokussierte Fenster sein soll – Fokuslogik ist separat).
        - `desktop_state.event_bridge.publish_window_mechanics_event(WindowMechanicsEvent::WindowConfiguredByMechanics { ... });`
    5. Für Fenster, die im `space` sind, aber NICHT in `layout.window_geometries` (d.h. sollen nicht mehr auf diesem Workspace sichtbar sein, z.B. weil geschlossen oder auf anderen WS verschoben):
        - `if let Some(window_to_unmap) = windows_map.get(&domain_id_im_space) { space.unmap_window(window_to_unmap); }`
    6. `space.damage_all_outputs();` (Oder spezifischer: `space.damage_elements(betroffene_fenster)`).
    7. `Ok(())`

#### 6.4. Untermodul: `system::window_mechanics::interactive_ops`

**Zweck:** Handhabung von interaktiven Fenster-Moves und -Resizes.

**Datei:** `src/window_mechanics/interactive_ops.rs`

- **Struct `PointerMoveResizeGrab`**: Implementiert `smithay::input::pointer::PointerGrab<DesktopState>`.
    - **Felder:** `op_state: InteractiveOpState`, `desktop_state_accessor: impl Fn() -> Arc<Mutex<DesktopState>>` (oder `Weak<Mutex<DesktopState>>`), `window_policy_service: Arc<dyn WindowManagementPolicyService>`.
    - **`motion(...)` Logik:**
        1. `current_pointer_pos_global = global_grab_start_pos + (current_event_pos - op_state.start_pointer_pos_pointer_local);`
        2. `new_geometry = calculate_new_geometry_for_op(&op_state.initial_window_geometry, &op_state.op_type, current_pointer_pos_global, op_state.start_pointer_pos_global);`
        3. **Snapping:**
            - `other_windows_on_workspace = collect_other_windows_geometries(desktop_state_accessor, &op_state.window_arc);`
            - `snapping_policy = block_on(self.window_policy_service.get_effective_snapping_policy());`
            - `gap_settings = block_on(self.window_policy_service.get_effective_gap_settings_for_workspace(...));`
            - `if let Some(snapped_geom) = block_on(self.window_policy_service.calculate_snap_target(&op_state.window_arc.domain_id, new_geometry, &other_windows_on_workspace, workspace_area, &snapping_policy, &gap_settings)) { new_geometry = snapped_geom; }`
        4. **Größenbeschränkungen anwenden:** Klemme `new_geometry.size` auf `op_state.initial_window_size_constraints`.
        5. Aktualisiere `op_state.window_arc.current_geometry = new_geometry;` (visuelles Feedback, kein Configure).
        6. `desktop_state_accessor().lock().unwrap().space.damage_window(&op_state.window_arc, None, None);` (Alte und neue Position beschädigen).
    - **`button(...)` Logik:**
        1. Wenn Maustaste losgelassen:
            - Finalisiere `final_geometry = op_state.window_arc.current_geometry;`
            - `if let WindowSurface::Toplevel(toplevel) = &op_state.window_arc.xdg_surface { ... send_configure mit final_geometry ... }`
            - `pointer_handle.unset_grab(serial, time);`
            - `desktop_state_accessor().lock().unwrap().event_bridge.publish_window_mechanics_event(InteractiveOpEnded { ... });`
- **Funktionen `start_interactive_move` / `start_interactive_resize`**:
    1. Erstellen `InteractiveOpState`.
    2. `pointer_handle.set_grab(serial, PointerMoveResizeGrab { ... }, Focus::Clear);`

#### 6.5. Submodul: `system::window_mechanics::focus_manager` (Vervollständigung)

**Zweck:** Technische Umsetzung des Fokuswechsels basierend auf Domänenentscheidungen und Benutzerinteraktionen.

**Datei:** `src/window_mechanics/focus_manager.rs`

- **Funktion `pub async fn set_application_focus(desktop_state_accessor: &impl Fn() -> Arc<Mutex<DesktopState>>, seat_name: &str, window_domain_id_to_focus: Option<&DomainWindowIdentifier>, serial: Serial) -> Result<(), WindowMechanicsError>`**:
    1. `let mut ds_guard = desktop_state_accessor().lock().await;`
    2. `let seat = ds_guard.seat_state.seats().find(|s| s.name() == seat_name).cloned().ok_or(WindowMechanicsError::InternalError("Seat nicht gefunden".into()))?;`
    3. `let old_focused_window_domain_id = ds_guard.active_input_surface.as_ref().and_then(|weak_surf| weak_surf.upgrade()).and_then(|surf| find_domain_id_for_surface(&ds_guard, &surf));`
    4. Finde `target_managed_window_arc_option`:
        - Wenn `window_domain_id_to_focus` `Some(id)`, suche in `ds_guard.windows.get(id)`.
        - Sonst `None`.
    5. `let target_wl_surface_option = target_managed_window_arc_option.as_ref().map(|arc_win| arc_win.wl_surface().clone());`
    6. Rufen Sie `crate::input::keyboard::focus::set_keyboard_focus(&mut ds_guard, seat_name, target_wl_surface_option.as_ref(), serial)?;`
    7. // Aktivierungslogik für XDG Toplevel
        - Wenn `old_focused_window_domain_id` existiert und sich von `window_domain_id_to_focus` unterscheidet:
            - Finde altes `ManagedWindow`. Wenn Toplevel, `old_toplevel.set_activated(false); old_toplevel.send_configure();`.
        - Wenn `target_managed_window_arc_option` ein Toplevel ist (`newly_focused_toplevel`):
            - `newly_focused_toplevel.set_activated(true); newly_focused_toplevel.send_configure();`
            - `ds_guard.space.raise_window(&newly_focused_toplevel_arc, true);` // True für Fokus
            - `ds_guard.active_input_surface = target_wl_surface_option.map(|s| s.downgrade());`
    8. `ds_guard.event_bridge.publish_window_mechanics_event(FocusSetByMechanics(window_domain_id_to_focus.cloned()));`
    9. `Ok(())`
- **Funktion `fn find_domain_id_for_surface(ds: &DesktopState, surface: &WlSurface) -> Option<DomainWindowIdentifier>`**: Iteriert `ds.windows` und vergleicht `wl_surface()`.

#### 6.6. Implementierungsschritte `system::window_mechanics`

1. `types.rs`, `errors.rs` definieren.
2. `layout_applier.rs`: `apply_workspace_layout_blocking` implementieren. Fokus auf korrekte `configure`-Events.
3. `interactive_ops.rs`: `PointerMoveResizeGrab` mit `PointerGrab` Trait implementieren. `start_interactive_move/resize` Funktionen. Snapping-Logik integrieren.
4. `focus_manager.rs`: `set_application_focus` mit XDG-Aktivierungslogik und Space-Interaktion.
5. Unit-Tests (sehr komplex):
    - Testen der `apply_workspace_layout` für verschiedene Layouts (mock `DesktopState` und `ManagedWindow`s).
    - Testen der Grab-Handler-Logik (Zustandsübergänge, Geometrieberechnung).
    - Testen der Fokus-Aktivierungslogik.

---

### Modul 7: `system::power_management` (Vervollständigung)

Zweck: DPMS, Interaktion mit logind für Suspend/Hibernate, Reaktion auf Benutzerinaktivität.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

#### 7.1. Untermodul: `system::power_management::types`

**Datei:** `src/power_management/types.rs`

- **Enum `DpmsState`**: Wie in der vorherigen Antwort (`On, Standby, Suspend, Off`). Serde für Konfiguration.
- **Event `PowerManagementSystemEvent`** (umbenannt von `PowerManagementEvent`):
    
    Rust
    
    ```
    use crate::dbus_interfaces::logind_client::types::LogindPowerOperation; // Pfad anpassen
    
    #[derive(Debug, Clone)]
    pub enum PowerManagementSystemEvent {
        OutputDpmsStateSet { output_name: String, new_state: DpmsState, success: bool },
        SystemSuspendingInitiated(LogindPowerOperation), // Vom logind_client erhalten
        SystemResumedNormally,
        ScreenBlankTimeoutReached(String /* output_name */),
        SystemIdleTimeoutReached, // Für Suspend/Hibernate
    }
    ```
    
- **Struct `IdleTimerState`**: Wie in der vorherigen Antwort, aber `timer_handle` muss `Send + Sync` sein, wenn der Service in einem `tokio::task` läuft und den Timer in `calloop` der Compositor-Schleife managt. Besser: Timer wird über einen Befehl an den Compositor-Thread gesetzt.
    
    Rust
    
    ```
    use chrono::{DateTime, Utc, Duration as ChronoDuration}; // Duration für Timer
    use calloop::TimerHandle; // Wenn Timer in calloop läuft
    
    #[derive(Debug)] // TimerHandle ist nicht Clone/Debug
    pub struct IdleTimerState {
        pub timer_id: String, // Eindeutige ID für den Timer (z.B. "output-HDMI-A-1-blank", "system-suspend")
        pub last_activity_ts: DateTime<Utc>,
        pub current_timeout_duration: ChronoDuration,
        // pub calloop_timer_handle: Option<TimerHandle>, // Wenn direkt in calloop
        // Alternativ: Timestamp, wann der Timer ablaufen soll
        pub scheduled_expiry_ts: Option<DateTime<Utc>>,
    }
    ```
    

#### 7.2. Untermodul: `system::power_management::errors`

**Datei:** `src/power_management/errors.rs`

- **Enum `PowerManagementError`**: Wie in der vorherigen Antwort.

#### 7.3. Untermodul: `system::power_management::service`

**Datei:** `src/power_management/service.rs`

- **Trait `PowerManagementControl`** (Schnittstelle zum Compositor/DRM-Backend für DPMS):
    
    Rust
    
    ```
    use async_trait::async_trait;
    use super::types::DpmsState;
    use super::errors::PowerManagementError;
    
    #[async_trait]
    pub trait PowerManagementControl: Send + Sync {
        async fn set_output_dpms_state(&self, output_name: &str, state: DpmsState) -> Result<(), PowerManagementError>;
        async fn list_outputs_for_dpms(&self) -> Result<Vec<String>, PowerManagementError>; // Gibt Namen der relevanten Outputs
    }
    ```
    
- **Struct `PowerManagementService`**:
    - **Felder:**
        - `settings_service: Arc<dyn GlobalSettingsService>`
        - `logind_service: Arc<dyn LogindClientService>`
        - `compositor_dpms_control: Arc<dyn PowerManagementControl>` (Injizierte Abhängigkeit)
        - `event_publisher: tokio::sync::broadcast::Sender<PowerManagementSystemEvent>`
        - `system_event_receiver: tokio::sync::broadcast::Receiver<crate::event_bridge::SystemLayerEvent>` (Empfängt `UserActivityDetectedEvent`, `LogindSystemEvent::PrepareForSleep/Shutdown`, `SettingChangedEvent` für Power-Settings).
        - `active_timers: Arc<tokio::sync::Mutex<HashMap<String /* timer_id */, IdleTimerState>>>`
        - `current_power_settings: Arc<tokio::sync::RwLock<crate::domain::global_settings_and_state_management::types::PowerManagementPolicySettings>>`
        - `on_ac_power: Arc<tokio::sync::RwLock<bool>>` (Wird durch UPower-Events aktualisiert)
    - **Konstruktor `new(...)`**: Nimmt Abhängigkeiten, abonniert Events vom `SystemEventBridge`.
    - **Methode `pub async fn run(&self)`**: Haupt-Task des Dienstes.
        1. Lädt initiale `PowerManagementPolicySettings` und `on_ac_power`-Status.
        2. Initialisiert/Resettet alle Idle-Timer basierend auf aktuellen Einstellungen und AC-Status.
        3. **Event-Loop (`tokio::select!`)**:
            - Hört auf `system_event_receiver`:
                - `UserActivityDetectedEvent`: `self.reset_all_idle_timers().await;`
                - `LogindSystemEvent::PrepareForSleep(is_suspending)`: Setze alle Outputs auf `DpmsState::Off`. `self.cancel_all_idle_timers().await;`
                - `LogindSystemEvent::SystemResumed`: `self.reset_all_idle_timers().await;` Setze Outputs auf `DpmsState::On`.
                - `SettingChangedEvent` für Power-Pfade: Lade `current_power_settings` neu, `self.reset_all_idle_timers().await;`
                - `UPowerSystemEvent::OnBatteryChanged(is_on_battery)`: Aktualisiere `self.on_ac_power`, `self.reset_all_idle_timers().await;`
            - Hört auf Timer-Abläufe (wenn Timer in `tokio` verwaltet werden, z.B. `tokio::time::sleep_until` für jeden Timer in einem separaten Task, der dann eine Nachricht an diesen Haupt-Task sendet).
                - Wenn "Screen Blank Timeout" für einen Output abläuft: `self.apply_dpms_state(output_name, DpmsState::Off).await;` Sende `ScreenBlankTimeoutReached`.
                - Wenn "System Suspend Timeout" abläuft:
                    - Rufe `self.logind_service.suspend(false).await` oder `hibernate(false).await` basierend auf Policy. Sende `SystemIdleTimeoutReached`.
    - **Private Methoden:**
        - `async fn reset_all_idle_timers(&self)`: Liest aktuelle Settings und AC-Status. Berechnet neue Timeout-Dauern (z.B. `screen_blank_timeout_ac_secs` vs. `_battery_secs`). Startet/Neustartet `tokio::time::sleep_until` für jeden Output-Timer und den System-Suspend-Timer. Speichert `ScheduledExpiryTs` in `IdleTimerState`.
        - `async fn cancel_all_idle_timers(&self)`: Bricht laufende `tokio::time::sleep_until` ab (indem die Tasks, die sie verwalten, beendet werden oder indem `scheduled_expiry_ts` auf `None` gesetzt wird).
        - `async fn apply_dpms_state(...)`: Ruft `self.compositor_dpms_control.set_output_dpms_state(...)`. Sendet `OutputDpmsStateSet`.

#### 7.4. Implementierungsschritte `system::power_management`

1. `types.rs`, `errors.rs` definieren. `PowerManagementControl`-Trait definieren.
2. `service.rs`: `PowerManagementService` implementieren.
    - Event-Loop-Logik mit `tokio::select!`.
    - Timer-Management mit `tokio::time::sleep_until` (oder Integration mit `calloop`, falls performanter/einfacher im Compositor-Kontext).
    - Interaktion mit `GlobalSettingsService`, `LogindClientService`, `PowerManagementControl`.
3. Sicherstellen, dass `PowerManagementControl` im Compositor-Modul implementiert wird (z.B. `impl PowerManagementControl for DesktopState`).
4. Tests: Mocking von Abhängigkeiten. Testen der Timer-Logik, korrekte Reaktion auf Events, korrekte Anwendung von Policies (AC vs. Batterie).

---

### Modul 8: `system::event_bridge` (Vervollständigung)

Zweck: Zentrale Event-Verteilung innerhalb der Systemschicht und ggf. an die Domänenschicht für System-level Events.

Bestehende Spezifikation: Skizziert in der vorherigen Antwort.

**Datei:** `src/event_bridge/events.rs` (Definition aller System-internen Events)

- Hier werden alle Events definiert, die in den `types.rs`-Dateien der Submodule (`UPowerEvent`, `LogindEvent`, `NetworkManagerEvent`, `AudioEvent`, `McpClientSystemEvent`, `WindowMechanicsEvent`, `PowerManagementSystemEvent`, `InputDeviceHotplugEvent`) definiert wurden, ggf. gewrappt in ein übergreifendes `SystemLayerEvent`-Enum.
    
    Rust
    
    ```
    // Beispiel:
    // use crate::dbus_interfaces::upower_client::types::UPowerEvent;
    // use crate::input::types::InputDeviceHotplugEvent; // Beispiel
    // ...
    
    #[derive(Debug, Clone)] // Ggf. Serialize/Deserialize wenn über Grenzen gesendet
    pub enum SystemLayerEvent {
        UPower(UPowerEvent),
        Logind(LogindEvent),
        NetworkManager(NetworkManagerEvent),
        Audio(AudioEvent),
        McpClient(McpClientSystemEvent),
        WindowMechanics(WindowMechanicsEvent),
        PowerManagement(PowerManagementSystemEvent),
        InputDeviceHotplug(InputDeviceHotplugEvent),
        // Auch Domänen-Events, die von Systemschicht ausgelöst werden
        DomainUserActivity(crate::domain::common_events::UserActivityDetectedEvent),
        DomainSystemShutdown(crate::domain::common_events::SystemShutdownInitiatedEvent),
    }
    ```
    

**Datei:** `src/event_bridge/mod.rs`

- **Struct `SystemEventBridge`**:
    - **Felder:** Hält einen einzelnen `tokio::sync::broadcast::Sender<SystemLayerEvent>`.
        - `event_tx: tokio::sync::broadcast::Sender<SystemLayerEvent>`
    - **Konstruktor `new(capacity: usize) -> Self`**.
    - **Methoden:**
        - `pub fn subscribe(&self) -> tokio::sync::broadcast::Receiver<SystemLayerEvent>`
        - `pub(crate) fn publish(&self, event: SystemLayerEvent)`: Sendet das Event. Loggt Fehler, wenn keine Subscriber vorhanden sind.
- **Globale Instanz (optional aber oft praktisch):**
    
    Rust
    
    ```
    use std::sync::OnceLock;
    static SYSTEM_EVENT_BRIDGE_INSTANCE: OnceLock<SystemEventBridge> = OnceLock::new();
    
    pub fn global_system_event_bridge() -> &'static SystemEventBridge {
        SYSTEM_EVENT_BRIDGE_INSTANCE.get().expect("SystemEventBridge nicht initialisiert")
    }
    
    pub fn initialize_global_system_event_bridge(capacity: usize) {
        if SYSTEM_EVENT_BRIDGE_INSTANCE.set(SystemEventBridge::new(capacity)).is_err() {
            tracing::warn!("SystemEventBridge bereits initialisiert.");
        }
    }
    ```
    
    - Die Initialisierung würde sehr früh im Startprozess der Systemschicht erfolgen.

**Implementierungsschritte `system::event_bridge`**:

1. Alle relevanten Event-Typen in `events.rs` (oder den jeweiligen Modulen und hier re-exportiert/gewrappt) definieren.
2. `SystemEventBridge`-Struktur und globale Instanz implementieren.
3. Alle Systemmodule, die Events publizieren, nutzen `global_system_event_bridge().publish(...)`.
4. Alle Systemmodule (und Adapter zur Domänenschicht), die Events konsumieren, nutzen `global_system_event_bridge().subscribe()` und filtern dann nach dem `SystemLayerEvent`-Typ.

---

**Finale `novade-system/src/lib.rs` (Struktur):**

Rust

```
// novade-system/src/lib.rs

// Kern- und Domänen-Abhängigkeiten
// use novade_core;
// use novade-domain;

// System-interne Module
pub mod audio_management;
pub mod compositor;
pub mod dbus_interfaces;
pub mod event_bridge; // Muss früh initialisiert werden
pub mod input;
pub mod mcp_client;
pub mod power_management;
pub mod window_mechanics;

// Öffentliche API der Systemschicht (Traits und wichtige Typen)
// Diese werden typischerweise von der Hauptanwendung (Binary) oder der UI-Schicht genutzt.
// Beispiel:
// pub use compositor::CompositorControlService; // Hypothetischer Trait
// pub use input::InputControlService;          // Hypothetischer Trait
pub use dbus_interfaces::{
    UPowerClientService, LogindClientService, NetworkManagerClientService,
    SecretsServiceClientService, PolicyKitClientService, FreedesktopNotificationsServer,
    // Re-export der Service-Traits wäre hier besser als konkrete Typen, falls Traits existieren
};
pub use audio_management::{PipeWireClientService /* oder Trait */, AudioEvent};
pub use mcp_client::{SystemMcpService, McpClientSystemEvent, McpServerConfig};
// ... usw.

// Initialisierungsfunktion für die gesamte Systemschicht
// pub async fn initialize_system_layer(
//     core_services: Arc<CoreServices>, // Hypothetische Sammlung von Kernschicht-Services
//     domain_services: Arc<DomainServices>, // Hypothetische Sammlung von Domänenschicht-Services
//     display_handle: DisplayHandle, // Vom Backend (DRM, Winit)
//     loop_handle: LoopHandle<'static, DesktopState>, // Vom Backend
// ) -> Result<SystemServices, SystemInitializationError> {
//
//     event_bridge::initialize_global_system_event_bridge(1024);
//     let event_bridge = event_bridge::global_system_event_bridge();
//
//     // DesktopState (Compositor-Herzstück)
//     let desktop_state = Arc::new(Mutex::new(DesktopState::new(loop_handle.clone(), display_handle.clone(), domain_services.window_policy_service.clone(), ...)));
//
//     // Input-System initialisieren und in calloop registrieren
//     // let libinput_backend = input::libinput_handler::init_libinput_backend(&loop_handle, session_interface).await?;
//     // input::libinput_handler::register_libinput_source(&loop_handle, libinput_backend, "seat0".to_string(), desktop_state.clone())?;
//     // input::seat_manager::create_seat(&mut desktop_state.lock().unwrap(), &display_handle, "seat0".to_string())?;
//
//     // D-Bus Clients initialisieren
//     // let upower_client = Arc::new(UPowerClientService::new(event_bridge.publisher_for_upower_events()).await?);
//     // upower_client.initialize_and_listen().await?;
//     // ... für andere D-Bus Clients ...
//
//     // PipeWire Client initialisieren
//     // let audio_service = Arc::new(PipeWireClientService::new(event_bridge.publisher_for_audio_events()).await?);
//
//     // MCP Client initialisieren
//     // let mcp_connection_manager = Arc::new(McpConnectionManager::new(secrets_service_client, event_bridge.publisher_for_mcp_events()));
//     // let mcp_service = Arc::new(DefaultSystemMcpService::new(mcp_connection_manager));
//     // mcp_service.configure_servers(domain_services.global_settings.mcp_server_configs).await?;
//
//     // Window Mechanics (ist oft eng mit DesktopState oder als Service)
//     // let window_mechanics_service = Arc::new(DefaultWindowMechanicsService::new(desktop_state.clone(), domain_services.window_policy_service.clone()));
//
//     // Power Management Service
//     // let power_management_dpms_control = desktop_state.clone(); // DesktopState implementiert PowerManagementControl
//     // let power_service = Arc::new(PowerManagementService::new(domain_services.settings_service, logind_client, power_management_dpms_control, ...));
//     // tokio::spawn(async move { power_service.run().await; });
//
//     // Alle Wayland Globals erstellen (nachdem alle States in DesktopState initialisiert sind)
//     // compositor::core::create_all_wayland_globals(&mut desktop_state.lock().unwrap(), &display_handle)?;
//
//     // D-Bus Notifications Server starten (wenn NovaDE ihn bereitstellt)
//     // tokio::spawn(async move {
//     //    dbus_interfaces::notifications_server::run_notifications_server(domain_services.notification_service).await;
//     // });
//
//     // SystemServices struct zurückgeben, das Handles zu den wichtigsten System-Services enthält
//     // Ok(SystemServices { desktop_state_handle: desktop_state, ... })
// }
```

Mit diesen detaillierten Plänen für die Module 5 bis 8 ist die Spezifikation der Systemschicht nun vollständig. Die Implementierung erfordert sorgfältige Beachtung der Asynchronität, der Inter-Prozess-Kommunikation und der Integration mit den Domänen- und Kernschichten. Die Testbarkeit bleibt eine Herausforderung und erfordert umfangreiches Mocking oder dedizierte Testumgebungen.